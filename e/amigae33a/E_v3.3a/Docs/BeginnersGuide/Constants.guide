@database beginner.guide 

@Master beginner 

@Width 75 


This is the AmigaGuide® file beginner.guide, produced by Makeinfo-1.55 from 
the input file beginner.


@NODE "main" "Constants"
@Next "Types.guide/main" 
@Prev "Procedures.guide/main" 
@Toc "Contents.guide/main" 

Constants
*********

   A @{fg shine }constant@{fg text } is a value that does not change.  A (literal) number like
121 is a good example of a constant--its value is always 121.  We've
already met another kind of constant: string constants (see @{"Strings" Link "Introduction.guide/Strings" }).  As
you can doubtless tell, constants are pretty important things.


 @{" Numeric Constants " Link "Numeric Constants" } 
 @{" String Constants Special Character Sequences " Link "String Constants Special Character Sequences" } 
 @{" Named Constants " Link "Named Constants" } 
 @{" Enumerations " Link "Enumerations" } 
 @{" Sets " Link "Sets" } 


@ENDNODE

@NODE "Numeric Constants" "Numeric Constants"
@Next "String Constants Special Character Sequences" 
@Toc "main" 

Numeric Constants
=================

   We've met a lot of numbers in the previous examples.  Technically
speaking, these were numeric constants (constant because they don't change
value like a variable might).  They were all decimal numbers, but you can
use hexadecimal and binary numbers as well.  There's also a way of
specifying a number using characters.  To specify a hexadecimal number you
use a @{b }$@{ub } before the digits (and after the optional minus sign @{b }-@{ub } to
represent a negative value).  To specify a binary number you use a @{b }%@{ub }
instead.

   Specifying numbers using characters is more complicated, because the
base of this system is 256 (the base of decimal is ten, that of
hexadecimal is 16 and that of binary is two).  The digits are enclosed in
double-quotes (the " character), and there can be at most four digits.
Each digit is a character representing its ASCII value.  Therefore, the
character @{b }A@{ub } represents 65 and the character @{b }0@{ub } (zero) represents 48.  This
upshot of this is that character @{b }A@{ub } has ASCII value @{b }"A"@{ub } in E, and @{b }"0z"@{ub }
represents ("0" * 256) + "z" = (48 * 256) + 122 = 12,410.  However, you
probably don't need to worry about anything other than the single
character case, which gives you the ASCII value of the character.

   The following table shows the decimal value of several numeric
constants.  Notice that you can use upper- or lower-case letters for the
hexadecimal constants.  Obviously the case of characters is significant
for character numbers.

      @{i }Number@{ui }  @{i }Decimal value@{ui }
     ----------------------
         21          21
       -143        -143
        $1a          26
       -$B1        -177
      %1110          14
     -%1010         -10
        "z"         122
       "Je"      19,045
       -"A"         -65


@ENDNODE

@NODE "String Constants Special Character Sequences" "String Constants Special Character Sequences"
@Next "Named Constants" 
@Prev "Numeric Constants" 
@Toc "main" 

String Constants: Special Character Sequences
=============================================

   We have seen that in a string the character sequence @{b }\\n@{ub } means a
linefeed (see @{"Strings" Link "Introduction.guide/Strings" }).  There are several other similar such special
character sequences which represent useful characters that can't be typed
in a string.  The following table shows all these sequences.  Note that
there are some other similar sequences which are used to control
formatting with built-in procedures like @{b }WriteF@{ub }.  These are listed where
@{b }WriteF@{ub } and similar procedures are described (see
@{"Input and output functions" Link "BuiltIns.guide/Input and output functions" }).

     @{i }Sequence@{ui }          @{i }Meaning@{ui }
     --------------------------------------
        \\0     A null (ASCII zero)
        \\a     An apostrophe '
        \\b     A carriage return (ASCII 13)
        \\e     An escape (ASCII 27)
        \\n     A linefeed (ASCII 10)
        \\q     A double quote (ASCII 34)
        \\t     A tab (ASCII 9)
        \\\\     A backslash \\

An apostrophe can also be produced by typing two apostrophes in a row in a
string.  It's best to use this only in the middle of a string, where it's
nice and obvious:

       WriteF('Here\\as an apostrophe.\\n')       /* Using \\a */
     
       WriteF('Here''s another apostrophe.\\n')  /* Using '' */


@ENDNODE

@NODE "Named Constants" "Named Constants"
@Next "Enumerations" 
@Prev "String Constants Special Character Sequences" 
@Toc "main" 

Named Constants
===============

   It is often nice to be able to give names to certain constants.  For
instance, as we saw earlier, the truth value @{b }TRUE@{ub } actually represents the
value -1, and @{b }FALSE@{ub } represents zero (see @{"Logic and comparison" Link "Introduction.guide/Logic and comparison" }).  These are
our first examples of named constants.  To define your own you use the
@{b }CONST@{ub } keyword as follows:

     CONST ONE=1, LINEFEED=10, BIG_NUM=999999

This has defined the constant @{b }ONE@{ub } to represent one, @{b }LINEFEED@{ub } ten and
@{b }BIG_NUM@{ub } 999,999.  Named constants must begin with two uppercase letters,
as mentioned before (see @{"Identifiers" Link "Format.guide/Identifiers" }).

   You can use previously defined constants to give the value of a new
constant, but in this case the definitions must occur on different @{b }CONST@{ub }
lines.

     CONST ZERO=0
     CONST ONE=ZERO+1
     CONST TWO=ONE+1

The expression used to define the value of a constant can use only simple
operators (no function calls) and constants.


@ENDNODE

@NODE "Enumerations" "Enumerations"
@Next "Sets" 
@Prev "Named Constants" 
@Toc "main" 

Enumerations
============

   Often you want to define a whole lot of constants and you just want
them all to have a different value so you can tell them apart easily.  For
instance, if you wanted to define some constants to represent some famous
cities and you only needed to know how to distinguish one from another
then you could use an @{fg shine }enumeration@{fg text } like this:

     ENUM LONDON, MOSCOW, NEW_YORK, PARIS, ROME, TOKYO

The @{b }ENUM@{ub } keyword begins the definitions (like the @{b }CONST@{ub } keyword does for
an ordinary constant definition).  The actual values of the constants
start at zero and stretch up to five.  In fact, this is exactly the same
as writing:

     CONST LONDON=0, MOSCOW=1, NEW_YORK=2, PARIS=3, ROME=4, TOKYO=5

   The enumeration does not have to start at zero, though.  You can change
the starting value at any point by specifying a value for an enumerated
constant.  For example, the following constant definitions are equivalent:

     ENUM APPLE, ORANGE, CAT=55, DOG, GOLDFISH, FRED=-2,
          BARNEY, WILMA, BETTY
     
     CONST APPLE=0, ORANGE=1, CAT=55, DOG=56, GOLDFISH=57,
           FRED=-2, BARNEY=-1, WILMA=0, BETTY=1


@ENDNODE

@NODE "Sets" "Sets"
@Prev "Enumerations" 
@Toc "main" 

Sets
====

   Yet another kind of constant definition is the @{fg shine }set@{fg text } definition.  This
useful for defining flag sets, i.e., a number of options each of which can
be on or off.  The definition is like a simple enumeration, but using the
@{b }SET@{ub } keyword and this time the values start at one and increase as powers
of two (so the next value is two, the next is four, the next eight, and so
on).  Therefore, the following definitions are equivalent:

     SET ENGLISH, FRENCH, GERMAN, JAPANESE, RUSSIAN
     
     CONST ENGLISH=1, FRENCH=2, GERMAN=4, JAPANESE=8, RUSSIAN=16

However, the significance of the values it is best shown by using binary
constants:

     CONST ENGLISH=%00001, FRENCH=%00010, GERMAN=%00100,
           JAPANESE=%01000, RUSSIAN=%10000

If a person speaks just English then we can use the constant @{b }ENGLISH@{ub }.  If
they also spoke Japanese then to represent this with a single value we'd
normally need a new constant (something like @{b }ENG_JAP@{ub }).  In fact, we'd
probably need a constant for each combination of languages a person might
know.  However, with the set definition we can @{b }OR@{ub } the @{b }ENGLISH@{ub } and @{b }JAPANESE@{ub }
values together to get a new value, @{b }%01001@{ub }, and this represents a set
containing both @{b }ENGLISH@{ub } and @{b }JAPANESE@{ub }.  On the other hand, to find out if
someone speaks French we would @{b }AND@{ub } the value for the languages they know
with @{b }%00010@{ub } (or the constant @{b }FRENCH@{ub }).  (As you might have guessed, @{b }AND@{ub } and
@{b }OR@{ub } are really bit-wise operators, not simply logical operators.  See
@{"Bitwise AND and OR" Link "MoreExpressions.guide/Bitwise AND and OR" }.)

   Consider this program fragment:

       speak:=GERMAN OR ENGLISH OR RUSSIAN  /* Speak any of these */
       IF speak AND JAPANESE
         WriteF('Can speak in Japanese\\n')
       ELSE
         WriteF('Unable to speak in Japanese\\n')
       ENDIF
       IF speak AND (GERMAN OR FRENCH)
         WriteF('Can speak in German or French\\n')
       ELSE
         WriteF('Unable to speak in German or French\\n')
       ENDIF

The assignment sets @{b }speak@{ub } to show that the person can speak in German,
English or Russian.  The first @{b }IF@{ub } block tests whether the person can speak
in Japanese, and the second tests whether they can speak in German or
French.

   When using sets be careful you don't get tempted to add values instead
of @{b }OR@{ub }-ing them.  Adding two different constants from the same set is the
same as @{b }OR@{ub }-ing them, but adding the same set constant to itself isn't.
This is not the only time addition doesn't give the same answer, but it's
the most obvious.  If you to stick to using @{b }OR@{ub } you won't have a problem.


@ENDNODE

