@database UDF_OOP.guide

@AUTHOR Mauro "M&F" Fontana
@$VER:  UDF OOP guide v0.8E
@WIDTH 75

@node main "UDF module"
  
  @{" " LINK important} -- Important
  @{" " LINK udf} udf object
  @{" " LINK chunk} ck object
  @{" " LINK chunk_node} ck_node
  @{" " LINK metachunk} metack

@endnode


@node udf
@{b}   NAME@{ub}
    udf - Universal Data Format
      
@{b}   PURPOSE@{ub}
    Handles archives of data chunks.
    XPK library used automatically if required and available.
      
@{b}   DOCUMENTED ATTRIBUTES@{ub}
    None public.

@{b}   DOCUMENTED METHODS@{ub}
      
    @{"new()" LINK new}
    @{"end()" LINK end}
    @{"getversion()" LINK getversion}
    @{"getsize()" LINK getsize}
    @{"getname()" LINK getname}
    @{"gethead()" LINK gethead}
    @{"pushlevel()" LINK pushlevel}
    @{"poplevel()" LINK poplevel}
    @{"pushchunk()" LINK pushchunk}
    @{"popchunk()" LINK popchunk}
    @{"store()" LINK store}
    @{"save()" LINK save }
    @{"load()" LINK load}
    @{"findchunk()" LINK findchunk}
    @{"countchunks()" LINK countchunks}
    @{"collectchunks()" LINK collectchunks}
    @{"disposechunklist()" LINK disposechunklist}

@{b}   SEE ALSO@{ub}
    @{"chunk" LINK chunk}, @{"chunk_node" LINK chunk_node}
        
@endnode

@node new
@{b}   NAME@{ub}
    new() of @{"udf" LINK "udf"}
        
@{b}   SYNOPSIS@{ub}    
    udf.new(PTR TO CHAR)
        
    udf.new(name)
        
@{b}   FUNCTION@{ub}    
    Creates a new object and sets its name to the provided one. This is
    needed to handle any UDF correctly.
        
    The provided name must have complete path if in a different directory
    than the current program. The string is copied so it may be not remain
    valid thoughtout the program.
        
@{b}   INPUTS@{ub}      
    name:PTR TO CHAR - String name, even static.
        
@{b}   RESULT@{ub}      
    A right initialized udf object
        
@{b}   SEE ALSO@{ub}      
    end()
        
@endnode

@node end
@{b}   NAME@{ub}
    end() of @{"udf" LINK "udf"}
        
@{b}   SYNOPSIS@{ub}
    udf.end()
        
@{b}   FUNCTION@{ub}
    Dispose of the udf objects completely. All internal allocated memory is
    freed automatically.
        
@{b}   INPUTS@{ub}
    none
        
@{b}   RESULT@{ub}
    none
        
@{b}   SEE ALSO@{ub}
        
        
@endnode

@node getversion
@{b}   NAME@{ub}
    getversion() of @{"udf" LINK "udf"}
        
@{b}   SYNOPSIS@{ub}
    LONG, LONG := udf.getversion()
    
    version, revision := udf.getversion()
        
@{b}   FUNCTION@{ub}
    Returns the version and revision numbers of the udf object.
        
@{b}   INPUTS@{ub}
    none
        
@{b}   RESULT@{ub}
    Two return values:
    the first id the version number
    the second is the reevision number
        
@{b}   SEE ALSO@{ub}
    getsize(), gethead()
        
@endnode

@node getsize
@{b}   NAME@{ub}
    getsize() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    LONG := udf.getsize()
      
    size := udf.getsize()
      
@{b}   FUNCTION@{ub}
    Returns the actual size of UDF archive. This size is different from the
    total file size as the file header is not considered.
      
@{b}   INPUTS@{ub}
    none
      
@{b}   RESULT@{ub}
    Size of the loaded UDF achive.
      
@{b}   SEE ALSO@{ub}
    getversion(), gethead()
        
@endnode

@node getname
@{b}   NAME@{ub}
      getname() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO CHAR := udf.getname()
      
    name := udf.getname()
      
@{b}   FUNCTION@{ub}    
    Returns a pointer to the name string. This string must be considered
    read only!
      
@{b}   INPUTS@{ub}
    none
      
@{b}   RESULT@{ub}
    String pointer.
      
@{b}   SEE ALSO@{ub}
    getversion(), getsize()
        
@endnode

@node gethead
@{b}   NAME@{ub}
    gethead() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO ck := udf.gethead()
      
    ck := udf.gethead()
      
@{b}   FUNCTION@{ub}
    Returns the head of the chunk tree.
      
@{b}   INPUTS@{ub}
    none
      
@{b}   RESULT@{ub}
    Pointer to the higest level chunk.
      
@{b}   SEE ALSO@{ub}
        
@endnode

@node pushlevel
@{b}   NAME@{ub}
    pushlevel() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO ck := udf.pushlevel(PTR TO tagitem)
      
    ck := udf.pushlevel(taglist)
      
@{b}   FUNCTION@{ub}  
    Creates a new level for the current chunk. Returns the chunk at the
    start of this new level.
      
@{b}   INPUTS@{ub}
    taglist - a list of tagitem:
    
      CK_ID: the type of the chunk. User definable without limitations.
             See the guide to know about the available ID and how to
             create custom ones.
    
      CK_NUMBER: user definable number that can be used to distinguish
                 between chunks with the same ID.
      
      CK_SIZE: the size of the chunk buffer. If the provided value is
               different to SIZE_UNKNOWN then the buffer size is fixed.
               If SIZE_UNKNOWN is set then the buffer size will be
               dynamic, that is it will expand as needed.
                 
      CK_MASK: the kind of modification to automatically apply to the
               chunk buffer before saving it. Allowed values are:
                 
        MASK_NONE: Nothing (default)
        MASK_XOR : Encrypt with XOR technique
        MASK_SWAP: Encrypt by swapping hi/lo part of longs
        MASK_FAST: A fast algorythm that includes some of the 
                   previous methods
        XPK_COMPRESSION_MODE: Use XPK library to compress chunk. You
                              have to specify also the following tags:
   
          CK_XPK_METHOD: set it to a string pointer containing the 4 
                         letter name of the XPK method
              
          CK_XPK_MODE: set it to the efficiency value for the provided 
                       method. Default value is 50 if not supplied.
   
        Up to now you cannot use custom password for encryption. An
        internal general password is used when needed.
      
@{b}   RESULT@{ub}
    A pointer to a new created chunk object
      
@{b}   SEE ALSO@{ub}
    @{"ck" LINK chunk}, poplevel(), pushchunk(), popchunk()
        
@endnode

@node poplevel
@{b}   NAME@{ub}
    poplevel() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO ck := udf.poplevel()
      
    ck := udf.poplevel()
      
@{b}   FUNCTION@{ub}
    End this level and return to the previous one. Returns the pointer of
    the parent chunk.
      
@{b}   INPUTS@{ub}
    none
      
@{b}   RESULT@{ub}
    Returns a pointer to chunk object.
      
@{b}   SEE ALSO@{ub}
    @{"ck" LINK chunk}, pushlevel(), pushchunk(), popchunk()
        
@endnode

@node pushchunk
@{b}   NAME@{ub}  
   pushchunk() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}    
   PTR TO ck := udf.pushchunk(PTR TO tagitem)
      
   ck := udf.pushchunk(taglist)
      
@{b}   FUNCTION@{ub}    
   Creates a new chunk on thee same level as the current one. See
   pushlevel() to know the allowed tagitems.
      
@{b}   INPUTS@{ub}    
   taglist - a list of tagitem as for pushlevel()
      
@{b}   RESULT@{ub}
   A pointer to a new created chunk object.
      
@{b}   SEE ALSO@{ub}    
   @{"ck" LINK chunk}, pushlevel(), poplevel(), popchunk()
        
@endnode

@node popchunk
@{b}   NAME@{ub}
    popchunk() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO ck := udf.popchunk()

    ck := udf.popchunk()
      
@{b}   FUNCTION@{ub}
    Stop modifing the current chunk, freezing it, and return to the
    previous one. The returned pointer cannot be used to furtherly modify
    the old chunk. You can only use it to add new chunks.
    
@{b} INPUTS@{ub}
    nonw
      
@{b}   RESULT@{ub}
    Pointer to an already existing and "frozen" chunk
      
@{b}   SEE ALSO@{ub}
    @{"ck" LINK chunk}, pushlevel(), poplevel(), pushchunk()
        
@endnode

@node store
@{b}   NAME@{ub}
    store() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    LONG, LONG := udf.store(PTR, LONG, LONG)
      
    size, err := udf.store(buffer, length=0, minalloc=0)
    
@{b}   FUNCTION@{ub} 
    Copy the provided buffer into the chunk data buffer. Returns two
    values. size is the number of copied bytes which usually should always
    be the same as length. Otherwise an negative value for error is
    returned as well.
      
@{b}   INPUTS@{ub}
    buffer: PTR TO a data buffer
    length: how many bytes have to be copied into the chunk data buffer.
            If it is left zero the buffer is treated as a normal string
            which is terminated with a zero value (ASCII 0).
    minalloc: provides a size for the allocation of dynamic buffer. A
    resonable value is already set as default, but for particular
    problems this may be useful.
      
@{b}   RESULT@{ub}
    size: the number of copied bytes that have been copied in to the
          chunk data buffer.
    err:  if not all the bytes could be copied then an error is reportd
          as well:
          -5  : the fixed sized buffer is full
          -10 : the dynamic sized buffer could not be enlarged (usually
                due to out of memory problems)
      
@{b}   SEE ALSO@{ub}
    ck.store()
        
@endnode

@node save
@{b}   NAME@{ub}
    save() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    LONG := udf.save()
    
    err := udf.safe()
      
@{b}   FUNCTION@{ub}
    Save the current tree in a file. Filename and path are those stated
    when creating thee udf object throguh new() function.
      
@{b}   INPUTS@{ub}
    none
      
@{b}   RESULT@{ub}
    err: 0 all ok
         -10 an error occured while tring to open the file for saving
          (file may be exclusively locked or write protected).
      
@{b}   SEE ALSO@{ub}
    new(), load()
        
@endnode

@node load
@{b}   NAME@{ub}
    load() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    LONG := udf.load()
      
    err := udf.load()
      
@{b}   FUNCTION@{ub}
    Load a previously saved UDF archive. The hierarchical tree is
    rebuilt.
      
@{b}   INPUTS@{ub}
    none
    
@{b}   RESULT@{ub}
    err: 0 all was ok
         -5 the file is not an UDF archive
         -10 the file could not be locked (it may not exist)
         -20 the UDF file is corrupted
    
@{b}   SEE ALSO@{ub}
    new(), save()
    
@endnode

@node findchunk
@{b}   NAME@{ub}
    findchunk() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO ck := udf.findchunk(PTR TO tagitem, PTR TO ck, LONG)
      
    ck := udf.findchunk(taglist, startck=NIL, yet=FALSE)
       FUNCTION@{ub} 
    
    Scans the chunk tree, starting from the provided chunk, to look for the
    first chunk satisfing the supplied criteria. If startck is left NIL,
    then the scan starts from the beginning of the tree. The taglist
    contains the information that have to be matched to choose the chunk to
    be returned. If yet is set to TRUE, then the passed chunk is not
    checked. This is useful if the current chunk has already been returnd
    by a previous findchunk() call.
    
@{b}   INPUTS@{ub}
    taglist - Allowed tags:
      CK_ID: look for a chunk with the selected ID
      CK_NUMBER: look for a chunk with this number
      CK_SIZE: the wanted chunk must have this size
      CK_NUMSUBCK: we want a chunk with this number of subchunks
      CK_MASK: we are looking for a chunk which has this kind of mask
      
      All the provided tags have to be matched to make a chunk the
      wanted chunk.
      
    startck - optional pointer to a chunk where starting the search from.
    
    yet - optional boolean value that indicates if the passed starting chunk
         has already been checked.
    
@{b}   RESULT@{ub}
    Returns a PTR to a chunk satisfing all the requires or NIL if none is
    found.
      
@{b}   SEE ALSO@{ub}
    collectchunks()
    
@endnode

@node countchunks
@{b}   NAME@{ub}
    countchunk() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    LONG := udf.countchunks(PTR TO ck)
      
    number := udf.countchunks(startck=NIL)
      
@{b} FUNCTION@{ub} 
    Counts the chunks starting from the level of the provided one. The
    count is performed only on the selected level and those below. If
    startck is left NIL then the count starts for the beginning of the
    tree.
      
@{b}   INPUTS@{ub}
    startck - ptr to a chunk to use as the starting level.
    
@{b}   RESULT@{ub}
    The number of counted chunks.
    
@{b}   SEE ALSO@{ub}
    
@endnode

@node collectchunks
@{b}   NAME@{ub}
    collectchunks() of @{"udf" LINK "udf"}
    
@{b}   SYNOPSIS@{ub}
    lh := udf.collectchunks(PTR TO tagitem, PTR TO ck, LONG)
    
    lh := udf.collectchunk(taglist, startck=NIL, yet=FALSE)
      
@{b}   FUNCTION@{ub}
    Collect the chunk satisfing the supplied criteria in a linked list of
    chunk_nodes.
    
@{b}   INPUTS@{ub}
    taglist - see findchunk()
    startck - a pointer to a chunks to be used as starting level
    yet - an optional boolean value that indicates if the passed starting 
          chunk has already been checked.
    
@{b}   RESULT@{ub}
    A linked list of chunk_nodes. This is an normal double linked exec
    list.
    
@{b}   SEE ALSO@{ub}
    chunk_node, findchunk(), disposechunklist()
    
@endnode

@node disposechunklist
@{b}   NAME@{ub}
      disposechunklist() of @{"udf" LINK "udf"}
      
@{b}   SYNOPSIS@{ub}
    udf.disposechunklist(PTR TO lh)
    
@{b}   FUNCTION@{ub}
    Dispose list of chunk nodes returned by collectchunks().
    
@{b}   INPUTS@{ub}
    none
    
@{b}   RESULT@{ub}
    none
    
@{b}   NOTE@{ub}
    Please always use this function to dispose of the collectchunks()
    returned list to be compatible with any future enhancement/change.
    
@{b}   SEE ALSO@{ub}
    ck_node, collectchunks()
    
@endnode


@node chunk

@{b}   NAME@{ub}
    ck - udf chunk object
    
@{b}   PURPOSE@{ub}
    Base objects making up UDF archives/trees
    
@{b}   DOCUMENTED ATTRIBUTES@{ub}
    succ - pointer to eventual successive chunk object
    pred - pointer to eventual preeceeding chunk object
    
    Note: the object is linked in a standard exec list with header.
    
@{b}   DOCUMENTED METHODS@{ub}
    
    @{"getid()" LINK ck_getid}
    @{"getnumber()" LINK ck_getnumber}
    @{"getsize()" LINK ck_getsize}
    @{"getdatabuffer()" LINK ck_getdatabuffer}
    @{"getnumsubck()" LINK ck_getnumsubck}
    @{"getmask()" LINK ck_getmask}
    @{"getsublist()" LINK ck_getsublist}
    @{"getmetachunklist()" LINK ck_getmetachunklist}
    @{"store()" LINK ck_store}
    @{"findmeta()" LINK ck_findmeta}
    @{"addmeta()" LINK ck_addmeta}
    
@{b}   SEE ALSO@{ub}
    @{"metack" LINK metachunk}
    
@endnode


@node ck_getid getid
@{b}   NAME@{ub}
    getid() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.getid()
    
@{b}   FUNCTION@{ub}
    Returns th ID of th chunk.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    The chunk ID.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getnumber getnumber
@{b}   NAME@{ub}
    getnumber() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.getnumber()
    
@{b}   FUNCTION@{ub}
    Returns the use defined number value of the chunk.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    The number field of the chunk.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getsize getsize
@{b}   NAME@{ub}
    getsize() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.getsize()
    
@{b}   FUNCTION@{ub}
    Returns the size of the chunk data buffer only.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    Th size of the chunk datta buffer.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getdatabuffer getdatabuffer
@{b}   NAME@{ub}
    getdatabuffer() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO LONG := ck.getdatabuffer()
    
@{b}   FUNCTION@{ub}
    Returns a pointer to the chunk data buffer. This is the only way to get
    the pointer to the data of the chunk. Note that the data is READ ONLY!
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    A pointer to the data. READ ONLY.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getnumsubck getnumsubck
@{b}   NAME@{ub}
    getnumsubck() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.getnumsubck()
    
@{b}   FUNCTION@{ub}
    Returns he number of subchunks attached to the current chunk.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    THe numbeer of subchunks of this chunk.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getmask getmask
@{b}   NAME@{ub}
    getmask() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.getmask()
    
@{b}   FUNCTION@{ub}
    Returns the mask field of the chunk. Should not have any meaning for
    the user as all the modification of the data are done internally in an
    automatic way. However may be useful as a chunk can be looked for also
    by its mask field.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    The mask bitfield of the chunk.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getsublist getsublist
@{b}   NAME@{ub}
    getsublist() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    lh  := ck.getsublist()
    
@{b}   FUNCTION@{ub}
    Gets the header of the subchunk list. This is a normal exec list, which
    should never be modified! You are allowed to access subchunk from here,
    but they are READ ONLY. No parameters should be passed. This is the
    only documentedd way to use this function. You have been warned.
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    A header of a list of chunk.
    
@{b}   NOTE@{ub}
    May be made private in future.
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node ck_getmetachunklist getmetachunklist
@{b}   NAME@{ub}
    getmetachunklist() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    lh := ck.getmetachunklist()
    
@{b}   FUNCTION@{ub}
    Gets the headder of the metachunk list. This is a normal exec list,
    which should never be modified! You ar allowed to access metachunks
    from here, but they are READ ONLY!
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    The header of metachunk list.
    
@{b}   NOTE@{ub}
    May be made  private in future.
    
    
@{b}   SEE ALSO@{ub}
    metack
    
@endnode

@node ck_store store
@{b}   NAME@{ub}
    store() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    LONG := ck.store(PTR TO tagitem)
    
    err := ck.store(taglist)
    
@{b}   FUNCTION@{ub}
    Copy a buffer into the chunk data buffer. See @{"udf.store()" LINK store}
    
@{b}   INPUTS@{ub}
    None.
    
@{b}   RESULT@{ub}
    
    
@{b}   SEE ALSO@{ub}
    
    
@endnode

@node c_addmeta addmeta
@{b}   NAME@{ub}
    addmeta() of @{"ck" LINK "chunk"}
    
@{b}   SYNOPSIS@{ub}
    LONG := ck.addmeta(PTR TO tagitem)
    
    err := ck.addmeta(taglist)
    
@{b}   FUNCTION@{ub}
    Create a new metachunk and link it to the current chunk metachunk list.
    
@{b}   INPUTS@{ub}
    taglist - Allowed tags are:
      
      CK_ID: the same as for udf.pushlevel() but only the lower 16 bits are
             stored. If you follow the rules for custom ID then everything
             should work without problems also for metachunks.
      
      CK_NUMBER: a 16 bit number  dec 0-65535 or hex 0-$FFFF
      
      CK_SIZE: the size of the metachunk buffer. You cannot state
      SIZE_UNKNOWN. The supplied size is rounded to the greater multiple of
      4.
      
      CK_BUFFER: the buffer from where the data have to be copied into the
      metachunk data buffer.
      
@{b}   RESULT@{ub}
    err: 0 all was ok
         -10 the metachunk could not be created.
    
@{b}   SEE ALSO@{ub}
    metack, getmetachunklist()
    
@endnode

@node ck_findmeta findmeta
@{b}   NAME@{ub}
    findmeta() of @{"ck" LINK "chunk"}
      
@{b}   SYNOPSIS@{ub}
    PTR TO metack := ck.findmeta(PTR TO tagitem)
    
    metack := ck.findmeta(taglist)
    
@{b}   FUNCTION@{ub}
    Look for a particular metachunk belonging to the current chunk.
    
@{b}   INPUTS@{ub}
    taglist - Allowe dtags:
    
      CK_ID: the ID to match
      CK_NUMBER: the used defined number to match
    
      If both are present the the eventual returned metachunk satisfies
      both request (AND operation).
    
@{b}   RESULT@{ub}
    A pointer to a metachunk matching all the specified requests, or NIL if
    none is found.
    
@{b}   SEE ALSO@{ub}
    metack, getmetachunklist()
    
@endnode



@node chunk_node

@{b}   NAME@{ub}
    ck_node - chunk node object
    
@{b}   PURPOSE@{ub}
    Used to return a list of pointers to chunk.
    
@{b}   DOCUMENTED ATTRIBUTES@{ub}
    None.
    
@{b}   DOCUMENTED METHODS@{ub}
    None.

@{b}   NOTE@{ub}
    This is handled internally. You just have to use its chunk field to get
    a pointer to the requested chunk. Never modify the list where this is
    linked.

@{b}   SEE ALSO@{ub}
    @{"udf" LINK udf}, @{"ck" LINK chunk}
    
@endnode

@node metachunk

@{b}   NAME@{ub}
    metack - udf metachunk object
    
@{b}   PURPOSE@{ub}
    Used to keep a secondary list of data buffers for miscellaneous usage.
    
@{b}   DOCUMENTED ATTRIBUTES@{ub}
    succ : successive metachunk in list
    pred : precceding meetachunk in list
    id   :INT           ID
    num  :INT           number
    size :LONG          buffer size (rounded to multiple of 4)
    data :PTR TO LONG   data buffer
    
    Note: the object is linked in a standard exec list.
    
@{b}   DOCUMENTED METHODS@{ub}
    None. Completely handled internally. All the useful fields are made
    public to simplify data access, but have to be considered READ ONLY.
    May introduce methods to have access to the fields.
    
@{b}   SEE ALSO@{ub}
    @{"ck" LINK chunk}
    
    
@endnode

@node important Important
  
                            @{b}Important@{ub}

  This module is still in development. It has been made public to
  demonstrate its features and to receive some feedback before it is
  finalized. Actually, it is in an advanced state of development which
  allows to test almost all its features while being very stable. However
  some bugs may still be there, so do not hesitate to contact me if you
  find one.

  Most important is the fact that this release does not provide the final
  API and method names. This means that any application which is written to
  work with this release has probably to be modified in future to use the
  final version of the module which may have different method names and
  more or even less public methods available.
  
  So use this module just for testing. If you are really interested in this
  project and you want to know more or you have some idea about it you can
  contact me at this e-mail address:
  
  mfontana@komodo.ing.unico.it
  
  To use this module you need to use CreativE compiler v2.10+ from Tomasz
  Wiszkowski. This is a highly enhanced version of the ec compiler v3.3
  from Wouter van Oortmerssen and it is completely backward compatible.

@endnode
