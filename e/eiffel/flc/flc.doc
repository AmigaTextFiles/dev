
                +---------------------------------------+
                |                                       |
                |                  FLC                  |
                |         Guichard Damien 1995          |
                |                                       |
                |              M A N U A L              |
                |                                       |
                +---------------------------------------+

 This guide contents :

 Chapter  1 : Introduction
 Chapter  2 : Copyright
 Chapter  3 : Portability
 Chapter  4 : Efficiency
 Chapter  5 : Language level
 Chapter  6 : Syntax
 Chapter  7 : Author
 Chapter  8 : Bibliography


Introduction
-------------

FLC  is  a  prototype  of  a portable Eiffel V3.0 compiler that would provide
support for most advanced software engineering principles to popular systems.
FLC  has  been  succesfully  retargeted for MC68020 processor and compilation
time  for  Eiffel systems containing a few classes is typically less than one
second. The aim is clearly to provide a real compiler that doesn't generate C
code.   I   strongly   believe   that  compiler  port  is  much  better  than
cross-development,  and that any serious modern software inherits most of its
power and flexibility from the underlying system facilities.

Please  note that FLC is not really an Eiffel V3.0 compiler as several eiffel
features are not supported yet.

Eiffel  language  status from book "Eiffel: The language" : The design of the
Eiffel  language  is  in the public domain. Any individual or organization is
welcome  to  build  on  the  ideas  developed  in  this  book  and to produce
compilers, interpreters, tools and libraries for Eiffel.

NICE  has the holder of the Eiffel trademark and is entitled to grant the use
of  this  name  in connection with products or tools. Only technical criteria
(as  opposed  to  commercial  considerations)  will  be used in granting such
permissions; they may include such requirement as passing a validation suite.

Nonprofit International Consortium for Eiffel P.O. Box 6884 Santa Barbara, CA
93160 USA

Currently there is no PD Eiffel compiler.

FAQs about Eiffel are available at Usenet:comp.lang.eiffel


Copyright
----------

FLC is copyright (C) 1995 GUICHARD Damien.

This  program  is freeware. You may freely distribute it as long as you don't
charge  more  than nominal fee for copying it (max 3 US$) and no deletions is
made to the original package. You may also include it to freely distributable
disks such as Fred Fish collection.

This  program  is  distributed  without  warranty  of  any kind. So I take no
responsibility  about  this  program,  its  documentation,  functionality  or
damages it may cause.

Portability
------------

How  this  goal  can  be achieved from now? The design of the compiler really
helps. Like any modern compiler it is divided into two groups:
 _ The  front-end  consists  of  the  machine-independent phases (lexical and
   syntactic analysis, type checking)
 _ The back-end consists of the machine-dependent phases (code generation)

The  intermediate  representation  of  the source code needed between the two
phases,  makes  the  compiler  compact  and  efficient,  but  require special
attention to ensure portability.

The intermediate language
 --------------------------
It is called AME (Abstract Machine for Eiffel). It has been designed to:
 _ be machine and architecture (RISC/CISC) independant for portability
 _ allow use of all addressing modes and registers of its target processor
   for efficiency
 _ not be affected by adding or removing or changing the technique of garbage
   collection

This  goal is achieved in AME firstly by making no other assumption about the
target  processor  than  the fact that it owns several registers and a stack,
secondly  all  addressing  modes  used in AME are much Eiffel-like (Attribut,
Local,Routine,Argument,Current object) and can ever be translated to the best
available addressing modes by the back-end generator.

AME registers:

  PC           program counter
  SP           stack pointer
  FR           frame register (routine block pointer)
  SR           true/false result of last logic cumputing
  R0           last function call result
  R1 .. Rn     arithmetic and logic computing

AME Addressing modes:

  Current      current object
  Attribut i   i-th current object attribute
  Argument i   i-th current routine argument
  Local i      i-th current routine's local entity
  Routine i    i-th current object's routine
  false        false constant
  true         true constant
  Void         Void constant
  i            integer i
  "s"          "s" Eiffel string
  Ri           i-th AME register
  Li           i-th global label
  .Li          i-th current routine local label

'Result'  is  a  local  entity  available via "Local 1". 'Current' is another
local  entity availabe via "Current". A function ends with "CALL Local 1, R0"
so  its  result  is  available  via "R0". SP displacement-unit is size of one
entity  of  INTEGER  type.  FR  register  points  to a stack-block containing
current routine's arguments and local entities.


AME program syntax:

Program ::= {Class}+
Class ::= {Routine_declaration} Jump_table
Jump_table ::=
  TABLE Global_label                Global_label jump table
  {LINK Global_label}               link a class routine to Global_label

Routine_declaration ::= Routine_header Routine_body
Routine_header ::=
  ROUTINE Global_label |            define a new Global_label;
                                    push FR; FR := SP
  ONCE Global_label                 define a new Global_label;
                                    push FR; FR := SP;
                                    SR:=false within first call, else
                                    SR:=true and R0:=first call value

Routine_body ::=
  LOCALS Integer                    allocate Integer local variables by
                                    pushing Integer default values
  {Instruction}
  ENDROUTINE Integer                SP := FR; pop FR;
                                    pop Integer real arguments

Instruction ::=

-- Arithmetic
  ADD Source, Register |            Register := Register + Source
  SUB Source, Register |            Register := Register - Source
  MUL Source, Register |            Register := Register * Source
  DIV Source, Register |            Register := Register // Source
  MODULO Source, Register |         Register := Register \\ Source
  NEG Register |                    Register := - Register

-- Logic
  AND Source, Register |            SR := Register := Register and Source
  OR Source, Register |             SR := Register := Register or Source
  XOR Source, Register |            SR := Register := Register xor Source
  NOT Register |                    SR := Register := not Register
  EQUAL Source, Register |          SR := Register := Register = Source
  NOTEQUAL Source, Register |       SR := Register := Register /= Source
  NOTGREATER Source, Register |     SR := Register := Register <= Source
  NOTLESS Source, Register |        SR := Register := Register >= Source
  LESSTHAN Source, Register |       SR := Register := Register < Source
  GREATERTHAN Source, Register |    SR := Register := Register > Source

-- Jumps
  JALWAYS Local_label |             always jump to Local_label
  JFALSE Local_label |              jump to Local_label if SR=false
  JTRUE Local_label |               jump to Local_label if SR=true
  LABEL Local_label |               define a new Local_label

-- Handling of entities
  ASSIGN Writable, Register |       Writable := Register
  CALL Entity, Register |           Register := Entity
  CREATE Global_label, Register |   Register := a Global_label new instance
  CURRENT Entity |                  Current := Entity 
                                    (Entity as new current object)

-- Routine call
  PUSHREGS Integer |                push all registers from R1 to Rinteger
  PUSH Source |                     push Source as real argument
  CALL Routine |                    call Routine
  POPREGS Integer                   pop all registers from Rinteger to R1

Source    ::= Entity | Integer | String | "Void" | "true" | "false" | Register
Entity    ::= Writable | Formal | "Current" | Register
Writable  ::= Attribute | Local
Routine   ::= "Routine" Integer
Attribute ::= "Attribut" Integer
Local     ::= "Local" Integer
Formal    ::= "Argument" Integer
Register  ::= "R0" | "R1" | ...
Global_label ::= "L1" | "L2" | ...
Local_label  ::= ".L1" | ".L2" | ...

Example:

class COUNTER  -- counter
feature {ANY}
  count:INTEGER;  -- Current counter value.
  start is        -- Reset to 0.
    do count := 0
    end;  -- start
  forth is        -- One step.
    do count := count + 1
    end   -- forth
end  -- class 'COUNTER'

ROUTINE         L2              -- "start" routine at L2 label
CALL            0, R1           -- R1 := 0
ASSIGN          Attribut 1, R1  -- Attribut := R1
ENDROUTINE      0               -- routine end, no argument to be poped

ROUTINE         L3              -- "forth" routine at L3 label
CALL            Attribut 1, R1  -- R1 := Attribut 1
ADD             1, R1           -- R1 := R1 +1
ASSIGN          Attribut 1, R1  -- Attribut := R1
ENDROUTINE      0               -- "forth" routine end

TABLE           L1              -- COUNTER class routines at L1 label
LINK            L2              -- Link first routine to L2 label
LINK            L3              -- Link second routine to L3 label


Efficiency
-----------

The front-end parser
---------------------
The front-end is itself divided into two passes. An Eiffel system is a cyclic
directed  rooted  graph  of class nodes connected with client and inheritance
links. Here the compilation process of OO languages (and Eiffel) is viewed as
a  graph  linearization problem. The first pass builds the class graph out of
its  linear  description  in  class files by a read algorithm, and the second
pass  linearizes  the  class  graph  by  a write algorithm turning it into an
instruction  stream.  The two stages are as efficient as possible considering
both  memory  and  time. The time and space complexity is O(s) where s is the
size of the Eiffel system to be compiled. The AME code produced by the parser
can  not be inefficient since it is only a compact notation very close to the
original  Eiffel  text.  Routine parameters are just pushed to and poped from
stack without any possible optimisation. The only efficience-related issue is
register  allocation, it is optimal too. Only n+1 registers are needed for an
expression with n parenthesis levels.

Lets   assume   a  local  declaration:  local  a,b,c,d,e:INTEGER  The  eiffel
instruction  a:=b*c+d*e  is  interpreted  as  a:=((b*c)+(d*e))  and  has  two
parenthesis levels, so it requires 2+1=3 registers to be computed.

Instruction tree     Register allocation tree          AME code generated

       :=                                              CALL   LOCAL 2, R1
       / \                                             CALL   LOCAL 3, R2
      +   a                       R1                   MUL    R2, R1
     / \                         /  \                  CALL   LOCAL 4, R2
    *   *                      R1    R2                CALL   LOCAL 5, R3
   / \ / \                    /  \  /  \               MUL    R3, R2
  b  c d  e                  R1  R2 R2  R3             ADD    R2, R1
                                                       ASSIGN LOCAL 1, R1

Peephole optimization
----------------------
A  peephole stage is added between the front-end and the back-end. It is very
simple  and performs only processor-independant optimizations. After peephole
optimisation  only  n  registers  are  required  for  an  expression  with  n
parenthesis  levels. Instructions required are nearly divided by two. This is
the  most  important optimization, any possible additionnal optimization that
could  take  place  here  (mainly  local  variable registeration according to
amount  of available registers, and constant folding) would lead to much more
modest  gain. Moreover they heavily depend on code generated by the front-end
and  this  code  can be improved or changed, AME code definition itself could
even be changed or extended for future needs.

CALL z, Rx      becomes     X   z, Ry X    Rx, Ry

So AME code for the above expression becomes  CALL  LOCAL 2, R1
                                              MUL   LOCAL 3, R1
                                              CALL  LOCAL 4, R2
                                              MUL   LOCAL 5, R2
                                              ADD   R2, R1

Thanks  to  the  nature  of the intermediate code and to the optimal register
allocation,  performance  issue  is  not  part of the front-end, actually the
front-end  can't degrade the final code performance in any way. The front-end
concentrates  on eiffel software quality whereas the back-end concentrates on
generation of performant code.

The back-end generator
-----------------------
This first FLC version includes an AME to MC68020 code translator.

AME code produced by the peephole optimizer and its MC68020 translation:

  CALL   LOCAL 2, R1     move.l  -$4(A5),d1
  MUL    LOCAL 3, R1     mul     -$8(A5,d1
  CALL   LOCAL 4, R2     move.l  -$C(A5),d2
  MUL    LOCAL 5, R2     mul     -10(A5),d2
  ADD    R2, R1          add     d2,d1
  ASSIGN LOCAL 1,R1      move.l  d1,(A5)

As  you  can see, translation is ever optimal for any target processor as AME
do  no  choice  about addressing modes. RISC versions would just require more
instructions but would be still optimal.

Language level
---------------

Already implemented:

_ Simple inheritance
_ Feature renaming
_ Feature redefinition
_ Multiple declarations
_ Creations
_ Assignments
_ if instructions
_ loop instructions
_ Multi-pointed calls
_ C-validity checking
_ Dynamic binding
_ Cyclic dependancies in client relation between classes
_ Inheritance relation mixed with client relation, adding a second level
  of possible cyclic dependancies between classes
_ Covariant feature redefinition
_ Obsolete classes
_ Frozen features
_ Client export and different view possible for each client
_ Deferred routines
_ Routine effecting mixed with routine redefinition
_ Routine undefinition
_ Re-export of inherited features
_ Creation routines
_ Obsolete routines
_ Anchored types (limited to "like current" form)
_ Short-circuit evaluation

So  FLC already  provides  some Eiffel advanced features such as no need of a
'make'  utility,  cyclic  dependancies  in  client and inheritance relations,
feature  renaming,  deferred  routines, multiple inheritance, multiple views,
covariant  feature redefinition, feature un-definition. Such features already
required  specific  algorithms never described in compilation litterature (as
benefits of Eiffel technology are almost unknown outside UNIX world).

Missing:

_ Constrainted and unconstrainted genericity
_ Once functions
_ inspect instructions
_ Exceptions
_ Assertions
_ Repeated inheritance
_ Expanded types
_ Infix/prefix functions
_ External routines
_ Reverse assignment attempt
_ Feature merging
_ S-validity checking


Syntax
-------

This  syntax  reference  is  derived  from  book  "Eiffel:  The Language". It
embodies  features  already implemented in this version. The differences with
Eiffel  3.0 syntax stress the missing features. The syntactical correction is
the  first  level  of  valididity  requirements  for  any  Eiffel  structured
document.


Class_declaration ::= [ Indexing ]
                      Class_header
                      [Obsolete]
                      [ Inheritance ]
                      [Creators]
                      [ Features ]
                      [ Invariant ]
                      end ["--" class Class_name]

Class_header ::= [Header_mark] class Class_name
Header_mark  ::= deferred
Class_name   ::= Identifier

Creators ::= creation {Creation_clause creation ..."}+
Creation_clause ::= [ Clients ] [ Header_comment ] Feature_list

Obsolete ::= obsolete Message
Message  ::= Manifest_string

Indexing     ::= indexing Index_list
Index_list   ::= {Index_clause ";" ..."}
Index_clause ::= [Index] Index_terms
Index        ::= Identifier ":"
Index_terms  ::= {Index_value "," ..."}+
Index_value  ::= Identifier | Manifest_constant

Inheritance  ::= inherit Parent_list
Parent_list ::= {Parent ";" ..."}
Parent ::= Class_name [Feature_adaptation]
Feature_adaptation ::= [Rename]
                       [New_exports]
                       [Undefine]
                       [Redefine]
                       end

Rename ::= rename Rename_list
Rename_list ::= {Rename_pair "," ..."}
Rename_pair ::= Feature_name as Feature_name

New_exports ::= export New_export_list
New_export_list ::= {New_export_item ";" ..."}
New_export_item ::= Clients Feature_set
Feature_set ::= Feature_list | all
Feature_list ::= { Feature_name "," ..."}

Undefine ::= undefine Feature_list
Redefine ::= redefine Feature_list

Features ::= feature {Feature_clause feature ..."}
Feature_clause ::= [ Clients ]
                   [Header_comment]
                   Feature_declaration_list
Feature_declaration_list ::= {Feature_declaration ";" ..."}
Header_comment ::= Comment
Feature_declaration ::= New_feature_list Declaration_body
Declaration_body ::= [Formal_arguments]
                     [ Type_mark ]
                     [Constant_or_routine]
Constant_or_routine ::= is Feature_value
Feature_value ::= Manifest_constant | Unique | Routine
New_feature_list ::= {New_feature "," ..."}+
New_feature ::= [frozen] Feature_name
Unique ::= unique

Clients ::= "{" Class_list "}"
Class_list ::= Class_name

Feature_name ::= Identifier

Routine ::= [ Obsolete ]
            [Header_comment]
            [ Precondition ]
            [ Local_declarations ]
            Routine_body
            [ Postcondition ]
            [ Rescue ]
            end ["--" Feature_name ]
Routine_body ::= Effective | Deferred
Effective ::= Internal
Internal ::= Routine_mark Compound
Routine_mark ::= do
Deferred ::= deferred
Rescue ::= rescue

Precondition ::= require [else] Assertion
Postcondition ::= ensure [then] Assertion
Variant ::= variant Integer_expression
Invariant ::= invariant Assertion
Assertion ::= {Assertion_clause ";" ..."}
Assertion_clause ::= Unlabeled_assertion_clause
Unlabeled_assertion_clause ::= Comment

Compound ::= {Instruction ";" ..."}

Instruction ::= Creation |
                Call |
                Assignment |
                Conditional |
                Loop

Creation ::= "!" [ Type ] "!" Writable [Creation_call]
Creation_call ::= "." Unqualified_call

Assignment ::= Writable ":=" Expression

Conditional ::= if Then_part_list [Else_part] end
Then_part_list ::= {Then_part elseif ..."}+
Then_part ::= Boolean_expression then Compound
Else_part ::= else Compound

Loop ::= Initialization
         [Loop_body]
         end
Initialization ::= from Compound
Loop_body ::= Exit loop Compound
Exit ::= until Boolean_expression

Call ::= [Parenthesized_qualifier] Call_chain
Parenthesized_qualifier ::= Parenthesized "."
Call_chain ::= {Unqualified_call "." ..."}+
Unqualified_call ::= Identifier [Actuals]
Actuals ::= "(" Actual_list ")"
Actual_list ::= {Actual "," ..."}
Actual ::= Expression

Integer_expression ::= Expression
Boolean_expression ::= Expression

Expression ::= Call |
               Operator_expression |
               Equality |
               Constant |
               Local |
               Read_only |
               Manifest_array

Equality ::= Expression Comparison Expression
Comparison ::= "=" | "/="

Constant ::= Manifest_constant | Constant_attribute
Constant_attribute ::= Identifier

Operator_expression ::= Parenthesized |
                        Unary_expression |
                        Binay_expression
Parenthesized ::= "(" Expression ")"
Unary_expression ::= Unary Expression
Binary_expression ::= Binary Expression

Unary ::= not | "+" | "-"
Binary ::= "+" | "-" | "*" |
           "<" | ">" | "<=" | ">=" |
           "//" | "\\" |
           and then | or else | implies |
           and | or | xor

Formal_arguments ::="(" Entity_declaration_list ")"
Local_declarations ::= local Entity_declaration_list
Entity_declaration_list ::= {Entity_declaration_group ";" ..."}
Entity_declaration_group ::= Identifier_list Type_mark
Identifier_list ::= {Identifier "," ..."}+
Type_mark ::= ":" Type

Entity ::= Writable | Read_only
Writable ::= Attribute | Local
Attribute ::= Identifier
Local ::= Identifier | Result
Read_only ::= Formal | Current
Formal ::= Identifier

Manifest_constant ::= Boolean_constant | Character_constant |
                      Integer_constant | Manifest_string

Sign ::= "+" | "-"
Integer_constant ::= [Sign] Integer
Character_constant ::= "'" Character "'"
Boolean_constant ::= true | false
Manifest_string ::= '"' Simple_string '"'

Type ::= Class_type | Anchored

Class_type ::= Class_name
Anchored ::= like Anchor
Anchor ::= Current

Comment ::= "--" {Simple_string Comment_break ..."}
Comment_break ::= New_line [Blanks_or_tabs] "--"


Author
--------

The author can be contacted at home address:

    Guichard Damien
    8 Jean GIONO street
    42100 Saint Etienne
    FRANCE

Phone number: 77.57.58.71 (FRANCE)


Bibliography
-------------

"Object-Oriented Software Construction" Bertrand Meyer. Prentice Hall
Publishing Company. ISBN 0-13-629049-3 Explains the Eiffel approach to the
design and implementation of high-quality software.

"Eiffel: The Language" Bertrand Meyer. Prentice Hall Publishing Company.
ISBN: 0-13-247925-7 (English version) ISBN 2-7296-0525-8 (French version)
Provides a complete description of the Eiffel 3.0 language.

"Reusable Software:The Base Object-Oriented Libraries" Bertrand Meyer.
Prentice Hall Publishing Company. ISBN: 0-13-245499-8 (English version)
Principles of library design and taxonomy of fundamental software structures.

"An Object-Oriented Environment:Principles and applications" Bertrand Meyer.
Prentice Hall Publishing Company. ISBN: 0-13-245507-2 (English version)
Principles that led to the ISE EiffelBench environment.

E-mail: ftp://rtfm.mit.edu/pub/usenet/comp.lang.eiffel

