@database "Eiffel.guide"
@author "Damien Guichard"
@(c) "Copyright © 1995 Damien Guichard."
@$VER: Eiffel.guide 1.0 (21/06/95)
@font Helvetica.font 18
@wordwrap

@node "Main" "Eiffel V3.0 language reference"

@{b}Eiffel V3.0 language reference@{ub}

This is Eiffel V3.0 language reference and can be used pressing @{" Browse > " BEEP 0"} button or in conjunction with AmigaGuide capabilities of an Eiffel compiler or interpreter, providing complete and precise error report.
The high formalism degree of this document is part of Eiffel's challenge of software reliability.

All Eiffel3.0-related syntax and validity are described even if not implemented in CoolDemo.
Thus this document serves as an ideal that Cool must reach.

@endnode

@node "Syntax" "Syntax of Eiffel language V3.0"

@{b}Eiffel V3.0 syntax specification@{ub}

This is Eiffel syntax reference and can be used pressing @{" Browse > " BEEP 0"} button or in conjunction with AmigaGuide capabilities of an Eiffel compiler or interpreter, providing complete and precise error report.
The syntactical correction is the first level of valididity requirements for any Eiffel structured document.
Processing tools may claim supplememtary requirements on a well-formed specimem of a construct.
Such requirements are meaningless while the construct is not built according to the following rules.


@endnode

@node "Class"

Class_declaration ::= [ @{"Indexing" LINK "Indexing"} ]
                      Class_header
                      [ @{"Formal_generics" LINK "Genericity"} ]
                      [Obsolete]
                      [ @{"Inheritance" LINK "Inheritance"} ]
                      [Creators]
                      [ @{"Features" LINK "Features"} ]
                      [ @{"Invariant" LINK "Assertions"} ]
                      @{b}end@{ub} ["--" @{b}class@{ub} Class_name]

Class_header ::= [Header_mark] @{b}class@{ub} Class_name
Header_mark  ::= @{b}deferred@{ub} | @{b}expanded@{ub}
Class_name   ::= Identifier

Creators ::= @{b}creation@{ub} {Creation_clause @{b}creation@{ub} ..."}+
Creation_clause ::= [ @{"Clients" LINK "Clients"} ] [ @{"Header_comment" LINK "Features"} ] @{"Feature_list" LINK "Inheritance"}

Obsolete ::= @{b}obsolete@{ub} Message
Message  ::= @{"Manifest_string" LINK "Manifest"}
@endnode

@node "Indexing"

Indexing     ::= @{b}indexing@{ub} Index_list
Index_list   ::= {Index_clause ";" ..."}
Index_clause ::= [Index] Index_terms
Index        ::= Identifier ":"
Index_terms  ::= {Index_value "," ..."}+
Index_value  ::= Identifier | @{"Manifest_constant" LINK "Manifest"}
@endnode

@node "Genericity"

Formal_generics ::= "[" Formal_generics_list "]"
Formal_generic_list ::= {Formal_generic "," ..."}
Formal_generic ::= Formal_generic_name [Constraint]
Formal_generic_name ::= Identifier
Constraint ::= "->" @{"Class_type" LINK "Type"}
@endnode

@node "Inheritance"

Inheritance  ::= @{b}inherit@{ub} Parent_list
Parent_list ::= {Parent ";" ..."}
Parent ::= @{"Class_type" LINK "Type"} [Feature_adaptation]
Feature_adaptation ::= [Rename]
                       [New_exports]
                       [Undefine]
                       [Redefine]
                       [Select]
                       @{b}end@{ub}

Rename ::= @{b}rename@{ub} Rename_list
Rename_list ::= {Rename_pair "," ..."}
Rename_pair ::= @{"Feature_name" LINK "Names"} @{b}as@{ub} @{"Feature_name" LINK "Names"}

New_exports ::= @{b}export@{ub} New_export_list
New_export_list ::= {New_export_item ";" ..."}
New_export_item ::= @{"Clients" LINK "Clients"} Feature_set
Feature_set ::= Feature_list | @{b}all@{ub}
Feature_list ::= { @{"Feature_name" LINK "Names"} "," ..."}

Undefine ::= @{b}undefine@{ub} Feature_list
Redefine ::= @{b}redefine@{ub} Feature_list
Select ::= @{b}select@{ub} Feature_list
@endnode

@node "Features"

Features ::= @{b}feature@{ub} {Feature_clause @{b}feature@{ub} ..."}
Feature_clause ::= [ @{"Clients" LINK "Clients"} ]
                   [Header_comment]
                   Feature_declaration_list
Feature_declaration_list ::= {Feature_declaration ";" ..."}
Header_comment ::= @{"Comment" LINK "Comment"}
Feature_declaration ::= New_feature_list Declaration_body
Declaration_body ::= [ @{"Formal_arguments" LINK "Entities"}]
                     [ @{"Type_mark" LINK "Entities"} ]
                     [Constant_or_routine]
Constant_or_routine ::= @{b}is@{ub} Feature_value
Feature_value ::= @{"Manifest_constant" LINK "Manifest"} | Unique | @{"Routine" LINK "Routine"}
New_feature_list ::= {New_feature "," ..."}+
New_feature ::= [@{b}frozen@{ub}] @{"Feature_name" LINK "Names"}
Unique ::= @{b}unique@{ub}
@endnode

@node "Clients"

Clients ::= "{" Class_list "}"
Class_list ::= { @{"Class_name" LINK "Class"} "," ..."}
@endnode

@node "Names"

Feature_name ::= Identifier | Prefix | infix
Prefix ::= @{b}prefix@{ub} '"' Prefix_operator '"'
Infix ::= @{b}infix@{ub} '"' Infix_operator '"'
Prefix_operator ::= Unary | Free_operator
Infix_operator ::= Binary | Free_operator
@endnode

@node "Routine"

Routine ::= [ @{"Obsolete" LINK "Class"} ]
            [Header_comment]
            [ @{"Precondition" LINK "Assertions"} ]
            [ @{"Local_declarations" LINK "Entities"} ]
            Routine_body
            [ @{"Postcondition" LINK "Assertions"} ]
            [Rescue]
            @{b}end@{ub} ["--" @{"Feature_name" LINK "Names"} ]
Routine_body ::= Effective | Deferred
Effective ::= Internal | External
Internal ::= Routine_mark @{"Compound" LINK "Instruction"}
Routine_mark ::= @{b}do@{ub} | @{b}once@{ub}
Deferred ::= @{b}deferred@{ub}

Rescue ::= @{b}rescue@{ub} @{"Compound" LINK "Instruction"}
@endnode

@node "Assertions"

Precondition ::= @{b}require@{ub} [@{b}else@{ub}] Assertion
Postcondition ::= @{b}ensure@{ub} [@{b}then@{ub}] Assertion
Variant ::= @{b}variant@{ub} [Tag_mark] @{"Integer_expression" LINK "Expression"}
Invariant ::= @{b}invariant@{ub} Assertion
Assertion ::= {Assertion_clause ";" ..."}
Assertion_clause ::= [Tag_mark] Unlabeled_assertion_clause
Unlabeled_assertion_clause ::= @{"Boolean_expression" LINK "Expression"} | @{"Comment" LINK "Comment"}
Tag_mark ::= Tag ":"
Tag ::= Identifier
@endnode

@node "Instruction"

Compound ::= {Instruction ";" ..."}

Instruction ::= Creation |
                @{"Call" LINK "Call"} |
                Assignment |
                Reverse_assignment_attempt |
                @{"Conditional" LINK "Conditionals"} |
                @{"Multi_branch" LINK "Conditionals"} |
                Loop |
                @{"Debug" LINK "Debug"} |
                Check |
                Retry

Creation ::= "!" [ @{"Type" LINK "Type"} ] "!" @{"Writable" LINK "Entities"} [Creation_call]
Creation_call ::= "." @{"Unqualified_call" LINK "Call"}

Assignment ::= @{"Writable" LINK "Entities"} ":=" @{"Expression" LINK "Expression"}
Reverse_assignment_attempt ::= @{"Writable" LINK "Entities"} "?=" @{"Expression" LINK "Expression"}
Check ::= @{b}check@{ub} @{"Assertion" LINK "Assertions"} @{b}end@{ub}
Retry ::= @{b}retry@{ub}
@endnode

@node "Conditionals"

Conditional ::= @{b}if@{ub} Then_part_list [Else_part] @{b}end@{ub}
Then_part_list ::= {Then_part @{b}elseif@{ub} ..."}+
Then_part ::= @{"Boolean_expression" LINK "Expression"} @{b}then@{ub} @{"Compound" LINK "Instruction"}
Else_part ::= @{b}else@{ub} @{"Compound" LINK "Instruction"}


Multi_branch ::= @{b}inspect@{ub} @{"Expression" LINK "Expression"} [When_part_list] [Else_part] @{b}end@{ub}
When_part_list ::= @{b}when@{ub} {When_part @{b}when@{ub} ..."}+
When_part ::= Choices @{b}then@{ub} @{"Compound" LINK "Instruction"}
Choices ::= {Choice "," ..."}
Choice ::= Constant | Interval
Interval ::= Integer_interval | Character_interval
Integer_interval ::= @{"Integer_constant" LINK "Manifest"} ".." @{"Integer_constant" LINK "Manifest"}
Character_interval ::= @{"Character_constant" LINK "Manifest"} ".." @{"Character_constant" LINK "Manifest"}
@endnode

@node "Loop"

Loop ::= Initialization
       [ @{"Invariant" LINK "Assertions"} ]
       [ @{"Variant" LINK "Assertions"} ]
       [Loop_body]
       @{b}end@{ub}
Initialization ::= @{b}from@{ub} @{"Compound" LINK "Instruction"}
Loop_body ::= Exit @{b}loop@{ub} @{"Compound" LINK "Instruction"}
Exit ::= @{b}until@{ub} @{"Boolean_expression" LINK "Expression"}
@endnode

@node "Debug"

Debug ::= @{b}debug@{ub} [Debug_keys] @{"Compound" LINK "Instruction"} @{b}end@{ub}
Debug_keys ::= "(" Debug_key_list ")"
Debug_key_list ::= {Debug_key "," ..."}
Debug_key ::= @{"Manifest_string" LINK "Manifest"}
@endnode


@node "Call"

Call ::= [Parenthesized_qualifier] Call_chain
Parenthesized_qualifier ::= Parenthesized "."
Call_chain ::= {Unqualified_call "." ..."}+
Unqualified_call ::= Identifier [Actuals]
Actuals ::= "(" Actual_list ")"
Actual_list ::= {Actual "," ..."}
Actual ::= @{"Expression" LINK "Expression"} | Address
Address ::= "$" Identifier
@endnode

@node "Expression"

Integer_expression ::= Expression
Boolean_expression ::= Expression

Expression ::= @{"Call" LINK "Call"} |
               @{"Operator_expression" LINK "Operators"} |
               Equality |
               Constant |
               Local |
               Read_only |
               @{"Manifest_array" LINK "Manifest"} |
               Old |
               Strip

Equality ::= Expression Comparison Expression
Comparison ::= "=" | "/="

Constant ::= @{"Manifest_constant" LINK "Manifest"} | Constant_attribute
Constant_attribute ::= Identifier

Old ::= @{b}old@{ub} Expression

Strip ::= @{b}strip@{ub} "(" Attribut_list ")"
Atrribute_list ::= {Identifier "," ..."}
@endnode

@node "Operators"

Operator_expression ::= Parenthesized |
                        Unary_expression |
                        Binay_expression
Parenthesized ::= "(" @{"Expression" LINK "Expression"} ")"
Unary_expression ::= Unary @{"Expression" LINK "Expression"}
Binary_expression ::= Binary @{"Expression" LINK "Expression"}

Unary ::= @{b}not@{ub} | "+" | "-"
Binary ::= "+" | "-" | "*" | "/" |
           "<" | ">" | "<=" | ">=" |
           "//" | "\\" | "^" |
           @{b}and@{ub} | @{b}or@{ub} | @{b}xor@{ub} |
           @{b}and then@{ub} | @{b}or else@{ub} | @{b}implies@{ub}
@endnode

@node "Entities"

Formal_arguments ::="(" Entity_declaration_list ")"
Local_declarations ::= @{b}local@{ub} Entity_declaration_list
Entity_declaration_list ::= {Entity_declaration_group ";" ..."}
Entity_declaration_group ::= Identifier_list Type_mark
Identifier_list ::= {Identifier "," ..."}+
Type_mark ::= ":" @{"Type" LINK "Type"}

Entity ::= Writable | Read_only
Writable ::= Attribute | Local
Attribute ::= Identifier
Local ::= Identifier | @{i}Result @{ui}
Read_only ::= Formal | @{i}Current @{ui}
Formal ::= Identifier
@endnode

@node "Manifest"

Manifest_array ::= "<<" Expression_list ">>"
Expression_list ::= { @{"Expression" LINK "Expression"} "," ..."}

Manifest_constant ::= Boolean_constant | Character_constant |
                      Integer_constant | Real_constant |
                      Manifest_string | Bit_constant
Sign ::= "+" | "-"
Integer_constant ::= [Sign] Integer
Character_constant ::= "'" Character "'"
Boolean_constant ::= @{b}true@{ub} | @{b}false@{ub}
Real_constant ::= [Sign] Real
Manifest_string ::= '"' Simple_string '"'
Bit_constant ::= Bit_sequence
@endnode

@node "Type"

Type ::= Class_type |
         Class_type_expanded |
         Formal_generic_name |
         Anchored |
         Bit_type
Class_type ::= @{"Class_name" LINK "Class"} [Actual_generics]
Actual_generics ::= "[" type_list "]"
Type_list ::= {Type "," ..."}
Class_type_expanded ::= @{b}expanded@{ub} Class_type
Bit_type ::= BIT Constant
Anchored ::= @{b}like@{ub} Anchor
Anchor ::= Identifier | @{i}Current @{ui}
@endnode

@node "External"

External ::= @{b}external@{ub} Language_name [External_name]
Language_name ::= @{"Manifest_string" LINK "Manifest"}
External_name ::= @{b}alias@{ub} @{"Manifest_string" LINK "Manifest"}
@endnode

@node "Comment"

Comment ::= "--" {Simple_string Comment_break ..."}
Comment_break ::= New_line [Blanks_or_tabs] "--"
@endnode

@node "Validity" "Validity constraints of Eiffel language V3.0"

@{b}Eiffel V3.0 validity specification@{ub}

This is validity reference and can be used pressing @{" Browse > " BEEP 0"} button or in conjunction with AmigaGuide capabilities of an Eiffel compiler or interpreter, providing complete and precise error report.
Validity is the second and last level of requirements for any Eiffel structured document.
Any valid construction can be processed by an Eiffel compiler or interpreter.
Validity requirements are meaningless while the construct is not built according to the syntax rules.

@endnode

@node "VAOL" "VAOL, Chapter 9.9"

An Old expression of the form @{b}old@{ub} @{i}e @{ui}, where @{i}e @{ui} is an expression of type @{i}TE @{ui}, is valid if and only if it satisfies the following two conditions:
1. It appears in a Postcondition clause of a Routine @{i}r @{ui}.
2. Transforming @{i}r @{ui} into a function with result type @{i}TE @{ui} (by adding a result type if @{i}r @{ui} is a procedure, or changing its result type if it is already a function) and replacing its entire Routine part by
     @{b}do@{ub}
       @{i}Result @{ui} := @{i}e @{ui}
     @{b}end@{ub}
 would yield a valid routine.
@endnode

@node "VAPE" "VAPE, Chapter 9.8"

A Precondition of a routine @{i}r @{ui} of a class @{i}C @{ui} is valid if and only if every feature whose final name appears in any Assertion_clause is available to every class to which @{i}r @{ui} is available.
@endnode

@node "VAVE" "VAVE, Chapter 9.14"

A variant is valid if and only if it is an expression of type @{i}INTEGER @{ui}.
@endnode

@node "VBAR" "VBAR, Chapter 2.6"

@{b}Assignment rule@{ub}

An assignment is valid if and only if its source expression conforms to its target entity.
@endnode

@node "VBGV" "VBGV, Chapter 2.7"

@{b}General Validity rule@{ub}

Every validity constraint relative to a construct is considered to include an implicit supplementary condition stating that every component of the construct statisfies every validity constraint applicable to the component.
@endnode

@node "VCCH" "VCCH, Chapter 4.8"

A Class_header appearing in the text of a class @{i}C @{ui} is valid if and only if it satisfies either of the following two conditions:
1. There is no Header_mark of the @{b}deferred@{ub} form and @{i}C @{ui} is effective.
2. There is a Header_mark of the @{b}deferred@{ub} form and @{i}C @{ui} is deferred.
@endnode

@node "VCFG" "VCFG, Chapter 4.9"

A Formal_generics part of a Class_declaration is valid if and only if every Formal_generic_name @{i}G @{ui} appearing in it satisfies the following two conditions:
1. @{i}G @{ui} is different from the name of any class in the surrounding universe.
2. @{i}G @{ui} is different from any other Formal_generic_name appearing in the same Formal_generics_part.
@endnode

@node "VCRN" "VCRN, Chapter 4.11"

If present, this comment must repeat the Class_name given at the head of the class.
@endnode

@node "VDCN" "VDCN, Chapter D.5"

A consistency condition applies to names used in an Ace: the Cluster_name must be unique for each cluster. It is valid, however, to use the same identifier in two or more of the role of Cluster_name, System_name, Class_name.
@endnode

@node "VDJR" "VDJR, Chapter 10.23"

@{b}Join rule@{ub}

It is valid for a class @{i}C @{ui} to inherit two different features as deferred under the same final name if and only if, after possible redeclaration in @{i}C @{ui}, they have identical signatures.
@endnode

@node "VDOC" "VDOC, Chapter D.11"

A Target_list may only appear in an Option paragraph, not in a Defaults paragraph. A System_tag may only appear in an Ace-level Defaults clause.
@endnode

@node "VDRD" "VDRD, Chapter 10.22"

@{b}Redeclaration rule@{ub}

Let @{i}C @{ui} be a class and @{i}g @{ui} a feature of @{i}C @{ui}. It is valid for @{i}g @{ui} to be a redeclaration of a feature @{i}f @{ui} inherited from a parent @{i}B @{ui} of @{i}C @{ui} if and only if the following conditions are satisfied:
1. No effective feature of @{i}C @{ui} other than @{i}f @{ui} and @{i}g @{ui} has the same final name as @{i}f {ui"} and @{i}g @{ui}.
2. The signature of @{i}g @{ui} conforms to the signature of @{i}f @{ui}.
3. If @{i}g @{ui} is a routine, its Precondition, if any, begins with @{b}require@{ub} @{b}else@{ub} (not
   just @{b}require@{ub}), and its Postcondition, if any, begins with 'ensure then'
   (not just @{b}ensure@{ub}).
4. If the redeclaration is a redefinition (rather than an effecting) the
   Redefine subclause of the Parent part of @{i}B @{ui} lists the final name of @{i}f @{ui} in
   its Feature_list.
5. If @{i}f @{ui} is inherited as effective, then @{i}g @{ui} is also effective.
6. If @{i}f @{ui} is an attribute, @{i}g @{ui} is an attribute,
   @{i}f @{ui} and @{i}g @{ui} are both variable and their type are both
   expanded or both non expanded.
7. If one from @{i}f @{ui} or @{i}g @{ui} is an External routine, then the other too.
@endnode

@node "VDRS" "VDRS, Chapter 10.19"

@{b}Redefine Subclause rule@{ub}

Consider a class @{i}C @{ui} with a parent @{i}B @{ui}. If a Parent part for @{i}B @{ui} in @{i}C @{ui} contains a Redefine subclause, that clause is valid if and only if every Feature_identifier @{i}fname @{ui} that it lists (in its Feature_list) satisfies the following conditions:
1. @{i}fname @{ui} is the final name in @{i}C @{ui} of a feature inherited from @{i}B @{ui}.
2. That feature was not frozen, and was not a constant attribute.
3. @{i}fname @{ui} appears only once in the Feature_list.
4. The Features part of @{i}C @{ui} contains one Feature_declaration for @{i}fname @{ui}, which is a valid redeclaration, but not an effecting, of the original feature.
@endnode

@node "VDUC" "VDUC, Chapter D.8"

The Cluster_properties part contained in a Use file may not itself contain a Use paragraph.
@endnode

@node "VDUS" "VDUS, Chapter 10.19"

@{b}Undefine Subclause rule@{ub}

Consider a class @{i}C @{ui} that inherits from a class @{i}B @{ui}. If a Parent part for @{i}B @{ui} in @{i}C @{ui} contains an Undefine subclause, that clause is valid if and only if, for every Feature_identifier @{i}fname @{ui} that it lists (in its Feature_list):
1. @{i}fname @{ui} is the final name in @{i}C @{ui} of a feature inherited from @{i}B @{ui}.
2. That feature was not frozen, and was not an attribute.
3. That feature was effective in @{i}B @{ui}.
4. @{i}fname @{ui} appears only once in the Feature_list.
@endnode

@node "VEEN" "VEEN, Chapter 17.9"

An occurence of an entity @{i}e @{ui} in text of a class @{i}C @{ui} is valid if and only if
it satisfies one of the following conditions:
1.  @{i}e @{ui} is the final name of an attribute of @{i}C @{ui}.
2A. The occurence is in a Local_declarations, Routine_boby, Postcondition or Rescue part of a Routine text for a function, and @{i}e @{ui} is the local entity @{i}Result @{ui}.
2B. The occurence is in a Local_declarations, Routine_boby or Rescue part of a Routine text for a routine @{i}r @{ui}, and the Local_declarations part for @{i}r @{ui} contains an Entity_declaration_list including @{i}e @{ui} as part of its Identifier_list.
3.  The occurence is in a Feature_declaration for a routine @{i}r @{ui}, and the Formal_arguments part for @{i}r @{ui} contains an Entity_declaration_list including @{i}e @{ui} as part of its Identifier_list.
4.  @{i}e @{ui} is Current.

@endnode

@node "VFFD" "VFFD, Chapter 5.14"

@{b}Feature declaration rule@{ub}

A Feature_declaration appearing in a class @{i}C @{ui}, and whose New_feature_list
contains one or more feature names F1,..,Fn is valid if and only if it
satisfies all of the following conditions:
1. Its Declaration_body describes a feature which, according to the rules
   of 5.11, is one of: variable attribute, constant attribute, procedure,
   function.
2. None of the Fi has the same name as another faeture introduced in @{i}C @{ui}
   (in particular Fi is not the same name as Fj for different i and j).
3. If the name of any of the Fi is the same as the final name of any
   inherited feature, the Declaration_body satisfies the Redeclaration rule.
4. If the Declaration_body describes a deferred feature, then none of the
   Fi is preceded by the keyword 'frozen'.
5. If any of the Fi is a Prefix name, the Declaration_body describes an
   attribute or a function with no argument.
6. If any of the Fi is an Infix name, the Declaration_body describes a
   function with exactly one argument.
7. If the Declaration_body describes a once function, the result type is not
   a Formal_generic_name.
@endnode

@node "VGCC" "VGCC, Chapter 18.9"

@{b}Creation Instruction rule@{ub}

Consider a Creation instruction appearing in a class @{i}X @{ui}. Let @{i}x @{ui} be the
target of the instruction and @{i}T @{ui} a type of base class @{i}C @{ui}.

The instruction is C-valid if and only if it satisfies the following
conditions:
1. @{i}T @{ui} is not a Formal_generic_name (that is to say, a formal parameter of the class where the instruction appears).
2. @{i}C @{ui} is an effective class.
3. If the Type part is present, the type that it contains (which is @{i}T @{ui}) conforms to the type of @{i}x @{ui}, and is a reference type.
4. If @{i}C @{ui} does not have a Creators part, there is no Creation_call part.
5. If @{i}C @{ui} has a Creator part, there is a Creation_call part, and the call would be A-valid if it appeared in the text of @{i}C @{ui}.
6. If case 5 holds and @{i}f @{ui} is the feature of the Creation_call, then @{i}f @{ui} is a procedure, its Routine_body is not of the @{b}once@{ub}... form, and @{i}f @{ui} is available for creation to @{i}X @{ui}.

@endnode

@node "VGCI" "VGCI, Chapter 18.10"

A Creation instruction is valid if and only if it is both C-valid and S-valid.
@endnode

@node "VGCP" "VGCP, Chapter 18.8"

@{b}Creation_clause rule@{ub}

A Creation_clause appearing in the Creators part of a class @{i}C @{ui} is valid if and only if it satisfies the following four conditions, the last three for every Feature_identifier @{i}fname @{ui} in the clause's Feature_list:
1. @{i}C @{ui} is effective.
2. @{i}fname @{ui} is the final name of a procedure of @{i}C @{ui}.
3. @{i}fname @{ui} appears only once in the Feature_list.
4. If @{i}C @{ui} is expanded, that procedure has no arguments, and no other Feature_identifier appears in the Feature_list.
@endnode

@node "VGCS" "VGCS, Chapter 18.10"

A Creation instruction is S-valid (system-valid) if and only if it satisfies
one of the following two conditions:
1. The creation type is explicit (in other words, the instruction begins with !@{i}T @{ui}!... for some type @{i}T @{ui}).
2. The creation type is implicit (in other words, the instruction begins with !!...) and every possible dynamic type @{i}T @{ui} for @{i}x @{ui}, with base class @{i}C @{ui}, satisfies conditions 1 to 6 of the Creation Instruction rule. In applying conditions 5 and 6, the feature of the call, @{i}f @{ui}, must be replaced by its version in @{i}C @{ui}.
@endnode

@node "VHAY" "VHAY, Chapter 6.15"

Wether you use the default @{i}ANY @{ui} or another one, any system will need to have a class of name @{i}ANY @{ui}. This is a constraint on any valid universe.
@endnode

@node "VHPR" "VHPR, Chapter 6.6"

@{b}Parent rule@{ub}

The Inheritance clause of a class @{i}D @{ui} is valid if and only if it meets the following two conditions:
1. In every Parent clause for a class @{i}B @{ui}, @{i}B @{ui} is not a descendant of @{i}D @{ui}.
2. If two or more Parent clauses are for classes which have a common ancestor @{i}A @{ui}, @{i}D @{ui} meets the conditions of the Repeated Inheritance Consistency constraint for @{i}A @{ui}.
@endnode

@node "VHRC" "VHRC, Chapter 6.9"

@{b}Rename Clause rule@{ub}

It is valid to use @{i}old_name @{ui} as first element of a Rename_pair,  appearing in the Rename subclause of the Parent clause for @{i}B @{ui} in a class @{i}C @{ui}, if and only if the following two conditions are satisfied:
1. @{i}old_name @{ui} is the final name of a feature of @{i}B @{ui}.
2. @{i}old_name @{ui} does not appear as the first element of any other Rename_pair in the same Rename subclause.
@endnode

@node "VIRW" "VIRW, Chapter 25.9"


An identifier is valid if and only if it is not one of the language's reserved words.
@endnode

@node "VJAR" "VJAR, Chapter 20.4"

@{b}Assignment rule@{ub}

An assignment is valid if and only if its source expression conforms to its target entity.
@endnode

@node "VJRV" "VJRV, Chapter 20.14"

@{b}Reverse Assignment Attempt rule@{ub}

A Reverse_assignment_attempt is valid if and only if the type of its target entity conforms to the type of its source expression.
@endnode

@node "VKCN" "VKCN, Chapter 21.3"

Whether a particular call is an instruction or a function depends on the nature of the feature of the call:
1. If the feature is an attribute or a function, the Call is syntactically an expression.
2. If the feature is a procedure, the Call is an instruction.

@endnode

@node "VLCP" "VLCP, Chapter 7.13"

A Clients part is valid if and only if every Class_name appearing in its Class_list is the name of a class in the surrounding universe.
@endnode

@node "VLEC" "VLEC, Chapter 7.5"

@{b}Expanded Client rule@{ub}

It is valid for a class @{i}C @{ui} to be an expanded client a class @{i}SC @{ui} if and only if @{i}SC @{ui} is not a direct or indirect expanded client of @{i}C @{ui}.
@endnode

@node "VLEL" "VLEL, Chapter 7.13"

@{b}Export List rule@{ub}

A New_exports clause appearing in class @{i}C @{ui} in a Parent clause for a parent @{i}B @{ui}, of the form

@{b}export@{ub}
  {'class list' 1"}   'feature_list' 1;
  ...
  {'class list' 'n'"} 'feature_list' 'n';

is valid if and only if (for 'i' in the interval 1..'n'):

1. At most one of the 'feature_list'i is the keyword 'all'.
2. All the other 'feature_list' 'i' are lists of final names of features of @{i}C @{ui} obtained from @{i}B @{ui}.
3. No final feature name appears twice in any such list, or apppears in more than one list.
@endnode

@node "VMCN" "VMCN, Chapter 11.11"

1. A class may not introduce two different features, both deferred or both effective, with the same name.
2. If a class introduces a feature with the same name as a feature it inherits in effective form, it must rename the inherited version.
3. If a class inherits two features as effective from different parents and they have the same name, the class must also (except under sharing for repeated inheritance) remove the name clash through renaming.
@endnode

@node "VMFN" "VMFN, Chapter 11.11"

@{b}Feature name rule@{ub}

It is valid for a class @{i}C @{ui} to introduce a feature with the Feature_identifier @{i}fname @{ui}, or to inherit a feature under the final name @{i}fname @{ui}, if and only if no other feature of @{i}C @{ui} has that same name.
@endnode

@node "VMRC" "VMRC, Chapter 11.13"

It is valid for a class @{i}D @{ui} to be a repeated descendant of a class @{i}A @{ui} if and only if @{i}D @{ui} satisfies the following two conditions for every feature @{i}f @{ui} of @{i}A @{ui}:

1. If the Repeated Inheritance rule implies that @{i}f @{ui} wil be shared in @{i}D @{ui}, then all the inherited versions of @{i}f @{ui} are the same feature.
2. If the Repeated Inheritance rule implies that @{i}f @{ui} wil be replicated in @{i}D @{ui} and @{i}f @{ui} is potencially ambiguous, then the Select subclause of exactly one of the Parent parts of @{i}D @{ui} lists the corresponding version of @{i}f @{ui}, under its final name in @{i}D @{ui}.
@endnode

@node "VMSS" "VMSS, Chapter 11.13"

@{b}Select Subclause rule@{ub}

A Select subclause appearing in the Parent part for a class @{i}B @{ui} in a class @{i}D @{ui} is valid if and only if, for every Feature_identifier @{i}fname @{ui} in its Feature_list, @{i}fname @{ui} is the final name in @{i}D @{ui} of a feature that has two or more potential versions in @{i}D @{ui}, and @{i}fname @{ui} appears only once in the Feature_list.
@endnode

@node "VNCB" "VNCB, Chapter 13.11"

The possible conformance cases involving a Bit_type are the following:
1. 'BIT N' conforms to 'BIT P' for N<=P.
2. For every type @{i}T @{ui} which is not a Bit_type, there is an integer @{i}bit_size @{ui}(t) such that @{i}T @{ui} conforms to 'BIT N' if and only if @{i}bit_size @{ui}(t)<=N. The value of @{i}bit_size @{ui}(t) is platform-dependent.

Other than implied by these rules, no type conforms directly to a Bit_type, and a Bit_type conforms directly to no type.
@endnode

@node "VNCC" "VNCC, Chapter 13.4"

@{b}General Conformance@{ub}

Let @{i}T @{ui} and @{i}V @{ui} be two types other than Bit_type. @{i}V @{ui} conforms to @{i}T @{ui} if and only if one of the following holds:
1. @{i}V @{ui} and @{i}T @{ui} are identical.
2. @{i}V @{ui} is 'NONE' and @{i}T @{ui} is a reference type.
3. @{i}V @{ui} is B[Y1,..Yn] for some generic class @{i}B @{ui}, @{i}T @{ui} is B[X1,..,Xn], and every one of the Yi conforms (recursively) to the corresponding Xi.
4. @{i}T @{ui} is a reference type and, for some type @{i}U @{ui}, @{i}V @{ui} conforms directly to @{i}U @{ui} and @{i}U @{ui} conforms (recursively) to @{i}T @{ui}.
@endnode

@node "VNCE" "VNCE, Chapter 13.10"

@{b}Direct Conformance (Expanded Types)@{ub}

Let @{i}T @{ui} be an Expanded type. Then:
1. If the base type @{i}BT @{ui} of @{i}T @{ui} is a reference type, @{i}BT @{ui} conforms directly to @{i}T @{ui} and @{i}T @{ui} conforms directly to @{i}BT @{ui}.
2. If @{i}T @{ui} is @{i}INTEGER @{ui}, if conforms directly to @{i}REAL @{ui} and @{i}DOUBLE @{ui}, and if @{i}T @{ui} is @{i}REAL @{ui} it conforms directly to @{i}DOUBLE @{ui}.

Other than implied by these cases, no type conforms directly to @{i}T @{ui}, and @{i}T @{ui} conforms directly to no type.
@endnode

@node "VNCF" "VNCF, Chapter 13.7"

@{b}Direct Conformance (Formal Generic)@{ub}

Let @{i}G @{ui} be a generic parameter of a class, which in the class may be used as a type of the Formal_generic_name category. No type conforms directly to @{i}G @{ui}. If @{i}G @{ui} is not constrained, it conforms directly to the type @{i}ANY @{ui} (based on the corresponding universal class) and to no other type. If @{i}G @{ui} is constrained by @{i}CT @{ui}, @{i}G @{ui} conforms directly to @{i}CT @{ui} and to no other type.
@endnode

@node "VNCG" "VNCG, Chapter 13.6"

@{b}Direct Conformance (Generic Substitution)@{ub}

Let @{i}BT @{ui} be a generically derived type of base type @{i}B @{ui}[@{i}X @{ui}1,...@{i}X @{ui}n] for
some n>=1, where the formal generic parameters of @{i}B @{ui} are @{i}G @{ui}1,...@{i}G @{ui}n.
Let @{i}CT @{ui} be a type of base class @{i}C @{ui} different from @{i}B @{ui}. To determine
whether @{i}CT @{ui} conforms directly to @{i}BT @{ui}, define the substitution ð as follows:
. If @{i}CT @{ui} is non-generic, ð is the identity substitution.
. If @{i}CT @{ui} is a generically derived type, of the form @{i}C @{ui}['Y'1,...'Y'm], and
  class @{i}C @{ui} is declared with formal generic paramaters 'H'1,...'H'm, then ð
  applied to any of the 'H'i (for 1<=i<=m) is 'Y'i and ð applied to any other
  element is the element itself.

Then @{i}CT @{ui} conforms directly to @{i}BT @{ui} if and only if the Inheritance clause of
@{i}C @{ui} lists @{i}B @{ui}['Z'1,...'Z'n] as one of its Parent items and, for every 'j'
such that 1<='j'<='n', applying substitution ð to 'Z'j yields @{i}X @{ui}j.
@endnode

@node "VNCH" "VNCH, Chapter 13.8"

@{b}Direct Conformance (Anchored)@{ub}

In a class @{i}C @{ui}, type @{b}like @{ub} @{i}Current @{ui} conforms directly to its base type @{i}CT @{ui}, where @{i}CT @{ui} is @{i}C @{ui} followed by its Formal_generic_list, if any, with any Constraint removed.

Type @{b}like @{ub} @{i}anchor @{ui}, where @{i}anchor @{ui} is a feature of @{i}C @{ui} or a formal argument of a routine of @{i}C @{ui}, conforms directly to the type of @{i}anchor @{ui} in @{i}C @{ui}.

An anchored type conforms directly to no type other than implied by these rules. No types conforms directly to an anchored type.
@endnode

@node "VNCN" "VNCN, Chapter 13.5"

Let @{i}CT @{ui} be a type of base class @{i}C @{ui}, and @{i}BT @{ui} be a type whose base class @{i}B @{ui} is not generic. @{i}CT @{ui} conforms directly to @{i}BT @{ui} if and only if the Inheritance clause of @{i}C @{ui} lists @{i}B @{ui} in one or more of its Parents items.
@endnode

@node "VNCS" "VNCS, Chapter 13.3"

@{b}Signature Conformance@{ub}

A signature @{i}t @{ui}=(<B1,..,Bn>,<S>) conforms to a signature 's'=(<A1,..,An>,<R>)
if and only if:
. Each of the two sequence components of @{i}t @{ui} has the same number of
  elements as the corresponding component of 's'.
. Every type in each of the two sequence components of @{i}t @{ui} conforms to
  the corresponding type in the corresponding component of 's'.
@endnode

@node "VNCX" "VNCX, Chapter 13.9"

@{b}Conformance (Expression)@{ub}

An expression @{i}v @{ui} of type @{i}VT @{ui} conforms to an expression @{i}t @{ui} of type @{i}TT @{ui} if and only if they satisfy any one of the following four conditions:
1. @{i}VT @{ui} conforms to @{i}TT @{ui}.
2. @{i}VT @{ui} is @{b}like @{ub} @{i}t @{ui} (@{i}t @{ui} in this case must be an entity).
3. @{i}VT @{ui} and @{i}TT @{ui} are both of the form @{b}like @{ub} @{i}x @{ui} for the same @{i}x @{ui}.
4. @{i}TT @{ui} is @{b}like @{ub} @{i}x @{ui} where @{i}x @{ui} is a formal argument to a routine @{i}r @{ui}, @{i}v @{ui} is an actual argument in a call to @{i}r @{ui}, and @{i}VT @{ui} conforms to the type of the actual argument corresponding to @{i}x @{ui} in the call.
@endnode

@node "VOMB" "VOMB, Chapter 14.5"

@{b}Multi_branch rule@{ub}

A Multi_branch instruction is valid if and only if the following conditions are met by its unfolded form:
1. The inspect expression is of type @{i}INTEGER @{ui} or @{i}CHARACTER @{ui}.
2. The inspect constants (the values in the various Choices parts) are constant attributes of the same type as the inspect expression.
3. Any two non-Unique inspect constants have different values.
4. Any two Unique inspect constants have different names.
5. If any inspect constant is Unique, then every other inpect constant in the instruction is either Unique or has negative or zero value.
6. All Unique inspect constants, if any, have the same class of origin (the enclosing class or a proper ancestor).
@endnode

@node "VQMC" "VQMC, Chapter 16.5"

A declaration of a feature @{i}f @{ui} introducing a manifest constant is valid if and only if the Manifest_constant @{i}m @{ui} used in the declaration matches the type @{i}T @{ui} declared for @{i}f @{ui} in one of the following ways:
. @{i}m @{ui} is a Boolean_constant and @{i}T @{ui} is @{i}BOOLEAN @{ui}.
. @{i}m @{ui} is a Character_constant and @{i}T @{ui} is @{i}CHARACTER @{ui}.
. @{i}m @{ui} is an Integer_constant and @{i}T @{ui} is @{i}INTEGER @{ui}.
. @{i}m @{ui} is a Real_constant and @{i}T @{ui} is @{i}REAL @{ui} or @{i}DOUBLE @{ui}.
. @{i}m @{ui} is a Manifest_string and @{i}T @{ui} is @{i}STRING @{ui}.
. @{i}m @{ui} is a Bit_constant and @{i}T @{ui} is a Bit_type.
@endnode

@node "VQUI" "VQUI, Chapter 16.6"

A declaration of a feature @{i}f @{ui} introducing a Unique constant is valid if and only if the type @{i}T @{ui} declared for @{i}f @{ui} is @{i}INTEGER @{ui}.
@endnode

@node "VREG" "VREG, Chapter 8.3"

Let @{i}el @{ui} be an Entity_declaration_list. Let @{i}identifiers @{ui} be the concatenation of every Identifier_list of every Entity_declaration_group in @{i}fa @{ui}. Then @{i}el @{ui} is valid if and only if no Identifier appears more than once in the list @{i}identifiers @{ui}.
@endnode

@node "VRFA" "VRFA, Chapter 8.3"

@{b}Formal Argument rule@{ub}

Let @{i}fa @{ui} be the Formal_arguments part of a routine @{i}r @{ui} in a class @{i}C @{ui}. Let @{i}formals @{ui} be the concatenation of every Identifier_list of every Entity_declaration_group in @{i}fa @{ui}. Then @{i}fa @{ui} is valid if and only if no Identifier @{i}e @{ui} appearing in @{i}formals @{ui} is the final name of a feature of @{i}C @{ui}.
@endnode

@node "VRLE" "VRLE, Chapter 8.7"

@{b}Local Entity rule@{ub}

Let @{i}ld @{ui} be the Local_declarations part of a routine @{i}r @{ui} in a class @{i}C @{ui}. Let @{i}locals @{ui} be the concatenation of every Identifier_list of every Entity_declaration_group in @{i}ld @{ui}. Then @{i}ld @{ui} is valid if and only if every Identifier @{i}e @{ui} in @{i}ld @{ui} satisfies the following two conditions:
1. No feature of @{i}C @{ui} has @{i}e @{ui} as its final name.
2. No formal argument of @{i}r @{ui} has @{i}e @{ui} as its Identifier.
@endnode

@node "VRRR" "VRRR, Chapter 8.5"

@{b}Routine rule@{ub}

A Routine part of a routine declaration is valid if and only if one of the following conditions holds:
1. Its Routine_body is an Internal body (beginning with @{b}do@{ub} or @{b}once@{ub}).
2. In the other cases (where the Routine_body is External or Deferred), there is neither a Local_declarations part nor a Rescue part.
@endnode

@node "VSCN" "VSCN, Chapter 3.5"

No two classes in a given cluster may have the same class name.
@endnode

@node "VSRC" "VSRC, Chapter 3.4"

@{b}Root class rule@{ub}

A class @{i}C @{ui} may be used as root of a system if and only if it satisfies the following two conditions:
1. @{i}C @{ui} is not generic.
2. Any creation procedure of @{i}C @{ui} has either no formal argument, or a single formal argument of type @{i}ARRAY @{ui}[@{i}STRING @{ui}].
@endnode

@node "VTAT" "VTAT, Chapter 12.15"

An anchored type of the form @{b}like@{ub} @{i}anchor @{ui} appearing in a class @{i}C @{ui} is valid if and only if one of the following holds:
1. @{i}anchor @{ui} is the final name of an attribute or function of @{i}C @{ui}, whose declared type is a non-Anchored reference type.
2. The type appears in the text of a routine @{i}r @{ui} of @{i}C @{ui}, and @{i}anchor @{ui} is a formal argument of @{i}r @{ui}, whose declared type is a non-Anchored reference type.
3. @{i}anchor @{ui} is the reserved word @{i}Current @{ui}.
@endnode

@node "VTBT" "VTBT, Chapter 12.14"

A Bit_type is valid if and only if its Constant is of type @{i}INTEGER @{ui}, and has a positive value.
@endnode

@node "VTCG" "VTCG, Chapter 12.8"

@{b}Constrained Genericity rule@{ub}

Let @{i}C @{ui} be a constrained generic class. A Class_type @{i}CT @{ui} having @{i}C @{ui} as base class is valid if and only if @{i}CT @{ui} satisfies the Unconstrained Genericity rule and, in addition:
3. For any Formal_generic parameter in the declaration of @{i}C @{ui} having a constraint of the form -> @{i}D @{ui}, the corresponding Type in the Actual_generics list of @{i}CT @{ui} conforms to @{i}D @{ui}.
@endnode

@node "VTCT" "VTCT, Chapter 12.5"

@{b}Class Type rule@{ub}

An Identifier @{i}CC @{ui} is valid as the Class_name part of a Class_type if and only if it is the name of a class in the surrounding universe.
@endnode

@node "VTEC" "VTEC, Chapter 12.12"

@{b}Expanded Type rule@{ub}

An expanded type of the form @{b}expanded @{ub} @{i}CT @{ui}, where @{i}CT @{ui} is a Class_type of base class @{i}C @{ui}, is valid if and only if it satisfies the following conditions:
1. @{i}C @{ui} is not a deferred class.
2. @{i}C @{ui} either has no creation procedure, or has only one creation procedure with no argument.
@endnode

@node "VTUG" "VTUG, Chapter 12.7"

@{b}Unconstrained Genericity rule@{ub}

Let @{i}C @{ui} be an unconstrained generic class. A Class_type @{i}CT @{ui} having @{i}C @{ui} as base class is valid if and only if it satisfies the following two conditions:
1. @{i}C @{ui} is a generic class.
2. The number of Type components in @{i}CT @{ui}'s Actual_generics list is the same as the number of Formal_generic parameters in the Formal_generic_list of @{i}C @{ui}'s declaration.
@endnode

@node "VUAR" "VUAR, Chapter 22.9"

Consider an E-valid (export-valid) call of target @{i}target @{ui} and feature name @{i}fname @{ui} appearing in a class @{i}C @{ui}. (For an Unqualified_call take @{i}target @{ui} to be @{i}Current @{ui}.) Let @{i}ST @{ui} be the type of @{i}target @{ui}, @{i}S @{ui} the base class of @{i}ST @{ui}, and @{i}sf @{ui} the feature of final name @{i}fname @{ui} in @{i}S @{ui}. Let @{i}D @{ui} be a descendant of @{i}S @{ui}, and @{i}df @{ui} the version of @{i}sf @{ui} in @{i}D @{ui}. The call is A-valid
(argument-valid) for @{i}D @{ui} if and only if it satisfies the following four
conditions:
1. The number of actual arguments is the same as the number of formal arguments
   declared for @{i}df @{ui}.
2. Every actual argument, if any, conforms to the corresponding formal
   argument of @{i}df @{ui}.
3. If @{i}target @{ui} is itself a Call, it is (recursively) argument-valid for @{i}D @{ui}.
4. If any of the actual arguments is of Address form $ 'fn', @{i}df @{ui} is an
   external routine, and 'fn' is the final name of a feature of @{i}C @{ui} which is
   not a constant attribute.
@endnode

@node "VUCS" "VUCS, Chapter 22.9"

@{b}Call rule@{ub}

Consider a single-dot call with target @{i}x @{ui}, appearing in a class @{i}C @{ui}. Let @{i}S @{ui} be the type of @{i}x @{ui}. Then:
1. The call is C-valid (class-valid) if it is E-valid (export-valid) and A-valid (argument-valid) for @{i}S @{ui}.
2. The call is S-valid (system-valid) if for any element @{i}D @{ui} of the dynamic class set of @{i}x @{ui} it is E-valid and A-valid for @{i}D @{ui}.
@endnode

@node "VUEX" "VUEX, Chapter 22.9"

A call appearing in a class @{i}C @{ui}, having @{i}fname @{ui} as the feature of the call, is export-valid for a class @{i}D @{ui} if and only if it satisfies either of the following two conditions:
1. The call is an Unqualified_call and @{i}fname @{ui} is the final name of a feature of @{i}C @{ui}.
2. The call has at least one dot, @{i}D @{ui} has a feature of name @{i}fname @{ui} which is available to @{i}C @{ui}, and the call's target is either a valid entity of @{i}C @{ui} or (recursively) a call which is export-valid for @{i}D @{ui}.
@endnode

@node "VUGV" "VUGV, Chapter 22.9"

@{b}Call rule@{ub}

A call is valid if and only if it is both C-valid and S-valid.
@endnode

@node "VWBE" "VWBE, Chapter 23.2"

A Boolean_expression is valid if and only if it is an Expression of type
@{i}BOOLEAN @{ui}.
@endnode

@node "VWEQ" "VWEQ, Chapter 23.3"

An Equality expression is valid if and only if either of its operand conforms to the other.
@endnode

@node "VWCA" "VWCA, Chapter 23.13"

A Constant_attribute in the text of a class @{i}C @{ui} is valid if and only if its Entity is the final name of a constant attribute in @{i}C @{ui}.
@endnode

@node "VWID" "VWID, Chapter 23.12"

@{b}Identifier rule@{ub}

An Identifier appearing unqualified in an expression as part of the text of a routine @{i}r @{ui} in a class @{i}C @{ui} must be the name of a feature of @{i}C @{ui}, a local entity of @{i}r @{ui}, or a formal argument of @{i}r @{ui}.
@endnode

@node "VWMA" "VWMA, Chapter 23.20"

@{b}Manifest Array rule@{ub}

A Manifest_array <<e1, e2, ...en>> is a valid expression of type @{i}ARRAY @{ui}[@{i}T @{ui}]
if and only if the type of every ei conforms to @{i}T @{ui}.
@endnode

@node "VWMS" "VWMS, Chapter 23.18"

A Manifest_string is valid if and only if it satisfies the following two conditions:
1. None of the characters of its associated Simple_string is a double quote.
2. In the extended form, no characters other than blanks or tabs may appear before the initial percent sign on the second and subsequent lines.
@endnode

@node "VWOE" "VWOE, Chapter 23.6"

An Operator_expression is valid if and only if its equivalent dot form is a valid call.
@endnode

@node "VWST" "VWST, Chapter 23.21"

A Strip expression appearing in a class @{i}C @{ui} is valid if and only if every Identifier in its Attribute_list is the final name of an attribute of @{i}C @{ui}.
@endnode

@node "VXRC" "VXRC, Chapter 15.8"

It is valid for a Routine to include a Rescue clause if and only if its Routine_body is of the Internal form.
@endnode

@node "VXRT" "VXRT, Chapter 15.8"

A Retry instruction is valid if and only if it appears in a Rescue clause.
@endnode

