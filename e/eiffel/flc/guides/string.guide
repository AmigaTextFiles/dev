@database string.guide
@author "Damien Guichard"
@(c) "Copyright © 1995 Damien Guichard."
@$VER: string.guide 1.0 (21/06/95)
@font helvetica.font 13

@node Main "STRING class short form"
-- Characters strings
@{b}expanded class interface@{ub} STRING @{b}creation procedures@{ub}
    make (n:@{"INTEGER" LINK integer.guide/main})
        -- Allocate space for at least 'n' characters.
      @{b}require@{ub}
        non_negative_size: n >= 0
      @{b}ensure@{ub}
        capacity = n
@{b}exported features@{ub}
    append (s:STRING)
        -- Append a copy of 's' at end of current string.
      @{b}require@{ub}
        argument_not_void: s /= Void
      @{b}ensure@{ub}
        count = @{b}old@{ub} count + s.count
    capacity:@{"INTEGER" LINK integer.guide/main}
        -- Number of characters that can be contained in the string
    clear
        -- Clear out string.
      @{b}ensure@{ub}
        count = 0
    copy (other:STRING)
        -- Reinitialize with copy of 'other'
      @{b}require@{ub}
        other /= Void
      @{b}ensure@{ub}
        count = other.count;
        -- For all i: 1..count, item (i) = other.item (i)
    count:@{"INTEGER" LINK integer.guide/main}
        -- Actual number of characters making up the string
      @{b}ensure@{ub}
        Result >= 0
    empty:@{"BOOLEAN" LINK boolean.guide/main}
        -- Is string empty?
    extend (c:@{"CHARACTER" LINK character.guide/main})
        -- Add 'c' at end.
      @{b}ensure@{ub}
        count = @{b}old@{ub} count + 1
    fill_blank
        -- Fill with blanks.
      @{b}ensure@{ub}
        -- For all i: 1..count, item (i) = Blank
    hash_code:@{"INTEGER" LINK integer.guide/main}
        -- Hash code value of current string
    head (n:@{"INTEGER" LINK integer.guide/main})
        -- Remove all characters except for the first 'n';
        -- do nothing if n >= count.
      @{b}require@{ub}
        non_negative_argument: n >= 0
      @{b}ensure@{ub}
        -- count = min (n,@{b}old@{ub} count)
    index_of (c:@{"CHARACTER" LINK character.guide/main}; i:@{"INTEGER" LINK integer.guide/main}):@{"INTEGER" LINK integer.guide/main}
        -- Index of the first occurence of 'c', starting at
        -- position i; 0 if not found.
      @{b}require@{ub}
        index_large_enough: i >= 1;
        index_small_enough: i <= count
      @{b}ensure@{ub}
        Result = 0 @{b}or@{ub} item (Result) = c
    is_equal (other:STRING):@{"BOOLEAN" LINK boolean.guide/main}
        -- Is current string made of the same characters sequence as 'other'?
        -- (Redefined from 'ANY')
    item (i:@{"INTEGER" LINK integer.guide/main}):@{"CHARACTER" LINK character.guide/main}
        -- Character at position 'i'
      @{b}require@{ub}
        index_large_enough: i >= 1;
        index_small_enough: i <= count
    item_code (i:@{"INTEGER" LINK integer.guide/main}):@{"INTEGER" LINK integer.guide/main}
        -- Numeric code of character at position 'i'
      @{b}require@{ub}
        index_large_enough: i >= 1;
        index_small_enough: i <= count
    lef_adjust
        -- Remove leading blanks.
        -- NOT IMPLEMENTED.
      @{b}ensure@{ub}
        (count /= 0) @{b}implies@{ub} (item (1) /= ' ')
    precede(c:@{"CHARACTER" LINK character.guide/main})
        -- Add 'c' at front.
        -- NOT IMPLEMENTED.
      @{b}ensure@{ub}
        count = @{b}old@{ub} count + 1
    prepend(s:STRING)
        -- Prepend a copy of 's' at front of current string.
        -- NOT IMPLEMENTED.
      @{b}require@{ub}
        argument_not_void: s /= Void
      @{b}ensure@{ub}
        count = @{b}old@{ub} count + s.count
    put (c:@{"CHARACTER" LINK character.guide/main}; i:@{"INTEGER" LINK integer.guide/main})
        -- Replace by 'c' character at position 'i'.
      @{b}require@{ub}
        index_large_enough: i >= 1;
        index_small_enough: i <= count
      @{b}ensure@{ub}
        item (i) = c
    remove (i:@{"INTEGER" LINK integer.guide/main})
        -- Remove i-th character.
        -- NOT IMPLEMENTED.
      @{b}require@{ub}
        index_large_enough: i >= 1;
        index_small_enough: i <= count
      @{b}ensure@{ub}
        count = @{b}old@{ub} count - 1
    remove_all_occurrences (c:@{"CHARACTER" LINK character.guide/main})
        -- Remove all occurrences of 'c'.
        -- NOT IMPLEMENTED.
      @{b}ensure@{ub}
        -- For all i: 1..count, item (i) /= c
        -- count = @{b}old@{ub} count - number of occurrences of 'c' in initial string
    right_adjust
        -- Remove trailing blanks.
        -- NOT IMPLEMENTED.
      @{b}ensure@{ub}
        count /= 0 @{b}implies@{ub} item (count) /= ' '
    shrink (s:STRING; n1,n2:@{"INTEGER" LINK integer.guide/main})
        -- Remove characters outside of interval n1..n2
        -- NOT IMPLEMENTED.
      @{b}require@{ub}
        argument_not_void: s /= Void
        meaningful_origin: 1 <= n1;
        meaningful_interval: n1 <= n2;
        meaningful_end: n2 <= s.count
      @{b}ensure@{ub}
        is_equal (s.substring (n1, n2))
    substring (n1, n2:@{"INTEGER" LINK integer.guide/main}):STRING
        -- Copy of substring of current string containing all characters
        -- at indices between n1 and n2.
        -- NOT IMPLEMENTED.
      @{b}require@{ub}
        meaningful_origin: 1 <= n1;
        meaningful_interval: n1 <= n2;
        meaningful_end: n2 <= count
      @{b}ensure@{ub}
        Result.count = n2 - n1 +1
        -- For all i: 1..n2-n1, Result.item(i) = item (n1 +i -1)
    tail (n:@{"INTEGER" LINK integer.guide/main})
        -- Remove all characters except for the last 'n';
        -- do nothing if n >= count.
        -- NOT IMPLEMENTED.
      @{b}require@{ub}
        non_negative_argument: n >= 0
      @{b}ensure@{ub}
        -- count = min (n,@{b}old@{ub} count)
    to_integer:@{"INTEGER" LINK integer.guide/main}
        -- Integer value of current string, assumed to contain digits only
        -- When applied to "123", will yield 123.
      @{b}require@{ub}
        -- String contains digits only
    to_lower
        -- Convert string to lower case.
    to_upper
        -- Convert string to upper case.
@{b}invariant@{ub}
   0 <= count; count <= capacity
@{b}end interface@{ub} -- class 'STRING'
@endnode
