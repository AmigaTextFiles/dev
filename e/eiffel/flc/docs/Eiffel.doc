

Eiffel V3.0 language reference

This is Eiffel V3.0 language reference and can be used pressing  Browse >
button or in conjunction with AmigaGuide capabilities of an Eiffel compiler or
interpreter, providing complete and precise error report. The high formalism
degree of this document is part of Eiffel's challenge of software reliability.

All Eiffel3.0-related syntax and validity are described here even if not
implemented in CoolDemo. Thus this document serves as an ideal that Cool must
reach.


Eiffel V3.0 syntax specification

This is Eiffel syntax reference and can be used pressing  Browse >  button or
in conjunction with AmigaGuide capabilities of an Eiffel compiler or
interpreter, providing complete and precise error report. The syntactical
correction is the first level of valididity requirements for any Eiffel
structured document. Processing tools may claim supplememtary requirements on
a well-formed specimem of a construct. Such requirements are meaningless while
the construct is not built according to the following rules.


Class_declaration ::= [ Indexing ]
                      Class_header
                      [ Formal_generics ]
                      [Obsolete]
                      [ Inheritance ]
                      [Creators]
                      [ Features ]
                      [ Invariant ]
                      end ["--" class Class_name]

Class_header ::= [Header_mark] class Class_name
Header_mark  ::= deferred | expanded
Class_name   ::= Identifier

Creators ::= creation {Creation_clause creation ..."}+
Creation_clause ::= [Clients ] [ Header_comment ] Feature_list

Obsolete ::= obsolete Message
Message  ::= Manifest_string

Indexing     ::= indexing Index_list
Index_list   ::= {Index_clause ";" ..."}
Index_clause ::= [Index] Index_terms
Index        ::= Identifier ":"
Index_terms  ::= {Index_value "," ..."}+
Index_value  ::= Identifier | Manifest_constant

Formal_generics ::= "[" Formal_generics_list "]"
Formal_generic_list ::= {Formal_generic "," ..."}
Formal_generic ::= Formal_generic_name [Constraint]
Formal_generic_name ::= Identifier
Constraint ::= "->" Class_type

Inheritance  ::= inherit Parent_list
Parent_list ::= {Parent ";" ..."}
Parent ::= Class_type [Feature_adaptation]
Feature_adaptation ::= [Rename]
                       [New_exports]
                       [Undefine]
                       [Redefine]
                       [Select]
                       end

Rename ::= rename Rename_list
Rename_list ::= {Rename_pair "," ..."}
Rename_pair ::= Feature_name as as Feature_name

New_exports ::= export New_export_list
New_export_list ::= {New_export_item ";" ..."}
New_export_item ::= Clients Feature_set
Feature_set ::= Feature_list | all
Feature_list ::= { Feature_name "," ..."}

Undefine ::= undefine Feature_list
Redefine ::= redefine Feature_list
Select ::= select Feature_list

Features ::= feature {Feature_clause feature ..."}
Feature_clause ::= [Clients ]
                   [Header_comment]
                   Feature_declaration_list
Feature_declaration_list ::= {Feature_declaration ";" ..."}
Header_comment ::= Comment
Feature_declaration ::= New_feature_list Declaration_body
Declaration_body ::= [Formal_arguments]
                     [ Type_mark ]
                     [Constant_or_routine]
Constant_or_routine ::= is Feature_value
Feature_value ::= Manifest_constant | Unique | Routine
New_feature_list ::= {New_feature "," ..."}+
New_feature ::= [frozen] Feature_name
Unique ::= unique Unique ::= unique

Clients ::= "{" Class_list "}"
Class_list ::= { Class_name "," ..."}

Feature_name ::= Identifier | Prefix | infix
Prefix ::= prefix '"' Prefix_operator '"'
Infix ::= infix '"' Infix_operator '"'
Prefix_operator ::= Unary | Free_operator
Infix_operator ::= Binary | Free_operator

Routine ::= [ Obsolete ]
            [Header_comment]
            [ Precondition ]
            [ Local_declarations ]
            Routine_body
            [ Postcondition ]
            [Rescue]
            end ["--" Feature_name ]
Routine_body ::= Effective | Deferred
Effective ::= Internal | External
Internal ::= Routine_mark Compound
Routine_mark ::= do | once
Deferred ::= deferred
Rescue ::= rescue Compound

Precondition ::= require [else] Assertion
Postcondition ::= ensure [then] Assertion
Variant ::= variant [Tag_mark] Integer_expression
Invariant ::= invariant Assertion
Assertion ::= {Assertion_clause ";" ..."}
Assertion_clause ::= [Tag_mark] Unlabeled_assertion_clause
Unlabeled_assertion_clause ::= Boolean_expression | Comment
Tag_mark ::= Tag ":" Tag ::= Identifier

Compound ::= {Instruction ";" ..."}

Instruction ::= Creation |
                Call |
                Assignment |
                Reverse_assignment_attempt |
                Conditional |
                Multi_branch |
                Loop |
                Debug |
                Check |
                Retry

Creation ::= "!" [ Type ] "!" Writable [Creation_call]
Creation_call ::= "." Unqualified_call

Assignment ::= Writable ":=" Expression
Reverse_assignment_attempt ::= Writable "?=" Expression
Check ::= check Assertion end
Retry ::= retry "?=" Expression
Check ::= check Assertion end
Retry ::= retry

Conditional ::= if Then_part_list [Else_part] end
Then_part_list ::= {Then_part elseif ..."}+
Then_part ::= Boolean_expression then then Compound
Else_part ::= else Compound


Multi_branch ::= inspect Expression [When_part_list] [Else_part] end
When_part_list ::= when {When_part when ..."}+
When_part ::= Choices then Compound
Choices ::= {Choice "," ..."}
Choice ::= Constant | Interval
Interval ::= Integer_interval | Character_interval
Integer_interval ::= Integer_constant ".." Integer_constant
Character_interval ::= Character_constant ".." Character_constant

Loop ::= Initialization
         [ Invariant ]
         [ Variant ]
         [Loop_body]
         end
Initialization ::= from Compound
Loop_body ::= Exit loop Compound
Exit ::= until Boolean_expression

Debug ::= debug [Debug_keys] Compound end end
Debug_keys ::= "(" Debug_key_list ")"
Debug_key_list ::= {Debug_key "," ..."}
Debug_key ::= Manifest_string

Call ::= [Parenthesized_qualifier] Call_chain
Parenthesized_qualifier ::= Parenthesized "."
Call_chain ::= {Unqualified_call "." ..."}+
Unqualified_call ::= Identifier [Actuals]
Actuals ::= "(" Actual_list ")"
Actual_list ::= {Actual "," ..."}
Actual ::= Expression | Address
Address ::= "$" Identifier

Integer_expression ::= Expression
Boolean_expression ::= Expression

Expression ::= Call |
               Operator_expression |
               Equality |
               Constant |
               Local |
               Read_only |
               Manifest_array |
               Old |
               Strip

Equality ::= Expression Comparison Expression
Comparison ::= "=" | "/="
Constant ::= Manifest_constant | Constant_attribute
Constant_attribute ::= Identifier
Old ::= old Expression
Strip ::= strip "(" Attribut_list ")"
Atrribute_list ::= {Identifier "," ..."}
Operator_expression ::= Parenthesized |
                        Unary_expression |
                        Binay_expression
Parenthesized ::= "(" Expression ")"
Unary_expression ::= Unary Expression
Binary_expression ::= Binary Expression

Unary ::= not | "+" | "-" Binary ::= "+" | "-" | "*" | "/" |
          "<" | ">" | "<=" | ">=" |
          "//" | "\" | "^" |
          and | or | xor |
          and then | or else | implies

Formal_arguments ::="(" Entity_declaration_list ")"
Local_declarations ::= local Entity_declaration_list
Entity_declaration_list ::= {Entity_declaration_group ";" ..."}
Entity_declaration_group ::= Identifier_list Type_mark
Identifier_list ::= {Identifier "," ..."}+
Type_mark ::= ":" Type

Entity ::= Writable | Read_only
Writable ::= Attribute | Local
Attribute ::= Identifier
Local ::= Identifier | Result
Read_only ::= Formal | Current
Formal ::= Identifier

Manifest_array ::= "<<" Expression_list ">>"
Expression_list ::= { Expression "," ..."}

Manifest_constant ::= Boolean_constant | Character_constant |
                      Integer_constant | Real_constant |
                      Manifest_string | Bit_constant
Sign ::= "+" | "-"
Integer_constant ::= [Sign] Integer
Character_constant ::= "'" Character "'"
Boolean_constant ::= true | false
Real_constant ::= [Sign] Real
Manifest_string ::= '"' Simple_string '"'
Bit_constant ::= Bit_sequence

Type ::= Class_type |
         Class_type_expanded |
         Formal_generic_name |
         Anchored |
         Bit_type
Class_type ::= Class_name [Actual_generics]
Actual_generics ::= "[" type_list "]"
Type_list ::= {Type "," ..."}
Class_type_expanded ::= expanded Class_type
Bit_type ::= BIT Constant
Anchored ::= like Anchor
Anchor ::= Identifier | Current

External ::= external Language_name [External_name]
Language_name ::= Manifest_string
External_name ::= alias
External_name ::= alias Manifest_string

Comment ::= "--" {Simple_string Comment_break ..."}
Comment_break ::= New_line [Blanks_or_tabs] "--"


Validity constraints of Eiffel language V3.0

This is validity reference and can be used pressing  Browse >  button or in
conjunction with AmigaGuide capabilities of an Eiffel compiler or interpreter,
providing complete and precise error report. Validity is the second and last
level of requirements for any Eiffel structured document. Any valid
construction can be processed by an Eiffel compiler or interpreter. Validity
requirements are meaningless while the construct is not built according to the
syntax rules.


VAOL, Chapter 9.9

An Old expression of the form old e, where e is an expression of type TE,
is valid if and only if it satisfies the following two conditions:
1. It appears in a Postcondition clause of a Routine r.
2. Transforming r into a function with result type TE (by adding a result
   type if r is a procedure, or changing its result type if it is already a
   function) and replacing its entire Routine part by
     do
       Result  := e
     end
   would yield a valid routine.


VAPE, Chapter 9.8

A Precondition of a routine r of a class C is valid if and only if every
feature whose final name appears in any Assertion_clause is available to every
class to which r  is available.


VAVE, Chapter 9.14

A variant is valid if and only if it is an expression of type INTEGER .


VBAR, Chapter 2.6

Assignment rule

An assignment is valid if and only if its source expression conforms to its
target entity.


VBGV, Chapter 2.7

General Validity rule

Every validity constraint relative to a construct is considered to include an
implicit supplementary condition stating that every component of the construct
statisfies every validity constraint applicable to the component.


VCCH, Chapter 4.8

A Class_header appearing in the text of a class C is valid if and only if it
satisfies either of the following two conditions:
1. There is no Header_mark of the deferred form and C is effective.
2. There is a Header_mark of the deferred form and C is deferred.


VCFG, Chapter 4.9

A Formal_generics part of a Class_declaration is valid if and only if every
Formal_generic_name G  appearing in it satisfies the following two conditions:
1. G  is different from the name of any class in the surrounding universe.
2. G  is different from any other Formal_generic_name appearing in the same
   Formal_generics_part.


VCRN, Chapter 4.11

If present, this comment must repeat the Class_name given at the head of the
class.


VDCN, Chapter D.5

A consistency condition applies to names used in an Ace: the Cluster_name must
be unique for each cluster. It is valid, however, to use the same identifier
in two or more of the role of Cluster_name, System_name, Class_name.


VDJR, Chapter 10.23

Join rule

It is valid for a class C to inherit two different features as deferred under
the same final name if and only if, after possible redeclaration in C, they
have identical signatures.


VDOC, Chapter D.11

A Target_list may only appear in an Option paragraph, not in a Defaults
paragraph. A System_tag may only appear in an Ace-level Defaults clause.


VDRD, Chapter 10.22

Redeclaration rule

Let C be a class and g  a feature of C. It is valid for g  to be a
redeclaration of a feature f  inherited from a parent B of C if and only if
the following conditions are satisfied:
1. No effective feature of C other than f and g has the same final name as f
   and g.
2. The signature of g conforms to the signature of f.
3. If g is a routine, its Precondition, if any, begins with require else (not
   just require), and its Postcondition, if any, begins with 'ensure then'
   (not just ensure).
4. If the redeclaration is a redefinition (rather than an effecting) the
   Redefine subclause of the Parent part of B lists the final name of f in its
   Feature_list.
5. If f is inherited as effective, then g is also effective.
6. If f is an attribute, g is an attribute,
   f and g are both variable and their type are both expanded or both non
   expanded.
7. If one from f or g is an External routine, then the other too.


VDRS, Chapter 10.19

Redefine Subclause rule

Consider a class C with a parent B . If a Parent part for B in C contains a
Redefine subclause, that clause is valid if and only if every Feature_identifier
fname  that it lists (in its Feature_list) satisfies the following conditions:
1. fname  is the final name in C of a feature inherited from B.
2. That feature was not frozen, and was not a constant attribute.
3. fname  appears only once in the Feature_list.
4. The Features part of C contains one Feature_declaration for fname, which
   is a valid redeclaration, but not an effecting, of the original feature.


VDUC, Chapter D.8

The Cluster_properties part contained in a Use file may not itself contain a
Use paragraph.


VDUS, Chapter 10.19

Undefine Subclause rule

Consider a class C that inherits from a class B. If a Parent part for B in C
contains an Undefine subclause, that clause is valid if and only if, for every
Feature_identifier fname that it lists (in its Feature_list):
1. fname is the final name in C of a feature inherited from B.
2. That feature was not frozen, and was not an attribute.
3. That feature was effective in B.
4. fname appears only once in the Feature_list.


VEEN, Chapter 17.9

An occurence of an entity e  in text of a class C is valid if and only if
it satisfies one of the following conditions:
1.  e is the final name of an attribute of C.
2A. The occurence is in a Local_declarations, Routine_boby, Postcondition or
    Rescue part of a Routine text for a function, and e is the local entity
    Result.
2B. The occurence is in a Local_declarations, Routine_boby or Rescue part of a
    Routine text for a routine r, and the Local_declarations part for r
    contains an Entity_declaration_list including e as part of its
    Identifier_list.
3.  The occurence is in a Feature_declaration for a routine r, and the
    Formal_arguments part for r contains an Entity_declaration_list including
    e as part of its Identifier_list.
4.  e is Current.


VFFD, Chapter 5.14

Feature declaration rule

A Feature_declaration appearing in a class C, and whose New_feature_list
contains one or more feature names F1,..,Fn is valid if and only if it
satisfies all of the following conditions:
1. Its Declaration_body describes a feature which, according to the rules
   of 5.11, is one of: variable attribute, constant attribute, procedure,
   function.
2. None of the Fi has the same name as another faeture introduced in C
   (in particular Fi is not the same name as Fj for different i and j).
3. If the name of any of the Fi is the same as the final name of any
   inherited feature, the Declaration_body satisfies the Redeclaration rule.
4. If the Declaration_body describes a deferred feature, then none of the
   Fi is preceded by the keyword 'frozen'.
5. If any of the Fi is a Prefix name, the Declaration_body describes an
   attribute or a function with no argument.
6. If any of the Fi is an Infix name, the Declaration_body describes a
   function with exactly one argument.
7. If the Declaration_body describes a once function, the result type is not
   a Formal_generic_name.


VGCC, Chapter 18.9

Creation Instruction rule

Consider a Creation instruction appearing in a class X. Let x be the
target of the instruction and T a type of base class C.

The instruction is C-valid if and only if it satisfies the following
conditions:
1. T is not a Formal_generic_name (that is to say, a formal parameter of the
   class where the instruction appears).
2. C is an effective class.
3. If the Type part is present, the type that it contains (which is T) conforms
   to the type of x, and is a reference type.
4. If C does not have a Creators part, there is no Creation_call part.
5. If C has a Creator part, there is a Creation_call part, and the call would
   be A-valid if it appeared in the text of C.
6. If case 5 holds and f  is the feature of the Creation_call, then f is a
   procedure, its Routine_body is not of the once... form, and f  is available
   for creation to X.


VGCI, Chapter 18.10

A Creation instruction is valid if and only if it is both C-valid and S-valid.


VGCP, Chapter 18.8

Creation_clause rule

A Creation_clause appearing in the Creators part of a class C is valid if and
only if it satisfies the following four conditions, the last three for every
Feature_identifier fname in the clause's Feature_list:
1. C is effective.
2. fname is the final name of a procedure of C.
3. fname appears only once in the Feature_list.
4. If C is expanded, that procedure has no arguments, and no other
   Feature_identifier appears in the Feature_list.


VGCS, Chapter 18.10

A Creation instruction is S-valid (system-valid) if and only if it satisfies
one of the following two conditions:
1. The creation type is explicit (in other words, the instruction begins with
   !T !... for some type T).
2. The creation type is implicit (in other words, the instruction begins with
   !!...) and every possible dynamic type T for x, with base class C, satisfies
   conditions 1 to 6 of the Creation Instruction rule. In applying conditions
   5 and 6, the feature of the call, f, must be replaced by its version in C.


VHAY, Chapter 6.15

Wether you use the default ANY or another one, any system will need to have a
class of name ANY . This is a constraint on any valid universe.


VHPR, Chapter 6.6

Parent rule

The Inheritance clause of a class D is valid if and only if it meets the
following two conditions:
1. In every Parent clause for a class B, B is not a descendant of D.
2. If two or more Parent clauses are for classes which have a common ancestor
   A, D meets the conditions of the Repeated Inheritance Consistency constraint
   for A.


VHRC, Chapter 6.9

Rename Clause rule

It is valid to use old_name  as first element of a Rename_pair,  appearing in
the Rename subclause of the Parent clause for B in a class C, if and only if
the following two conditions are satisfied:
1. old_name  is the final name of a feature of B.
2. old_name  does not appear as the first element of any other Rename_pair in
   the same Rename subclause.


VIRW, Chapter 25.9


An identifier is valid if and only if it is not one of the language's reserved
words.


VJAR, Chapter 20.4

Assignment rule

An assignment is valid if and only if its source expression conforms to its
target entity.


VJRV, Chapter 20.14

Reverse Assignment Attempt rule

A Reverse_assignment_attempt is valid if and only if the type of its target
entity conforms to the type of its source expression.


VKCN, Chapter 21.3

Whether a particular call is an instruction or a function depends on the
nature of the feature of the call:
1. If the feature is an attribute or a function, the Call is syntactically an
   expression.
2. If the feature is a procedure, the Call is an instruction.


VLCP, Chapter 7.13

A Clients part is valid if and only if every Class_name appearing in its
Class_list is the name of a class in the surrounding universe.


VLEC, Chapter 7.5

Expanded Client rule

It is valid for a class C to be an expanded client a class SC if and only if SC
is not a direct or indirect expanded client of C.


VLEL, Chapter 7.13

Export List rule

A New_exports clause appearing in class C in a Parent clause for a parent B,
of the form

export
  {'class list' 1"}   'feature_list' 1;
  ...
  {'class list' 'n'"} 'feature_list' 'n';

is valid if and only if (for 'i' in the interval 1..'n'):

1. At most one of the 'feature_list'i is the keyword 'all'.
2. All the other 'feature_list' 'i' are lists of final names of features of C
   obtained from B .
3. No final feature name appears twice in any such list, or apppears in more
   than one list.


VMCN, Chapter 11.11

1. A class may not introduce two different features, both deferred or both
   effective, with the same name.
2. If a class introduces a feature with the same name as a feature it inherits
   in effective form, it must rename the inherited version.
3. If a class inherits two features as effective from different parents and
   they have the same name, the class must also (except under sharing for
   repeated inheritance) remove the name clash through renaming.


VMFN, Chapter 11.11

Feature name rule

It is valid for a class C to introduce a feature with the Feature_identifier
fname, or to inherit a feature under the final name fname, if and only if no
other feature of C has that same name.


VMRC, Chapter 11.13

It is valid for a class D to be a repeated descendant of a class A if and only
if D satisfies the following two conditions for every feature f of A:
1. If the Repeated Inheritance rule implies that f wil be shared in D, then
   all the inherited versions of f are the same feature.
2. If the Repeated Inheritance rule implies that f wil be replicated in D and
   f is potencially ambiguous, then the Select subclause of exactly one of the
   Parent parts of D lists the corresponding version of f, under its final
   name in D .


VMSS, Chapter 11.13

Select Subclause rule

A Select subclause appearing in the Parent part for a class B in a class D is
valid if and only if, for every Feature_identifier fname in its Feature_list,
fname is the final name in D of a feature that has two or more potential
versions in D, and fname appears only once in the Feature_list.


VNCB, Chapter 13.11

The possible conformance cases involving a Bit_type are the following:
1. 'BIT N' conforms to 'BIT P' for N<=P.
2. For every type T  which is not a Bit_type, there is an integer bit_size(t)
   such that T  conforms to 'BIT N' if and only if bit_size (t)<=N. The value
   of bit_size (t) is platform-dependent.

Other than implied by these rules, no type conforms directly to a Bit_type,
and a Bit_type conforms directly to no type.


VNCC, Chapter 13.4

General Conformance

Let T and V be two types other than Bit_type. V  conforms to T  if and only if
one of the following holds:
1. V and T are identical.
2. V is 'NONE' and T is a reference type.
3. V is B[Y1,..Yn] for some generic class B, T is B[X1,..,Xn], and every one of
   the Yi conforms (recursively) to the corresponding Xi.
4. T is a reference type and, for some type U, V conforms directly to U and U
   conforms (recursively) to T.


VNCE, Chapter 13.10

Direct Conformance (Expanded Types)

Let T be an Expanded type. Then:
1. If the base type BT of T is a reference type, BT conforms directly to T and
   T conforms directly to BT .
2. If T is INTEGER , if conforms directly to REAL and DOUBLE, and if T is REAL
   it conforms directly to DOUBLE.

Other than implied by these cases, no type conforms directly to T, and T
conforms directly to no type.


VNCF, Chapter 13.7

Direct Conformance (Formal Generic)

Let G be a generic parameter of a class, which in the class may be used as a
type of the Formal_generic_name category. No type conforms directly to G. If G
is not constrained, it conforms directly to the type ANY (based on the
corresponding universal class) and to no other type. If G is constrained by CT,
G conforms directly to CT and to no other type.


VNCG, Chapter 13.6

Direct Conformance (Generic Substitution)

Let BT  be a generically derived type of base type B [X 1,...X n] for
some n>=1, where the formal generic parameters of B  are G 1,...G n.
Let CT  be a type of base class C  different from B . To determine
whether CT  conforms directly to BT , define the substitution ð as follows:
. If CT  is non-generic, ð is the identity substitution.
. If CT  is a generically derived type, of the form C ['Y'1,...'Y'm], and
  class C  is declared with formal generic paramaters 'H'1,...'H'm, then ð
  applied to any of the 'H'i (for 1<=i<=m) is 'Y'i and ð applied to any other
  element is the element itself.

Then CT  conforms directly to BT  if and only if the Inheritance clause of
C  lists B ['Z'1,...'Z'n] as one of its Parent items and, for every 'j'
such that 1<='j'<='n', applying substitution ð to 'Z'j yields X j.


VNCH, Chapter 13.8

Direct Conformance (Anchored)

In a class C, type like Current conforms directly to its base type CT, where CT
is C followed by its Formal_generic_list, if any, with any Constraint removed.
Type like  anchor, where anchor is a feature of C or a formal argument of a
routine of C, conforms directly to the type of anchor in C.
An anchored type conforms directly to no type other than implied by these
rules. No types conforms directly to an anchored type.


VNCN, Chapter 13.5

Let CT be a type of base class C, and BT be a type whose base class B is not
generic. CT conforms directly to BT if and only if the Inheritance clause of C
lists B in one or more of its Parents items.


VNCS, Chapter 13.3

Signature Conformance

A signature t =(<B1,..,Bn>,<S>) conforms to a signature 's'=(<A1,..,An>,<R>)
if and only if:
. Each of the two sequence components of t  has the same number of
  elements as the corresponding component of 's'.
. Every type in each of the two sequence components of t  conforms to
  the corresponding type in the corresponding component of 's'.


VNCX, Chapter 13.9

Conformance (Expression)

An expression v of type VT conforms to an expression t of type TT if and only
if they satisfy any one of the following four conditions:
1. VT conforms to TT.
2. VT is like t (t in this case must be an entity).
3. VT and TT are both of the form like x for the same x.
4. TT is like x where x is a formal argument to a routine r, v is an actual
   argument in a call to r, and VT conforms to the type of the actual argument
   corresponding to x in the call.


VOMB, Chapter 14.5

Multi_branch rule

A Multi_branch instruction is valid if and only if the following conditions
are met by its unfolded form:
1. The inspect expression is of type INTEGER  or CHARACTER .
2. The inspect constants (the values in the various Choices parts) are constant
   attributes of the same type as the inspect expression.
3. Any two non-Unique inspect constants have different values.
4. Any two Unique inspect constants have different names.
5. If any inspect constant is Unique, then every other inpect constant in the
   instruction is either Unique or has negative or zero value.
6. All Unique inspect constants, if any, have the same class of origin (the
   enclosing class or a proper ancestor).


VQMC, Chapter 16.5

A declaration of a feature f introducing a manifest constant is valid if and
only if the Manifest_constant m  used in the declaration matches the type T
declared for f in one of the following ways:
. m is a Boolean_constant and T is BOOLEAN.
. m is a Character_constant and T is CHARACTER.
. m is an Integer_constant and T is INTEGER.
. m is a Real_constant and T is REAL  or DOUBLE.
. m is a Manifest_string and T is STRING.
. m is a Bit_constant and T is a Bit_type.


VQUI, Chapter 16.6

A declaration of a feature f introducing a Unique constant is valid if and only
if the type T declared for f is INTEGER.


VREG, Chapter 8.3

Let el be an Entity_declaration_list. Let identifiers be the concatenation of
every Identifier_list of every Entity_declaration_group in fa. Then el is valid
if and only if no Identifier appears more than once in the list identifiers.


VRFA, Chapter 8.3

Formal Argument rule

Let fa be the Formal_arguments part of a routine r in a class C. Let formals be
the concatenation of every Identifier_list of every Entity_declaration_group in
fa. Then fa is valid if and only if no Identifier e appearing in formals is the
final name of a feature of C.


VRLE, Chapter 8.7

Local Entity rule

Let ld be the Local_declarations part of a routine r in a class C. Let locals
be the concatenation of every Identifier_list of every Entity_declaration_group
in ld. Then ld is valid if and only if every Identifier e in ld satisfies the
following two conditions:
1. No feature of C has e as its final name.
2. No formal argument of r has e as its Identifier.


VRRR, Chapter 8.5

Routine rule

A Routine part of a routine declaration is valid if and only if one of the
following conditions holds:
1. Its Routine_body is an Internal body (beginning with do or once).
2. In the other cases (where the Routine_body is External or Deferred), there
   is neither a Local_declarations part nor a Rescue part.


VSCN, Chapter 3.5

No two classes in a given cluster may have the same class name.


VSRC, Chapter 3.4

Root class rule

A class C  may be used as root of a system if and only if it satisfies the
following two conditions:
1. C is not generic.
2. Any creation procedure of C has either no formal argument, or a single
   formal argument of type ARRAY[STRING].


VTAT, Chapter 12.15

An anchored type of the form like anchor  appearing in a class C is valid if
and only if one of the following holds:
1. anchor  is the final name of an attribute or function of C, whose declared
   type is a non-Anchored reference type.
2. The type appears in the text of a routine r of C, and anchor is a formal
   argument of r, whose declared type is a non-Anchored reference type.
3. anchor  is the reserved word Current .


VTBT, Chapter 12.14

A Bit_type is valid if and only if its Constant is of type INTEGER, and has a
positive value.


VTCG, Chapter 12.8

Constrained Genericity rule

Let C be a constrained generic class. A Class_type CT having C as base class is
valid if and only if CT satisfies the Unconstrained Genericity rule and, in
addition:
3. For any Formal_generic parameter in the declaration of C having a constraint
   of the form -> D, the corresponding Type in the Actual_generics list of CT
   conforms to D.


VTCT, Chapter 12.5

Class Type rule

An Identifier CC is valid as the Class_name part of a Class_type if and only if
it is the name of a class in the surrounding universe.


VTEC, Chapter 12.12

Expanded Type rule

An expanded type of the form expanded  CT, where CT is a Class_type of base
class C , is valid if and only if it satisfies the following conditions:
1. C is not a deferred class.
2. C either has no creation procedure, or has only one creation procedure with
   no argument.


VTUG, Chapter 12.7

Unconstrained Genericity rule

Let C be an unconstrained generic class. A Class_type CT having C as base class
is valid if and only if it satisfies the following two conditions:
1. C is a generic class.
2. The number of Type components in CT's Actual_generics list is the same as
   the number of Formal_generic parameters in the Formal_generic_list of C 's
   declaration.


VUAR, Chapter 22.9

Consider an E-valid (export-valid) call of target target  and feature name
fname appearing in a class C. (For an Unqualified_call take target to be
Current.) Let ST be the type of target, S the base class of ST, and sf the
feature of final name fname in S. Let D be a descendant of S, and df the
version of sf in D. The call is A-valid (argument-valid) for D if and only if
it satisfies the following four conditions:
1. The number of actual arguments is the same as the number of formal arguments
   declared for df .
2. Every actual argument, if any, conforms to the corresponding formal
   argument of df .
3. If target  is itself a Call, it is (recursively) argument-valid for D .
4. If any of the actual arguments is of Address form $ 'fn', df  is an
   external routine, and 'fn' is the final name of a feature of C  which is not
   a constant attribute.


VUCS, Chapter 22.9

Call rule

Consider a single-dot call with target x, appearing in a class C. Let S be the
type of x. Then:
1. The call is C-valid (class-valid) if it is E-valid (export-valid) and
   A-valid (argument-valid) for S .
2. The call is S-valid (system-valid) if for any element D  of the dynamic
   class set of x  it is E-valid and A-valid for D .


VUEX, Chapter 22.9

A call appearing in a class C, having fname as the feature of the call, is
export-valid for a class D if and only if it satisfies either of the following
two conditions:
1. The call is an Unqualified_call and fname is the final name of a feature of
   C.
2. The call has at least one dot, D has a feature of name fname which is
   available to C, and the call's target is either a valid entity of C or
   (recursively) a call which is export-valid for D.


VUGV, Chapter 22.9

Call rule

A call is valid if and only if it is both C-valid and S-valid.


VWBE, Chapter 23.2

A Boolean_expression is valid if and only if it is an Expression of type
BOOLEAN.


VWEQ, Chapter 23.3

An Equality expression is valid if and only if either of its operand conforms
to the other.


VWCA, Chapter 23.13

A Constant_attribute in the text of a class C is valid if and only if its
Entity is the final name of a constant attribute in C.


VWID, Chapter 23.12

Identifier rule

An Identifier appearing unqualified in an expression as part of the text of a
routine r in a class C must be the name of a feature of C, a local entity of r,
or a formal argument of r.


VWMA, Chapter 23.20

Manifest Array rule

A Manifest_array <<e1, e2, ...en>> is a valid expression of type ARRAY[T]
if and only if the type of every ei conforms to T.


VWMS, Chapter 23.18

A Manifest_string is valid if and only if it satisfies the following two
conditions:
1. None of the characters of its associated Simple_string is a double quote.
2. In the extended form, no characters other than blanks or tabs may appear
   before the initial percent sign on the second and subsequent lines.


VWOE, Chapter 23.6

An Operator_expression is valid if and only if its equivalent dot form is a
valid call.


VWST, Chapter 23.21

A Strip expression appearing in a class C is valid if and only if every
Identifier in its Attribute_list is the final name of an attribute of C.


VXRC, Chapter 15.8

It is valid for a Routine to include a Rescue clause if and only if its
Routine_body is of the Internal form.


VXRT, Chapter 15.8

A Retry instruction is valid if and only if it appears in a Rescue clause.


