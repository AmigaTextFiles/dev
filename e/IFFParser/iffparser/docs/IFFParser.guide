@database iffparser.guide

@node "Main" "IFFParser_oo Guide"

                  ** IFFParser_OO - Written By Fabio Rotondo **

                          ** DOCUMENTATION GUIDE **


     @{" Introduction " link "Introduction" 0}            @{" Author's Infos " link "Author" 0}         @{" Example Program" link "Example" 0}

    COMMANDS                            BRIEF DESCRIPTION
    -------------------------------------------------------------------------- -
    @{" iffparser()                    " link "iffparser" 0}    Inits the iffparser object.
    @{" addr()                         " link "addr" 0}    Returns current data position in mem.
    @{" close()                        " link "close" 0}    Closes currently IFF session.
    @{" closechunk()                   " link "closechunk" 0}    Closes last created chunk.
    @{" createchunk(type, id, size)    " link "createchunk" 0}    Inits a new chunk to write.
    @{" exit(type, id)                 " link "exit" 0}    Defines when scan() must stop.
    @{" first(type, id)                " link "first" 0}    Prepares data examination.
    @{" getheader(string, filename)    " link "getheader" 0}    Returns header of a file.
    @{" load(filename)                 " link "load" 0}    Inits an IFF Load session.
    @{" save(filename)                 " link "save" 0}    Inits an IFF SAVE session.
    @{" scan()                         " link "scan" 0}    Begins scanning an IFF file.
    @{" setscan(type, id)              " link "setscan" 0}    Defines type of chunk to scan for.
    @{" succ()                         " link "succ" 0}    Gets next memory data location.
    @{" size()                         " link "size" 0}    Returns current data size.
    @{" writechunk(datas, datalen)     " link "writechunk" 0}    Writes some datas to a chunk.

    @{"EXCEPTIONS TABLE" link "EXCEPTIONS" 0}
@endnode

@node "Introduction" "Introduction "


    IFFParser is an Object to easily read/write IFF files.

    It  is not so powerful as IFFParse.library:  it misses some features, but I
have  written  it  to  match  all my needs, and it does.  I hope you will enjoy
using. Look at the examples for working programs.


@endnode

@node "Author" "Author's Infos"

    My name is Fabio Rotondo. I am a free-lance Amiga programmer and I would
    like to get in touch with anyone who writes code for the Amiga.
    I write in AmigaE, BlitzII, C and a bunch of other languages.

    Please, feel free to contact me for any suggestions/questions.

    My address is:

    Fabio Rotondo
    C.so Vercelli 9
    28100 Novara
    ITALY
    Tel. (ITA) - (0)321 - 459676
    e-mail: fsoft@intercom.it

    Check out my WWWPage with many of my AmigaE Modules/Sources!

    Thanks!

-------------------------------------------------------------------------------
   //                      | Fabio Rotondo           e-mail: fsoft@intercom.it
\\X/ Amiga. Feel The Power.| URL:     http://www.intercom.it/~fsoft/index.html
+-----------------------------------------------------------------------------+
|GTBoxConv V4.20 | SafeLocks V1.00 | Locator.library V1.00 | MIDIBridge V1.00 |
|MIDIFilter V1.1 | PCATPro (65%)   | DOOPSI-GS (85%)       | Great Game (10%) |
+-----------------------------------------------------------------------------+


@endnode

@node "Example" "Example Program"


    See  directory  Docs/Examples/IFFParser_Examples  for  some  working AmigaE
programs.   They are all PD sources!  Feel free of examing and grab outwhatever
you want!

@endnode

@node "iffparser" "iffparser()                     "
           NAME: iffparser()

    DESCRIPTION: This command will initialize the iffparser object.

          INPUT: NONE.

        RESULTS: NONE.

     EXCEPTIONS: @{" iffp " LINK EXCEPTIONS}

       SEE ALSO:
@endnode

@node "addr" "addr()                          "
           NAME: addr()

    DESCRIPTION: This command will return current memory data address.

          INPUT: NONE.

        RESULTS: a PTR TO LONG specifying memory data address (may be NIL)

     EXCEPTIONS: NONE.

       SEE ALSO: @{" size()  " link "size" 0}
                 @{" first() " link "first" 0}
                 @{" succ()  " link "succ" 0}
@endnode

@node "close" "close()                         "
           NAME: close()

    DESCRIPTION: This command will close curent IFF session.

          INPUT: NONE.

        RESULTS: NONE.

     EXCEPTIONS: NONE.

       SEE ALSO: @{" load() " link "load" 0}
                 @{" save() " link "save" 0}
@endnode

@node "closechunk" "closechunk()                    "
           NAME: closechunk()

    DESCRIPTION: This command will close current chunk.

          INPUT: NONE.

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}
                 @{" popc " link "EXCEPTIONS" 0}

       SEE ALSO: @{" createchunk() " link "createchunk" 0}
                 @{" writechunk()  " link "writechunk" 0}
                 @{" save()        " link "save" 0}
@endnode

@node "createchunk" "createchunk(type, id, size)     "
           NAME: createchunk(type, id, size=IFFSIZE_UNKNOWN)

    DESCRIPTION: This command will create a new chunk where to write in.

          INPUT: type       - (LONG) type of the chunk. (ex. "ILBM")
                 id         - (LONG) id of the chunk. (ex. "FORM")

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}
                 @{" push " link "EXCEPTIONS" 0}

       SEE ALSO: @{" closechunk() " link "closechunk" 0}
                 @{" writechunk() " link "writechunk" 0}
                 @{" save()       " link "save" 0}
@endnode

@node "exit" "exit(type, id)                  "
           NAME: exit(type, id)

    DESCRIPTION: Use this command to determinate WHEN scan() should stop.

          INPUT: type       - (LONG) type of the chunk. (ex. "ILBM")
                 id         - (LONG) id of the chunk. (ex. "FORM")

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}
                 @{" exit " link "EXCEPTIONS" 0}

       SEE ALSO: @{" load()   " link "load" 0}
                 @{" scan()   " link "scan" 0}
                 @{" setscan()" link "setscan" 0}
@endnode

@node "first" "first(type, id)                 "
           NAME: first(type, id)

    DESCRIPTION: Use this command to position IFFParser object to the FIRST
                 memory data location of a specific kind.

          INPUT: type       - (LONG) type of the chunk. (ex. "ILBM")
                 id         - (LONG) id of the chunk. (ex. "FORM")

        RESULTS: a PTR TO LONG memory location of the data (may be NIL)

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}


       SEE ALSO: @{" load()    " link "load" 0}
                 @{" scan()    " link "scan" 0}
                 @{" setscan() " link "setscan" 0}
                 @{" succ()    " link "succ" 0}
@endnode

@node "getheader" "getheader(string, filename)     "
           NAME: getheader(string:PTR TO CHAR, filename:PTR TO CHAR)

    DESCRIPTION: Use this command to determinate the kind of a file.

          INPUT: string     - A _VALID_ Estring already initialized.
                 filename   - Name of the file to examine.

        RESULTS: string     - your _VALID_ Estring will be filled with the
                              file header (ex. "ILBM")

           NOTE: This command returns a STRING not a LONG!

     EXCEPTIONS: NONE.


       SEE ALSO:
@endnode

@node "load" "load(filename)                  "
           NAME: load(filename:PTR TO CHAR)

    DESCRIPTION: Use this command to open an already existing IFF file and
                 to begin a IFF load session.

          INPUT: filename   - Name of the file to open / load.

        RESULTS: NONE.

     EXCEPTIONS: @{" iffa " link "EXCEPTIONS" 0}
                 @{" oold " link "EXCEPTIONS" 0}
                 @{" oiff " link "EXCEPTIONS" 0}

       SEE ALSO: @{" setscan() " link "setscan" 0}
                 @{" scan()    " link "scan" 0}
                 @{" close()   " link "close" 0}
@endnode

@node "save" "save(filename)                  "
           NAME: save(filename:PTR TO CHAR)

    DESCRIPTION: Use this command to create a new IFF file and to begin
                 a IFF save session.

          INPUT: filename   - Name of the file to open / load.

        RESULTS: NONE.

     EXCEPTIONS: @{" iffa " link "EXCEPTIONS" 0}
                 @{" onew " link "EXCEPTIONS" 0}
                 @{" oiff " link "EXCEPTIONS" 0}

       SEE ALSO: @{" createchunk() " link "createchunk" 0}
                 @{" writechunk()  " link "writechunk" 0}
                 @{" closechunk()  " link "closechunk" 0}
                 @{" close()       " link "close" 0}
@endnode

@node "scan" "scan()                          "
           NAME: scan()

    DESCRIPTION: Use this command to begin scanning an IFF file.

          INPUT: NONE.

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}

       SEE ALSO: @{" setscan() " link "setscan" 0}
                 @{" load()    " link "load" 0}
@endnode

@node "setscan" "setscan(type, id)               "
           NAME: setscan(type, id)

    DESCRIPTION: Use this command to set chunk that will be loaded by
                 scan().

          INPUT: type       - (LONG) type of chunk. (ex. "ILBM")
                 id         - (LONG) id of chunk.   (ex. "FORM")

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}
                 @{" coll " link "EXCEPTIONS" 0}

          NOTES: You can do more than a single setscan() before scan()ing the
                 IFF file. This is the biggie ;)
                 In this way you can load up in memory all you need in a single
                 file access.

       SEE ALSO: @{" scan() " link "scan" 0}
                 @{" load() " link "load" 0}
@endnode

@node "size" "size()                          "
           NAME: size()

    DESCRIPTION: Use this command to get size of current memory data.

          INPUT: NONE.

        RESULTS: size   - (LONG) size of the memory data. (May be NIL)

     EXCEPTIONS: NONE.

       SEE ALSO: @{" first() " link "first" 0}
                 @{" succ()  " link "succ" 0}
@endnode

@node "writechunk" "writechunk(datas, datalen)      "
           NAME: writechunk(data, datalen)

    DESCRIPTION: Use this command to write some data into a chunk.

          INPUT: data    - (PTR TO LONG) memory location of your datas.
                 datalen - (LONG) length in bytes of your data.

        RESULTS: NONE.

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}
                 @{" writ " link "EXCEPTIONS" 0}

       SEE ALSO: @{" save()        " link "save" 0}
                 @{" createchunk() " link "createchunk" 0}
                 @{" closechunk()  " link "closechunk" 0}
@endnode

@node "succ" "succ()      "
           NAME: succ()

    DESCRIPTION: Use this command to position to the next memory data.

          INPUT: NONE.

        RESULTS: a PTR TO LONG to the new location of memory data. (May be NIL)

     EXCEPTIONS: @{" init " link "EXCEPTIONS" 0}

       SEE ALSO: @{" load()  " link "load" 0}
                 @{" first() " link "first" 0}
@endnode

@node "EXCEPTIONS" "EXCEPTIONS TABLE"
                
                             EXCEPTIONS TABLE

 EXCEPTION       - DESCRIPTION
--------------------------------------------------------------------------
 "coll"          - Could not do a CollectionChunk() call.
 "exit"          - Could not assign StopOnExit.
 "iffa"          - Could not AllocIFF().
 "iffp"          - Could not open iffparse.library.
 "init"          - IFFParser object not initialized with load() or save().
 "oiff"          - Could not OpenIFF().
 "onew"          - Could not create filename with Open(fname, MODE_NEWFILE).
 "oold"          - Could not Open() file for reading.
 "popc"          - Could not Pop current chunk.
 "push"          - Could not Push current chunk.
 "writ"          - WriteChunkBytes() failed.
@endnode

