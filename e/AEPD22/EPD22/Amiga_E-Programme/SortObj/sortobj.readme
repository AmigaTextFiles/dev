Short: Abstract sortobj object for Amiga E
Type: dev/e
Author: Joseph E. Van Riper III
Uploader: jvanriper@uncavx.unca.edu
Long:

SortObj for Amiga E

This set of objects was created by Trey Van Riper of the
Cheese Olfactory Workshop for use with Amiga E.  Wear it in
good health.

This archive has SortObj, String, Integer, and Address.

PURPOSE
-------

To supply the Amiga E community with an extensible OT class
that might help provide for some extreme functionality in
the future through reuse (for example, I will very likely
create a sorted list class based on this object class) I
took the trouble to create SortObj.

The basic idea behind 'SortObj' is to have a single object
from which other objects can be derived that might allow for
sorting in a list or somesuch.  I have not yet made such a
list, but these objects will still be useful to OT
developers working in Amiga E.

NOTE: As this is an abstract class, it's extremely
low-level.  Initially, this object looks on the face of it
to be darned useless, but as people start deriving more
objects from this one, its flexibility will become more
obvious.

I am hoping this will help encourage people to release OT
objects to help extend Amiga E's usefulness.

HOW TO USE
----------

Well.. I suppose I'd best give the SortObj ShowModule output
first:

ShowModule v1.9 (c) 1992 $#%!
now showing: "sortobj.m"
NOTE: don't use this output in your code, use the module instead.

/* this module contains 620 bytes of code! */

(---) OBJECT sortobj
        new(a)
        opts(a)
        init()
        lt(a)
        gt(a)
        et(a)
        le(a)
        ge(a)
        ne(a)
        cmp(a)
        set(a)
        write()
        get()
	id()
        end()
(---) ENDOBJECT     /* SIZEOF=4 */

-- new(a)

   This method is intended to be an intializer.  You can
   pass options to it; I would recommend one passes an Amiga
   E list rather than a simple value; this will help keep
   your code extensible.  Basically, one shouldn't have to
   worry about creating their own new() methods as this one
   calls 'init()' and 'opts()'.

-- opts(a)

   This method allows you to pass special options to the
   object, in case your object requires several things to be
   set at various values (examine the Address object).
 
-- init()

   This method is intended to help you initialize the
   object, in case it needs it.  Maybe you need to NEW some
   pointers or something.

-- cmp(a)

   This method is VERY important... to get the most out of
   sortobj, you will want to define this.  Basically, this
   should perform a comparison between something within your
   object, and something within object 'a' (which should be
   the same as your own object).

   Not that the above makes a lot of sense.

   Generally, 'a' is supposed to be an instance of the
   object you're creating.  'cmp()' is supposed to compare
   something within that instance with something inside your
   'self' instance.

   It should return '1' if the 'self' value is greater than
   the 'a' value, '0' if the two are equal, and '-1' if
   'self' is less than the 'a' value.

   Then, a whole bunch of other functions will become
   enabled for your procedure... lt()/gt()/le()/ge()/ne()/et()
   will all instantly start working for you.

   I recommend you try to make this function work as quickly
   as possible, as in some cases it might be called twice
   (eg ge() and le()).

-- lt(a)

   This tests to see if self is less than a.

-- gt(a)

   This tests to see if self is greater than a.

-- et(a)

   This tests to see if self is equal to a.

-- le(a)

   This tests to see if self is less than or equal to a.

-- ge(a)

   This tests to see if self is greater than or equal to a.

-- ne(a)

   This tests to see if self is not equal to a.

-- write()

   This method should return a string to be written by
   someone else.  Perhaps, in the far future, this class
   could be extended by creating an output object that could
   be used by sortobj or something.. in the meantime, you
   can try using this.

   Basically, make sure this method returns something you
   could WriteF().

-- get()

   This method should return the data within the object.
   This isn't exactly easy to judge in the case of objects
   with multiple members (such as the Address object), but
   its useful for such things as strings and integers.
   Perhaps this could return an OBJECT with normal pointers
   to strings and stuff like that... it'll have to be your
   own call how to use it, but you hopefully get the general
   drift.  Use the other objects derived from sortobj as a
   guide.

-- id()

   This method returns a number describing the kind of
   object it is.  This can be handy for making lists of
   objects of unknown types.

-- end()

   Of course, this is the deallocator.  This function will
   be called when someone ENDs the object, so it should be
   useful for something <grin>.

SO WHAT, WHO CARES
------------------

I know it doesn't seem like such a big deal to have these
objects, especially since I'm not yet supplying a sorted
list, but consider how useful this would be when used with
something like queuestack (yeah, I know, cheap
advertisement, but hey, it's a cheap product)... then again,
someone else might beat me to the creation of an object
oriented sorted list!

You could store pointers to different kinds of sortobjs
within queuestack, dropping them into the queuestack
willy-nilly, without any idea what they might be, then pull
them out again as needed, id()ing them to figure out what
they are.

You could even iterate through the queuestack, write()ing
the values to some kind of variable to be printed out in a
WriteF() or something, without having to worry about what
the object in the queuestack is!

I've taken the trouble to provide you with a string and
integer object as subclasses of sortobj, as well as an
example of a more complex object 'address'.  Still to be
written are a float and fraction object.

The string and integer classes need further work; the string
class should have some means by which someone could append
new strings to it, as well as number conversions and all
that happy stuff (basically, all the various Amiga
Efunctions put into the class itself), while the integer
object could use various functions to handle arithmatic
matters.

In fact, the entire integer class will be reworked in the
future to be derived from a higher abstract class 'number' that
I'm going to create sometime later... but I wanted to get a
quick version out in the meantime.

DISTRIBUTION
------------

You are granted full rights to use and distribute this.
I am not requiring money for its use.  In fact, I encourage
as many people as possible to use this, and to possibly
extend this as much as possible.  Hell, fix any screwup you
find!

Basically, this is Public Domain; even the source has been
made available so you can have yet another example of OT
programming.  I ask that you do not modify the source code
under my name; let me be responsible for my own mistakes,
nobody else's.  I also ask you do not take credit for work
I've done; OT programming seems to be tricky for some folks
to handle, and I want to be sure to get the credit where
it's due.

Consider this a contribution to the Amiga E community to
encourage the development of object tools in the Amiga E
language.

As ever, Wouter van Ootmerson has full permission to include
this in his next release of Amiga E, as he sees fit, without
having to pay me anything but credit.
