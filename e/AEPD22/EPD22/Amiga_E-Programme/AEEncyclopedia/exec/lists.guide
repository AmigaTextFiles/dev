@database exec/lists
@index indexnode
@author Gregor Goldbach

@node main "Lists"
The following chapters will give you the knowledge to use exec's lists.
If you don't know what a list is, read the following lines in this paragraph,
else choose between these:

        @{" Building                      " link "exec_BuildingLists"     } - basic exec functions for that
        @{" Changing contents             " link "exec_ChangingLists"     } - move/swap nodes etc.
        @{" Description of exec/lists: lh " link "exec_DescOfList"        } - OS module explanation
        @{" Navigation through            " link "exec_ListNavigation"    } - move through a list
        @{" Terms                         " link "exec_ExecListsinGeneral"} - some terms one has to know


A list is a construct which consists of elements of a same kind, i.e. numbers,
strings or whatever. Unlike an array it can be dynamically changed - and this
is the main reason why one uses a list instead of an array.

NOTE: I'll compare the contructs list and array. If you don't know what an
array is, please read the according paragraph. Thank you.

Each element (also called node, see @{" terms " link exec_ExecListsInGeneral} or the @{" nodes.guide " link nodes.guide/main}) has at
least one link to a neighbour; if a list consists of elements with just one
such link - normally to their successors - it is called single-linked, if two
links are present (predecessor and successor), it is called doubly-linked.
see @{" Diagram on lists " system "SYS:Utilities/MultiView pics/lists1.brush"}

The list's length can - and in most cases will - be changed. For example, every
screen structure contains a list of windows that were opened on it. If this
list would be substituted by an array of the size five, only five windows
could be opened on it. Obviously this is not the case... The number of
windows opened can be virtually unlimited (only limited by memory available).

A disadvantage of lists is that we cannot get to a certain element at once
but only by passing its neighbour. When working with an array we can say
something like: give me the third element. When working with a single-linked
list we would have to say: give me the successor of the successor of the
element that's at the head of the list.

Another advantage though is the easy way one can insert elements. If you
would like to insert an element in an array you would have to shift the one
that's already in the slot to, say, the right. That element there would have
to be shifted to the right and so on and so on. Take this single-linked list:

  apple -> bean -> table

Now you want to insert the word 'tree' between 'bean' and 'table'. You just
have to tell 'bean' that its successor is no longer 'table' but 'tree'.
That makes the following list:

  apple -> bean -> tree       table

Note that there's no link between tree and table yet, we have to take care
of that. So you have to tell 'tree' that its sucessor is table. Voila! That
makes this list:

  apple -> bean -> tree -> table

It seems as if this is what we wanted:)

This was easy, and it would have been easy if we had taken an array instead
of an list. But imagine an array with more than hundred elements, it would
have been quite a work to insert an element there (not the insertion itself
but the shifting would have taken much more time).

        @{" Terms                    " link exec_ExecListsInGeneral}
        @{" Building lists           " link exec_BuildingLists}
        @{" Navigating through lists " link exec_ListNavigation}

Gregor Goldbach January 17th 1995
@endnode

@node exec_ExecListsInGeneral "Exec's lists - terms and other stuff"
This chapter will inform you about the terms used to describe exec lists.

An element of an exec list is also called node.

The element that's lying 'after' another element is named successor,
the one lying 'before' predecessor.

Exec lists are doubly-linked for each node has a link to its predecessor
and its successor (@{" Diagram on lists " system "SYS:Utilities/MultiView pics/lists1.brush"}).

The following terms are elements of the structure @{" list " link exec_DescOfList} (module exec/lists):

The beginning of an exec list is called head, the end is called tail,
the predecessor of the tail is called tailpred.

The head's predecessor does not exist, therefore it is set to NIL.
The tail of a list is always NIL. The tailpred is actually pointing to
the last existing node in the list.

Read the last three sentences again.

HINT: use the function [newlist()] defined in tools/constructors to
initialize a list. Don't do it manually or sorrows will cross your mind.
Honestly.

@next exec_BuildingLists
        @{" Building lists " link exec_BuildingLists}

Gregor Goldbach January 17th 1995
@endnode


@node exec_BuildingLists "Building Lists - exec-meets-E Functions"
To build a valid exec list, we need a structure of that name. It is declared
in 'exec/lists' [showmodule link on that]. Let's define a pointer on it:

  DEF listpointer: PTR TO lh      -> lh short for 'list header'

Phantastic. Now we have to initialize it - or better we would have to if we
were using some other language. In E there's a tiny module for that,
tools/contructors. It contains the function newlist() which does this job
very well, so why not using it:

  listpointer := newlist()

With listpointer we do now hold a pointer to a valid list. By now this list
is empty, let's fill it. Since a list contains nodes we must use nodes,
i.e. for now, for a more complex example see [link]. Once again we can use
the module mentioned above for this, it does also contain a function called
newnode(). newnode(NIL, 'any name') returns the pointer to a node with its
name set to 'any name'. We need a variable to hold that address, here comes
the definition for it:

DEF  listnode: PTR TO ln

'ln' ist the short name for 'list node'. This structure is declared in
'exec/nodes'. So we get our first initialized node of the list with the call:

  listnode := newnode(NIL,'first')

Fine. We put this node in the list by doing this:

  AddHead(listpointer, listnode)

The function AddHead is a function of the exec.library which puts the given
node at the head of the given list. There are two other way of putting a
node in a list: [Insert] and [AddTail].

You are now able to build an exec-list and you can even add nodes to it.
See chapter @{" Navigation through lists " link exec_ListNavigation} for information on how to access the
data, jumping from one node to another and the like.

Gregor Goldbach January 17th 1995
@endnode

@node exec_ListNavigation "Navigation through lists"
Nice to see you. You're about to learn how to move from one node to another and
related stuff. For that we have to declare anywhere in a PROC

DEF listhead:PTR TO lh,
    listnode:PTR TO ln

If this doesn't say you anything, read the information on @{" building lists " link exec_BuildingLists}.

Let's start at the beginning, the head of the list:

  listnode := listpointer.head  -> move the pointer of the list's head to var

To see the name of the first node you can write:

  WriteF('\s\n', listnode.name)

To get to the next node in the list you have to get the address that's put in
the successor slot:

  listnode := listnode.succ     -> move next node's address to var

You can move on and on this way but you should watch the contents of the
node's successor. If it is NIL, you have reached the end of the list.

Let's write a little PROC that takes a list and prints all its nodes
names: @{" print_nodenames(list) " rx "AEE:ARexxScripts/ViewFilePart.rexx examples/lists1.e 36 59"}
NOTE: in the PROC above I seem to have forgotten my own remark about the
contents of listnode.succ. I move it happily into the variable. Well, that's
fine because I use WHILE there - 'WHILE listnode' means the loop is only
entered if listnode contains a value other than NIL. You may change that line
to 'WHILE listnode<>NIL' if you like. BTW: this PROC can be found in an @{" example " system "SYS:Utilities/MultiView examples/lists1.e"}.


'If I can walk forward through the list backwards must be possible,too.' you
think. Smarty, you're right. Have a guess which slot of the node is taken to
get to its predecessor. Right, pred is the one. So

  listnode := listnode.pred

gets us one node back. As with node.succ you have to keep an eye on node.pred.
If it's NIL you've reached the beginning of the list. I don't recommend going
further in that direction :)

And now for something special: take a list and move forward through it. If
actual_node.succ is NIL you are - because of the design of the structure lh -
NOT at the last node you added to the list but in the list header. Read the
last sentence again. If you don't know why, look up the explanation of the
structure @{" lh " link exec_DescOfList}, if you do, you'll also know that
if node.pred is NIL you are actually in the list header, too.

Alright, that was that, you are now able to move through lists. If you already
know how to build lists you should read the @{" example " system "SYS:Utilities/MultiView examples/lists1.e"} mentioned above, if not,
read the chapter on @{" Building lists " link exec_BuildingLists}. If you'd like to know how you can change
the list's order, read @{" Changing the list's contents " link exec_ChangingLists}.

Gregor Goldbach January 17th 1995
@next exec_ChangingLists
@endnode

@node exec_DescOfList "Description of structure lh"
ShowModule tells us the contents of the module @{" exec/lists " rx "/ARexxScripts/ShowModulePart.rexx EMODULES:exec/lists.m 4 10"}, move the window that
pops up after you press this button so you can read this text.

The structure we are interested in is named lh. It means 'list header'. Let's
start right at the beginning:


  o   head:LONG

      This is the slot where we find the pointer to the list's first node. If
      head.succ equals NIL, the list is empty, read note below.

  o   tail:LONG

      Contains the pointer to the successor node of the list's last node: NIL.
      No kidding, it is always NIL, read the note below.

  o   tailpred:LONG

      Contains the pointer of the list's last node.

  o   type:CHAR

      As it says, the type of the list. [types]

  o   pad:CHAR

      A pad byte to make the number of the structure's bytes even.


Maybe the existence of the 'tail' slot makes no sense to you. Here's the
explanation. If you build a new list, it's empty of course. You can initialize
the structure shown above by hand - if you understand what I'm about to tell
you - or you can use the function newlist() from the module tools/constructors
which is really very useful. After the initialization the list looks like
this:

  .-> head --.
  |          |
  |   NIL  <-'
  |
  `-- tailpred

      type

      pad

Looks nice, doesn't it? list.head.succ equals list.tail (which is always NIL),
list.tailpred points to list.header.

Take this as a given fact: an empty exec list looks that way. Therefore we can
write this lines in our code to test if a list is empty:

  list = newlist()
  node := list.head

  IF node.succ = NIL THEN WriteF('The list is empty!\n')

Gregor Goldbach January 20th 1995
@endnode

@node exec_ChangingLists "Changing the list's contents"
In this chapter you will learn how to change the order of the nodes and some
other manipulation.

        @{" Move a node through the list " link exec_MoveNode}
        @{" Swapping nodes               " link exec_SwapNodes}

Gregor Goldbach January 18th 1995
@endnode

@node indexnode "Index"

        @{" List - Building                      " link "exec_BuildingLists"}
        @{" List - Contents, Changing of         " link "exec_ChangingLists"}
        @{" List - Description of exec/lists: lh " link "exec_DescOfList"}
        @{" List - General                       " link "main"}
        @{" List - Navigation through            " link "exec_ListNavigation"}
        @{" List - Terms                         " link "exec_ExecListsinGeneral"}

        @{" Node - Moving                        " link "nodes.guide/exec_MoveNode"}
        @{" Node - Swapping                      " link "nodes.guide/exec_SwapNodes"}
@endnode
