@database exec/nodes
@author Gregor Goldbach
@index Index

@node main "Exec/Nodes - Introduction"
You will learn how to create, move, swap a node. Additionally, the usage of
nodes in own structures is shown. If you don't know what a node is, read the
following lines in this paragraph, else choose between:


      @{" Description of exec/nodes: ln " link Description}
      @{" Node creation                 " link exec_CreateNode}
      @{" Move a Node                   " link exec_MoveNode}
      @{" Swapping Nodes                " link exec_SwapNodes}
      @{" Inserting Nodes               " link exec_InsertNode}
      @{" Removing Nodes                " link exec_RemoveNode}
      @{" Usage in other structures     " link exec_NodeInStructure}


A node is an element of an exec list. ( If you don't know what such a list is,
read all about it in the lists.guide. There you will also find a chapter where
the corresponding terms a described.) Back to the nodes: each node has a link
the both its predecessor and its successor ([Diagram on lists]).


Gregor Goldbach January 23nd 1995
@endnode

@node Description "Exec - Nodes -- Description of the module exec/nodes.m"
Let's see what the module @{" exec/nodes " rx "AEE:ARexxScripts/ShowModulePart.rexx EMODULES:exec/nodes.m 4 10"} contains:

  succ:PTR TO ln

  The successor of this node, to some strange reason also a node:) If it is
  NIL, there is none.

  pred:PTR TO ln

  The predecessor of this node. If it is NIL, there is none.

  type

  The node's type. The type is set to the type of the list the node is in.
  The @{" list of types " rx "AEE:ARexxScripts/ShowModulePart.rexx EMODULES:exec/nodes.m 17 38"} shows you between what types you can choose.
  Since nodes are usually at the head of a structure (see the according
  [chapter] in this guide) this type can be used to tell what kind of data
  will follow. The OS itself does this - e.g. take a node of a task list and
  you'll see that the tye is set tp NT_TASK, in a device list the type is set
  to NT_DEVICE and so on. Set it to 0 (=NT_UNKNOWN) if you use it in a
  non-OS-list.

  pri

  The priority of this node. Useful if you want to sort a list by
  'importance'. If something has a higher priority it is more important than
  something else and therefore is put nearer at the beginning of the list.
  Tasks are sorted this way, the CHANGETASKPRI shell command sets this entry
  to the given value. Set to 0 if it is totally normal.

  name:PTR TO CHAR

  The node's name, 0-terminated.

Gregor Goldbach January 28th 1995
@endnode


@node exec_CreateNode "Node creation"
Via calling tools/constructors/newnode().

  node := newnode(NIL, 'nodename')
@endnode

@node exec_MoveNode "Moving a node"
You'll learn how to move a node to another place within the list. Take this
list:


  NIL <-- one <--> two <--> three --> NIL


(The arrows indicate the direction one can move through the list.)

We want to move node three between node one and node two. The result will be
that when we move through the list we walk through node one first, then pass
node three and stop at node two.


  NIL <-- one <--> three <--> two --> NIL


That means that node three has to get the successor of node one whilst node
one has to get the predecessor of node three, right? Right. Given the node
pointers one, two and three which contain the according pointers this would
have to be the code to do it:


  one.succ := three   -> node three gets successor of node one
  three.pred := one   -> node one gets predecessor of node three


The list we have just created looks like this:


  NIL <-- one <--> three --> NIL


As you may see, node two has vanished. 'Why?', I hear you ask. Well, node two
was the successor of node one. We have just substituted that link. We have
also replaced the link betwenn node three and node two. To get node two back
on the list the following lines have to be typed:


  three.succ := two   -> node two gets successor of node three
  two.pred   := three -> node three gets predecessor of node two


Now we have this list:


  NIL <-- one <--> three <--> two -.
                      |____________|


Since we didn't change it, the succ slot of node two still points to node
three. But we want to have the end marked there, so this is what we do:


  two.succ := NIL     -> the end is nigh


Finally we have the desired list:


  NIL <-- one <--> three <--> two --> NIL



Gregor Goldbach January 18th 1995
@endnode


@node exec_SwapNodes "How to swap nodes"
Now you'll learn how to swap nodes. As you know each node has a link to its
predecessor and its successor. Take this list (maybe an image would be
better):

    NIL <-- one <--> two <--> three <--> four --> NIL

We want to swap nodes two and three, the result will look like this:

    NIL <-- one <--> three <--> two <--> four --> NIL

It's very easy, it can be done via moving node three between node two and
four. That's it.

Gregor Goldbach January 21st 1995
@endnode

@node exec_NodeInStructure "Usage of nodes in structures"
The node structure can be found in many other structures used by the OS, e.g.
in [message ports].

You know how to build a list with nodes, however, very often you will wish to
build a list with additional information. That's no problem - just define an
OBJECT with the needed information an put a node at its beginning. For
example, build a list with the phone numbers with all your friends. We need
the name and the phone number of your friend:

  the_name[50]:ARRAY OF CHAR          -> allow a length of 50
  phone_number[30]:ARRAY OF CHAR      -> 20 characters for the phone number

Now put a node in front of this data and the object to use is ready:

  OBJECT phone
    node:ln                           -> the list node
    the_name[50]:ARRAY OF CHAR
    phone_number[30]:ARRAY OF CHAR
  ENDOBJECT

You may now use all the functions and methods discussed before on this
object. The reason for this is that the resulting data structure actually
looks like this:

  OBJECT phone

    succ:LONG                       -> this
    pred:LONG                       -> is
    type:CHAR                       -> the
    pri:CHAR                        -> object
    name:LONG                       -> ln

    name[50]:ARRAY OF CHAR
    phone_number[20]:ARRAY OF CHAR
  ENDOBJECT

So if you pass this object's address to, say, AddHead(), the object is treated
like a normal node - and that's fine because the fields that function does
access ARE in fact those of a node. Therefore the result is equal to that of a
'pure' node.

The  @{" example " system "SYS:Utilities/MultiView examples/phone.e"} will show you how to use the object created above.

NOTE: look at the PROC @{b}print_phoneentries@{ub}. You will see how you can move
through the list via using the '::' operator. The object @{b}phone@{ub} is transformed
in the object @{b}ln@{ub}. Instead of writing @{b}phone::ln.succ@{ub} I could also type
@{b}phone.node.succ@{ub}.

Gregor Goldbach January 22nd 1995
@endnode

@node exec_InsertNode "Inserting a Node"
There are three ways to insert a node in a list:

a) via Insert()
b) via AddHead()
c) via AddTail()



  Insert(list:PTR TO lh, node:PTR TO ln, predecessor:PTR TO ln)

  Inserts a node after the node labelled predecessor. If this node is NIL,
  the node is inserted at the head of the list (but for that purpose you
  should use AddHead())


  AddHead(list:PTR TO lh, node:PTR TO ln)

  Puts the node at the head of the list.


  AddTail(list:PTR TO lh, node:PTR TO ln)

  Puts the node at the end of the list.


To see how these functions are used, look at the @{" example " system "SYS:Utilities/MultiView examples/lists1.e"}..

Gregor Goldbach January 23rd 1995
@endnode

@node exec_RemoveNode "Removing a Node from a list"
To remove a node from a list, just call Remove() with the node's address:

DEF node:PTR ln
.
.
.
  Remove(node)

You may then safely free the memory allocated for this node or whatever you
want to do for the node is no longer in the list.

Gregor Goldbach January 23rd 1995
@endnode

@node Index "Exec/Nodes - Index"

      @{" Creation                  " link exec_CreateNode}
      @{" Insertion                 " link exec_InsertNode}
      @{" Moving                    " link exec_MoveNode}
      @{" Removing                  " link exec_RemoveNode}
      @{" Swapping                  " link exec_SwapNodes}
      @{" Usage in other structures " link exec_NodeInStructure}

Gregor Goldbach January 23rd 1995
@endnode

