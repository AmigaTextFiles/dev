@database exec/devices
@author Gregor Goldbach

@node main "Exec - Devices -- Main"
A device is something that's used for communication with an apparatus,
the apparatus itself is either logical (console) or physical (printer).
Every device has a set of basic commands that can be used by your program
such as reading/writing from/to the apparatus. If you know how to use one
device you can use every device, even if such different devices like
'trackdisk.device' (for floppy disk access) and 'audio.device' (playing
sampled data) are needed.

Before you can use the device you have to open it. Furthermore, you have to
provide an initialized structure when you @{" open a device " link OpenADevice}, this structure is
called @{" iorequest " link IORequest}. This iorequest is used everytime you want to communicate
with the devices, every information that's needed is put in there.

When @{" communicating " link Communication} with the device you ask it for execution of a given
@{" command " link Commands} (that's why the data structure is called 'request' :). You pass the
data to the device, then you can a) continue in the program (the system gives
you a hint when the command was executed) or b) wait until the command was
executed. Method a) may be used for long execution time, e.g. printing a text;
method b) for short commands.

@{" Close the device " link CloseADevice} if you don't need it any more.

        @{" OBJECT device " link OBJECTDevice}

Gregor Goldbach February 11th 1995
@endnode

@node OpenADevice "Exec - Devices -- Open a device"
To open a device the following steps have to be taken:

  o   create a @{" message port " link "message ports.guide/main"} (via [CreateMsgPort()])

        The message port is used for signalling your task when you asked for
        asynchronous execution of a device @{" command " link Commands}.

  o   create an initialized @{" iorequest " link IORequest} structure (via [CreateIORequest()])

        The iorequest's entries are initialized with 'the right' values,
        whatever that means. The message port is needed for this.

  o   open the device (via [OpenDevice()])

        When opening a device you have to specifiy a @{" unit " link Unit} and the
        iorequest that you have just created.

[example code from oomodules/device.e]

Gregor Goldbach February 12th 1995
@endnode

@node CloseADevice "Exec - Devices -- Close a device"
To close an opened device the following steps have to be taken in this order:

  o   close the device (via CloseDevice())

  o   delete the @{" iorequest " link IORequest} (via DeleteIORequest())

        This is only needed if you don't need the iorequest any more. You may
        use it in another part of your program of course.

  o   delete the @{" message port " link "message ports.guide/main"} (via DeleteMsgPort())

        This is only needed if you don't need the message port any more. You
        may use it in another part of your program of course.


Gregor Goldbach February 13th 1995
@endnode

@node OpenClose "Exec - Devices -- Opening and Closing"
To open a device call

  OpenDevice(name,iorequest,unit,flags)

  o name            the name of the device, e.g. 'trackdisk.device'
  o iorequest       an initialized iorequest, note that alsmost every device
                    has its own iorequest structure
  o unit            the unit you want to use. In trackdisk this is 0 for the
                    internal disk drive, 1 for df1:, 2 for df2: and 3 for df3:
                    If no special unit seems reasonable it should be set to 0.
  o flags           Special flags for this unit.


  NOTE:

  Read the according chapter for each device, there you will find more
  information on iorequest, unit and flags.

If the result is NIL, everything was fine.


To close an opened device call

  CloseDevice(iorequest)

Gregor Goldbach February 11th 1995
@endnode

@node Communication "Exec - Devices -- How to communicate"
As I've already told you when you ask the device for execution of a command
you can a) get a note when the command has been executed or b) wait until the
execution is finished. You know that every needed data has to be put in a
iorequest, too.

Method a) is called 'synchronous execution' and can be done via calling
DoIO(iorequest), b) is called 'asynchronous execution' and can be done via
SendIO(iorequest). Both functions can be found in the exec.library.

Gregor Goldbach February 11th 1995
@endnode


@node IORequest "Exec - Devices -- IORequest"
The iorequest structure contains all relevant data needed for execution of a
given device command. Example: you want to use the printer.device to print
some text. You'll have to put the text and its length in the iorequest, then
you can ask for execution of the WRITE command.

Since the printer needs information that is quite different from the
information needed by the audio.device (which plays sampled audio data) the
iorequests are different. Look in the chapter for the according device to see
how that particular iorequest is built. However, the head of every iorequest
is equal to the @{" iostd " link IOStd} (standard input/output request).

Gregor Goldbach February 11th 1995
@endnode

@node Commands "Exec - Devices -- Device commands"
A device has a set of basic commands that can be found in every device. This
consists of:

  CMD_ILLEGAL       well... actually it does nothing
  CMD_RESET         reset the printer etc.
  CMD_READ          read a track, read keyboard input etc.
  CMD_WRITE         print text, play a sample, speak text etc.
  CMD_UPDATE        save the contents of the track buffer etc.
  CMD_CLEAR         clear all buffers
  CMD_STOP          stop with what you're doing
  CMD_START         you may continue now
  CMD_FLUSH         delete all request that follow

This basic set must be provided, however, the command may do just nothing if
that command is senseless for this device.

Naturally this set can be extended, read the device chapter for its commands.

Gregor Goldbach February 11th 1995
@endnode


@node IOStd "Exec - Devices -- The standard I/O request
In @{" exec/io.m " rx "AEE:ARexxScripts/ShowModulePart.rexx EMODULES:exec/io.m 13 24"} we can find the definition of iostd, the standard iorequest.

  mn:mn

  An exec @{" message " link "messages.guide/main"}.

  device

  A pointer to the [device] structure.

  unit

  A pointer to the @{" unit " link Unit} structure.

  command

  The @{" command " link Commands} to be executed. A simple number.

  flags

  Special flags for each device, look in the device's chapter for them. Only
  one flag is the same in all devices: IOF_QUICK. It tells the device to
  execute the command at once.

  error

  If something went wrong it is non-NIL.

  IOERR_FAIL        the device could not be opened
  IOERR_ABORTED     a command was aborted
  IOERR_NOCMD       unknown/illegal command
  IOERR_BADLENGTH   the length entry is kinda wrong

  actual

  After a CMD_READ this entry contains the number of bytes that could actually
  be read, for other commands according values will be found.

  length

  The length of the data that shall be used by the device, e.g. the length of
  the text that is to be printed.

  data

  A pointer to the data that shall be used by the device, e.g. the text that
  is to be printed.

  offset

  [more]


There is also a structure called 'io' which lacks the entries after error.
[more]

Gregor Goldbach February 11th 1995
@endnode

@node OBJECTDevice "Exec - Devices -- OBJECT device"
There's an OBJECT which has been created for convenience, it's called
'device'. With its help it's very easy to use a device. Here's the document
for its methods.

METHOD open of device

INPUTS

  name - PTR TO CHAR, the name of the device
  unit - the unit to be opened
  flags - the flags, set to NIL if unknown

DESCRIPTION

  Opens the unit of the device of the given name with the flags. The following
  exceptions may be raised:

    "dev", -2   CreateMsgPort() failed
    "dev", -3   CreateIORequest() failed
    "dev", -4   OpenDevice() failed

RESULTS

  TRUE if everything's fine.

---

METHOD close of device

DESCRIPTION

  Closes itself

---

METHOD end of device

DESCRIPTION

  Calls self.close()

---

METHODs doio, sendio, abortio

Calls the according exec.library functions.

Gregor Goldbach February 11th 1995
@endnode

@node Unit "Exec - Devices -- Unit"
A device can be used via several units, e.g. the 'trackdisk.device' provides
four units 0-3 (one per floppy drive). When it makes no sense to use more than
one unit - this is the case if you want to access the printer -, the unit is
usually set to 0. So to open the printer you have to say

  OpenDevice('printer.device',0 , iorequest, flags:=0)

(Keep in mind that you have to initialize the iorequest.)


This is what @{" exec/devices.m " rx "AEE:ARexxScripts/ShowModulePart.rexx EMODULES:exec/devices.m 8 13"} tells us about a unit:

  mp:mp

  The message port you have created before opening the device.

  flags:CHAR

  These are the flags you specified for this unit.

  pad

  Once again a pad byte to keep the boundaries even.

  opencnt

  How often was the device opened?


That was a basic unit structure that is equal in all devices. However, every
device may extend this structure for internal purposes. Since the programmer
who uses the device doesn't need anything that's in such a unit the contents
of it are of no interest, anyway.

Gregor Goldbach February 12th 1995
@endnode
