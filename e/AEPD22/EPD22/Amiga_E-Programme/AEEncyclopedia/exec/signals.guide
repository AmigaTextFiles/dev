@database exec/signals
@author Gregor Goldbach

@node main "Exec - Signals"
A simple communication method between tasks is implemented via signals. A task
can set and wait for signals - that's all. A task can wait for a signal that
says: "an input was made". It can then react on this input.

  @{" Allocation and Freeing " link Allocation}
  @{" Setting                " link Setting}
  @{" Waiting                " link Waiting}

Signals are used in communication via @{" message ports " link "message ports.guide/main"}.

You won't find an example in this guide but in the one stated above. I
thought it best to show the usage of signals in that context.

Gregor Goldbach January 25th 1995
@endnode

@node Allocation "Exec - Signals -- Allocation of signals"
Each task has a set of 32 signals. However, 16 signals are reserved for
internal purposes so only 16 signals can be used by the task itself. Before
you can use a signal you have to allocate it. This is done by calling the
function AllocSignal():

  signal := AllocSignal(signal_number)

signal_number is the number of the signal to allocate (0-31). The result is
the bit mask of the successfulyy allocated signal; if it is -1, the signal
could not be allocated.

To allocate one of the free signals you can call this function with the
argument -1 (this is usually done):

  signal := AllocSignal(-1)

You will then get the successfully allocated signal.


To free an allocated signal just call FreeSignal():

  FreeSignal(signal_number)

signal_number is the number of an allocated signal (0-31).

Gregor Goldbach January 24th 1995
@endnode

@node Setting "Exec - Signals -- Setting signals"
This function is one of the most important functions in the OS:

  Signal(task, signal_number)

It sets the task's signal. With this function inter-task communication is made
possible.

Gregor Goldbach January 24th 1995
@endnode

@node Waiting "Exec - Signals -- Waiting for a signal"
With the following function the task is set to 'wait'-state:

  Wait(signal_mask)

signal_mask is a long word. The number of the bit set is the number of the
signal to wait for. If the task shall wait for signal number four, the mask
would be %1000. Since the argument is a mask, several signals can be waited
for: %10010 would be the mask if the task should wait for either signal number
16 or signal number 2.

NOTE: Wait() returns if at least one message has arrived, i.e. when Wait()
returns more than one message may have arrived at the port. Example:

Our task waits for a message
Task one sends a message to our port    -> Msglist contains 1 msg
Wait() returns
Our task gets it                        -> Msglist contains 0 msgs

Task two sends a msg to our port        -> Msglist contains 1 msg
Task three sends a msg to our port      -> Msglist contains 2 msgs

We reply the first msg
Wait() returns at once
We get the msg                          -> Msglist contains 1 msg

We wait() for a msg                     -> Msglist still contains 1 msg!
Task one sends a msg                    -> Msglist does contain 2 msgs
Wait() returns
...

So if Wait() returns we have to check by ourselves if there's more than one
message at the port. This can be done via calling GetMsg() in a WHILE-loop
for GetMsg() returns NIL if there's no message:

  Wait(signal mask)

  WHILE(message := GetMsg(port))
    do_action(message)
    ReplyMsg(message)
  ENDWHILE

Gregor Goldbach January 25th 1995
@endnode

@node index "Exec - Signals -- The Index"

  @{" Allocation and Freeing " link Allocation}
  @{" Setting                " link Setting}
  @{" Waiting                " link Waiting}

Gregor Goldbach January 24th 1995
@endnode
