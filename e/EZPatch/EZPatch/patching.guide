@database 00544e40-0
@master src:setfunc/ezpatch/patching.guide
@$VER: 1.0
@author "Dobes Vandermeer"
@(c) "1996"
@index HeddleyAutoIndex
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" "Patching.guide"
@next "Introduction"
@prev "Distribution"




Easy Patching for E v1.0     Docs       © 1997 by Dobes Vandermeer
------------------------     ----       --------------------------
                          @{"Introduction" link "Introduction" 0}
                          @{"Distribution" link "Distribution" 0}
                           @{"Disclaimer" link "Disclaimer" 0}
                          @{"Installation" link "Installation" 0}
                           @{"Copyright" link "Copyright" 0}
                             @{"Usage" link "Usage" 0}
                            @{"Problems" link "Unsolved problems" 0}
                             @{"Author" link "Author" 0}


+----------------------------------------------------------------+
@endnode

@node "Usage" "Using my easy patching object"
@next "Unsolved problems"
@prev "Installation"

   Usage
   -----

   The main part of the package is the module, 'patch.m'.  You must link
this in with your E code.  After that, you must create and allocate a
patch object for each function you wish to patch, and each patch for that
function.  After that, you may use the following methods:

   Methods
   -------
      @{"patch.init(libbase, offset, newfunc [, call=1])" link "init" 0}
      @{"patch.install()" link "install" 0}
      @{"patch.remove()" link "remove" 0}
      @{"patch.end()" link "end" 0}
@endnode

@node "Introduction" "Introduction to my easy object"
@next "Installation"
@prev "Main"
   Introduction
   ------------

   This package is intended to greatly simplify patching library
functions.  I wrote it because I tried to write a program for patching a
library function, but I ran into many problems, and decided that I would
create an object to handle everything for me.  It is not totally complete,
I guess, but it is functional.
   If you've done/looked into patching packages before, you have probably
sen that they often use semaphores or counters which have to be
incremented by your program.  This takes care of all that.  On the other
hand, it has some @{"problems" link "Unsolved problems" 0}, too, which you should look up.


   @{"Installation" link "Installation" 0}
   @{"Usage" link "Usage" 0}
@endnode

@node "Distribution" "Distribution"
@next "Main"
@prev "Disclaimer"

   Distribution
   ------------

   This package and it's files may be distributed freely so long as the
following conditions are met:

   1. The files carried with this document are left unchanged in the
distribution.

   2. None of the files carried with this document are left out.

   3. This software and any medium carrying it is never sold for more than
the price of $20 US Dollars.


   If any of these conditions cannot be met, exceptions may be made with
permission of the author.
@endnode

@node "Disclaimer" "Disclaimer"
@next "Distribution"
@prev "Copyright"

   Disclaimer
   ==========

   I, the author, hereby take no responsible for any damages or extra
costs incurred, caused, or otherwise by this program.  I take no
responsibility for any undesirable effects achieved through use of this
program.  I only take responsibility for things this program does that are
desirable.
@endnode

@node "Copyright" "Copyright"
@next "Disclaimer"
@prev "Author"

   Copyright
   =========

   This software/package is copyright © 1997 Dobes Vandermeer.  It may not
be sold or distributed in such a way that an amount of currency exceeding
$20 US will be given to the distributing party.  Any software using this
package must not have a price/registration fee of greater than $20 US, and
I should receive a registered copy of that program at no charge.  If you
find these conditions unreasonable, I might be flexible if you present
your case.
@endnode

@node "Installation" "Installation"
@next "Usage"
@prev "Introduction"

   Automated Installation
   ----------------------

   To install, click on the install icon, or run it as an argument to the
installer command.

   Manual Installation
   -------------------

   Copy the EMods directory to the emodules: directory, i.e.:

   > Copy EMods emodules: all

   Copy or move the entire directory to e:src or any other directory you
want, for reference.

   You may also copy this .guide file to e:docs/
@endnode

@node "Unsolved problems" "Problems"
@next "Author"
@prev "Usage"

   Problems/Notes/Bugs
   -------------------

   - A4 will be changed when your function is called.  If you need A4 as
an arg, you'll have to re-write the system a bit, to pass A4 as an arg.  I
guess I could do this pretty easily, if you asked me.

   - I haven't found a usable way to call the old function from within the
function.  I am working on it, but if you find a way, mail it to me, and
I'll include it in another release of this archive.

   - This may not work with some dos.library functions.
@endnode

@node "Author" "Author"
@next "Copyright"
@prev "Unsolved problems"

   Please send any comments, suggestions, post-cards, etc. to:


   Snail Mail               E-Mail
   ==========               ======
   Dobes Vandermeer         dobes@prcn.org
   RR2 Southview Rd.
   Powell River, BC
   Canada
   V8A 4Z3

     OR

   Dobes Vandermeer
   RR2 Wild Rd.
   Powell River, BC
   Canada
   V8A 4Z3
@endnode

@node "init" "Initilialize"
NAME
   init -- Initialize patch object

SYNOPSIS
   patch.init( libbase, offset, func [, call=1])

FUNCTION
   This procedure will initalize the patch structure in preparation for
use.

   Note the replacement function will be in the format:

   PROC myfunc(oldfunc, patch)
      DEF <vars>              -> Define ALL args here
      DEF lib
      MOVE.L <reg>, <var>     -> Do this for EVERY arg (in the registers)
      MOVE.L A6, lib          -> Save libbase

      /* your code */

      MOVE.L <var>, <reg>     -> DO this for EVERY arg
      MOVE.L lib, A6          -> Restore libbase
   ENDPROC

   oldfunc will be the address of the original function, and patch will be
the patch which this function is associated with.  You could even use the
same function in two patches, although I suspect that might crash if both
were used simultaneously.

INPUTS
   libbase  -- Library base of open library
   offset   -- Function offset (You can find it in the emodules:
               directory, or by using @{"getoff" link "getoff" 0})
   func     -- Replacment function
   call     -- Whether to call the original function at exit
               (See @{"Problems" link "Unsolved problems" 0})

RESULT
   none.

EXCEPTIONS
   PATCH_IN_USE   -- This patch is currently installed, and is being
                     executed.
   MEMORY_ERROR   -- Probably ran out of memory
@endnode

@node "install" "Patch Installation"
NAME
   install

SYNOPSIS
   patch.install()

FUNCTION
   This installs the new function in place of the old.

INPUTS
   None

RESULTS
   None

EXCEPTIONS
   MEMORY_ERROR    -- Unable to allocate jump entry (6 bytes!)
   NOT_INITIALISED -- Object was not initialised before you tried to
                      install it.
@endnode

@node "remove" "Removal"
NAME
   remove

SYNOPSIS
   dbl := patch.remove()

FUNCTION
   This waits for any currently executing patches to complete and then
removes it, restoring it to the previous value.

INPUTS
   none

RESULT
   Will return DOUBLE_PATCHED if another application has patched your
function.  Otherwise, it will return NIL.

EXCEPTIONS
   NOT_INITIALISED   -- Patch has has not been completely initialised, or
                        has not been installed
@endnode

@node "end" "Destruction"
NAME
   end

SYNOPSIS
   END patch

FUNCTION
   Destroys and de-allocates allocated data.

INPUTS
   none

RESULT
   none

EXCEPTIONS
   none
@endnode

@node "getoff" "getoff"
@next "init"
@prev "init"

   getoff
   ------
   getoff is a little script I have included for looking up function
offsets.  To get the offset, use:

   getoff <library> <funcname>

   <funcname> can be a partial string or whatever, because the engine is
so simple.

   It requires that you have the commands "search" and "showmodule" in
your path.
@endnode

@node HeddleyAutoIndex "Index"
@remark Index auto-generated by Heddley
Index of database 00544e40-0

Documents

@{"Author" link "Author"}
@{"Copyright" link "Copyright"}
@{"Destruction" link "end"}
@{"Disclaimer" link "Disclaimer"}
@{"Distribution" link "Distribution"}
@{"getoff" link "getoff"}
@{"Initilialize" link "init"}
@{"Installation" link "Installation"}
@{"Introduction to my easy object" link "Introduction"}
@{"Patch Installation" link "install"}
@{"Patching.guide" link "Main"}
@{"Problems" link "Unsolved problems"}
@{"Removal" link "remove"}
@{"Using my easy patching object" link "Usage"}

Buttons

@{"Author" link "Author" 0}
@{"Copyright" link "Copyright" 0}
@{"Disclaimer" link "Disclaimer" 0}
@{"Distribution" link "Distribution" 0}
@{"getoff" link "getoff" 0}
@{"Installation" link "Installation" 0}
@{"Introduction" link "Introduction" 0}
@{"patch.end()" link "end" 0}
@{"patch.init(libbase, offset, newfunc [, call=1])" link "init" 0}
@{"patch.install()" link "install" 0}
@{"patch.remove()" link "remove" 0}
@{"Problems" link "Unsolved problems" 0}
@{"Usage" link "Usage" 0}
@endnode
