============================================================================

                         EPP V1.1.  E Preprocessor.
             Copyright ©1993 Barry Wills.  All rights reserved.


============================================================================


DISTRIBUTION.
~~~~~~~~~~~~
   This product may be freely distributed under the following restrictions:

   1.  The complete contents of the original archive must remain intact.
   2.  The original material may in no way be modified. (See P.S at the end
       of this document for extenuation of this term.)
   3.  This product may not be distributed for profit.  A nominal copying
       fee is authorized (for cost of materials and shipping and handling
       comparable to that charged by Fred Fish.)
   4.  Commercial distribution of this product without written permission
       from the author is forbidden.



USE OF THIS PRODUCT.
~~~~~~~~~~~~~~~~~~~
   This product may be used under the following restrictions:

   1.  Non-commercial use of this product is free of charge.
   2.  Commercial use of this product without written permission from the
       author is forbidden.  This includes shareware.
   3.  Honorable mention of the author and product must be included in the
       client documentation (non-commercial and licensed-commercial.)
   4.  This product may not be used for malicious intent.



DISCLAIMER.
~~~~~~~~~~
   This product is provided without any warranty, express or implied.  The
   user of this product assumes full responsibility for any damage resulting
   from the use and/or misuse of this product.



CONTENTS.
~~~~~~~~
   This archive should contain the following files:

     EPP          - Executable V1.1.
     EPP.doc      - Copyright notice and product information (this file).
     EPP.e        - V0.13b source.
     EPP.history  - Revision history.
     EPP_Example1 - Directory containing an example EPP project.
     EPP_Example2 - Directory containing an example EPP projects, and module
                    tests and demos.
     Fishcon.txt  - Short program description.
     Readme_First - Getting started.
     Pmodules/*   - example real-world modules.


============================================================================


WHAT'S NEW?
~~~~~~~~~~
   ·  More speed!  Thanks to Son Huu Le, who rearranged EPP's parsing
      algorithm!

   ·  Fixed bug in the Turbo routine.  Turbo was eating modules if the
      default buffer size was not used.

   ·  Added an OPT TURBO directive to turn on Turbo mode for the duration of
      the invoking module.  This is good if you want fast processing, but
      still want to see the progress messages for part of the project.

   ·  New PModules!  Modules names cSkip* are optimized for speed and may be
      used instead of the original skip* modules.  (This will require changes
      to your main programs!  Read the comments in the modules to find out
      how to use them properly.)  The old versions are still provided for
      die-hards.  I will not distribute the old versions in future releases
      (unless I forget to remove them :)

   ·  Fixed bug in read() that dropped last line of a module if the line
      did not end with a linefeed (ascii 10).  No more program crashes due
      to this error. :)

   ·  Replaced calls to write() with Write() for speed.

   ·  Modified program to process CtrlC().

   ·  Son Huu Le modified appendProcsToDefs() for speed and cosmetics.


REQUIREMENTS.
~~~~~~~~~~~~
   An Amiga with at least 1Meg of RAM.  I have tested EPP inside of about
   500K, and EPP processed itself with room to spare.

   Of course, you will also need Wouter van Oortmerssen's Amiga E V2.1b or
   better.  At the time of this release, Amiga E V2.1b is the most recent.
   (NOTE: the Amiga E compiler requires at least 1Meg of RAM to be able to
   do anything meaningful.)

   EPP should not be KickStart sensitive.



DESCRIPTION.
~~~~~~~~~~~
   EPP is an E project development tool which allows an E application to be
   developed in a modular fashion.  Use of this tool contributes towards
   some important software engineering concepts, such as reusability and
   modularity.  Anyone who has tried to write a respectable application in a
   language which doesn't support modules can attest to the unwieldiness of
   a huge main program file.  And anyone who has written multiple
   applications in a language which supports modules can attest to the
   luxury of being able to reuse source components without having to block-
   copy source code from several locations.

   Wouter van Oortmerssen, the author of E, has promised to support user
   modules in a future release.  The release of EPP does not presume that he
   will not make good on his promise.  On the contrary, I am eagerly awaiting
   it!  But in the meantime, EPP can do the basics, and hopefully the
   appearance of EPP will allow Wouter to concentrate on the more important
   (I think) features of the language:  floating point support and OOP.  Much
   care has been taken to ensure that EPP remain simple enough that only
   minimal changes should be required to E source code in order to become
   compatible with future releases of E which incorporate modules.  At that
   time, EPP may respectfully retire.


           »»»»»  ENOUGH!!!  HOW DO I USE THIS THING???  «««««



USAGE.
~~~~~
   Invocation:  EPP -l### -b### -s -t infile[.e] outfile[.e]

   · infile = filename of the main program, '.e' extension is optional.
   · outfile = filename of the processed program, which will
     (hopefully) be suitable for compilation with ec, the E compiler.
   · -l### = maximum expected source line length; increase for longer lines.
     Valid range is 20 to MAX_LONG_INTEGER, default is 128.
   · -b### = input buffer size in bytes; use size of largest source file for
     maximum speed, decrease if memory is low.  Valid range is 20 to
     MAX_LONG_INTEGER, default is 128.
   · -s = silence progress messages (except for error messages).
   · -t = Turbo mode; read the "NOTE ON TURBO MODE" in the section "PROGRAM
     STRUCTURE" before using this switch!


   EPP allows primitive inclusion of user pseudo-modules.  EPP pseudo-
   modules are E source code.  EPP is similar to a very primitive C
   preprocessor in that it merges source code as specified by module
   inclusion directives entered into the source code.  Module inclusion
   directives use the following notation:


     PMODULE 'dev:path/filename'


   The keyword PMODULE is required.  The optional 'dev:' is any valid
   logical DOS device.  'Path' is the optional subdirectory in which the
   module can be found.  'Filename' is the name of the module file without
   the '.e' extension.  The '.e' extension is added automatically by EPP.
   (NOTE:  EPP does not use a default logical device or directory to locate
   modules.  The device and path must always be specified if the modules are
   not in the current directory.)

   EPP will merge all global declarations in the order of dependency as
   determined by the PMODULE statements:  first come, first serve.  EPP will
   then merge all procedures and functions in the same order.

   The final output file contains all modules' comments.  Additional module
   information is inserted at strategic locations by EPP if the -c switch is
   specified on the command line.  Runtime progress messages are sent to
   stdout, unless the -s switch is specified on the command line.



PROGRAM STRUCTURE.
~~~~~~~~~~~~~~~~~
   PMODULE statements can be put anywhere (see the "NOTE ON TURBO MODE"
   below for a caveat.)  The only thing you have to mind is that the modules
   containing types, constants, and variables needed by subsequent modules
   must be included first, otherwise EC will inform you of the error.  The
   general format of a main program is:


     PMODULE 'mod1'[; ...]  /* Containing types and/or procs. */

     [Global defs and decls...]

     PMODULE 'anothermod'[; ...]  /* Containing types and/or procs. */

     PROC identifier ()
       ...
     ENDPROC

     PMODULE 'moremods'[; ...]  /* Containing types and/or procs. */

     PROC main ()
       ...
     ENDPROC
       /* END OF MODULE. */


   As you can see, you have a lot of flexibility in placement of modules.
   EPP locates any module declarations at the front of the final output file,
   and the procedures are inserted at the place of module declaration.
   Pseudo-modules MAY BE NESTED AS DEEPLY AS RESOURCES WILL PERMIT, i.e., as
   long as you have enough stack and memory you can have PMODULEs within
   PMODULEs within PMODULEs...

                          *    *    *    *    *

   NOTE ON TURBO MODE:  Turbo mode does *not* recognize PMODULE statements
   that occur after the first PROC statement in a module.  Turbo mode does
   *not* check for duplicate PROC main()s in modules.  The reason for this
   is speed.  Turbo mode does *NO PARSING* of the procs section of modules.

   The OPT TURBO directive starts TURBO mode within a single module for the
   duration of that module.  It can be placed anywhere in a module outside
   of a PROC..ENDPROC.  The Turbo routine will be invoked upon the next
   occurrence of the PROC keyword.  OPT TURBO must, of course, be uncommented.
   It may be placed as far down in the module as desired.  Only one OPT TURBO
   directive should be used within a module file since subsequent occurrences
   will not be parsed once the Turbo routine is invoked, and EC will not
   recognize "OPT TURBO".


                          *    *    *    *    *

   See the two examples directories supplied with this package.  EPP_Example1
   attempts to simulate the structure of a real project.  EPP_Example2
   contains examples of how to use some of the modules provided in the
   PModules directory.



OTHER CONSIDERATIONS.
~~~~~~~~~~~~~~~~~~~~
   EPP is *NOT* like the COBOL COPY statement.  Any global definitions and
   declarations in a module are moved to the global section of the main
   program.

   EPP tries to be smart about what it is reading.  It is not, however, a
   full-blown syntax checker.  EPP relies on good syntax in your modules, so
   you should test modules for syntax before using them with EPP.  This will
   reduce the risk of brain damage. :)

   EPP allows you to keep a PROC main() in all modules to facilitate ease
   of testing.  Any PROC main() encountered in modules other than the main
   module are omitted, and, if EPP comments are turned on, an E comment is
   inserted in the final output file to indicate this.  This can be quite
   handy while testing a module since E requires a PROC main() in order to
   compile the module.  EPP saves you the hassle of commenting and
   uncommenting code in your source module during development.  (HINT:  place
   all test PROCs after PROC main() and EPP will ignore them.  Likewise, if
   you want PROCs recognized by EPP, don't put them after a PROC main() in
   your modules.)  THIS FEATURE IS NOT AVAILABLE IF YOU CHOOSE TO USE THE
   TURBO OPTION IN A MODULE.  (HINT:  use the OPT TURBO directive in modules
   that don't need this feature to speed up processing.  Duplicate PROC
   main()s will still be omitted in modules not using OPT TURBO.)

   Since EPP is simply a sophisticated text file merger, it is up to you to
   ensure that all your modules' identifiers are unique.  If they are not,
   the E compiler will inform you of the duplicate identifiers.

   CAUTION:  In the instructions for compiling the examples (the file
   Readme_First.doc) the output file main.e is used.  You are not restricted
   to using this name as the final output name.  You are encouraged, however,
   to come up with a personal convention for naming the final output file.
   That way you will not risk accidentally overwriting your original source.
   One suggestion is to set up a separate directory to receive the final
   output file and compile it there:  a directory in RAM: or RAD: is ideal
   for this, and you could easily set up a script to make the process less
   unwieldy.

   CAUTION:  The default line length should be adequate for most programs.
   However, line length must be large enough to accommodate the longest line
   of source.  If a line is split, a keyword or a comment delimiter could be
   missed, and your source output may be chewed.  If EPP is producing strange
   output, check the length of your lines before reporting a possible bug.


============================================================================


LIMITATIONS.
~~~~~~~~~~~
    · If you like to put comments outside of PROCs you will notice that some
      of them don't end up where you'd like, especially those that follow
      the global declarative section.  See Example1 project, module 'mod2.e'
      for a demonstration of this phenomenon.  EPP thinks that everything
      before the first PROC belongs to the global declaratives.  (HINT:  keep
      your modules small and put your comments *inside* the PROC, immediately
      following the headers.)




TO DO (MAYBE).
~~~~~~~~~~~~~
    · Macro expansion of identifiers.
    · Macro selection of source code (as in #ifdef ... #endif)
    · Optional exclusion of comments in final source output.


============================================================================


MISCELLANEOUS.
~~~~~~~~~~~~~
This product was developed in Amiga E language and tested on a Commodore
Amiga 500 with the following configuration:

   KickStart V1.3, WorkBench V1.3, ©Commodore-Amiga, Inc.
   Amiga E V2.1, ©Wouter van Oortmerssen
   AZ V1.50, ©Jean-Michel Forgeas

   DataFlyer 500 SCSI controller
   Quantum 52M HD
   Dual 880K floppy drive
   1M 16-bit Chip RAM
   CSA Derringer 030 accellerator:
      68030 CPU @25MHz
      68881 FPU @27MHz
      4M 32-bit Fast RAM


============================================================================


CREDITS.
~~~~~~~
Special thanks go to:

  · Wouter van Oortmerssen for Amiga E!  (And for revealing to me the
    insidious, ubiquitous, sideways smiley face :)

  · Jean-Michel Forgeas and The Software Winery for their AZ text editor!

  · Son Huu Le for his testing, analysis, and modifications.  If it weren't
    for his initiative, EPP would probably still be taking its own good time
    (and yours, too! :)


============================================================================


CONTACTING THE AUTHOR.
~~~~~~~~~~~~~~~~~~~~~
I can be reached by the following means:

  Internet:  bwills@kirk.safb.af.mil

  USnail:    Barry Wills
             5528D Pryor Dr.
             Scott AFB, IL 62225 (USA)
             (618)-744-1096

I wrote this for my own use, but I hope you get as much use out of it as I
do.  Send mail, money, software, warm weather to the address(es) above.  I
am very interested in feedback; I will answer all mail.  Good luck and
enjoy!

  -- Barry



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                »»»»»  Join the Amiga E mailing list!  «««««

                             Email the words
                          "Please subscribe me!"
                    to amigae-request@bkhouse.cts.com.

               Get in tune with Life, the Universe...and E!

               ("Those are in the wrong order," says Wouter.
                  But I didn't want to obscure the pun! :-)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


P.S - Distributers and users of this program are hereby granted the right to
replace the letters of the singly occurring expletive "shitloads" (now doubly
occurring) with asterisks (*), character for character, if it so offends
them.  This is the only permitted change to the package contents.  A package
so changed MAY BE DISTRIBUTED IN THAT MODIFIED FORM (although there are some
out there who would feel cheated if they couldn't figure out just what that
darn word was before somone axed it!)  This amendment is intended for the
convenience of G-rated BBSs.  (Those receiving this package in its censored
form may contact me and I will reveal to them the original word so they can
change it back :)


============================================================================
