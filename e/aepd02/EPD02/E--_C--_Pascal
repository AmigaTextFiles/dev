
            E-->C-->Pascal
            --------------

    Wouter hat hier eine Gegenüberstellung von Amiga_E zu C und
    Pascal gemacht.

    Ich hoffe, Ihr könnt hier heraus auch noch was lernen, oder?
    JCL_Power

-------------------------------------------------------------------------

Hello all,

In some articles for this list I'd like to address some common
problems that people might have with E, for example working with
OBJECTs. Now I will discuss E in general with repect to C, for
people translating sources.

have fun with it,

Wouter.


-----------------------------------------------------------------------

               Amiga E in terms of C/C++/Pascal etc.

This document is intended as yet another way to understand E, especially
for those who already know another language, like C, and it may also be
a guide for people translating to/from E.
I personally always find it enlightening to see constructs of the
language I'm learning as equivalent in a language I know already, and
I know others do too.

In the first/second column I will match E against AnsiC/C++, the third
column is reserved for a third language. I will mainly use Pascal here,
but where a feature asks for it, I will use others (for example, LISP
with quoted expression, Ada with exceptions etc.

note well: take these tables with a grain of salt. I'll try to denote
syntactic equivalences, and semantic properties as well as possible,
but different languages still need their own evaluation.

if you see errors in the translation, please let me know (especially
my Pascal knowledge is somewhat rusty).

usage of signs:

-       = feature not available in language in question.
?       = author has no clue what this feature translates to.
          (or atleast he's not sure).
...     = feature may be available, but no appropriate 1:1 translation
          possible to make it interesting.
x,y,z   = arbitrary identifiers
e,f,g   = arbitrary expressions
s,t,u   = arbitrary statements
i,j,k   = arbitrary integers
etc.


-----------------------------------------------------------------------
STRUCTURE/STATEMENTS

E                       C/C++                   Pascal
----------------------- ----------------------- -----------------------
PROC x()                int x() {               FUNCTION x:INTEGER;
PROC x(y,z)             int x(y,z) {            FUNCTION x(y,z:INTEGER):INTEGER;
ENDPROC                 return 0; };            x:=0; END;
ENDPROC e               return e; };            x:=e; END;
RETURN e                return e;               ?

IF e                    if(e) {                 IF e THEN BEGIN
ELSEIF e                } else if(e) {          END ELSE IF e THEN BEGIN
ELSE                    } else {                END ELSE BEGIN
ENDIF                   };                      END;
IF e THEN s             if(e) s;                IF e THEN s;
IF e THEN s ELSE t      if(e) s else t;         IF e THEN s ELSE t;

FOR x:=e TO f           - (1)                   FOR x:=e TO f DO BEGIN
FOR x:=e TO f STEP i    -                       - (2)
ENDFOR                  -                       END;
FOR x:=e TO f DO s      -                       FOR x:=e TO f DO s;

WHILE e                 while(e) {              WHILE e DO BEGIN
ENDWHILE                };                      END;
WHILE e DO s            while(e) s;             WHILE e DO s;

s; WHILE e              for(s;e;u) {            s; WHILE e DO BEGIN
  t; u                    t;                      t; u
ENDWHILE                };                      END;

REPEAT                  do {                    REPEAT
UNTIL e                 } while(!e);            UNTIL e;

LOOP                    for(;;) {               WHILE TRUE DO BEGIN (?)
ENDLOOP                 };                      END;

INC x                   x++;                    x:=x+1; (INC())
DEC x                   x--;                    x:=x-1; (DEC())
JUMP lab                goto lab;               GOTO lab;
x:=e                    x=e;                    x:=e;

(1) see WHILE; C has no FOR, "for" in C is another way of writing "while"
(2) only STEP -1 as DOWNTO


-----------------------------------------------------------------------
VALUES

E                       C/C++                   Pascal
----------------------- ----------------------- -----------------------
1                       1                       1
1.0                     1.0                     1.0
$1                      0x1                     ?
%1                      ?                       ?
"a"                     'a'                     chr(97) (?)
'blabla'                "blabla"                'blabla'
[1,2,3]                 - (1)                   -
[1,2,3]:INT             -                       -

(1) in translating from E to C, you can often simulate them with:

myfunc([1,2,3])

becomes:

int dummy [] = {1,2,3};
myfunc(dummy);


-----------------------------------------------------------------------
OPERATORS

E                       C/C++                   Pascal
----------------------- ----------------------- -----------------------
+ - * /                 + - * /                 + - * DIV
= <> > < >= <=          == != > < >= <=         = <> > < >= <=
AND OR  (log)           && ||                   and or
AND OR  (bit)           & |                     ?
SIZEOF x                sizeof(x)               -
`e                      -                       - (1)
^x                      *x                      ...
{x}                     &x                      ...
x++                     x++                     -
x--                     --x                     -
-x                      -x                      -x
IF e THEN f ELSE g      e ? f : g               -
x.y                     x->y    x.y             x^.y    x.y
a:=x.y; a.z             x->y->z x.y.z           x^.y^.z x.y.z
x:=e                    x=e                     -
e BUT f                 (e,f)                   -
x[]                     x[0] *x (2)             x[0]
x[1]                    x[1]                    x[1]
x[1].y                  x[1]->y                 x[1]^.y
x[]++                   *x++                    -
x[1].y++                *(x+1)++                -

(1) see QUOTED EXPRESSIONS
(2) also for others, equivalences between *(x+e) and x[e] hold.


-----------------------------------------------------------------------
CONSTANTS/TYPES

E                       C/C++                   Pascal
----------------------- ----------------------- -----------------------
CONST X=1               #define X 1             CONST X=1;
                        const int X=1;
ENUM X,Y,Z              #define X 0 (etc.)      TYPE x=(X,Y,Z);
                        enum x{X,Y,Z};
SET X,Y,Z               -                       TYPE x=SET OF (X,Y,Z);

DEF                                             VAR
x                       int x; (or: long x;)    x:INTEGER;
x:LONG                  int x;                  x:INTEGER;
x:PTR TO y              struct y* x;            x:^y;
x:y                     struct y x;             x:y;
x[10]:ARRAY OF y        struct y x[10];         x:ARRAY [0..9] OF y;
x[10]:STRING            - (1)                   x:STRING[10]; (2)
x[10]:LIST              - (1)                   - (1)

OBJECT x                struct x {      (3)     TYPE x = RECORD
  y:CHAR,z:INT            char y; short z;        y:CHAR; z:INTEGER;
ENDOBJECT               };                      END;

(1) when translating from E to C, simulate with an array of char/int resp.,
    and do your own range-checking etc.
(2) no Wirth Pascal, but available in all popular dialects.
(3) or public class ofcourse...


-----------------------------------------------------------------------
QUOTED EXPRESSIONS

E                       LISP                        MIRANDA
----------------------- --------------------------- -------------------
`e                      (QUOTE e)  'e               ?
                        (LAMBDA () e)     (1)
`x+y                    '(+ x y)
Eval(`e)                (EVAL `e)
ForAll(v,l,`e)          - (2)
MapList(v,l,l,`e)       (MAPCAR (LAMBDA (V) E) L)   map (\v->e) l

example:

E:              MapList({x},[1,2,3,4],a,`x*x)
MIRANDA:        map (\x->x*x) [1,2,3,4]
LISP:           (MAPCAR (LAMBDA (X) (* X X) `(1 2 3 4))

(1) really QUOTE, but sometimes used where in LISP LAMBDA would be
    used, like in MapList()
(2) not even in ProLog, see other logical languages.


-----------------------------------------------------------------------
EXCEPTIONS

E                       C++                     ADA
----------------------- ----------------------- -----------------------
PROC x() HANDLE         int x() { try {         function x is begin
EXCEPT                  } catch (exc) {   (1)   exception
ENDPROC                 }};                     end x;

Raise(e)                throw e;                raise e;
RAISE "MEM" IF New()=0  -                       - (2)


(1) catch handles only one specific exception, it's quite different
    from general exception handlers as used in E.
(2) the runtime system does raise some exceptions, but I'm not sure
    wether automatically raised exceptions can be defined in Ada.


-----------------------------------------------------------------------
BUILTIN FUNCTIONS
(only a few are presented here, as an example)

E                       C/C++                   Pascal
----------------------- ----------------------- -----------------------
WriteF(fs,...)          printf(fs,...);         WriteLn(a,b,...);
                        cout << a << b ... ;

ReadStr(f,s)            scanf(fs,...)           ReadLn(s)
Val(s,n)                                        Val()
                        cin >> s;

StrCopy(s,s,n)  (1)     strcpy(s,s)             s:=s;

p:=New(e)               p=malloc(e);            New(p);
                        p=new type;
Dispose(p)              free(p);                Dispose(p);
                        delete p;

Mod(e,e)                e%e                     e MOD e
Shl(e,n)                e<<n                    Shl()
Long(e)                 -                       -

(1) when translating from C, make sure you turn the arrays of char into
    proper STRINGs.


-------------------------------EOF--------------------------------------
