Compiler Version.: 2.1b
Art .............: Interpreter für die Programmmiersprache YAX
Autor ...........: Wouter van Oortmerssen


    Dieses ist die neue Version 1.2 des Yax-Interpreters.
    Wouter hat viele neue Funktionen integriert. Die Beschreibung hierzu
    ist im folgenden enthalten. Die neuen Funktionen sind am Ende
    beschrieben.


                +---------------------------------------+
                |                                       |
                |       Amiga YAX Interpreter v1.1      |
                |                                       |
                |            (c) 1992/93 $#%!           |
                |              M A N U A L              |
                |                                       |
                +---------------------------------------+

                        1. Introduction
                        2. The Language
                        3. Built-in Functions

                +---------------------------------------+
                |       1. Introduction                 |
                +---------------------------------------+

update from v0.x/1.0 to 1.1:
bug fixes:
- negative number division failed!
- box accepted illegal values

update from v1.1 to 1.2:
- new functions, see below.

YAX stands for "Yet Another Instruction Code Set", as the author couldn't
think of better name. YAX is a procedural language with LISP-syntax and
evaluation, as well as somewhat lambda function application.

In this manual it is assumed the reader possesses knowledge of other
languages, as all 'obvious' explanations are left out. Readers for whom
YAX would be their first programming language are advised to read
a standard text on the subject  8-).

                +---------------------------------------+
                |       2. The Language                 |
                +---------------------------------------+

Structure.
The basic building block of a YAX program is called a term.
Examples of terms are:

integer constants:      1 2 100 -1
string constants:       'a' 'hi folks!'
variables:              a count
function calls:         (+ 1 2) (* 3 (- 4 5))

a function call is a list '()' with as first item the name of the
function to be applied, followed by its arguments. With few execeptions,
arguments to functions are again terms, so expressions may be built
to infinite complexity. The main task of the interpreter is to
evaluate these terms recursively.

Format.
between any two lexical elements, any number of spaces, tabs and linefeeds
may be placed. Comments start with '/*' and end with '*/', may extend
over several lines, and may be nested. following two statements are equal:

(if(eq a 1)(for b 1 10(write'blabla')))       /* ugly */

(if (eq a 1)
  (for b 1 10 (write 'blabla'))               /* better */
)


                +---------------------------------------+
                |       3. Built-in Functions           |
                +---------------------------------------+

If not explicitly stated, functions return 0. type of arguments:

<term>          any term
<iterm>         term that evaluates to integer
<sterm>         term that evaluates to string
<var>           term that is a variable
<svar>          term that is a string variable
<func>          term that evaluates to a function
...             any number of terms of the same type may follow

                           --> INTEGER MATH <--

(add <iterm> ...)     or    (+ <iterm> ...)
(sub <iterm> ...)     or    (- <iterm> ...)
(mul <iterm> ...)     or    (* <iterm> ...)
(div <iterm> ...)     or    (/ <iterm> ...)

(and <iterm> ...)
(or <iterm> ...)
(not <iterm>)

(eq <iterm> ...)
(uneq <iterm> <iterm>)
(smaller <iterm> <iterm>)
(greater <iterm> <iterm>)

These functions perform the functions you'd expect them to do.
All boolean logic functions return true (-1) or false (0). and/or/not
work as logical as well as bitwise operators.
except for the last three, all functions handle any number of arguments,
i.e.  (eq 10 (+ 1 2 3 4) (* 2 5))  is a valid term.

                         --> PROGRAM STRUCTURE <--

(for <var> <iterm> <iterm> <term> ...)
(if <boolexp> <ifterm> <elseterm>)
  /* also returns value of term */
(do <term> ...)
(select <iterm> <term> ...)
  /* <iterm> is matched agains even items of <term>s, and
     corresponding odd <term> is executed */
(while <term> <term> ...)
(until <term> <term> ...)
(set <var> <term>)

(defun <var> (<var> ...) <term> ...)
(lambda (var ...) <term> ...)
   /* returns function as value (may only be used in (set) and (apply) */
(apply <func> <term> ...)

(array <var> <iterm>)
(string <var>)


                           --> INPUT OUTPUT <--

(write <term> ...)
(locate <iterm> <iterm>)
(cls)
(window <iterm> <iterm> <iterm> <iterm> <sterm>)

(tell <sterm>)                  open a file for writing
(told)                          close file
(see <sterm>)                   open a file for reading
(seen)                          close file
(filelen <sterm>)               get filelength

(readint)                       read an integer
(read <svar>)                   read a string
(get)                           read one character
(put <iterm>)                   write one character

(dump)                          show all variables


                             --> GRAPHICS <--

(line <iterm> <iterm> <iterm> <iterm> <iterm>)
(plot <iterm> <iterm> <iterm>)
(box <iterm> <iterm> <iterm> <iterm> <iterm>)
(text <iterm> <iterm> <iterm> <iterm> <sterm>)
(mousex), (mousey)              intuition
(mouse)                         non-intuition



NEW IN VERSION 1.2:
- changes to existing functions:
    (>) as equivalent for (greater)
    (<) as equivalent for (smaller)
    (array <var> <size> <iterm> ...)    /* inits array with <iterm>s (opt) */
    (set <stringvar> <sterm>)
- additional functions:
  math etc.:
    (abs <iterm>)
    (mod <iterm> <iterm>)               /* (mod 20 3) => 2 */
    (eor <iterm> ...)
    (swap <var> <var>)                  /* currently vars only */
    (power <iterm> <iterm>)             /* (power 2 5) => 32 */
    (inc <var>)
    (dec <var>)
  system:
    (kick <iterm>)                      /* (if (kick 37) ... ) */
    (exit)
  control:
    (when <bterm> <term> ...            /* (if <bterm> (do <term> ...)  */
             else <term> ...)           /*             (do <term> ...)) */
  input/output:
    (hex <iterm>)                       /* writes num in hexadecimal */
  intuition:
    (req <sterm> <sterm> <sterm>)       /* (req 'YAX req' 'choose:' 'a|b|c') */
    (screen w h d flags title)          /* opens screen */
    (win x y w h IDCMP flags title)     /* opens gfx-only window and closes
                                           any previous w. if (screen) was
                                           used, (win) opens on it */
    (gadget id x y width title)         /* makes gadget on cur. window */
    (message)                           /* Wait()s and returns IDCMP */
    (gadid)                             /* returns gadnum in event */

  NOTE: now that there's (win) and (screen), graphics and intuition
        functions should not be used on windows opened with (window)
        (these are for stdio only), it will be possible however to use
        graphics functions on them for backward compatability with 1.1.


POSSIBLE ENHANCEMENTS:
- true lambda's for function calls

ben:
- string commands
- run another yax prog from yax code
- (see) twice --> problems? better file support.
- yax compiler (to E)





