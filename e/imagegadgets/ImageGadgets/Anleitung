@DATABASE "Anleitung.guide"
@REMARK $VER: Imagegadgets-Anleitung.guide 1.0 (14.12.96)
@NODE MAIN "Imagegadgets V1.0"

	@{" Allgemeines               " LINK Allgemeines}
	@{" Programmautor             " LINK Autor}

	@{" Programmieranleitung      " LINK Funktionen}
          @{" gcc_InitImageGadgets()  " LINK F1}
          @{" gcc_InitDiskImage()     " LINK F2}
          @{" gcc_RemoveDiskImage(nr) " LINK F3}
          @{" gcc_CreateGetFileA()    " LINK F4}
          @{" gcc_InstallGetFileA()   " LINK F5}
          @{" gcc_CreateGadgetA()     " LINK F6}
          @{" gcc_SetGadgetAttrsA()   " LINK F7}
@ENDNODE

@NODE Autor "Programmautor"


 Ich habe dieses Module nach bestem Wissen und Gewissen geschrieben.
 Es läuft bei mir fehlerfrei, trotzdem übernehme ich keine Garantie.
 Die Benutzung dieses Modules erfolgt auf eigenes Risiko! Der Autor
 haftet nicht für eventuelle Schäden.


   Ich bitte um Kritiken und/oder Verbesserungsvorschläge!

   E-Mail:  alexander.zopf@cks1.uni-rostock.de
            mbzoal@hsw-serv.hs-wismar.de
@ENDNODE

@NODE Allgemeines "Allgemeines"

 Was ist das?
 ------------
 Dieses Module ermöglicht es, schnell und unkompliziert ImageGadgets
 zu erzeugen. Dabei stehen schon 3 Typen von GetFile-Gadgets zur Ver-
 fügung, und es können problemlos auch eigene Images eingebunden
 werden. Die erzeugten Gadgets sind echte GadToolsGadgets, d.h. die
 neuen Systemfunktionen können fast alle genutzt werden.


 WICHTIG!!!
 ----------
 Die Gadget-Struktur bietet mit gadgetrender und selectrender die
 Möglichkeit, Images ODER Border zu übergeben. Aus diesem Grunde
 haben die Gadgets keine Border. Die Rahmen der Gadgets müssen
 also in den Imagedaten enthalten sein. 


 Systemvoraussetzungen:
 ----------------------
 Amiga mit KS 2.04+
 Workbench 2.0 ODER Workbench 2.1 für Locale
 ca. 250 Byte ChipRam pro Gadgettyp

@ENDNODE

@NODE Funktionen "Programmieranleitung"

 Ich erzeuge ganz einfach Gadgets vom Typ GENERIC_KIND. Dann wird
 die Gadgetstruktur aufgefüllt. Die Funktionen bestehen daher aus
 2 Gruppen:

  IMAGEFUNKTIONEN:
   gcc_InitImageGadgets(), gcc_InitDiskImage(), gcc_RemoveDiskImage(),
   gcc_InstallGetFileA(), gcc_CreateGetFileA()

   Diese Funktionen sind nur von Bedeutung, wenn die internen GetFile-
   Gadgets benutzt werden.


  GADGETFUNKTIONEN:
   gcc_CreateGadgetA(), gcc_SetGadgetAttrsA()

   Damit werden die eigentlichen Gadgets erzeugt und manipuliert. Auch
   die Imagefunktionen machen davon Gebrauch.


 Im Module sind global definiert:
  - g: PTR TO gadget -> wird genutzt als PTR zur gadgetlist
  - visual           -> enthält das VisualInfo für GadTools

 Diese Variablen MÜSSEN in dem fraglichen Window benutzt werden, sonst
 passieren fürchterliche Dinge!!!


 @{" Beispiel: imagedemo.e "}

@ENDNODE

@NODE F1 "ImageGadgets V1.0"

 @{" gcc_InitImageGadgets() "}

 Parameter: KEINE
 Rückgabe:  KEINE

 Funktion:
 Aktiviert die interne Sicherheitsüberprüfung. Diese Funktion wirkt
 nur, wenn wenn die Images aus dem Module benutzt werden.

 WICHTIG:
 Wenn diese Funktion angewendet wird, MUSS sie als erster Befehl aus
 dem Module benutzt werden!! 


 Querverweise: @{" gcc_InitDiskImage()     " LINK F2}
               @{" gcc_RemoveDiskImage(nr) " LINK F3}


@ENDNODE

@NODE F2 "ImageGadgets V1.0"

 @{" gcc_InitDiskImage(nr,modus) "}

 Parameter: # nr = Nummer des Gadgettyps
              0 - GadToolsBox  (20x14x3)
              1 - kleine Disk  (30x15x3)
              2 - große Disk   (30x17x3)

            # modus = Hintergrundmodus
              0 - kein Hintergrund
              1 - Farbe 3 (blau)

 Rückgabe:  KEINE

 Funktion:
 Die Imagedaten für den angegebenen Gadgettyp werden erzeugt. Diese
 Funktion MUSS immer VOR @{" gcc_CreateGetFileA() " LINK F4} ausgeführt werden! 
 Es genügt, wenn das Image für den Gadgettyp einmal initialiert wird.
 Danach kann man den Gadgettyp beliebig oft erzeugen.


 Querverweise: @{" gcc_InitImageGadgets()  " LINK F1}
               @{" gcc_RemoveDiskImage(nr) " LINK F3}


@ENDNODE

@NODE F3 "ImageGadgets V1.0"

 @{" gcc_RemoveDiskImage(nr) "}

 Parameter: # nr = Nummer des Gadgettyps
              0..2 - Nummer des Gadgettyps
              ALL  - alle Images werden freigegeben

 Rückgabe:  KEINE

 Funktion:
 Gibt den von der Imagestruktur belegten ChipRAM frei.

 WICHTIG!!!
 Es ist taktisch außerordentlich unklug, wenn man den RAM für ein Image
 freigibt, das nicht initialisiert ist! Wenn die Sicherheitsprüfung nicht
 aktiviert wurde, ist ein Guru sehr wahrscheinlich.


 Querverweise: @{" gcc_InitImageGadgets()  " LINK F1}
               @{" gcc_InitDiskImage()     " LINK F2}


@ENDNODE

@NODE F4 "ImageGadgets V1.0"

 @{" gcc_CreateGetFileA(nr,x,y,flagstatus) "}

 Parameter: # nr = Nummer des Gadgettyps
              0 - GadToolsBox  (20x14x3)
              1 - kleine Disk  (30x15x3)
              2 - große Disk   (30x17x3)

            # x,y = Koordinaten des Gadgets

            # flagstatus = Verfügbarkeit des Gadgets
              0 - anzuklicken
              1 - nicht anzuklicken

 Rückgabe:  PTR TO gadget oder -1

 Funktion:
 Erzeugt ein GetFile-Gadget.

 WICHTIG!!!
 Die Imagedaten für das Gadget müssen VORHER mit @{" gcc_InitDiskImage() " LINK F2}
 initialisiert werden! Wenn die Sicherheitsprüfung nicht aktiviert wurde,
 kann es ansonsten zum Crash kommen.


 Querverweise: @{" gcc_InitImageGadgets()  " LINK F1}
               @{" gcc_RemoveDiskImage(nr) " LINK F3}


@ENDNODE

@NODE F5 "ImageGadgets V1.0"

 @{" gcc_InstallGetFileA(nr,x,y,modus,flagstatus) "}

 Parameter: # nr = Nummer des Gadgettyps
              0 - GadToolsBox  (20x14x3)
              1 - kleine Disk  (30x15x3)
              2 - große Disk   (30x17x3)

            # x,y = Koordinaten des Gadgets

            # modus = Hintergrundmodus
              0 - kein Hintergrund
              1 - Farbe 3 (blau)

            # flagstatus = Verfügbarkeit des Gadgets
              0 - anzuklicken
              1 - nicht anzuklicken

 Rückgabe:  PTR TO gadget oder -1

 Funktion:
 Initialisiert und erzeugt ein GetFile-Gadget. Diese Funktion ist
 besonders gut geeignet, wenn nur 1 Gadget benötigt wird. Die Image-
 struktur für diesen Gadgettyp ist danach initialisiert. Weitere
 Gadgets von selben Typ können sofort mit @{" gcc_CreateGetFileA() " LINK F4}
 angelegt werden.


 Querverweise: @{" gcc_RemoveDiskImage(nr) " LINK F3}


@ENDNODE

@NODE F6 "ImageGadgets V1.0"

 @{" gcc_CreateGadgetA(x,y,n1: PTR TO image,n2: PTR TO image,flagstatus) "}

 Parameter: # x,y = Koordinaten des Gadgets

            # n1,n2 = PTR TO image
              n1 - normal
              n2 - selektiert (PTR TO image oder NIL)

            # flagstatus = Verfügbarkeit des Gadgets
              0 - anzuklicken
              1 - nicht anzuklicken

 Rückgabe:  PTR TO gadget oder -1

 Funktion:
 Erstellt ein Gadget. Breite und Höhe des Gadgets wird den Imagedaten
 entnommen. Die erzeugten Gadgets sind vom Typ BUTTON.


 Querverweise: @{" gcc_SetGadgetAttrsA() " LINK F7}


@ENDNODE

@NODE F7 "ImageGadgets V1.0"

 @{" gcc_SetGadgetAttrsA(name,win:PTR TO window,befehl,stat) "}

 Parameter: # name = Bezeichner des Gadgets

            # win = PTR zum Window mit dem Gadget

            # befehl = zu änderndes Attribut
              GA_DISABLED - Verfügbarkeit des Gadgets

            # stat = Status des Attributs
              0 - AN
              1 - AUS

 Rückgabe:  KEINE

 Funktion:
 Ändert die Attribute eines existierenden ImageGadgets.

 WICHTIG!!!
 Die erzeugten Gadgets sind zwar echte GadToolsGadgets, aber vom Typ
 GENERIC_KIND. Dummerweise kann man die Attribute dieses Typs nicht
 mit GT_SetGadgetAttrsA() ändern. Deshalb muss bei ImageGadgets auf
 diese Funktion zurückgegriffen werden.


 Querverweise: @{" gcc_CreateGadgetA() " LINK F6}


@ENDNODE

