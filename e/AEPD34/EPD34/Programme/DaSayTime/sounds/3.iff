)


Documentation
-------------

The standard documentation on the Resource functions suffices for the
Resource modules.  All the other functions (eCodeXXX and split) return NIL
if an error occurred, which is normally "out of memory".

  ecode.m:
    o   eCode() takes the address of an E function (or a label) and wraps it
      so that it can be called from other tasks/processes and still access
      the global variables of the main program.  This function was created
      for use with createTask(), but has other uses.
    o   eCodePreserve() is similar, but it also protects the function by
      preserving the non-scratch registers on the stack.  This means the
      function can retrieve (and change) registers D2-D7/A2-A6 as local
      variables.  For instance,
        PROC fun(a6,a5,a4,a3,a2,d7,d6,d5,d4,d3,d2) IS d2:=d3+a3
      will have the effect of changing register D2 (and D0) when the
      function returns.  Note: you do not need to specify all registers,
      just the suffix of the above that you are actually interested in.
        PROC fun(a3,a2,d7,d6,d5,d4,d3,d2) IS d2:=d3+a3
      would have done...
    o   eCodeTask() is just eCode() with a more suggestive name.
    o   eCodeASLHook() takes the address of an E function (or a label) and
      returns something usable as an ASL hook function (nothing to do with
      the utility library hooks, more's the pity).
    o   eCodeCxCustom() does the same for CX custom functions.
    o   eCodeCollision() does the same for GEL collision functions.
    o   eCodeIntHandler() is for interrupt handlers: you get A1 and D1 as
      arguments (in that order) to your function.  (A1 is the data element
      of your interrupt, and D1 contains the interrupt flags.)
    o   eCodeIntServer() is for interrupt servers: you get A1 (the data
      element of your interrupt) as an argument.
    o   eCodeSoftInt() is the same, but for software interrupts.
    o   eCodeSwapArgs() is like eCode() except it swaps the order of two
      arguments on the stack.  This means the E function can have its
      arguments in the same order as a similar C function.  For example,
      you can use this instead of eCodeCollision() if your collision code is
      simple (i.e., doesn't use PrintF() and the like).
    o   eCodeDispose() is passed the result of the one of the above
      functions, and will to dispose the memory used by the special wrapper.
      You will rarely need to use this, as the memory will be freed
      automatically at the end of the program.
    o   eCodeASLHook(), eCodeCxCustom(), eCodeIntHandler(), eCodeIntServer()
      and eCodeSoftInt() all use their own private scratch area to preserve
      registers, thus saving crucial stack space.  This has the disadvantage
      of making the code non-reentrant, so if you need to use the same
      function as multiple interrupt servers you must use eCodeIntServer()
      multiple times.  Apart from that they should be OK, since they do
      not get called from multiple tasks.  (If you find this a problem then
      you can use eCodePreserve()...)
    o   eCodePreserve() uses a big bit of STACK to store registers, so be
      careful...

  split.m:
    o   argSplit(str=NIL) splits a string of arguments like "arg" (which is
      the default), handling quoted arguments correctly.  The result is an
      E-list of strings, or NIL if an error occurred.  The list is also
      NIL-terminated so you have a choice of ways to manipulate it.  The
      string passed to this function (or "arg" by default) is *altered* by
 