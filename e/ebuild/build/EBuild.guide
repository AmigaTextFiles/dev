@database Ebuild.guide

@Master ebuild.texi

@Width 72


This is the AmigaGuide®  file Ebuild.guide, produced by Makeinfo-1.67 from 
the input file ebuild.texi.

   This file is the EBuild documentation.

   Copyright 1997 Gregor Goldbach


@node Main "Ebuild.guide"
@Next "Introduction"

   This file documents version 0.97 of the Ebuild tool.  You may find
in this document:


 @{" Introduction              " link "Introduction"}     An introduction to automatic program building
 @{" Invoking EBuild           " link "Invoking EBuild"}     EBuild command-line arguments
 @{" Build Files               " link "Build Files"}     Buildfiles tell EBuild what to do.
 @{" Misc                      " link "Misc"}     What Build does and what it's good for
 @{" Bugs - Future             " link "Bugs - Future"}     Known and removed bug and the future of EBuild
 @{" History                   " link "History"}     The past of EBuild
 @{" The Authors               " link "The Authors"}     Who did it?


@endnode

@node "Introduction" "Ebuild.guide/Introduction"
@Next "Invoking EBuild"
@Prev "Main"
@Toc "Main"

Introduction
************

   EBuild is a @{b}Make@{ub} clone, and it functions likewise. It is a tool that
helps you in recompiling necessary parts of a large application after
modification.

   You write a file @{b}.build@{ub} in the directory that contains the sources
of your project. The file contains info about which sources depend on
which, and what actions need to be performed if a module or exe needs
to be rebuilt.

   EBuild checks the dates of the files to see if a source has been
modified after the last compilation, and if the source uses modules that
also have been modified, it will compile these first.


@endnode

@node "Invoking EBuild" "Ebuild.guide/Invoking EBuild"
@Next "Build Files"
@Prev "Introduction"
@Toc "Main"

Invoking EBuild
***************

   EBuild can be run from any shell. If run without any arguments it
reads the file @{b}.build@{ub} and performs the actions of the first target in
this file if any of the dependancies is newer.

   The arguments are:

     TARGET,FROM/K,FORCE/S,VERBOSE/S,NOHEAD/S,CONSTANTS/S,MESS/S:

@{b}TARGET@{ub}
     Build the provided target rather than the first in the build file.

@{b}FROM@{ub}
     Allows you to use another file than @{b}.build@{ub}

@{b}FORCE@{ub}
     Rebuild, regardless of whether it was really necessary.

@{b}VERBOSE@{ub}
     Print the actions while executing them.

@{b}NOHEAD@{ub}
     Don't print the heading line (version and copyright).

@{b}CONSTANTS@{ub}
     Print all symbolic constants and the strings they are replaced
     with.

@{b}MESS@{ub}
     Don't delete the action script after execution. Useful for
     debugging.  Note that the script file name is target dependant.


@endnode

@node "Build Files" "Ebuild.guide/Build Files"
@Next "Misc"
@Prev "Invoking EBuild"
@Toc "Main"

Build Files
***********


 @{" Symbolic Constants        " link "Symbolic Constants"}     
 @{" Including Files           " link "Including Files"}

   Build files are normally named @{b}.build@{ub}. This is the file EBuild looks
for when it is run.

   The syntax of build files equals that of unix-make. In general, @{b}#@{ub}
precedes lines with comments, and:

     target: dep1 dep2 ...
       action1
       action2
       ...

   @{b}target@{ub} is the resulting file we're talking about, in most cases an
exe or module, but may be anything. Following the @{b}:@{ub} you write all files
that it depends upon, most notably its source, and other modules.

   The actions on the following lines are normal AmigaDos commands, and
need to be preceded by at least one space or tab to distinquish them
from targets.

     bla: bla.e defs.m
          ec bla quiet

   This simple example will only recompile @{b}bla.e@{ub} if it was modified, or
if the @{b}defs.m@{ub} which it uses was modified.

   If you type @{b}build@{ub} with no args, build will ensure the first target
in the file to be up to date.

   A longer example:

     # test build file
     
     all:    bla burp
     
     defs.m: defs.e
             ec defs quiet
     
     bla:    bla.e defs.m
             ec bla quiet
     
     burp:   burp.e
             ec burp quiet
     
     clean:
             delete  defs.m bla burp

   This build file is about two programs, @{b}bla@{ub} and @{b}burp@{ub}, of which @{b}bla@{ub}
also depends on a module @{b}defs.m@{ub}. An extra target @{b}clean@{ub} has been added
so you can type @{b}build clean@{ub} to delete all results. The @{b}clean@{ub} target is
called a @{i}phony target@{ui} or @{i}fake target@{ui} since it's not a real file.

   The @{b}all@{ub} target is a fake target, too. It's okay to have multiple
fake targets, however, these cannot be used as dependancies.

   Other dependencies and actions are easily added. For example, if
your project uses a parser generated by E-Yacc:

     yyparse.m: parser.y
                eyacc parser.y
                ec yyparse quiet

   Or incorporates macro-assembly code as often used tool module:

     blerk.m: blerk.s
              a68k blerk.s
              o2m blerk
              copy blerk.m emodules:tools
              flushcache tools/blerk


@endnode

@node "Symbolic Constants" "Ebuild.guide/Symbolic Constants"
@Next "Including Files"
@Toc "Build Files"

Symbolic Constants
==================

   In @{b}EBuild@{ub} a @{i}symbolic constant@{ui} is a string bound to a name.  Those
symbols can be used in rules and actions. The string of a symbol will
be inserted wherever  the symbol is found. Example:

     options=IGNORECACHE LINEDEBUG DEBUG
     test:   test.e
             ec test.e $(options)
             ==> ec test.e IGNORECACHE LINEDEBUG DEBUG

   The following example shows how to use constants in rules:

     testfile=bla
     $(testfile):    $(testfile).e
                     ec $(testfile).e

   There are two special symbols in EBuild. The first, @{b}target@{ub}, holds
the name of the target the current action belongs to. @{b}dep@{ub} gets the name
of the first dependancy of the current target.

   All except these two preset symbols may be used in rules as well as
in actions. @{b}target@{ub} and @{b}dep@{ub}, however, may only be used in actions. It's
safe to have it in rules, EBuild just aborts with a message that tells
you that it doesn't know this symbol.


 @{" target                    " link "target"}     
 @{" dep                       " link "dep"}     
 @{" Example for Constants     " link "Example for Constants"}


@endnode

@node "target" "Ebuild.guide/target"
@Next "dep"
@Toc "Symbolic Constants"

target
------

   In the example below we tell EC to compile the target instead of
writing the actual name:

     options=IGNORECACHE LINEDEBUG DEBUG
     test:   test.e
             ec $(target).e $(options)

   This may seem to be not too useful, but take a look at this example:

     options=IGNORECACHE LINEDEBUG DEBUG
     test:   test.e
             ec $(target) $(options)
             if warn
             echo "Error: compile failed"
             else
             echo "Compiled OK... running"
             $(target)
             endif

   It's largely equivalent to the old code below, but allows more.

     options=IGNORECACHE LINEDEBUG DEBUG
     all:    test
             echo "ok, running:"
             test
     
     test:   test.e
             ec -q test $(options)


@endnode

@node "dep" "Ebuild.guide/dep"
@Next "Example for Constants"
@Prev "target"
@Toc "Symbolic Constants"

dep
---

   Another preset symbol is @{b}dep@{ub}. It holds the name of the first
dependancy of the current target.

   Again, look at this example from the introduction of symbolic
constants:

     test:   test.e
             ec test.e IGNORECACHE LINEDEBUG DEBUG

   Using @{b}dep@{ub} would give this fragment:

     test:   test.e
     	ec $(dep) IGNORECACHE LINEDEBUG DEBUG


@endnode

@node "Example for Constants" "Ebuild.guide/Example for Constants"
@Prev "dep"
@Toc "Symbolic Constants"

Example for Constants
---------------------

   This example is the one from an earlier section. We will use symbols
to generalize it.

     options=IGNORECACHE LINEDEBUG DEBUG
     test:   test.e
             ec test IGNORECACHE LINEDEBUG DEBUG
             if warn
             echo "Error: compile failed"
             else
             echo "Compiled OK... running"
             test
             endif

   As a first step every use of the actual name @{b}test@{ub} is replaced by a
constant and the compiler options are put in a symbol:

     OPTIONS=IGNORECACHE LINEDEBUG DEBUG
     PGM=test
     $(PGM): $(PGM).e
             ec $(pgm) $(OPTIONS)
             if warn
             echo "Error: compile failed"
             else
             echo "Compiled OK... running"
             $(PGM)
             endif

   To indicate that we want to handle the target of the actions we
should rather use $(target) instead of the $(PGM). Note that both uses
are correct. We should use $(dep), too.

     PGM=test
     OPTIONS=IGNORECACHE LINEDEBUG DEBUG
     $(PGM): $(PGM).e
             ec $(dep) $(OPTIONS)
             if warn
             echo "Error: compile failed"
             else
             echo "Compiled OK... running"
             $(target)
             endif

   Take a look at the line where the source is compiled. This line can
be used for every source since the name of the file is in the preset
symbol. If you like you could even make a symbol that holds this line:

     COMPILE=ec $(dep) $(options)


@endnode

@node "Including Files" "Ebuild.guide/Including Files"
@Prev "Symbolic Constants"
@Toc "Build Files"

Including Files
===============

   When a file is included its contents are copied in the current build
file before it is processed. The copying is only temporary, both the
build file and the included file are left untouched.

   Including is useful if you have a number of build files that all need
the same variables or share some fake targets.

   To include a file the build file has to have the '#i' directive
followed by the name of the file to include. For example,

     #i /scripts/template

   includes the file @{b}/scripts/template@{ub} in the current build file.
Let's say this file contains these symbol definitions:

     COMPILER=E:bin/EC
     TEMP_DIR=T:

   The following build file includes these definitions and uses it:

     #i /scripts/template
     
     test: test.e
       $(COMPILER) $(dep)
       Copy $target TO $(TEMP_DIR)

   @{b}EBuild@{ub} takes everything it finds in the file you include, you could
even include binary files. This is not recommended... let's just say
the behaviour of @{b}EBuild@{ub} is undefined in that case.

   Since every file is included before processing the build file
constants cannot be used in the file name. The following scheme may
illustrate it:

  1. Parse the build file for any include directives and include the
     files.

  2. Process the build file line by line and substitute constants in
     rules.

  3. Build target if necessary and substitute constants in actions.


@endnode

@node "Misc" "Ebuild.guide/Misc"
@Next "Bugs - Future"
@Prev "Build Files"
@Toc "Main"

Misc
****

   Once you get to know build, you'll discover you can use it for more
purposes than just this. See it as an intelligent script tool.

   If you want to find out the details of what build can do, read the
documentation of some unix-make, as build should be somewhat compatible
with this. What it doesn't do for now, is:

   - allow backslash at the end of a line for longer rules

   When EBuild discovers a cyclic dependancy it just aborts, i.e. this
won't be executed:

     bla:	defs.m blurp.m bla
     	ec $(target).e

   since the target @{b}bla.e@{ub} has the dependancy @{b}bla.e@{ub}. EBuild used to
crash with an infinite loop on this one. However, it is still very easy
to make an infinite loop:

     bla:	defs.m blurp.m bla
     	ec $(target).e
     
     defs.m: bla
             ec defs.e

   @{b}bla@{ub} depends on @{b}defs.m@{ub} which depends on @{b}bla@{ub} which depends on @{b}defs.m@{ub}
which depends on @{b}bla@{ub} which depends on @{b}defs.m@{ub} which depends on @{b}bla@{ub} which
depends on @{b}defs.m@{ub} ...


@endnode

@node "Bugs - Future" "Ebuild.guide/Bugs - Future"
@Next "History"
@Prev "Misc"
@Toc "Main"

Bugs / Future
*************

   Bugs: none known

   Future: implement some more 'Make' features. Top of things to do:

   @{b}*@{ub} Allow for recursion in symbolic constants.

   @{b}*@{ub} Implement some more preset symbols:
        @{b}*@{ub} the first file this target depends on (done)

        @{b}*@{ub} all but the first file this target depends on

        @{b}*@{ub} ...

   @{b}*@{ub}     @{b}#include@{ub}-like directive (done)

   @{b}*@{ub} yet another argument to list the targets available in the build
     file. (minor)


@endnode

@node "History" "Ebuild.guide/History"
@Next "The Authors"
@Prev "Bugs - Future"
@Toc "Main"

History
*******

   For v3.1 it was updated by Jason Hulance, to fix the bug that
executed actions in reverse order. Also he introduced the local variable
$target in actions.

   EBuild was updated for v3.3a by Gregor Goldbach to support symbolic
constants and to stop on cyclic dependancies. The $target behaviour was
expanded to match other symbols: $(target) is legal, too.


@endnode

@node "The Authors" "Ebuild.guide/The Authors"
@Prev "History"
@Toc "Main"

The Authors
***********

   Wouter van Oortmerssen is the creator of E. He has studied computer
sciences and lives in England where he occasionally destroys monitors.

   Jason R Hulance is an Englishman and they say he has met Wouter
several times. He coded some tools for E, most notably Explorer which
runs together with EDBG in the current E release.

   Rob is just Rob.

   Gregor Goldbach loves E, started studying computer sciences in
October '97 and lives in Germany. He met Wouter but his monitor is
still running.

   The current maintainer of EBuild is Gregor Goldbach. Bug reports and
suggestions should be sent to him via email
(<glauschwuffel\@amt.comlink.de>), you can also find him on the E
mailing list.

   This EBuild documentation is part of the Amiga E Encyclopedia which
can be found at
@{b}http://www.asta.uni-hamburg.de/users/goldi/aee/aee_1.html@{ub} (online)
or on aminet/dev/e (snapshot).

@EndNode

