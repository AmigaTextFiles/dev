	Generalized QuickSort for anything ( qsort.m )

	© Richard Perrott 4th April 1995 FreeWare
	  email: hcm94rp2@dmu.ac.uk

This module implements the quicksort algorithm in the most flexible way.

	PROC qsort(base,first,last,comp,swap)

base:
	the start address of an ARRAY OF ? e.g. CHAR, INT, LONG, OBJECT ?.

first:
	the lowest position you want to sorting from

last:
	the highest position you want to sorting to

comp:
	a pointer to a PROC to compare the value of two items 

	e.g.

	PROC comp(base:PTR TO LONG, position1, position2)
	  DEF item

	  item := base[position]
	  IF item1 < find THEN RETURN -1
	  IF item1 > find THEN RETURN 1
	ENDPROC 0

swap:
	a pointer to a PROC ????(base, position_1, position_2)
	to swap two items.

Note:
  Any registers it uses are saved, but if your comp and swap
routines use registers other than D0 and the caller of qsort
needs them, then you will need to save them. qsort doesn't
care which registers you use.

  The module contains 244 bytes of assembler / E code.

  The routine won't stay in a 68020+ code cache unless the
PROCs it calls are tiny and very close to it.

  The routine has been heavily tested, though there are no promises
and I won't be held responsible if you find bugs or you misuse the
routine.

  If you do find any bugs then please email me.

References:
	Programming and Problem Solving in Modula-2, Sanford Leestma
	& Larry Nyhoff, © Macmillan 1992, USA, page 624-626

	( beware the example in this book for Split() contains some bugs )
