arexx.m: simple routines pour ajouter u port Arexx à votre programme.


port:=rx_OpenPort(nomduport)

    Créé un port Arexx. De gros programme peuevent maintenant vous atteindre
    en disant 'ADDRESS nomduport').
    Exception possible : "MEM", "SIG", "DOUB". Les 2 derniers sont
    'Ne peut allouer le signal' et 'Un port avec le même nom éxiste déja'.


rx_ClosePort(port)

    Libère le port et les resources associées. Peut être sans preoblême être
    appelé avec NIL.


mes,string:=rx_GetMsg(port)

    Comme un GetMsg, à partir qu'il est spécifique pour Rexx. Sort la chaine
    envoyée par le programme externe. Si mes=NIL alors il n'y avait pas de
    message.


rx_ReplyMsg(mes,rc=0,chaineresultat=NIL)

    Répond au message que vous avez reçu de rx_GetMsg(). Mettez rc=0 si pas
    d'erreur, et une chaine si vous pensez que la commande envoyée demande un
    résultat. rc> signale une erreur (pas de résultat retourné).


rx_HandleAll(interpret_proc,nomduport)

    Les 4 premières fonctions vous travailler avec la machinery nécessaire pur
    ouvrir un port Arexx à vos programmes. Cependant si votre programme n'est
    fait quepour attendre et réaliser des messages Arexx, vous pouvez utiliser
    cette fonction qui englobe les 4 autres. Tout ce qu'il y a à faire est de
    faire un PROC pour lire les messages et un nom de port.

    Le source de cette fonction est un exemple utile pour savoir comment
    appeler les autres 4 fonctions, en cas que vous vouliez les appelez
    vous-même:

    PROC rx_HandleAll(interpret_proc,nomduport) HANDLE
      DEF port=NIL,sig,quit=FALSE,mes,s,rc,rs
      port,sig:=rx_OpenPort(nomduport)
      REPEAT
        Wait(sig)
        REPEAT
          mes,s:=rx_GetMsg(port)
          IF mes
            quit,rc,rs:=interpret_proc(s)
            rx_ReplyMsg(mes,rc,rs)
          ENDIF
        UNTIL (mes=NIL) OR (quit=TRUE)
      UNTIL quit
      Raise()
    EXCEPT
      rx_ClosePort(port)
      ReThrow()
    ENDPROC

    A partir de ce code, on peut voir que la procédure donnée comme argument à
    rx_HandleAll() reçoit comme argument une chaine qu'on peut utiliser, et
    qui retourne un drapeau pour quitter ou non, et  rc et rs comme écrit dans
    la fonction rx_Reply().
    Voir arexxsimple.e pour savoir comment faire un arexxhost avec cette
    fonction avec juste quelques lignes de code.
