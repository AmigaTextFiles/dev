longreal.m: Un module pour des flottants sur 64bits.

Le module introduit un type 'longreal' au langage E.
Toutes les fonctions du module sont préfixés par un 'd' (pour 'double').
Avant d'utilisez ce module, applez d'abord:

    dInit()

et avant de sortir, _toujours_ appeler:

    dCleanup()

dInit() peut lever une exception "DLIB" si il ne peut ouvrir une des
bibliothèques IEEE double. Si vous n'avez pas besoin de fonctions
transcendentales, dInit(FALSE) n'ouvrira seulement la
mathieeedoubbas.library.


Utiliser les réels longs comme type:
    Il y a de nombreuses façon de créer des variables réelles longues.
    Le plus simple est:

        DEF f:longreal

    ou:

        DEF f:PTR TO longreal

    et plus tard:

        NEW f

    aussi, vous poouvez faire des tableaux de réels longs, ou les utiliser dans les objets:

        OBJECT bla
          x:INT, y:longreal
        ENDOBJECT

        DEF a[100]:ARRAY OF longreal, b:bla

Comme vous le voyez, ilsmarchent comme les types prédéfinis.
Dans l'exemple suivant

    f, a[1], a[10], b.y

tous sont des variables réelles longues. Elles peuvent être utilisé à chaque
fois qu'un réel long est demandé dans les fonctions décrote plus bas.
Notez cependant que, étant des objets, les réels longs sont passés par
référence.


i:=dFix(f)              dFloat(i,f)

    convertis un réel long en un LONG, et respectivement un LONG en réel long.
    dFloat() retourne f.


dAdd(x,y)               dAdd(x,y,to)
dSub(x,y)               dSub(x,y,to)
dMul(x,y)               dMul(x,y,to)
dDiv(x,y)               dDiv(x,y,to)

    réalise ces opérations sur leurs arguments. 'x' et 'y' sont dans le même
    ordre que leur équivalent opérateur. Le résultat est mis dans 'to', ou
    dans 'x' si 2 arguments sont passés. (toutes les fonctions retournent
    'to' ou 'x', respectivement).


r:=dCompare(x,y)        r:=dTest(x)

    compare des réels longs. dTest compare x avec 0 comme second argument.
    Le résultat 'r' est positif si x>y, négatif pour x<y, et 0 pour x=y.


dRound(x)               dRoundUp(x)

    arrondi x, où dRound le fait par défaut, et dRoundUp par excès. Tous 2
    retournent x.


dAbs(x)                 dNeg(x)

    prend la valeur absolue de x ou l'opposé dex, respectivement. Tous 2
    retournent x.


dCopy(x,y)

    copie y vers x, et retourne x aussi.


dFormat(s:STRING,x,num)

    produit un représentation de 'x' dans 's' avec 'num' décimales après le
    '.'. 'num' doit être >0. Retourne s.
    Pas formidable, et un peu lent, mais ça marche :-)

dSqrt(x)


----------------
NOTE: Erwinn a ajouté pas mal de fonctions, et la documentation à ce propos
peut être trouvé dans le module source, et longdemo.e.
Parce que le module est plutôt volumineux, j'ai aussi inclue le module
original longreal (maintenant longrealtiny.m) pour ceux qui n'ont pas besoin
les huées et les sifflets...
