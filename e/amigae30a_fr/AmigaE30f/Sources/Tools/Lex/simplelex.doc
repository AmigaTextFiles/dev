simplelex.m: un analyseur lexical général simple pour des taches variées

Ce lex() est à utiliser si ca vous ennuie d'en faire un vous même. Il peut
aussi servir comme exemple ou comme point de départ sur comment faire
votre propre lex. Regardez simpletest.e pour une chouette exemple
d'analyseur qui utilise ce lex.


lex_int(début,long,formelibre=FALSE,unelignecommentaire=-2)

    initialise lex, 'début' et 'long' prend la région de lamémoire où se trouve
    le texte duquel lex() prendra les tokens. La mémoire a besoin d'être
    suivit par des "\n", readfile() du file.m le fait pour vous. 'formelibre'
    dit si "\n" doit être interprété comme un espace ou non.
    'unelignecommentaire' est un CHAR.


token,attr:=lex()

    Le lex actuel retourne un token, et pour certains tokens aussi un attribut.

    " ", "\t"                       espace, pas retourné
    "\n"                            LEX_EOL, ou espace
    "[a-zA-Z_][a-zA-Z0-9_]*"        LEX_IDENT, attr=ptr sur le premier caractère
                                    [comme l'indentation du E]
    <num>                           LEX_INTEGER, attr=valeur
                                    [n'importe quoi accpté par Val()]
    <eof>                           LEX_EOF
    "<anything>"                    LEX_STRINGQ, attr=ptr sur le premier caractère
    '<anything>'                    LEX_STRINGA, idem.

    n'importe quel autre caractère est retourné comme token.


linenum:=lex_curline()

    retourne le numéro de ligne qui est actuellement analysé.


ptr:=lex_current()

    retourne le pointeur actuel dans le texte. Pratique pour ces cas où lex
    retourne un 'pointeur sur le premier caractère', comme cela sera un
    'pointeur sur le dernier caractère'.


pos:=lex_getline(estring)

    copie la ligne actuelle dans une chaine E, et retourne l'offset dans
    cette chaine où se trouve lex(). Très pratique pour des reports
    d'erreurs précis, comme 'simpletest.e' le démontre.
