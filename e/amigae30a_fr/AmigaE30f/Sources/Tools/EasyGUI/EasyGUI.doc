[Désolé, j'ai travaillé la dessus juste avant la distrubition, et c'est
 loin d'être terminé. C'est à cause d'un mauvais timing :-).
 Enfin bon, partez à l'aventure et essayez le! mais sachez que certaines
 choses changeront, d'autre ne marche pas pour me moment (ou pas comme il
 faut). Ci-dessous sont quelques morceaux de la documentation, et à la fin
 vous verrez ce qu'il manque...]


                        Introduction au nouveau :

                             E A S Y G U I

    Un contructeur d'interface pour le E, avec les caractèristiques suivantes:

        - complètement sensible aux polices de caractères
        - possibilité de modifier la taille
        - s'organise tout seul, ie il arrange ses gadgets en fonction
        - est dans le pur style Guide
        - rapide et flexible
        - relativement petit, n'a pas besoin de bibliothèque supplémentaire
        - et par dessus tout: très facile à utiliser!!!


EasyGUI prend la forme d'un module qui a bvesoin d'être unclue dans votre
source E. Le façon le plus simple de construire u GUI consiste à appeler
la fonction easygui() avec une liste E (pourquoi pas dynamique) qui décrit
votre GUI. Pour vous montrer la simplicité, essayez ce source:

        MODULE 'tools/EasyGUI'
        PROC main() IS easygui('Euh,...',[BUTTON,0,'Ok!'])

Il ouvrira une fenêtre avec juste un gadget, et attendra que l'utilisateur
y appuye. Si easygui() ne peut pas prendre ce qu'il veut, il enerra des
exceptions, donc on aura certainement besoin d'un gestionnaire
d'exceptions pour être capable d'en informer l'utilisateur.

e premier argument d'easygui() est le titre de la fenêtre,le second est la
description du GUI. La forme de ces descriptions est simple : c'est une
liste avec comme premier élément le type de gadget, le second est appelé une
valeur d'action (dans la suite), et le reste est spécifique au gadget.

Pour être capable de construire un GUI de plusieurs composants, il est
possible de grouper les gadgets en lignes (ROW) et colonnes (COL):
To b
[COL,
  [BUTTON,1,'Ok'],
  [BUTTON,0,'Cancel']
]

Ceci créera un nouveau groupe, consistant en 2 gadgets cote à cote.
Les groupes COL et ROW sont comme un seul gadget, ie vous pouvez facilement
les mettre dans d'autres groupes, pour créer des GUIs d'un compléxité
infinie.
Par exemple,essayez ce source:

------------------------
Voilà pour la documentation que j'ai tapé. Plus d'infos:

Les groupes:

    ROWS,EQROWS,COLS,EQCOLS,BEVEL

Gadgets etc.
Format général: [NOM,action,texte,...]
dans {}: dans quelle direction il peut changer la taille.
* = non implémenté où manque de bouts.

[BUTTON,action,intext]
buttonaction(info)

[CHECK,action,textedroit,booléen,textboolgauche]
checkaction(info,booléen)

*[INTEGER,action,textegauche,num]
integeraction(info,newnum) {x}

*[LISTV,action,textabove,xsize,xsize,execlist,litbool,selection]   (selection: 0=aucun, 1=lit, 2=gadget string)
listviewaction(info,num_selected) {x,y}

[MX,action,textedroit,nil_term_elist,textegauchebool]
mxaction(info,num_selected)

*[CYCLE,action,textegauche,nil_term_elist]
cycleaction(info,num_selected)

*[PALETTE,action,textegauche,depth,relx,rely]
paletteaction(info,couleur) {x,y}

*[SCROLL,action,isvert,total,top,visible]
scolleraction(info,curtop) {x|y}

*[SLIDE,action,textegauche,isvert,min,max,cur]     -> a un afficheur de niveau??
slideraction(info,cur) {x|y}

[STR,action,textegauche,initial,maxcaract,relsize]
stringaction(info,nouvchaine) {x}

*[TEXT,text,textegauche,bordbool] {x}

*[NUM,int,textegauche,bordbool] {x}

*[RENDER,actionr,actionp,x,y]               -> en unites de fonte
renderrefresh(x,y,xs,ys)
renderpress(x,y)                           -> relatif au coin haut-gauche

*[RENDERFIXED,actionr,actionp,x,y]          -> en pixels
renderfixedrefresh(x,y)
renderfixedpress(x,y)

[SBUTTON] {x}                   -> pareil que bouton.


Codes d'action:
- un entier entre 0..999
  dogui() fermera tout et sortira avec ce code
- un pointeur sur une procédure pour éxécuter une action. Le type de procédure
  (i.e. nombre d'arguments) diffère avec chaque gadgets. Après avoir appelé la
  procédure, dogui() continuera normalement ce gui, jusqu'à ce que le procédure
  retourne FALSE.


Les exceptions:

"MEM"   -- pas de mémoire
"GUI"   -- pour des chose comme CreateGadgetA, OpenWindowTagList etc.
"GT"    -- ne peut ouvrir la gadtools.library
"DF"    -- idem pour diskfont
"Egui"  -- un erreur dans le design : très probablement dû à une liste de dogui()
           qui étaittrop longue ou trop courte.
<other> -- Levée par la fonction elle-même


Exemple d'utilisation de 3 autres fonctions (= définition easygui())


PROC easygui(windowtitle,gui,info=NIL,screen=NIL,prefs=0,textattr=NIL) HANDLE
  DEF gh=NIL:PTR TO guihandle,res=-1
  gh:=guiinit(windowtitle,gui,info,screen,prefs,textattr)
  WHILE res<0
    Wait(gh.sig)
    res:=guimessage(gh)
  ENDWHILE
EXCEPT DO
  cleangui(gh)
  IF exception THEN ReThrow()
ENDPROC res


Ce qui n'a pas été fait:
- il utilise la police de caractères du système au lieu de la police de
  l'écran
- n'essayepas des polices plus petites si le GUI ne va pas
et beaucoup de petits problêmes...
