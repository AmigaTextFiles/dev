@database ecx.guide
@author Leif Salomonsson
@copyright Leif Salomonsson 2002-2008

@node main

    :                                                              :
     ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

                                  E C X

   ::               E compiler by Leif Salomonsson 2002-2009       ::

                                   2.2

     ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
    :                                                              :


            Read first

            @{" About this doc         " link aboutdoc}   Read this if
            @{" Also check out         " link checkalso}   new to AmigaE !

            Before you start

            @{" Requirements           " link requirements}
            @{" Warranty               " link warranty}
            @{" Distribution           " link distribution}
            @{" Installation           " link installation}   READ THIS!
            @{" Usage                  " link usage}
            @{" Introduction           " link introduction}
            @{" Registration           " link registration}

            New language features/improvements/changes

            @{" The OPT keyword        " link optkey}
            @{" Various improvements   " link variousimprovements}
            @{" Various new features   " link variousnewfeatures}
            @{" Incompatibilities      " link incompatibilities}
            @{" Floating point         " link floatpoint}
            @{" STATIC data            " link statickey}
            @{" Class methods          " link staticmeths}
            @{" Library mode           " link librarymode}
            @{" 680x0 inline asm       " link inlasm68k}
            @{" PowerPC inline asm     " link inlasmppc}
            @{" Internal functions     " link intfuncs}
            @{" Thread support         " link threadsupp}
            @{" Linkobject mode        " link linkobject}
            @{" String formatting      " link stringformat}
            @{" 64bit integers         " link integer64}

            Values, types, and how they fit together

            @{" Value system           " link valuesys}
            @{" Type system            " link typesys}
            @{" 64bit discussion       " link disc64}
            @{" Order of evaluation    " link evalorder}

            Preprocessor

            @{" Define macros          " link defmacs}
            @{" Conditional compilation" link condcomp}
            @{" Predefined symbols     " link predefsyms}
            @{" Multi statement macros " link asmmacs}
            @{" Other directives       " link ppmore}
            @{" Notes                  " link ppdetails}

            Reference

            @{" Predefined globals     " link iglobals}
            @{" Predefined constants   " link iconstants}
            @{" Namespaces             " link namespaces}
            @{" Grammar description    " link ebnfgrammar}
            @{" Target details         " link targdetails}
            @{" Compiler details       " link compdetails}
            @{" Hardcoded limits       " link limits}
            @{" Other limits           " link currlimits}

            Binary compatibility

            @{" Using old modules      " link ecbinmods}

            Support tools

            @{" Tools                  " link tools}

            Frequently asked questions

            @{" Language               " link langfaq}
            @{" Other                  " link otherfaq}

            Tips

            @{" Debugging              " link debugtips}
            @{" Cross compiling        " link crosscomp}

            Finally

            @{" Bugs                   " link bugs}
            @{" Thanks to              " link thanksto}
            @{" The author of ECX      " link ecxauthor}

@endnode

@node aboutdoc

#-------------------------------------------------------------------#
|  About this documentation                                         |
#-------------------------------------------------------------------#

   1. This doc is under construction.

   2. This doc assumes you are already familiar with the AmigaE language
      and the EC compiler. If you are not, this doc might not be very useful.

@endnode

@node checkalso

#-------------------------------------------------------------------#
|  More E information                                               |
#-------------------------------------------------------------------#

   For AmigaE and related docs, check out

      Wouters AmigaE Homepage "wouter.fov120.com/e/".

      Aminet:dev/e/amigae33a.lha contains the original AmigaE compiler
      and examples, documentation (look for E.guide and BeginnersGuide/
      Contents.guide)

      Beginners Guide also available online:
      http://cshandley.co.uk/JasonHulance/beginner_1.html

      Wouters E.guide converted to html is avilable here:
      http://blubbedev.net/e_guide_html/main.html

   For even more E related material:

      Aminet: "dev/e/"

   AmigaE Mailinglist:

      "www.freelists.org/list/positron/"

   Damiens system programming guide:

      "Aminet:dev/e/EC4OS3.lha"

   ECX Homepage:

      "blubbedev.net/ecx"

@endnode



@node requirements

#-------------------------------------------------------------------#
|  Requirements                                                     |
#-------------------------------------------------------------------#

   AmigaOS compiler:

      OS3 (V39+), 68020+, 2MB free memory.

   MorphOS compiler:

      MorphOS PPC, 2MB free memory.

   AmigaOS4 compiler:

      AmigaOS4 PPC, 2MB free memory.

   Generated executables:

      AmigaOS 3.0 (V39+), 68020+ (and 68881+ if using floats).

      or

      MorphOS PPC

      or

      AmigaOS4 PPC

@endnode

@node installation

#-------------------------------------------------------------------#
|  Installation                                                     |
#-------------------------------------------------------------------#

   [CHANGED 2.0]

   Unpack archive (ecx.lha) to somewhere on your harddrive.

   ECX needs the assign "ecxmodules:" to find binary modules.

   > ASSIGN ECXMODULES: ECX:modules ECX:moremods

   ECX:moremods is for putting third party (or your own)
   modules in.

   The emodules: dir should not be part of ecxmodules: assign
   anymore, it is handled in the environment variables now.

   > setenv ecx-amigaos-dir emodules: ecxmodules: ecxmodules:amigaos/
   > setenv ecx-morphos-dir emodules: ecxmodules: ecxmodules:morphos/
   > setenv ecx-amigaos4-dir emodules: ecxmodules: ecxmodules:amigaos4/
   > COPY env:ecx#? envarc:

   You probably want to add a PATH also:

   > PATH ECX:bin ADD


   The files in the ecx archive:
   -----------------------------

   Modules (dir)        -> ecx binary modules here
      amigaos (dir)     -> amigaos 3.x modules
      amigaos4 (dir)    -> amigaos 4.x modules
      ecx (dir)         -> ecx private modules (startups etc)
      graphics (dir)    -> just contains a dummy gfxmacros.m
      morphos (dir)     -> morphos modules
      powerpc (dir)     -> powerpc macros etc

   Bin (dir)            -> executable files and tools drawer

   Docs (dir)           -> documentation drawer
      ecx.guide         -> this document

   Source (dir)         -> various sources
      #? (dir)          -> various directories


   Do not put modules for EC/CreativE in ecxmodules:, put them as usual in
   emodules:.


   If upgrading from versions before 2.x
   --------------------------------------

   Delete all files in ecxmodules:ecx/ they are not needed as
   new ones with new names comes with 2.0.

   Some things have changed regarding how ecx searches for
   modules and how modules are organised.

   Following dirs

   aboxlib/
   emul/
   toolsabox/
   muiabox/
   otherabox/

   are now located in

   morphos/amigalib/
   morphos/emul
   morphos/tools/
   morphos/mui/
   morphos/other/

   ECX automatically prepends "morphos/" to module names
   when compiling for MorphOS, so no need to type that.
   The idea is that whether you compile for AmigaOS3, MorphOS
   or AmigaOS4, module names all look the same.

   To make old sources work with new dir structure, you either
   1. rewrite all module statements that needs it, or
   2. use softlinks

      cd into the <ecxdir>
      execute the script makelinks.script

      Then add ECX:softlinks to the ecxmodules: assign.


@endnode

@node warranty

#-------------------------------------------------------------------#
|  No warranty                                                      |
#-------------------------------------------------------------------#

   There are NO WARRANTIES.
   It is impossible to guarantee that there are no bugs present,
   even for final release versions.
   The author takes NO RESPONSIBILITY for any damage from the use
   of this software.
   Usage is entirely AT YOUR OWN RISK.

@endnode

@node distribution

#-------------------------------------------------------------------#
|  Distribution                                                     |
#-------------------------------------------------------------------#

   The archive ecx.lha may be distributed freely, as long as the
   contents and name of the archive remains intact and unmodified.

@endnode


@node introduction

#-------------------------------------------------------------------#
|  Introduction                                                     |
#-------------------------------------------------------------------#

   The E Compiler X (ECX) project was born in 2002 to replace
   and improve on the AmigaE language and compiler (EC) created
   by Wouter van Oortmerssen that was discontiniued in 1998.
   ECX is written from scratch in E and compiles itself.
   It is fast, stable, resource efficient, highly compatible,
   generates quite okayish code (for multiple targets) and
   adds a considerable amount of (actually useful) new features
   and improvements :)

   Highlights:

   1. PowerPC support.

      This is the most important one, and the reason ECX exists.

   2. Heavily improved librarymode.

      Probably the easiest and most powerful library mode/support in
      ANY compiler for Amiga/MorphOS EVER .. :)

   3. Heavily improved floating point support.

      No more slow and 32bit only..

   4. 64bit integer support (PowerPC only)

   5. And a lot more..

   Read all about the rest in this documentation..


@endnode

@node registration

#-------------------------------------------------------------------#
|  Registration                                                     |
#-------------------------------------------------------------------#

   ECX as of 2.0 makes use of a keyfile, if present.
   Keyfile should be located in envarc:.

   Keyfiles are personal and per host platform.
   You can compile for any target with any keyfile.
   You decide how much you think is a fair amount to pay.

   These are the differences between using ECX without
   and with a keyfile:

   1. ECX outputs the registration status as part of the program
      greeting message.

   2. All executables will have a symbol with information about the
      version of ECX used to compile it, registration status is part
      of this information.

   3. Unregistered versions of ECX will contain a $VER: string
      that explains the unregistered status of the compiler.
      No matter if you define your own version string or not.

   4. Unregistered versions of ECX will ignore the QUIET/S command-line
      option. This simply to make point 1. work better :)

   Register (or donate !) here: http://blubbedev.net/ecxregister.html

   Thank you.

@endnode

@node usage

#-------------------------------------------------------------------#
|  Usage                                                            |
#-------------------------------------------------------------------#


   Quick usage:
   ------------

      ecx <sourcename> <targetname>

      example:

      ecx myapp amigaos



   Commandline parameters:
   -----------------------


   SOURCE/A             - Required, the source file name, with or without ".e".


      -- Targets --


   POWERPC/S         - *DEPRECATED,OBSOLETE* Does the same as MORPHOS/S.

   AMIGAOS/S         - Compile code for AmigaOS.

   AMIGAOS4/S        - Compile code for AmigaOS4.

   MORPHOS/S         - Compile code for MorphOS.


   -- Optimisation --


   REG=NUMREGALLOC/N    - Automatically put often used variables in
                          registers. 0..4 registers for 680x0, 0..12
                          for powerpc. It is safe to give too big value
                          here, ECX just tries to use as many registers
                          as possible. Using "NUMREGALLOC -1", will make
                          ECX to decide itself how many registers to use
                          for each procedure (recommended).

   FREG=NUMFREGALLOC/N  - Like above, now for DOUBLE variables. 0-12 or -1.
                          (powerpc only).

   OPTI/S               - Sets NUMREGALLOC and NUMFREGALLOC to -1.


   -- Script related --


   HOLD/S               - Wait for a RETURN before exiting.

   WBTOFRONT/S          - Flip the workbench screen to front.

   SHOWFNAME/S          - Show the name of SOURCE file in the output.

   QUIET/S              - Keep quiet unless there are warnings or errors.

   NOWARN/S             - Output no warnings.

   ERRLINE/S            - Return linenumber as error code to shell.


   -- Debugging --


   NIL=NILCHECK/S    - Inserts code to check for "NIL-pointers".
                       If found, the following code will be executed:
                       Throw("NIL", linenum). Also will make sure all
                       uninitialised variables are set to NIL.

   SYM=SYMBOLHUNK/S  - Add symbol information to the executable.
                       Symbols that will be present in the symbolhunk are:
                       Procedures, used internal functions, assembler labels, methods.

   LINE=LINEDEBUG/S  - Add line and source information to the module/executable.
                       Automatically turns on SYMBOLHUNK.

   VAR=VARDEBUG/S    - Add debug information about variables to module/executable.
                       Automatically turns on SYMBOLHUNK, LINEDEBUG.

   STEP=STEPDEBUG/S  - Makes it possible to debug code with a debugger.
                       Automatically turns on SYMBOLHUNK, LINEDEBUG, VARDEBUG.
                       Not implemented yet.


   -- Preprocessor --


   DEFINE/K          - Define macro(s) on the commandline. Examples:
                       > ECX myprogg DEFINE MYSWITCH
                       > ECX myprogg DEFINE "MyMacroValue 100"
                       Use ";" to separate multiple macros.
                       You need "OPT PREPROCESS" in the source.


   SHOWCONDSYMS/S    - Show preprocessor symbols being used in conditional
                       compilation.


   -- Input/output paths --


   DDIR=DESTDIR/K    - Place resulting file(s) in another directory.
                       Default is the same directory as the source-file.

   EXENAME/K         - Set another name for resulting exe/lib.
                       Default is sourcename less '.e'.

   MODNAME/K         - Use another name for resulting module.
                       Also works in librarymode (EXENAME and MODNAME can
                       be combined). '.m' will get appended to name.

   DIR=MODULEDIR/K   - Like OPT DIR, allows to add more directories to
                       module search path. The order in which ECX searches
                       modules is
                       1. Commandline MODULEDIR/K (right to left),
                       2. OPT DIR (right to left)
                       3. ecx-<target>-dir environment variable (right to left)


   -- Other --


   NODEFMODS/S       - Do not automatically load the default exec.m, dos.m,
                       intuition.m, graphics.m

   OUTFORMAT/K       - RAW:  Outputs executable in raw format, that is,
                             simply dumping the binary opcodes of the
                             codesection to disk. Any use of relocations
                             will give an error message (but see ABSOLUTE/S).

                       ELF:  Outputs executable in ELF format
                             (default for PowerPC)

                       ADOS: Outputs executable in ADOS format
                             (default for 68k)

   TOADDR/N          - Generates the raw executable to a specific memory-address instead
                       of writing to disk. Be SURE to have the buffer in memory big enough!

   ABSOLUTE/N        - Relocates raw code into absolute code before output.
                       Takes desired address as parameter.

@endnode

@node optkey

#-------------------------------------------------------------------#
|  The OPT keyword                                                  |
#-------------------------------------------------------------------#


   OPT may be followed by:


   MODULE         - Declare source as module.

   EXPORT         - Export everything from module, except PRIVATE stuff.

   NOWARN         - Disable the output of all warnings.

   OSVERSION      - ECX 1.6.0+
                    Explicitly define the minimum os version we require.
                    ECX will warn if we make use of a module with a version
                    number higher than the version we have requested with
                    OPT OSVERSION, but only if the module in question contains
                    code. Startup will fail as usual if started on a version
                    of the os < OSVERSION.
                    If OSVERION is not defined, ECX will automatically set it
                    to the highest OSVERSION of any module used, _that contains
                    code_, otherwise leave it to zero. ECX shows the osversion
                    in the normal shell output, if it is > 0. Note that the
                    startup may require a higher osversion than the one you
                    have defined..


   -- Input / output / paths --


   DIR            - Add another directory to the list of directories to search
                    for modules in. Directory will be placed at top of list.
                    Multiple directories may be specified, the right-most will
                    get searched first. ex: OPT DIR = 'ecymodules: bla:urgh/'.

   EXENAME        - Tell ECX to name resulting executable/library differently.
                    Filename only, does not alter directory.
                    Example: OPT EXENAME = 'myfantasticexe'

   MODNAME        - Tell ECX to name resulting module differently.
                    Filename only, does not alter directory.
                    '.m' will get appended to name.
                    Example: OPT MODNAME = 'myfantasticmod'


   -- Compatibility --


   ASM            - Does nothing. For compatibility.

   LARGE          - For compatibility. does nothing.

   FPEXP          - For compatibility with CreativE.
                    Turns on OPT ROUNDNEAR.


   -- Optimisation --


   REG            - Does the same as NUMREGALLOC/N command line option. ex: "REG=5".

   FREG           - Like REG, but for DOUBLE vars.


   -- Preprocessing --


   PREPROCESS     - Enable preprocessing of source.


   -- Targets --


   POWERPC        - *DEPRECATED,OBSOLETE* Does the same as MORPHOS.

   AMIGAOS        - Compile code for AmigaOS.

   AMIGAOS4       - Compile code for AmigaOS4.

   MORPHOS        - Compile code for MorphOS.

   NATURALALIGN   - Forces natural alignment of OBJECT members, that is
                    LONG at 4-byte boundaries, DOUBLE at 8-byte boundaries, etc.

   ROUNDNEAR      - Make integer to float conversion round to nearest
                    instead of the default towards zero.

   -- Startupcode --


   STACK      - Manually set the stacksize that startupcode will allocate.
                ex : OPT STACK=50000


   MINSTARTUP - A very minimal startup code will be used.
                No libraries are opened (except execbase).
                No stdin, stdout or wbmessage.
                Built-in memory functions, exceptions, globals,
                inline lists, will work.
                Avoid using mixed code (ppc+68k).
                (Similar to CreativE's OPT NOSTARTUP.
                Sorry for name confusion.
                NOSTARTUP works different with ECX, see below).

   NOSTARTUP  - No startupcode will be used.
                Execution will start at the first piece of code in the main
                source (through a jump though). Nothing is initialised at
                this point. Immediate lists will not work, neither will any
                global variables or exceptions.


   -- Other --


   NODEFMODS  - Disable loading of the default modules:
                exec.m,dos.m,intuition.m,graphics.m


@endnode

@node inlasm68k

#-------------------------------------------------------------------#
|  680x0 inline assembler                                           |
#-------------------------------------------------------------------#

   Most of the 68020 instructions (except Bitfield, BCD, Exceptions,
   etc) are supported and a subset of addressing modes are available.


   68k addressing modes supported
   ------------------------------

   Immediate

      #<32bit constant expression>

   Data register

      Dx
      regvar

   Address register

      Ax

   Address register indirect

      (Ax)

   Address register indirect predecrement, postincrement

      -(Ax)
      (Ax)+

   Address register indirect with offset

      100(Ax)
      BLA(Ax)
      -16(Ax)
      AddTail(Ax)
      variable
      .member(Ax:object)

   Address register indirect with index and scale

      notes:
         ofs8 = 8bit signed, can be omitted
         using scale higher than 1 requires 68020+

      ofs8(Ax,Dx)             -> ofs8(Ax,Dx.L*1)
      ofs8(Ax,Dx.L)           -> ofs8(Ax,Dx.L*1)
      ofs8(Ax,Dx.L*scale)     -> scale = 1/2/4/8

   PC relative label

      mylabel
      mylabel(PC)

   Additionally for MOVEM instruction registerlists are supported

      MOVEM.L D2-D7/A3/A5, -(A7)

   And 68020+ double register operands for MULx.L and DIVx.L instructions.

      MULS.L D4, D5:D6


   Not supported compared to EC
   ----------------------------

   No absolute addressing

   No support for Dx.W in ofs8(Ax,Dx.W)


   Instructions supported
   ----------------------

   MOVE
   MOVEA
   LEA
   NOP
   RTS
   ADD
   ADDA
   ADDI
   SUB
   SUBA
   SUBI
   ADDQ
   SUBQ
   CLR
   CMP
   CMPA
   CMPI
   EXT
   EXTB
   NEG
   AND
   ANDI
   OR
   ORI
   EOR
   EORI
   NOT
   MOVEQ
   PEA
   UNLK
   RTD
   TST
   ASL
   ASR
   LSL
   LSR
   ROL
   ROR
   ROXL
   ROXR
   SWAP
   EXG
   LINK
   BSR
   Bcc
   DBcc
   MOVEM
   MULS
   MULU
   DIVS
   DIVU
   Scc
   JSR
   JMP
   ADDX
   SUBX
   RTR
   RTE
   NEGX
   CMPM

@endnode

@node inlasmppc

#-------------------------------------------------------------------#
|  PowerPC inline assembler                                         |
#-------------------------------------------------------------------#

   The PowerPC 32bit instructionset is fully supported and complete.

   For the simplified PowerPC mnemonics, resort to this module with
   preprocessing enabled: powerpc/simple.m

   Up to 12 general purpose and 12 floating point registers may be used
   for register-variables.


   Special  addressingmodes
   -----------------------

      There are no special instructions for accessing E variables.

      To load a variable into register:

         LWZ Rx, variable

      To store a register into a variable:

         STW Rx, variable

      To get the address of a variable, use the "ADDI" instruction:

                                       Translates to:
         ADDI Rx, localvar          -> ADDI Rx, R1, localvar_offset
         ADDI Rx, globalvar         -> ADDI Rx, R13, globalvar_offset

      Local ARRAY/STRING/LIST "variables" are a bit different.
      They are not real variables but only represents the address
      of some storage on the stack.

         To get the address of that *data*:

            ADDI Rx, local_array  -> ADDI Rx, local_array_offset(R1)

         Using a load or store instruction is still possible:

            LWZ Rx, local_array   -> LWZ Rx, local_array_offset(R1)
            -> this loads the first longword of the array into Rx.

      For getting address of code labels, use the special "LA" instruction:

         LA Rx, codelabel

      We may dereference object members:

         LWZ Rx, .member(Ry:object)  -> LWZ Rx, member_offset(Ry)
         STB Rx .member(Ry:object)   -> STB Rx, member_offset(Ry)
         ADDI Rx, .member(Ry:object) -> ADDI Rx, Ry, member_offset
         STW Rx, .member(Ry:self)    -> STW Rx, member_offset(Ry) [in methods]

      Registervariables (DEF <name>:REG ...) may be used directly
      as if they where registers:

         DEF y:REG, x:REG PTR TO object
         LBZ y, .member(x)          -> LBZ Ry, member_offset(Rx)
         ADDI y, .member(x)         -> ADDI Ry, Rx, member_offset

      Libraryfunction identifier may be used as constant (offset):

         ADDI R3, R0, AddTail        ..68K
         LWZ Rx, FindTaskByPID(Ry)   ..SYSV

      Other special instructions:

         Load Immediate Word

            LIW Rx, <constant expression>    -> May use two instructions if constant
                                             -> expression does not fit in 16bit.
         Add Immediate Word

            ADDIW Rx, <constant expression>  -> May use two instructions if constant
                                             -> expression does not fit in 16bit.

@endnode

@node variousimprovements

#-------------------------------------------------------------------#
|  Various improvements                                             |
#-------------------------------------------------------------------#


   o  SELECT keyword takes any expression, not just variables.
      Expression is only evaluated once.

   o  CASE in normal SELECT statement now also supports multiple matches
      like this:

         SELECT x
         CASE 1,2,x
           ...
         CASE a,b,BLA
           ...
         ........

   o  EXIT keyword now works in all four loop constructs.

   o  "::" (pointertyping) now also works on variables, indirect longs
      (ptr[]::) and arrays (object::).

   o  Unification accepts right-hand list typed as :LONG.
      Only difference is no list-len-comparison is done
      and so, "exp" could be just any piece of memory.

   o  "(" ")" grouping is allowed in constant expressions.

   o  Typed immediate (and static) lists always allocates whole object(s)
      and clears fields not used.

   o  Global ARRAYs and OBJECTs are cleared with zeroes.

   o  Local librarybases is possible. Just define it locally with same name.

   o  This does not compile with EC/CreativE, but does with ECX.
      "x OP -y" where OP is math/bitwise/comparison operator.

   o  Usage of {} around code labels has been relaxed. From now a code label
      represents its own address without the need for {} around it.

   o  With EC/CreativE you cannot just use (without DEFining it) globals
      exported from another module unless you do it from main source.
      With ECX you can.

   o  * and / operators are fully 32bit on all targets.

   o  Indexing ([]) an object-pointer with a negative value does not work
      with EC/CreativE because index is treated as unsigned. ECX treats
      index as signed.

   o  Objects can now inherit from multiple parents. Just separate parent
      names with comma ",". Only the first parent may contain methods though.

   o  RAISE directive now also handles procedures. Procedure must be from
      a module though. For procedures in same source better to let it raise
      its own exception.

   o  Abs and Not are now unary operators instead of built-in functions.
      It is fully backwards compatible, but means that there is no need
      for Abs64 and Not64 in 64bit integer mode. Abs() even works in float
      mode, so Fabs() is not needed anymore but kept for compatibility.
      Abs and Not also works in constant expressions.

   o  SIZEOF extensions.

      Besides

      SIZEOF object

      there is now also:

      SIZEOF {variable}   -> get size of variable (4 or 8, 0 for array)

      SIZEOF variable[]   -> get size of one element of pointer/array

      SIZEOF (array)      -> get total size of array in bytes (0 for non array).
                          -> Note that STRING type includes nil-term.

      SIZEOF (static)     -> Like above but for STATIC data.

   o  Initialisation for private globals in modules.

         Init values and global arrays possible:

            DEF xxx=12, yyy[100]:ARRAY, etc

@endnode

@node variousnewfeatures

#-------------------------------------------------------------------#
|  Various new features                                             |
#-------------------------------------------------------------------#

   From CreativE:
   --------------

   o  New operators "<<", ">>"

      <<    -  Bitwise shift left. Same binary function as Shl().
      >>    -  Arithmetic shift right. Same binary function as Shr().

   o  LONG label
      Example: LONG myLabel

   o  Modification.. ex:

      x+=y                 -> x := x + y
      x.y[]++ *= z.bla     -> x.y[] := x.y[] * z.bla ; x.y++

      Works for math/bitwise operators.

      ECX addition: If destination is of type FLOAT/DOUBLE/REAL
      operation will automatically be done in floating point mode:

      DEF f:REAL
      f+=3.0               -> f := ! f + 3.0


   New with ECX:
   -------------

   o  New operators "SHR", "XOR"

      SHR   -  Bitwise shift right. (Non arithmetic shift)
      XOR   -  Exclusive OR. Same binary function as Eor().

      Usage is allowed in code and in declarations such as CONST etc..
      "Precedence" is like other math/bitwise/comparison operators.

   o  LONG 'string'
      Example: LONG theProcedure, 'of drinking', 10, 'beers'

   o  Float constants is possible.
      Example: CONST MYFLOAT=10.99
               CONST MYOTHERFLOAT=!MYFLOAT + 0.5
               CONST MYINTEGER=!MYFLOAT!

   o  Local class objects (DEF myclass:<classobjname>) is possible.
      ".end()" is called automatically at procedure end.
      Note: It is not possible to use the object in RETURN/IS/ENDPROC
      part of procedure. Reason is .end() method has already been called
      just before this. Implementation quirk that will not be fixed.

   o  Object members new features:

      OBJECT test
         test_as_array[0]:ARRAY OF LONG
         a:PTR TO LONG,b:PTR TO INT,c:PTR TO CHAR
         x:PTR TO object @ a
         private1 @ -4
         private2 @ -8
      ENDOBJECT

      1. arrays in objects may have zero-size.
      2. union-members are members that are placed at the offset
      of another already defined member, but takes no place, and does not
      change the size of an object. The "@" sign (at) is used for this purpose.
      3. members may be placed at a specific offset, similar to 2.

      Viewmodule would print out "test" this way:

      (----) OBJECT test
      (   0)   test_as_array[0]:ARRAY OF LONG
      (   0)   a:PTR TO LONG
      (   4)   b:PTR TO INT
      (   8)   c:PTR TO CHAR
      (   0)   x:PTR TO object
      (  -4)   private1:LONG
      (  -8)   private2:LONG
      (----) ENDOBJECT /* SIZEOF = 8 */

   o  Methods have also access to the virtual "self" object.
      PROC method(s:PTR TO self)  OF bla
         DEF s:self, s:PTR TO self
         ...

   o  "OFFSETOF object.member"

         Gives you the offset of member inside object.
         Handles objects in objects recursively.

   o  It is now possible to define function variables with DEF.

         DEF myfunc(LONG,REAL), x, a:REAL, b, c:REAL
         DEF myfunc2(REAL,REAL,PTR)(REAL,LONG,REAL)

         x := myfunc(1,10.0)
         a,b,c := myfunc2(1.0,2.0,[1,2,3])

   o  Inverted versions of IF, ELSEIF, WHILE, UNTIL, EXIT,
      a feature I copied from the PowerD language:

         IFN x       -> IF x = NIL
         ELSEIFN x   -> ELSEIF x = NIL
         WHILEN x    -> WHILE x = NIL
         UNTILN x    -> UNTIL x = NIL
         EXITN x     -> EXIT x = NIL

         Or even:
         IFN x > y   -> IF x <= y

    o New types:

      signed CHAR, called BYTE      (and PTR TO BYTE, ARRAY OF BYTE)

      unsigned INT, called WORD     (and PTR TO WORD, ARRAY OF WORD)

      32bit FLOAT, called FLOAT     (and PTR TO FLOAT, ARRAY OF FLOAT)

    o  Local labels

      Simply put a "." in front of label.
      Label must be inside a procedure and will not be visbile outside ot it.

      .blah:
      JUMP .blah

@endnode

@node incompatibilities

#-------------------------------------------------------------------#
|  Incompatibilities                                                |
#-------------------------------------------------------------------#


   o  Increment/decrement on object-members affects the *member* and NOT
      the base variable. I did not change this just to be annoying..
      it also has to do with the uselessness of the construct as it
      was in AmigaE versus how much more useful it has now become :)
      And I've never seen any source that actually depends on this feature.

         examples:

         object.member++      -> "member" is incremented.
         object[x].y.z--      -> "z" is decremented.
         bla.x[]--            -> "x" is decremented.

   o  The Int() function of ECX returns a 32bit sign extended 16bit value
      rather than unsigned as EC does. The new Word() function does what
      old Int() did.

   o  Local STRINGs allocated on the stack are NOT allowed to be linked
      with Link() function.

   o  When receiving multiple return values, ECX only allows receiving
      into simple variables. EC/CreativE allows first of multiple return
      values to go into a dereferenced variable.


   Unsupported stuff
   ---------------------------------------------------------------------------


   o  "^" operator (use Long() or [] instead).

   o  Lisp cells. Never found a use for them and never under six years heard
      anyone wanted it implemented so it is gone.


@endnode

@node stringformat

#-------------------------------------------------------------------#
|   String formatting                                               |
#-------------------------------------------------------------------#

   String formatting codes works like with CreativE. To print out the
   % character, use %%.


   Immediate codes
   ---------------

   \\n      -  A newline (ascii 10)

   \\t      -  A tab (ascii 9)

   \\a      -  A single quote  (')

   \\q      -  A double quote (")

   \\e      -  Escape (ascii 27)

   \\\\      -  The backslash itself

   \\0      -  Nil-byte (ascii 0)

   \\b      -  A carriage return (ascii 13)

   CreativE additions

   \\xHH    -  Insert any character represented by a two digit hex number (HH).

   \\!      -  A bell (ascii 7)

   \\v      -  A vertical tabulator (ascii 11)

   ECX additions

   \\~         -  Inserts nothing!

   \\1 .. \\9  -  ascii 1 .. ascii 9


   Codes used by string formatting functions
   -----------------------------------------

   \\d      -  Inserts decimal number, with optional field specifier.
   \\d[x]

   \\h      -  Inserts hexadecimal number, with optional field specifier.
   \\h[x]

   \\s      -  Inserts a string, with optional field specifier.
   \\s[x]

   \\c      -  Inserts a character

   \\z      -  Zero fill in field (default is space filling).
              Only affects next field.

   \\l      -  Place result to the left in field.
              Affects rest of string (or until \\r).

   \\r      -  Place result to the right in field (default).
              Affects rest of string (or until \\l).

   CreativE additions

   \\u      -  Inserts unsigned decimal number, with optional field specifier.
   \\u[x]


   ECX additions

   \\D      -  Inserts 64bit decimal number, with optional field specifier.
   \\D[x]

   \\H      -  Inserts 64bit hexadecimal number, with optional field specifier.
   \\H[x]


   Notes:

      The (min,max) field specifier of the \\s formatting code is
      not supported.


@endnode

@node defmacs

#-------------------------------------------------------------------#
|   Preprocessor / #define macros                                   |
#-------------------------------------------------------------------#


   Differences compared with EC/CreativE:


      o Null-arg macros are supported

         Example: #define BLA() ..stuff..


      o Variable arguments are supported

         Example: #define Bla(x,y,...) [1,2,x,y,...,NIL]

         Note: If "..." in body is immediately preceded by "," (as in above example),
               The "," will get removed automatically if the "..." argument is empty.


      o Defines may be exported explicitly:

         EXPORT #define ...


@endnode

@node condcomp

#-------------------------------------------------------------------#
|   Preprocessor / conditional compilation                          |
#-------------------------------------------------------------------#

   Directives from EC:

      o #ifdef <symbol>

      o #ifndef <symbol>

      o #endif


   New directives with ECX:

      o #else

         "else"

      o #elifdef <symbol>

         "else if defined"

      o #elifndef <symbol>

         "else if not defined"


   Notes:

      Conditional compilation directives are "free-form", and may be put
      anywhere on a line and does not need to be terminated with newline.

         #ifdef DEBUG WriteF('x=\\d\\n', x := y) #else x := y #endif

@endnode

@node predefsyms

#-------------------------------------------------------------------#
|   Predefined preprocessor symbols                                 |
#-------------------------------------------------------------------#

   These are all new with ECX.

   __AMIGADATE__

      - this is set to current date as '(DD.MM.YYYY)',
        useful with version strings.

      #define __AMIGADATE__ '(08.01.2008)'

      verstr:
      CHAR '$VER: Blala 1.0 ', __AMIGADATE__, 0

   __DATE__

      - this is set to the current date as 'DD-Mmm-YYYY'

      #define __DATE__ '08-Jan-2008'

   __TIME__

      - this is set to the current time as 'HH:MM:SS'

      #define __TIME__ '19:45:13'

   __TARGET__

      -  this symbol is set to a name describing the current
         target, as an immediate string. Example:
         WriteF('\s\n', __TARGET__) -> MorphOS,PPC

   __AMIGAOS__, __AMIGAOS4__, __MORPHOS__

      -  one of these symbols will be set for respective targets
         operating system.

   __M68K__, __PPC__

      -  one of these symbols will be set for respective targets CPU.

   ECX_VERSION

      - this is set to the current version of ECX.

      46 = v1.2
      47 = v1.3
      48 = v1.4
      49 = v1.4.x
      50 = v1.5

      This is mainly just to check if compiled with ECX.

      #ifdef ECX_VERSION
         ..do super cool ecx stuff..
      #endif


@endnode


@node asmmacs

#-------------------------------------------------------------------#
|   Preprocessor / assembler macros                                 |
#-------------------------------------------------------------------#

   Macros with multiple statements like the assembler "MACRO" macros
   are also supported. Quite useful when using PowerPC asm, but is not
   restricted to asm instructions.

   <label> MACRO
    ...
    ...
    ...
   ENDM

   Arguments are received in "\\1" to "\\9".
   "\\0" is reserved for an optional "." / ".L" / ".W" / ".B" / ".D".

   example:

      A PowerPC asm macro:

         ROTLW MACRO -> Rotate Left Word
            RLWNM\\0 \\1,\\2,\\3,0,31
         ENDM

      Using the macro:

         ROTLW R3, R4, R5  -> produces : RLWNM R3, R4, R5, 0, 31
         ROTLW. R3, R4, R5 -> produces : RLWNM. R3, R4, R5, 0, 31
         ROTLW x,y         -> produces : RLWNM x y, 0, 31 -> error !

      A different FOR construct:

         FOR2 MACRO
            \\1
            WHILE \\2
         ENDM

         ENDFOR2 MACRO
               \\1
            ENDWHILE
         ENDM

      Use it:

         FOR2 x := 3, x < 1000
            WriteF('x=\\d\n', x)
         ENDFOR2 x := x * 3

   "EXPORT" may be used:

      EXPORT COPY MACRO
         ...


   To use a MACRO, it must be the first thing on a line (white
   space not counted) or it will not be recognised as a MACRO.


@endnode

@node ppmore

#-------------------------------------------------------------------#
|      Other preprocessor directives                                |
#-------------------------------------------------------------------#

   #fmtstr symbol fstr values...

      Formats a string with values and assigns it to a symbol.

      "fstr" is like a normal immediate string with formatting codes.

      "values..." are the values we want to format. Two kinds of
      identifiers are legal: constants and symbols. Symbols are
      always inserted by using the \\s formatting code, all others
      formatting codes requires a constant.

      If the body of a symbol-value starts with single quote, the quote
      and its counter part are removed before insertion. Otherwise we
      would get unwanted quotes in formatted string.

      Example: -> let's create a version string!

         #define PROG_NAME 'My Program'
         #define PROG_AUTH 'John Smith'
         CONST PROG_VER = 10,
               PROG_REV = 1

         #fmtstr VERSTR '$VER: \\s \\d.\\d \\s by \\s' \\
            PROG_NAME PROG_VER PROG_REV _DATE_ PROG_AUTH

         ..would result in VERSTR looking something like:
         '$VER: My Program 10.1 (06.06.2008) by John Smith'

         The "\\" char can be used to continue values on next line.

   #error '..error message..'

      Will make compilation fail and output the error message.
      Can be useful with conditional compilation.

   #warning '..warning message..'

      Will output the warning message.
      Can be useful with conditional compilation.

@endnode

@node ppdetails

#-------------------------------------------------------------------#
|      Preprocessor details                                         |
#-------------------------------------------------------------------#

   All comments are removed before preprocessor is invoked.

   It is not possible to redefine built-in language indentifiers
   like keywords, internal functions, etc.

   Directives can start anywhere on a line. There may be horizontal
   whitespace between the # character and the directive name, like
   "#  ifdef ...".


@endnode

@node floatpoint

#-------------------------------------------------------------------#
|      Floating point support                                       |
#-------------------------------------------------------------------#

   Floating point computations with +-*/ are 64bit and uses
   inline floating point instructions as opposed to calling
   libraryroutines for this.

   In powerpc mode, also all internal Fxxx floating point support functions
   does computations in full 64bit.
   Exception is RealF() which only supports single precision for now.


   The basic, pointer and array types for dealing with 64bit floats:

      DOUBLE, PTR TO DOUBLE, ARRAY OF DOUBLE

   And 32bit floats:

      FLOAT, PTR TO FLOAT, ARRAY OF FLOAT

   And a generic float type;

      REAL, PTR TO REAL, ARRAY OF REAL

   The REAL type means "the default floating point precision" and is currently the same
   as DOUBLE, that is 64 bits. but it could be different on some targets. Always use
   REAL unless you absolutely need it to be exactly 64 bits (DOUBLE) or 32 bits (FLOAT).

   Note that the LONG type can still be used to store floats just as in original AmigaE.
   The FLOAT/ARRAY OF FLOAT type only differs in that it is automatically 4-byte aligned
   in objects and as inline data, instead of 2-byte. This is needed for some cpu's like
   the PowerPC. DOUBLE/ARRAY OF DOUBLE is aligned the same way.

   REAL/DOUBLE may be an argument.

      PROC doublestuff(d:REAL,x)
      ENDPROC ! d * 2.0 -> returns 32bit float in normal return register.

   It is possible to return a float in a floating point register.

      PROC doublestuff(d:REAL,x) (REAL) -> tell compiler to return in float register.
      ENDPROC ! d * 2.0 -> returns value in 64bit float register.

   Six new functions:

      d := Double(adr)
      r := Real(adr)

         reads a double (64bit) float from memory.

      PutDouble(adr,f)
      PutReal(adr,f)

         writes a double float to memory at address "adr".
         "f" should be any float expression.

      r := Float(adr)

         reads a single (32bit) float from memory.
         differs from Long() in that result is returned in floating point register.

      PutFloat(adr,f)

         writes a single (32bit) float to memory at address "adr".
         "f" should be any float expression.
         differs from PutLong() in that "f" is passed in floating point register.


   Other notes:

      1. Up to all 4 returnvalues may use floating point registers.

      2. LONG/PTR can be used to specify non float values when several mixed type
         return values are used, example:

         PROC bla(x) (LONG,REAL,PTR,REAL)

      3. Avoid "REG DOUBLE" for future compatibility. Use "REG REAL" instead.

      4. Using REAL variables is quicker than using LONG/FLOAT
         because ECX keeps LONG/FLOAT variables in 32bit integer registers.
         This especially makes difference on the PowerPC. Another reason
         to type your float variables to REAL.


   Note that ECX does not support double precision immediate/constant
   values currently, but values will be converted from single to double precision.


@endnode

@node statickey

#-------------------------------------------------------------------#
|      STATIC data                                                  |
#-------------------------------------------------------------------#

   The STATIC keyword is used to define tables or strings of data.

   STATIC mystring = 'hello universe!!',
          mylongstring = 'this string is so very..' +
                         'very very very very very ' +
                         '..long!!'

   OBJECT myobj
      w,x,y,z
   ENDOBJECT

   STATIC mylist = [1,2,3,4],
          myobj = [4,5,6,7]:myobj,
          myarray = [3,4,5]:INT

   List/array elements can be constant expressions, strings,
   code labels / statics and other lists.

   STATIC mycomplexlist =
      [1,2,3,[myfunction, mylist,'hello!',
         [-1, 10*MYCONST, 9.999]:someobj]:PTR,NIL]

   Note that static lists has no problems being typed with object
   containing arrays (or other objects):

   OBJECT blaha
      a,b,c
      array[2]:ARRAY OF REAL
   ENDOBJECT

   STATIC myobj2 = [1,2,3,[10.0,-150.5]:REAL]:blaha


   Dereferencing of static data is much like normal dereferencing of
   variables/members. Difference is you cannot make assignments,
   increment/decrement, NEW/END etc. A (derefenced) label is always
   an expression.

   WriteF('\\s', mystring)     -> prints 'hello universe!!'
   WriteF('\\c', mystring[4])  -> prints 'o'

   WriteF('\\d', myobj.z)      -> prints '7'
   WriteF('\\d', myarray[1])   -> prints '4'

   Selection (.), indexing ([]) and pointer typing (::) can be used to
   dereference a static label.


@endnode

@node librarymode

#-------------------------------------------------------------------#
|      Library mode                                                 |
#-------------------------------------------------------------------#

   What is different ?

      > FAST environment lookup (a single instruction)

      > Immediate lists [with runtime values] are safe to use,
        even if library is used by several tasks at the same time.

      > An application may open a library several times, just
        remember to close it as many times.


   How does it work ?

      When OpenLibrary() is called on library, a new librarybase that is
      shared between the library and its opener, is created. This librarybase
      contains the jump/func-table and the global e-environment needed for
      each opener. There is no 32k limit on this environment as is usual with
      other similar solutions. If the same task does OpenLibrary() on our
      library several times, the same librarybase will be returned as from the
      first call.

   Usage is pretty much like with AmigaE, but keep this in mind:

      The main() routine (if defined) should return <>NIL if all went okay,
      else FALSE. Returning FALSE will make OpenLibrary() to fail.

      The "LIBRARY ..." declaration must be placed before
      any "RAISE", "DEF", "PROC", "label:".

   The private librarybase

      A pointer to the librarybase can be obtained through the
      global "librarybase" variable. This is not the librarybase
      in execbase.liblist, but the one the application using the
      library has obtained.

      The 18 bytes after the standard library header of this base
      is free to use in any way by the library/application.
      You should have GOOD reasons to use this area, else don't do it.
      An example of use would be plugin-libraries for GoldED (Dietmar Eilert),
      that needs to have a special binary ID poked into offset
      36 of the librarybase. This would be done in the main()
      routine.

      librarybase.version is a bit special, it contains the version requested
      by OpenLibrary(), not necessarily the actual version of your library.
      This might be handy if you need to do different stuff depending on
      the version.. but you probably should not do it :)

   Extensions

      Using "EMPTY" instead of a procedure name in the list of entries
      creates a dummy function that just returns NIL.

      In powerpc mode for morphos, the library will by default have a 68k
      ABI, which will be callable from 68k programs. You should define the
      registers used for arguments and not let the compiler decide, because
      ECX and EC/CreativE uses different defaults. And it makes things more
      clear.

      Using the "SYSV" switch will create a library with MorphOS SYSV
      ABI. This is faster, but cannot be called from 68K programs anymore.
      Like this:

         OPT POWERPC
         LIBRARY SYSV name,ver,rev,idstr IS ...

      A MorphOS 2.0+ library may define a "query" function at the offset of
      the normally unused "ExtFunc" (offset -24), it should look something
      like this:

      (Note: we have no global environment inside query() function!
       For this reason "utilitybase" (needed by FindTagItem()) is passed to
       it so that we do not have to open and close it everytime ourselves.)

      PROC query(data:PTR TO LONG, attr, utilitybase)
         DEF ti:PTR TO tagitem
         IF ti := FindTagItem(attr, mytags)
            data[] := ti.data
            RETURN TRUE
         ELSE
            RETURN FALSE
         ENDIF
      ENDPROC

      A MorphOS 2.0+ library may use an extended resident structure containing
      tags. Example:

      LIBRARY 'bla.library', 50, 1, 'bla.library by nisse 2007' TAGS mytags IS
      ...
      ...

      mytags:
      LONG TAG_XXX, VAL_XXX,
           TAG_YYY, VAL_YYY,
           TAG_END


   Other

      Finally, it should also be noted that with ECX it is possible to create
      your library or even device "by hand". Just use OPT NOSTARTUP at the top
      of your source and.. well that is beyond the scope of this guide.

@endnode

@node threadsupp

#-------------------------------------------------------------------#
|  Thread support functions                                         |
#-------------------------------------------------------------------#

   Note: These are not built in functions, se the module tools/thread.m


   These functions cater for the 3 most important things when it comes to
   thread creation: synchronisation, error handling, argument/environment
   passing. They also provide a neat interface that should be quite portable
   atleast across Amiga-like OSes. They don not involve themselves in any way
   with what is done after the synchronised creation is done. This is all
   up to the programmer.

   --------------------------------------------------------------
   process, r := newProcess(proc,pri,name,arg,stack=NIL,tags=NIL)
   --------------------------------------------------------------

      This function starts a new asynchronous process.

      "proc" is address of the procedure that will be run as a process.

      "pri" is the priority (-128..127).

      "name" is the name of the process.

      "arg" is always passed as argument to "proc", put whatever you please here.

      "stack" is the desired stacksize. it defaults to 16000 bytes for powerpc,
      10000 bytes for 68k.

      "tags" is additional tags for dos.library/CreateNewProc(), if needed.

      On failure, "process" will be NIL, and "r" will contain the error ("SIG" for no
      signals, "PROC" for CreateNewProc() failure), other errors may come from the
      new process returning them.

   ----------------------------------
   releaseSuccess(private,return=NIL)
   ----------------------------------

      If nothing went wrong, the newProcess() function will put the
      calling process to sleep until the new process calls the
      releaseSuccess() function or returns an error code.
      This allows the new process to make initialisations and
      inform mother about its success.

      "private" is a private argument to "proc".

      "return" can be anything and will be returned as "r" from the
      newProcess() call on success.

   The thread-procedure should look something like this:

      PROC myThread(private, arg)

         ... make initialisations ...

         IF all_okay
            releaseSuccess(private)
         ELSE
            RETURN error -> "error" ends up in "r"
         ENDIF

         ... do stuff here ...

      ENDPROC NIL -> Thread should ALWAYS return NIL when exiting normally !

   Note: "private" really is private, do not assume anything about it.

   For an example of use, see E:Source/MUI/Subtask.e


   ---------------------------
   success := newEnvironment()
   ---------------------------

      This function is for use in new processes (created with
      newProcess()) only. It will allocate a new global environment,
      initialise it, and replace the current one. A good place to call
      it is before releaseSuccess(). Creating a new environment is
      normally not needed. It might be useful to allow exception
      handling and use of built-in memory allocation functions like New(),
      etc.

      "success" will be TRUE if memory could be allocated, FALSE if not.

      wbmessage, arg, stdin, stdout, etc, will all be NIL !

      execbase,dosbase,gfxbase,intuitionbase will be copied
      from previous environment.

      Global arrays/lists/strings will be NIL, allocate them
      yourself if needed.

      Memory can be allocated with memoryfunctions as usual,
      and will be deallocated when the process ends.

      Exception-handling will work, but as with libraries,
      never pass an exception out the window :)

      FreeStack() will work.

      Following float support functions will work:
      Fabs(),Ffloor(),Fceil(),Fsin(),Fsqrt(), Fcos(),
      Fexp(),RealF(),RealVal().
      More may be made to work in future.

      As stdout is NIL, WriteF()/PrintF() will open a console,
      unless the stdout variable has been set to a valid filehandle.

      Does not work in librarymode.


@endnode

@node staticmeths

#-------------------------------------------------------------------#
|  Class methods                                                    |
#-------------------------------------------------------------------#

   Besides E's normal methods, ECX also supports class methods.

   Definition of a class method is as follows:

   PROC myClassMethod() OF CLASS myNiceObject

   "myNiceObject" is some kind of OBJECT we have previously declared.

   Class methods are a powerful kind of syntax sugar and functions
   alot like a macro.

   Class methods may be inherited and redefined just as normal methods.

   Difference with C++ and Java class/static methods, is that ECX class
   methods has access to "self" just as normal methods do. And there is
   no such thing as a physical "class", only instances of classes (objects).

   The object in question does not have to be allocated with NEW,
   or even created from E, it could be any structure from the OS,
   say "window". It could even be NIL, but then the method shouldn't
   try to peek/poke it :).

   ViewModule will mark a class method like this (notice the asterix):

   (   *)    mymethod (bla)

@endnode

@node intfuncs

#-------------------------------------------------------------------#
| Internal functions                                                |
#-------------------------------------------------------------------#

   All EC 68k internal functions except lisp cell functions
   are implemented for AmigaOS target.

   All of above except Mouse() and Gadget() are implemented
   for AmigaOS4 and MorphOS targets.

   PowerPC List(), String(), DisposeLink() now accepts an optional
   argument: mempool. mempool should be a pool created with
   exec.library/CreatePool().

   PowerPC ForAll(), SelectList(), MapList(), Exists()
   Currently does not check list length so make sure destination list
   is big enough! Also, these functions really cannot be used recursively
   for now (implementation quirk).

   StrCopy() now handles zero length copy correctly
   (EC/CreativE version just returns without setting
    new string length / nil term).


   New functions:


   ObjName(eobj), ObjSize(eobj).
      Use these functions to get the name and size of an e object with methods.
      (Class methods does not qualify! (no method table))

   DebugF(fmtstr,...).

      Will normally send its output to the serial port,
      unless something like sashimi is installed.

      Functions like debug_lib/KPrintF().

   NewList(list)

      Initialises exec list header.


@endnode



@node iglobals

#-------------------------------------------------------------------#
|  Internal global variables                                        |
#-------------------------------------------------------------------#

   From EC:

   stdout
   conout
   stdrast
   arg
   wbmessage
   execbase
   dosbase
   intuitionbase
   gfxbase
   exception
   stdin
   exceptioninfo

   New with ECX:

   librarybase

@endnode

@node iconstants

#-------------------------------------------------------------------#
|  Internal constants                                               |
#-------------------------------------------------------------------#

   From EC:

      TRUE        -> -1
      FALSE       -> 0
      NIL         -> 0
      ALL         -> -1
      EMPTY       -> 0
      STRLEN      -> length of last immediate string

   New with ECX:

      LINENUM     -> always contains the current line number,
                  -> useful for debugging.

   Amiga support constants:

      OLDFILE     -> same as dos/dos.m/MODE_OLDFILE   (EC)
      NEWFILE     -> same as dos/dos.m/MODE_NEWFILE   (EC)
      READWRITE   -> same as dos/dos.m/MODE_READWRITE (CreativE)

@endnode

@node valuesys

#-------------------------------------------------------------------#
|      Value system (32bit)                                         |
#-------------------------------------------------------------------#


   The original AmigaE can be seen as having a single-value system.
   All mathematical, bitwise, comparisons, etc, operations are done
   on the 32bit LONG value. ECX allows other types of values of other
   sizes to coexist with the default 32bit LONG value.

   1. The (LONG) General purpose value [default]

      LONG can hold
      Addresses: {},  `, ARRAY OF *, PTR TO *
      Single floats: FLOAT
      32bit Immediate values: 100, 99.78, -6, MY_VALUE*10, ..

      Values smaller than LONG are automatically converted to/from LONG:

         CHAR/INT  <=> LONG

   2. The (DOUBLE) Floating point value

      Values smaller than DOUBLE are automatically converted to/from DOUBLE:

         LONG/99.78/-6.0/!MY_VALUE*10.0, ..  <=> DOUBLE

   3. The (WIDE) 64bit integer

      Values scale WIDE <=> LONG/INT/CHAR

   4. Possibly in future: VECTOR type.

      Would use intrinsics to do math/bitwise/comparison.


@endnode

@node typesys

#-------------------------------------------------------------------#
|      Typesystem  (32bit)                                          |
#-------------------------------------------------------------------#


   Type                           Size      Reference
   -------------------------------------------------------------

   CHAR, BYTE                     1         Value   (LONG)

   INT, WORD                      2         Value   (LONG)

   LONG, ULONG                    4         Value   (LONG)

   PTR TO *                       4         Value   (LONG)

   DOUBLE                         8         Value   (REAL)

   WIDE                           8         Value   (WIDE)

   ARRAY OF *, LIST, STRING       x         Address (LONG)


@endnode


@node disc64

#-------------------------------------------------------------------#
|      64bit discussion                                             |
#-------------------------------------------------------------------#

   Who knows, some day there might be a 64bit E compiler/language.
   Let me just say, I have currently no plans to do something like that.
   Anyway, Here are some hints, tips, thoughts and a few extra features
   to help a future migration to a 64bit E language.

   Migrating to a 64bit PowerPC CPU will be more problematic than
   moving from 32bit 68K => 32bit PPC, that was relatively easy.

   Default (untyped) values, PTRs, and all addresses, will suddenly
   be 64bit. CHAR,INT,LONG,DOUBLE will remain unchanged, the 64bit
   WIDE type will be added.

   Lets go through areas that needs attention:

   1. Untyped variables, arguments, members.

      On a 32bit system these will all be treated as "LONG",
      on a 64bit system they will be treated as "WIDE".

   2. Untyped listelements.

      In a 32bit language, elements will default to "LONG",
      on a 64bit system they will default to "WIDE".

   3. Storing pointers in arrays.

      Not an uncommon thing to do.
      In a 32bit system we use "ARRAY OF LONG" and "PTR TO LONG" for this,
      on a 64bit system we would use "ARRAY OF WIDE", "PTR TO WIDE".
      Now, should we have to change all occurrences of these constructs
      in our sources, or is there a solution ? There is a solution:
      "ARRAY OF PTR" and "PTR TO PTR". This small addition to the ECX
      typesystem solves this. On a 32bit system "ARRAY OF PTR" will equal
      "ARRAY OF LONG", on a 64bit system "PTR TO PTR" will equal "PTR TO WIDE".

   4. Inline pointers.

      ECX supports inline pointers like this:
         LONG mylabel, 'blabla', NIL
      But to be 64bit compatible, this is required:
         PTR mylabel, 'blabla', NIL

   5. Size of pointers.

      "SIZEOF PTR" gives the size of pointers,
      The size is 4 on 32bit systems, 8 on 64bit systems.

   6. Using 32bit compiled modules with a 64bit compiler.

       A. Constants will be signextended to 64bit integers.
          This is definitely a problem for any floating point constants.

       B. PTRs in objects will be treated as plain LONGs.

       C. Code in modules will not understand any possible 64bit
          pointers passed as arguments to procedures.
          Code in modules will not understand any integer values
          larger than >32bit signed. Code in modules assumes the stack
          is a 32bit one.. Code in modules will not work.

       Conclusion, recompile your modules!

   7. Peeking/poking pointers with Long()/PutLong().

      On a 64bit system, pointers will not fit in LONG.
      ECX adds two replacement functions for this, for future
      64bit compatibility: Ptr(), PutPtr(). On a 32bit system,
      these works just as Long(), PutLong(). On a 64bit system,
      they will do the same as Wide(), PutWide().

   8. LONG variables.

      If possible, avoid giving variables the "LONG" type,
      unless really needed, just leave them untyped.
      This way on a 64bit system they will be treated as WIDE,
      and possibly optimised into a register. Especially avoid
      "x:REG LONG", it will likely not work on 64bit target.

   9. X86_64

      64bit PPC would be easiest to implement, if working from
      the ECX sourcecode. But X86_64 seems like a relatively nice CPU too :)
      Certainly it would be possible, but then there will be endian-issues
      to care about also, if old code is to be ported. And there is
      no magical solution to this but to rewrite code where needed,
      use macros if portability X86<=>PPC is desired.


   Have you noticed, on the 64bit system there are two types
   with the same size: DOUBLE and WIDE. Why is this ?

   1. It gives compiler the possibility to place variables ment
      for float-values in float registers, variables ment for
      integers/pointers in general purpose registers.

   2. It also has to do with automatic scaling.
      Assignments LONG<=>DOUBLE automatically scales single<=>double floats.
      Assignments CHAR/INT <=> LONG <=> WIDE automatically scales in a similar
      way but now for integers.




   Finally, the 64bit version of the type-table:


   Type                           Size       Reference
   --------------------------------------------------------

   CHAR, BYTE                     1          Value   (WIDE)

   INT, WORD                      2          Value   (WIDE)

   LONG, ULONG                    4          Value   (WIDE)

   WIDE                           8          Value   (WIDE)

   PTR TO *                       8          Value   (WIDE)

   DOUBLE                         8          Value   (REAL)

   ARRAY OF *, LIST, STRING       x          Address (WIDE)


@endnode

@node evalorder

#-------------------------------------------------------------------#
|      Order of evaluation                                          |
#-------------------------------------------------------------------#

   Apart from assignment, all expressions are always evaluated
   from left to right. Be it math/bitwise/comparison or parameters
   to functions or elements of an immediate list.

   "a+b*c" is evaluated as:

      1. load value of a
      2. add value of b
      3. multiply with value of c

   "bla(x[]++, x[]++)" is evaluated as:

      1. load value of x[] as first parameter
      2. increment x
      3. load value of x[] as second paramater
      4. increment x
      5. call function

   Assignment always evaluates right hand side expression first,
   then if needed, evaluates the left hand side.

   "x[exp] := y[]++" is evaluated as:

      1. load value from y[]
      2. increment y
      3. evaluate exp
      4. store value in x[exp]


@endnode



@node namespaces

#-------------------------------------------------------------------#
|      Namespaces                                                   |
#-------------------------------------------------------------------#

   X   = uppercase
   x   = lowercase or "_"
   ... = anything
   #   = anycase
   XXX = all uppercase

   Namespace #1:

      Constants               -> X...
      Variables               -> x...
      Procedures              -> x...
      Asm labels              -> #...
      Internal functions      -> Xx...
      System functions        -> X...
      Inline asm registers    -> XXX
      Define symbols          -> #...

   Namespace #2:

      Objects                 -> x...
      Inline asm instructions -> XXX
      Assembler MACROs        -> X...

   Reserved keywords:

      NEW, END, AND, OR, BUT, OPT, MODULE, OBJECT, ENDOBJECT, CONST,
      SET, ENUM, PROC, ENDPROC, IS, DEF, SUPER, FOR, STEP, ENDFOR,
      LOOP, ENDLOOP, WHILE, ENDWHILE, REPEAT, UNTIL, JUMP, REG, IF,
      THEN, ELSE, ELSEIF, ENDIF, SELECT, INC, CASE, DEFAULT, ENDSELECT,
      CHAR, INT, LONG, STRING, LIST, DEC, ARRAY, PTR, TO, DO, OF, STRLEN,
      EXPORT, SIZEOF, RETURN, EXCEPT, HANDLE, EXIT, RAISE, MACRO, ENDM,
      SHL, SHR, NOP, LIBRARY, INCBIN, DOUBLE, VECTOR, CLASS, PRIVATE,
      PUBLIC, FLOAT, WIDE, UWIDE, REAL, BYTE, WORD, ULONG, AS, LINKOBJECT,
      IFN, ELSEIFN, WHILEN, UNTILN, EXITN


@endnode

@node ebnfgrammar

#-------------------------------------------------------------------#
|  ECX Grammar Description   (EBNF)                                 |
#-------------------------------------------------------------------#

(*   E Grammar Description for ECX 1.9
     Corrections are welcome
     Leif Salomonsson 2004-2008

Extended BNF        Operator         Meaning
----------------------------------------------------
unquoted words                     non-terminal symbol
"..."                              terminal symbol
'...'                              terminal symbol
(...)                              grouping
[...]                              optional symbols
{...}                              symbols repeated zero or more times
{...}-                           symbols repeated one or more times
=                  in               defining symbol
;                  post            rule terminator
|                  in               alternative
,                  in               concatenation
-                  in               except
*                  in               occurrences of
(*...*)            in               comment
?...?                              special sequence

*)

(* Digits *)

Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

(* Letters *)

LetLC = "a" | "b" | "c" | "d" | "e" | "f" | "g" |
        "h" | "i" | "j" | "k" | "l" | "m" | "n" |
        "o" | "p" | "q" | "r" | "s" | "t" | "u" |
        "v" | "w" | "x" | "y" | "z" ;

LetUC = "A" | "B" | "C" | "D" | "E" | "F" | "G" |
        "H" | "I" | "J" | "K" | "L" | "M" | "N" |
        "O" | "P" | "Q" | "R" | "S" | "T" | "U" |
        "V" | "W" | "X" | "Y" | "Z" ;

LetAC = LetLC | LetUC ;

(* Values *)

LetHex = Dig | "a" | "b" | "c" | "d" | "e" | "f" | "A" | "B" | "C" | "D" | "E" | "F" ;

ValDec = Dig, {Dig} ;

ValHex = "$", {LetHex}- ;

ValBin = "%" {"0" | "1"}- ;

ValChar = any-character-except-doublequote;

ValStr = '"' [ValChar] [ValChar] [ValChar] [ValChar] '"' ;

Float = [ValDec] "." {Digit} ;

Int = ValDec | ValHex | ValBin | ValStr ;

ImmVal = Float | Int ;

(* Termination *)

Sep = {";"}- ;

Term = {NEWLINE | Sep}- ;

MORE = "," [NEWLINE] ;

(* Comment *)

Comment = ("/*" {AnyThing} "*/") | ("->" {AnyThingButNewLine} NewLineOrEOF) ;

(* Labels *)

LabLC = ("_" | LetLC) {"_" | LetAC | Digit} ;

LabUC = (LetUC) {"_" | LetAC | Digit} ;

LabAC = ("_" | LetAC) {"_" | LetAC | Digit} ;

(* Identifiers *)

Var   = LabLC ;

Const = LabUC ;

Obj   = LabLC ;

Proc  = LabLC ;

Meth  = LabLC ;

Memb = LabLC ;

Ifunc = LetUC, LetLC, {LetAC} ;

Lfunc = LabUC ;

Define = LabAC ;

Macro = LabUC ;

Asm = {LetUC}- ;

Reg = ("R" | ("F" ["P"]) | "A" | "D") {Digit}- ;

Label = LabAC ;

Arg = LabLC ;

Static = LabLC ;

(* OPT *)

OptItem = OptName ["=" (Int | NameString)] ;

OPT = "OPT" OptItem {MORE OptItem} Term ;

(* MODULE *)

MODULE = "MODULE" NameString {MORE NameString} Term ;

(* Declarations *)

MembMerge = "@" Memb | (["-"] Int) ;

MembDec = Memb [MembType [MembMerge]] ;

VarDef = Var ["=" ConstExp] VarType ;

RaiseDef = Const | ImmVal "IF" (Lfunc "(",")") | (Ifunc "()") Compare ConstExp ;

ArgItem = Arg ["=" ConstExp] [ArgType] ;

ArgList =  [ArgItem {MORE ArgItem}] ;

RValue = "LONG" | "PTR" | "DOUBLE" | "REAL"
RValueDef = {RValue {MORE RValue}}-

StaticExp = (String {"+" String}) | StatList ;

StaticDef = Static "=" StaticExp ;

StatListExp = ConstExp | String | Label | StatList ;

StatList = "[" StatListExp {MORE StatListExp} "]" [":" (BasicType | ObjType)] ;

DECL = ( ["EXPORT"] "OBJECT" Obj ["OF", Obj] Term
         {
            ("PRIVATE" | "PUBLIC") [Term] {MembDec {"," MembDec} Term}
         }
         "ENDOBJECT" Term

       ) |

       ( ["EXPORT"] "PROC" Proc "(" ArgList ")" ["(" RValueDef ")"] ["OF", Obj] (["HANDLE"] Term
            "DEF" VarDef {MORE VarDef} Term
            STATES
         ["EXCEPT" ["DO"] Term
            STATES]
         "ENDPROC" Returns) | ("IS" Returns) Term

       ) |

       ( ["EXPORT"] "CONST" Const = ConstExp {MORE Const = ConstExp} Term

       ) |

       ( ["EXPORT"] "SET" Const ["=" ConstExp] {MORE Const ["=" ConstExp]} Term

       ) |

       ( ["EXPORT"] "ENUM" Const ["=" ConstExp] {MORE Const ["=" ConstExp]} Term

       ) |

       ( ["EXPORT"] "DEF" VarDef {MORE VarDef} Term

       ) |

       ( ["EXPORT"] "STATIC" StaticDef {MORE StaticDef} Term

       ) |

       ( "RAISE" RaiseDef {MORE RaiseDef} Term

       ) ;

(* Inline *)

LongItem = ConstExp | Label | ImmString ;

INLINE = (["EXPORT"] Label ":") |

         (Asm [operands] Term) |

         (("DOUBLE" | "REAL") ConstExp {MORE ConstExp} Term) |

         (("LONG" | "PTR") LongItem {MORE LongItem} Term) |

         (("INT" | "WORD") ConstExp {MORE ConstExp} Term) |

         (("CHAR" | "BYTE") (ConstExp | String) {MORE (ConstExp | String)} Term) |

         ("INCBIN" NameString Term) ;

(* Statements *)

STAT = ( "IF" Exp Term
           STATES
         {"ELSEIF" Exp Term
           STATES}
         ["ELSE" Term
           STATES]
         "ENDIF" Term

       ) |

       ( "WHILE" Exp Term
            STATES | {"EXIT" Exp Term}
         "ENDWHILE" Term

       ) |

       ( "REPEAT" Term
            STATES | {"EXIT" Exp Term}
         "UNTIL" Exp Term

       ) |

       ( "FOR" Var ":=" Exp "TO" Exp ["STEP" ["-"] Int] Term
            STATES | {"EXIT" Exp Term}
         "ENDFOR" Term

       ) |

       ( "LOOP" Term,
            STATES | {"EXIT" Exp Term}
         "ENDLOOP" Term

       ) |

       ( "SELECT" Exp Term
         ({"CASE" Exp {MORE Exp} Term}
            STATES)
         ["DEFAULT" Term
            STATES]
         "ENDSELECT" Term

       ) |

       ( "SELECT" ConstExp "OF" Exp Term
         ({"CASE" ConstExp ["TO" ConstExp] | {MORE ConstExp ["TO" ConstExp]} Term}
            STATES)
         ["DEFAULT" Term
            STATES]
         "ENDSELECT" Term

       ) |

       ( SINGSTAT

       ) |

       ( INLINE

       ) ;

SINGSTAT = (("IF" Exp "THEN" SINGSTAT ["ELSE" SINGSTAT]

            ) |

            ("WHILE" Exp "DO" SINGSTAT

            ) |

            ("FOR" Var ":=" Exp "TO" Exp ["STEP" ["-"] Int] "DO" SINGSTAT

            ) |

            ("INC" Var

            ) |

            ("DEC" Var

            ) |

            ("NEW" (Var [Deref] [Method] {MORE Var [Deref] [Method]}) |
                    (ImmList) |
                    (ImmString)

            ) |

            ("END" Var [Deref] {MORE Var [Deref]}

            ) |

            ("SUPER" Var [Deref] Method

            ) |

            ("JUMP" Label

            ) |

            ("RETURN" ExpList

            ) |

            (VarDo

            ) |

            (UniExp

            ) |

            (Var "," Var ["," Var] ["," Var] ":=" Exp

            ) |

            (Function

            )

            ("VOID" Exp

            )

           ) {"BUT" SINGSTAT} Term ;

STATES = {STAT} ;

(* Variables, members, index, methods *)

Index = "[" [Exp] "]" [Select | PtrType] ;

Select = "." Memb [Deref] ;

Method = "." Meth Params ;

PtrType = "::" Obj Select ;

Deref = PtrType | Index | Select ;

IncDec = "++" | "--" ;

Assign = ":=" Exp ;

VarDo = Var [Deref] ([IncDec] [Assign]) | Method ;

VarExp = VarDo | (["NEW"] Var [Deref]) | ("SUPER" Var [Deref] Method) ;

LabExp = Label [Deref] ;

(* Strings *)

StringChar = any-character-except-quote ;

NameChar = LetAC | "_" | Digit | "/" | ":" ;

NameString = "'" {NameChar} "'" ;

String = "'" {StringChar} "'" ;

ImmString = ["NEW"] String {"+" String} ;

(* Lists *)

ExpList = [Exp {MORE Exp}] ;

ImmList = ["NEW"] "[" ExpList "]" ListType ;

Params = "(" ExpList ")" ;

Returns = ExpList ;

(* Types *)

BasicTypeName = "CHAR" | "BYTE" | "INT" | "WORD" | "LONG" | "FLOAT" | "DOUBLE" | "REAL" | "PTR" ;

BasicType = ":" BasicTypeName ;

ObjType = ":" Obj ;

PtrType = ":" "PTR" "TO" (BasicTypeName | Obj) ;

ArrayType = "[" ConstExp "]" ":" "ARRAY" "OF" (BasictypeName | Obj) ;

ListType = "[" ConstExp "]" ":" "LIST" ;

StringType = "[" ConstExp "]" ":" "STRING" ;

ListType = "" | BasicType | ObjType ;

FuncType = "(" {"LONG" | "PTR" | "DOUBLE" | "REAL"} ")" ["(" {"LONG" | "PTR" | "DOUBLE" | "REAL"} ")"] ;

VarType = "" | BasicType | ObjType | PtrType | ArrayType | ListType | StringType | FuncType ;

MembType = "" | BasicType | ObjType | PtrType | ArrayType ;

ArgType = "" | PtrType | "LONG" | "FLOAT" | "REAL" | "DOUBLE" | "PTR" | FuncType ;

(* Operators *)

Math = "+" | "-" | "*" | "/" ;

Bitwise = "AND" | "OR" | "SHL" | "SHR" ;

Compare = "<" | ">" | "<=" | ">=" | "<>" | "=" ;

(* ConstExp *)

ConstVal = ["-"] Const | ImmVal | ("SIZEOF" Obj) | "STRLEN" ["!"] ;

ConstOp = Math | Bitwise ;

ConstExp = ["!"] ConstVal {ConstOp ConstVal} ;

(* Expressions *)

Function = (Var Params) | (Ifunc Params) | (Lfunc Params) | (Proc Params) ;

LabAddr = ("{" Label "}") | Label ;

VarAddr = "{" Var "}" ;

IfExp = "IF" Exp "THEN" Exp "ELSE" Exp ;

SimpleExp = VarExp |
            ConstExp |
            ImmString |
            ImmList |
            Function |
            LabAddr |
            LabExp |
            VarAddr |
            Reg ;

ExpVal = ["-"] SimpleExp | IfExp | UniExp ["!"] ;

ExpOp = Math | Bitwise | Compare ;

Exp = ["`"] ["!"] ExpVal {ExpOp ExpVal} ["BUT" Exp] ;

(* Unification *)

UniItem = Var | ImmVal | Const | "*" | UniList ;

UniList = ("[" [UniItem {MORE UniItem}] "]" [":" "LONG"]) ;

UniExp = SimpleExp "<=>" UniList ;


(* Grouping *)

(* ..Grouping "(" ... ")" can be applied to almost any valid expression.. *)

(* Program *)

Program = {OPT} {MODULE} {DECL | INLINE} ;




@endnode

@node limits

#-------------------------------------------------------------------#
|  Limits                                                           |
#-------------------------------------------------------------------#

Hardcoded limits:
~~~~~~~~~~~~~~~~~

Maximum values:


- globals

   # of global variables in application (private+public)      4000..8000
   total size of global data                                  *

- immediate

   # of entries for an immediate list                         32767 (checked)
   max length of one immediate string                         16000
   total length of one continued immediate string ("+")       16000

- static

   max length of one immediate string                         16000
   total length of one continued immediate string ("+")       16000
   # of list entries / total list size                        *

- arrays

   # of elements in one array [#]                             32767 (checked)
   total size of one local array                              <32k  (checked)
   total elements of one global array                         32767 (checked)
   total size of one array inside object                      <32k  (checked)

- procedures / methods

   # of arguments                                             255
   # of local variables / procedure                           4000..8000
   size of procedure local data                               32k     (checked)
   size of procedure code                                     min 32k (checked)

- internal functions

   # of arguments to WriteF(), StringF() etc                  1024

- objects

   # of members in one object                                 2048
   # of methods in one object                                 2048
   size of one object                                         32k   (checked)

- assembler

   length/size of CHAR/INT/LONG/INCBIN data declarations      *

- preprocessor

   size in bytes of of macro body before/after expansion      16000 (checked)
   # of fixed arguments for macro                             16    (checked)
   # of variable arguments for macro                          *
   macro nesting                                              - (stack checked)

- misc

   identifier length in characters                            255
   # of modules used in one application                       *
   size of ascii source                                       *
   # of lines in ascii source                                 *
   width of one line                                          1000 tokens
   total length of a continued ("+", ",", "(", etc)) line     *
   codesize of one module                                     16M
   codesize of executable                                     32M

   *   : No real limit (to my knowledge :-)).
         Available memory will most likely be the ultimate limit.



@endnode

@node currlimits

#-------------------------------------------------------------------#
|  Current limits                                                   |
#-------------------------------------------------------------------#

   o  ECX.68k currently cannot handle floating point immediate values
      with more than 9 digits in total.

   These limitations might be changed if there is need.

   o (PPC) Max 8 double arguments for functions.

   o (68K) Max 7 double arguments for functions.


@endnode

@node ecbinmods

#-------------------------------------------------------------------#
|  EC binary modules support                                        |
#-------------------------------------------------------------------#

   When ECX stumbles on an EC-module, it immediately translates it
   (internally) to the ECX module format before using it further.

   ECX may place the resulting module in the cache as any other module,
   if the cache has not been deactivated.

   Notes:

      Methods from EC / CreativE binary modules cannot be used.

      CreativE modules:

         New internal functions are not implemented in ECX and will
         give an error message.

         New internal globals will be NIL. It isn't possible for ECX
         to see if a module is using these, so no error message will
         appear.

         New V51: CreativE modules using the internal global "__pool"
         now works.


@endnode

@node tools

#-------------------------------------------------------------------#
|  Tools                                                            |
#-------------------------------------------------------------------#

   Tools in the E:bin/ drawer
   ==========================


   ViewModule     - MODULENAME/A
                    View contents of binary module.

   ViewCache      - View contents of modulecache.

   EmptyCache     - Empty the modulecache.
                    Optionally may remove modules using pattern.

   TrackHit       - EXENAME/A, OFFSET
                    Shows source and linenumber for a given offset into exe.
                    ADOS Executable must have been compiled with LINEDEBUG/S
                    switch. Example: trackhit bla $eb8

   DisHunk        - FILENAME/A, DIS/S
                    Amiga DOS Hunk viewer, with optional PPC-disassembly.
                    Does not really support much more than is needed to display
                    ECX ADOS binaries :)

   DisELF         - Show contents of ELF files, with optional PPC-disassembly.
                    FILENAME/A  --  name of ELF file.
                    DIS/S       --  disassemble sections
                    HIT/N       --  offset to locate for hit-information.
                    SECT/K      --  view only this section (name).
                    (For a more advanced tool to look at ELFs, I recommend
                     "MorphOS_SDK:DevEnv/Bin/objdump")

   ModuleFromFD   - Convert an .fd (function definition) file to an ecx module.
                    Currently supports standard Amiga FD and MorphOS FD.
                    FD/A          --  the name of the FD file.
                    MODULEDIR/A   --  directory to place resulting module in.
                    VERBOSE/S     --  show some info.
                    BASE/K        --  use another name of librarybase.
                    NAMEFIX/S     --  fix case of beginning letters of
                                      functions to Xx.

   ModuleFromProto - Convert a textfile with C function prototypes into
                     an e library module. See bin/modulefromproto.readme.

   CeeModule       - View module in a C friendlier way.
                     Supports library functions, objects and constants.
                     MODULE/A       - name of module with or witout .m
                     LIBPROTOS/S    - Normally library functions are
                                      displayed FD-style. With this
                                      switch they are displayed
                                      as C prototypes.

   MakeLibMod     -  Create a library module.
                     Replaces old ModuleFromFD and ModuleFromProto tools.
                     No more documentation for now. It is in a bit of early
                     state, and things might change, but was used to create
                     all the library modules for OS4 and MOS2.

@endnode

@node targdetails

#-------------------------------------------------------------------#
|  Target Details                                                   |
#-------------------------------------------------------------------#

- 68k binaries -

   o Register usage:

      D0-D2   : return values [scratch]
      D3      : local scratch (callee save for compatibility)
      D4-D7   : register-variables [save]
      A0-A3   : scratch
      A4      : global pointer
      A5      : frame pointer
      A6      : librarybases [scratch]
      A7      : stack pointer

      F0 - F7 : floating point scratch
      F1 - F7 : double parameters


   o Internal functions:

     Thanks to Wouter for letting me use the internal functions of the EC compiler.

- PPC binaries -

   o A lot of the smaller internal functions are permanently put inline.
     Inlined functions:
        Char(), Int(), Long(), PutChar(), PutInt(), PutLong(), ListItem(),
        ListLen(), EstrLen(), StrMax(), ListMax(), SetStr(), SetList(),
        ObjSize(), ObjName(), Shr(), Shl(), Not(), Or(), Eor(), And(),
        Odd(), Even(), Link(), Next(), Eval(), Mul(), Div(), Car(), Cdr(),
        Double(), PutDouble(), Ptr(), PutPtr(), Real(), PutReal(), Float(),
        PutFloat(), Word(), PutWord(), Byte(), PutByte(), Fabs()

   o Functions/procedures takes their arguments in registers (r3..r10).

   o Additional parameters to functions and procedures (>8 params)
     are passed on the stack. "self" is passed in R12.

   o Register usage is following: (SysV / MorphOS)

     R0        : scratch
     R1        : stack pointer
     R2        : reserved for system
     R3  - R5  : return-values [scratch]
     R3  - R10 : parameters to functions and procedures [scratch]
     R11,  R12 : scratch
     R13       : global environment pointer
     R14 - R19 : save
     R20 - R31 : register variables [save]

     F0  - F13 : scratch
     F1  - F8  : floating point parameters to functions and procedures [scratch]
     F1  - F4  : floating point return values [scratch]
     F14 - F19 : save
     F20 - F31 : floating point register variables [save]

     V0  - V19 : vector scratch
     V2  - V13 : vector parameters to functions and procedures [scratch]
     V2  - V5  : vector return values [scratch]
     V20 - V31 : vector register variables [save]


- 68k and ppc binaries -

   String(), List(), DisposeLink() functions now uses a private
   exec/memorypool. This makes allocation faster, deallocation and
   end_of_program_auto_allocation much faster. You also save 4 bytes
   for each string/list. It also means runtime memlist gets less
   cluttered so Dispose() function may get much faster too.

@endnode

@node compdetails

#-------------------------------------------------------------------#
|  Compiler details                                                 |
#-------------------------------------------------------------------#


   ECX sets the shell variable "Result2" to the linenumber on an error.


@endnode


@node bugs

#-------------------------------------------------------------------#
|  Bugs                                                             |
#-------------------------------------------------------------------#


   Reporting bugs
   --------------

   If you find a bug, send a mail about it to "dev at blubbedev dot net"
   with subject "ECX bug".

   You could also join the mailinglist and post it there.

@endnode

@node otherfaq

#-------------------------------------------------------------------#
|  Other FAQ                                                          |
#-------------------------------------------------------------------#

   Q: How do i use MUI on MorphOS ?

   A: As of ECX 2.0, no changes are normally needed, but see
      next question.


   Q: My hookfunction is defined like this and it doesn't work:

      PROC myhook(o, m)
         ...
         ...
      ENDPROC

   A: This is a sloppy hookfunction that just happens to work on 68K
      because the stack is used to store arguments. This does not work
      on PPC. Always use the correct # of arguments (3), even if you dont
      use all of them. (Your function will continue to work on 68K).

      PROC myhook(h, o, m)


   Q: EasyGUI wont compile/work on PowerPC

   A: Forget EasyGUI. It is not PowerPC compatible at all but does tricks
      on the 68k stack with arguments which cannot work on PowerPC. It is not
      enough to fix EasyGUI itself, all applications using it must be fixed too.
      So.. forget it.


@endnode

@node langfaq

#-------------------------------------------------------------------#
|  Language FAQ                                                     |
#-------------------------------------------------------------------#


   Q: I define an array and later I try to modify it like a variable,
      but it doesn't work!?

   A: Arrays are not variables to ECX, they are addresses made up of an
      offset relative to a baseregister. So it cannot be changed. This is
      not true for global arrays though, because they need to be able to
      merge with exported globals from modules. ECX will complain anyway
      if you modify a global array. Solution: use pointers, or modify
      _contents_ of array instead.

   --------------------------------------------------------------------------

   Q: I have a float expression like
      y := Fabs(!x+3.3)*0.5
      and ECX compiles this wrong !?!

   A: EC/Creative in the above example lets the "!x+3.3" float
      expression "leak" the float mode outside of the parentheses.
      This is undocumented behaviour, not even sure if it is deliberate.
      A problem with this is that it makes an expression like following
      impossible: y := func_returning_integer_but_taking_float(!a*b) + 12
      And what should happen in this case ?
      y := myfunc(a, !x+3.3, b) * 0.5

      Anyway, the correct syntax for the code in question
      (works on all E compilers):

      y := !Fabs(!x+3.3)*0.5

   -----------------------------------------------------------------------------

   Q: I have allocated large arrays of data on the stack and ECX complains,
      what gives ?

   A: ECX limits data on the stack for each procedure to 32k.
      Making ECX support above that is not worth the effort.

      Workarounds:

      a) Make the array global instead. Great solution unless you need
         to be recursive or multi threading safe.

      b) Allocate/deallocate the array dynamically. Might sometimes have
         A negative inpact on speed, but allows size to change runtime.

      c) Simply let the procedure take the array as argument from its caller.
         A very powerful solution when it fits the situation.

   -----------------------------------------------------------------------------

   Q: SdivMod32()/UdivMod32() from utility.library does not work when compiling
      for PowerPC MorphOS, why ?

   A: These functions do not work for PowerPC native programs from C either,
      because of a bug in their implementation. Maybe this has been fixed
      in MorphOS 2.x, maybe not. Anyway, ECX's built-in Mod() is fully 32bit
      so atleast SdivMod32() is not needed anymore.

@endnode

@node thanksto

#-------------------------------------------------------------------#
|  Thanks To                                                        |
#-------------------------------------------------------------------#

   Thanks and greetings to following people:


   Wouter van Oortmerssen

      The creator of AmigaE and EC, amongst many other things

      "wouter.fov120.com"

   Ingo Musquinier

      "amigazeux.org"

   Matthias "UltraGelb" Böcker

      Biggest ECX beta tester and coder of many cool apps :)

      "amigazeux.org"

   Chris S Handley

      For the idea and initiative to restart the AmigaE-List.
      Also author of "PortablE".

      "cshandley.co.uk/portable/"

   All the folks at the original and the new AmigaE-List.

      "http://home.intercom.it/~fsoft/amiga/elist/"
      "www.freelists.org/list/positron"

   Frank Wille

      His excellent assemblers and linkers, and other stuff..

      "devnull.owl.de/~frank/index_e.html"

   MorphOS Development Team

      "www.morphos-team.net"

   Damien Guichard

      "membres.lycos.fr/brickcaster/"
      "perso.wanadoo.fr/alphablock/"

   Stefan Haubenthal


   Ilka Lehtoranta

      Maker of OS4Emu, which was useful for ECX os4 support.

      "www.lehtoranta.net"

   Tomasz Wiszkowski

      Author of CreativE compiler.

   Martin Kushinka

      Author of PowerD compiler.

========================================================

   Special thanks go to those who donated money:

   Damien Guichard,
   Ingo Musquinier,
   Jens Holzammer,
   Karoly Balogh

========================================================

   Special thanks to those who donated hardware:

   Genesi, bplan, Phoenix Developers Consortium

      They supplied me with a Pegasos "PhreeBoard", which made
      developing this piece of software ALOT easier !

      "www.pegasosppc.com"
      "www.phinixi.com"
      "www.morphosppc.com"
      "www.bplan-gmbh.de"
      "developer.morphosppc.com"

========================================================

   And thanks to you who registered..


@endnode

@node ecxauthor

   The author of this software is Leif Salomonsson.

   ECX is Copyright 2002-2008 by the author.

   How to reach the author:

      Email: dev at blubbedev dot net


@endnode

@node debugtips

#-------------------------------------------------------------------#
|  Debugging tips                                                   |
#-------------------------------------------------------------------#

   When you find yourself having alot of

   #ifdef DEBUG
   DebugF(...)
   #endif

   all over your source, it could be time to make things more maintainable.

   #define DEBUG /* comment me out for no debugging */

   #ifdef DEBUG
      #define DEBUGF(str,...) DebugF(str,...)
   #else
      #define DEBUGF(str,...)
   #endif

   ..now you can just put "DEBUGF(...)" in your source instead and save 2
   lines each time.

   Maybe you want to have debugging to standard console instead, just define
   "DEBUGF()" as "WriteF()" and so on..

@endnode

@node crosscomp

#-------------------------------------------------------------------#
|  Cross compilation tips                                           |
#-------------------------------------------------------------------#

   [Pretty much obsolete as of ECX 2.0]


   When you find yourself having lots of conditional compilation
   in lots of modules to select between target specific modules
   (like hooks, threads, and so on) it might be time to put all
   conditional compilation into its own module instead. Lets call
   it modules.e.  It could look something like this:

->8------------------------------------------------

OPT PREPROCESS
OPT MODULE
OPT EXPORT

->  if compiled with ec/creative we automatically set CODE_AMIGAOS
#ifndef ECX_VERSION
#define CODE_AMIGAOS
#endif

#ifdef CODE_MORPHOS
#define m_muicustomclass 'muiabox/muicustomclass'
#define m_ecode 'otherabox/ecode'
#define m_installhook 'toolsabox/installhook'
#define m_thread 'toolsabox/thread'
#define m_boopsi 'aboxlib/boopsi'
#define m_lists 'aboxlib/lists'
#define m_time 'aboxlib/time'
#define m_tasks 'aboxlib/tasks'
#define m_random 'aboxlib/random'
#define m_ports 'aboxlib/ports'
#define m_io 'aboxlib/io'
#define m_cx 'aboxlib/cx'
#define m_argarray 'aboxlib/argarray'
#endif

#ifdef CODE_AMIGAOS
#define m_muicustomclass 'mui/muicustomclass'
#define m_ecode 'other/ecode'
#define m_installhook 'tools/installhook'
#define m_thread 'tools/thread'
#define m_boopsi 'amigalib/boopsi'
#define m_lists 'amigalib/lists'
#define m_time 'amigalib/time'
#define m_tasks 'amigalib/tasks'
#define m_random 'amigalib/random'
#define m_ports 'amigalib/ports'
#define m_io 'amigalib/io'
#define m_cx 'amigalib/cx'
#define m_argarray 'amigalib/argarray'
#endif

->8-----------------------------------------------

   using the modules would then look something like this:

->8-----------------------------------------------

OPT PREPROCESS
MODULE '*modules'
MODULE m_muicustomclass
MODULE m_ecode
MODULE m_installhook
MODULE m_thread
MODULE m_boopsi
MODULE m_lists
MODULE m_time
MODULE m_tasks
MODULE m_random
MODULE m_ports
MODULE m_io
MODULE m_cx
MODULE m_argarray
..other modules here..

->8--------------------------------------------------


When compiling with ecx, use the DEFINE argument to select target:

> ecx modules.e define CODE_MORPHOS
> ecx ..other modules.. <opts>
> ecx main.e <opts>


@endnode

@node linkobject

#-------------------------------------------------------------------#
|  Linkobject mode                                                  |
#-------------------------------------------------------------------#

   "LINKOBJECT" in source switches on LINKOBJECT mode.

   In this mode, ECX will output an ELF linkable object.

   This is mainly useful if you want to link some E code together with
   some C code or so, by using an external linker.

   Notes:

   - Code from modules can not be used from linkobject.
     Anything else from a module can be used.

   - You can not use the internal functions in linkobject mode.
     If you attempt to use them, the linkobject will be having external
     references to the functions that you used. This way if you have another
     linkobject with replacement functions in it, just link it with your
     linkobject..  and voila.

   - You can make use of external functions/labels from your linkobject by
     using the USES keyword after LINKOBJECT:
     Example:
        LINKOBJECT USES
        Bla(),
        alabel,
        AnotherFunc(x,y,z),
        YetAnotherOne(i:LONG, f:DOUBLE) (DOUBLE,LONG)

   - You can export globals, procedures and constants from your linkobject,
     just put EXPORT in front of the stuff you want exported.

   - Be aware that some language constructs might need access to internal
     functions, which means these functions have to be available from some other
     linkobject when linking. NEW/END needs access to FastNew()/FastDispose()
     and int->float conversion needs a special function. Nilcheck needs access
     to Throw() function.

   - External librarybases needs special handling. C uses DOSBase, E uses
     dosbase.. etc.
     EXPORT DEF has an extension in LINKOBJECT mode for this situation:
     Example:
         OPT MORPHOS
         LINKOBJECT
         MODULE 'exec'
         EXPORT DEF execbase AS SysBase

   - No default modules are automatically loaded.

   - This is experimental stuff for now..

@endnode

@node integer64

#-------------------------------------------------------------------#
|  64bit integers                                                   |
#-------------------------------------------------------------------#

   ECX supports 64bit integers on 32bit targets.

   The WIDE type has the usual versions:

      WIDE, PTR TO WIDE, ARRAY OF WIDE

   It can be used anywhere (objects, locals, arguments, globals, lists).

   Usage is similar to how floating point is handled.

   To make computations (math,bitwise,comparison) in full 64bit, the
   @ (at) sign is used:

      x := @ y * z -> switch into 64bit mode and do multiplication.

      IF @ x < y   -> switch into 64bit mode and make comparison.

   Note that there is not need to explicetly convert between
   64bit integers and 32bit integers, scaling is automatic.

   Assignment, ++, --, +=, etc does not need the @ sign. Same with
   simple testing of values with IF, WHILE, UNTIL, EXIT, etc:

      wide := wide2
      long := wide
      wide := wideptr[]++
      widey := func()
      wide += 100
      WHILE mywide--
      IF widereturningfunc()
      ...

   SELECT accepts wides too:

      SELECT mywide
      CASE something -> compares in full 64bit
      ...

      Note that the compiler looks at "mywide" here to decide whether to
      go into 64bit mode or not. "something" can have any number of bits
      but does not alter mode.

   New internal functions:

      Mod64()        -  64bit version of Mod().
      UlongToWide()  -  Convert LONG to WIDE without extending sign.

   Notes:

      All the math/bitwise/comparison operators works in 64bit mode too.

      64bit "/" operator and Mod64() function does not support negative
      values for now. They might in future. So only pass them positive
      values.

      "WIDE" and "ARRAY OF WIDE" are 4byte aligned in objects by default.

      This feature is only for powerpc for now.

      ECX does not support 64bit immediate values yet. Seldom needed though.

@endnode


