@database BFBPlayMaster.guide
@version $VER: 1.0 BFB Team productions.
@width 80

@node main "BFBPlayMaster.guide autodoc"

	BFBlplaymaster.library v1.0 autodocs.
	-------------------------------------

	  Welcome to the autodocs of bfbplaymaster.library. This is a multi-
	format module replayer library system. Soon enough you will realise
	how easy it's to use these libraries in your own applications like
	moduleplayers, games or other software. The complete package is
	rather large (all sub libs and the master lib) and that's why I've
	build the libraries in a way that they can completely be accessed
	without the master library. See the @{" Sublib autodocs " link BFBPlayXXXX.guide/main } for
	more details about using sub libs directly. However, please read
	these docs also, they are full of important information.

	@{" BFBCheckModule ()     " link bfbcheckmodule }	Checks a file if it's a module.
	@{" BFBLoadModule ()      " link bfbloadmodule }	Load a module for you.
	@{" BFBUnLoadModule ()    " link bfbunloadmodule }	Unloads a module.
	@{" BFBForceLoadModule () " link bfbforceloadmodule }	Same as Loadmod, but without checks.
	@{" BFBPlayModule ()      " link bfbplaymodule }	Start playing the module.
	@{" BFBStopModule ()      " link bfbstopmodule }	Stop playing the module.
	@{" BFBContModule ()      " link bfbcontmodule }	Continue a stopped module.
	@{" BFBNextPage ()        " link bfbnextpage }	Jump to next page.
	@{" BFBPreviousPage ()    " link bfbpreviouspage }	Jump to previous page.
	@{" BFBChangeModule ()    " link bfbchangemodule }	Change song inside the module file.
	@{" BFBGetSampleNames ()  " link bfbgetsamplenames }	Get sample names of module.
	@{" BFBAuthorInfo ()      " link bfbauthorinfo }	Get the real author of the replayer.
	@{" BFBGetError ()        " link bfbgeterror }	Translate error code into string.
	@{" BFBAllocChannels ()   " link bfballocchannels }	Allocate audio channels.
	@{" BFBFreeChannels ()    " link bfbfreechannels }	Free audio channels.

	(c) 1996 Jarkko Vatjus-Anttila (a BFB Team production)

@endnode

@node bfbcheckmodule "BFBCheckModule()"

NAME
	BFBCheckModule() -- Check if the file is a module.

SYNOPSIS
	modtype = BFBCheckModule( struct *TagList )
	 d0			   a0

FUNCTION
	  BFBCheckModule checks if the file you passed as an argument is
	a module or not. Note that this routine is capable to recognize more
	modules than you may have sub-replayer libraries. That's why you may
	get errors like: "No replayer-library available for this module type"
	if you try to load a module that has been identified to be a module.

INPUTS
	taglist - Pointer to a standard taglist that contains all needed
		information for this routine. Accepted tags are those
		that follow (all others are ignored).

	BFBTAG_SongName, BFBTAG_SongFH and BFBTAG_SongBuf. See descriptions
	in file @{" Developer.guide " link developers.guide/tags }

RESULT
	modtype  - A number indicating the module type. If an error
		   occured, then this value is negative and should be
		   considered as an error code. See bfbplay.i for more
		   details about errorcodes and moduletype flags. 

BUGS
	None known

NOTES
	  As you may well imagine, no check routine is perfect. Let's take
	an example: I check if the file is a Player 6.0a or Player 6.1a by
	checking if there's a "P60A" or "P61A" sign in the beginning of the
	module. If there isn't such mark, then my check routine fails and
	the file will not be recognized. However, if you are certain that
	the file you have *IS* a module, then you may bypass this check
	and use the @{" BFBForceLoadModule() " link bfbforceloadmodule } to load it to memory.

@endnode

@node bfbloadmodule "BFBLoadModule()"

NAME
	BFBLoadModule() -- Load a module file into memory.

SYNOPSIS
	errorcode = BFBLoadModule( struct *TagList )
	 d0			    a0

FUNCTION
	  BFBLoadModule() load a file into memory resulting a pointer to
	modinfo structure that is initialized to correct values. If this
	routine returns with success, then you are free to read the fields
	of modinfo structure. Remember that this routine includes a check
	if the requested file is a module, so you do not need to check it
	yourself before calling this. Note also that if you are absolutely
	sure that you are trying to load a module, but this routine still
	fails in checking it, then it might be better to use
	@{" BFBForceLoadModule() " link bfbforceloadmodule } instead.

	  BFBLoadModule() calls equivalent SubLibrary and it takes care
	that the module is loaded into right type of memory.

INPUTS
	taglist - A pointer to a taglist array that tells everything
		  needed information for this routine. Accepted tags are:
		  (All other tags are ignored.)

	Everyone but the BFBTAG_ModType. See @{" Developers.guide "link developers.guide/tags } for
	more details.

RESULT
	errorcode      - A negative error code if a failure has happened,
			 otherwise this is 0. The error code can be translated
			 into a string with @{" BFBGetError() " link bfbgeterror } function. 
			 See includes for definitions of the different error
			 codes.
BUGS
	None known

NOTES
	  After calling this routine all fields in structure modinfo are
	initialized except the mi_SampleNameBuffer. This is initialized by
	@{" BFBGetSampleNames " link bfbgetsamplenames } and must be called separately after this
	function.

	  PSID modules differ from other modules in a way that they can have
	a special "main tune" in the module file. If user is going to change
	a song inside a PSID tune, this "main tune" value should be fetched
	from mi_CurrentModule right after BFBLoadModule. If this is not done,
	changing the song may cause unexpected results.

@endnode

@node bfbunloadmodule "BFBUnLoadModule()"

NAME
	BFBUnLoadModule() -- Frees all resources that were allocated by last
	module format.

SYNOPSIS
	BFBUnLoadModule( struct *modinfo )
	 		  a0

FUNCTION
	  This routine frees absolutely everything that the current module
	might have allocated for it's playiback. This includes interrupts,
	memories and audiochannels. Take a special care noting that this
	function also deallocates the modinfo structure you just passed as
	an argument. This is done always, no matter who allocated it. That's
	why *NONE* of the modinfo fields nor the modinfo structure itself
	should be used for anything anymore.

	  I know that this deallocation process can in some special situations
	be very annoying. That's why I planned to create a special tag for
	this purpose: BFBTAG_FreeResources (TRUE/FALSE). As you can imagine,
	if you pass this tag set to false, the resources would not be freed,
	but somewhy I never managed to program this tag. However, this is
	in my top 10 list.

INPUTS
	struct modinfo - Pointer to a modinfo structure that was gained from
			 @{" BFBLoadModule " link bfbloadmodule }.

BUGS
	None known

NOTES
	  Currently this routine checks if the module is playing and stops
	it before freeing the resources. However, this is a feature that you
	may NOT rely on. It may change in the future. Use @{" BFBStopModule " link bfbstopmodule }
	before calling this.

@endnode

@node bfbforceloadmodule "BFBForceLoadModule()"

NAME
	BFBForceLoadModule() -- Same as @{" BFBLoadModule " link bfbloadmodule } but without checks.

SYNOPSIS
	errorcode = BFBForceLoadModule( struct *TagList )
	 d0                              d0

FUNCTION
	  This routine allows you to load files into memory without checking
	them first. This might be useful when you notice that some certain
	module fails loading with @{" BFBLoadModule " link bfbloadmodule } to an error that
	indicates that the check failed. This routine does not check the
	module at all, so it's quite easy to crash your machine with it.
	As you might imagine, loading a MED file as Player 6.1a and then
	replaying it WILL crash your machine without a doubt. I strongly
	recommend using the @{" BFBLoadModule " link bfbloadmodule }, but still take this routine
	as an option.

INPUTS
	taglist - This is a pointer in a taglist array telling the routine
		  all neccessary things. See descriptions of @{" tags " link developers.guide/tags }
		  in file Developers.guide.

RESULT
	errorcode      - This is a negative value if something went wrong.
			 In that case use @{" BFBGetError " link bfbgeterror } to convert the
			 errorcode into a string.

	If the loading process was succesfull, then a pointer to initialized
	ModInfo structure is returned. The pointer is stored into ti_Data
	field of BFBTAG_ModInfo tag and should be fetched right after this
	function. You did pass the BFBTAG_ModInfo tag, didn't you. ;)

BUGS
	None known

NOTES
	  After calling this routine all fields in structure modinfo are
	initialized except the mi_SampleNameBuffer. This is initialized by
	@{" BFBGetSampleNames " link bfbgetsamplenames } and must be called
	separately after this function.

	  PSID modules differ from other modules in a way that they can have
	a special "main tune" in the module file. If user is going to change
	module inside a PSID tune, this "main tune" value should be fetched
	from mi_CurrentModule right after BFBLoadModule. If this is not done,
	changing the module may cause unexpected results.

@endnode

@node bfbplaymodule "BFBPlayModule()"

NAME
	BFBPlayModule() -- Start playing of a modulefile.

SYNOPSIS
	errorcode = BFBPlayModude ( struct *modinfo )
         d0                          a0

FUNCTION
	  This routine starts playing the module. All resources that might
	be needed to play the module are allocated but will *NOT* be released
	until you call the @{" BFBUnLoadModule " link bfbunloadmodule }. These resources include
	interrupts and audiochannels. Please note that this routine allocates
	the channels with @{" BFBAllocChannels () " link bfballocchannels } routine, so you don't
	need to call it by yourself. However, double allocations are checked
	and ignored.

INPUTS
	struct modinfo - Pointer to initialized structure gained from
			 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	errorcode - 0 if success, else a negative error code. See bfbplay.i
		    for more details about these.

BUGS
	None known

@endnode

@node bfbstopmodule "BFBStopModule()"

NAME
	BFBStopModule() -- Stop module playing.

SYNOPSIS
	BFBStopModule( struct *modinfo )
			a0

FUNCTION
	  This routine stops the module playing. Interrupts stop running,
	but they are not removed. The audio channels stay allocated too.
	In case you need to return all allocated resources, you have to
	call @{" BFBUnLoadModule " link bfbunloadmodule }.

INPUTS
	struct modinfo - Pointer to modinfo structure gained from
			 @{" BFBLoadModule " link bfbloadmodule }

BUGS
	None known

@endnode

@node bfbcontmodule "BFBContModule()"

NAME
	BFBContModule() -- Continue an interrupted module.

SYNOPSIS
	errorcode = BFBContModule( struct *modinfo )
	 d0                         a0

FUNCTION
	  This routine continues the module after calling a @{" BFBStopModule " link bfbstopmodule }.
	Remember that not all modules can be continued.

INPUTS
	struct modinfo - Pointer to modinfo structure received from
	                 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	errorcode - -1 if module was unable to continue or 0 if success.

BUGS
	None known

NOTES
	  To test if module supports continuing, call this routine after
	@{" BFBLoadModule " link bfbloadmodule } but before @{" BFBPlayModule " link bfbplaymodule }. The module will not
	start playing, but the result is -1 if the module does NOT support
	the continue option or 0 if it does.

@endnode

@node bfbnextpage "BFBNextPage()"

NAME
	BFBNextPage() -- Jump to next page of current module.

SYNOPSIS
	error = BFBNextPage( struct *modinfo )
	 d0                   a0

FUNCTION
	  If the current module supports jumping between patterns this routine
	will do it. Checks are included so you cannot jump to patterns that
	do not exist. If the current moduletype supports pagejump, the
	Field mi_CurrentPattern in struct modinfo is updated by this
	function, so you can read the value and use it for your own
	purposes.

INPUTS
	struct modinfo - Pointer to modinfo structure received from
	                 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	error - If the module does NOT support page jumping, then this
		return code is -1, else 0. The returned code is not a
		valid errorcode. Do not try to use @{" BFBGetError " link bfbgeterror }

BUGS
	None known.

NOTES
	  This function is safe to call. If module type doesn't support
	jumping between pages, this function is obsolete and simply does
	nothing. (Except sets the return code 0).

@endnode

@node bfbpreviouspage "BFBPreviousPage()"

NAME
	BFBPreviousPage() -- Browse module patterns backwards.

SYNOPSIS
	error = BFBPreviousPage( struct *modinfo )
	 d0			  a0

FUNCTION
	  This function is similiar to @{" BFBNextPage " link bfbnextpage }, but it browses
	pages backwards. You cannot jump to the paterns that do not exist, so
	it's safe to call this even you are at the beginning of the module.

INPUTS
	struct modinfo - Pointer to modinfo structure received from
	                 @{" BFBLoadModule " link bfbloadmodule }.


RESULT
	error - If the module does NOT support page jumping, then this
		return code is -1, else 0. The returned code is not a
		valid errorcode. Do not try to use @{" BFBGetError " link bfbgeterror }

BUGS
	None known.

NOTES
	  This function is safe to call. If module type doesn't support
	jumping between pages, this function is obsolete and simply does
	nothing.

@endnode

@node bfbchangemodule "BFBChangeModule"

NAME
	BFBChangeModule() -- Change song inside the module.

SYNOPSIS
	currentmodnumber = BFBChangeModule( modnumber, struct *modinfo )
	 d0				     d0		a0

FUNCTION
	  Some moduletypes support having more than one songdata in one
	module file. With this function you can change the currently playing
	song.

INPUTS
	modnumber      - The number of module you want to be played.
	struct modinfo - Pointer to the modinfo structure received from
			 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	currentmodnumber - Number of module currently playing. If this
			   routine returns without error, this number is
			   the same that you passed as modnumber argument. 

BUGS
	None known.

NOTES
	  This routine is free to call. If there's no other songs in the
	module file or you've asked a song that doesn't exist then this
	routine has no effect.

@endnode

@node bfbgetsamplenames "BFBGetSampleNames()"

NAME
	BFBGetSampleNames() -- Get the sample texts from the module.

SYNOPSIS
	struct samplenames = BFBGetSampleNames( struct *modinfo )
	 d0					 a0

FUNCTION
	  After this routine you are able to read the sample texts of the
	current module, if the moduletype even has sample texts. In case the
	module has sample texts, a pointer to samplename structure is
	returned and can be used for your purposes. If you manage to trash
	this pointer, don't worry. It can be fetched from module info
	structure from field mi_SampleNameBuffer.

	  Briefly the structure of the samplenames structure is as follows:

	  structure	samplenames,0
		long	sn_NumberOfStrings
		long	sn_LengthOfEachString

		aptr	sn_FirstSampleString
		aptr	sn_SecondSampleString
		.
		.
		.
		aptr	sn_nthSampleString

		label	sn_SIZEOF

	sn_NumberOfStrings    - number of sample strings in this structure.
				(For ProTracker  this would be 31, but for
				PSID this would be only 2)
	sn_LengthOfEachString - length of one string in chars. This is
				passed in case the sample strings are not
				null terminated.
	sn_SampleStrings      - Pointers to sample strings.

INPUTS
	struct modinfo - Pointer to the modinfo structure received from
			 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	struct samplenames - Pointer to the samplename structure described
			     above. If module has no sample texts, then this
			     field is NULL, otherwise it contains a negative
			     error code. This error code can be translated
			     into a string with @{" BFBGetError " link bfbgeterror } function.

BUGS
	None known

NOTES
	  The field mi_SampleBufferPtr is initialized to point into this
	structure. In case you trash the pointer value returned in d0, then
	you can refetch the poineter from modinfo structure.

	  The samplenamebuffer is released when @{" BFBUnLoadModule " link bfbunloadmodule } is
	called.

@endnode

@node bfbauthorinfo "BFBAuthorInfo()"

NAME
	BFBAuthorInfo() -- Get the real author of current replayer.

SYNOPSIS
	authorstring = BFBAuthorInfo( struct *modinfo )
	 d0                            a0

FUNCTION
	  This routine will tell you the real author of the current replayer
	source. In some cases some additional info is added, too.

INPUTS
	struct modinfo - Pointer to the modinfo structure received from
			 @{" BFBLoadModule " link bfbloadmodule }.

RESULT
	authorstring - This is a pointer to a NULL terminated string that
		       tells the real author of current replayer source.
		       (For Protracker this would be "ProTracker 2.1b..." etc)
		       If you try to get info about something that is not
		       recognized as module you get NULL pointer. Note also
		       that the result can be a negative errorcode too.
		       In that case use @{" BFBGetError " link bfbgeterror }
BUGS
	None known

NOTES
	  This string can be directly used to be displayed somewhere, but
	remember that the somewhat long strings are split into smaller
	pieces around 60 characters and separated from each other by CR
	code. The string is NULL terminated.

@endnode

@node bfbgeterror "BFBGetError ()"

NAME
	BFBGetError -- Convert an error code into a string.

SYNOPSIS
	errormsg = BFBGetError( errorcode )
	 d0			 d0

FUNCTION
	This routine is meant to convert the possible error codes into
	strings. The strings that bfbplaymaster.library offers are
	descibed in the include files among the error codes.

INPUTS
	errorcode - an error code that some routine has returned. The codes
		    are defined in the includes.

RESULT
	errormsg - A pointer to the error message string. this can be used
		   directly for example with reqtools requesters. It's
		   null terminated and has never over 50 characters. See
		   includes for details.

NOTES
	the value passed for the function is not checked in any way. So
	you pass an invalid code (that is lower than -18 and bigger than 0),
	a crash is certain.

@endnode

@node bfballocchannels "BFBAllocChannels ()"

NAME
	BFBAllocChannels() -- Allocate audio channels for bfbplaymaster.library

SYNOPSIS
	errorcode = BFBAllocChannels()
	 d0

FUNCTION
	  BFBAllocChannels is meant to allocate audio channels for music
	playback. The channels are allocated with priority 127, so no-one
	who behaves in system-friendly way can steal the channels from the
	bfbplaymaster.library. Note that @{" BFBPlayModule() " link bfbplaymodule} calls this
	for you when starting playback, so you don't need to call this
	routine for it. However, it does no harm even if you do.

	  Note also that the channels are aalocated for the
	bfbplaymaster.library, so if there are several programs using the
	libraries this might cause some confusion.

INPUTS
	None

RESULT
	errorcode - An error code that can be converted into string with
		    @{" BFBGetError " link bfbgeterror }.

BUGS
	None known.

@endnode

@node bfbfreechannels "BFBFreeChannels ()"

NAME
	BFBFreeChannels() -- Free audio channels for other programs.

SYNOPSIS
	BFBFreeChannels()

FUNCTION
	  BFBFreeChannels frees the aalocated audio resources for public
	use. Note that @{" BFBUnLoadModule " link bfbunloadmodule } deallocates the channels
	for you if they were allocated at all. so you don't need to call
	this routine yourself. However, it does no harm even if you call.

INPUTS
	None

RESULT
	The channels are freed if they were allocated in first place.

BUGS
	None known

@endnode
