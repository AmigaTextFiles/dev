@database "MDArray"
@wordwrap
@node main
@title "Contents of MDArray"
@{b}The Contents Page@{ub}

@{"Introduction          " link Intro}
@{"Installing            " link Install}
@{"Features and drawbacks" link Feature}
@{"Instructions          " link Instruct}
@{"Special tricks        " link Tricks}
@{"Demo program          " link Demo}
@{"Future extras         " link Future}
@{"Overview of functions " link Overview}
@{"Basic usage           " link Basic}

@{"About the author      " link AboutMe}
@endnode

@node Intro
@title "Introduction to MDArray"
@next Install
@{b}Introduction@{ub}

MDArray is quite possibly something powerful hidden in the mere disguise of a simple E Module file. As the title hints, it stands for @{i}Muiti-Dimensional Arrays.@{ui} Yes, now you won't be limited by E's lack of supporting multi-dimensional arrays of which the author claims could be impossible too. (Read the FAQ in E.guide for more info.) Now you add this feature by yourself by using my support module, and even do tricks that would be hard to pull off even if E did properly support @{"MDA's." link MDA}

It works by giving you functions to initialize and set-up MDA's, but the real core of it is an index function that replaces a usual single index. It calculates a single index from a list of multiple-indexes you give it. Thus, it incorporates into single-dimensioned arrays well and they can be accessed as per norm as well. If you find it hard to understand at first, just keep reading through the guide and you will learn how it works.
@endnode

@node MDA
@title "What are MDA's"
MDA's. MDA stands for Multi-Dimensional Arrays if you didn't work it out or just wanted to see what information you would find out by clicking on that word. It probably didn't give you much more than you already know so you'd better do a "Retrace" or something similar now before I make you feel like more of an idiot than I'm making you feel like now!
@endnode

@node Install
@title "How to install MDArray"
@{b}Installation@{ub}

By double-clicking on the Install icon will start up a script that will install it for you. Don't worry, it's not too stupid or arrogant. It won't simply copy files without asking. There are two main files to install, 
obviously the module file and this documentation. The script will copy each file to a logical destination. In this case the module will go to directory "EModules:other" and the documentation will go to directory "HELP:". Before it copies it will bring up a file requester where you can select an alternate drawer if you wish or select "Cancel" to avoid copying particulars files. But watch out! Selecting "Okay" will give the go ahead and it will start copying files across. The script requires the command RequestFile to be resident in your C directory. You can off course, copy the files manually yourself, but the script is better than no installer at all. Even if its not the fancy official one used by commercial software.
@endnode

@node Feature
@title "Features and drawbacks of MDArray"
@{b}Features@{ub}

* Adds multi-dimensional array support (obviously)

* Incorporates neatly into your existing E code

* Utilizes normal arrays but expands their usefulness

* Major functions written in assembler for speed and memory optimizations

* Lets you do neat tricks such as having a multiple-choice for the way you
  can access an array

* It eats less than 1K of memory

* Not too many drawbacks


@{b}Drawbacks@{ub}

* Can make your E code look clumsy after a while (That's a contradiction!)

* Because of the way it incorporates MDA's, your code is somewhat slower
  than it would be if E did properly support MDA's (But hopefully not too
  much)

* It takes up memory (Oh yeah! Like 1K is really gonna put a load on your
  mind!)
@endnode

@node Instruct
@title "Instructions on using MDArray"
@{b}Instructions@{ub}

Obviously the first thing you need to know before going through these instructions is a basic knowledge of setting up an E program and of course the way E handles it's arrays. I'll assume that all the ground work is done for our E program and all we want to know now is how to incopriate the MDA module into it and how to use it.

It is also recommended you take a look a the overview of functions to gain a better understanding of what is going on. Functions will have a hypertext link to gain more information should you need it. I will also mention that each function of the MDArray module has the letters "mda" preceding it with an underscore, indicating what it is.


@{b}1. Setting up@{ub}
This takes three steps. First we "include" the module with a MODULE command, second we DEFine our array variables and third we call an initialisation routine. The first step is quite simple and involves something like this:

MODULE 'other/mdarray'

If the module is not in the "other" module directory then you will know where it is yourself and can include it how you like but it would be wise keep the module name as @{i}mdarray.@{ui}

The second step involves declaring your variable names. Let's say we want a chessboard array of type integer, and another array for demonstration purposes of type char which I'll call numbers. The multi-dimensional array data for our numbers array is also already in our E program, so we don't need to allocate separate memory for it. We will dimension it as 1x2x3. Not the most original, but that array will take up 6 bytes, which is short enough to get my point across. This will declare it:

DEF chessboard:PTR TO INT, numbers:PTR TO CHAR, numbersinfo

You will notice the extra variable at the end, this is to hold extra data for the MDA routines because our actual array is already allocated, and so cannot be contained in the one variable as our chessboard can. Let's set our numbers array to the following numbers:

numbers:=[000,001,002,010,011,012]:CHAR

The perceptive minded amoung you will have noticed (and with prior knowledge of how a normal multi-dimensional array works) that each number in the above array corrosponds to its actual 3d index, which is why each number (or element) has three digits.

The third step is to call an initialisation routine. What this will do is set-up exception ID's in case of fatal errors (like a required argument is missing) or when no memory is available. This requires a call to the 
function @{"mda_InitIDs()" link Overview} and in the simplest case just calling it with no arguments will do just fine. It takes two arguments. First, the ID for a fatal error and second, the ID for no memory. By 
default these are set to "MDA" and "MEM" in their respective order. So if you want too customize the fatal ID and use the default memory ID then calling it with one argument will just change the fatal ID. Below is a simple example to get you started and you should place it somewhere at the top of your main() procedure before anything major happens, especially using the other array functions. Setting an ID to zero will not cause any exceptions of that type to be raised and the function will return NIL instead should you wish it. It's syntax is mda_InitIDs(fatal="MDA",mem="MEM).

mda_InitIDs()


@{b}2. Array allocation and dimensioning@{ub}
Here we set up the arrays with the required arguments and allocate memory for them if required. This comes in the form of the @{"mda_Dim" link Overview} function. The @{i}Dim@{ui} means Dimension and is similar to the BASIC command DIM itself. It accepts four arguments, three must be given. These are the size of each element, number of indexes, an INT list of it's dimensions and a flag indicating weather memory should be allocated for the array data. As hinted above, the last one can be obmitted in which case memory @{i}will@{ui} be allocated. It's format is mda_Dim(size,indexes,dimensions,flags).
Currently only one flag is supported, and that is MDAF_DEF. Which indicates that you have already have memory allocated for your array or you have its data already in memory in which case it is not necessary to allocate memory for it. For size and indexes CONSTants have already been set up for readability. Size has the basic types CHAR, INT and LONG. Indexes is from a 2D to a 5D array. For other types and number of indexes just enter what you want yourself. For our chessboard each element is of type INT. A chessboard is an 8x8 grid and this will allocate one for us:

chessboard:=mda_Dim(MDA_INT,MDA_2D,[8,8]:INT)

And this will set-up our numbers array:

numbersinfo:=mda_Dim(MDA_CHAR,MDA_3D,[1,2,3]:INT,MDAF_DEF)

Please note the dimensions are an INT typed list. And this is all that is accepted. A default LONG list would look neater and would be less typing, but would make the internal programming of the MDA routines slower and more complicated, especially on 16-bit-like 68000 systems. It will have to do for now, unless a 32-bit version is made or an option is added to E to set a default type for lists for whatever else. While on the subject an IFNIL or IFNOT command would be good too, to test for FALSE conditions. It would avoid the IF NIL=(...) THEN... And an option to have a CHAR array in an object aligned on an odd word. I think you get my drift.


@{b}3. Array accessing and indexing@{ub}
The part you've been waiting for! There are two functions for accessing MDA's, @{"mda_Index()" link Overview} being the main one and an the alternate function @{"mda_Offset()' link Overview} which I won't go into detail here. It's very simple and because of the way it works it doesn't change the way you access your arrays too much. The index function takes two arguments, your indexes in an INT typed list and what you got back from mda_Dim(). Here's a few examples using the chessboard array:

@{i}Testing an element@{ui}
IF chessboard[mda_Index([3,2]:INT,chessboard)] THEN itstrue()

@{i}Copying an element to a variable@{ui}
piece:=chessboard[mda_Index([2,6]:INT,chessboard)]

@{i}Setting an element@{ui}
chessboard[mda_Index([4,7]:INT,chessboard)]:=PIECECONST

And one for the numbers array:

@{i}Accessing the numbers array@{ui}
number:=numbers[mda_Index([0,1,2]:INT,numbersinfo)]

As you can see we have provided the MDA we wish to access to the mda_Index() function every time. If we wish to access the same array several times in a row, providing it's name can get a bit tedious. Because of this there is a routine to set what MDA we wish to access. It is called @{"mda_Set()" link Overview} and sets a default MDA to be accessed if no parameter is given. If we with to access the chessboard MDA without refering to it we would set it using this:

mda_Set(chessboard)

And access it like this:

chessboard[mda_Index([4,2]:INT]:=NIL


@{b}4. Disposing of array memory@{ub}
Any memory allocated by the MDA module is automaticly disposed of at the end of your E program as it uses the built in E memory allocation routines. And you don't usually have to worry about it. However if you want to free it yourself for any reason at all you can do so by the use of the @{"mda_Free()" link Overview} command which takes a MDA as returned by mda_Dim() as it's argument.


That concludes the basic instructions for setting up multi-dimensional arrays. Extra special tricks you can do by using the module will be found by reading on.
@endnode

@node Tricks
@title "Special tricks possible using MDArray"
@{b}Special tricks@{ub}

Because MDArray incorpiates itself into a normal one-dimensional array you can have the best of both worlds and utililize some special trickery. Lets say for example that you have a MDA with three indexes, and we only wish in this case is to clear the whole thing. I'll use dimensions of [5,4,2] for this one. Normally what you would have to do is set up three variables in FOR loops for each of the three indexes, so the code could end up something like this:

FOR x:=0 To 4     -> 1st index range
  FOR y:=0 TO 3   -> 2nd index range
    FOR z:=0 TO 1 -> 3rd index range
      array[mda_Index([x,y,z]:INT,array)]:=NIL ->Clear element
    ENDFOR
  ENDFOR
ENDFOR

Now this of course would work fine and at least you know what it's doing but it can be optimised to the following which not only is less to type in, but will run faster as well.

FOR i:=0 TO mda_MaxIndex(array)
    array[i]:=NIL
ENDFOR

Now isn't that a neat trick we can play on an usually monster looking MDA? You will of course notice the introduction of a new command, @{"mda_MaxIndex()" link Overview} which will return the maximum possible index of a MDA when accessing it in normal one-dimensional fashion.

Of extra note is that you can also have MDA's full of objects just like normal arrays, so here is an example of using objects if in an some sort of 3d maze program.

@{i}An OBJECT for each block in the maze.@{ui}
OBJECT block
  type:INT,
  gfx:LONG,
ENDOBJECT

@{i}Some CONSTants@{ui}
CONST WALKABLE=1,WALL=2

@{i}Some variables.@{ui}
DEF maze:PTR TO block,gfx,i,x,y,z

@{i}The "main" bit@{ui}
  maze:=mda_Dim(SIZEOF block,MDA_3D,[32,32,32]:INT)

-> Clear our maze so we can walk right over it!
FOR i:=0 TO mda_MaxIndex(maze)
    maze[i].type:=WALKABLE
    maze[i].gfx:=gfx
ENDFOR

-> Randomize our maze (not very logical if it was a real example)
FOR x:=0 TO 31
  FOR y:=0 TO 31
    FOR z:=0 TO 31
      IF Rnd(1)
        i:=mda_Index([x,y,z]:INT,maze) -> Shortcut. Also speeds up access.
        maze[i].type:=WALL
        maze[i].gfx:=gfx
      ENDIF
    ENDFOR
  ENDFOR
ENDFOR


You will also notice a shortcut in the code which takes a calculated 3d index and stores it at a one-dimensional one for future access. This is also good when you make lots of accesses to one array as it saves memory and time during runtime. It also can be used if you are accessing different arrays but have the same dimensions and the same indexes.

Lastly, don't forget you can use the mda_Set() function to make things easier as well.

That should give you some idea of what tricks you can do.
@endnode

@node Demo
@title "Demonstration program for MDArray"
@{b}Demo program@{ub}

To help you out a bit there is a test program which allocates MDA's and gives you information about them. It's called "TestMDArray" and includes the source so you can see the module in a real program. You can of course do whatever you want with the source code. It's there to help you.
@endnode

@node Future
@title "Future extras posible for MDArray"
@{b}Future extras@{ub}

In the future I hope to include some program tutorials as part of the package, but time retraints me to just include the neccessary stuff to get you started. For now you'll just have to try it out for yourself, and take a look at the demo program.
@endnode

@node Overview
@title "Overview of functions for MDArray"
@{b}Overview of functions@{ub}

Here is the full list of functions available in the MDArray module including any useful constants of use.

@{b}mda_InitIDs()@{ub}

Syntax:
mda_InitIDs(fatal="MDA",mem="MEM)

Description:
This function initialzies the exception ID's in case an error occurs and must be called before any of the other functions are used. Setting any of these ID's to NIL will cause @{i}no@{ui} exception of it's type to be raised and NIL will be returned from the function that the error occured in.

Arguments:
@{i}fatal@{ui}
The ID in case a fatal error happens during a call within a function, most likely in this case is that no array is present when one is reqired.

@{i}mem@{ui}
The ID in case a memory allocation fails, such as when allocating memory for a MDA.

Commments:
Calling it with no arguments is usually sufficient enough in most cases.

Example:
mda_InitIDs()
This will set up the exceptions as default.

@{b}mda_Dim()@{ub}

Syntax:
mdarray:=mda_Dim(size,subscripts,dimensions:PTR TO INT,flags=NIL)

Description:
This function is similar to the DIM command in BASIC and in fact achieves the same result. What it does is dimension an array for you by allocating memory for the array settings and the array itself if you wish.

Arguments:
@{i}size@{ui}
The size of each element the array. For CHAR, INT or LONG types you can use the special constants MDA_CHAR, MDA_INT and MDA_LONG. For anything else, such as an object you can specifiy the size yourself.

@{i}subscripts@{ui}
The number of subscripts for the array. In other words how many dimensions you want the array to be. For arrays of two to five dimensions you can use the special constants MDA_2D, MDA_3D, MDA_4D 
and MDA_5D. Anything of more dimensions will require you to input the number of subscripts yourself.

@{i}dimensions@{ui}
An INT typed list of the dimensions for the array. The number of dimensions is the muber of subscripts.

@{i}flags@{ui}
Presently their is only one flag and that is MDAF_DEF. Setting this flag will not allocate any memory for the array itself indicating that it is already DEFined and resides at another memory location.

Result:
@{i}mdarray@{ui}
A pointer to the MDA ready for usage in the other functions.

Comments:
Attempting to dimension a MDA with only one subscript will result in the function returning NIL no matter what!

Example:
field:=mda_Dim(MDA_INT,MDA_2D,[8,8]:INT)
This will allocate memory for an array suitable for a chessboard with the size of each element being of type INT, two subscripts and dimensions of 8x8. Because no flags are set memory will automaticly be allocated for the array.

@{b}mda_Set()@{ub}

Syntax:
mda_Set(mdarray)

Description:
This function sets the default MDA for access when none is given to the other functions and helps on readability. If you are going to access a MDA several times it is recommended to use this function.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to set as returned by mda_Dim().

@{b}mda_Index()@{ub}

Syntax:
index:=mda_Index(indexes:PTR TO INT,mdarray=NIL)

Description:
This is the most major function of all and the one you will probably spend most of your time using. This will calculate the one-dimensional index from a set of multiple-indexes for access to a MDA to use as if it was a normal array.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

@{i}indexes@{ui}
An INT typed list containing each of the indexes required to access a single element.

Result:
@{i}index@{ui}
The one-dimensional index with which you can access the MDA as if it were a normal one.

Comments:
This function has been written in optimized assembly for optimum performance which should speed up your MDA access no end.

Example:
3d_array[mda_Index(3d_array,[2,3,1]:INT)]:=32
This will set element [2,3,1] of the MDA 3d_array to the value 32.

@{b}mda_Offset@{ub}

Syntax:
offset:=mda_Offset(array,indexes:PTR TO INT)

Description:
This is very similar to mda_Index() but calculates instead of the one-dimensional index the actual offset into memory that the indexes point to.

Arguments:
@{i}array@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

@{i}indexes@{ui}
An INT typed list containing each of the indexes required to find the offset.

Result:
@{i}offset@{ui}
The offset into the mdarray that the indexes point to.

Example:
WriteF('Element [2,3,1] of 3d_array is at offset \d\n',
       mda_Offset(3d_array,[2,3,1]:INT))
This will output the offset of indexes [2,3,1] in the MDA 3d_array to the current standard output.

@{b}mda_MaxIndex()@{ub}

Syntax:
maxindex:=mda_MaxIndex(mdarray)

Decription:
This function will return the maximum posible index when accessing the MDA as a normal array. Useful in FOR loops.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

Result:
@{i}maxindex@{ui}
The MDA's maximum one-dimensional index.

@{b}mda_Indexes()@{ub}

Syntax:
indexes:=mda_Indexes(mdarray)

Description:
This function will return the number of total one-dimensional indexes that makes up the MDA.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

@{b}mda_Length()@{ub}

Syntax:
length:=mda_Length(mdarray)

Description:
This function returns the total number of bytes that the MDA occupies with array data which comprimises it's length.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

@{b}mda_Size()@{ub}

Syntax:
size:=mda_Size(mdarray)

Description:
This function will return the size of each element in the MDA in bytes.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

@{b}mda_Free()@{ub}

Syntax:
mda_Free(mdarray)

Description:
This function will free up all memory that belongs to the MDA mdarray.

Arguments:
@{i}mdarray@{ui}
The MDA you wish to access as returned by mda_Dim(), or none if already set with mda_Set().

Comments:
In most cases you will not need to use this function because memory occupied by any MDA's is freed up at the end of the program anyway. It is, however, available in case you need to manualy free an array from memory.
@endnode

@node Basic
@title "Basic usage of MDArray"
@{b}Basic usage@{ub}

Here is a short section which explains a basic usage of MDArray and what is least reqired to get up and running. It's a bit easier to read than the instructions and will probably help you on the basics in case to run into errors.

First, make sure you have included the module in your E source.

Then, make a call to mda_InitIDs() to set you up. Note that if you enable exceptions by using the default arguments or setting one to a non-zero value it would be wise to include an exception handler in case you need to process one. (Very handy in debugging your program.)

Now you can set up your MDA's with the mda_Dim() function. Probably one after the other would be a good choice, though if you do it in a PROC make sure you're exceptions are set up.

And voila! Now you can use your new MDA's using the mda_Index() function and access them however you want to your hearts content. Especially any other MDA functions you may want to use.
@endnode

@node AboutMe
@title "About Me"
Well, not much. I been programming for about five years and this is my first step into a high-level language. Here are my contact details:

Damien Stewart
41 Kempston St.
Greensborough 3088
[Victoria, Australia]

Ph. (03) 9435 7836

Oh yes, and as you might have noticed you can only contact me by snail-mail or audio-phone contact. Sorry, but I'm not on the net, yet!
@endnode
