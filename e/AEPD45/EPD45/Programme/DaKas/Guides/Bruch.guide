@database "Bruch.GUIDE"
@$VER: Bruch.guide v1.0 © Copyrights by Daniel Kasmeroglu

@node main "E-Modul: Bruch.M"

  Autor   : Daniel Kasmeroglu
  Version : 1.0

  OBJECT bruch
    @{" bru_Pi()         " LINK bru_pi}
    @{" bru_E()          " LINK bru_e}
    @{" bru_Negativ()    " LINK bru_negativ}
    @{" bru_Groesser()   " LINK bru_groesser}
    @{" bru_Gleich()     " LINK bru_gleich}
    @{" bru_Kleiner()    " LINK bru_kleiner}
    @{" bru_Negiere()    " LINK bru_negiere}
    @{" bru_Sqr()        " LINK bru_sqr}
    @{" bru_Potenz()     " LINK bru_potenz}
    @{" bru_Kuerze()     " LINK bru_kuerze}
    @{" bru_Add()        " LINK bru_add}
    @{" bru_Sub()        " LINK bru_sub}
    @{" bru_Mul()        " LINK bru_mul}
    @{" bru_KehrWert()   " LINK bru_kehrwert}
    @{" bru_Div()        " LINK bru_div}
    @{" bru_Bruch()      " LINK bru_bruch}
    @{" bru_Zahl2Bruch() " LINK bru_zahl2bruch}
    @{" bru_Real2Bruch() " LINK bru_real2bruch}
  ENDOBJECT

@endnode

@node bru_pi " bru_Pi() "

  Aufruf....: ptr.bru_Pi(fak)

  Parameter.: <fak> ist eine ganze Zahl, die den Wert 1 trägt, wenn sie
              nicht explizit angegeben wurde. <ptr> ist ein PTR TO bruch.

  Funktion..: Das Objekt <fak> erhält den Wert von PI * <fak> als Bruch.
              Ähnlich wie bei @{" bru_E() " LINK bru_e} .

  (PI = Kreiszahl = 3.14???)

@endnode

@node bru_e " bru_E() "

  Aufruf....: ptr.bru_E(fak)

  Parameter.: <fak> ist eine ganze Zahl, die den Wert 1 trägt, wenn sie
              nicht explizit angegeben wurde. <ptr> ist ein PTR TO bruch.

  Funktion..: Das Objekt <fak> erhält den Wert von E * <fak> als Bruch.
              Ähnlich wie bei @{" bru_E() " LINK bru_e} .

  (E = Eulersche Zahl = 2.718281828)

@endnode

@node bru_negativ " bru_Negativ() "

  Aufruf....: bool := ptr.bru_Negativ()

  Parameter.: <bool> ist eine LONG-Variable, die den Funktionswert aufnimmt.
              <ptr> ist wieder ein PTR TO bruch.

  Funktion..: Wenn der Bruch kleiner als null ist, erhält <bool> den Wert
              TRUE, andernfalls FALSE.

@endnode

@node bru_groesser " bru_Groesser() "

  Aufruf....: bool := ptr.bru_Groesser(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typen PTR TO bruch.

  Funktion..: Wenn der Bruch <ptr> größer als <ptr2> ist, erhält <bool>
              den Wert TRUE, andernfalls FALSE. Im umgekehrten Fall
              muß man @{" bru_Kleiner() " LINK bru_kleiner} benutzen.

@endnode

@node bru_gleich " bru_Gleich() "

  Aufruf....: bool := ptr.bru_Gleich(ptr2)

  Parameter.: siehe @{" bru_Groesser() " LINK bru_groesser}

  Funktion..: <bool> erhält nur dann den Wert TRUE, wenn beide Brüche
              gleichgroß sind.

@endnode

@node bru_kleiner " bru_Kleiner() "
 
  Aufruf....: bool := ptr.bru_Kleiner(ptr2)

  Parameter.: siehe @{" bru_Groesser(ptr2) " LINK bru_groesser}

  Funktion..: <bool> erhält den Wert TRUE, wenn <ptr> kleiner als
              <ptr2> ist.

@endnode

@node bru_negiere " bru_Negiere() "

  Aufruf....: ptr.bru_Negiere()

  Parameter.: <ptr> ist eine Variable vom Typ PTR TO bruch.

  Funktion..: Der Bruch <ptr> erhält bzw. verliert sein Vorzeichen.

@endnode

@node bru_sqr " bru_Sqr() "

  Aufruf....: ptr.bru_Sqr()

  Parameter.: <ptr> : PTR TO bruch

  Funktion..: Der Bruch <ptr> wird mit sich selbst multipliziert.

@endnode

@node bru_potenz " bru_Potenz() "

  Aufruf....: ptr.bru_Potenz(fak)

  Parameter.: <fak> ist eine natürliche Zahl, während <ptr> ein PTR TO bruch
              ist.

  Funktion..: Der Bruch <ptr> wird <fak> mal mit sich multipliziert.

@endnode

@node bru_kuerze " bru_Kuerze() "

  Aufruf....: ptr.bru_Kuerze()

  Parameter.: <ptr> : PTR TO bruch

  Funktion..: Diese Methode versucht im Bruch zu kürzen um Nenner und
              Zähler zu verkleinern, was Rechenoperationen etwas
              beschleunigt (im Erfolgsfalle).

@endnode

@node bru_add " bru_Add() "

  Aufruf....: ptr.bru_Add(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typ PTR TO bruch

  Funktion..: <ptr> := <ptr> + <ptr2>

@endnode

@node bru_sub " bru_Sub() "

  Aufruf....: ptr.bru_Sub(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typ PTR TO bruch

  Funktion..: <ptr> := <ptr> - <ptr2>

@endnode

@node bru_mul " bru_Mul() "

  Aufruf....: ptr.bru_Mul(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typ PTR TO bruch

  Funktion..: <ptr> := <ptr> * <ptr2>

@endnode

@node bru_kehrwert " bru_KehrWert() "

  Aufruf....: ptr.bru_KehrWert()

  Parameter.: <ptr> ist vom Typ PTR TO bruch

  Funktion..: <ptr> := 1 / <ptr> 

@endnode

@node bru_div " bru_Div() "

  Aufruf....: ptr.bru_Div(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typ PTR TO bruch

  Funktion..: <ptr> := <ptr> / <ptr2>

@endnode

@node bru_bruch " bru_Bruch() "

  Aufruf....: ptr.bru_Bruch(ptr2)

  Parameter.: <ptr> und <ptr2> sind vom Typ PTR TO bruch

  Funktion..: <ptr> := <ptr2>

@endnode

@node bru_zahl2bruch " bru_Zahl2Bruch() "

  Aufruf....: ptr.bru_Zahl2Bruch(zaehler,nenner)

  Parameter.: <zaehler> und <nenner> sind LONGs. <ptr> ist vom Typ PTR TO bruch.

  Funktion..: Der Bruch <ptr> erhält den Wert <zaehler>/<nenner>.

@endnode

@node bru_real2bruch " bru_Real2Bruch() "

  Aufruf....: ptr.bru_Real2Bruch(ieee,fak)

  Parameter.: <ieee> ist ein reelle Zahl, während <fak> eine große Ganze
              Zahl ist. <ptr> ist vom Typ PTR TO bruch.

  Funktion..: Die reelle Zahl <ieee> wird mit <fak> multipliziert. Das
              Resultat ohne Nachkommastellen entspricht dem Zähler des
              Bruches <ptr>, während der Nenner den Wert <fak> erhält.

@endnode
