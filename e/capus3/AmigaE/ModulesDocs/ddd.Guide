@database "ddd.guide"
@node main
@title "ddd.library"

        Ce fichier contient la déscription des fonctions permettant
    la gestion d'un base 3D.Je ne dis pas que ces routines sont sans bugs ou
    ou quelles sont optimisées.Elles ont le mérite d'exister et si vous ne
    les trouvez pas a vôtre gout,rien ne vous empêche de les completées et/ou
    les améliorées.

    Je decline toute responsabilité quand a l'utilisation des ces sources.
    Toutes utilisation est faites a vos risques et perils.


    * TOUTE UTILISATION COMMERCIALE DE CES SOURCES ET STRICTEMENT INTERDITE SANS
    MON AUTORISATION.

    * TOUTE UTILISATION DOMAINE PUBLIC EST AUTORISE AUX SEULES CONDITION DE:

    - QUE L'ORIGINE SOIT SPECIFIER.
    - QUE LE PROGRAMME RESULTANT SOIT AUSSI LIBRE QUE CES SOURCES.
    - QUE LES SOURCES E ORIGINALES SOIT FOURNIS,ET PAS SEULEMENT LES EXECUTABLES BINAIRES.
      SI VOTRE PRRGRAMME UTILISE LA DDD.LIBRARY ,MEME SI IL EST ECRIT EN C/ASM/TRUC_BIDULE,
      LES SOURCES DE LA DDD.LIBRARY DOIVENT ETRE FOURNIS (COMPACTE OU NON).

    * TOUTE INCLUSION SUR CDROM EST STRICTEMENT INTERDITE SANS MON AUTORISATION.
      SEULES LES DISTRIBUTIONS FAITES PAR FRED FISH ET AMINET CDROM SONT AUTORISE
      A DISTRIBUER CES PROGRAMMES/SOURCES.

    * TOUTE UTILISATION MILITAIRE EST STRICTEMENT INTERDITE.

    Que tous ceci ne vous empeche pas de travailler sur les sources elles
    mêmes.Je n'interdit pas l'amélioration ou la réctification d'une bogue.
    Si vous effectuez un gros travail sur ces sources et que vous voulez les
    mettre en DP,rajoutez vôtre nom quelque part plus un bout de documentation
    et le tour est joué.

            Merci a tous les programmeurs qui fournissent leurs sources !!



    @{"Structures" link STRUCTURES}
    @{"Fonctions " link FONCTIONS}
    
    La ddd.library est © Capus André (NasGûl).

    Contact:
    
    Capus André
    74 Rue Jules Guesde
    92240 Malakoff
    FRANCE

        Vous pouvez laisser des messages a l'adresse internet suivante:

        lafargue@worldnet.net
        ou
        support@worldnet.sct.fr

        Attention cette adresse n'est pas la mienne,veuillez donc bien
         presisez le destinataire (moi) et l'objet du courrier merci.
        Pour les non-francophones veuillez utiliser l'anglais/espagnol/italien.



@endnode

->> DOC Init3DBase()
@node INIT3DBASE
@title "Init3DBase()"



        base:=Init3DBase()

        PARA   : Aucun
        RETOUR : pointeur sur un structure base3d,ou

                 ERR3D_MEM      - erreur de mémoire.
                 ERR3D_MATHLIB  - une des bibliothèques ne peut être ouverte.

        Cette fonction initialise la base 3D.
        les 4 libraries mathématiques,

        mathffp.library
        mathtrans.library
        mathieeesingtrans.library
        mathieeedoubtrans.library

        sont ouvertes par cette fonction et elles sont fermées par
        la fonctions @{"Rem3DBase()" link "REM3DBASE"}.

        ! ATTENTION si vous voulez utilisées des flottants dans vôtre
        programme (addition,...) vous devez OBLIGATOIREMENT ouvrir ces
        libraries.
@endnode
-><
->> DOC checkIf3DFile()
@node CHECKIF3DFILE
@title CheckIf3DFile()


        a,b:=CheckIf3DFile(fichier)

        PARA:
                fichier AmigaDos (STRING).
        RETOUR:
            <a> contient l'erreur (ERR3D_NONE si tous c'est bien
            passé,et <b> le type de l'objet (TYPE_<nom>).
            
            <a> peut prendre les valeurs suivantes:
                ERR3D_NOFILE       Fichier inexistant.
                ERR3D_UNKNOWNFILE  Format inconnu.

        Verifie si le fichier est bien d'un format supporté par la
        librarie.
@endnode
-><
->> DOC readFile3D()
@node READFILE3D
@title "ReadFile3D()"

        ret,t:=ReadFile3D(base,file)

        PARA   :base:PTR TO base3d,file:PTR TO CHAR (fichier amigados)
        RETOUR :
          valeur possible de <ret>;
                            ERR3D_NONE         si ok,sinon
                            ERR3D_MEM          mémoire inssuffisante.
                            ERR3D_UNKNOWNFILE  fichier au format inconnu.

    Cette fonction permet de charger un objet 3d dans la base 3D.Si tout
    ce passe bien ret=ERR3D_NONE et t contient le type de fichier chargé.Les types
    possible sont:

     TYPE_IMAGINE TYPE_OLDCYBER TYPE_NEWCYBER TYPE_SCULPT TYPE_OLDVERTEX
     TYPE_NEWVERTEX TYPE_3DPRO TYPE_LIGHTWAVE TYPE_VERTEX2

    Attention le type TYPE_LIGHTWAVE n'arrivera jamais ,car je n'ai pas
    trouvé comment les points et faces sont rangés.

    Ex:

        ret,t:=ReadFile3D(mybase,'ram:objtest.obj')

@endnode
-><

->> DOC saveGeoFile()
@node SAVEGEOFILE
@title "SaveGeoFile()"


        ret:=SaveGeoFile(base,dir)

        PARA :
            base:PTR TO base3d  -> pointeur sur une structure base3d.
            dir:PTR TO CHAR -> nom de dossier amigados.

           RETOUR: <ret>=ERR3D_NONE si ok ,sinon

                    ERR3D_NODIR    si le dossier est inexistant.
                    ERR3D_OPEN     si le fichier resultant ne peut être
                                   ouvert.

    Sauve la base 3D en un format exploitable par tous logiciels conprenant
    la description d'objets 3D au format GEO (3DG1).
    pour chaque objet 1 fichier est crée.

    Ex:
        ret:=SaveGeoFile(mybase,'Ram:')
        ....

    Voir: @{"Informations Sauvegarde" Link SAVEINFO}

@endnode
-><
->> DOC saveDxfFile()
@node SAVEDXFFILE
@title "SaveDxfFile()"


        ret:=SaveDxfFile(base,dir)

        PARA :
            base:PTR TO base3d  -> pointeur sur une structure base3d.
            dir:PTR TO CHAR -> nom de dossier amigados.

           RETOUR: <ret>=ERR3D_NONE si ok ,sinon

                    ERR3D_NODIR    si le dossier est inexistant.
                    ERR3D_OPEN     si le fichier resultant ne peut être
                                   ouvert.


    Sauve la base 3D en un format exploitable par tous logiciels conprenant
    la description d'objets 3D au format DXF (utilisation de 3DFACE uniquement).
    pour chaque objet 1 fichier est crée.

    Ex:
        ret:=SaveDxfFile(mybase,'Ram:')
        ....

    Voir: @{"Informations Sauvegarde" Link SAVEINFO}
@endnode
-><
->> DOC saveRayFile()
@node SAVERAYFILE
@title "SaveRayFile()"


        ret:=SaveRayFile(base,dir)

        PARA :
            base:PTR TO base3d  -> pointeur sur une structure base3d.
            dir:PTR TO CHAR -> nom de dossier amigados.

        RETOUR: <ret>=ERR3D_NONE si ok ,sinon

                    ERR3D_NODIR    si le dossier est inexistant.
                    ERR3D_OPEN     si le fichier resultant ne peut être
                                   ouvert.


    Sauve la base 3D en un format exploitable par rayshade,
    pour chaque objet 1 fichier est crée.

    Ex:
        ret:=SaveRayFile(mybase,'Ram:')
        ....

    Voir: @{"Informations Sauvegarde" Link SAVEINFO}
@endnode
-><
->> DOC SavePovFile()
@node SAVEPOVFILE
@title "SavePovFile()"


        ret:=SavePovFile(base,dir)

        PARA :
            base:PTR TO base3d  -> pointeur sur une structure base3d.
            dir:PTR TO CHAR -> nom de dossier amigados.

        RETOUR: <ret>=ERR3D_NONE si ok ,sinon

                    ERR3D_NODIR    si le dossier est inexistant.
                    ERR3D_OPEN     si le fichier resultant ne peut être
                                   ouvert.


    Sauve la base 3D en un format exploitable par Pov1.0/Pov2.0,
    pour chaque objet 1 fichier est crée.

    Ex:
        ret:=SavePovFile(mybase,'Ram:')
        ....

    Voir: @{"Informations Sauvegarde" Link SAVEINFO}
@endnode
-><
->> DOC saveBinFile()
@node SAVEBINFILE
@title "SaveBinFile()"

        ret:=SaveBinFile(base,dir,factor)

        PARA :
            base:PTR TO base3d  -> pointeur sur une structure base3d.
            dir:PTR TO CHAR -> nom de dossier amigados.
            factor      -> facteur multiplicatif lors de la sauvegarde
                       ATTENTION factor DOIT ETRE FLOTTANT.

        RETOUR: <ret>=ERR3D_NONE si ok ,sinon

                    ERR3D_NODIR    si le dossier est inexistant.
                    ERR3D_OPEN     si le fichier resultant ne peut être
                                   ouvert.

    Sauve la base 3D en un format exploitable par la vector.library,
    pour chaque objet 2 fichiers sont crées,un pour les points l'autre
    pour les faces.


    Ex:
        /* reduction de moitié */
        ret:=SaveBinFile(mybase,'Ram:',0.5)
        ....
        /* tel quel */
        ret:=SaveBinFile(mybase,'HD1:Objects/',1.0)

    Voir: @{"Informations Sauvegarde" Link SAVEINFO}
@endnode
-><

->> DOC rem3DBase()
@node REM3DBASE
@title "Rem3DBase()"

        VOID Rem3DBase(base)

        PARA   : base:PTR TO base3d
        RETOUR : Aucun

        Cette fonction libère la mémoire prise par la base 3D.
    elle ferme aussi les libraries précedement ouverte.

@endnode
-><

->> DOC updateCenterBase()
@node UPDATECENTERBASE
@title "UpdateCenterBase()"

        VOID UpdateCenterBase(base)

        PARA : base:PTR TO base3d


        Remet a jour le centre géométrique de la base 3D,
        donc les pointeurs:

        base3d.basecx
        base3d.basecy
        base3d.basecz

        Cette fonction ne marche que si les mini/maxi de la
        base sont juste.

        Pour remettre a jour les mini/maxi de la base3d,il faut
        appeller pour chaque object la fonction @{"BuildMinMax()" link BUILDMINMAX}.

@endnode
-><
->> DOC buildMinMax()
@node BUILDMINMAX
@title "BuildMinMax()"

        VOID BuildMinMax(base,obj,update)

        PARA  :
            base:PTR TO base3d   -> pointeur sur une structure base3d.
            obj:PTR TO object3d  -> pointeur sur une structure object3d.
            update:LONG      -> TRUE/FALSE remet a jour le centre de la base 3D.

    Cette fonction calcule les mini et maxi en x,y,z et met a jour les pointeurs:

    obj.minx  minimum en x de l'objet
    obj.maxx  maximum en x
    obj.miny  minimum en y
    obj.maxy  maximum en y
    obj.minz  minimum en z
    obj.maxz  maximum en z
    obj.objcx centre en x
    obj.objcy centre en y
    obj.objcz centre en z

        Si update=TRUE les valeurs base3d.basecx,base3d.basecy,base3d.basecz sont remis a
    jour.
@endnode
-><

->> DOC formatBase3DWithScreen()
@node FORMATBASEWITHSCREEN
@title "FormatBase3DWithScreen(base,s)"


        VOID FormatBase3DWithScreen(base:PTR TO base3d,s:PTR TO screen)

        PARA:
        base    -> pointeur sur une structure base3d
        s   -> pointeur sur une structure screen

    Cacule les valeurs base3d.draw_x,base3d.draw_y,base3d.draw_w,base3d.draw_h
    base3d.centrex,base3d.centrey,base3d.format.

@endnode
-><
->> DOC formatBase3DWithWindow()
@node FORMATBASEWITHWINDOW
@title "FormatBase3DWithWindow(base,w)"


        VOID FormatBase3DWithWindow(base:PTR TO base3d,win:PTR TO window)

        PARA:
        base    -> pointeur sur une structure base3d
        win -> pointeur sur une structure window.

    Cacule les valeurs base3d.draw_x,base3d.draw_y,base3d.draw_w,base3d.draw_h
    base3d.centrex,base3d.centrey,base3d.format.
@endnode
-><

->> DOC drawBase3D()
@node DRAWBASE
@title "DrawBase3D(base,win)"

        ret:=DrawBase3D(base:PTR TO base3d,win:PTR TO window)

        PARA:
        base  -> pointeur sur une structure base3d.
        win   -> pointeur sur une structure window.
        RETOUR:
            TRUE si ok,FALSE si l'objet sort du rectangle,STOP_DRAWING si
            l'utilisateur a stopper le dessin.

    Cette fonction dessine la base de données,ATTENTION vous devez appeler
    @{"formatBaseWithWindow()" LINK FORMATBASEWITHWINDOW} avant drawBase3D().

    Lors de la création d'une structure base3d,un champ de cette structure est
    defini comme suis:

    OBJECT base3d
        ...
        stopdrawing:LONG
       ...
    ENDOBJECT

    base3d.stopdrawing sert a définir la touche d'arrêt du dessin par défaut
    base3d.stopdrawing:=$21 (touche <s> du clavier).Pour que cette particularité
    fonctionne vous devez ouvir vôtre fenêtre avec au moins IDCMP_RAWKEY.

    la routine de stop est la suivante: (elle se trouve dans @{"drawObject3D()" LINK DRAWOBJECT3D})

    DEF viewport:PTR TO mp,stop_mes:PTR TO intuimessage,class,code
    viewport:=win.userport
    ......
    IF stop_mes:=GetMsg(viewport)
    class:=stop_mes.class
    code:=stop_mes.code
    IF (class=IDCMP_RAWKEY) AND (code=base.stopcode)
        DisplayBeep(0)
        WHILE stop_mes:=GetMsg(viewport) DO ReplyMsg(stop_mes)
        RETURN STOP_DRAWING
    ENDIF
    WHILE stop_mes:=GetMsg(viewport) DO ReplyMsg(stop_mes)
    ENDIF
    .....
@endnode
-><
->> DOC drawObject3D()
@node DRAWOBJECT3D
@title "DrawObject3D(base,do,win)"


        ret:=DrawObject3D(base:PTR TO base3d,do:PTR TO object3d,win:PTR TO window)

        PARA:
        base        ->  pointeur sur une structure base3d
        do      ->  pointeur sur une structure object3
        win     -> pointeur sur une structure window

    Dessine un objet de la base 3D ,comme pour @{"drawBase3D()" LINK DRAWBASE3D} la fonction
    @{"FormatBaseWithWindow()" LINK FORMATBASEWITHWINDOW} doit être appeler en premier.

@endnode
-><
->> DOC DRAWOBJECTFACE
@node DRAWOBJECTFACE

        Non Documenté intentionellement.

@endnode
-><
->> DOC clearDrawingArea()
@node CLEARDRAWINGAREA
@title "ClearDrawingArea(win,color)"


        VOID ClearDrawingArea(win:PTR TO window,color)

        PARA:
        win   -> pointeur sur une structure window.
        color     -> couleur.

    Efface avec la couleur <color> la fenêtre de dessin.
@endnode
-><
->> DOC conv3Dbj2Vect()
@node CONV3DOBJ2VECT
@title "Conv3DObj2Vect(mybase,numobj,v_face,center=FALSE)"


        adrpts,adrfcs:=Conv3DObj2Vect(mybase:PTR TO LONG,numobj:LONG,v_face:LONG,numcolors:LONG,center=FALSE)

        PARA:
        mybase    -> pointeur sur une structure base3d
        numobj    -> numéro d'objet
        v_face    -> flags pour la génération des faces (FV_INDIRECT/FV_DIRECT/FV_DOUBLE).
        numcolors -> défini le nombres de couleurs pour la représentation.
        center    -> Si center=TRUE ,l'objet resultant sera centré en 0,0,0.

        RETOUR:

            adrpts   -> addresse de la liste des points si ok,sinon 0.
            adrfcs   -> addresse de la liste des faces si ok ,sinon 0.


        Cette fonction converti les points et les faces d'un objet 3D,
        dans un format pouvant être exploité par le module FilledVector.m.

        La valeur v_face défini dans quel sens sont générées les faces,
        Frank a choisi comme base un trièdre indirect (sens inverse au sens
        trigonométrique),c'est a dire que les sommets des faces des objets tourne
        dans le sens des aiguilles d'une montre vus de l'exterieur de l'objet.
        Le sens des faces est TRES IMPORTANT,des logiciels comme Imagine ou Sculpt
        générent leurs faces dans n'importe quel sens,la convertion sans alourdir
        l'objet est impossible,le seul moyen est de faire la convertion avec v_face:=FV_DOUBLE,
        l'objet vera ces faces doublées (donc plus lourd).
        l'autre solution est d'utilisé un programme 3D générant toutes ces faces dans le même
        sens,3DPro (Amiga) et CyberStudio (Atari) génèrent leurs faces dans le sens trigonométrique.

        ATTENTION !!,en aucun cas cette routine initialise un object vobject,vous devez le faire
        vous même.

        ===================================================================================
        De plus cette routine alloue de la mèmoire pour stocker les points et les faces
        cette mémoire est désalloué avec la fonction freeVectorObjet() (je fait entièrement
        confiance a la routine de Frank).
        (VOUS DEVEZ DONC CREER UN OBJET ET LE LIBERE AVEC freeVectorObject(),MEME SI VOUS
        NE VOULEZ PAS DESSINE L'OBJECT,IL N'Y A AUCUNE ROUTINE DANS LA LIBRARIE ddd.library
        PERMETTANT LA LIBERATION DE LA MEMOIRE ALOUE AVEC Conv3Dbj2Vect().
        ===================================================================================
        
        
        Les coordonnées des points sont stockées sur des INT,alors que les objets de la base ont
        leurs coordonnées en flottants (LONG),le facteur base3d.vectorfactor est utilisé lors de
        la convertion (au même titre que lors de la sauvegarde en BIN).Attention donc a veiller que
        vos points ne soit pas trop loin (coordonnées trop grande).

        <numcolors> sert a définir le nombres maximum de couleurs utilisés.Lors de la convertion
        la couleur des faces est caculée avec une source lumineuse en 4500,-4500,4500.Cette technique
        permet de donner du volume a vôtre objet de manière simple et réaliste.


    Exemple:

        DEF mybase:PTR TO base3d

        PROC main()
        DEF s,apts,afcs
        DEF newvobj:PTR TO vobject
        ... -> open lib !!
        IF mybase:=Init3Base()
            MakeObject(mybase,PRIM_TORUS,'Torus',10,10,50.0,FV_DIRECT)
            apts,afcs:=Conv3DObj2Vect(mybase,0,FV_INDIRECT)
            IF ((apts<>NIL) AND (afcs<>NIL))
            ... -> open screen an init polygone context (cf FilledVector.Guide).
            IF newvobj:=newVectorObject(0,121,200,apts,afcs)
                ... -> your stuff
                IF newvobj THEN freeVectorObject(newvobj)
            ENDIF
            ENDIF
            Rem3DBase(mybase)
        ENDIF
        ENDPROC
@endnode
-><
->> DOC conv3DObj2VectLib()
@node CONV3DOBJ2VECTLIB
@title "Conv3DObj2VectLib(mybase,numobj,v_face,center=FALSE)"


        arpts,arfcs:=Conv3DObj2VectLib(mybase,numobj,v_face,center=FALSE)

        PARA:
            mybase    -> pointeur sur une structure base3d
            numobj    -> numèro d'objet
            v_face    -> flags pour la génération des faces (FV_INDIRECT/FV_DIRECT/FV_DOUBLE).
            center    -> Si center=TRUE ,l'objet resultant sera centré en 0,0,0.

        RETOUR:
            adrpts    -> addresse des points si ok,sinon 0.
            adrfcs    -> addresse des faces si ok,sinon 0.

        Cette fonction converti les points et les faces d'un objet 3D,
        dans un format pouvant être exploité par la vector.library.

        La valeur v_face défini dans quel sens sont générées les faces,
        A.Lippert a choisi comme base un trièdre direct (sens trigonométrique),
        c'est a dire que les sommets des faces des objets tourne dans le sens inverse
        des aiguilles d'une montre vus de l'exterieur de l'objet.
        Le sens des faces est TRES IMPORTANT,des logiciels comme Imagine ou Sculpt
        générent leurs faces dans n'importe quel sens,la convertion sans alourdir
        l'objet est impossible,le seul moyen est de faire la convertion avec v_face:=FV_DOUBLE,
        l'objet vera ces faces doublées (donc plus lourd).
        l'autre solution est d'utilisé un programme 3D générant toutes ces faces dans le même
        sens,3DPro (Amiga) et CyberStudio (Atari) génèrent leurs faces dans le sens trigonométrique.

        ATTENTION !!,en aucun cas cette routine initialise un object object,vous devez le faire
        vous même.
        vous devez TOUT faire (ouvrir l'écran,allouer de la mémoire pour la structure object,ect..)

        Les coordonnées des points sont stockées sur des INT,alors que les objets de la base ont
        leurs coordonnées en flottants (LONG),le facteur base3d.vectorfactor est utilisé lors de
        la convertion (au même titre que lors de la sauvegarde en BIN).Attention donc a veiller que
        vos points ne soit pas trop loin (coordonnées trop grande).

        <numcolors> sert a définir le nombres maximum de couleurs utilisées.Lors de la convertion
        la couleur des faces est caculée avec une source lumineuse en 4500,-4500,4500.Cette technique
        permet de donner du volume a vôtre objet de manière simple et réaliste.


        Exemple:

        DEF mybase:PTR TO base3d
        PROC main()
        DEF vobj:PTR TO object
        .... -> open lib !!!
        IF mybase:=Init3DBase()
            MakeObject(mybase,PRIM_TORUS,'Torus',10,10,50.0,FV_DIRECT)
            apts,afcs:=Conv3DObj2VectLib(mybase,0,FV_DIRECT)
            IF ((apts<>NIL) AND (afcs<>NIL))
            IF vobj:=New(SIZEOF object)
                vobj.point_data:=apts
                vobj.area_data:=afcs
                .... etc...
                ... -> your stuff
            ENDIF
            ENDIF
            Rem3DBase(mybase)
        ENDIF
        ENDPROC
@endnode
-><
->> DOC renderVectorbject()
@node RENDERVECTOROBJECT
@title "RenderVectorObject(base,numobj,support,vsens,time,rotx,roty,rotz,center=FALSE)"


        VOID RenderVectorObject(base,numobj,support,vsens,time,rotx,roty,rotz)

        PARA:

            base        -> pointeur sur une structure base3d.
            numobj      -> numéro d'objet.
            support     -> defini le mode de vectorisation (vector.library ou filledvector.m)
                       peut prendre les valeurs VECTOR_LIB ou VECTOR_MOD
            vsens       -> sens de génération des faces.
                       (FV_INDIRECT,FV_DIRECT,FV_DOUBLE)
                       ce paramètre est directement passé au routine de
                       convertion.
            time        -> temps.
                       temps en ticks (paramètre ne servant que pour la vector.library).
            rotx,roty,rotz  -> rotation en x,y,z.
            center      -> Si center=TRUE ,l'objet resultant sera centré en 0,0,0.

    Cette routine initialise toutes les structures (objet,ecran) pour la visualisation
    a l'aide de la vector.library ou du module E FilledVector.m.

    Avant la visualisation cette routine converti l'objet dans le format voulu ,pour cela
    elle fait appel a @{"Conv3DObj2Vect()" LINK CONV3DOBJ2VECT} et @{"Conv3DObj2VectLib()" LINK CONV3DOBJ2VECTLIB}.
@endnode
-><
->> DOC GETCOLOR
@node GETCOLOR
        
        Non Documenté intentionellement.

@endnode
-><
->> DOC makeObject()
@node MAKEOBJECT
@title "MakeObject()"


        ret:=MakeObject(base3d,type,name,sepx,sepy,factor,fc)


        PARA  :
            base3d:PTR TO base3d -> Pointeur sur une structure base3d.
            type:LONG        -> type de l'objet.
            name:PTR TO CHAR     -> nom de l'objet.
            sepx:LONG        -> séparation en x.
            sepy:LONG        -> séparation en y.
            factor:LONG      -> facteur 3D multiplicatif (FLOTTANT).
            fc:LONG      -> flags pour la génération des faces.

        RETOUR :
            ERR3D_NONE             si ok,sinon
            ERR3D_WRONGPRIMTYPE    type de primitive inconnu.
            ERR3D_MEM              mémoire inssuffisante.


        Ajoute un primitive caculée a la base 3D.

        type:LONG
        ---------
        les types possibles sont les suivants:

        PRIM_TORUS PRIM_MOEBIUS PRIM_PLAN PRIM_TRBL PRIM_SPHERE
        PRIM_SPIRALE PRIM_VAGUES PRIM_CYLINDRE PRIM_CONED PRIM_DOME

        sepx:LONG,sepy:LONG
        -------------------

        Défini le séparation en nombre de faces de l'objet.Une pirmitive
        plan (PRIM_PLAN) avec sepx:=10 et spey:=10 créera un plan avec 10 faces
        dans chaque direction (x et y).

        factor:LONG
        -----------
        Défini lors du calcul des points le facteur multiplicatif.Certaines
        fonctions ont un domaine de definition bien particulier (de fois très petit),
        ce facteur sert donc a agrandir les objets lors de leurs création.
        CETTE VALEUR DOIT ETRE FLOTTANTE.


        fc:LONG
        -------
        Défini si seulement les faces superieures sont générées (fc:=0),
        seulement les faces inférieurs (fc:=1),ou les deux (fc:=2).
        Certains logiciels 3D ne peuvent rendre les faces d'un objet que
        si elles sont définies dans le sens trigonométrique,dans ces logiciels
        (ex:3DPro) un cylindre généré comme suis auras ces faces interieurs
        invisibles.

            ret:=MakeObject(mybase,PRIM_CYLINDRE,'MonCylindre',10,6,50.0,0)

        Pour avoir les deux cotés des faces faites il faut fc:=2.
@endnode
-><
->> DOC primCube()
@node PRIMCUBE
@title "PrimCube()"


        ret:=PrimCube(base,name,type)


        PARA  :
            base:PTR TO base3d   -> pointeur sur une structure base3d.
            name:PTR TO CHAR     -> nom de l'objet.
            type:LONG        -> type de l'objet

        RETOUR : 
                ERR3D_NONE           si ok,sinon
                ERR3D_WRONGPRIMTYPE  primitive inconnu.


        Ajoute a la base 3D une primitive cubique,c'est a dire que les
    coordonnées des points de l'objet sont des datas fixes.

        les types possibles sont:
        PRIMD_CUBE
        PRIMD_TETRA
        PRIMD_OCTA
        PRIMD_DODECA
        PRIMD_ICOSA
        PRIMD_OCTATRONQUE
        PRIMD_CUBO
@endnode
-><
->> DOC rotateBase3D()
@node ROTATEBASE3D
@title "RotateBase3D(base,key)"


        VOID RotateBase3D(base:PTR TO base3d,key)

        PARA:
        base      -> pointeur sur une structure base3d.
        key   -> const (CURSORUP/CURSORDOWN/CURSORRIGHT/CURSORLEFT)


    Tourne les objets de la base 3D d'un angle de <base.rotationangle>,suivant le
    plan de vue et la valeur de <key>.
    cette fonction appelle @{"RotateBase()" LINK ROTATEBASE} aprés traitement.

    la hiérarchie des procédures de rotations est la suivante:

    RotateBase3D(base,key) appelle @{"RotateBase()" LINK ROTATEBASE},qui
    appelle pour chaque objet @{RotateObject3D()" LINK ROTATEOBJECT3D}.

@endnode
-><
->> DOC rotateBase()
@node ROTATEBASE
@title "RotateBase(base,axe,angle)"


        VOID RotateBase(base:PTR TO base3d,axe,angle)

        PARA:
        base        -> pointeur sur une structure base3d.
        axe     -> un axe de rotation (AXE_X/AXE_Y/AXE_Z).
        angle       -> une valeur d'angle en RADIANS.


    Effectue une rotation de la base,cette fonction est publique mais il
    vaut mieux utilisé @{"RotateBase3D()" LINK ROTATEBASE3D}.

    Voici 2 exemples d'action similaire:

    Exemple 1:
        DEF mybase:PTR TO base3d
        /*== init base and load object ===*/
        ...
        ...
        ....
        mybase.plan:=PLAN_XOY
        mybase.rotationangle:=10.0
        RotateBase3D(mybase,CURSORUP)

    Exemple 2:
        DEF mybase:PTR TO base3d
        DEF agl
        /*== init base and load object ===*/
        ...
        ...
        ....
        mybase.rotationangle:=10.0
        agl:=IeeeSPDiv(IeeeSPMul(base.anglerotation,3.14159),180.0)
        RotateBase(mybase,AXE_X,agl)

@endnode
-><
->> DOC rotateObject3D()
@node ROTATEOBJECT3D
@title "RotateObject3D(base,do,axe,angle=0)"


        VOID RotateObject3D(base:PTR TO base3d,do:PTR TO object3d,axe,angle)

        PARA:
        base        -> pointeur sur une structure base3d.
        do      -> pointeur sur une strcuture object3d.
        axe     -> un axe (AXE_X,AXE_Y,AXE_Z).
        angle       -> angle de rotation en radians.

    Effectue la rotation d'un objet.


@endnode
-><
->> DOC centreBase3D()
@node CENTREBASE3D
@title "CentreBase3D(base)"


        VOID CentreBase3(base:PTR TO base3d)

        PARA:
        base    ->Pointeur sur une structure base3d.


    Centre la base d'objets en 0,0,0.

@endnode
-><
->> DOC centreObject3D()
@node CENTEROBJECT3D
@title "CentreObject3D(base,do)"

        VOID CentreObject3D(base:PTR TO base3d,do:PTR TO object3d)

        PARA:
        base3d         -> pointeur sur un structure base3d.
        do         -> pointeur sur une structure object3d.

    Centre un objet 3d.

@endnode
-><
->> DOC boundedObject3D()
@node BOUNDEDOBJECT3D
@title "BoundedObject3D(base,data,getwith,action)"

        VOID BoundedObject3D(base:PTR TO base3,data,getwith,action)

        PARA:
        base          -> pointeur sur une structure base3d.
        data          -> données en correspondance avec <getwith>
        getwith       -> données en correspondance avec <data>
        action        -> True ou False

    Permet d'encadré un objet de la base 3D.
    >> ATTENTION << cette fonction fait intervenir une procédure se trouvant
    dans le module other/plist.m (getInfoNode()).les paramètres <data> et
    <getwith> sont donc les mêmes que cette fonction.

    (voir @{"Plist.Guide" link "Plist.guide/main"})

@endnode
-><
->> DOC boundedAllObject3D()
@node BOUNDEDALLOBJECT3D
@title "BoundedAllObject3D(base,action)"


        VOID BoundedAllObject3d(base:PTR TO base3d,action)

        encadre tous les objets de la base 3D,les objets ont donc
    tous leurs o.bounded sur <action>.

@endnode
-><
->> DOC selectObject3D()
@node SELECTOBJECT3D
@title "SelectObject3D(base,data,getwith,action)"


        VOID SelectObject3D(base:PTR TO base3,data,getwith,action)

        PARA:
        base          -> pointeur sur une structure base3d.
        data          -> données en correspondance avec <getwith>
        getwith       -> données en correspondance avec <data>
        action        -> True ou False

    Permet de séléctionné un objet de la base 3D.
    >> ATTENTION << cette fonction fait intervenir une procédure se trouvant
    dans le module other/plist.m (getInfoNode()).les paramètres <data> et
    <getwith> sont donc les mêmes que cette fonction.

    (voir @{"Plist.Guide" link "Plist.guide/main"})

@endnode
-><
->> DOC selectAllObject3D()
@node SELECTALLOBJECT3D
@title "SelectAllObject3D(base,action)"

        VOID SelectAllObject3D(bas:PTR TO base3d,action)

        PARA:
        base   -> pointeur sur une structure base3d.
        action -> TRUE ou FALSE

        RETOUR: NIL

        séléctionne tous les objets de la base 3D,les objets ont donc
    tous leurs o.selected sur <action>.
@endnode
-><
->> DOC SAVEINFO
@node SAVEINFO
@title "Sauvegarde"

    Lors de la sauvegarde c'est un dossier la destination est non un
    fichier.Tous les objets sont sauvés un par un dans des fichiers différents.
    Le nom du fichier est le même que le nom de l'objet avec un point d'extention
    différent pour chaque format.
    De plus les objets effectivement sauvés par ces fonctions dépende de la valeur
    de @{"base3d.savewhat" link STRUCTURES},les  différentes valeur sont:

    SAVEOBJ_ALL   -> sauve tous les objetsde la base 3D.
    SAVEOBJ_SEL   -> sauve que les objets seléctionnés.
    SAVEOBJ_DES   -> sauve aue les objets non-seléctionnés.


    @{"SaveBinFile(base,dir,factor)" LINK SAVEBINFILE}
    @{"SavePovFile(base,dir)" LINK SAVEPOVFILE}
    @{"saveRayFile(base,dir)" LINK SAVERAYFILE}
    @{"saveDxfFile(base,dir)" LINK SAVEDXFFILE}
    @{"saveGeoFile(base,dir)" LINK SAVEGEOFILE}
@endnode
-><
->> DOC Fonctions
@node FONCTIONS
@title "Fonctions"

    @{"Init3DBase()   " link INIT3DBASE}
    @{"CheckIf3DFile()" link CHECKIF3DFILE}
    @{"ReadFile3D()   " link READFILE3D}
    @{"SaveGeoFile()  " link SAVEGEOFILE}
    @{"SaveDxfFile()  " link SAVEDXFFILE}
    @{"SaveRayFile()  " link SAVERAYFILE}
    @{"SavePovFile()  " link SAVEPOVFILE}
    @{"SaveBinFile()  " link SAVEBINFILE}
    @{"rem3DBase()    " link REM3DBASE}

    @{"UpdateCenterBase()" link UPDATECENTERBASE}
    @{"BuildMinMax()     " link BUILDMINMAX}

    @{"FormatBase3DWithScreen()" LINK FORMATBASEWITHSCREEN}
    @{"FormatBase3DWithWindow()" LINK FORMATBASEWITHWINDOW}

    @{"DrawBase3D()      " LINK DRAWBASE}
    @{"DrawObject3D()    " LINK DRAWOBJECT3D}
    @{"DrawObjectFace()  " LINK DRAWOBJECTFACE}
    @{"ClearDrawingArea()" LINK CLEARDRAWINGAREA}

    @{"Conv3DObj2Vect()    " LINK CONV3DOBJ2VECT}
    @{"Conv3DObj2VectLib() " LINK CONV3DOBJ2VECTLIB}
    @{"RenderVectorObject()" LINK RENDERVECTOROBJECT}
    @{"GetColor()          " lINK GETCOLOR}

    @{"MakeObject()" link MAKEOBJECT}
    @{"PrimCube()  " link PRIMCUBE}

    @{"RotateBase3D()      " LINK ROTATEBASE3D}
    @{"RotateBase()        " LINK ROTATEBASE}
    @{"RotateObject3D()    " LINK ROTATEOBJECT3D}
    @{"CentreBase3D()      " LINK CENTREBASE3D}
    @{"CentreObject3D()    " LINK CENTEROBJECT3D}
    @{"BoundedObject3D()   " LINK BOUNDEDOBJECT3D}
    @{"BoundedAllObject3D()" LINK BOUNDEDALLOBJECT3D}
    @{"SelectObject3D()    " LINK SELECTOBJECT3D}
    @{"SelectAllObject3D() " link SELECTALLOBJECT3D}

@endnode
-><
->> DOC Structures
@node STRUCTURES
@title "Définitions des structures"

Ce texte est la copie conforme du fichier dddobject.e
->> EDEVHEADER
/*= © NasGûl ==========================
 ESOURCE dddobject.e
 EDIR    Workbench:AmigaE/Sources/3DView/3DLib
 ECOPT   ERRLINE
 EXENAME dddobject.m
 MAKE    BUILD
 AUTHOR  NasGûl
 TYPE    EMOD
=====================================*/
-><
->> ©/DISTRIBUTION/UTILISATION
/*=====================================

 - TOUTE UTILISATION COMMERCIALE DES CES SOURCES EST
   INTERDITE SANS MON AUTORISATION.

 - TOUTE DISTRIBUTION DOIT ETRE FAITES EN TOTALITE (EXECUTABLES/MODULES E/SOURCES E).

 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 !! TOUTE INCLUSION SUR UN CD-ROM EST INTERDITE SANS MON AUTORISATION.!!
 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

=====================================*/
-><
OPT MODULE
OPT EXPORT
MODULE 'exec/nodes'  -> les objets sont chainés dans une liste Exec (lh).
->> Constantes
->> ID IMAGINE -> chunk propre a Imagine.

CONST ID_FORM=$464F524D
CONST ID_TDDD=$54444444
CONST ID_SIZE=$53495A45
CONST ID_NAME=$4E414D45
CONST ID_PNTS=$504E5453
CONST ID_EDGE=$45444745
CONST ID_FACE=$46414345
-><
->> ID SCULPT  -> chunk propre a Sculpt.
CONST ID_SC3D=$53433344
CONST ID_VERT=$56455254
-><
->> ID 3D2 -> chunk propre a CyberStudio (ATTENTION INT).

CONST ID_3D2=$3D02
CONST ID_3D3D=$3D3D

-><
->> ID_VERTEX -> chunk propre a Vertex.
CONST ID_VR3D=$56523344 -> v1.62 et <.
CONST ID_VE3D=$56453344 -> v1.73 et >.
CONST ID_3DDD=$33444444 -> v2.0 .
-><
->> ID 3Dpro -> chunk propre a 3DPro.

CONST ID_3DPRO=$43533344
-><
->> ID LightWave -> chunk propre a LightWave (non utilisé car non trouvé).

CONST ID_LWOB=$4C574F42
CONST ID_POLS=$504F4C53
-><
->> VUE -> constantes définisant le plan de vue de la base 3D.

ENUM PLAN_XOY,PLAN_XOZ,PLAN_YOZ
-><
->> AXE DE LA BASE -> constantes définisant les axes de la base 3D pour les rotations.

ENUM AXE_X,AXE_Y,AXE_Z
-><
->> MODE DE DESSIN -> Constantes définisant le mode de dessin de la base 3D.

ENUM DRAW_PTS,DRAW_FCS,DRAW_PTSFCS
-><>

->=<<<<<<<<<<<<<<< -> Constantes définisant le format de sauvegarde de la base 3D,
->= CTS SAUVEGARDE -> ainsi que les objets a sauvegarder (base3d.savewhat).
->=<<<<<<<<<<<<<<<
ENUM SAVEOBJ_ALL,SAVEOBJ_SEL,SAVEOBJ_DES
ENUM SAVE_DXF,SAVE_GEO,SAVE_RAY,SAVE_BIN,SAVE_POV1,SAVE_POV2

->=<<<<<<<<<<<<< -> Type d'objets fichiers et primitives calculées.
->= TYPE D'OBJET
->=<<<<<<<<<<<<<
ENUM TYPE_IMAGINE,TYPE_OLDCYBER,TYPE_NEWCYBER,TYPE_SCULPT,TYPE_OLDVERTEX,
     TYPE_NEWVERTEX,TYPE_3DPRO,TYPE_LIGHTWAVE,TYPE_VERTEX2,
     PRIM_TORUS,PRIM_MOEBIUS,PRIM_PLAN,PRIM_TRBL,PRIM_SPHERE,
     PRIM_SPIRALE,PRIM_VAGUES,PRIM_CYLINDRE,PRIM_CONED,PRIM_DOME,
     PRIMD_CUBE,PRIMD_TETRA,PRIMD_OCTA,PRIMD_DODECA,PRIMD_ICOSA,
     PRIMD_OCTATRONQUE,PRIMD_CUBO,TYPE_UNKNOWN
    /*
    Les types de fichier suivent cette règle:
        TYPE_<nom>  type d'objet en fichier
        PRIM_<nom>  type d'objet calculé.
        PRIMD_<nom> type d'objet en données fixe.
    */
->=<<<<<<<<<<<<<<<<<<<<<<<<<<<<
->= CONSTANTE D'ARRET DU DESSIN
->=<<<<<<<<<<<<<<<<<<<<<<<<<<<<
CONST STOP_DRAWING=1
->=<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
->= CONSTANTE POUR LA GENERATION DES FACES ET LA CONVERTION VECTORIELLE
->=<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
CONST FV_INDIRECT=0
CONST FV_DIRECT=1
CONST FV_DOUBLE=2
CONST VECTOR_LIB=0,VECTOR_MOD=1
-><
->> Objets
->=<<<<<<<<
->= OBJECTS
->=<<<<<<<<
->=<<<<<<<<<<<<<<<<<<<<<
->= Structure de la base
->=<<<<<<<<<<<<<<<<<<<<<
->****************************************************************
-> Certaines valeurs sont initialisées lors de l'appel de init3DBase()
-> (voir 3Dload.e<PROC init3DBase()>)
-> ATTENTION certaines valeur sont flottantes d'autres non.
-> les pointeurs suivi de * sont privés,vous pouvez les lire sans prôblème
-> mais si vous faites des changements c'est a vos risques et perils.
-> Les autres servent aux diverses fonctions donc configurable.
->****************************************************************
->> OBJECT base3d
OBJECT base3d
    nbrsobjs:LONG     -> nombres total d'objets.  *
    totalpts:LONG     -> nombres total de points. *
    totalfcs:LONG     -> nombres total de faces.  *
    objlist:LONG      -> adresse de la liste Exec contenant les objets. *
    fctoldcyber:LONG      -> facteur 3D a appliqué lors du chargement d'objet Cyber v1.0 (float)
    fctnewcyber:LONG      ->  "                                          "    Cyber v2.0 (float)
    fct3dpro:LONG     ->  "                                          "    3DPro      (float)
    fctsculpt:LONG    ->  "                                          "    Sculpt     (float)
    fctimagine:LONG   ->  "                                          "    Imagine    (float)
    fctvertex:LONG    ->  "                                          "    Vertex     (float)
    vectorfactor:LONG     -> facteur 3D pour la savegarde en BIN.
    minx:LONG         -> minimum en x de la base 3D                  (float) *
    maxx:LONG         -> maximum en x de la base 3D                  (float) *
    miny:LONG         -> minimum en y de la base 3D                  (float) *
    maxy:LONG         -> maximum en y de la base 3D                  (float) *
    minz:LONG         -> minimum en z de la base 3D                  (float) *
    maxz:LONG         -> maximum en z de la base 3D                  (float) *
    echelle:LONG      -> echelle de représentation                   (float)
    plan:LONG         -> plan de vue (PLAN_XOY,PLAN_YOZ,PLAN_XOZ)
    basecx:LONG       -> centre x de la base 3D                  (float)  *
    basecy:LONG       -> centre y de la base 3D                  (float)  *
    basecz:LONG       -> centre z de la base 3D                  (float)  *
    signex:LONG       -> multiplicateur pour le dessin (1.0 ou -1.0),                (float)
    signey:LONG       -> ceci permet d'inverser le dessin sans toucher au points.    (float)
    signez:LONG       -> (en x y et z).                                              (float)
    format:LONG       -> défini la constante largueur/hauteur            (float)  *
    centrex:LONG      -> centre x de l'ECRAN (dépendant de la résolution).                    *
    centrey:LONG      -> centre y de l'ECRAN (idem)                                           *
    draw_x:LONG       -> Cadre du clipping calculée avec la fonction formatBase3DWithWindow() *
    draw_y:LONG       ->
    draw_w:LONG       ->
    draw_h:LONG       ->
    stopcode:LONG     -> code pour l'arret du dessin
    anglerotation:LONG    -> angle de rotation (pour chaque appel a une rotation).       (float)
    palette:LONG      -> Palette
    rgbpts:INT        -> couleur points
    rgbnormal:INT     -> couleur faces
    rgbselect:INT     -> couleur select
    rgbbounding:INT   -> couleur de l'encadrement
    drawmode:LONG     -> mode de dessin
    saveformat:INT    -> format de sauvegarde (SAVE_DXF,SAVE_GEO,SAVE_RAY,SAVE_BIN).
    savewhat:INT      -> séléction de sauvegarde (SAVEOBJ_ALL,SAVEOBJ_SEL,SAVEOBJ_DES).
    freedata:LONG     -> data pour la libération de la mémoire lors de l'éffacement d'un objet. *
    formatname:PTR TO LONG -> data contenant les noms des formats supportés. *
ENDOBJECT
-><
->=<<<<<<<<<<<<<<<<<<<<<
->= Structure d'un objet
->=<<<<<<<<<<<<<<<<<<<<<
->> OBJECT object3
OBJECT object3d
    obj_node:ln     -> noeud exec (ln.name contient le nom de l'objet sinon objet_<num>.  *
    nbrspts:LONG    -> nombres de points de l'objet.                                      *
    nbrsfcs:LONG    -> nombres de faces de l'objet.                                       *
    datapts:LONG    -> adresse des points.                        *
    datafcs:LONG    -> adresse des faces.                         *
    typeobj:LONG    -> type de l'objet (TYPE_<nom>).                                      *
    objcx:LONG      -> centre de l'objet. (float)                                         *
    objcy:LONG      ->                                    *
    objcz:LONG      ->                                    *
    objminx:LONG    -> objet mini et maxi en x,y,z. (float)                               *
    objmaxx:LONG    ->                                    *
    objminy:LONG    ->                                    *
    objmaxy:LONG    ->                                    *
    objminz:LONG    ->                                    *
    objmaxz:LONG    ->                                    *
    selected:LONG -> objet séléctionné ? (TRUE/FALSE).
    bounded:LONG  -> objet encadré ? (TRUE/FALSE).
ENDOBJECT
-><
->=<<<<<<<<<<<<<<<<<<<<<
->= Structure d'un point
->=<<<<<<<<<<<<<<<<<<<<<
->> OBJECT vertice
OBJECT vertice
      x:LONG        -> flottant.
      y:LONG        -> flottant.
      z:LONG        -> flottant.
ENDOBJECT
-><
->=<<<<<<<<<<<<<<<<<<<<<
->= Structure d'une face
->=<<<<<<<<<<<<<<<<<<<<<
->> OBJECT fc
OBJECT fc
      v1:LONG
      v2:LONG
      v3:LONG
ENDOBJECT
-><
-><
->> Erreurs
CONST ERR3D_NONE=TRUE
ENUM  ERR3D_MEM,
      ERR3D_MATHLIB,
      ERR3D_NOFILE,
      ERR3D_UNKNOWNFILE,
      ERR3D_NODIR,
      ERR3D_CONVVECTOR,
      ERR3D_NOVECTORLIB,
      ERR3D_WRONGPRIMTYPE
-><
@endnode
-><


