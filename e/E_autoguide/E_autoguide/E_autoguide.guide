@database "E_autoguide.guide"

@INDEX INDEX

@node MAIN

         +------------------------------------------------------------+
         |                                                            |
         |               "AutoGuide" for Amiga E v3.1a                |
         |                                                            |
         +------------------------------------------------------------+

@{b}Contents:@{ub}

     @{" General  " link General}  All about "AutoGuide" and the Author etc.

     @{" Overview " link Overview}  All keywords in syntactical order
     @{" Index    " link Index}  All keywords in alphabetical order

@endnode

@node General
         +------------------------------------------------------------+
         |                                                            |
         |               "AutoGuide" for Amiga E v3.1a                |
         |          Created by hand from the file 'E.doc'.            |
         |                                                            |
         |   (Amiga E v3.1a and E.doc is © Wouter van Oortmerssen)    |
         |                                                            |
         +------------------------------------------------------------+

     "AutoGuide" means that for every keyword of the E-Language a own node
      exists. So you can easy find the description of the keyword. I also
      built in many cross-references. So you can easy find the counterpart
         of an keyword or similar functions (for example see @{"STRINGs" link STRING}).
        For example: Do you know the syntax of the 'Val()'-function ?
                No ? Then klick here ---> @{"Val" link Val}

                  This conversion was done by Sven Steiniger.
                       (and is still ©Sven Steiniger)

 With 'ged_EAutoGuide.rexx' arexx script you can add a online help to GoldED.
 Simply assign the following command to a key (or menu entry):
     GoldED:arexx/ged_EAutoguide.rexx doc_path
 'doc_path' is the path were you have put in this guide and the .ref file.
 Whenever you press the key the script takes the word under the cursor and
 shows the description in an extra window. If no word is under the cursor
 a requester pops up were you can enter the keyword to be searched.

 Be sure that you have the right GoldED-configuration !!
 (in my GoldED-version the character "=" wasn't set as seperation-character
  (menu config/gui -> Spaces). This give funny effects because GoldED than
  handle (for example) "msgport=NIL" as one (!) word.
  My configuration is now :
     0-" ",34,128-160,".,;:!()[]{}/-<>«»*'|=+"
  )

  Thanks to BURGHARD Eric (ged_guideref.rexx)
  (I use his idee introducing a amigaguide-port, so the .guide-file
   must only be read once)
@endnode

@$VER: E_AutoGuide.guide 3.1a (16.8.95/23:10:00/Text) Hypertext for E Compiler.

@node Overview

@{b}Constants@{ub}

 @{" CONST                     " link CONST}
 @{" ENUM                      " link ENUM}@{" SET                       " link SET}

 @{" built-in constants        " link "built-in constants"}
   @{" TRUE                      " link "built-in constants"}@{" FALSE                     " link "built-in constants"}
   @{" NIL                       " link "built-in constants"}@{" GADGETSIZE                " link "built-in constants"}
   @{" ALL                       " link "built-in constants"}@{" STRLEN                    " link "built-in constants"}
   @{" OLDFILE                   " link "built-in constants"}@{" NEWFILE                   " link "built-in constants"}
   @{" EMPTY                     " link "built-in constants"}


@{b}E Type-System@{ub}

 @{" DEF                       " link DEF}

 @{" LONG                      " link LONG}@{" PTR                       " link PTR}
 @{" INT                       " link INT}@{" CHAR                      " link CHAR}
 @{" ARRAY                     " link ARRAY}@{" OF                        " link OF}

 @{" STRING                    " link STRING}@{" LIST                      " link LIST}
 @{" OBJECT                    " link OBJECT}@{" ENDOBJECT                 " link ENDOBJECT}

 @{" SIZEOF                    " link SIZEOF}

 @{" build-in system variables " link systemvars}
   @{" arg                       " link systemvars}@{" stdout                    " link systemvars}
   @{" stdin                     " link systemvars}@{" conout                    " link systemvars}
   @{" execbase                  " link systemvars}@{" dosbase                   " link systemvars}
   @{" gfxbase                   " link systemvars}@{" intuitionbase             " link systemvars}
   @{" stdrast                   " link systemvars}@{" wbmessage                 " link systemvars}

@{b}Assignment@{ub}

 @{" :=                        " link assignment}

@{b}Statements@{ub}

 @{" AND / And()               " link AND}
 @{" OR  / Or()                " link OR}
 @{" EXIT                      " link EXIT}

 @{" IF                        " link IF}
   @{" THEN                      " link THEN}
   @{" ELSE                      " link IF}
   @{" ELSEIF                    " link IF}
 @{" ENDIF                     " link IF}

 @{" FOR                       " link FOR}
   @{" TO                        " link TO}
   @{" STEP                      " link STEP}
   @{" DO                        " link DO}
 @{" ENDFOR                    " link FOR}

 @{" WHILE                     " link WHILE}
   @{" DO                        " link DO}
 @{" ENDWHILE                  " link WHILE}

 @{" REPEAT                    " link REPEAT}
 @{" UNTIL                     " link UNTIL}

 @{" LOOP                      " link LOOP}
 @{" ENDLOOP                   " link LOOP}

 @{" SELECT                    " link SELECT}
   @{" CASE                      " link SELECT}
   @{" DEFAULT                   " link SELECT}
 @{" ENDSELECT                 " link SELECT}

 @{" JUMP                      " link JUMP}
 @{" INC                       " link INC}
 @{" DEC                       " link DEC}
 @{" VOID                      " link VOID}

@{b}Sequencing@{ub}

 @{" BUT                       " link BUT}

@{b}Functions@{ub}

 @{" PROC                      " link PROC}@{" ENDPROC                   " link ENDPROC}
 @{" RETURN                    " link RETURN}@{" IS                        " link PROC}

 @{" default arguments         " link "default arguments"}
 @{" multiply return values    " link "multiple return values"}
 @{" function values           " link "function values"}

@{b}Unary@{ub}
 @{" {}                        " link unary}@{" ^                         " link ^}
 @{" ++                        " link ++}@{" --                        " link --}
 @{" SIZEOF                    " link SIZEOF}@{" ` (quoted expressions)    " link `}

@{b}Unification@{ub}

 @{" <=>                       " link unification}

@{b}Pointer Typing@{ub}

 @{" ::                        " link "pointer typing"}

@{b}Initialisation@{ub}

 @{" General                   " link initialisation}

@{b}IO-Functions@{ub}

 @{" WriteF()                  " link WriteF}@{" PrintF()                  " link PrintF}
 @{" Out()                     " link Out}@{" Inp()                     " link Inp}
 @{" FileLength()              " link FileLength}@{" ReadStr()                 " link ReadStr}
 @{" SetStdOut()               " link SetStdOut}@{" SetStdIn()                " link SetStdIn}

@{b}String-Functions@{ub}

 @{" String()                  " link String_proc}
 @{" StrCmp()                  " link StrCmp}@{" StrCopy()                 " link StrCopy}
 @{" StrAdd()                  " link StrAdd}@{" StrLen()                  " link StrLen}
 @{" EstrLen()                 " link EstrLen}@{" StrMax()                  " link StrMax}
 @{" StringF()                 " link StringF}@{" RightStr()                " link RightStr}
 @{" MidStr()                  " link MidStr}@{" Val()                     " link Val}
 @{" InStr()                   " link InStr}@{" TrimStr()                 " link TrimStr}
 @{" UpperStr()                " link UpperStr}@{" LowerStr()                " link LowerStr}
 @{" ReadStr()                 " link ReadStr}@{" SetStr()                  " link SetStr}
 @{" AstrCopy()                " link AstrCopy}@{" OstrCmp()                 " link OstrCmp}

@{b}List-Functions@{ub}

 @{" ListCopy()                " link ListCopy}@{" ListAdd()                 " link ListAdd}
 @{" ListCmp()                 " link ListCmp}@{" ListLen()                 " link ListLen}
 @{" ListMax()                 " link ListMax}@{" ListItem()                " link ListItem}
 @{" SetList()                 " link SetList}

@{b}Intuition-Support-Functions@{ub}

 @{" OpenW()                   " link OpenW}@{" CloseW()                  " link CloseW}
 @{" OpenS()                   " link OpenS}@{" CloseS()                  " link CloseS}
 @{" Gadget()                  " link Gadget}@{" Mouse()                   " link Mouse}
 @{" LeftMouse()               " link LeftMouse}@{" WaitLeftMouse()           " link WaitLeftMouse}
 @{" MouseX()                  " link MouseX}@{" MouseY()                  " link MouseY}
 @{" WaitIMessage()            " link WaitIMessage}@{" MsgCode()                 " link MsgCode}
 @{" MsgQualifier()            " link MsgQualifier}@{" MsgIaddr()                " link MsgIaddr}

@{b}Graphic-Support-Functions@{ub}

 @{" General                   " link graphfuncs}

 @{" Plot()                    " link Plot}@{" Line()                    " link Line}
 @{" Box()                     " link Box}@{" Colour()                  " link Colour}
 @{" TextF()                   " link TextF}@{" SetStdRast()              " link SetStdRast}
 @{" SetTopaz()                " link SetTopaz}@{" SetColour()               " link SetColour}

@{b}System-Support-Functions@{ub}

 @{" KickVersion()             " link KickVersion}@{" CleanUp()                 " link CleanUp}
 @{" FreeStack()               " link FreeStack}@{" CtrlC()                   " link CtrlC}

@{b}Memory (De-)Allocation@{ub}

 @{" New()                     " link New}@{" NewR()                    " link NewR}
 @{" NewM()                    " link NewM}@{" Dispose()                 " link Dispose}

 @{" NEW                       " link NEW 13}@{" END                       " link END}
 @{" FastNew()                 " link FastNew}@{" FastDispose()             " link FastDispose}
 @{" FastDisposeList()         " link FastDisposeList}

@{b}Peek and Poke@{ub}
 
 @{" Char()                    " link Char_proc}@{" PutChar()                 " link PutChar}
 @{" Int()                     " link Int_proc}@{" PutInt()                  " link PutInt}
 @{" Long()                    " link Long_proc}@{" PutLong()                 " link PutLong}

@{b}Math-Functions@{ub}

 @{" And()                     " link AND}@{" Or()                      " link OR}
 @{" Not()                     " link Not}@{" Eor()                     " link Eor}
 @{" Mul()                     " link Mul}@{" Div()                     " link Div}
 @{" Odd()                     " link Odd}@{" Even()                    " link Even}
 @{" Min()                     " link Min}@{" Max()                     " link Max}
 @{" Rnd()                     " link Rnd}@{" RndQ()                    " link RndQ}
 @{" Abs()                     " link Abs}@{" Sign()                    " link Sign}
 @{" Mod()                     " link Mod}@{" Shl()                     " link Shl}
 @{" Shr()                     " link Shr}@{" Bounds()                  " link Bounds}

@{b}String and List linking functions@{ub}

 @{" General                   " link linkfunctions}

 @{" Link()                    " link Link}@{" Next()                    " link Next}
 @{" Forward()                 " link Forward}@{" DisposeLink()             " link DisposeLink}

@{b}Lisp-Cells and Lisp-Functions@{ub}

 @{" Lisp-Cells                " link lispcells}
 @{" <=> (Unification)         " link unification}

 @{" Car()                     " link Car}@{" Cdr()                     " link Cdr}
 @{" Cell()                    " link Cell}@{" FreeCells()               " link FreeCells}
 @{" SetChunkySize()           " link SetChunkySize}

@{b}Module-Interface@{ub}

 @{" MODULE                    " link MODULE}

 @{" EXPORT                    " link EXPORT}@{" PRIVATE                   " link PRIVATE}

@{b}Quoting and Scope@{ub}

 @{" ` (quoting)               " link `}

 @{" Eval()                    " link Eval}@{" MapList()                 " link MapList}
 @{" ForAll()                  " link ForAll}@{" Exists()                  " link Exists}

@{b}Float-type and Float-functions@{ub}

 @{" ! (float operator)        " link !}

 @{" Fsin()                    " link Fsin}@{" Fcos()                    " link Fcos}
 @{" Ftan()                    " link Ftan}@{" Fabs()                    " link Fabs}
 @{" Ffloor()                  " link Ffloor}@{" Fceil()                   " link Fceil}
 @{" Fexp()                    " link Fexp}@{" Flog()                    " link Flog}
 @{" Flog10()                  " link Flog10}@{" Fpow()                    " link Fpow}
 @{" Fsqrt()                   " link Fsqrt}@{" RealVal()                 " link RealVal}
 @{" RealF()                   " link RealF}

@{b}Exception-System@{ub}

 @{" General                   " link exceptions}

 @{" HANDLE                    " link HANDLE}@{" EXCEPT                    " link EXCEPT}
 @{" RAISE / IF                " link RAISE}@{" exceptionIDs              " link exceptionIDs}
 @{" Raise()                   " link Raise_proc}@{" Throw()                   " link Throw}
 @{" ReThrow()                 " link ReThrow}

@{b}Object-Oriented Programming@{ub}

 @{" General                   " link "OO features"}

 @{" PUBLIC                    " link PUBLIC}@{" PRIVATE                   " link PRIVATE}
 @{" SUPER                     " link SUPER}

@{b}Assembly in E@{ub}

 @{" Assembly                  " link Assembly}

@{b}Register-Allocation@{ub}

 @{" REG                       " link REG}

@{b}Using Binary Data@{ub}

 @{" INCBIN                    " link INCBIN}@{" LONG                      " link INCBIN 13}
 @{" INT                       " link INCBIN 13}@{" CHAR                      " link INCBIN 13}

@{b}OPT-Keyword@{ub}

 @{" OPT                       " link OPT}

@{b}The PreProcessor@{ub}

 @{" PreProcessor              " link preprocess}
 @{" #define                   " link #define}@{" #ifdef                    " link #ifdef}
 @{" #ifndef                   " link #ifndef}@{" #endif                    " link #endif}

@endnode

@node INDEX
@{b}!@{ub}
  @{" !                   " link !}
@{b}#@{ub}
  @{" #define             " link #define}
  @{" #endif              " link #endif}
  @{" #ifdef              " link #ifdef}
  @{" #ifndef             " link #ifndef}
@{b}+@{ub}
  @{" ++                  " link ++}
@{b}-@{ub}
  @{" --                  " link --}
@{b}:@{ub}
  @{" ::                  " link "pointer typing"}
  @{" :=                  " link assignment}
@{b}<@{ub}
  @{" <=>                 " link unification}
@{b}A@{ub}
  @{" Abs()               " link "built-in constants"}
  @{" ALL                 " link "built-in constants"}
  @{" AND                 " link AND}
  @{" And()               " link AND}
  @{" arg                 " link systemvars}
  @{" ARRAY               " link ARRAY}
  @{" AstrCopy()          " link AstrCopy}
@{b}B@{ub}
  @{" Bounds()            " link Bounds}
  @{" Box()               " link Box}
  @{" BUT                 " link BUT}
@{b}C@{ub}
  @{" Car()               " link Car}
  @{" CASE                " link SELECT}
  @{" Cdr()               " link Cdr}
  @{" Cell()              " link Cell}
  @{" CHAR                " link CHAR}
  @{" Char()              " link Char_proc}
  @{" CleanUp()           " link CleanUp}
  @{" CloseS()            " link CloseS}
  @{" CloseW()            " link CloseW}
  @{" Colour()            " link Colour}
  @{" conout              " link systemvars}
  @{" CONST               " link CONST}
  @{" CtrlC()             " link CtrlC}
@{b}D@{ub}
  @{" DEC                 " link DEC}
  @{" DEF                 " link DEF}
  @{" DEFAULT             " link SELECT}
  @{" Dispose()           " link Dispose}
  @{" DisposeLink()       " link DisposeLink}
  @{" Div()               " link Div}
  @{" DO                  " link DO}
  @{" dosbase             " link systemvars}
@{b}E@{ub}
  @{" ELSE                " link IF}
  @{" ELSEIF              " link IF}
  @{" EMPTY               " link EMPTY}
  @{" END                 " link END}
  @{" ENDFOR              " link FOR}
  @{" ENDIF               " link IF}
  @{" ENDLOOP             " link LOOP}
  @{" ENDOBJECT           " link ENDOBJECT}
  @{" ENDPROC             " link ENDPROC}
  @{" ENDSELECT           " link ENDSELECT}
  @{" ENDWHILE            " link WHILE}
  @{" ENUM                " link ENUM}
  @{" Eor()               " link Eor}
  @{" EstrLen()           " link EstrLen}
  @{" Eval()              " link Eval}
  @{" Even()              " link Even}
  @{" EXCEPT              " link EXCEPT}
  @{" execbase            " link systemvars}
  @{" Exists()            " link Exists}
  @{" EXIT                " link EXIT}
  @{" EXPORT              " link EXPORT}
@{b}F@{ub}
  @{" Fabs()              " link Fabs}
  @{" FALSE               " link "built-in constants"}
  @{" FastDispose()       " link FastDispose}
  @{" FastDisposeList()   " link FastDisposeList}
  @{" FastNew()           " link FastNew}
  @{" Fceil()             " link Fceil}
  @{" Fcos()              " link Fcos}
  @{" Fexp()              " link Fexp}
  @{" Ffloor()            " link Ffloor}
  @{" FileLength()        " link FileLength}
  @{" Flog()              " link Flog}
  @{" Flog10()            " link Flog10}
  @{" FOR                 " link FOR}
  @{" ForAll()            " link ForAll}
  @{" Forward()           " link Forward}
  @{" Fpow()              " link Fpow}
  @{" FreeCells()         " link FreeCells}
  @{" FreeStack()         " link FreeStack}
  @{" Fsin()              " link Fsin}
  @{" Fsqrt()             " link Fsqrt}
  @{" Ftan()              " link Ftan}
@{b}G@{ub}
  @{" Gadget()            " link Gadget}
  @{" GADGETSIZE          " link "built-in constants"}
  @{" gfxbase             " link systemvars}
@{b}H@{ub}
  @{" HANDLE              " link HANDLE}
@{b}I@{ub}
  @{" IF                  " link IF}
  @{" INC                 " link INC}
  @{" INCBIN              " link INCBIN}
  @{" Inp()               " link Inp}
  @{" InStr()             " link InStr}
  @{" INT                 " link INT}
  @{" Int()               " link Int_proc}
  @{" intuitionbase       " link systemvars}
  @{" IS                  " link PROC}
@{b}J@{ub}
  @{" JUMP                " link JUMP}
@{b}K@{ub}
  @{" KickVersion()       " link KickVersion}
@{b}L@{ub}
  @{" LeftMouse()         " link LeftMouse}
  @{" Line()              " link Line}
  @{" Link()              " link Link}
  @{" LIST                " link LIST}
  @{" List()              " link List_proc}
  @{" ListAdd()           " link ListAdd}
  @{" ListCmp()           " link ListCmp}
  @{" ListCopy()          " link ListCopy}
  @{" ListItem()          " link ListItem}
  @{" ListLen()           " link ListLen}
  @{" ListMax()           " link ListMax}
  @{" LONG                " link LONG}
  @{" Long()              " link Long_proc}
  @{" LOOP                " link LOOP}
  @{" LowerStr()          " link LowerStr}
@{b}M@{ub}
  @{" MapList()           " link MapList}
  @{" Max()               " link Max}
  @{" MidStr()            " link MidStr}
  @{" Min()               " link Min}
  @{" Mod()               " link Mod}
  @{" MODULE              " link MODULE}
  @{" Mouse()             " link Mouse}
  @{" MouseX()            " link MouseX}
  @{" MouseY()            " link MouseY}
  @{" MsgCode()           " link MsgCode}
  @{" MsgIaddr()          " link MsgIaddr}
  @{" MsgQualifier()      " link MsgQualifier}
  @{" Mul()               " link Mul}
@{b}N@{ub}
  @{" NEW                 " link NEW}
  @{" New()               " link New_proc}
  @{" NEWFILE             " link "built-in constants"}
  @{" NewM()              " link NewM}
  @{" NewR()              " link NewR}
  @{" Next()              " link Next}
  @{" NIL                 " link "built-in constants"}
  @{" Not()               " link Not}
@{b}O@{ub}
  @{" OBJECT              " link OBJECT}
  @{" Odd()               " link Odd}
  @{" OF                  " link OF}
  @{" OLDFILE             " link "built-in constants"}
  @{" OpenS()             " link OpenS}
  @{" OpenW()             " link OpenW}
  @{" OPT                 " link OPT}
  @{" OR                  " link OR}
  @{" Or()                " link OR}
  @{" OstrCmp()           " link OstrCmp}
  @{" Out()               " link Out}
@{b}P@{ub}
  @{" Plot()              " link Plot}
  @{" PrintF()            " link PrintF}
  @{" PRIVATE             " link PRIVATE}
  @{" PROC                " link PROC}
  @{" PTR                 " link PTR}
  @{" PUBLIC              " link PUBLIC}
  @{" PutChar()           " link PutChar}
  @{" PutInt()            " link PutInt}
  @{" PutLong()           " link PutLong}
@{b}R@{ub}
  @{" RAISE               " link RAISE}
  @{" Raise()             " link Raise_proc}
  @{" ReadStr()           " link ReadStr}
  @{" RealF()             " link RealF}
  @{" RealVal()           " link RealVal}
  @{" REG                 " link REG}
  @{" REPEAT              " link REPEAT}
  @{" ReThrow()           " link ReThrow}
  @{" RETURN              " link RETURN}
  @{" RightStr()          " link RightStr}
  @{" Rnd()               " link Rnd}
  @{" RndQ()              " link RndQ}
@{b}S@{ub}
  @{" SELECT              " link SELECT}
  @{" SET                 " link SET}
  @{" SetChunkySize()     " link SetChunkySize}
  @{" SetColour()         " link SetColour}
  @{" SetList()           " link SetList}
  @{" SetStdIn()          " link SetStdIn}
  @{" SetStdOut()         " link SetStdOut}
  @{" SetStdRast()        " link SetStdRast}
  @{" SetStr()            " link SetStr}
  @{" SetTopaz()          " link SetTopaz}
  @{" Shl()               " link Shl}
  @{" Shr()               " link Shr}
  @{" Sign()              " link Sign}
  @{" SIZEOF              " link SIZEOF}
  @{" stdin               " link systemvars}
  @{" stdout              " link systemvars}
  @{" stdrast             " link systemvars}
  @{" STEP                " link STEP}
  @{" StrAdd()            " link StrAdd}
  @{" StrCmp()            " link StrCmp}
  @{" StrCopy()           " link StrCopy}
  @{" STRING              " link STRING}
  @{" String()            " link String_proc}
  @{" StringF()           " link StringF}
  @{" StrLen()            " link StrLen}
  @{" StrMax()            " link StrMax}
  @{" SUPER               " link SUPER}
@{b}T@{ub}
  @{" TextF()             " link TextF}
  @{" THEN                " link THEN}
  @{" Throw()             " link Throw}
  @{" TO                  " link TO}
  @{" TrimStr()           " link TrimStr}
  @{" TRUE                " link "built-in constants"}
@{b}U@{ub}
  @{" UNTIL               " link UNTIL}
  @{" UpperStr()          " link UpperStr}
@{b}V@{ub}
  @{" Val()               " link Val}
  @{" VOID                " link VOID}
@{b}W@{ub}
  @{" WaitIMessage()      " link WaitIMessage}
  @{" WaitLeftMouse()     " link WaitLeftMouse}
  @{" wbmessage           " link systemvars}
  @{" WHILE               " link WHILE}
  @{" WriteF()            " link WriteF}
@{b}^@{ub}
  @{" ^                   " link ^}
@{b}`@{ub}
  @{" `                   " link `}
@{b}{}@{ub}
  @{" { }                 " link unary}
@endnode

@node STRING
 string ('bla')
----------------
Strings are any ascii representation, enclosed in single '' quotes.
The value of such a string is a pointer to the first character of it.
More specific: 'bla' yields a 32bit pointer to a memory area where
we find the bytes "b", "l" and "a". ALL strings in E are terminated
by a zero byte.
Strings may contain format signs introduced by a slash "\", either
to introduce characters to the string that are for some reason
not displayable, or for use with string formatting functions
like @{"WriteF()" link WriteF}, @{"TextF()" link TextF} and @{"StringF()" link StringF}, or kick2 Vprintf().

\n		a linefeed (ascii 10)
\a or ''	an apostrophe ' (the one used for enclosing the string)
\q		a doublequote: "
\e		escape (ascii 27)
\t		tab (ascii 9)
\\		a backslash
\0		a zero byte. Of rare use, as ALL strings are 0-terminated
\b		a carriage return (ascii 13)

Additionally, when used with formatting functions:

\d	print a decimal number
\h	print a hexadecimal
\s	print a string
\c	print a character
\z	set fill byte to '0' character
\l	format to left of field
\r	format to right of field (these last two act as toggles)

Field specifiers may follow the \d,\h and \s codes:

[x]	specify exact field width x
(x,y)	specify minimum x and maximum y (strings only)

Example: print a hexadecimal number with 8 positions and leading zeroes:
WriteF('\z\h[8]\n',num)

A string may be extended over several lines by trailing them with a "+"
sign and a <lf>:

'this specifically long string ' +
'is separated over two lines'


 the complex type (STRING)
----------------------------
  Similar to arrays, but different in the respect that they may only be
  changed by using E string functions, and that they contain length and
  maxlength information, so string functions may alter them in a safe
  fashion, i.e: the string can never grow bigger than the memory area
  it is in. Definition:

  DEF s[80]:STRING

  The STRING datatype (called an estring) is backwards compatible with
  @{"PTR" link PTR} TO @{"CHAR" link CHAR} and of course @{"ARRAY" link ARRAY} OF @{"CHAR" link CHAR}, but not the other way around.

 strings
---------

E has a datatype STRING. This is a string, from now on called 'Estring',
that may be modified and changed in size, as opposed to normal 'strings',
which will be used here for any zero-terminated sequence. Estrings are
downward compatible with strings, but not the other way around, so if an
argument requests a normal string, it can be either of them. If an Estring
is requested, don't use normal strings. Example of usage:

DEF s[80]:STRING, n                -> s is an estring with a maxlen of 80
@{"ReadStr" link ReadStr}(stdout,s)                  -> read input from the console
n:=@{"Val" link Val}(s)                          -> get a number out of it
  -> etc.

Note that all string functions will handle cases where string tends to
get longer than the maximum length correctly;

DEF s[5]:STRING
@{"StrAdd" link StrAdd}(s,'this string is longer than 5 characters',ALL)

s will contain just 'this '.

A strings may also be allocated dynamically from system memory with @{"String()" link String_proc}.

See for string-functions:
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"StrLen" link StrLen}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCopy" link OstrCopy}
@endnode

@node String_proc
Syntax: String(maxlen)

A string may also be allocated dynamically from system memory
with the function String(), (note: the pointer returned from this function
must always be checked against NIL)

	s:=String(maxlen)

DEF s[80]:STRING     is equivalent to     DEF s     and     s:=String(10)


See for string-functions:
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"StrLen" link StrLen}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCopy" link OstrCopy}
See for string linking functions:
    @{"Link" link Link}, @{"Next" link Next}, @{"Forward" link Forward}, @{"DisposeLink" link DisposeLink}
@endnode

@node LIST
 lists ([1,2,3]) and typed lists
----------------------------------
An immediate list is the constant counterpart of the LIST datatype,
just as a 'string' is the constant counterpart for the @{"STRING" link STRING} or
@{"ARRAY" link ARRAY} OF @{"CHAR" link CHAR} datatype. Example:

[3,2,1,4]

is an expression that has as value a @{"PTR" link PTR} to an already initialised list,
a list as a representation in memory is compatible with an @{"ARRAY" link ARRAY} OF @{"LONG" link LONG},
with some extra length information at a negative offset. You may use these
immediate lists anywhere a function expects a @{"PTR" link PTR} to an array of
32bits values, or a list. Examples:

['string',1.0,2.1]
[WA_FLAGS,1,WA_IDCMP,$200,WA_WIDTH,120,WA_HEIGHT,150,TAG_DONE]


 the complex type (LIST)
-------------------------
  These may be interpreted as a mix between a @{"STRING" link STRING} and an @{"ARRAY" link ARRAY} OF @{"LONG" link LONG}.
  I.e: this data structure holds a list of @{"LONG" link LONG} variables which may be
  extended and shortened like @{"STRINGs" link STRING}. Definition:

  DEF x[100]:LIST

  A powerful addition to this datatype is that it also has a 'constant'
  equivalent [], like @{"STRINGs" link STRING} have ''. LIST is backward compatible with
  @{"PTR" link PTR} TO @{"LONG" link LONG} and of course @{"ARRAY" link ARRAY} OF @{"LONG" link LONG}, but not the other way around.


 lists
-------

  Lists are like strings, only they consist of @{"LONGs" link LONG}, not @{"CHARs" link CHAR}.
  They may also be allocated either global, local or dynamic:

  DEF mylist[100]:LIST         /* local or global */
  DEF a
  a:=@{"List" link List_proc}(10)                  /* dynamic */

  Just as strings may be represented as constants in expressions, lists
  have their constant equivalent:

  [1,2,3,4]

  The value of such an expression is a pointer to an already initialised list.
  Special feature is that they may have dynamic parts, i.e, which will
  be filled in at runtime:

  a:=3
  [1,2,a,4]

  moreover, lists may have some other type than the default @{"LONG" link LONG}, like:

  [1,2,3]:INT
  [65,66,67,0]:CHAR                    /* equivalent with   'ABC'   */
  ['topaz.font',8,0,0]:textattr
  OpenScreenTagList(NIL,[SA_TITLE,'MyScreen',TAG_DONE])

  As shown in the latter examples, lists are extremely useful with
  system functions: they are downward compatible with an @{"ARRAY" link ARRAY} OF @{"LONG" link LONG},
  and object-typed ones can be used wherever a system function needs
  a pointer to some structure, or an array of those.
  Taglists and vararg functions may also be used this way.
  NOTEZ BIEN: all list functions only work with @{"LONG" link LONG} lists, typed-lists
  are only convenient in building complex data structures and expressions.

  As with strings, a certain hierarchy holds:
  list variables -> constant lists -> array of long/ptr to long
  When a function needs an array of long you might just as well give a list
  as argument, but when a function needs a listvar, or a constant list,
  then an array of long won't do.

  It's important that one understands the power of lists and in particular
  typed-lists: these can save you lots of trouble when building just
  about any data-structure. Try to use these lists in your own programs,
  and see what function they have in the example-programs.

  summary:

  [<item>,<item>,... ]		immediate list (of @{"LONGs" link LONG}, use with listfuncs)
  [<item>,<item>,... ]:<type>	typed list (just to build data structures)

  If <type> is a simple type like @{"INT" link INT} or @{"CHAR" link CHAR}, you'll just have the
  initialised equivalent of @{"ARRAY" link ARRAY} OF <type>, if <type> is an object-name,
  you'll be building initialised objects, or @{"ARRAY" link ARRAY} OF <object>, depending
  on the length of the list.

  If you write    [1,2,3]:INT   you'll create a data structure of 6 bytes,
  of 3 16bit values to be precise. The value of this expression then
  is a pointer to that memory area. Same works if, for example, you have
  an object like:

  OBJECT myobject
    a:LONG, b:CHAR, c:INT
  ENDOBJECT

  writing    [1,2,3]:myobject     would then mean creating a data structure
  in memory of 8 bytes, with the first four bytes being a @{"LONG" link LONG} with value 1,
  the following byte a @{"CHAR" link CHAR} with value 2, then a pad byte, and the last
  two bytes an @{"INT" link INT} (2 bytes) with value 3. you could also write:

  [1,2,3,4,5,6,7,8,9]:myobject

  you would be creating an @{"ARRAY" link ARRAY} OF myobject with size 3. Note that such
  lists don't have to be complete (3,6,9 and so on elements), you may
  create partial objects with lists of any size

  One last note on data size: on the amiga, you may rely on the fact that
  a structure like 'myobject' has size 8, and that it has a pad byte
  to have word (16bit) alignment. It is however very likely that an
  E-compiler for 80x86 architectures will not use the pad byte and make
  it a 7byte structure, and that an E-compiler for a sun-sparc architecture
  (if I'm not mistaken) will try to align on 32bit boundaries, thus make
  it a 10 or 12 byte structure. Some microprocessors (they are rare, but
  they exist) even use (36:18:9) as numbers of bits for their types
  (LONG:INT:CHAR), instead of (32:16:8) as we're used to. So don't make too
  great an assumption on the structure of @{"OBJECTs" link OBJECT} and LISTs if you want to
  write code that stands a chance of being portable or doesn't rely on side
  effects.


For dynamical Lists see @{"List()" link List_proc}

See also:
    @{"ListLen" link ListLen}, @{"ListItem" link ListItem}
See for using with @{"quoted expressions" link `},
                   @{"Eval" link Eval}, @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"Exists" link Exists}, @{"SelectList" link SelectList}
@endnode


@node List_proc
Syntax: List(length)

Lists are like strings, only they consist of @{"LONGs" link LONG}, not @{"CHARs" link CHAR}.
They may also be allocated either global, local or dynamic:

DEF mylist[100]:LIST         /* local or global */
DEF a
a:=List(10)                  /* dynamic */

(note that in the latter case, pointer 'a' may contain NIL)

See also:
    The @{"LIST" link LIST}-type
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
See for list linking functions:
    @{"Link" link Link}, @{"Next" link Next}, @{"Forward" link Forward}, @{"DisposeLink" link DisposeLink}
See for using with @{"quoted expressions" link `},
                   @{"Eval" link Eval}, @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"Exists" link Exists}, @{"SelectList" link SelectList}
@endnode

@node OF
Used with @{" ARRAY " link ARRAY},
          @{" OO - Object inheritance " link "OO features" 12},
          @{" OO - methods and virtual methods " link "OO features" 101}
@endnode

@node OBJECT
 the compound type (OBJECT)
----------------------------
OBJECTs are like a struct/class in C/C++ or a RECORD in pascal. Example:

OBJECT myobj
  a:LONG
  b:CHAR
  c:INT
ENDOBJECT

This defines a data structure consisting of three elements. Syntax:

OBJECT <objname>
  <membername> [ : <type> ]           /* any number of these */
@{"ENDOBJECT" link ENDOBJECT}

where type is one of the following:

@{"CHAR" link CHAR}/@{"INT" link INT}/@{"LONG" link LONG}/<object>
@{"PTR TO" link PTR} CHAR/INT/LONG/<object>
@{"ARRAY OF" link ARRAY} CHAR/INT/LONG/<object>

(ARRAY is short for ARRAY OF CHAR)

like DEF declarations, omitting the type means :LONG.

Note that <membername> need not be a unique identifier,
it may be in other objects too. There are lots of ways to use objects:

DEF x:myobj                      /* x is a structure */
DEF y:PTR TO myobj               /* y is just a pointer to it */
DEF z[10]:ARRAY OF myobj

y:=[-1,"a",100]:myobj            /* typed lists */

IF y.b="a" THEN /* ... */

z[4].c:=z[d+1].b++

ARRAYs in objects are always rounded to even sizes, and put on
even offsets:

OBJECT mystring
  len:CHAR, data[9]:ARRAY
ENDOBJECT

@{"SIZEOF" link SIZEOF} mystring is 12, and "data" starts at offset 2.

'PTR TO' is the only type in OBJECTs that may refer to yet undeclared
other objects.

For all other OBJECT features that are somehow OO related see @{"OO features" link "OO features"}.
@endnode

@node ENDOBJECT
Syntax: ENDOBJECT

 See @{"OBJECT" link OBJECT}
@endnode

@node BUT
 sequencing (BUT)
------------------
The sequencing operator "BUT" allows two expressions to be written
in a construction that allows for only one. Often in writing
complex expressions/function calls, one would like to do a second
thing on the spot, like an assignment.

Syntax: <exp1> BUT <exp1>

this says: evaluate exp1, but return the value of exp2.
Example:

myfunc((x:=2) BUT x*x)

assign 2 to x and then calls myfunc with x*x. The () around the
assignment are again needed to prevent the @{":=" link assignment} operator from taking
(2 BUT x*x) as an expression.
@endnode

@node AND
 logical and bitwise (AND)
------------------------------
Syntax: a:=b AND c	/* operator */
        a:=And(b,c)     /* function */

These operators either combine truth values to new ones, or perform
bitwise AND operations. Examples:
(a>1) AND ((b=2) AND (c>=3))        /* logical */
a:=b AND $FF                        /* bitwise */

See @{"Or" link Or}, @{"Eor" link Eor}
@endnode

@node OR
 logical and bitwise (OR)
------------------------------
Syntax: a:=b OR c     /* operator */
        a:=Or(b,c)    /* function */

These operators either combine truth values to new ones, or perform
bitwise OR operations. Examples:
(a>1) OR ((b=2) OR (c>=3))         /* logical */
a:=b OR $FF                        /* bitwise */

See @{"And" link And}, @{"Eor" link Eor}
@endnode

@node SIZEOF
Syntax: SIZEOF <objectident>

simply returns the size of a certain @{"object" link object} or @{"CHAR" link CHAR}/@{"INT" link INT}/@{"LONG" link LONG}.
Example: SIZEOF newscreen + SIZEOF INT
@endnode

@node IF
 conditional statement (IF)
----------------------------
IF, THEN, ELSE, ELSEIF, ENDIF

syntax:		IF <exp> THEN <statement> [ ELSE <statement> ]
or:		IF <exp>
                  <statements>
		[ ELSEIF <exp>           /* multiple elseifs may occur */
                  <statements> ]
		[ ELSE ]
                  <statements>
		ENDIF

builds a conditional block. Note that there are two general forms of
this statement, a single-line and a multiple-line version.


 triple (IF THEN ELSE)
-----------------------
The IF operator has quite the same function as the IF statement, only
it selects between two expressions instead of two statements or blocks
of statements. It equals the x?y:z operator in C.

IF <boolexp> THEN <exp1> ELSE <exp2>

returns exp1 or exp2, according to boolexp. For example, instead of:

IF a<1 THEN b:=2 ELSE b:=3
IF x=3 THEN @{"WriteF" link WriteF}('x is 3\n') ELSE WriteF('x is something else\n')

write:

b:=IF a<1 THEN 2 ELSE 3
WriteF(IF x=3 THEN 'x is 3\n' ELSE 'x is something else\n')
@endnode

@node ARRAY
 array ([]) - Syntax
---------------------
<var>[<indexexp>] (is a <varexp>)
This operator reads the value from the array <var> points to, with
index <indexexp>. The index may be just about any expression.
Note1: "[]" is a shortcut for "[0]"
Note2: with an array of n elements, the index is  0 .. n-1
Examples:

a[1]:=10           /* sets second element to 10 */
x:=table[y*4+1]    /* reads from array */
x.y[3]             /* accesses array in an object */


 the array type (ARRAY)
------------------------
ARRAYs are declared by specifying their length (in bytes):

@{"DEF" link DEF} b[100]:ARRAY

this defines an array of 100 bytes. Internally, 'b' is a variable of
type LONG and a PTR to this memory area.
Default type of an array-element is CHAR, it may be anything by specifying:

DEF x[100]:ARRAY OF LONG
DEF mymenus[10]:ARRAY OF newmenu

where "newmenu" is an example of a structure, called OBJECTs in E.
Array access is very easy with:   <var>[<sexp>]

b[1]:="a"
z:=mymenus[a+1].mutualexclude

Note that the index of an array of size n ranges from 0 to n-1,
and not from 1 to n.
Note that ARRAY OF <type> is compatible with PTR TO <type>, with the
only difference that the variable that is an ARRAY is already
initialised.
@endnode

@node NEW
 dynamic memory allocation (NEW-operator)
------------------------------------------
the NEW operator is a powerful operator for dynamic memory allocation.
it has various forms:

(assuming DEF p:PTR TO whateverobj, q:PTR TO INT)

NEW p

is an expression that will allocate zero-ised memory for the object-size
p points to. the resulting pointer will be put in p, and is also
the value of the expression. if NEW fails to get memory, it raises
a "NEW" exception. 'NEW p' is therefore roughly equivalent with:

IF (p:=New(SIZEOF whateverobj))=NIL THEN @{"Raise" link Raise_proc}("MEM")

with the difference that p never gets any value if an exception
is raised, and that the former is of course an expression, not
a statement

but there's more: one can also allocate an array dynamically:

NEW p[10]       /* array of 10 objects */

NEW q[a+1]      /* array of INT, size is runtime computed */

(this doesn't work when instantiating classes)
A problem with list [1,2,3] expressions sometimes is that they are static,
and when using these to build large datastructures they would need to be
created at run-time. one may then use the dynamic equivalent to static
lists:

p:=[1,2,3]:whateverobj           /* static structure */

p:=NEW [1,2,3]:whateverobj       /* dynamicly allocated! */

this works with both lists and typed-lists, and also with arrays:

NEW [1,2,3]        /* constant-list, dyn. (note: not a like a listvar!) */
NEW [1,2,3]:obj    /* object */
NEW [1,2,3]:INT    /* array of INTs */

freeing memory allocated with any variations of NEW is done automatically
at the end of the program, or by hand with @{"END" link END} or @{"FastDispose()" link FastDispose}.
(note: the only exception is NEW <list>, use @{"FastDisposeList()" link FastDisposeList})

If you use NEW [...]:obj, and the number of fields is less than the
one present in the object, additional 0/NIL/"\0" whatever fields will
be added. this allows one to extend objects without getting into
trouble with allocations like these. (note that this is different
from the static [...]:obj)

when you use NEW as a statement, multiple pointers may follow, i.e.:

	NEW a,b.create(),c

is valid.

See @{"END" link END},
    @{"New()" link New_proc},@{"Dispose()" link Dispose},
    @{"NewR()" link NewR}, @{"NewM()" link NewM}, @{"FastNew()" link FastNew}, @{"FastDispose()" link FastDispose}, @{"FastDisposeList()" link FastDisposeList},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node New_proc
Syntax: mem:=New(n)

This dynamically creates an array (or memory area, if you wish) of
n bytes. Difference with AllocMem() is that it is called automatically
with flags $10000 (i.e cleared mem, any type) and that no calls to
Dispose() are necessary, as it is linked to a memory list that is
automatically de-allocated upon exit of your program.

See @{"Dispose()" link Dispose},@{"NewR()" link NewR}, @{"NewM()" link NewM}, @{"FastNew()" link FastNew},
    @{"NEW" link NEW}
@endnode

@node unification
 unification (<=>)
-------------------
Unification allows a totally different style of programming
that will be familiar to you if you're used to either Logic
(ProLog), equational or functional (Miranda/Gofer/Haskell)
programming. Most of us when using structures/arrays whatever
are used to get values from it by selection ("." and "[]"),
in these languages however pattern matching is used.

in E:

exp <=> uni_exp

exp can be any expression, but in v3 it's only really useful
if it somehow is a pointer to a @{"list" link list}. uni_exp is the pattern
that is used to match exp. All constants in uni_exp much
match to values in exp, variables are set to their respective
values. if something doesn't match, no variables get a value,
and the expression has the result FALSE. otherwise TRUE.
example:

a:=[1,2,3]
...
IF a <=> [1,x,y] THEN ...

this will succeed with x=2 and y=3. If list a were to be another
lenght than 3, the match would fail too. The fact that a is a list
in the first place is something you need to assure by yourself, EC
simply tries to fit the uni_exp on whatever value it gets as exp.
examples of FALSE:

a <=> [1,x]		-> wrong list-len
a <=> [1,4,x]		-> 4=2 fails
'bla' <=> [1,2]		-> unpredictable result / crash ?

The fun thing with unification is that you can do very complex matches,
and that if you take the first field or so as a constant telling what the
structure is, you have a nice form of dynamic typing. And, all the time
without using PTRs!

a slightly nicer example:

[BLA,[1,'burp'],['bla',"bla"]] <=> [BLA,[1,x],y]

binds:

x='burp', y=['bla',"bla"]

or even:

IF myexp <=> [PLUS,[MUL,a,1],[SUBS,[PLUS,c,d],e]] THEN RETURN a+c+d-e

maybe a silly example, but one could imagine doing complex stuff
like this in a compiler's code-optimizer. it equals this traditional code:

IF @{"ListLen" link ListLen}(myexp)=3
  IF myexp[]=PLUS
    IF ListLen(dummy:=myexp[1])=3
      IF (dummy[]=MUL) AND (dummy[2]=1)
        a:=dummy[1]
        IF ListLen(dummy:=myexp[2])=3
          IF dummy[]=SUBS
            e:=dummy[2]
            IF ListLen(dummy2:=dummy[1])=3
              IF dummy2[]=PLUS
                c:=dummy2[1]
                d:=dummy2[2]
                @{"RETURN" link RETURN} a+c+d-e
              ENDIF
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
ENDIF

only then a bit more optimal. As you see there's a lot of expressive
power involved in unification as compared to traditional selection-based
programming.

For now, the only thing allowed in unification are @{"untyped lists" link LIST},
(integer) constants, variables and @{"LISP-Cells" link lispcells}.
The future will see this expanded with strings, typed-lists/objects,
and even expressions [!]
@endnode

@node "pointer typing"
 pointer typing (::)
---------------------
when you write an expression like 'p' where p is a PTR TO object,
this allows you to dereference it as such. The pointer typing
operator allows you to change such a type on the fly:

DEF p:PTR TO mp			-> message port

p.sigbit			-> access it
p::ln.name			-> access pointer as if it were a node

this is very useful for pointers that can point to different sorts
of things or objects that are part of each other, where of course
only one declaration is possible.

A second handy use is in OBJECTs that have members declared as LONG,
which are actually pointers. You may type it on the fly to dereference
it anyway:

mywindow.userport::mp.sigbit

here the window OBJECT has userport defined as LONG, so you wouldn't
be able to dereference it normally.
@endnode

@node JUMP
 statement labels and gotos (JUMP)
-----------------------------------
Labels are global-scoped identifiers with a ':' added to them, as in:

mylabel:

they may be used by instructions such as JUMP, and to reference
static data. They may be used to jump out of all types of loops (although
this technique is not encouraged, (See @{"EXIT" link EXIT}), but not out of
procedures. In normal E programs they are mostly used with inline assembly.
Labels are always globally visible.

Syntax: JUMP <label>

continues execution at <label>. You are not encouraged to use this
instruction, it's there for situations that would otherwise increase
the complexity of the program. Example:

IF done THEN JUMP stopnow

/* other parts of program */

stopnow:
@endnode

@node assignment
 assignment (:=)
-----------------
The basic format of an assignment is:   <var> := <exp>
Examples: a:=1,  a:=myfunc(),  a:=b*3

In E one can assign multiple variables at once, when <exp> is
a @{"function" link PROC} that returns @{"multiple returnvalues" link "multiple return values"}.
@endnode

@node FOR
 for-statement (FOR)
---------------------
FOR, TO, STEP, DO, ENDFOR

syntax:		FOR <var> := <exp> TO <exp> STEP <step> DO <statement>
or:		FOR <var> := <exp> TO <exp> STEP <step>
                  <statements>
		ENDFOR

builds a for-block, note the two general forms. <step> may be
any positive or negative constant, excluding 0, and is optional. Example:

FOR a:=1 TO 10 DO @{"WriteF" link WriteF}('\d\n',a)

The body of FOR may contain @{"EXIT" link EXIT} statements.
@endnode

@node DO
 Used with @{" FOR " link FOR},
           @{" WHILE " link WHILE},
           @{"EXCEPT" link EXCEPT}
@endnode

@node EXIT
Syntax:

  EXIT <boolexp>

Which allows you to exit the loop if boolexp is true.

Used with @{" FOR " link FOR}, @{" WHILE " link WHILE} (and @{"LOOP" link LOOP}????)
@endnode

@node WHILE
 while-statement (WHILE)
-------------------------
WHILE, DO, ENDWHILE

syntax:		WHILE <exp> DO <statement>
or:		WHILE <exp>
                  <statements>
		ENDWHILE

builds a while-loop, which is repeated as long as <exp> is TRUE. Note
the one-line/one-statement version and the multiple line version.

WHILE may also contain @{"EXIT" link EXIT} statements.
@endnode

@node REPEAT
 repeat-statement (REPEAT)
---------------------------
REPEAT, UNTIL

syntax:		REPEAT
		UNTIL <exp>

builds a repeat-until block: it will continue to loop this block until
<exp>=TRUE. Example:

REPEAT
  @{"WriteF" link WriteF}('Do you really, really wish to exit this program?\n')
  @{"ReadStr" link ReadStr}(stdout,s)
UNTIL @{"StrCmp" link StrCmp}(s,'yes please!')
@endnode

@node LOOP
 loop-statement (LOOP)
-----------------------
LOOP, ENDLOOP

syntax:		LOOP
		  <statements>
		ENDLOOP

builds an infinite loop.
@endnode

@node SELECT
 select-case-statement (SELECT)
--------------------------------
SELECT, CASE, DEFAULT, ENDSELECT

syntax:		SELECT <var>
		[ CASE <exp>
		  <statements> ]
		[ CASE <exp>
		  <statements> ]   /* any number of these blocks */
		[ DEFAULT
		  <statements> ]
		ENDSELECT

builds a select-case block. Various expressions will be matched against
the variable, and only the first matching block executed. If nothing matches,
a default block may be executed.

SELECT character
  CASE 10
    @{"WriteF" link WriteF}('Gee, I just found a linefeed\n')
  CASE 9
    WriteF('Wow, this must be a tab!\n')
  DEFAULT
    WriteF('Do you know this one: "\c" ?\n',character)
ENDSELECT

next to the old SELECT <var> which works on expressions in the CASE
statements, E has a SELECT <maxrange> OF <exp> which works with constants
and or ranges of constants in a CASE. not only is this for many applications
more powerful, it is also much faster for large numbers of cases (>5
usually), or if cases are equally probable. It assumes however, that all
CASEs lie within a small integer range from 0 TO n-1, where n is something
reasonable, for example 10, or 255 for characters.

example:

SELECT 127 OF FgetC(stream)
  CASE "\n","\b"
    WriteF('line ending\n')
  CASE "\t"," "
    WriteF('whitepace\n')
  CASE "0" TO "9"
    WriteF('Integer\n')
  CASE "A" TO "Z", "a" TO "z", "_"
    WriteF('Identifier\n')
  DEFAULT
    WriteF('some other character\n')
ENDSELECT

DEFAULT will be hit not only for those for which there is no CASE,
but also for the chars that fall out of the range, i.e. 128 TO 255
(and >255, and <0).
note that speed costs: because this SELECT uses a jump-table
to quickly get at the right CASE, it'll use 2*<maxrange> bytes,
256 in this case.
@endnode

@node INC
Syntax: INC <var>

short for <var>:=<var>+1. Only difference with var@{"++" link ++} is that those is a
statement, and do not return a value.
@endnode

@node DEC
Syntax: DEC <var>

short for <var>:=<var>-1. Only difference with var@{"--" link --} is that those is a
statement, and do not return a value.
@endnode

@node VOID
Syntax: VOID <exp>

calculates the expression without the result going anywhere. Only useful
for a clearer syntax, as expressions may be used as statements without
VOID in E anyway. This may cause subtle bugs though, as "a:=1" assigns
a the value 1, but "a=1" as a statement will do nothing. E will give you
a warning if this happens.
@endnode

@node END
 memory deallocation (END)
---------------------------
END is the complement to @{"NEW" link NEW}. any pointer obtained should be
deallocated (and only!) with END

	END a

or even

	END a,b,c

where the arguments are PTRs to some type. END frees the amount of space
that is being pointed to, so if a is PTR TO LONG it will only free 4
bytes. so if you allocated a with NEW a[NUM], free it with

	END a[NUM]

NIL-pointers may safely be passed to NEW. Pointers are also
nuked to NIL afterwards.
If a is a PTR to an object that is an instance of a class, END
will dynamically get the size to be freed from the class-object,
so if you have an object of class b which is 32 bytes, but the
pointer you're freeing with is a baseclass pointer (only 24
bytes), END will correctly deallocate 32 bytes. this only works
for classes.

You can imagine END p as a macro for:

	IF p
	  p.end()
	  @{"FastDispose" link FastDispose}(p,p.classobject.virtuallen)
	  p:=NIL
	ENDIF

note that the
  @{"NEW" link NEW} and END make use of the @{"FastNew()" link FastNew} and @{"FastDispose()" link FastDispose}
functions (described elsewhere) which work quite differently from
  @{"NewR()" link NewR} and @{"Dispose()" link Dispose}.
@endnode

@node PROC
 proc definition and arguments (PROC)
--------------------------------------

You may use PROC and ENDPROC to collect statements into your own functions.
Such a function may have any number of arguments, and several return values.

PROC, ENDPROC

Syntax:		PROC <label> ( <args> , ... )
		ENDPROC <returnvalue>, ...

defines a procedure with any number of arguments. Arguments are of type @{"LONG" link LONG}
or optionally of type @{"PTR TO <type>" link PTR} and need no further declaration. The end
of a procedure is designated by ENDPROC. If no return value is given, 0 is
returned. Example: write a function that returns the sum of two arguments:

PROC add(x,y)         /* x and y are local variables */
ENDPROC x+y           /* return the result  */

a short version:

PROC add(x,y) IS x+y

See also @{" default arguments " link "default arguments"},
         @{" multiple return values " link "multiple return values"},
         @{" function values " link "function values"}
@endnode

@node RETURN
 RETURN, ENDPROC
-----------------
As stated before, ENDPROC marks the end of a function definition, and may
return a value. Optionally RETURN may be used at any point in the function
to exit, if used in main(), it will exit the program. (See @{"CleanUp" link CleanUp}()).

RETURN [<returnvalue>]          /* optional */

Example:

@{"PROC" link PROC} getresources()
  /* ... */
  IF error THEN RETURN FALSE  /* something went wrong, so exit and fail */
  /* ... */
ENDPROC TRUE   /* we got this far, so return TRUE */

a very short version of a function definition is:

PROC <label> ( <arg> , ... ) RETURN <exp>

(or @{"IS" link PROC} instead of "RETURN")
These are function definitions that only make small computations, like
faculty functions and the like:  (one-liners :-)

PROC fac(n) IS IF n=1 THEN 1 ELSE fac(n-1)*n

See also @{"multiple return values" link "multiple return values"}
@endnode

@node ENDPROC
 See @{" PROC " link PROC} and @{" RETURN " link RETURN}
@endnode

@node DEF
 local and global definitions: scope (DEF)
-------------------------------------------
You may define additional local variables besides those which are
arguments with the DEF statement. The easiest way is simply like:

DEF a,b,c

declares the identifiers a, b and c as variables of your function.
Note that such declarations should be at the start of your function.

DEF

Syntax:		DEF <declarations>,...

declares variables. A declaration has one of the forms:

		<var>
		<var>:<type>              where <type>=@{"LONG" link LONG},<objectident>,...
		<var>[<size>]:<type>      where <type>=@{"ARRAY" link ARRAY},@{"STRING" link STRING},@{"LIST" link LIST}

For now, we'll use the <var> form.
Arguments to functions are restricted to basic types.
A declaration of a basic type can have an initialisation, in the current
version this must be an integer (not an expression):

DEF a=1,b=2

A program consists of a set of functions, called procedures, @{"PROCs" link PROC}. Each
procedure may have Local variables, and the program as a whole may have
Global variables. At least one procedure should be the PROC main(), as
this is the module where execution begins. A simple program could look like:

DEF a, b                            /* definition of global vars */

PROC main()                         /* all functions in random order */
  bla(1)
ENDPROC

PROC bla(x)
  DEF y,z                           /* possibly with own local vars */
ENDPROC

To summarize, local definitions are the ones you make at the start of
procedures, and which are only visible within that function. Global
definitions are made before the first PROC, at the start of your
source code, and they are globally visible. Global and local variables
(and of course local variables of two different functions) may have the
same name, local variables always have priority.
@endnode

@node systemvars
 built-in system variables
---------------------------
Following global variables are always available in you program,
they're called system variables.

arg		As discussed above, contains a pointer to a zero-terminated
		string, containing the command-line arguments. Don't use this
		variable if you wish to use ReadArgs() instead.
stdout		Contains a file-handle to the standard output (and input).
		If your program was started from the workbench, so no
		shell-output is available, @{"WriteF" link WriteF} will open a
		CON: window for you and put its file handle here.
stdin		file-handle of standard input
conout		This is where that file handle is kept, and the console
		window will be automatically closed upon exit of your
		program. @{"WriteF" link WriteF}, on how to use these two variables
		properly).
execbase,	These four variables are always provided with their
dosbase,	correct values.
gfxbase,
intuitionbase
stdrast		Pointer to standard rastport in use with your program,
		or NIL. The built-in graphics functions like @{"Line" link Line}
		make use of this variable.
wbmessage	Contains a ptr to a message you got if you started
		from wb, else NIL. May be used as a boolean to detect
		if you started from workbench, or even check any
		arguments that were shift-selected with your icon.
		See WbArgs.e in the Src/Args dir how to
		make good use of wbmessage.
@endnode

@node "default arguments"
 default arguments to functions
--------------------------------

default arguments allows you to specify for one or more
arguments of a procedure which is the default value, if the
procedure is called with less args than parameters. for example,
a procedure like:

@{"PROC" link PROC} bla(a,b=1,c=NIL)

can be called like:			is equivalent with:

bla(a,b,c)				bla(a,b,c)
bla(a,b)				bla(a,b,NIL)
bla(a)					bla(a,1,NIL)

This can be useful and also express something about the
procedures function, i.e. that most of the time one would
call it with NIL anyway, so why not leave it out for clarity.
That's also why you should not overdo it with D.A.: do not
start specifying non-sensical values for procedures
out of pure laziness, if you feel a certain parameter really
has no default value.

to make calls with fewer args unambiguous, D.A. declarations
can only apply to the last 0..n parameters of a PROC of n parameters.

for example, illegal is:  PROC bla(a,b=1,c)

(you should then simply reorder the parameters, of course).
arguments supplied in a call are filled in from left to right,
missing arguments are added with D.A.'s as needed.
@endnode

@node "multiple return values"
 multiple return values
------------------------
In E you can return any number of return values (max 3 in
Amiga E because of implementation reasons). How?

@{"RETURN" link RETURN} <exp>,<exp>,<exp>                 (or @{"ENDPROC" link ENDPROC}, of course)

example:

PROC sincos(rad)
  DEF sin,cos
  /* whatever computation is needed */
ENDPROC sin,cos

call with:

s,c:=sincos(3.14)
s:=sincos(1.00)

as you can see, there's a new statement of the form:

<var> , ... := <exp>

where <exp> makes mostly only sense as function call.
note two things:
- you can decide yourself how many values you wish to receive.
  this makes sense when the first retval is the main one,
  and the second/third optional infos, which might only be
  important to some callers.
- this form is a _statement_. this means that when you would
  call sincos() as part of another expression, only the
  first (the regular) return value is used:   fun(sincos(1.0))
@endnode

@node "function values"
 function values
-----------------
With v3, you can also have functions as values, and pass these
freely around. they're different from quoted expression, since
they're called just like normal @{"PROCs" link PROC}. example:

fun:={myproc}			-> get PROC ptr

...

fun(1,2,3)			-> apply to args, just like normal PROC

notes:
- you have to be sure that the PROC you have a ptr to and the
  number of args are the same. the compiler can't check this for you.
- even worse: you have to be sure the ptr is a PROC at all.
  there is a compiler warning that may help you with this.
@endnode

@node unary
Syntax: {<var>}

Returns the address of a variable or label. This is the operator
you would use to give a variable as argument to a function by
reference, instead of by value, which is default in E.
Example:  @{"Val" link Val}(input,{x})

See @{"^ (counterpart)" link ^},
    @{"function values" link "function values"}
@endnode

@node ++
Syntax: <varexp>++

Increases the pointer that is denoted by <varexp> by the size of the data it
points to. This has the effect that that pointer points to the next or
previous item. When used on variables that are not pointers, these will simply
be changed by one. Note that ++ always takes effect _after_ the calculation
of <varexp>. Example:

  a++          /* return value of a, then increase by one */

  See @{"INC" link INC}, @{"--" link --}, @{"DEC" link DEC}
@endnode

@node --
Syntax: <varexp>--

Decreases the pointer that is denoted by <varexp> by the size of the data it
points to. This has the effect that that pointer points to the next or
previous item. When used on variables that are not pointers, these will simply
be changed by one. Note that -- always takes effect _before_ the calculation
  of <varexp>. Example:

  sp[]--       /* decrease pointer sp by 4 (if it were an array of long),
                  and read value pointed at by sp */

  See @{"DEC" link DEC}, @{"++" link ++}, @{"INC" link INC}
@endnode

@node {
 See @{" function values " link "function values"},
     @{" unary " link unary}
@endnode

@node }
 See @{" function values " link "function values"},
     @{" unary " link unary}
@endnode

@node ^
Syntax: ^<var>

The counterpart of @{"{}" link unary}, writes or reads variables that were given by
reference, examples:      ^a:=1     b:=^a
it may also be used to plainly "peek" or "poke" @{"LONG" link LONG} values from
memory, if <var> is pointer to such a value.
Example for @{"{}" link unary} and ^: write your own assignment function;

  @{"PROC" link PROC} set(var,exp)
    ^var:=exp
  ENDPROC

  and call it with:     set({a},1)     /* equals a:=1 */
@endnode


@node CONST
Syntax: CONST <declarations>,...

Enables you to declare a constant. A declaration looks like:
<ident>=<value>
constants must be uppercase, and will in the rest of the program be
treated as <value>. Example:

CONST MAX_LINES=100, ER_NOMEM=1, ER_NOFILE=2

You cannot declare constants in terms of others that are being
declared in the same CONST statement: put these in the next.

CONST, @{"ENUM" link ENUM} and @{"SET" link SET} declarations are always global, i.e. it is not
possible to declare constants local to a PROC. The best place for
constant declarations is at the top of your source, but EC also
allows you to put them between two PROCs, for example.
@endnode

@node ENUM
 enumerations (ENUM)
-----------------------
Enumerations are a specific type of @{"constant" link CONST} that need not be given values,
as they simply range from 0 .. n, the first being 0. At any given point
in an enumeration, you may use the '=<value>' notation to set or reset
the counter value. Example:

ENUM ZERO, ONE, TWO, THREE, MONDAY=1, TUESDAY, WEDNESDAY

ENUM ER_NOFILE=100, ER_NOMEM, ER_NOWINDOW

See @{"CONST" link CONST}, @{"SET" link SET}
@endnode

@node SET
 sets (SET)
------------
Sets are again like @{"enumerations" link ENUM}, with the difference that instead of
increasing a value (0,1,2,...) they increase a bitnumber (0,1,2,...) and
thus have values like (1,2,4,8,...). This has the added advantage that
they may be used as sets of flags, as the keyword says.
Suppose a set like the one below to describe properties of a window:

SET SIZEGAD,CLOSEGAD,SCROLLBAR,DEPTH

to initialise a variable to properties DEPTH and SIZEGAD:

winflags:=DEPTH @{"OR" link OR} SIZEGAD

to set an additional SCROLLBAR flag:

winflags:=winflags OR SCROLLBAR

and to test if either of both of two properties hold:

IF winflags @{"AND" link AND} (SCROLLBAR OR DEPTH) THEN /* whatever */

See @{"CONST" link CONST}, @{"ENUM" link ENUM}
@endnode

@node "built-in constants"
 built-in constants
--------------------
Following are built-in @{"constants" link CONST} that may be used:

TRUE,FALSE	Represent the boolean values (-1,0)
NIL		(=0), the uninitialised pointer.
ALL		Used with string functions like StrCopy() to copy all characters
GADGETSIZE	Minimum size in bytes to hold one gadget; See @{"Gadget" link Gadget}
OLDFILE,NEWFILE	Mode-parameters for use with Open()
EMPTY		used with @{"methods" link "OO features"} (might be keyword in the future)
STRLEN		Always has the value of the length of the last immediate
		string used. Example:

		@{"WriteF" link WriteF}(handle,'hi folks!',STRLEN)      /* =9 */
@endnode

@node StrLen
Syntax: len:=StrLen(string)

calculates the length of any zero-terminated string


Also a constant exists :
  STRLEN - See @{" built-in constants " link "built-in constants" 11}

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}
@endnode

@node LONG
 the basic type (LONG)
-----------------------
There's only one basic, non-complex variable type in E, which is the
32bit type LONG. As this is the default type, it may be declared as:

DEF a:LONG             or just:            DEF a

This variable type may hold what's known as @{"CHAR" link CHAR}/@{"INT" link INT}/@{"PTR" link PTR}/LONG types in other
languages.

See @{"Long()" link Long_proc}

 using binary data
-------------------
 See @{"INCBIN" link INCBIN 13}
@endnode

@node Long_proc
Syntax: a:=Long(adr)

peeks into memory at some address, and returns the value found (@{"LONG" link LONG}). This
works with 32bit respectively. Note that the compiler does not check if 'adr'
is valid. These functions are available in E for those cases where reading
and writing in memory with @{"PTR TO <type>" link PTR} would only make a program more
complex or less efficient. You are _not_ encouraged to use these functions.

See @{"PutLong" link PutLong},
    @{"Char" link Char}, @{"Int" link Int}
@endnode    

@node PTR
 the basic type (PTR)
---------------------- 
A special variation of @{" LONG " link LONG} is the PTR type. This type
is compatible with LONG, with the only difference that it specifies
to what type it is a pointer. By default, the type LONG is specified
as PTR TO CHAR. Syntax:

DEF <var>:PTR TO <type>

where type is either a simple type or a compound type. Example:

DEF x:PTR TO INT, myscreen:PTR TO screen

Note that 'screen' is the name of an object as defined in intuition/screens.m
For example, if you open your own screen with:

myscreen:=@{"OpenS" link OpenS}(...   etc.

you may use the pointer myscreen as in 'myscreen.rastport'. However,
if you do not wish to do anything with the variable until you call
CloseS(myscreen), you may simply declare it as

DEF myscreen

Variable declarations may have optional initialisations, but only
integer constants, i.e. no full expression:

DEF a=1, b=NIL:PTR TO textfont
@endnode

@node CHAR
 the simple type (CHAR)
------------------------
The simple type CHAR (8bit) may not be used as type for a basic (single)
variable; the reason for this must be clear by now.
However they may be used as data type to build @{"ARRAYs" link ARRAY} from, set @{"PTRs" link PTR} to,
use in the definition of @{"OBJECTs" link OBJECT} etc. See those for examples.

See @{"Char()" link Char_proc}

 using binary data
-------------------
 See @{"INCBIN" link INCBIN 13}
@endnode

@node Char_proc
Syntax: a:=Char(adr)

peeks into memory at some address, and returns the value found (@{"CHAR" link CHAR}). This
works with 8bit respectively. Note that the compiler does not check if 'adr'
is valid. These functions are available in E for those cases where reading
and writing in memory with PTR TO <type> would only make a program more
complex or less efficient. You are _not_ encouraged to use these functions.

See @{"PutChar" link PutChar},
    @{"Long" link Long}, @{"Int" link Int}
@endnode

@node INT
 the simple type (INT)
-----------------------
The simple type INT (16bit) may not be used as type for a basic (single)
variable; the reason for this must be clear by now.
However they may be used as data type to build @{"ARRAYs" link ARRAY} from, set @{"PTRs" link PTR} to,
use in the definition of @{"OBJECTs" link OBJECT} etc. See those for examples.

See @{"Int()" link Int_proc}

 using binary data
-------------------
 See @{"INCBIN" link INCBIN 13}
@endnode

@node Int_proc
Syntax: a:=Int(adr)

peeks into memory at some address, and returns the value found (@{"INT" link Int_proc}). This
works with 16bit respectively. Note that the compiler does not check if 'adr'
is valid. These functions are available in E for those cases where reading
and writing in memory with PTR TO <type> would only make a program more
complex or less efficient. You are _not_ encouraged to use these functions.

See @{"PutInt" link PutInt},
    @{"Char" link Char}, @{"Long" link Long}
@endnode

@node initialisation
 initialisation
----------------
1. Always initialised to NIL (or else, if explicitly stated)
   - global variables
     NOTE: for documentation purposes, it's always nicer if you
     write =NIL in the definitions of variables that you expect to be NIL.
2. Initialised to '' and [] resp.
   - global and local STRINGs
   - global and local LISTs
3. Not initialised
   - local variables (unless explicitly stated)
   - global and local ARRAYs
   - global and local OBJECTs
@endnode

@node WriteF
 io functions (WriteF/@{"PrintF" link PrintF})
-------------------------------

	WriteF(formatstring,args,...)
	PrintF(formatstring,args,...)

prints a string (which may contain formatting codes) to stdout. Zero
to unlimited arguments may be added. Note that, as formatstrings may
be created dynamically, no check on the correct number of arguments
is (can be) made. Examples:

WriteF('Hello, World!\n')	/* just write a lf terminated string */

WriteF('a = \d \n',a)		/* writes: "a = 123", if a was 123 */

(see @{"STRING" link STRING} about strings for more).
NOTE: if @{"stdout" link systemvars}=NIL, for example if your program was started from the
Workbench, WriteF() will create an output window, and put the handle
in conout and stdout. This window will automatically be closed on
exit of the program, after the user typed a <return>. WriteF() is the
only function that will open this window, so if you want to do IO
on stdout, and want to be sure @{"stdout" link systemvars}<>NIL, perform a "WriteF('')"
as first instruction of your program to ensure output. If you want
to open a console window yourself, you may do so by placing the resulting
file handle in the @{"stdout" link systemvars} and @{"conout" link systemvars} variables, as your window will
then be closed automatically upon exit. If you wish to close this window
manually, make sure to set @{"conout" link systemvars} back to NIL, to signal E that there's
no console window to be closed.
Return the length of the string that was printed.

See also @{"TextF" link TextF}
@endnode

@node PrintF
Syntax: PrintF(formatstring,args,...)

PrintF() is the same as @{"WriteF" link WriteF} only uses the v37+ buffered IO.
Return the length of the string that was printed.
@endnode

@node Out
Syntax: Out(filehandle,char)

Write one single byte to some file or @{"stdout" link systemvars}.
Returns the number of bytes actually written (<>1 is error)

See @{"Inp" link Inp}
@endnode

@node Inp
Syntax: char:=Inp(filehandle)

Read one single byte from some file or @{"stdout" link systemvars}.
If char=-1 then an EOF was reached, or an error occured.
Returns the number of bytes actually read (<>1 is error)

See @{"Out" link Out}
@endnode

@node FileLength
Syntax: len:=FileLength(namestring)

lets you determine the length of a file you *may* wish to load, and
also, if it exists (returns -1 upon error/file not found).
@endnode

@node SetStdOut
Syntax: oldout:=SetStdOut(newstdout)

Sets the standard output variable @{"stdout" link systemvars}. Equivalent for:
oldout:=stdout; stdout:=newstdout.

See @{"SetStdIn" link SetStdIn}
@endnode

@node SetStdIn
Syntax: oldin:=SetStdIn(newstdin)

Sets the standard input variable @{"stdin" link systemvars}. Equivalent for:
oldin:=stdin; stdin:=newstdin.

See @{"SetStdOut" link SetStdOut}
@endnode

@node StrCmp
Syntax: bool:=StrCmp(string,string,len=ALL)

compares two strings. len must be the number of bytes to compare,
or 'ALL' if the full length is to be compared. Returns TRUE or FALSE

See @{"Strings" link String},
    @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node StrCopy
Syntax: StrCopy(estring,string,len=ALL)

copies the string into the estring. If len=ALL, all will be copied.
returns the estring.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node StrAdd
Syntax: StrAdd(estring,string,len=ALL)

same as @{"StrCopy" link StrCopy}, only now the string is concatenated to the end.
returns the estring.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node EstrLen
Syntax: len:=EstrLen(estring)

returns the length of an estring

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node StrMax
Syntax: max:=StrMax(estring)

returns the maximum length of a estring

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node StringF
Syntax: StringF(estring,fmtstring,args,...)

similar to @{"WriteF" link WriteF}, only now output goes to estring instead of @{"stdout" link systemvars}.
example:

StringF(s,'result: \d\n',123)

's' will be 'result: 123\n'
returns the estring, and length as second returnvalue.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node RightStr
Syntax: RightStr(estring,estring,n)

fills estring with the last n characters of the second estring
returns the estring.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node MidStr
Syntax: MidStr(estring,string,pos,len=ALL)

copies any number of characters (including all if len=ALL) from
position pos in string to estring
NOTEZ BIEN: in all string related functions where a position in a
string is used, the first character in a string has position 0,
not 1, as is common in languages like BASIC.
returns the estring.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node Val
Syntax: value,read:=Val(string,read=NIL)

finds an integer encoded in ascii out of a string. Leading spaces/tabs
etc. will be skipped, and also hexadecimal numbers (1234567890ABCDEFabcdef)
and binary numbers (01) may be read this way if they are preceded by a
"$" or a "%" sign respectively. A minus "-" may indicate a negative integer.
Val() returns the number of characters read in the second argument, which
must be given by reference (<-!!!), or can be received as second returnvalue.
If "read" returns 0 (value will be 0 too) then the string did not contain an
integer, or the value was too sizy to fit in 32bit. "read" may be NIL.

examples of strings that would be parsed correctly:
'-12345', '%10101010', '   -$ABcd12'

these would return both as "value" and in read a 0:
'', 'hello!'

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node InStr
Syntax: foundpos:=InStr(string1,string2,startpos=0)

searches string1 for the occurrence of string2, possibly starting from
another position than 0. Returned is the offset at which the substring
was found, else -1.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node TrimStr
Syntax: newstringadr:=TrimStr(string)

returns the *address* of the first character in a string, i.e., after
leading spaces, tabs etc.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node UpperStr
Syntax: UpperStr(string)

changes the case of a string.
TAKE NOTE: those functions modify the contents of 'string', so it may
only be used on estrings, and strings that are part of your programs data.
Effectively this means that if you obtain the address of a string through
some amiga-system function, you must first @{"StrCopy" link StrCopy} it to a string of
your program, then use those function.
Return the string.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node LowerStr
Syntax: LowerStr(string)

changes the case of a string.
TAKE NOTE: those functions modify the contents of 'string', so it may
only be used on estrings, and strings that are part of your programs data.
Effectively this means that if you obtain the address of a string through
some amiga-system function, you must first @{"StrCopy" link StrCopy} it to a string of
your program, then use those function.
Return the string.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node ReadStr
Syntax: ok:=ReadStr(filehandle,estring)

will read a string (ending in ascii 10) from any file or stdout.
ok contains -1 if an error occurred, or an EOF was reached.
Note: the contents of the string read so far is still valid.
Also note that, like @{"Inp" link Inp} @{"Out" link Out}, etc. this function makes use
of unbuffered 1.3 style IO, and thus may be slow. The dos.library
Fgets() function forms a nice alternative.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node SetStr
Syntax: SetStr(estring,newlen)

manually sets the length of a string. This is only handy when you read
data into the estring by a function other then an E string function,
and want to continue using it as an Estring. For example, after
using a function that just puts a zero-terminated string at the
address of estring, use   SetStr(mystr,@{"StrLen" link StrLen}(mystr))  to make
it manipulatable again. If the string is too long, SetStr does nothing
(this should always be prevented).

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"AstrCopy" link AstrCopy}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node AstrCopy
Syntax: AstrCopy(string1,string2,size)

'Array String Copy' copies string2 into the memory area denoted by string1.
string1 is typically not an estring but an @{"ARRAY" link ARRAY}. size is the total #of chars
string1 can hold, i.e. if you write 5 and string2='helloworld', string1 will
be 'hell' + 0termination.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"OstrCmp" link OstrCmp}, @{"StrLen" link StrLen}
@endnode

@node OstrCmp
Syntax: order:=OstrCmp(string1,string2,max=ALL)

'Ordered String Compare' returns 1 if string2>string1, 0 for equal and -1
for less. only max chars are compared.

See @{"Strings" link String},
    @{"StrCmp" link StrCmp}, @{"StrCopy" link StrCopy}, @{"StrAdd" link StrAdd}, @{"EstrLen" link EstrLen}, @{"StrMax" link StrMax}, @{"StringF" link StringF},
    @{"RightStr" link RightStr}, @{"MidStr" link MidStr}, @{"Val" link Val}, @{"InStr" link InStr}, @{"TrimStr" link TrimStr}, @{"UpperStr" link UpperStr}, @{"LowerStr" link LowerStr},
    @{"ReadStr" link ReadStr}, @{"SetStr" link SetStr}, @{"AstrCopy" link AstrCopy}, @{"StrLen" link StrLen}
@endnode

@node ListCopy
Syntax: ListCopy(listvar,list,num=ALL)

Copies num elements from list to listvar. example:
DEF mylist[10]:LIST
ListCopy(mylist,[1,2,3,4,5],ALL)
returns listvar.

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
@endnode

@node ListAdd
Syntax: ListAdd(listvar,list,num=ALL)

Copies num items of list to the tail of listvar.
returns listvar.

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
@endnode

@node ListCmp
Syntax: ListCmp(list,list,num=ALL)

Compares two lists, or some part of them.

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
@endnode

@node ListLen
Syntax: len:=ListLen(list)

Returns length of list, like     ListLen([a,b,c])    would return 3

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
@endnode

@node ListMax
Syntax: max:=ListMax(listvar)

returns maximum possible length of a listvar.

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListItem" link ListItem}, @{"SetList" link SetList}
@endnode

@node ListItem
Syntax: value:=ListItem(list,index)

functions as    value:=list[index]    with the difference that
list may also be a constant value instead of a pointer. This is
very useful in situations like this where we directly want to
use a list of values:

@{"WriteF" link WriteF}(ListItem(['ok!','no mem!','no file!'],error))

this prints an errormessage according to "error". it's similar to:

DEF dummy:PTR TO LONG
dummy:=['ok!','no mem!','no file!']
WriteF(dummy[error])

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"SetList" link SetList}
@endnode

@node SetList
Syntax: SetList(listvar,newlen)

manually sets the length of a list. This will only be useful when you read
data into the list by a function other then a list-specific function,
and want to continue using it as a true list.

See @{"LISTs" link LIST}, @{"List()" link List_proc},
    @{"ListCopy" link ListCopy}, @{"ListAdd" link ListAdd}, @{"ListCmp" link ListCmp}, @{"ListLen" link ListLen}, @{"ListMax" link ListMax}, @{"ListItem" link ListItem}
@endnode

@node OpenW
Syntax: wptr:=OpenW(x,y,width,height,IDCMP,wflags,title,
                    screen,sflags,gadgets,taglist=NIL)

creates a window where wflags are flags for window layout
(like BACKDROP, SIMPLEREFRESH e.d, usually $F) and sflags are
for specifying the type of screen to open on (1=wb,15=custom).
screen must only be valid if sflags=15, else NIL will do.
gadgets may point to a glist structure, which you can easily
create with the Gadget() function, else NIL.

Windows opened with OpenW should be closed with @{"CloseW" link CloseW}.
@endnode

@node CloseW
Syntax: CloseW(wptr)

closes the window opened with @{"OpenW" link OpenW}. Only difference from CloseWindow()
is that it accepts NIL-pointers and sets @{"stdrast" link systemvars} back to NIL.
@endnode

@node OpenS
Syntax: sptr:=OpenS(width,height,depth,sflags,title,taglist=NIL)

opens a custom screen for you. depth is number of bitplanes (1-6, 1-8 AGA).

See @{"CloseS()" link CloseS}
@endnode

@node CloseS
Syntax: CloseS(sptr)

as @{"CloseW()" link CloseW}, now for screens opened with @{"OpenS()" link OpenS}.
@endnode

@node Gadget
Syntax: nextbuffer:=Gadget(buffer,glist,id,flags,x,y,width,string)

[warning: this function is a bit out of date]
This function creates a list of gadgets, which can then be put in your
window by giving them as an argument to @{"OpenW" link OpenW}(), or afterwards with
intuition functions like AddGlist().
buffer is mostly an ARRAY of at least @{"GADGETSIZE" link "built-in constants"} bytes to hold all the
structures associated with one gadget, id is any number that may help you
remember which gadget was pressed when an IntuiMessage arrives.
Flags are: 0=normal gadget, 1=boolean gadget, 3=boolean gadget that is
selected. Width is width in pixels, that should be large enough to hold
the string, which will be auto-centered. glist should be NIL for the first
gadget, and glistvar for all others, so E may link all gadgets.
The function returns a pointer to the next buffer (=buffer+GADGETSIZE).
Example for three gadgets:

CONST MAXGADGETS=GADGETSIZE*3

DEF buf[MAXGADGETS]:ARRAY, next, wptr

next:=Gadget(buf,NIL,1,0,10,20,80,'bla')   /* the 1st gadget */
next:=Gadget(next,buf,... )
next:=Gadget(next,buf,... )                /* any amount linked 2 1st */

wptr:=@{"OpenW" link OpenW}( ...,buf)
@endnode

@node Mouse
Syntax: code:=Mouse()

gives you the current state of all 2 or 3 mouse buttons; left=1,
right=2 and middle=4. If for example code=3 then left and right were
pressed together.
NOTEZ BIEN: this is not a real intuition function, if you want to
know about mouse-events the proper way, you'll have to check the
intuimessages that your window receives. This is the only E
function that directly checks the hardware, and thus only useful
in demo-like programs and for testing. (DO NOT USE THIS FUNCTION
IN PROGRAMS THAT ARE SUPPOSED TO WORK UNDER THE OS)

See @{"LeftMouse" link LeftMouse}, @{"WaitLeftMouse" link WaitLeftMouse}
@endnode

@node LeftMouse
Syntax: bool:=LeftMouse(win)

intuition @{"Mouse" link Mouse}() alternatives for programs that only want to test for
a mouseclick.

See @{"WaitLeftMouse" link WaitLeftMouse}
@endnode

@node WaitLeftMouse
Syntax: WaitLeftMouse(win)

intuition @{"Mouse" link Mouse}() alternatives for programs that only want to test for
a mouseclick.

See @{"LeftMouse" link LeftMouse}
@endnode

@node MouseX
Syntax: x:=MouseX(win)

enables you to read the mouse coordinates(X). win is the window
they need to be relative to.

See @{"MouseY" link MouseY}
@endnode

@node MouseY
Syntax: y:=MouseY(win)

enables you to read the mouse coordinates(Y). win is the window
they need to be relative to.

See @{"MouseX" link MouseX}
@endnode

@node WaitIMessage
Syntax: class:=WaitIMessage(window)

This function makes it easier to just wait for a window event. It simply
waits until a intuimessage arrives, and returns the class of the event.
It stores other variables like code and qualifiers as private global
variables, for access with functions described below.
WaitIMessage() represents the following code:

@{"PROC" link PROC} waitimessage(win:PTR TO window)
  @{"DEF" link DEF} port,mes:@{"PTR TO" link PTR} intuimessage,class,code,qual,iaddr
  port:=win.userport
  @{"IF" link IF} (mes:=GetMsg(port))=NIL
    @{"REPEAT" link REPEAT}
      WaitPort(port)
    UNTIL (mes:=GetMsg(port))<>NIL
  ENDIF
  class:=mes.class
  code:=mes.code             /* stored internally */
  qual:=mes.qualifier
  iaddr:=mes.iaddress
  ReplyMsg(mes)
ENDPROC class

as you see, it gets exactly one message, and does not forget about
multiple messages arriving in one event, if called more than once.
For example, say you opened a window that displays something and just
waits for a closegadget (you specified IDCMP_CLOSEWINDOW only):

WaitIMessage(mywindow)

or, you have a program that waits for more types of events, handles
them in a loop, and ends on a closewindow event:

@{"WHILE" link WHILE} (class:=WaitIMessage(win))<>IDCMP_CLOSEWINDOW
  /* handle other classes */
ENDWHILE

See @{"MsgCode" link MsgCode}, @{"MsgQualifier" link MsgQualifier}, @{"MsgIaddr" link MsgIaddr}
@endnode

@node MsgCode
Syntax: code:=MsgCode()

Supply you with the private global variables as mentioned before.
the values returned are all defined by the most recent call
to @{"WaitIMessage" link WaitIMessage}. Example:

IF class:=IDCMP_GADGETUP
  mygadget:=MsgIaddr()
  IF mygadget.userdata=1 THEN  /* ... user pressed gadget #1 */
ENDIF

See @{"WaitIMessage" link WaitIMessage}, @{"MsgQualifier" link MsgQualifier}, @{"MsgIaddr" link MsgIaddr}
@endnode

@node MsgQualifier
Syntax: qual:=MsgQualifier()

See @{"WaitIMessage" link WaitIMessage}, @{"MsgCode" link MsgCode}, @{"MsgIaddr" link MsgIaddr}
@endnode

@node MsgIaddr
Syntax: iaddr:=MsgIaddr()

See @{"WaitIMessage" link WaitIMessage}, @{"MsgCode" link MsgCode}, @{"MsgQualifier" link MsgQualifier}
@endnode

@node graphfuncs
 graphics support functions
----------------------------
All graphics support functions that do not explicitly ask for a rastport,
make use of the system-variable 'stdrast'. It is automatically defined by
the last call to @{"OpenW" link OpenW} or @{"OpenS" link OpenS}, and is set to NIL by @{"CloseW" link CloseW} and
@{"CloseS" link CloseS}. Calling these routines while stdrast is still NIL is legal.
@{"stdrast" link systemvars} may be manually set by @{"SetStdRast" link SetStdRast} or @{"stdrast" link systemvars}:=myrast

See @{"Plot" link Plot}, @{"Line" link Line}, @{"Box" link Box}, @{"Colour" link Colour}, @{"TextF" link TextF}, @{"SetStdRast" link SetStdRast}, @{"SetTopaz" link SetTopaz}, @{"SetColour" link SetColour}
@endnode

@node Plot
Syntax: Plot(x,y,colour=1)

Draws a single dot on your screen/window in one of the colours available.
colour ranges from 0-255, or 0-31 on pre-AGA machines.

See @{"graphics support functions" link graphfucs}
@endnode

@node Line
Syntax: Line(x1,y1,x2,y2,colour=1)

Draws a line

See @{"graphics support functions" link graphfucs}
@endnode

@node Box
Syntax: Box(x1,y1,x2,y2,colour=1)

Draws a box

See @{"graphics support functions" link graphfucs}
@endnode

@node Colour
Syntax: Colour(foreground,background=0)

sets the colours for all graphics functions (from the library) that
do not take a colour as argument. This is the colour *register*
(i.e 0-31) and not colour *value*
NOTE: functions that have "colour" as an argument, change the Apen
of stdrast.

See @{"graphics support functions" link graphfucs}
@endnode

@node TextF
Syntax: TextF(x,y,formatstring,args,...)

exactly the same function as @{"WriteF" link WriteF}(), only outputs to some (x,y) on
your @{"stdrast" link systemvars}, instead of @{"stdout" link systemvars}.
returns the length of the resulting string.

See @{"graphics support functions" link graphfucs}
@endnode

@node SetStdRast
Syntax: oldrast:=SetStdRast(newrast)

changes the output rastport of the E graphics functions

See @{"graphics support functions" link graphfucs}
@endnode

@node SetTopaz
Syntax: SetTopaz(size=8)

lets you set the font of the rastport @{"stdrast" link systemvars} to topaz, just to be sure
that some custom system font of the user won't screw up your window layout.
size is of course 8 or 9. Only to be used as last resort if you can't
support font-sensitivity.

See @{"graphics support functions" link graphfucs}
@endnode

@node SetColour
Syntax: SetColour(screen,colourreg,r,g,b)

set colour register (0..255) of screen to certain RGB values.
each rgb value has a range of 0..255, i.e. 24bit colour. this
function will automatically rescale to 12bit colour if no AGA
is present, and also use the correct function.

See @{"graphics support functions" link graphfucs}
@endnode

@node KickVersion
Syntax: bool:=KickVersion(vers)

Will give TRUE if the kickstart in the machine your program is running
on is equal or higher than vers, else FALSE
@endnode

@node NewR
Syntax: mem:=NewR(n)

same as @{"New()" link New_proc}, only now automatically raises the "MEM" exception
instead of return if no memory could be allocated.

See @{"NewM()" link NewM}, @{"Dispose()" link Dispose}, @{"FastNew()" link FastNew}, @{"FastDispose()" link FastDispose}, @{"FastDisposeList()" link FastDisposeList}, @{"END" link END},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node NewM
Syntax: mem:=NewM(n,flags)

same as @{"NewR()" link NewR}, but also allows you to specify flags (MEMF_CHIP etc.)

See @{"New()" link New}, @{"Dispose()" link Dispose}, @{"FastNew()" link FastNew}, @{"FastDispose()" link FastDispose}, @{"FastDisposeList()" link FastDisposeList}, @{"END" link END},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node Dispose
Syntax: Dispose(mem)

Frees any mem allocated by @{"New()" link New_proc}. You only have to use this function
if you explicitly wish to free memory _during_ your program, as all
is freed at the end anyway.

See @{"NewR()" link NewR}, @{"NewM()" link NewM}, @{"FastNew()" link FastNew}, @{"FastDispose()" link FastDispose}, @{"FastDisposeList()" link FastDisposeList}, @{"END" link END},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node CleanUp
Syntax: CleanUp(returnvalue=0)

Exits the program from any point. It is the replacement for the DOS
call Exit(): never use it! instead use CleanUp(), which allows
for the deallocation of memory, closing libraries correctly etc.
The return value will be given to dos as returncode.
Cleanup() is ONLY necessary if you have to exit at a point different
from @{"ENDPROC" link ENDPROC} in main.

For example See @{"CtrlC" link CtrlC 7}
@endnode

@node FreeStack
Syntax: amount:=FreeStack()

returns the amount of free stack space left. This should always be 1000 or
more. If you don't do heavy recursion, you need not worry about your free
stack space.

For example See @{"CtrlC" link CtrlC 7}
@endnode

@node CtrlC
Syntax: bool:=CtrlC()

Returns TRUE if Ctrl-C was pressed since you last checked, else FALSE.
This only works for programs running on a console, i.e. cli-programs.

Example of how these last three (@{"CleanUp" link CleanUp}, @{"FreeStack" link FreeStack}, @{"CtrlC" link CtrlC})
functions may be used:

/* calculate faculty from command-line argument */

OPT STACK=100000

PROC main()
  DEF num,r
  num:=@{"Val" link Val}(arg,{r})
  IF r=0 THEN @{"WriteF" link WriteF}('bad args.\n') ELSE @{"WriteF" link WriteF}('result: \d\n',fac(num))
ENDPROC

PROC fac(n)
  DEF r
  IF @{"FreeStack" link FreeStack}()<1000 OR @{"CtrlC" link CtrlC}() THEN @{"CleanUp" link CleanUp}(5)    /* xtra check */
  IF n=1 THEN r:=1 ELSE r:=fac(n-1)*n
ENDPROC r

Of course, this recursion will hardly run out of stack space, and when it
does, it's halted by @{"FreeStack" link FreeStack} so fast you won't have time to press
@{"CtrlC" link CtrlC}, but it's the idea that counts here.
A definition of fac(n) like:

PROC fac(n) IS IF n=1 THEN 1 ELSE fac(n-1)*n

would be less safe.
@endnode

@node FastNew
Syntax: mem:=FastNew(size)

FastNew() is a replacement for @{"NewR(size)" link NewR} (used by @{"NEW" link NEW 14}).
This is what it have in common:
- "NEW" exceptions may be Raised
- memory is always cleared
- auto-dealloc at end of program
but the following differences should be noted (positive):
- varying from 10 to 50 times faster (!)
- use way less memory for small objects
- do not fragment memory
[all this is for objects <=256 bytes, for bigger ones @{"NewR()" link NewR}
 is used]

See @{"NewM()" link NewM}, @{"Dispose()" link Dispose}, @{"FastDispose()" link FastDispose}, @{"FastDisposeList()" link FastDisposeList}, @{"END" link END},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node FastDispose
Syntax: FastDispose(mem,size)

FastDispose() is a replacements for @{"Dispose(ptr)" link Dispose} (used @{"END" link END}).
This is what they have in common:
- See @{"FastNew" link FastNew}
- auto-dealloc at end of program
- varying from 10 to 50 times faster (!)
- use way less memory for small objects
- do not fragment memory
negative:
- they do not free mem, but recycle it.
- FastDispose() needs exact size of allocation. @{"END" link END} also.

List allocated with @{"NEW" link NEW 14} need the function @{"FastDisposeList()" link FastDisposeList}. Because
Lists have a length, the size parameter isn't needed.

See @{"FastNew()" link FastNew}, @{"NewM()" link NewM}, @{"Dispose()" link Dispose}, @{"DisposeLink()" link DisposeLink}
@endnode

@node FastDisposeList
Syntax: FastDisposeList(list)

List allocated with @{"NEW" link NEW 14} need the function FastDisposeList. Because
Lists have a length, the size parameter isn't needed.

See @{"FastNew()" link FastNew}, @{"NewM()" link NewM}, @{"Dispose()" link Dispose}, @{"FastDispose()" link FastDispose}, @{"END" link END},
    @{"DisposeLink()" link DisposeLink}
@endnode

@node Not
Syntax: a:=Not(b)

Work with the usual operation, boolean as well as arithmetic.
@endnode

@node Eor
Syntax: a:=Eor(b,c)

Exclusiv OR
Work with the usual operation, boolean as well as arithmetic.

See @{"AND" link AND}, @{"OR" link OR}
@endnode

@node Mul
Syntax: a:=Mul(b,c)

Performs the same operation as the '*' operator, but now in full 32bit.
For speed reasons, normal operations are 16bit*16bit=32bit. This is sufficient
for nearly all calculations, and where it's not, you may use Mul().

See @{"Div" link Div}, @{"Mod" link Mod}
@endnode

@node Div
Syntax: a:=Div(a,b)

Performs the same operation as the '/' operator, but now in full 32bit.
For speed reasons, normal operations are 32bit/16bit=16bit. This is sufficient
for nearly all calculations, and where it's not, you may use Div().
NOTE: in the Div case, a is divided by b, not b by a.

See @{"Mul" link Mul}, @{"Mod" link Mod}
@endnode

@node Odd
Syntax: bool:=Odd(x)

Return TRUE or FALSE if some expression is Odd.

See @{"Even" link Even}
@endnode

@node Even
Syntax: bool:=Even(x)

Return TRUE or FALSE if some expression is Even

See @{"Odd" link Odd}
@endnode

@node Min
Syntax: Min(a,b)

compute min of the two given ints.

See @{"Max" link Max}, @{"Bounds" link Bounds}
@endnode

@node Max
Syntax: Max(a,b)

compute max of the two given ints.

See @{"Min" link Min}, @{"Bounds" link Bounds}
@endnode

@node Rnd
Syntax: randnum:=Rnd(max)

Rnd() computes a random number from an internal seed in range 0 .. max-1.
For example,  Rnd(1000)   returns an integer from 0..999
To initialise the internal seed, call Rnd() with a negative value;
the Abs() of that value will be the initial seed. A good way to initialise
the internal seed is:
  Rnd(-VbeamPos())

Also see @{"RndQ" link RndQ}
@endnode

@node RndQ
Syntax: seed:=RndQ(seed)

RndQ() computes a random number "Q"uicker than @{"Rnd" link Rnd} does, but returns
only full range 32bit random numbers. Use the result as the seed for
the next call, and for startseed, use any large value, like $A6F87EC1.

Also see @{"Rnd" link Rnd}
@endnode

@node Abs
Syntax: absvalue:=Abs(value)

computes the absolute value.

See also @{"Sign" link Sign}
@endnode

@node Sign
Syntax: s:=Sign(v)

computes the sign of v, i.e. returns -1,0,1

See also @{"Abs" link Abs}
@endnode

@node Mod
Syntax: a,b:=Mod(c,d)

Divides 32bit c by 16bit d and returns 16bit modulo a and optionally
a 16bit result of the division b. If these 16bit limits are exceeded,
Mod() will not give correct results.

See also @{"Div" link Div}, @{"Mul" link Mul}
@endnode

@node Shl
Syntax: x:=Shl(y,num)

shifts y num bits to left (set new bits to 0).

See @{"Shr" link Shr}
@endnode

@node Shr
Syntax: x:=Shr(y,num)

shifts y num bits to right (set new bits to 0).

See @{"Shl" link Shl}
@endnode

@node PutLong
Syntax: PutLong(adr,a)

Pokes value 'a' into memory.

See @{"Long()" link Long 12},
    @{"PutInt" link PutInt}, @{"PutChar" link PutChar}
@endnode

@node PutInt
Syntax: PutInt(adr,a)

Pokes value 'a' into memory.

See @{"Int()" link Int 9},
    @{"PutLong" link PutLong}, @{"PutChar" link PutChar}
@endnode

@node PutChar
Syntax: PutChar(adr,a)

Pokes value 'a' into memory.

See @{"Char()" link Char 10},
    @{"PutLong" link PutLong}, @{"PutInt" link PutInt}
@endnode

@node Bounds
Syntax: y:=Bounds(x,a,b)

makes sure x lies between bounds a and b, and adjust acordingly if necessary.
It equals:    y:=IF x<a THEN a ELSE IF x>b THEN b ELSE x

See also @{"Min" link Min}, @{"Max" link Max}
@endnode

@node linkfunctions
 string and list linking functions
-----------------------------------
E provides for a set of functions that allows the creation of
linked list with the @{"String()" link String_proc} and @{"List()" link List_proc} datatype, or strings and lists
that were created with String() and List() respectively. As you may
know by now, strings and lists, complex datatypes, are pointers
to their respective data, and have extra fields to a negative offset
of that pointer specifying their current length and maxlength. the
offsets of these fields are PRIVATE. as an addition to those two,
any complex datatype has a 'next' field, which is set to NIL by
default, which may be used to build linked list of strings, for example.
in the following, I will use 'complex' to denote a ptr to a STRING
or LIST, and 'tail' to denote another such pointer, or one that already
has other strings linked to it. 'tail' may also be a NIL pointer,
denoting the end of a linked list.
[note: these String-list functions have nothing to do with E-lists or
 Lisp-Cell lists]
The following functions may be used:
    @{"Link" link Link}, @{"Next" link Next}, @{"Forward" link Forward}, @{"DisposeLink" link DisposeLink}
@endnode

@node Link
Syntax: complex:=Link(complex,tail)

puts the value tail into the 'next' field of complex. returns again complex.
example:

DEF s[10]:STRING, t[10]:STRING
Link(s,t)

creates a linked list like:    s --> t --> NIL

See @{"string and list linking functions" link linkfunctions}
@endnode

@node Next
Syntax: tail:=Next(complex)

reads the 'next' field of var complex. this may of course be NIL, or
a complete linked list. Calling Next(NIL) will result in NIL, so it's
safe to call Next when you're not sure if you're at the end of a linked list.

See @{"string and list linking functions" link linkfunctions}
@endnode

@node Forward
Syntax: tail:=Forward(complex,num)

same as @{"Next" link Next}, only goes forward num links, instead of one, thus:

Next(c) = Forward(c,1)

You may safely call Forward() with a num that is way too large;
Forward will stop if it encounters NIL while searching links, and
will return NIL.

See @{"string and list linking functions" link linkfunctions}
@endnode

@node DisposeLink
Syntax: DisposeLink(complex)

same as @{"Dispose" link Dispose}, with two differences: it's only for strings and
lists allocated with @{"String()" link String_proc} or @{"List()" link List_proc}, and will automatically
de-allocate the tail of complex too. Note that large linked lists
containing strings allocated with String() as well as some allocated
locally or globally with STRING may also be de-allocated this way.

For a good example of how linked lists of strings may be put to
good use in real-life programs, see Src/Utils/D.e

See @{"string and list linking functions" link linkfunctions}
@endnode

@node lispcells
 lisp-cells 
------------
yep. that's right. you thought LISP was fun, then try E now.
[or: the story about why E is a better LISP than LISP itself :-)]

Starting from v3, E has the cell datatype, almost identical to cells
in the LISP language. more technically, E has:

`Conservative Mark and Sweep Garbage-Collected Lisp-Cells'

basically this amounts to being able to allocate LISP-cells,
which are pairs of two values:

	x:=<a|b>

which is much like @{"NEW" link NEW} [a,b]:LONG, only now E will automatically
deallocate the 8 bytes in question itself when it finds out it needs
memory and no pointers are pointing to the cell. In practise this
means that you can freely have functions create cells as temporaries,
without worrying about freeing them. And any LISP-programmer will
be able to explain to you that with cells you can build any
data-structure (most notably trees and lists). [note: this text
does not thorougly explain how to make full use of cells, since
dozens of LISP books have been written about this]

Selecting the values can easily be done using @{"Car(x)" link Car} and @{"Cdr(x)" link Cdr},
two LISP-functions which select head and tail (first and second)
element of the cell. if x is a PTR TO LONG, even x[0] and x[1]
are allowed.

One can also write lists of cells:

	<a,b,c>

(note the commas) as short for

	<a|<b|<c|NIL>>>

An alternative for selection with Car/Cdr is E's unification:

	x <=> <a,b|c>
	a+b+c

instead of:

	Car(x)+Car(Cdr(x))+Cdr(Cdr(x))

lisp-cell unification resembles E-list unification (see @{"Unification" <=>}). for
example:

	x <=> <1,2|a>

equals:

	IF Car(x)=1
          IF Car(Cdr(x))=2
            a:=Cdr(Cdr(x))
            ...


A lisp-nil value is available "<>", which equals NIL and 0.

some functions are available (note that Cons() is _only_ available
through <...>):
  @{"Car" link Car}, @{"Cdr" link Cdr}, @{"Cell" link Cell}, @{"FreeCells" link FreeCells}, @{"SetChunkySize" link SetChunkySize}



In general, get a good book about lisp to understand more about
programming with cells.

One can write any LISP-functions in E, with exactly the same functionality:

PROC append(x,y) IS IF x THEN <Car(x)|append(Cdr(x),y)> ELSE y
PROC nrev(x) IS IF x THEN append(nrev(Cdr(x)),<Car(x)>) ELSE NIL
PROC sum(x) IS IF x THEN Car(x)+sum(Cdr(x)) ELSE 0

using a destructive implementation for functions like these is
also allowed.

techy stuff:
E's garbage collector implements a conservative mark and sweep algorithm
that was tested to be 5 to 25 times faster than several logical and
functional language implementations on the Amiga. Conservative
means that in case of doubt, the GC will not deallocate a cell. this
is necessary since in a typeless language such as E, the GC can
easily bump into a value that is not a valid pointer etc.

The GC allocates big chunks (default 128k), in which it allocates
cells. if out of cells, it will collect garbage by scanning the
stack and registers for pointers into the cellspace, and recursively
mark them. after that, all unmarked cells are reused, and if the
gain after a collection was only small, a new chunk is allocated
(if this fails, "NEW" is raised).

interaction with other E values:
- storing other values in cells is no problem whatsoever. objects,
  strings, floats, anything can be put into a cell without confusing
  the GC too much.
- storing cells in other values, for example a ptr to a cell in a
  dynamic object, is problematic, since the GC won't be able to find
  it there. a solution for this will be provided. However I think this
  case will seldom occur.
  ptrs to cells can safely be stored in global and local variables,
  even registers, and any stack datastructures.
  [and most importantly, in other cells!]

caveats:
- The GC currently can't collect cells that have a Car-list >1000
  long or so, i.e. <<<NIL:a>:b>:c>, but then 1000 instead of 3
  entries. this will hardly ever occur since lists like this
  are usually formed as Cdr-lists, which the GC can handle into
  infinity. (it will raise "STCK" if this fails")
- inline assembly code should never push stuff on the stack that
  is not LONG aligned. this was already necessary in v2.1b,
  but now is even more essential.

There's a trade off in chunk-size between time and space.
Allocating small chunks obviously is nice since you won't waste
any memory, however, when collecting garbage, the effort for
each pointer to trace is almost proportional to the number of
spaces. therefore:
- if speed is most important tune the chunkspacesize such that
  that only one space is needed. if the top cell-memory usage at a
  certain time is 50k, a chunkspace of 100k or 150k will give
  optimal performance.
- if memory usage is more important, in the example above a
  chunksize of 20k or 30k will be quite optimal for memory.
In general, time a heavy usage of your cell-algorithm with
different sizes to see what trade-off suits you best.
@endnode

@node Car
Syntax: h:=Car(c)

fix the head value of a cell c

See @{"Cdr" link Cdr}
For general informations see @{"Lisp-Cells" link lispcells}
@endnode

@node Cdr
Syntax: h:=Cdr(c)

fix the tail value of a cell c

See @{"Car" link Car}
For general informations see @{"Lisp-Cells" link lispcells}
@endnode

@node Cell
Syntax: bool:=Cell(c)

gives a bool for whether or not c points at a cell, so Cell(<1>)=TRUE,
and Cell(3.14)=FALSE. This is not a fast function.

For general informations see @{"Lisp-Cells" link lispcells}
@endnode

@node FreeCells
Syntax: n:=FreeCells()

tell you about the amount of free cells available. very slow function.
there should be no need to call this function other than curiosity.

For general informations see @{"Lisp-Cells" link lispcells}
@endnode

@node SetChunkySize
Syntax: SetChunkSize(k)

Sets the chunksize to allocate for cells to k kilobyte. default is 128k.
This function can only be called once, and only before the first cons
(<..>) allocation takes place. Thereafter it has no effect.

For general informations see @{"Lisp-Cells" link lispcells}
@endnode

@node MODULE
 interfacing to the amiga system with the v39 modules
-------------------------------------------------------
To use any other library than the five in the previous section, you'll
need to resort to modules. Also, if you wish to use some OBJECT or CONST
definition from the Amiga includes as is usual in C or assembler,
you'll need modules. Modules are binary files which may include constant,
object, library and function (code) definitions. The fact that they're
binary has the advantage over ascii (as in C and assembly), that they
need not be compiled over and over again, each time your program is
compiled. The disadvantage is that they cannot simply be viewed; they
need a utility like ShowModule to make their contents visible. The modules
that contain the library definitions (i.e the calls) are in the root of
emodules: (the modules dir in the distribution), the constant/object
definitions are in the subdirectories, structured just like the originals
from Commodore.
------------------------------------------------------------------------------

syntax:		MODULE <modulenames>,...

Loads a module. A module is a binary file containing information on libraries,
constants, and sometimes functions. Using modules enables you to use
libraries and functions previously unknown to the compiler.

Now for an example, below is a short version of the source/examples/asldemo.e
source that uses modules to put up a filerequester from the 2.0 Asl.library.


MODULE 'Asl', 'libraries/Asl'

PROC main()
  DEF req:PTR TO filerequester
  IF aslbase:=OpenLibrary('asl.library',37)
    IF req:=AllocFileRequest()
      IF RequestFile(req) THEN WriteF('File: "\s" in "\s"\n',req.file,req.drawer)
      FreeFileRequest(req)
    ENDIF
    CloseLibrary(aslbase)
  ENDIF
ENDPROC


From the modules 'asl', the compiler takes asl-function definitions like
RequestFile(), and the global variable 'aslbase', which only needs to
be initialised by the programmer. From 'libraries/Asl', it takes
the definition of the filerequester object, which we use to read the
file the user picked. Well, that wasn't all that hard: did you think
it was that easy to program a filerequester in E?


 compiling own modules
-----------------------
with v3, you can gather all PROCs, CONSTs, OBJECTs and to
some extent also global variables that you feel somehow belong
together in one source, write "OPT MODULE" to signal EC that
this is supposed to be a module, and then compile all to a
.m file to be used in the main program, just like you used to
do with the old modules.

by default, all elements in a module are @{"PRIVATE" link PRIVATE}, i.e. not accessable
to the code that imports the .m file. to show which elememts
you wish to be visible in the module, simply write @{"EXPORT" link EXPORT}
before it:

EXPORT ENUM TESTING,ONE,TWO,THREE,FOUR

EXPORT DEF important_glob_var, bla:PTR TO x

EXPORT OBJECT x
  next, index, term
ENDOBJECT

EXPORT PROC burp()
  /* whatever */
ENDPROC

"EXPORT" is useful in making a distinction between private and
public, especially when all functions of an OBJECT can be accessed
via PROCs, you may wish to keep OBJECT private as an effective
method of @{"data hiding" link "OO features" 47}.
[EXPORT can be written on any line, doesn't affect everything though.]

If in a module _all_ elememts need to be exported (for example
one with only constants), a '@{"OPT" link OPT} EXPORT' will export all, without
the need for individual EXPORT keywords.

global variables require extra attention:
- try to avoid lots of global variables. having lot of globals
  in modules makes projects messy and error-prone
- globs in a module cannot have initialisations directly
  in the DEF statement (reason for this will become clear
  below). for example:
  DEF a             not     DEF a=1
  DEF a:PTR TO x    not     DEF a[10]:ARRAY OF x
- globals in a module which are not exported function as
  local for the module, i.e. they'll never clash with globals
  in other modules. those who _are_ exported though, are
  combined with the others, i.e. if in both the main program
  and in a module a variable with the same name are used,
  this will be one and the same variable. that's why
  one can write DEF a[10]:ARRAY OF x in the main program,
  and EXPORT DEF a:PTR TO x in the module, to share the
  array. Also, if both use for example 'gadtools.m',
  only one of the two needs to initialise 'gadtoolsbase'
  for both to be able to make calls to the library.
  If you do not want librarybases to be shared (i.e. you
  want to have a local, private library base), simply
  redeclare it in a DEF in the module that is not EXPORTed.
  If you export a variable in a general purpose
  module, make sure to give it a pretty unique name.
- using globals in modules which provide general purpose
  datatypes needs special attention, as the module may be
  in use from more than one other module, in which case
  it may be unclear who is responsable for resources.
  take good care of this.

Using modules in modules

This requires little extra attention. If the module (B) you include
in your own module (A) is one that only declares CONSTs, LIBRARYs and
OBJECTs (without code) nothing special happens, however if B includes
PROCs, then it's obvious this code needs to be linked later to the
main program when A is linked. Therefore if a main program uses A,
B will need to be present for compilation. The fact that A needs
B is stored in A, and can be viewed with ShowModule. This chain
of uses may grow out to a tree of dependencies, which has the result
that if you use just one module in your program, a lot of others
are automatically linked to it. Thus, E's module system automatically
keeps track of dependancies that other languages need makefiles for.
EC also allows for circular inclusions, and loads/links modules at most
once (i.e. doesn't link unused modules). One thing E's module system
doesn't automatically do for you is recompile dependant modules. If
you change B, it is often necessary to recompile A too, since it
might be referring to offsets etc. in the old version of B, which
might cause code to crash. If this gets too complex in your project,
use a utility such as E-Build.


Try out the new ShowModule  to see what EC puts in modules.


Including modules from other directories.

By default, a module name is prefixed by 'emodules:' to obtain
the actual file. Now you can prefix the name with a '*' to
denote the directory the source is in, so:

MODULE 'bla', '*bla'

if this statement would be in source 'WORK:E/burp.e', these two
modules would be 'emodules:bla.m' and 'WORK:E/bla.m'.

This is naturally the way to include components of your app into
other parts. If you write modules that you use in many of your programs
it would be handy to store them in the emodules hierarchy, and the
place for this is the 'emodules:other/' dir.
@endnode

@node EXPORT
 See @{" MODULE " link MODULE 49},
     @{" Data-hidding " link "OO features" 47},
     @{" OPT-Keyword " link OPT}
@endnode

@node PRIVATE
 See @{" MODULE " link MODULE 49},
     @{" OBJECT " link OBJECT 53},
     @{" Data-hidding " link "OO features" 47}
@endnode

@node `
Syntax: `<exp>

This is called a quoted expression, from LISP. <exp> is not evaluated,
but instead returns the address of the expression, which can later be
evaluated when required.


 quoting and scope
-------------------
Quoted expressions start with a backquote. The value of a quoted
expression is not the result from the computation of the expression,
but the address of the code. This result may then be passed on as
a normal variable, or as an argument to certain functions.
example:

myfunc:=`x*x*x

myfunc is now a pointer to a `function' that computes x^3 when evaluated.
These pointers to functions are very different from normal PROCs, and
you should never mix the two up. The biggest differences are that a
quoted expression is just a simple expression, and thus cannot have its
own local variables. In our example, "x" is just a local or global variable.
That's where we have to be cautious:
if we evaluate myfunc somewhat later in the same PROC, x may be local,
but if myfunc is given as parameter to another PROC, and then evaluated,
x needs of course to be global. There's no scope checking on this.

Example of how to use these functions in a practical fashion:
we allocate different sizes of memory in one statement, check them
all together at once, and free them all, but still only those that
succeeded. (example is v37+)

PROC main()
  @{"DEF" link DEF} mem[4]:@{"LIST" link LIST},x
  @{"MapList" link MapList}({x},[200,80,10,2500],mem,`AllocVec(x,0))              -> alloc some
  @{"WriteF" link WriteF}(@{"IF" link IF} @{"ForAll" link ForAll}({x},mem,`x) @{"THEN" link THEN} 'Yes!\n' ELSE 'No!\n')        -> suxxes ?
  @{"ForAll" link ForAll}({x},mem,`@{"IF" link IF} x @{"THEN" link THEN} FreeVec(x) @{"ELSE" link IF} NIL)     -> free only those <>NIL
ENDPROC

Note the absence of iteration in this code. Just try to rewrite this
example in any other language to see why this is special.

See also @{"Eval" link Eval}, @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"Exists" link Exists}, @{"SelectList" link SelectList}
@endnode

@node Eval
Syntax: Eval(func)

simply evaluates a @{"quoted expression" link `} (exp = Eval(`exp)).

NOTE: because E is a somewhat typeless language, accidentally writing
"Eval(x*x)"  instead of  "Eval(`x*x)"  will go unnoticed by the
compiler, and will give you big runtime problems: the value of x*x
will be used as a pointer to code.

To understand why 'quoted expressions' is a powerful feature think of the
following cases: if you were to perform a set of actions on a set of different
variables, you'd normally write a function, and call that function with
different arguments. But what happens when the element that you want to give
as argument is a piece of code? in traditional languages this would not be
possible, so you would have to 'copy' the blocks of code representing your
function, and put the expression in it. Not in E. say you wanted to write
a program that times the execution time of different expressions. In E you
would simply write:

PROC timing(func,title)
  /* do all sorts of things to initialise time */
  Eval(func)
  /* and the rest */
  @{"WriteF" link WriteF}('time measured for \s was \d\n',title,t)
ENDPROC

and then call it with:

timing(`x*x*x,'multiplication')
timing(`sizycalc(),'large calculation')


in any other imperative language, you would have to write out
copies of timing() for every call to it, or you would have to
put each expression in a separate function. This is just a simple
example: think about what you could do with data structures (LISTs)
filled with unevaluated code:

drawfuncs:=[`@{"Plot" link Plot}(x,y,c),`@{"Line" link Line}(x,y,x+10,y+10,c),`@{"Box" link Box}(x,y,x+20,y+20,c)]

Note that this idea of functions as normal variables/values is not new
in E, quoted expressions are literally from LISP, which also has the
somewhat more powerful so-called Lambda function, which can also be
given as argument to functions; E's quoted expressions can also be
seen as parameterless (or global parameter only) lambdas.

See also @{"quoted expressions" link `},
         @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"Exists" link Exists}, @{"SelectList" link SelectList}


REALs (or FLOATs, whatever) are very different in E than in other
languages. This mainly has to do with the fact that E doesn't
really discriminate between types of values. One is advised to
understand this chapter _well_ before attempting to use floats.
@endnode

@node MapList
Syntax: MapList(varadr,list,listvar,func)

performs some function on all elements of list and returns all
results in listvar. func must be a @{"quoted expression" link `},
and var (which ranges over the list) must be given by reference. Example:

MapList({x},[1,2,3,4,5],r,`x*x)       results r in:     [1,4,9,16,25]

returns listvar.

See also @{"quoted expression" link `},
         @{"Eval" link Eval}, @{"ForAll" link ForAll}, @{"Exists" link Exists}, @{"SelectList" link SelectList}
@endnode

@node ForAll
Syntax: ForAll(varadr,list,func)

Returns TRUE if for all elements in the list the function (@{"quoted expression" link `})
evaluates to TRUE, else FALSE. May also be used to perform a certain function
for all elements of a list:

ForAll({x},['one','two','three'],`@{"WriteF" link WriteF}('example: \s\n',x))

See also @{"quoted expression" link `},
         @{"Eval" link Eval}, @{"MapList" link MapList}, @{"Exists" link Exists}, @{"SelectList" link SelectList}
@endnode

@node Exists
Syntax: Exists(varadr,list,func)

As @{"ForAll()" link ForAll}, only this one returns TRUE if for any element the function
evaluates to TRUE (<>0). note that ForAll() always evaluates all elements,
but @{"Exists()" link Exists} possibly does not.

See also @{"quoted expression" link `},
         @{"Eval" link Eval}, @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"SelectList" link SelectList}
@endnode

@node SelectList
Syntax: SelectList(v,list,listvar,quotedexp)

Much like @{"MapList()" link MapList}, only now doesn't store the result from quotedexp,
it uses it as a boolean value, and only those values for which it is
true are stored in listvar (which should be capable of holding
the same amount of elements as list. example:

SelectList({x},[1,2,0,3,NIl],r,`x<>0)

results in r being [1,2,3].
returns length of listvar.

See also @{"quoted expression" link `},
         @{"Eval" link Eval}, @{"MapList" link MapList}, @{"ForAll" link ForAll}, @{"Exists" link Exists}
@endnode

@node !
 float operator (!)
--------------------
<exp>!<exp>
Converts expressions from integer to float and back, and
overloads operators + - * / = <> < > <= >= with float equivalents.

 float values
--------------
In E, a float is just another 32bit value. The E compiler treats
them just like integers or pointers, with the difference that
their bit representation means something different. The E float
format is the IEEEsingle standard.

A float value looks like an integer value with the exception that
somewhere a "." is present. for example, the following are valid 
floats:

	3.14159    .1    1.    -12345.6

these aren't:

	.    1234

(i.e. atleast one "." and one "0-9" char must be present).

You can use these values at almost all places where @{"LONG" link LONG} values
are legal, i.e. if you have have a function or datastructure that
handles arbitrary LONG values, it will also handle floats.

	@{"DEF" link DEF} f=3.14
	myobj.x:=.1
	fun(f,2.73)

 computing with floats
-----------------------
Because to E a float will seem like just another LONG, it will happily
apply integer math to it when used in an expression, which is mostly
not what you want. Also, one would like to be able to convert to
integer and vice-versa. The float operator "!" handles all this.

assume in the following examples that a,b,c contain integer values,
and x,y,z float values.

By default, an expression in E is considered an integer expression.
what the "!" does when it occurs in an expression is the following:
- changes the expression from int to float. any operators following
  (+ * - / = <> > < >= <=) will be float operations. "!" may occur
  any number of times in an expression, changing from and to float
  again and again.
- the expression that did occur before the "!", if any, is converted
  to the appropriate type.

examples:

	x:=a!

converts "a" to float, and stores the result in x. "a" is an integer exp,
which is then toggled to float, which implies a conversion.

	a:=!x!

converts "x" to integer and stores the result in a.

	x:=y

	x:=@{"Ftan" link Ftan}(y)

no "!" is needed here since no operator-math or conversions are necessary.

	x:=!y*z

the "*" acts on y and z as floats, since "!" denotes the whole as
a float-exp. the float result is stored in x

	a:=b!*x+y!

a more complex example: the int "b" is converted to float, then x
and y are float-multiplied and float-added to it. The result is converted
to int and stored in the int "a"

	x:=!y*z-z*y+(a!)+z/z

	z:=!x*@{"Fsin" link Fsin}(!x*y)

all (+ * - /) are computed as float, and the int "a" is converted
to float somewhere in the middle. since "(" ")" denotes a new expression,
it has it's own status of "!". Same idea for the function below.

	IF !x<0.1 THEN @{"WriteF" link WriteF}('Float value too small!\n')

as you can see, "!" also works on the six comparison operators.

For other built in float-functions see
  @{"Fsin" link Fsin}, @{"Fcos" link Fcos},@{"Ftan" link Ftan}, @{"Fabs" link Fabs},
  @{"Ffloor" link Ffloor}, @{"Fceil" link Fceil},
  @{"Fexp" link Fexp}, @{"Flog" link Flog}, @{"Flog10" link Flog10}, @{"Fpow" link Fpow}, @{"Fsqrt" link Fsqrt},
  @{"RealVal" link RealVal}, @{"RealF" link RealF}


 float implementation issues
-----------------------------
As said before, the E float format is IEEE (single), this means that
older float code using the FFP format with the SpXxx functions will
have to be rewritten (as stated in the v2.1b docs). The mathffp
library is no longer directly supported by EC v3.0, and you'll
have to open this library like all others if you want to use it.

single IEEE's were chosen because:
- double IEEE's don't fit in a LONG
- the FFP format routines do not make use of a 68881 if present,
  the IEEE ones do. Furthermore the FFP format is incompatible
  with the 68881, which also uses IEEE format.
- IEEE is the worldwide float-format standard, which encourages
  data-file compatability among software/platforms.

E's float routines use the mathieeesingbas.library and the
mathieeesingtrans.library, which are not by default supplied
with the ancient v1.3 of the OS. This means that if you want
to write under / support 1.3 AND you want to use the _builtin_
floats, you have to make sure these libraries are present (they
seem to be available, maybe through commodore?).

Both EC and the programs it generates do not open these libraries
as long as no float-features are used.

If all else fails, one can always use other floatlibraries to use
floats with 1.3. I might recommend the tools/longreal.m module
which uses doubles.

In the future, EC will probably allow mathieee library calls to
be replaced with inline 68881 code transparently.

[note: v3.1 (v40) of the amiga operating system is known to contain
 a bug in the IEEE code. Be sure to run a SetPatch that fixes this]
@endnode

@node Fsin
Syntax: x:=Fsin(y)

usual sin() function. work with radians.

See @{"Float operator" link !}
@endnode

@node Fcos
Syntax: x:=Fcos(y)

usual cos() function. work with radians.

See @{"Float operator" link !}
@endnode

@node Ftan
Syntax: x:=Ftan(y)

usual tan() function. work with radians.

See @{"Float operator" link !}
@endnode

@node Fabs
Syntax: x:=Fabs(y)

compute absolute value of y

See @{"Float operator" link !}
@endnode

@node Ffloor
Syntax: x:=Ffloor(y)

compute lowest whole-number float value near y

See @{"Float operator" link !}
@endnode

@node Fceil
Syntax: x:=Fceil(y)

compute highest whole-number float value near y

See @{"Float operator" link !}
@endnode

@node Fexp
Syntax: x:=Fexp(y)

compute e^y.

See @{"Float operator" link !}
@endnode

@node Flog
Syntax: x:=Flog(y)

compute ln(y).

See @{"Float operator" link !}
@endnode

@node Flog10
Syntax: x:=Flog10(y)

compute log base 10.

See @{"Float operator" link !}
@endnode

@node Fpow
Syntax: x:=Fpow(y,z)

compute z^y.

See @{"Float operator" link !}
@endnode

@node Fsqrt
Syntax: x:=Fsqrt(y)

compute square root of y.

See @{"Float operator" link !}
@endnode

@node RealVal
Syntax: x,n:=RealVal(s)

parses string "s" to produce float value x. will skip leading spaces and tabs.
n is the number of characters parsed from the start of the string, or 0
if it couldn't be parsed as a float value. "x" will then be 0.0.
accepts negative numbers (and number without a ".", even).
example:

RealVal(' 3.14 ')    results in    3.14, 5
RealVal('blabla')    results in    0.0, 0

See @{"Float operator" link !}
@endnode

@node RealF
Syntax: s:=RealF(s,x,n)

Format a float value x to the estring s, with n positions after the ".".
max for "n" is 8, even less if you have lots of digits leading the ".".
an "n" of 0 will denote no fraction. The string is returned as result,
so it can be reused in a WriteF() for example:

@{"WriteF" link WriteF}('float = \s\n',RealF(s,3.14159),4)    results in    'float = 3.1416\n'

RealF() tries hard to make sensible roundings for a certain "n", as
the example shows. negative numbers are also handled properly.

RealF(s,-3.14159,0)    results in    '-3'

See @{"Float operator" link !}
@endnode

@node exceptions
 defining exception handlers (HANDLE/EXCEPT)
----------------------------------------------
The exception mechanism in E is basically the same as in ADA; it
provides for flexible reaction on errors in your program and
complex resource management. NOTE: the term 'exception' in E has
very little to do with exceptions caused directly by 680x0 processors.

An exception handler is a piece of program code that will be invoked
when runtime errors occurs, such as windows that fail to open or
memory that is not available. You, or the runtime system itself,
may signal that something is wrong (this is called "raising an
exception"), and then the runtime-system will try and find the
appropriate exception handler. I say "appropriate" because a program
can have more than one exception handler, on all levels of a program.
A normal function definition may (as we all know) look like this:

PROC bla()
  /* ... */
ENDPROC

a function with an exception handler looks like this:

@{"PROC" link PROC} bla() @{"HANDLE" link HANDLE}
  /* ... */
@{"EXCEPT" link EXCEPT}
  /* ... */
@{"ENDPROC" link ENDPROC}

The block between PROC and EXCEPT is executed as normal, and if no
exception occurs, the block between EXCEPT and ENDPROC is skipped, and
the procedure is left at ENDPROC. If an exception is raised, either
in the PROC part, or in any function that is called in this block,
an exception handler is invoked.

For using exceptions see @{"using the Raise()-function" link Raise_proc}, @{"ExceptionIDs" link ExceptionIDs}
See @{"HANDLE" link HANDLE}, @{"EXCEPT" link EXCEPT}, @{"Raise()" link Raise_proc}, @{"RAISE" link RAISE}, @{"Throw" link Throw}, @{"ReThrow" link ReThrow}
@endnode

@node HANDLE
Syntax: @{"PROC" link PROC} bla() HANDLE

Shows E that the function 'bla' has an exception handler.

See @{"Exceptions" link Exceptions}, @{"ExceptionIDs" link ExceptionIDs}
    @{"EXCEPT" link EXCEPT}, @{"Raise()" link Raise_proc}, @{"RAISE" link RAISE}, @{"Throw" link Throw}, @{"ReThrow" link ReThrow}
@endnode

@node EXCEPT
Syntax: EXCEPT		/* normal exception-handler */
        EXCEPT DO	/* See @{"Raise()" link Raise_proc} */

If an exception occur, the code after EXCEPT is executed.

See @{"Exceptions" link Exceptions}, @{"ExceptionIDs" link ExceptionIDs}
    @{"HANDLE" link HANDLE}, @{"Raise()" link Raise_proc}, @{"RAISE" link RAISE}, @{"Throw" link Throw}, @{"ReThrow" link ReThrow}
@endnode

@node RAISE
 defining exceptions for built-in functions (RAISE/IF)
-------------------------------------------------------
With exceptions like before (see @{"Raise()" link Raise_proc}), we have made a major gain over
the old way of defining our own "error()" function, but still it is
a lot of typing to have to check for NIL with every call to New().

The E exception handling system allows for definition of exceptions
for all E functions (like @{"New()" link New_proc}, @{"OpenW()" link OpenW} etc.), and for all Library
functions (OpenLibrary(), AllocMem() etc.), even for those
included by modules. Syntax:

RAISE <exceptionId> IF <func> <comp> <value> , ...

the part after RAISE may be repeated with a ",".
Example:

RAISE NOMEM IF @{"New()" link New_proc}=NIL,
      NOLIBRARY IF OpenLibrary()=NIL

the first line says something like: "whenever a call to New() results
in NIL, automatically raise the NOMEM exception".
<comp> may be any of = <> > < >= <=
After this definition, we may write all through our programs:

mem:=@{"New" link New_proc}(size)

without having to write:

IF mem=NIL THEN Raise(NOMEM)

Note that the only difference is that 'mem' never gets any value
if the runtime system invokes the handler: code is generated for
every call to New() to check directly after New() returns and call
Raise() when necessary.

We'll now be implementing a small example that would be complex to solve
without exception handling: we call a function recursively, and in each
we allocate a resource (in this case memory), which we allocate before,
and release after the recursive call. What happens when somewhere high
in the recursion a severe error occurs, and we have to leave the program?
right: we would (in a conventional language) be unable to free all the
resources lower in the recursion while leaving the program, because all
pointers to those memory areas are stored in unreachable local variables.
In E, we can simply raise an exception, and from the end of the handler
again raise an exception, thus recursively calling all handlers and
releasing all resources. Example:


CONST SIZE=100000
ENUM NOMEM  /* ,... */

RAISE NOMEM IF AllocMem()=NIL

PROC main()
  alloc()
ENDPROC

PROC alloc() HANDLE
  DEF mem
  mem:=AllocMem(SIZE,0)		/* see how many blocks we can get */
  alloc()			/* do recursion */
EXCEPT DO
  IF mem THEN FreeMem(mem,SIZE)
  @{"ReThrow" link ReThrow}()			/* recursively call all handlers */
ENDPROC


This is of course a simulation of a natural programming problem that
is usually far more complex, and thus the need for exception handling
becomes far more obvious. For a real-life example program whose error
handling would have become very difficult without exception
handlers, see the 'D.e' utility source.

The @{"DO" link DO} after an @{"EXCEPT" link EXCEPT} means that instead of jumping to @{"ENDPROC" link ENDPROC},
the main code will simply continue execution in the handler as soon
as it gets there. it also sets exception to 0.
This is handy if you free resources local to a @{"PROC" link PROC} in the handler.

See also @{"Raise()" link Raise_proc}
@endnode

@node Raise_proc
Syntax: Raise(exceptionID=0)

the exception ID is simply a constant that defines the type of
exception, and is used by handlers to determine what went wrong.
Example:

ENUM NOMEM,NOFILE  /* and others */

@{"PROC" link PROC} bla() @{"HANDLE" link HANDLE}
  @{"DEF" link DEF} mem
  @{"IF" link IF} (mem:=@{"New" link New_proc}(10))=NIL @{"THEN" link THEN} Raise(NOMEM)
  myfunc()
@{"EXCEPT" link EXCEPT}
  @{"SELECT" link SELECT} exception
    @{"CASE" link SELECT} NOMEM
      @{"WriteF" link WriteF}('No memory!\n')
    /* ... and others */
  @{"ENDSELECT" link ENDSELECT}
@{"ENDPROC" link ENDPROC}

PROC myfunc()
  DEF mem
  IF (mem:=New(10))=NIL THEN Raise(NOMEM)
ENDPROC

The "exception" variable in the handler always contains the value of
the argument to the Raise() call that invoked it.
In both New() cases, the Raise() function invokes the handler of
function bla(), and then exits it correctly to the caller of bla().
If myfunc() had its own exception-handler, that one would be invoked
for the New() call in myfunc(). The scope of a handler is from the start
of the PROC in which it is defined until the EXCEPT keyword, including
all calls made from there.

This has three consequences:
A. handlers are organized in a recursive fashion, and which handler is
   actually invoked is dependant on which function calls which at runtime;
B. if an exception is raised within a handler, the handler of a lower
   level is invoked. This characteristic of handlers may be used
   to implement complex recursive resource allocation schemes with
   great ease, as we'll see shortly.
C. If an exception is raised on a level where no lower-level handler
   is available (or in a program that hasn't got any handlers at all),
   the program is terminated. (i.e: Raise(x) has the same effect as
   CleanUp(0))

other functions:
  @{"Throw" link Throw}, @{"ReThrow" link ReThrow}
See also @{"RAISE" link RAISE}
         @{"Exceptions" link Exceptions}, @{"ExceptionIDs" link ExceptionIDs}
         @{"EXCEPT" link EXCEPT}, @{"HANDLE" link HANDLE}
@endnode

@node Throw
Syntax: Throw(exceptionID,value)

same as @{"Raise()" link Raise_proc}, only now it takes an arbitrary value with it. in
a handler one can then scrutinize this value with the variable @{"exceptioninfo" link exceptioninfo}
@endnode

@node ReThrow
Syntax: ReThrow()

has no args. simply does a @{"Throw()" link Throw} on the current exception value,
IFF it is <>0.
@endnode

@node exceptionIDs
 use of exception-ID's
-----------------------
In real life an exception-ID is of course a normal 32-bit value,
and you may pass just about anything to an exception handler: for
example, some use it to pass error-description strings

@{"Raise" link Raise_proc}('Could not open "gadtools.library"!')

However, if you want to use exceptions in expandabele fashion and you
want to be able to use future modules that raise exceptions not defined
by your program, follow the following guidelines:

- Use and define ID 0 as "no error" (i.e. normal termination)

- For exceptions specific to your program, use the ID's 1-10000.
  Define these in the usual fashion with @{"ENUM" link ENUM}:

  ENUM OK,NOMEM,NOFILE,...

  (OK will be 0, and others will be 1+)

- ID's 12336 to 2054847098 (these are all identifiers
  consisting of upper/lowercase letters and digits of length 2,3 or 4
  enclosed in "") are reserved as common exceptions. A common exception
  is an exception that need not be defined in your program, and that
  may be used by implementors of modules (with functions in them) to
  raise exceptions: for example, if you design a set of procedures that
  perform a certain task, you may want to raise exceptions. As you would
  want to use those functions in various programs, it would be
  unpractical to have to coordinate the IDs with the main program,
  furthermore, if you use more than one set of functions (in a module,
  in the future) and every module would have a different ID for
  'no memory!', things could get out of hand.
  This is where common exceptions come in: the common out-of-memory
  ID is "MEM" (including the quotes): any implementor can now simply

  @{"Raise" link Raise_proc}("MEM")

  from all different procedures, and the programmer that uses the module
  only needs to suply an exception handler that understands "MEM"

  future modules that contain sets of functions will specify what
  exception a certain procedure may raise, and if these overlap
  with the IDs of other procedures, the task of the programmer
  that has to deal with the exceptions will be greatly simplified.

  examples:

  (system)

  "MEM"		out of memory
  "FLOW"	(nearly) stack overflow
  "STCK"	garbage collector has stack problems
  "^C"		Control-C break
  "ARGS"	bad args

  (exec/libraries)

  "SIG"		could not allocate signal
  "PORT"	could not create messageport
  "LIB"		library not available
  "ASL"		no asl.library
  "UTIL"	no utility.library
  "LOC"		no locale.library
  "REQ"		no req.library
  "RT"		no reqtools.library
  "GT"		no gadtools.library (similar for others)

  (intuition/gadtools/asl/gfx)

  "WIN"		failed to open window
  "SCR"		failed to open screen
  "REQ"		could not open requester
  "FREQ"	could not open filerequester
  "GAD"		could not create gadget
  "MENU"	could not create menu(s)
  "FONT"	problem getting font

  (dos)

  "OPEN"	could not open a file / file does not exist
  "OUT"		problems while writing
  "IN"		problems while reading
  "EOF"		unexpected end of file
  "FORM"	input format error
  "SEG"		loadseg problems

  The general tendency is:
  * all uppercase for general system exceptions,
  * mixed case for exceptions used by >1 app, but not general enough.
  * all lowercase for exceptions raised within your own
    multi-module application

- all others (including all negative IDs) remain reserved.

See also @{"Exceptions" link Exceptions},
         @{"Raise()" link Raise_proc}, @{"RAISE" link RAISE}, @{"EXCEPT" link EXCEPT}, @{"HANDLE" link HANDLE}, @{"Throw" link Throw}, @{"ReThrow" link ReThrow}
@endnode

@node "OO features"
 OO features in E
------------------
The features descibed here in this chapter are grouped as such
since they constitute what is generally seen as the three essential
main components that make a language 'Object Oriented' (i.e.
inheritance - data hiding - polymorhism). However in E they are
by no means a 'separate chapter' since each can be used in any
way with other E features.



 object inheritance
--------------------
it's always annoying not being able to express dependencies between
@{"OBJECTs" link OBJECT}, or reuse code that works on a particular OBJECT with a bigger
OBJECT that encapsulates the first. Object Inheritance allows you
to do just that in E. when you have an object a:

OBJECT a
  next, index, term
ENDOBJECT

you can make a new object b that has the same properties
as a (and is compatible with code for a):

OBJECT b OF a
  bla, x, burp
ENDOBJECT

is equivalent to:

OBJECT b
  next, index, term         /* from a */
  bla, x, burp
ENDOBJECT

with DEF p:b, you can directly not only access p.bla as usual,
but also p.next.

as an example, if one would have a module with an OBJECT to
implement a certain datatype (for example a doubly-linked-list),
and PROCs to support it, one could simply inherit from it, adding
own data to the object, and use the _existing_ functions to
manipulate the list. However, it's only in combination with
methods (descibed below), inheritance can show its real power.


 data hiding (@{"EXPORT" link EXPORT}/@{"PRIVATE" link PRIVATE}/@{"PUBLIC" link PUBLIC})
-------------------------------------
E has a very handy data-hiding mechanism. Other languages, like C++,
use data-hiding on classes, which raises the need for kludges (like
'friends'), and makes datahiding insecure (Eiffel). E's datahiding
works on the module-level, which can model class-level datahiding,
but enables more intelligent schemes also.

@{"PRIVATE" link PRIVATE} and @{"PUBLIC" link PUBLIC} let you declare a section of an object as visible
to the outer world or not; the outer world here is all code outside
the module. for the code within a module, everything is always visible.
example:


OBJECT mydata PRIVATE                   -> whole object is private
  bla:PTR TO mydata, burp, grrr:INT
ENDOBJECT

OBJECT aaargh
  blerk:PTR TO aaargh                   -> public
PRIVATE
  x:INT, y:INT, z:INT                   -> private
PUBLIC
  hmpf[10]:ARRAY OF mydata              -> public again
ENDOBJECT


an object is by default public, an occurring PRIVATE or PUBLIC
acts as a toggle-switch to the objects current visibility. In the
first object, all is private. The second object has only (x,y,z)
as private. PRIVATE and PUBLIC keywords may occur:
- in the object header line
- as a line on itself in the object-def
- preceding decls in an object-def
(i.e virtually anywhere)

Why datahiding?
If you want to know why datahiding is a good technique, you'd
probably want to read a good book on OO. But in short: it is
generally assumed that lots of problems in maintaining and
enhancing large pieces of software is the fact that it's hard to change
things because lots of code start to depend on certain structures
in your program. if you datahide an object, only the code within a
module will rely on the format of objects, and you can easily change
both representation of an object (for example changing a stack
implementation from ARRAY to a linked list) and the code that
works with it. If a lot of code of a large app depend on the fact
that the stack is an ARRAY, you won't be able to simply change
it, which will lead to kludges. In general, try to datahide as
much as possible without becoming too restrictive on the use
of your object. Using methods (below) will often enable you to
keep the whole object private.


 methods and virtual methods
-----------------------------
A method is much like a PROC, only now it's part of an OBJECT. It
also allows you to exploit Polymorhism on objects, as we'll see
below. definition of a method:


OBJECT blerk PRIVATE
  x:PTR TO blerk, y:INT, z
ENDOBJECT

PROC getx() OF blerk IS self.x


the 'OF blerk' part tells the compiler it belongs to the object
'blerk'. Note that apart from the 'OF' the syntax is completely
like a 'PROC', however, it can't be invoked as one, and also
functions quite differently.

'self' is a local variable that is available in every method, and
is a pointer to the object that the method belongs to (in this
case 'self:PTR TO blerk'). This function just returns the value
of the x field of blerk, which actually makes sense, given that
this allows you to later change whatever x represents.

we may call methods similar to object selections ".":


DEF a:PTR TO blerk
@{"NEW" link NEW} a
...
a.getx()           -> invoke method getx() on object a


in this example, upon invocation `a' becomes the value of `self'
during the execution of getx().

so far the use of methods has been nice, but hasn't show us its
real power, which only comes when used with inheritance.

If I inherit an object that has methods, I automatically get
those in the new object:


OBJECT burp OF blerk PRIVATE        -> same as blerk, + extra field
  prut:INT
ENDOBJECT

DEF b:PTR TO burp
NEW b
...
b.getx()                            -> same method


The interesting thing is now, that instead of inheriting a method,
you may also redefine it:


PROC getx() OF burp IS self.x+1


(it goes without saying that we may also add new methods)
so where appropriate, we can choose to modify slightly the
behaviour of methods we get from other objects, while the
interface to it (i.e. 'getx()') stays the same. Not only
does this allow us to reuse code selectively, we can also make use
of polymorhism:


PROC dosomething(o:PTR TO blerk)
  ...
  o.getx()
  ...
ENDPROC

dosomething(a)
dosomething(b)


we may call that PROC with both a and b, since both are compatible
with a blerk object. But which of the two method implementations of
getx() is invoked at o.getx()? Answer: both are. Method calls in E
are what virtual method calls are in other languages: they dynamically
act on the real type of an object (o) and call the appropriate method.

A more clear example:


-> classical OO polymorphic example

OBJECT loc
  PRIVATE xpos:INT, ypos:INT
ENDOBJECT

OBJECT point OF loc
  PRIVATE colour:INT
ENDOBJECT

OBJECT circle OF point
  PRIVATE radius:INT
ENDOBJECT

PROC show() OF loc IS WriteF('I''m a Location!\n')
PROC show() OF point IS WriteF('I''m a Point!\n')
PROC show() OF circle IS WriteF('I''m a Circle!\n')

PROC main()
  DEF x:PTR TO loc,l:PTR TO loc,p:PTR TO point,c:PTR TO circle
  @{"ForAll" link ForAll}({x},[@{"NEW" link NEW} l,NEW p,NEW c],`x.show())
ENDPROC


In the above, x is a PTR TO loc, so many would expect x.show() to
write 'I'm a Location' three times, but instead it writes the
right string for each object.

If one would write this example in a non-OO language, one would need
a SELECT for every operation like show(), testing some value
present in the object to see what it is. If I would add a new shape
to this, say:

OBJECT ellipse OF circle

I would need to change all @{"SELECTs" link SELECT} throughout my app to account for
it. With object-polymorhism, I can just write a show() method, and
ALL code throughout my app that calls x.show() will act correctly
when x is a PTR TO ellipse, even without recompilation!


It's difficult to show why this is powerful in a few examples, and
best to discover this is using it in real life apps. and: like I said,
read a book on it.


How does polymorphism work?
In the above examples, it's clear the compiler can't know
what method it's going to call. that's why E uses a 'class
object', and every object created gets a ptr to this object.
In the class object, all information is stored that is common
for all objects of that type, such as pointers to methods.
when the E compiler sees a call like x.show(), instead of
looking directly at the show() that belongs to the type of
x (i.e. loc), it will generate code to retrieve the pointer
to the show() method from loc's class object. since the
class object for point looks the same as loc (only maybe
slightly larger), that code will automatically call point's
show(), when x is really a point object. This is sometimes
called runtime binding.

Objects that have methods therefore always are 4 bytes larger
than you expect them to be, since they contain a class object
pointer. This pointer is automatically installed by NEW, which
is the reason _currently_ NEW is the only way to create such
an object.

If a method is declared with the sole purpose of enabling
subclasses to redefine it (this type of class is known as
a virtual baseclass in some languages), one may use EMPTY:

PROC bla() OF obj IS EMPTY

it may then be redefined in subclasses. Since a programmer
might not implement all methods at once, it is not an error
when the above method is executed. it will just return 0 or NIL.


One may effectively add methods to system OBJECTs:

	OBJECT mygadget OF gadget	-> from intuition!
	  -> extra fields here
	ENDOBJECT

	PROC creategadget() OF mygadget IS ...

A pointer to an object such as mygadget above is then compatible
with a normal gadget pointer, i.e. it may be added directly to a
window etc.


 Constructors, Destructors and Super-Methods
---------------------------------------------

The constructor name may be anything, but it is usually given the same name
as the class. One may even have multiple constructors for one class.
A constructor is called directly on the object created with NEW:

	@{"NEW" link NEW} obj.stack()

Destructors however have to be named "end". An object is destroyed like this:

	@{"END" link END} obj

If 'obj' has a .end() method, it is automatically called. end() shouldn't have
any arguments, and it is of no use returning a value.


The super-method of a method is the method by the same name of its super
class. Sometimes it's handy to call this method because you might want to
add its behaviour to the implementation of your class, however, since
you've redefined it, calling the super-method by that name will just
call yourself (!). The @{"SUPER" link SUPER} keyword allows you to call any method of your
superclass (or someone else's superclass):

	@{"SUPER" link SUPER} obj.method()

This piece of code above can be used as expression and statement.
Care has to be taken though, since if your supermethod calls another
method of that object, it will call the redefined version, not the
one at its own 'level', so to speak (generally this is what one wants).
Also, the compiler looks at the static type of 'obj' to find the
superclass, not the dynamic type (though it may still have that behaviour).
@endnode

@node PUBLIC
  See @{" OBJECT " link OBJECT}
  See @{" Data-hidding (OO features) " link "OO features" 47}
@endnode

@node SUPER
Syntax: SUPER obj.method()
  See @{" Super-Methods " link "OO features" 301}
@endnode

@node Assembly
 assembly mnemonics
--------------------
In E, inline assembly is a true part of the language, they need not
be enclosed in special "ASM" blocks or the like, as is usual in
other languages, nor are separate assemblers necessary to assemble
the code. This also means that it obeys the E syntax rules, etc.
Example:

DEF a,b
b:=2
MOVEQ  #1,D0             /* just use some assembly statements */
MOVE.L D0,a              /* a:=1+b  */
ADD.L  b,a
WriteF('a=\d\n',a)       /* a will be 3 */



 identifier sharing
--------------------
As you've probably guessed assembly instructions may be freely mixed with
E code. The big secret is, that a complete assembler has been built in to the
compiler. Apart from normal assembly addressing modes, you may use the
following identifiers from E:

mylabel:
LEA mylabel(PC),A1		/* labels */

DEF a				/* variables */
MOVE.L (A0)+,a			/* note that <var> is <offset>(A4) (or A5) */

MOVE.L dosbase,A6		/* library call identifiers */
JSR    Output(A6)

MOVEQ  #TRUE,D0			/* constants */


EC's assembler supports following constructs,

where
n	= registernum
x	= index
lab	= label, from: "label:" or "PROC label()"
abs	= absolute addressing
s	= size. L, W or B where appropriate.

- addressing modes supported by EC:

  Dn, An, (An), (An)+, -(An), x(An), x(An,Dn.s),
  lab(PC), lab(PC,Dn.s), abs, abs.W

  (note: write abs.W in hexadecimal, to not confuse it with a float
   value, i.e. write   MOVE.L $4.W,A6   )

- supported partially:

  #<constexp>

- not supported:

  lab (same as abs), #lab
  use LEA lab(PC),An instead.

- extra modes:

  var.s (transfers contents of var. optionally size is ".W" or ".B",
         default is ".L")

  LibraryFunction(A6)

  example:

  ...
  MOVE.W myvar.W,D0     -> move lowword of 'myvar'
  ...
  MOVE.L dosbase,A6
  JSR    Write(A6)



As an extra, E allows to directly return registers from a function:

  ENDPROC D0

You may even interpret this as multiple return values, i.e. D0/D1/D2.



 the inline assembler compared to a macro assembler
----------------------------------------------------
The inline assembler differs somewhat from your average macro-assembler,
and this is caused mainly by the fact that it is an extension to E,
and thus it obeys E-syntax. Main differences:

- comments are with /* */ and not with ";", they have a different meaning.
- keywords and registers are in uppercase, everything is case sensitive
- no macros and other luxury assembler stuff (well, there's the complete
  E language to make up for that ...)
- You should be aware that registers A4/A5 may not be trashed by inline
  assembly code, as these are used by E code. Also, if your code
  can be called by code that is register-allocated, you should preserve
  D3-D7. an instruction like

	MOVEM.L D3-D7,-(A7); /* inline asm */; MOVEM.L (A7)+,D3-D7

  should help if problems occur.
- no support for LARGE model/reloc-hunks in assembly _YET_.
  This means practically that you have to use (PC)-relative addressing
  for now (which is faster anyway).


 Inline asm and register variables
-----------------------------------
 See @{"REG" link REG}
@endnode

@node REG
 Inline asm and register variables
-----------------------------------
register variables are a great companion to inline assembly, as
they function just as registers, but at the same time have clear
identifiers instead of Dx, and also are automatically saved and
restored by E code. example:

PROC bla()
  DEF count:REG
  MOVEQ #10,count
loop: @{"WriteF" link WriteF}('count=\d\n',count)
  DBRA count,loop
ENDPROC

all instruction that can work with a Dx EA, work with register
variables. examples:

MOVEQ #1,a
MOVEM.L D0/D1/a/b/A0,-(A7)
LSL.L a,b

etc.

as may be known, EC uses D3-D7 for these register variables. If you wish
to write code that freely mixes assembly with E, it's advisable to
keep longer-term values in register variables, and temporaries in
D0-D2/A0-A3/A6



 register allocation
---------------------
E v3 supports a register allocation, which is a technique to keep
variables in registers instead of on the stack. For normal code
that uses OS-routines you won't notice the difference very much,
but for tight computation-loops, this optimisation can make a big
difference. There are two ways to use register allocation:

- with the option REG.
  If you write for example EC REG=3 bla.e, (max=5, currently),
  EC will compute for each PROC the 3 most-used variables in
  registers. Register allocation is a technique that tries to be
  intelligent: it will compute for each var a weight, and will
  use heuristics to increase that weight, for example a var used
  in a FOR loop gets relatively a higher weight than one outside
  it, and one in an IF gets an even lower weight. These weights
  are combined, so a WHILE in a FOR gets quite a high weight.

- DIY: you can put the keyword REG in front of any type in a
  declaration, for example:

	@{"DEF" link DEF} x:REG, s[4]:REG @{"LIST" link LIST}

  you can do this if you don't trust the register-allocator,
  or if you want to fine-tune just one PROC. You can even use
  both together: if in a PROC you have one var with :REG,
  compiling with REG=5 will allow EC to pick the remaining 4
  by itself.

The default is REG=0, so EC works much like the older versions.

The variables that CAN be allocated are only local variables
that are not parameters. also, if you take the address of
a variable with {} it can't be put in a register either (guess
why...). registers can't be allocated in PROCs that have
an exception handler, for now.

There are a few things to note when using registers:
- this part of EC is currently (E v3.0a) was tested to
  be pretty reliable, but you still check that behaviour is
  the same as in non-allocated code.
  it _should_ work ok, but it's too early to guarantee it :-)
  In short: be careful for now when applying these techniques.
- EC uses registers D7..D3 for variables, so if you use
  inline assembly, you need to check that PROCs that use
  register-allocation or :REG don't trash these.
  The code generated for a PROC automatically saves the
  registers it uses (callee save) to protect the code that
  called it.
- hint: compiling with REG=5 is not inherently fastest,
  since variable saving on function/library calls also
  incurs an overhead. REG=3 may be better for some
  cases. Also if _all_ code in question deals with
  library calls instead of pure computation, expect no
  gain from registers.

-> register allocation will easily make this program twice as fast

PROC main()
  DEF a,b=10,c=20,d
  @{"FOR" link FOR} a:=1 TO 1000000 DO d:=b+c
ENDPROC

-> at most 5% faster when using register allocation

PROC main()
  DEF a,s[100]:STRING,t
  t:='putting "a" in a reg won''t give that much of a speedup, I think.'
  FOR a:=1 TO 100000 DO @{"StrCopy" link StrCopy}(s,t)
ENDPROC
@endnode

@node INCBIN
 ways using binary data 
------------------------
Syntax:		INCBIN <filename>

includes a binary file at the exact spot of the statement, should
therefore be separate from the code. Example:

mytab: INCBIN 'df1:data/blabla.bin'

@{"LONG" link LONG}, @{"INT" link INT}, @{"CHAR" link CHAR}

syntax:		LONG <values>,...
		INT <values>,...
		CHAR <values>,...

Allows you to place binary data directly in your program. Functions much
like DC.x in assembly. Note that the CHAR statement also takes strings,
and will always be aligned to an even word-boundary. Example:

mydata: LONG 1,2; CHAR 3,4,'hi folks!',0,1
@endnode

@node OPT
 the OPT keyword
-----------------

OPT, LARGE, STACK, ASM, NOWARN, DIR, OSVERSION, MODULE, EXPORT, RTD, REG

syntax:		OPT <options>,...

allows you to change some compiler settings:

LARGE		Sets code and data model to large. Default is small;
		the compiler generates mostly pc-relative code, with a
		max-size of 32k. With LARGE, there are no such limits,
		and reloc-hunks are generated.
STACK=x		Set stacksize to x bytes yourself. Only if you know what
		you are doing. Normally the compiler makes a very good
		guess itself at the required stack space.
ASM		Set the compiler to assembly mode. From there on, only
		assembly instructions are allowed, and no initialisation
		code is generated. (See @{"inline assembly" link assembly})
NOWARN		Shut down warnings. The compiler will warn you if it
		*thinks* your program is incorrect, but still syntactically
		ok.
DIR=moduledir	Sets the directory where the compiler searches for modules.
		default='emodules:'
OSVERSION=vers	Default=33 (v1.2). Sets the minimum version of the kickstart
		(like 37 for v2.04) your program runs on. That way, your
		program simply fails while the dos.library is being opened
		in the initialisation code when running on an older machine.
		However, checking the version yourself and giving an
		appropriate error-message is more helpful for the user.
MODULE		denotes this source to be a module. (see @{"MODULE" link MODULE})
EXPORT		automatically export all declarations in a module
RTD		generates RTD's instead of RTS in the main source.
		020+ only. [experimental optimisation]
020,881,040	generate code for these CPUs. not really usable yet.
REG=n		use n register for register-allocation.

example:

OPT STACK=20000,NOWARN,DIR='df1:modules',OSVERSION=39,REG=3
@endnode

@node preprocess
 EC PreProcessor
-----------------

EC has an internal preprocessor which features macro substitution and
conditional compilation. These are not features of the E language,
rather it has been integrated with EC for speed and flexibility.

Activating the preprocessor.
Until you type:

	@{"OPT" link OPT} PREPROCESS

EC will behave as normal. This OPT is necessary for any preprocessor
related feature.

Macros.
The macropreprocessor is compatible with Mac2E and the C language PP.
You can define macros as follows:

	#define MACRONAME
	#define MACRONAME BODY
	#define MACRONAME(ARG,...) BODY
	#define MACRONAME(ARG,...) BODY \
	  REST OF BODY

MACRONAME and ARG may be ANY case, and may contain "_" and 0-9 as usual.
Whitespace may be added everywhere, except between MACRONAME and "(", because
otherwise EC can't see the difference between arguments and a body.
The BODY may contain occurances of the ARGs. A macro may continue on the
next line by preceding the end_of_line with a "\".
[a macroname with no body is useful in combination with conditional
 compilation].

Macro identifiers have precedence over other identifiers.

Macro definitions defined in a module will be saved in the module only if
@{"OPT" link OPT} EXPORT is on (#define can't be preceded with @{"EXPORT" link EXPORT}). If that's a problem,
keep macros together in their own modules. Macros in modules can be used in
other code simply by importing them with @{"MODULE" link MODULE} and OPT PREPROCESS.


Using a macro.
Using MACRONAME anywhere in the program will insert the body of the macro
at that spot. Note that this substitution is text substitution, and has
little to do with actual E syntax. If the macros have arguments they will
be inserted at their respective places in the macrobody. If the body (or
the arguments) contain futher macros, these will be expanded after that.

example:

	#define MAX(x,y) (IF x>y THEN x ELSE y)

	@{"WriteF" link WriteF}('biggest = \d\n',MAX(10,a))

will equal writing:

	WriteF('biggest = \d\n',(IF 10>a THEN 10 ELSE a))

This immediately shows a danger of macros: since it simply copies
textually, writing MAX(large_computation(),1) will generate code
that executes large_computation() twice. Be aware of this.



Conditional compilation.
This can be useful if you wish to decide at compile time which part of
your code to use. syntax:

	#ifdef MACRONAME

or

	#ifndef MACRONAME

the piece of source following this will or won't be compiled depending on
whether MACRONAME was defined. you can simply do this with:

	#define MYFLAG

or somesuch. End a conditionally compiled block with:

	#endif

Blocks like these may be nested. example:

#define DEBUG
->#define HEAVYDEBUG

#ifdef DEBUG
  WriteF('now entering bla() with x = \d\n',x)
#ifdef HEAVYDEBUG
  WriteF('now dumping memory...\n')
  /* ... */
#endif
#endif
@endnode

@node #define
Syntax:	#define MACRONAME
    or  #define MACRONAME BODY
    or  #define MACRONAME(ARG,...) BODY
    or  #define MACRONAME(ARG,...) BODY \
          REST OF BODY

  See @{"PreProcessor (1)" link PreProcess 16},
      @{"PreProcessor (2)" link PreProcess 75}
@endnode

@node #ifdef
Syntax: #ifdef MACRONAME

  See @{"PreProcessor" link PreProcess 64},
      @{"#ifndef" link #ifndef},
      @{"#endif" link #endif}
@endnode

@node #ifndef
Syntax: #ifndef MACRONAME

  See @{"PreProcessor" link PreProcess 64},
      @{"#ifdef" link #ifdef},
      @{"#endif" link #endif}
@endnode

@node #endif
Syntax: #endif

  See @{"PreProcessor" link PreProcess 64},
      @{"#ifdef" link #ifdef},
      @{"#ifndef" link #ifndef}
@endnode
