@database OOEproject.guide
@master EMODULES:oomodules/OOEproject.guide
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "MAIN" "OOEproject.guide"
 This document explains the goals and current accomplishments of the Object
Oriented E Project, much of which was started by Joseph E. Van Riper III, but
loosely maintained by the Amiga E Encyclopedia folks in general.

 @{" Table Of Contents " link "Table_Of_Contents" 0}

 @{" Why " link "1." 0}
 @{" Caveats " link "2." 0}
 @{" Submissions " link "3." 0}
 @{" Implementation " link "4." 0}
 @{" The Plan " link "5." 0}
 @{" Notes from authors " link "6." 0}
@endnode

@node "Table_Of_Contents" " Table Of Contents "
MAIN@{" OOEproject.guide " link "MAIN" 0}
  1.@{" Why " link "1." 0}
  2.@{" Caveats " link "2." 0}
  3.@{" Submissions " link "3." 0}
  4.@{" Implementation " link "4." 0}
    4.1.@{" Object " link "4.1." 0}
      4.1.1.@{" Methods " link "4.1.1." 0}
    4.2.@{" Sort " link "sort/sort.guide/main" 0}
  5.@{" The Plan " link "5." 0}
  6.@{" Notes from authors " link "6." 0}
    6.1.@{" Joseph Van Riper " link "6.1." 0}
      6.1.1.@{" My OT History " link "6.1.1." 0}
      6.1.2.@{" OT Satori " link "6.1.2." 0}
    6.2.@{" Gregor Goldbach " link "6.2." 0}
@endnode

@node "1." "Why"
 OOEP was started because, as of this writing, the Amiga E programming
language, while very powerful, lacks a very comfortable, easily extensible
object library to take advantage of its Object Technology features.  So, while
you may program objects, you aren't getting the full benefits of Object
Technology.

So, you have the option of creating your own extensible set of objects and
whatnot on your own, which will take you a certain measure of time, or you can
use ours.  Since the source code is included, you can fix any bugs you might
stumble upon, or optimize anything that doesn't work quickly enough for you,
or otherwise improve the system in some way. Or, if you want, you may
contribute new objects to extend the system.  All of these should be sent to
the AEE (Amiga E Encyclopedia) folks for approval and submission to the
greater Amiga E audience.

With this set of objects, Amiga E can become a more friendly environment to
work with.

@endnode

@node "2." "Caveats"
 In building reusable code, and building it to be as extensible as this hopes
to be, one often finds him/herself having to make various tradeoffs.  This
almost always takes the form of speed vs. memory, although in the case of
reuse, sometimes it's speed/memory vs. reuse.

A case in point might be some of the stuff that will be done in the 'Numbers'
objects.  Both memory and speed will be used due to the coersion schemes to
convert sets of numbers to other sets of numbers.

Sometimes, you'll find the more classical Amiga E approaches to be stronger
than anything developed here.  If you need speed and efficiency or better use
of memory, and these modules don't exactly offer it for you, you may have to
build your objects a little more by scratch (say, perhaps, using Amiga E's
float numbers rather than our object 'Float').

The goals of this project is reuse and extensibility.  We attempt to make our
objects as efficient and memory-conserving as possible, but our primary goal
is reuse.

If there are any glaring problems (say, an object simply doesn't work
properly), we ask you either fix the problem yourself and send the AEE team
your fix (which will make you part of the AEE team <grin>) or make the AEE
team aware of the problem (many of them are also on the Amiga E mailing
list).

You'll note the comments in the code are somewhat lacking. We apologize for
this.. in the interest of getting this coded quickly, we dropped internal
documentation.  However, this document is intended to explain the attributes
and methods of each object in the library, so you may find your answers here.

@endnode

@node "3." "Submissions"
 You can submit extensions/corrections to this library through the AEE mailing
list or the Amiga E mailing list, or perhaps by ftp to Aminet dev/e.  Please
include an e-mailing address that we can contact you by, in case we have some
problems of some kind with your submission.

@endnode

@node "4." "Implementation"
 You'll note that this library comes with its own subdirectory 'oomodules'.
This subdirectory is an idea of Gregor, who started putting his devices
objects in it.  From this directory, you can find the hierarchy of objects
that make up this project.  You should put 'oomodules' in your emodules: set
of directories if you want to use them.. or recompile all the codes with your
own idea of how things should be set up.

If you make a correction in a higher-level object, all objects derived from
the corrected object will also need to be recompiled.  This is an unfortunate
result of the way Amiga E handles some of its internal stuff with the modules.
Therefore, if you make corrections to 'object', EVERYTHING would need to be
recompiled IN ORDER according to hierarchy.

We hope to get things right the first time <grin>.

In the following list, we'll outline each object and its methods.  As you
click deeper into the guide (or pay attention to the numbers preceding the
titles in the doc), you'll note that the methods from preceding objects are
automatically applied to the current objects.

And so, we start with the one object from which all other objects are
derived....

 @{"Object" link "4.1." 0}
 @{"Sort" link "sort/sort.guide/main" 0}
    @{"Library" link "EMODULES:oomodules/library/library.guide/main" 0}
      @{"ReqTools" link "EMODULES:oomodules/library/reqtools/reqtools.e" 0} - the source
      @{"Device" link "EMODULES:oomodules/library/device/device.guide/main" 0}
        @{"Printer" link "EMODULES:oomodules/library/device/printer/printer.guide/main" 0}
        @{"Trackdisk" link "EMODULES:oomodules/library/device/trackdisk/trackdisk.guide/main" 0}
        Keyboard - the source
        Audio - not working
@endnode

@node "6." "Notes from authors"
 As of this document, only one author has contributed to this project (mostly
because this author is trying to drag everyone else into it).  Hopefully, more
folks will catch on to this, and contribute useful objects into this system,
perhaps even improving this system for everyone's benefit.

This section of the document is included for special notes (perhaps pleas,
perhaps other things) from the various authors who submit work to this
daunting project.  If you're adding something to this document, please add
your name to the list.

NOTE: Currently, this document is design to work with Text2Guide by Stephan
Sürken, so those without AmigaGuide or MoreText can negotiate it.  It's
further modified either by hand or by a favorite AmigaGuide editor to include
other files (such as object.guide or whatever).

 @{" Joseph Van Riper " link "6.1." 0}
 @{" Gregor Goldbach " link "6.2." 0}
@endnode

@node "4.1." "Object"
 The Object object (hmm.. sounds redundant) has no attributes, and tons of
methods.

We may decide to create one or two very important global variables in the
future.  These variables will hold information on various system settings
which will allow a smoother halt() and some other handy functions.  At the
moment, though, no global variables exist in the Object module.

 @{" Methods " link "4.1.1." 0}
@endnode

@node "4.1.1." "Methods"
 All objects in this system will gain these methods.  Some should be
overridden with an object's preference.. others should be left alone.

        new(a)

This allows new instances of objects to be created.  It takes as an argument
an Amiga E list ['such','as','this'] which is then parsed by the opts()
method, which places a call to the 'select()' method.  My might want to read
up on those.

In general, you will only want to create new 'select()' statements for your
objects.. 'new()' most likely can be left alone.

Therefore, when folks go to use objects, they ought to do something like the
following:

NEW object.new()

or if there are options to parse...

NEW object.new(["boo",'SCREAM'])

        init()

This initializes an object to default startup values.  You very likely will
want to create your own init() method in your derived objects, in order to
properly initialize your attributes.  This init() method does nothing.  If
you're not concerned about the internal attributes during initialization, then
this method can be left alone.

        size()

This returns the SIZEOF the current object.  Most likely, this is a
superfluous method, and might need to be reconsidered.  In the meantime, if
you want this method to have any meaning at all, you need to calculate the
'SIZEOF' your object either by adding up all the attributes and adding four
more bytes (for the pointer to its methods), or by compiling the object and
using ShowModule to see the SIZEOF it comes up with.

        opts(a)

This runs a FOR/ENDFOR loop that calls 'select()'.  It's most unlikely that
you'll need to modify this method. This method may disappear in the future (it
might be absorbed by 'new()'.

        select(a,b)

You'll definately want to create a 'select' statement if you want new() to
have options enabled.  All select statements should have this general format:

PROC select(opts,i) OF myBlowOutObject
 DEF item
 item:=ListItem(opts,i)
 SELECT item
 -> various cases and perhaps a default.. could look like this:
 CASE "boo"
  INC i
  self.boo(ListItem(opts,i))
 ENDSELECT ENDPROC i

NOTE THE LAST LINE!  If you fail to return i, you could wind up with an
endless loop!  This would be a bad thing.

        error(a,b)

This calles err_WriteF(a,b) as it stands, and returns NIL. You may want to
overload this behavior to do something else, or perhaps call this from within
your own error() routine via SUPER.  The 'err_WriteF()' procedure was written
by Joseph E. Van Riper III as an easy kind of standard error port for Amiga
E... it should be found in the emodules:other directory of your structure..
but if you don't have it, you can get it from aminet:dev/e.

If err_WriteF() is ever called, the programmer must end hir main() program
with 'err_Dispose()' before exiting.  This is due to certain housekeeping
matters in Van Riper's StdErr port.

        name()

This method should be overloaded for each new class.  It should return a short
string of the name of the object.  In the object "object," it's called
'Object'.  This is useful for trying to track down certain internal things in
the system (particularly some of the really funky stuff in the Numbers
hierarchy).

        end()

This is the automatic deallocator.  Whenever an object is ENDed, this will be
called.  While the Object's 'end()' statement does nothing, other objects in
the hierarchy may be doing some kind of housekeeping before deallocating the
object.  If you do not know whether or not your parent object needs to do some
kind of housekeeping, do a SUPER self.end() somewhere within your own end()
statement (if you even need an end() statement).

        halt(a)

This is intended to stop the entire program dead in its tracks.  Use this with
extreme prejudice, as it doesn't bother to deallocate anything (yet), and will
likely leave filehandles open or memory allocated or any of a hundred other
horrible system-unfriendly things (it calls CleanUp(a)).

In the future, this statement will likely be used to Raise() an exception
rather than die.

        sameAs(a)

This method determines whether or not the current object is the same kind of
object as the parameter object.  'a' is assumed to be in the Object heirarchy
at some point. Basically, this simply compares self.name() to a.name() to see
if it's the same value.  It will return TRUE or FALSE accordingly.

        differentFrom(a)

This method determines whether or not the current object is a different kind
of object from the parameter object.  'a' is assumed to be in the Object
heirarchy at some point. Basically, this simply compares self.name() to
a.name() to see if it's a different value.  It will return TRUE or FALSE
accordingly.

        update(a)

This method currently does nothing, but the idea behind this method is to
cause the object to update itself (freshen its current information, perhaps).
You can use the included parameter any way you want.

@endnode

@node "5." "The Plan"
 There is, believe it or not, a general plan to all this. We're attempting to
apply as much of the GNU Smalltalk structure (with perhaps some additional
stuff out of IBM Smalltalk) as we can in our designs.  We acknowledge that we
cannot do things the same exact way (nor would we want to), but we are
attempting to loosely follow this plan.

So, VERY roughly, here's a road-map to some of the basic objects, and their
heirarchy, that we hope to have implemented and designed sometime in the
future.  Some of these have already been at least partially implemented,
although not many of them.

Object
 Logic
  Boolean
   Bitwise
  Categorical
 List
  QueueStack
  Bag
  TreeAVL
  Set
   Dictionary
 Sort
  Number
   Integer
   Real
   Fraction
    Complex
    Coordinate
  String
  DateStamp
   Time
    Hour
    Minutes
    Seconds
   Date
    Weekday
    Day
    Month
    Year
 Hook
 Library
  Device
   Stream
    Printer
    Serial
    File
    Console
    StdErr
    Clipboard
    Rexx
   Keyboard
   Timer
   Gameport
   Audio
  ReqTools
  IffParse
  Commodities
  GadTools
  Graphics
  Icon
  Keymap
  Layers
  Translator
  Utility
  Workbench

You can help!  Point out problems with this heirarchy, build some of these
objects, make out CRC cards or use-cases to get a better idea what we're up
against... help this come to fruition.  See @{"Submissions" link "3." 0} to get an idea of how
to contribute.

BTW: CRC cards might look something like the following:

-------------+ CLASS Object |
=============+================================================ Attributes:  |
-------------+

 [none]

-------------+------------------------------------------------ Methods:     |
-------------+
        new
        init
        size
        opts
        select
        error
        name
        end
        halt
        sameAs
        differentFrom
        update

--------------------------------------------------------------

They are intended to give an idea what the object is supposed to do, and how
it's supposed to do it.  They're only a tool towards developing the system.

@endnode

@node "6.1." "Joseph Van Riper"
 Most of the work in building objects for a system is in the design, not in
the programming; programming should be relatively simple once the analysis and
design is taken care of.  It is my sincere hope that this meager beginning
might help folks start developing a system that would work with the Amiga and
Amiga E, with elegance and efficiency.

Ultimately, I would like to see object equivalences to the entire Amiga OS
handled by these objects, but I cannot possibly do this on my own without
desiring to charge for the work <grin>.

In this way, I see this rather daunting project of developing a system of
objects for Amiga E as an excellent opportunity for the Amiga E Encyclopedia,
for as folks code examples of the OS, that same code can be re-written as
objects applicable to this project.

If Object Technology works as I understand it to work, this job will never be
completed.. only perfected.  As such, I am concerned that this project be
handled with as much responsibility and care as possible.  Please examine
documents carefully.  Please try to grok Object Technology, its advantages,
methodology issues, and other related matters as much as possible while you
contribute.

We may not be able to resurrect the Amiga from Commodore's flames, but we can
put up a good fight <grin>.

Those of you familiar with Smalltalk may notice some similarities in what I'm
trying to do and the GNU Smalltalk available for unix systems.  I've taken
many of the ideas and reapplied them.  Because this is not actually Smalltalk,
we have several significant differences in the way we handle things.  This is
normal.

 @{" My OT History " link "6.1.1." 0}
 @{" OT Satori " link "6.1.2." 0}
@endnode

@node "6.1.1." "My OT History"
 I've been trying to gather an understanding of Object Technology since 1990,
when I left the US military (I am honorably discharged, something I think of
as remarkable considering my distaste for the military).  I bought the Lattice
C++ compilor for $300, only to find Lattice had but one object with the
compilor... 'stream'.  I felt as if I'd been ripped off.

Now SAS owns Lattice, and no longer freely provides the technical support they
used to provide, something I consider horrid as the manuals are terribly
misleading, and the compilor will GURU if coaxed none-too-carefully.

Thus I started working with Amiga E.  Amiga E is faster, handles objects with
greater facility than C++, makes smaller code, and has the greatest bunch of
folks using it that one could ever hope for.  I'll admit that Amiga E has its
shortcomings, but that I have put Amiga E on my 40 meg harddrive and not SAS's
C++ compilor should speak volumes. My $35 for Amiga E feels better spent than
the $300 on SAS's C++.

I'm now taking Object Technology as a course at UNC-Asheville.  I'm probably
not going to do well in the course, though, because I can't stand the volumes
of busy-work this instructor loads the students with.  A three-credit hour
course does not require papers written each week on various readings we do...
and my ability to retain information is not so weak as to necessitate this
kind of work.  Unfortunately, I cannot seem to convince the instructor to ease
up, so I'll probably not do well.

None-the-less, I am learning what I want to learn from the course.  I figured
out fairly early (during my SAS C++ miseries) that the key to making Object
Technology work was not as much in the programming as the organization, but I
hadn't quite figured out the way to approach organizing what I wanted to do.

So I thought I'd try leaping into the whole mess with my first fairly
significant programming project for the Amiga, 'Quip'.  Some of you may have
seen it haunting Aminet... it lurks as a rather large, hulking entity, and
boasts itself as The Fortune Cookie Program from Hell.  The first version I
wrote was written in C++, although I took advantage of none of the object
features in the language, having been accustomed to procedural ways of
programming.  Thus, C++ was a failure for me, in terms of learning object
technology. Amiga E suffers from the same problem, frankly.  They are both
hybrid languages, incorporating both Object and Procedural methodologies.

I realized I wasn't really working with objects, so I attempted to reprogram
the entire thing as a set of objects. I made the classic OT programming
mistake of turning the main() part into a separate object and thinking "Object
Oriented".  I had done a little more than this, though, but ultimately I had
failed to really grasp it, and I could tell that my work was still somehow
'weak' in terms of programming elegance; I couldn't reuse my code very well.

It wasn't long after this that I abandoned programming for a long time,
concentrating on my music studies.  Eventually, I picked up the GNU C++
compilor, but I had to get rid of it, since it was taking up too much space on
my tiny harddrive.  Then I stumbled into Amiga E, which proved to be faster
than any compilor I'd run across on any platform.

I was saddened that Amiga E wasn't object oriented (this was the old 2.??
version).  I still had demands set up for myself for Quip, so I reprogrammed
the entire thing from scratch (this was at least the second or third time I
had done so), but I had to use procedural ways of doing things to avoid global
variables.  I STILL hadn't really grasped OT that well.  Considering some of
the comments I had made to Wouter, and that Wouter had had a chance to examine
some of my code before I finished it (in the process of hunting down errors I
perceived in his compilors.. I think the errors were mostly mine, as usual..
Wouter is the most patient programmer I have ever stumbled across) I sometimes
think I must have looked like a total dolt as far as Object Technology is
concerned.

I could tell I hadn't quite figured SOMETHING out, but I didn't really quite
grasp it until I picked up 'IBM Smalltalk; The Language' for my Object
Technology course.  I started reading some of it before the course started,
and suddenly figured out what my basic problem was, and how to go about
creating good objects.

When the course started, everything fell right into place. I had alread
grasped the single most difficult concept this way of programming threw to me,
and I was hungry for more information.

One might say that this attempt to create a system of objects for Amiga E and
the Amiga is the culmination of literally years of searching for The Way to
program in this kind of methodology.

@endnode

@node "6.1.2." "OT Satori"
 The trick to working with OT is in the design (as I mentioned before). Before
writing the first character of code, one must analyse and design what one is
attempting to do, and with what one must do it.

This is the biggest difference:  'with what one must do it'.

In the past, I had been trying to figure out 'how one must do it' rather than
'with what one must do it.'  The difference is staggering.  In fact, one
begins to find a greater ease in programming in an OT fashion than in the
older procedural way... the hard part becomes the analysis and design.

You find yourself building little objects, and ways for the little objects to
communicate to each other so they might, in a tiny little community that makes
up your program, get a specific set of tasks done.  Together, they form a kind
of community (or 'system' as the parlance goes).  The focus is on the data
you're trying to play with, and not on the actual "playing with the data".

I've already uploaded a couple of examples of the Object Technology approach,
by way of showing its benefits (and, hopefully, how to think about the matter
elegantly).  The best example prior to this starting project that I uploaded
was my most recent set of Quip objects (which are still not even close to
being done <sigh>, since I've been working on this project and a zillion other
things).  I urge you to examine that code (and this code) to get an idea of
what I'm up to.

@endnode

@node "6.2." "Gregor Goldbach"
Soon after founding the Amiga E Encyclopedia project (AEE), which this is a
part of, I got in touch with Trey. He told me of his OT plans for Amiga E and
almost instantly I felt that this was something I had to be part of.

Unluckily, I have almost no experience in OT programming. So everything you'll
see with my name on it is (at least by now) checked, tested and commented by
Trey.

To get things running I've coded (*not* designed) the device object and those
inheriting from it. They are in fact commented - I tried something like the
autodoc style. Judge for yourself :-)

The objects will now be designed, I'll try to base all my objects on the
'Object' object. Fortunately I've found a smalltalk so I am now able to learn
some 'real' OT programming. I hope I will.
@endnode

