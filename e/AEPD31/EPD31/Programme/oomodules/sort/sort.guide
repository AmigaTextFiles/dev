@DATABASE "Sort.guide"

@NODE MAIN "Sort.guide"

This document deals with the various objects derived from
the Sort object.

@{" Table Of Contents " Link Table_Of_Contents}

@{" Sort " Link 1.}
@ENDNODE

@NODE Table_Of_Contents " Table Of Contents "
MAIN@{" Sort.guide " Link MAIN}
  1.@{" Sort " Link 1.}
    1.0.@{" Methods " Link 1.0.}
    1.1.@{" Integer " Link 1.1.}
    1.2.@{" String " Link 1.2.}
    1.3.@{" Address " Link 1.3.}
@ENDNODE

@NODE 1. "Sort"

The sort object basically handles sortable objects.  Objects
that can be sorted in any way (alphanumerically,
numerically, category, etc) should be derived from Sort.
All one should really have to do to make their Sort object
work is to create a method 'cmp()', per below.

 @{" Methods " Link 1.0.}
 @{" Integer " Link 1.1.}
 @{" String " Link 1.2.}
 @{" Address " Link 1.3.}
@ENDNODE

@NODE 1.0. "Methods"

The following methods are found in all Sort objects:

        lt(a)

Less Than.. it checks to see if self is less than a.

        gt(a)

Greater Than.. checks to see if self is greater than a.

        et(a)

Equal To.. checks to see if self is equal to a.

        le(a)

Less Than Equal To.. checks to see if self is less than or
equal to a.

        ge(a)

Greater Than Equal To.. checks to see if self is greater
than or equal to a.

        ne(a)

Not Equal To.. checks ot see if self is not equal to a.

        cmp(a)

This does a comparison of a against self.  You will have to
overload this method yourself to make it really work.
Basically, you want it to return 1 if self is greater than
a, 0 if they're equal, and -1 if self is smaller than a.
This one method will cause all the above methods to work
properly, so you only need to define this to get everything
else working.

        set(a)

This sets the current object to a value of 'a'.  I think.

        write()

This returns an Estring representing the contents of the
current object.. if you've implemented it properly.  The
idea is to use this for stream i/o.  Very likely, the
details behind how stream i/o is handled by the object
hierarchy will change as we get to it.. but at the moment,
this simply returns a string.

        get()

This is intended to return the guts of the current object.
Often, the guts are speedier to work with than the string
representation.

        name()

This returns 'Sort'.

@ENDNODE

@NODE 1.1. "Integer"

In the future, this object will be absorbed into the Numbers
object (which is currently being designed).  Therefore,
we'll kind of gloss over this.  We needed an Integer object
of some kind, though, for the String object.

@ENDNODE

@NODE 1.2. "String"

This object is still being developed, but it should handle
anything that needs to be handled with strings.

String has two attributes, 'item' and 'len'.  'len' refers
to the length of the string in 'item'.  We thought it might
be faster to do things this way, rather than always
performing a StrLen()... however, we may change our minds
later (for the sake of memory).

	size()

Returns 12, which is the length of an instance of String.
Do not get this confused with 'length()', which returns the
length of the string.

	name()

This returns a pointer to some text that says 'String'.

	init()

This will initialize the integer 'len' to zero.

	select()

This enables new() for String.  Basically, if you want to
initialize a string during a NEW, just do the following:

NEW string.new(["set",'string'])

	end()

This deallocates both the string in item (via 'END') and the
integer in len (same way).

	cmp()

The comparison is handled by comparing the two strings byte
by byte until a byte is different from the other, or the end
of a string is reached.

This method enables all the other Sort methods associated
with cmp().

	set()

This allows you to set the string to a particular value.  If
we could use operators, this command would be ':='.  The
incoming parameter should be a pointer to a string.

	length()

This returns the length of the string.

	write()
	get()

Both of these return a pointer to the string itself.


@ENDNODE

@NODE 1.3. "Address"

This was meant mostly as an experiment.  It isn't terribly
functional, but serves mostly as an example of how one may
extend the Sort class of objects.

Address has five attributes:

 lname:  the last name of a person
 fname:  the first name of a person
 street: the street s/he lives on
 city:   the city s/he lives in
 phone:  hir phone number

	size()

This returns 48.

	name()

This returns a pointer to a string that says 'Address'.

	init()

This initializes as the attributes as string objects.

	select()

This is kind of ugly.  In fact, it may be a good argument
for using constants.  'select()' allows new() to process the
following arguments:

"set"

This sets lname to the following item.

"sfnm"

This sets fname to the following item.

"slnm"

This sets lname to the following item.

"scty"

This sets city to the following item.

"sstr"

This sets street to the following item.

"sphn"

This sets phone to the following item.

So, if you had an entire object to create, knowing all the
various parameters to fill:

NEW address.new(["sfnm",'Trey',"slnm",'Van Riper',
                 "scty",'Asheville, NC  28804',
		 "sstr",'Dortch Ave.',
		 "sphn",'(704) 555-8964'])

You'll notice that "set" and "slnm" do exactly the same
thing.

	setFname()

This actually sets fname.

	setLname()

This sets lname.

	set()

This calls setLname() with its parameter.

	setStreet()

This sets street.

	setCity()

This sets city.

	setPhone()

This sets phone.

	cmp()

This does the comparison.  It uses lname as the key, doing
an object-string type of comparison.

	length()

This returns the length of a string that would be returned
by a write() command.

	write()

Returns pointer to text formatted as below:

 Name: "[lname], [fname]"
 Street: [street]
 City: [city]
 Phone: [phone]

	end()

Deallocates all the strings by ENDing them.


@ENDNODE

