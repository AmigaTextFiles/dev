@DATABASE AMIGA_E_REFERENCE
@NODE MAIN  "Inhalt"
@{b}                               Amiga E v2.1b
@{ub}                        Compiler für Die E Sprache
                         Von Wouter van Oortmerssen
@INDEX INDEX
@{b}                            Sprache Referenz@{ub}
      @{"1. Format" LINK 1}
      @{"2. Unmittelbare Werte" LINK 2}
      @{"3. Ausdrücke" LINK 3}

                                                              @{"He Jörg!" LINK ANNOTATION}
@ENDNODE
@NODE ANNOTATION "Bemerkung"

Das hier wird also der Amiga-Guide in Deutsch. Wenn du die anderen Kapitel
hast, kannst du sie mir zuschicken, ich vervollständige den Guide dann.

@ENDNODE
@NODE INDEX "Index"

@{b}                               Amiga E v2.1b
@{ub}                        Compiler für Die E Sprache
                         Von Wouter van Oortmerssen

                            Sprach-Referenz Index


      @{"1. Format" LINK 1}
         @{"A. Tabs,lf usw." LINK TABS}
         @{"B. Kommentare" LINK COMMENTS}
         @{"C. Identifikatoren und Typen" LINK IDENT}
      @{"2. Unmittelbare Werte" LINK 2}
         @{"A. Dezimal (1)" LINK DEC}
         @{"B. Hexadezimal ($1)" LINK HEX}
         @{"C. Binär (%1)" LINK BIN}
         @{"D. Gleitpunkt (1.0)" LINK FLOAT}
         @{"E. Zeichen ('a')" LINK CHAR}
         @{"F. Zeichenketten ('bla')" LINK STRING}
         @{"G. Listen ([1,2,3]) und Typenlisten" LINK LISTS}
      @{"3. Ausdrücke" LINK 3}
         @{"A. Format" LINK 3A}
         @{"B. Vorrang und Zusammenfassung" LINK 3B}
         @{"C. Ausdrucksarten" LINK 3C}
         @{"D. Funktionsaufrufe" LINK 3D}

@ENDNODE
@NODE 1 "Format"

         @{u}1.FORMAT@{uu}                   

         @{"A. Tabs,lf usw." LINK TABS}
         @{"B. Kommentare" LINK COMMENTS}
         @{"C. Identifikatoren und Typen" LINK IDENT}


         @{"Vorheriges Kapitel" LINK 16}     @{"Nächstes Kapitel" LINK 2}
@ENDNODE
@NODE TABS "Format"
@{b}1A. Tabs,lf usw.@{ub}
----------------

Bitte Kapitel 1 einfügen!

@TOC 1
@ENDNODE
@NODE COMMENTS "Format"
@{b}1B. Kommentare@{ub}
--------------

Bitte Kapitel 1 einfügen!

@TOC 1
@ENDNODE
@NODE IDENT "Format"
@{b}1C. Identifikatoren und Typen@{ub}
-----------------------------

Bitte Kapitel 1 einfügen!

@TOC 1
@ENDNODE
@NODE 2 "Unmittelbare Werte"

         @{u}2.Unmittelbare Werte@{uu}

        Alle unmittelbare Werte in E ergeben ein 32-Bit Ergebnis; der
        einzige Unterschied zwischen den Werten (A-G) ist entweder ihre
        interne Darstellung oder die Tatsache, daß sie einen Zeiger statt
        eines Wertes zurückgeben.

         @{"A. Dezimal (1)" LINK DEC}
         @{"B. Hexadezimal ($1)" LINK HEX}
         @{"C. Binär (%1)" LINK BIN}
         @{"D. Gleitpunkt (1.0)" LINK FLOAT}
         @{"E. Zeichen ('a')" LINK CHAR}
         @{"F. Zeichenketten ('bla')" LINK STRING}
         @{"G. Listen ([1,2,3]) und Typenlisten" LINK LISTS}



         @{"Vorheriges Kapitel" LINK 1}     @{"Nächstes Kapitel" LINK 3}
@ENDNODE
@NODE DEC "Unmittelbare Werte"
@{b}2A. Dezimal (1)@{ub}
---------------
Ein dezimaler Wert ist eine Folge von Zeichen "0" .. "9", der
möglicherweise ein Minus "-" Zeichen vorangeht, um negative Zahlen
anzugeben. 
Beispiele: 1, 100, -12, 1024

@TOC 2
@ENDNODE
@NODE HEX "Unmittelbare Werte"
@{b}2B. Hexadezimal ($1)@{ub}
--------------------
Ein hexadezimaler Wert besteht aus den Zeichen "A" .. "F" (oder
"a" .. "f") mit vorangehendem "$" Zeichen.

Beispiele: $FC, $DFF180, -$ABCD

@TOC 2
@ENDNODE
@NODE BIN  "Unmittelbare Werte"
@{b}2C. Binär (%1)@{ub}
--------------
Binäre Zahlen beginnen mit einem "%" Zeichen und bestehen ansonsten
nur aus "1" und "0".
Beispiele: %111, %1010100001, -%10101

@TOC 2
@ENDNODE
@NODE FLOAT "Unmittelbare Werte"
@{b}2D. Gleitpunkt (1.0)@{ub}
--------------------
Gleitpunktzahlen unterscheiden sich von normalen dezimalen Zahlen
nur durch das "." Zeichen, das ihre beiden Abschnitte trennt. Einer
der beide Abschnitt kann ausgelassen werden, nicht beide. Man beachte,
daß Gleitpunktzahlen eine andere interne 32Bit (FFP) Darstellung
besitzen. Kapitel 12 enthält weitere Informationen über Gleitpunkt-
zahlen.
Beispiele: 3.14159, .1 (=0.1), 1. (=1.0)

@TOC 2
@ENDNODE
@NODE CHAR "Unmittelbare Werte"
@{b}2E. Zeichen ("a")@{ub}
-----------------
Der Wert eines Zeichens (eingeschlossen in doppelten "" Anführungs-
zeichen) ist sein ASCII-Betrag, z.B. "A" = 65. In E können
unmittelbare Zeichenwerte ein String mit bis zu 4 Zeichen sein,
z.B. "FORM", wobei das erste Zeichen "F" das MSB der 32Bit
Darstellung sein wird und "M" das LSB (least significant byte).

@TOC 2
@ENDNODE
@NODE STRING "Unmittelbare Werte"
@{b}2F. Zeichenkette ('bla')@{ub}
------------------------
Strings bestehen aus einer Folge von ascii-Zeichen, die in '' eingeschlossen
sind. Der Wert eines solchen Strings ist ein Zeiger auf sein erstes
Zeichen. Beispiel: 'bla' bringt einen 32Bit Zeiger hervor, der auf
einen Speicherbereich zeigt, in dem wir die Bytes "b", "l" und "a"
finden. ALLE Strings in E enden mit einem Null-Byte ("0").
Strings können Formatzeichen, die mit einem slash "\" eingeleitet
werden, enthalten. Entweder, um Zeichen einzubringen, die aus irgend-
einem Grund nicht darstellbar sind, oder zum Gebrauch in string-
formattierenden Funktionen, wie WriteF(), TextF(), und StringF(), oder
kick2 VprintF().

\n		ein Zeilenvorschub (ascii 10)
\a or ''	ein Apostrophe ' (Dasjenige, das auch Strings einschließt)
\e		escape (ascii 27)
\t		tab (ascii 9)
\\		ein backslash
\0		ein Null-Byte. Selten gebraucht, da ALLE strings mit 0 enden
\b		ein Wagenrücklauf (ascii 13)

Zusätzlich, beim Gebrauch in formattierenden Funktionen:

\d	drucken einer dezimalen Zahl
\h	drucken einer hexadezimalen Zahl
\s	drucken eines Strings
\c	drucken eines Zeichens
\z	Auffüllbyte auf '0' Zeichen setzen
\l	zur linken Seite des Feldes formattieren
\r	zur rechten Seite des Feldes formattieren

Folgende Feldbezeichner können \d, \h und \s folgen:

[x]	Genaue Feldgröße x festlegen
(x,y)	Minimalgröße x und Maximalgröße y festlegen (nur Strings)

Beispiel: Drucken einer hexadezimalen Zahl mit 8 Stellen und Nullen am Anfang:

zahl:=$ff
WriteF('\z\h[8]\n',zahl)  

ergibt:  $000000ff


Ein String kann sich über mehrere Zeilen erstrecken wenn die einzelnen
Teile mit einem '+' Zeichen und einem <lf> verbunden sind.

'Diser extralange String' +
'ersteckt sich über zwei Zeilen'

@TOC 2
@ENDNODE
@NODE LISTS "Unmittelbare Werte"
@{b}2G. Listen ([1,2,3]) und Typenlisten@{ub}
------------------------------------
Eine unmittelbare Liste ist das Gegenstück zum LIST datatypes, genau so wie
'string' das Gegenstück zum STRING oder ARRAY OF CHAR datatype. Beispiel:

[3,2,1,4]

ist ein Ausdruck, der als Wert einen Zeiger auf eine schon initialisierte
Liste hat. Eine Liste in ihrer Speicherrepresentation ist kompatibel mit
ARRAY OF LONG, mit etwas zusätzlicher Längeninformation an einem negativen
offset. Man kann diese unmittelbaren Listen überall dort verwenden, wo
eine Funktion einen Zeiger auf ein Feld von 32Bit Werten oder eine Liste
erwartet. Beispiele:

['string',1.0,2.1]
[WA_FLAGS,1,WA_IDCMP,$200,WA_WIDTH,120,WA_HEIGHT,150,TAG_DONE]

Im Unterkapitel über Listenfunktionen stehen weitere Informationen über
unmittelbare Typenlisten.

@TOC 2
@ENDNODE

@NODE 3 "Ausdrücke"

         @{u}3.AUSDRÜCKE@{uu}

         @{"A. Format" LINK 3A}
         @{"B. Vorrang und Zusammenfassung" LINK 3B}
         @{"C. Ausdrucksarten" LINK 3C}
         @{"D. Funktionsaufrufe" LINK 3D}



         @{"Vorheriges Kapitel" LINK 2}     @{"Nächstes Kapitel" LINK 4}
@ENDNODE
@NODE 3A  "Ausdrücke"
@{b}3A. Format@{ub}
----------
Ein Ausdruck ist eine Stück Quellcode, der aus Operatoren, Funktionen und
Klammern besteht, und einen Wert ergibt.

Ausdrücke bestehen größtenteils aus:

- Unmittelbaren Werten, wie in Kapitel 2 beschrieben
- Operatoren, wie in Kapitel 4 beschrieben
- Funktionsaufrufen, wie in Kapitel 3D beschrieben
- Klammern (), wie in Kapitel 3B beschrieben
- Variablen oder Variablen-Ausdrücken (siehe 3C)

Beispiele für Ausdrücke:

1
'hallo'
$ABCD+(2*6)+Abs(a)
(a<1) OR (b>=100)

@TOC 3
@ENDNODE
@NODE 3B "Ausdrücke"
@{b}3B. Vorrang und Zusammenfassung@{ub}
-------------------------------
Amiga_E hat keine Vorrang-Rechnung oder etwas ähnliches. Das
heißt, das Ausdrücke von links nach rechts ausgewertet werden. Man kann das
durch die Einklammerung von (Teil-)Ausdrücken vermeiden:
1+2*3 /* =9 */     1+(2*3) /* =7 */       2*3+1  /* =7 */

@TOC 3
@ENDNODE
@NODE 3C "Ausdrücke"
@{b}3C. Ausdrucksarten@{ub}
------------------
Es gibt verschiedene Ausdrucksarten, die für unterschiedliche Zwecke
benutzt werden können:

- <var>, bestehend aus nur einer Variablen
- <varexp>, bestehend aus einer Variablen, möglicherweise mit unary operators,
  wie ++ (erhöhen) oder [] (Feld Operator). Weitere Informationen darüber stehen
  in den Kapiteln 4D und 4G. <varexp> macht veränderbare Ausdücke möglich,
  so wie Lvalues in C.
  Man beachte, daß diese (unary) Operatoren keinen Vorrang vor anderen
  Operatoren haben.
- <exp>. Schließt <var> und <varexp> sowie jeden anderen Ausdruck ein.

@TOC 3
@ENDNODE
@NODE 3D "Ausdrücke"
@{b}3D. Funktionsaufrufe@{ub}
--------------------
Ein Funktionsaufruf stellt eine Unterbrechung des momentanen Quelltextes
dar, in der eine Funktion angesprungen wird. Dies kann entweder eine
selbstgeschriebene Funktion (PROC), oder eine Funktion die vom System zur
Verfügung gestellt wird sein. Ein Funktionaufruf besteht aus dem Funktionsnamen,
gefolgt von null bis unendlich vielen Argumenten, die in zwei Klammern ()
eingeschlossen sind und von Kommata "," getrennt werden.
Man beachte, daß die Argumente einer Funktion wiederum Ausdrücke sind.
In Kapitel 6 steht, wie man seine eigenen Funktioen erstellt, Kapitel 9 und
10 behandeln die eingebauten Funktionen. Beispiele:

meinefunktion(1,2)
Gadget(buffer,glist,2,0,40,80+offset,100,'Abbruch')
Close(handle)

@TOC 3
@ENDNODE
@NODE 14 "Objekt-Orientierte Programmierung"

         @{u}14.OBJEKT-ORIENTIERTE PROGRAMMIERUNG@{uu}


         Da OOP noch nicht eingebaut ist, kann sie auch nicht dokumentiert
         werden.



         @{"Vorheriges Kapitel" LINK 13}     @{"Nächstes Kapitel" LINK 15}
@ENDNODE

@ENDNODE