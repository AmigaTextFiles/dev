
+---------------------------------------------------------------+
|                       2.UNMITTELBARE WERTE                    |
|                         IMMEDIATE VALUES                      |
+---------------------------------------------------------------+

Alle unmittelbare Werte in E ergeben ein 32-Bit Ergebnis; der
einzige Unterschied zwischen den Werten (A-G) ist entweder ihre
interne Darstellung oder die Tatsache, daß sie einen Zeiger statt
eines Wertes zurückgeben.

2A. Dezimal [decimal] (1)
------------------------
Ein dezimaler Wert ist eine Folge von Zeichen "0" .. "9", der
möglicherweise ein Minus "-" Zeichen vorangeht, um negative Zahlen
anzugeben. 
Beispiele: 1, 100, -12, 1024

2B. Hexadezimal [hexadecimal] ($1)
----------------------------------
Ein hexadezimaler Wert besteht aus den Zeichen "A" .. "F" (oder
"a" .. "f") mit vorangehendem "$" Zeichen.

Beispiele: $FC, $DFF180, -$ABCD

2C. Binär [binary] (%1)
-----------------------
Binäre Zahlen beginnen mit einem "%" Zeichen und bestehen ansonsten
nur aus "1" und "0".
Beispiele: %111, %1010100001, -%10101

2D. Gleitpunkt [float] (1.0)
----------------------------
Gleitpunktzahlen unterscheiden sich von normalen dezimalen Zahlen
nur durch das "." Zeichen, das ihre beiden Abschnitte trennt. Einer
der beide Abschnitt kann ausgelassen werden, nicht beide. Man beachte,
daß Gleitpunktzahlen eine andere interne 32Bit (FFP) Darstellung
besitzen. Kapitel 12 enthält weitere Informationen über Gleitpunkt-
zahlen.
Beispiele: 3.14159, .1 (=0.1), 1. (=1.0)

2E. Zeichen [character] ("a")
-----------------------------
Der Wert eines Zeichens (eingeschlossen in doppelten "" Anführungs-
zeichen) ist sein ASCII-Betrag, z.B. "A" = 65. In E können
unmittelbare Zeichenwerte ein String mit bis zu 4 Zeichen sein,
z.B. "FORM", wobei das erste Zeichen "F" das MSB der 32Bit
Darstellung sein wird und "M" das LSB (least significant byte).

2F. Zeichenfolge [string] ('bla')
---------------------------------
Strings bestehen aus einer Folge von ascii-Zeichen, die in '' eingeschlossen
sind. Der Wert eines solchen Strings ist ein Zeiger auf sein erstes
Zeichen. Beispiel: 'bla' bringt einen 32Bit Zeiger hervor, der auf
einen Speicherbereich zeigt, in dem wir die Bytes "b", "l" und "a"
finden. ALLE Strings in E enden mit einem Null-Byte ("0").
Strings können Formatzeichen, die mit einem slash "\" eingeleitet
werden, enthalten. Entweder, um Zeichen einzubringen, die aus irgend-
einem Grund nicht darstellbar sind, oder zum Gebrauch in string-
formattierenden Funktionen, wie WriteF(), TextF(), und StringF(), oder
kick2 VprintF().

\n		ein Zeilenvorschub (ascii 10)
\a or ''	ein Apostrophe ' (Dasjenige, das auch Strings einschließt)
\e		escape (ascii 27)
\t		tab (ascii 9)
\\		ein backslash
\0		ein Null-Byte. Selten gebraucht, da ALLE strings mit 0 enden
\b		ein Wagenrücklauf (ascii 13)

Zusätzlich, beim Gebrauch in formattierenden Funktionen:

\d	drucken einer dezimalen Zahl
\h	drucken einer hexadezimalen Zahl
\s	drucken eines Strings
\c	drucken eines Zeichens
\z	Auffüllbyte auf '0' Zeichen setzen
\l	zur linken Seite des Feldes formattieren
\r	zur rechten Seite des Feldes formattieren

Folgende Feldbezeichner können \d, \h und \s folgen:

[x]	Genaue Feldgröße x festlegen
(x,y)	Minimalgröße x und Maximalgröße y festlegen (nur Strings)

Beispiel: Drucken einer hexadezimalen Zahl mit 8 Stellen und Nullen am Anfang:

zahl:=$ff
WriteF('\z\h[8]\n',zahl)  

ergibt:  $000000ff


Ein String kann sich über mehrere Zeilen erstrecken wenn die einzelnen
Teile mit einem '+' Zeichen und einem <lf> verbunden sind.

'Diser extralange String' +
'ersteckt sich über zwei Zeilen'


2G. Listen ([1,2,3]) und Typenlisten
-------------------------------------
Eine unmittelbare Liste ist das Gegenstück zum LIST datatypes, genau so wie
'string' das Gegenstück zum STRING oder ARRAY OF CHAR datatype. Beispiel:

[3,2,1,4]

ist ein Ausdruck, der als Wert einen Zeiger auf eine schon initialisierte
Liste hat. Eine Liste in ihrer Speicherrepresentation ist kompatibel mit
ARRAY OF LONG, mit etwas zusätzlicher Längeninformation an einem negativen
offset. Man kann diese unmittelbaren Listen überall dort verwenden, wo
eine Funktion einen Zeiger auf ein Feld von 32Bit Werten oder eine Liste
erwartet. Beispiele:

['string',1.0,2.1]
[WA_FLAGS,1,WA_IDCMP,$200,WA_WIDTH,120,WA_HEIGHT,150,TAG_DONE]

Im Unterkapitel über Listenfunktionen stehen weitere Informationen über
unmittelbare Typenlisten.



+---------------------------------------------------------------+
|                         3. AUSDRÜCKE  			|
|                            EXPRESSIONS 			|
+---------------------------------------------------------------+

3A. Format [format]
-------------------
Ein Ausdruck ist eine Stück Quellcode, der aus Operatoren, Funktionen und
Klammern besteht, und einen Wert ergibt.

Ausdrücke bestehen größtenteils aus:

- Unmittelbaren Werten, wie in Kapitel 2 beschrieben
- Operatoren, wie in Kapitel 4 beschrieben
- Funktionsaufrufen, wie in Kapitel 3D beschrieben
- Klammern (), wie in Kapitel 3B beschrieben
- Variablen oder Variablen-Ausdrücken (siehe 3C)

Beispiele für Ausdrücke:

1
'hallo'
$ABCD+(2*6)+Abs(a)
(a<1) OR (b>=100)

3B. Vorrang-Rechnung und Zusammenfassung
----------------------------------------
Amiga_E hat keine Vorrang-Rechnung oder etwas ähnliches. Das
heißt, das Ausdrücke von links nach rechts ausgewertet werden. Man kann das
durch die Einklammerung von (Teil-)Ausdrücken vermeiden:
1+2*3 /* =9 */     1+(2*3) /* =7 */       2*3+1  /* =7 */

3C. Ausdrucksarten
------------------
Es gibt verschiedene Ausdrucksarten, die für unterschiedliche Zwecke
benutzt werden können:

- <var>, bestehend aus nur einer Variablen
- <varexp>, bestehend aus einer Variablen, möglicherweise mit unary operators,
  wie ++ (erhöhen) oder [] (Feld Operator). Weitere Informationen darüber stehen
  in den Kapiteln 4D und 4G. <varexp> macht veränderbare Ausdücke möglich,
  so wie Lvalues in C.
  Man beachte, daß diese (unary) Operatoren keinen Vorrang vor anderen
  Operatoren haben.
- <exp>. Schließt <var> und <varexp> sowie jeden anderen Ausdruck ein.

3D. Funktionsaufrufe
--------------------
Ein Funktionsaufruf stellt eine Unterbrechung des momentanen Quelltextes
dar, in der eine Funktion angesprungen wird. Dies kann entweder eine
selbstgeschriebene Funktion (PROC), oder eine Funktion die vom System zur
Verfügung gestellt wird sein. Ein Funktionaufruf besteht aus dem Funktionsnamen,
gefolgt von null bis unendlich vielen Argumenten, die in zwei Klammern ()
eingeschlossen sind und von Kommata "," getrennt werden.
Man beachte, daß die Argumente einer Funktion wiederum Ausdrücke sind.
In Kapitel 6 steht, wie man seine eigenen Funktioen erstellt, Kapitel 9 und
10 behandeln die eingebauten Funktionen. Beispiele:

meinefunktion(1,2)
Gadget(buffer,glist,2,0,40,80+offset,100,'Abbruch')
Close(handle)





+---------------------------------------------------------------+
|               14. OBJEKT-ORIENTIERTE PROGRAMMIERUNG           |
|                   OO PROGRAMMING			        |
+---------------------------------------------------------------+

Da OOP noch nicht eingebaut ist, kann sie auch nicht dokumentiert
werden.
