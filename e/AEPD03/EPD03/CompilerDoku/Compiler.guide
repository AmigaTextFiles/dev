@DATABASE Amiga_E_guide_comp
@NODE MAIN "Contents"
		+-----------------------------------------------+
		|						|
		|                 Amiga E v2.1b                 |
		|          Compiler for The E Language          |
		|           By Wouter van Oortmerssen           |
		|						|
 		|          Introduction - Installation          |
		|						|
		+-----------------------------------------------+

	NOTE: Amiga E v2.1b is a bug-fix update, and it's functionally
	      identicall to v2.1a, see chapter 4 for an overview.

			contents:

                        @{"1. Introduction, The features" LINK INTRO}
                        @{"2. The distribution" LINK DISTRIB}
                        @{"3. Using the compiler" LINK USING}
                        @{"4. Changes from v2.1 to v2.1b" LINK CHANGES}
                        @{"5. Additional information" LINK ADDITIONAL}
@ENDNODE

@NODE INTRO "Introduction"
		+-----------------------------------------------+
		|         1. INTRODUCTION: THE FEATURES         |
		+-----------------------------------------------+

E is a procedural higher programming language, mainly influenced by
languages such as C and Modula2. It is an all-purpose programming language,
and the Amiga implementation is specifically targeted at programming
system applications. The major features of the language/this implementation
include:

- Compilation speed of 10.000 to 35.000 lines/minute on a 7mhz Amiga 500,
  25.000 to 85.000 l/m on a 14mhz Amiga 1200 (both _without_ fastram)
  Faster than any other Amiga compiler.
- Produces small and fast executables from source code in one go: linker,
  assembler and other program modules integrated into the compiler
  Very fast turnaround times even when running from your own editor.
- True Inline Assembly with identifier sharing: a complete assembler
  has been build in to the language that interfaces with E in a
  natural fashion. However, assembly in E is 100% optional.
- Module system for import of library definitions/constants/functions
  (much like TurboPascals UNITs); a large set of pre-compiled modules
  provide for great programming power and extendability.
  _All_ commodore's 2.04 includes available as E modules (E is
  still v1.3 compatible though).
- Large amount of integrated system functions: OpenW(), OpenS(),
  Gadget(), WriteF(), TextF(), and numerous string/list/IO functions.
- All library calls of Exec, Dos, Intuition and Graphics of 2.04
  integrated as system functions into the compiler: call them without
  opening the library or including files. All other libraries accessible too.
- Flexible and powerful "type" system: one basic non-complex 32bit
  LONG variable, and datatypes ARRAY, STRING, LIST and OBJECT,
  code-security and generality through low-level polymorphism.
- LISP functionality: quoted expressions, functions like
  Eval(), ForAll(), Exists(): Implement algorithms that would
  normally require lambda-functions.
- immediate lists, typed lists: build complex data structures with
  all sort of data directly in expressions, make TagLists, structures,
  vararg function calls on the fly
- exception handling a la ADA
  provide handlers on all kinds of levels in programs, define
  automatic exception raising for often used functions like
  memory allocations, and implement complex resource allocation
  schemes with ease through recursive calls of handlers.
- compiles compact small programs with SMALL code/data model and large
  applications with LARGE model in seconds
- Manageable development system: one executable (the compiler/assembler/
  linker) and optionally a set of Module files is all you will need.

Negative points:
- some features not (yet) implemented, like: OOP, creation of own modules,
  source level debugger etc.
- *very* memory hungry: you're advised to have a minimum memory of 1 meg.
  on 512k machines, it's likely you won't get any further than helloworld;
  from 2 meg upwards, E works comfortably.
- no 020/030/040/881 specific code-generation (yet).
- Documentation on E starts to get better, but still very small.

If these features haven't made you anxious to use E,
I suggest you test-drive the compiler after reading this doc
to "feel the power" yourself.
This is what 'HelloWorld' looks like in E:

/* nominated for Most Boring Example */

PROC main()
  WriteF('Hello, World!\n')
ENDPROC

@ENDNODE
@NODE DISTRIB  "Distribution"

		+-----------------------------------------------+
		|             2. THE DISTRIBUTION               |
		+-----------------------------------------------+


Next to this .doc, you will find these three docs about E:

Reference.doc	Overview of the language.
Tutorial.doc	A step by step tutorial about programming in E.
Utilities.doc	description of support utilities that come with E and
		some example sources.

Besides the above-mentioned doc files, the distribution should include:

BIN		contains the compiler EC and the support utilities
MODULES		Directory containing all Amiga 2.04 E modules.
DOCS		all documentation on E
SOURCES		/EXAMPLES	simple examples for you to try
		/UTILITIES	a directory with utilities, some supporting
				the compiler, all written in E
		/PROJECTS	other, larger examples in E
		/OTHER		example sources written by other authors

This distribution should always be spread as a whole, with no
additions or modifications.

@ENDNODE
@NODE USING  "Using the Compiler"

		+-----------------------------------------------+
		|            3. USING THE COMPILER              |
		+-----------------------------------------------+

To install Amiga E on your system, just copy the whole distribution to
some place in your system, extend your path to the BIN directory, and
assign EMODULES: to the MODULES directory.

syntax of the compiler:

EC [-opts] <sourcefile>

As an example we'll compile the program 'HelloWorld.e'. The compiler will
produce an executable 'HelloWorld'. Notez bien: the missing '.e' on
the commandline is _obligatory_.


1>  ec helloworld
Amiga E Compiler/Assembler/Linker v1.8 (c) 1992 $#%!
CONGRATULATIONS !!!  NO ERRORS !!!
1>  helloworld
Hello, World!
1>  list
HelloWorld.e                  88 ----rwed Sunday    00:08:41
helloworld                   512 ----rwed Today     10:51:37
2 files - 4 blocks used


Last note on compiling the examples: if a program uses module files
for library definitions like:

MODULE 'GadTools', 'Reqtools'

the compiler needs to know where to find them. Two possible solutions:
1. you make the assignment "emodules:" to the modules directory (best).
2. you state in the source code where to look for modules, like:
   OPT DIR='dh0:src/e/modules'

Options.
these need to be written together, preceded by a "-":
-l	compiles with large code/data model. see OPT LARGE
-a	puts EC into assembler mode. see OPT ASM
-n	suppresses warnings. see OPT NOWARN
-w	puts wb to front (for scripts)
-b	shows buffer's memory usage information
-mX	forces EC to allocate more memory for its buffers.
	X ranges 1..9, the minimum number of 100k blocks to allocate.
        default is 1.

example:  EC -l blabla
compiles blabla.e with large model.
NOTE: in most standard cases you won't need to use any of these options

@ENDNODE
@NODE CHANGES  "Changes from v2.1 to v2.1b"
		+-----------------------------------------------+
		|         4. CHANGES FROM v2.1 TO v2.1b         |
		+-----------------------------------------------+

What's new in v2.1b:

BUG FIXES:
[ The primary goal for this release: v2.1 was already very stable,
v2.1b should be even better now. ]

- typed lists with expressions in them on CHAR fields would
  give unwanted results, i.e. [x+1]:CHAR
- The SELECT statement gave unwanted results in some nested
  constructions
- A RETURN statement within a HANDLE EXCEPT block was not
  properly supported.
- the label "main" could not be used like other labels, i.e.
  {main} gave an error.
- Exists() could give the wrong result.
- bug fixed in "D.e" source
- EC's command-line parsing didn't work well with some exotic shells.
- the "-r" option has been discarded


ENHANCEMENTS:
[ no "real" enhancements here, just the ones that came along ]

- Docs have been revised somewhat
- Even more examples. Especially worth mentioning:
  - the new version of ShowHunk.e by Jim Cooper that now understands just
    about ALL hunks, and features a complete disassembler (!)
  - The various tools/examples written by Diego Caravana
  - A new music programming language written by me.
- '' is now an equivalent for \a in strings.
- Rnd() now accepts a seed
- function ListItem() added.

Note about versions:
It's very likely that v2.1b is the last version that will be released
until v2.5 (major update!) comes out, for which no price has been set yet.

@ENDNODE
@NODE ADDITIONAL  "Additional Information"
		+-----------------------------------------------+
		|          5. ADDITIONAL INFORMATION            |
		+-----------------------------------------------+

The Amiga E Compiler was developed over the course of more than one and a
half year, after the author's idea of the ideal programming language, and
the ideal amiga-specific compiler for it. It was programmed (as you might
have guessed) in assembly, using the AsmOne assembler v1.02. All other
support programs were written in E itself.

Special thanks go to the following people/companies:

RCS Management, Canada.
Rob Verver - for continuous betatesting and comments/inspiration.
James Cooper (SAS) - for testing enforcer/mungwall-proofness, comments
  and his contributions to the system.
Jens Gelhar - for inspiration and advice.
  [ buy his great C++ compiler! (MaxonC++)  8-) ]

I also would like to thank the following people for their efforts:

Raymond Hoving, Erwin van Breemen, Paolo Silvera,
Diego Caravana, Jeroen Vermeulen and Jan van den Baard.

This compiler was programmed with great care towards reliability, and even
more so the code it generates, additionally it has been tested and
debugged for a long period. However, it is not impossible that it contains
bugs. if you happen to find one, or have other comments/questions,
write me at the address below: I _strongly_ prefer E-mail above
conventional mail.

NOTE WELL: due to the immense popularity of the previous version of
Amiga E, I get an almost unreplyable amount of Email, some of which
(50-75%) are questions that would not have been necessary if people
read all the docs carefully. What I mean to say is that I like
to receive Email, and I don't mind answering questions and helping
people out with programming problems, but be sure to check all other
information at your disposal (like the Amiga E docs or the RKRM's) to
see if your question is relevant, before mailing me.

I don't ask for any contributions (this is (still) PD, after all), but
if you can afford it and you really like Amiga E, I suggest you send me a
donation that you think is appropriate.


	Wouter van Oortmerssen ($#%!)
	Levendaal 87
	2311 JG  Leiden
	HOLLAND

or better if you have access to Email:

	Wouter@alf.let.uva.nl		(E-programming support)
	Wouter@mars.let.uva.nl		(personal)
	Oortmers@gene.fwi.uva.nl	(other)
@ENDNODE
