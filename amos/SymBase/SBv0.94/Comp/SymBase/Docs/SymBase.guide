@DATABASE SymBase
@$VER 0.85 (2001.11.26)
@Node MAIN "SymBase V0.85"

                        S y m B a s e
                        _____________

@{B}Database programming environment for Amos Pro.
@{UB}

System last updated: 2005.04.19.
Guide last updated : 2005.12.13.

        @{" Overview              " Link "Overview"}
        @{" What is an extension? " Link "About Extensions"} - Short explanation about Amos extensions.
        @{" SymBase features      " Link "Features"} - Capabilities of the current version.
        @{" How to install?       " Link "install"} - How could you starting to use.
        @{" Database handling     " Link "database"} - About the database handling in general.
        @{" Structures            " Link "struct"}

        @{" SymBase statements " Link "Statements"} - new statements.
        @{" SymBase Server     " Link "server"} - Arexx server commands
        @{" SymBase procedures " Link DB_Proc.Guide/Main} - which will moving under the prev. link
        @{" SymBase tools      " Link "tools"} - external programs

        @{" Disclaimer " Link "Disclaimer"}
        @{" Future     " Link "Future"}
        @{" History    " Link "History"}
        @{" Bugs       " Link "Bugs"}
        @{" Author     " Link "Author"}


@EndNode
@Node "About Extensions"
(from the file: |Music.s by Francois Lionet)

; >>> What's an extension?
;
; An extension to AMOS is a machine language program that adds new
; instructions to the already huge AMOS instruction set. This system is
; designed to be as powerfull as AMOS itself: the extension includes its
; own token list, its own routines. It can even access some main AMOS
; routines via special macros. It has a total access to the internal AMOS
; data zone, and to the graphic library functions.

Using SymBase, this added instructions gives the ability of Dbase database
handling to Amos programs.
@EndNode

@Node "Overview"
@WORDWRAP
@SMARTWRAP
SymBase overview

 This package is a relational database managing system. With it, you can create and store databases, manipulate its contents and structure. You can develop database programs, with the included Amos extension. You don't need to learn any database language. Your existing Amos experiences will help you to develop the program, which using databases.

 The package contains some external program besides the extension. Those tools are to help programming jobs.

 (The Amos is an outdated programming language, which can't keep its abilities with the AGA chip set, and it will useless when the P-OS arrives. In the present version's core is the Amos, because it has the largest part of my experiences.)

 The above is written at the beginning of the project. Some things changed since then. There is a group who taking care of Amos. The next generation Amiga is a vapor, and there is still no other alternative choice for a great computer beside my loved Amiga. So, I don't want to port my code to anywhere. Yes, I loose my mind as early as I got my first Amiga.

 The whole project started as a billing, and inventory program, for our little shop. If you looking for about a similar application, feel free to contact @{"me" Link "Author"}.

@EndNode

@Node "Features"

- the used database file is Xbase compatible
- internal routines are written in assembly, so it must be fast;
- you can open up to 65000 file at a time;
- not tested on animals;
- in the development not used any M$ product;

@EndNode

@Node "Install"
@WORDWRAP

The simplest and recommended way is to using the Install_SymBase script.

@{B}Manual installation:@{UB}
If you have any problem with the installer script, or you don't want to use that, you must install the components of SymBase manually.
Every SymBase related file lying under the Comp/Symbase folder. You can simply copy that folder.

The AmosPro extension's name is: SBASE_EX. To use this, copy to the AmosProSystem:Apsystem/ folder, and use the 'Set Interpreter' from the 'Config' menu of AmosPro editor.
In the configuration programm type 'SBASE_EX' to the 21th extension slot. 

@EndNode

@Node "database"
@{B}Database handling@{UB}


@EndNode

@Node "Statements"
@{B}SymBase extension statements@{UB}

@{B}Instructions:@{UB}

 @{" Db Use          " Link "db_use"} - opens a database
 @{" Db Close        " Link "db_close"} - closes an opened database
 @{" Db Saved On     " Link "db_saved"} - sets the record state
 @{" Db Saved Off    " Link "db_saved"} - sets the record state
 @{" Db Select       " Link "db_select"} - selects a given channel
 @{" Db Select First " Link "db_select"} - select the first used channel
 @{" Db Select Next  " Link "db_select"} - select the first unused channel
 @{" Db Goto         " Link "db_goto"} - record positioning
 @{" Db Put          " Link "db_put"} - puts data to a field
 @{" Db Append       " Link "db_append"} - add a new record
 @{" Db Append Blank " Link "db_append"}
 @{" Db Swap         " Link "db_swap"} - swap two record
 @{" Db Delete       " Link "db_delete"} - delete the current record
 @{" Db Recall       " Link "db_recall"} - recall a deleted record
 @{" Db Pack         " Link "db_pack"} - remove deleted records
 @{" Db Zap          " Link "db_zap"} - remove all records
 @{" Db Skip         " Link "db_skip"} - step to the next record
 @{" Db Cutspace On  " Link "db_cutspace"} - Turn on/off the trailing spaces of the field datas
 @{" Db Setdeleted On" Link "db_setdel"} - Turn on/off the deleted records
 @{" Db Notify       " Link "db_notify"} - Flushes database and allow notification
 @{" Db Locate       " Link "db_locate"} - Searching record by record
 @{" Db Continue     " Link "db_continue"} - Search for the next occurence
 @{" Db Header Update" Link "db_headerupdate"} - Controls the number of records data update in the header

@{B}Functions:@{UB}

 @{" =Db Flen()    " Link "db_flen"} - length of each field
 @{" =Db Ftype()   " Link "db_ftype"} - type of the data
 @{" =Db Field$()  " Link "db_field$"} - the name of the given field
 @{" =Db Field()   " Link "db_field"} - the number of the named field
 @{" =Db Get$()    " Link "db_get"} - the contents of a field
 @{" =Date Diff()  " Link "date_diff"} - Difference between two dates in days
 @{" =Date Valid() " Link "date_valid"} - Cheks the validity of a date string

@{B}System variables:@{UB}

 @{" Db Sel       " Link "db_sel"} - number of the work area
 @{" Db Address   " Link "db_address"} - address of the internal date zone
 @{" Db Fieldno   " Link "db_fieldno"} - number of the fields
 @{" Db Recsaved  " Link "db_recsaved"} - state of the record
 @{" Db Opencount " Link "db_opencount"} - return the number of used channels
 @{" Db State     " Link "db_state"} - used or unused, this is the question
 @{" Db Reccount  " Link "db_reccount"} - number of the records
 @{" Db Recno     " Link "db_recno"} - number of the current record
 @{" Db Recle     " Link "db_recle"} - record length
 @{" Db Deleted   " Link "db_deleted"}
 @{" Db Found     " Link "db_found"} - result of the last Db Locate

@EndNode

@Node "db_delete"
@WORDWRAP
@{B}Syntax:@{UB}
                        Db Delete

@{B}Function:@{UB}

 Sets the current record to be deleted. However the record not lost, because it is only sign to deleted. It is affected only if previously the Db Setdeleted switch is turned off. Then the Db Skip and some other instructions simply don't see the deleted record.
 This action can be restore by the Db Recall instruction.
 If you want to see the current record's state, use the Db Deleted variable.

@{B}Result:@{UB}

 The record's deleted flag is set.

@{B}Example:@{UB}

        Db Use "work:Inventory.dbf"
        Db Goto 10
        Db Delete
        Db Pack
        Db Close

 The above physically erase the 10th record from the database. Db Pack not restoreable!

@EndNode
@Node "db_recall"
@WORDWRAP
@{B}Syntax:@{UB}
                        Db Recall

@{B}Function:@{UB}

 Sets the current record's deleted flag to off. If the record was deleted before, then it will be showing again for every function.
 If the record was not deleted, then this instruction has no effect.

@{B}Result:@{UB}

 The record's deleted flag is cleared.

@{B}Example:@{UB}

        Db Use "work:Inventory.dbf"
        For i=1 to Db Reccount
        If Db Deleted
            Input "The ";Db Recno;". record is deleted! Do you want to restore it?";a$
            If a$="Y"
                Db Recall
            End If
        End If
        Db Pack
        Db Close

@EndNode
@Node "db_use"
@{B}Syntax:@{UB}        Db Use f$

@{B}Function:@{UB}

 Check file, allocate memory for the related dates, tables. Open the database file, get the
structure information from it.

@{B}Input:@{UB}

 f$ - the name of the database file

@{B}Result:@{UB}

 A work type memory bank with Dbase name. This bank contains the database structure
information, and room for one buffered record.

@{B}Errors:@{UB}

 Not a dbase file! - the first byte must be $03 or $83
 I/O error - file not found, file is used, etc. 
 Channel already used! - this channel has an opened database (see Db Select)

@{B}Example:@{UB}

Db Use "work:Inventory"

Trap Db Use f$
E=Errtrap
If E<>0
  Goto veg
End If
@EndNode

@Node "db_close"
@{B}Syntax:@{UB}        Db Close

@{B}Function:@{UB}

 Closes the database in the actual channel.

@{B}Errors:@{UB}

 No file is used!

@{B}Example:@{UB}

        Db Use "test.dbf"
        Db Goto 10
        A$=Db Get$(2)
        Db Close

@EndNode
@Node "db_saved"
@WORDWRAP
@{B}Syntax:@{UB}
                        Db Saved On
                        Db Saved Off

@{B}Function:@{UB}

 Sets the state of a record. If it is off, then the record will be stored at the next positioning.
 You don't need to use these instructions, because other instructions and functions handle this thing, normally.

@{B}Result:@{UB}

 The record's saved flag is set.

@{B}Example:@{UB}

        Db Use "work:Inventory.dbf"
        Db Goto 10
        Db Put$ "123",2
        Db Saved On
        Db Close

 The above don't change the 2nd field of the 10th record.

@EndNode
@Node "db_select"
@{B}Syntax:@{UB}
                Db Select n
                Db Select First
                Db Select Next

@{B}Function:@{UB}

 Db Select n - changes the current channel.
 Db Select First - selects the first used channel
 Db Select Next - selects the first unused channel

@{B}Input:@{UB}

 n - the number of the channel

@{B}Example:@{UB}

        Db Select 5
        Db Use "work:Inventory"

        For i=1 to Db Opencount
          Db Select First
          Db Close
        Next i

  The second example closes all of the opened channels.

@EndNode
@Node "db_goto"
@{B}Syntax:@{UB}
                Db Goto n

@{B}Function:@{UB}

 Read the n. record of the database.

@{B}Input:@{UB}

 n - the number of the record

@{B}Example:@{UB}

        For i=1 to Db Reccount
          Db Goto i
          Print Db Get$(1)
        Next i

  This will prints the first record of every record.

@{B}Bugs:@{UB}

 CANTDO The current version can't add new record to the file. (V 0.42) (ADDED)

@EndNode
@Node "db_put"
@WORDWRAP
@{B}Syntax:@{UB}

                Db Putn n,f   - numeric data to numeric field
                Db Put$ n$,f  - string data to any type of field

@{B}Function:@{UB}

  Puts the given data to the given field of the current record.
  The string must be equal or shorter as the field length.
  The numeric field will contain one character for the sign of the number. Only the minus is displayed.

  The data not saved immidiately. When going to another record, then modifications will be saved.

@{B}Input:@{UB}

 n  - integer value
 n$ - string
 f  - the number of the field

@{B}Bugs:@{UB}

  If the field length can't held the numeric data, then the value is dropped and a leading '#' sign warns you to the case.

@{B}Example:@{UB}

        Db Goto 3
        Db Put$ "Apple",2
        Db Putn 320,3

  Puts the string "Apple" to the second field and the number 320 to the third field of the third record.
@EndNode
@Node "db_flen"
@{B}Syntax:@{UB}

                x=Db Flen(f)

@{B}Function:@{UB}

  Returns the length of the given field in characters.

@{B}Input:@{UB}

 f  - the number of the field

@EndNode
@Node "db_ftype"
@{B}Syntax:@{UB}

                x=Db Ftype(f)

@{B}Function:@{UB}

  Returns the type of the given field in characters.

@{B}Input:@{UB}

 f  - the number of the field
@EndNode
@Node "db_field$"
@{B}Syntax:@{UB}

                x$=Db Field$(f)

@{B}Function:@{UB}

  Returns the name of the given field.

@{B}Input:@{UB}

 f  - the number of the field

@EndNode
@Node "db_field"
@{B}Syntax:@{UB}

                x=Db Field(n$)

@{B}Function:@{UB}

  Returns the number corresponding to the given field name.

@{B}Input:@{UB}

 n$  - the name of the field
@EndNode
@Node "db_get"
@{B}Syntax:@{UB}

                x$=Db Get$(f)  - for string output
                 i=Db Get(f)   - for integer output
                 l=Db Get(f)   - for boolean output (if field f is logic type)

@{B}Function:@{UB}

  Returns the content of the given field. Doesn't check integer or character type.
  This instruction will try to get the output in the type of the syntax, no matter
  what is the field type. It will try to convert string to integer, or vica versa.
  The difference is the third syntax, is that it will checks field type for logic.
  If field type is Logic, and the content is 'T', then it will output True (-1),
  and False (0) at any other case.

@{B}Input:@{UB}

 f  - the number of the field
@EndNode
@Node "db_sel"
@{B}Syntax:@{UB}

                x=Db Sel

@{B}Function:@{UB}

  Holds the number of the current database channel.
@EndNode
@Node "db_address"
@{B}Syntax:@{UB}

                x=Db Address

@{B}Function:@{UB}

  Holds the address of the extension's internal data zone.
@EndNode
@Node "db_fieldno"
@{B}Syntax:@{UB}

                x=Db Fieldno

@{B}Function:@{UB}

  Holds the number of the fields in the current database.
@EndNode
@Node "db_recsaved"
@{B}Syntax:@{UB}

                x=Db Recsaved

@{B}Function:@{UB}

  Holds the status of the current record. If this is True, then the record's current data is saved. If this is False, then the first Db Goto will save the record.

@EndNode
@Node "db_opencount"
@{B}Syntax:@{UB}

                x=Db Opencount

@{B}Function:@{UB}

  Holds the number of the opened databases. If this is 0, then no database is used.
@EndNode
@Node "db_state"
@{B}Syntax:@{UB}

                x=Db State

@{B}Function:@{UB}

  Gives information about the current channel. If this is false, then no used database is in the current channel.
@EndNode
@Node "db_reccount"
@{B}Syntax:@{UB}

                x=Db Reccount

@{B}Function:@{UB}

  Holds the number of the records in the current database.
@EndNode
@Node "db_recno"
@{B}Syntax:@{UB}

                x=Db Recno

@{B}Function:@{UB}

  Holds the number of the current record. This record is in memory, and readable with the Db Get$..
@EndNode
@Node "db_recle"
@{B}Syntax:@{UB}

                x=Db Recle

@{B}Function:@{UB}

  Holds the length of the record.
@EndNode
@Node "db_append"
@WORDWRAP
@{B}Syntax:@{UB}

                Db Append
                Db Append Blank

@{B}Function:@{UB}

 Add a new record to the end of the file. The contents of this new rekord depends on the syntax of the instruction. The simple Db Append links a clone of the current record to the end of the database. With the Blank option, an empty -space filled- record will be added.
 Before execution, the not saved record will be stored automatically.

@EndNode
@Node "db_recle"
@{B}Syntax:@{UB}

                x=Db Recle

@{B}Function:@{UB}

  Holds the length of the record.
@EndNode
@Node "db_swap"
@{B}Syntax:@{UB}

                Db Swap r1,r2

@{B}Input:@{UB}

 Two valid record number.

@{B}Function:@{UB}

 Swap the contents of the <r1> and <r2> records. After the execution the current record will be the <r1>, which is now in the position of <r2>.

@EndNode
@Node "db_zap"

@EndNode
@Node "db_skip"

@EndNode

@Node "date_diff"
@WORDWRAP
@{B}Syntax:@{UB}

                days=Date Diff (d1$,d2$) 

@{B}Function:@{UB}

  Calculate the days between two gregorian date strings. Date format is: YYYYMMDD

@{B}Input:@{UB}

 d1$,d2$  - date strings in the format of YYYYMMDD
 
@{B}Example:@{UB}

        days=Date Diff ("20021003","19850701")

@EndNode

@Node "date_valid"
@WORDWRAP
@{B}Syntax:@{UB}

                bool=Date Valid (d$) 

@{B}Function:@{UB}

  Checking the gregorian date string for validity. Result is true, if the date is valid, and false if invalid.

@{B}Input:@{UB}

 d$ - date strings in the format of YYYYMMDD
 
@{B}Example:@{UB}

        If Date Valid ("20021003")
                Print "This date could be was, could be, or will be."
        End If 

@EndNode


@Node "Dbhead"


@{U}A DbaseIII típusú adatállományok felépítése:
@{UU}


Az adatállomány három részre osztható:

        I.   - Header
        II.  - A mezõ sruktúra
        III. - Header lezárása
        IV.  - adatrekordok

I. - Header
-----------
Hossza mindíg 32 byte.
Offszetek a header elejétõl.


byte      offszet név       leírás
-------+-----------------+-------------------------------------------------
0.     | DBF_Id          | azonosító byte = $03 v. $83
-------+-----------------+-------------------------------------------------
1.-3.  | DBF_Date        | az utolsó módosítás dátuma (yy mm dd)
-------+-----------------+-------------------------------------------------
4.-7.  | DBF_RecNo       | az adatállomány rekordjainak száma
       |                 | a byte-ok fordított sorrendben
-------+-----------------+-------------------------------------------------
8.-9 . | DBF_HeadLe      | az elsõ adatrekord címe a header elejéhez képest
       |                 | vagy a header hossza eggyel növelve (alsó,felsõ)
-------+-----------------+-------------------------------------------------
10.-11.| DBF_RecLe       | az adatrekord hossza (alsó, felsõ)
       |                 | a hosszba beleszámít a deleted flag byte is
-------+-----------------+-------------------------------------------------
12.-31.|                 | fenntartva
-------+-----------------+-------------------------------------------------


II. - A mezõ struktúra
----------------------
Egy tag hossza 32 byte.
A tagok száma a header hosszából számítható.

byte      offszet név       leírás
-------+-----------------+-------------------------------------------------
0.-9.  | DBF_FieldName   | a mezõ neve 10 byte
-------+-----------------+-------------------------------------------------
10.    |                 | a mezõ nevét lezáró $00
-------+-----------------+-------------------------------------------------
11.    | DBF_FieldType   | a mezõ típusa (lásd lejjebb)
-------+-----------------+-------------------------------------------------
12.-15.|                 | mezõ adat cím (a file-ban csak a helye fenntartva)
-------+-----------------+-------------------------------------------------
16.    | DBF_FieldLe     | a mezõ hossza
-------+-----------------+-------------------------------------------------
17.    | DBF_FieldDec    | numerikus típus esetén a tizedesjegyek száma
-------+-----------------+-------------------------------------------------
18.-23.|                 | fenntartva
-------+-----------------+-------------------------------------------------
24.-25.| DBF_IFieldLe    | páros mezõhossz az indexfile-ban
-------+-----------------+-------------------------------------------------
26.-27.| DBF_IRecOff     | az elsõ index rekord címe az index file-ban
-------+-----------------+-------------------------------------------------
28.-31.| DBF_IFilehd     | a mezõhöz tartozó megnyitott index handlere
-------+-----------------+-------------------------------------------------

III. - Header lezárása
----------------------
$0D
v.
$0D $00


IV. - Adatrekord
-----------------
Az elsõ byte a deleted flag.


@EndNode

@Node "BANK"

A DB_USE által létrehozott bank szerkezete, felépítése:


Offszet:                                                         Hossz:
                    +-------------------------------------------+
BANK start          |   I.- adatállomány jellemzõk    128 byte  |   DE_BankHead
                    |                                           |
                    +-------------------------------------------+
                    |                                           |
+DB_HeadOff         | II.  - Head                      32 byte  |   DE_DataHead
                    |                                           |
                    +-------------------------------------------+
                    |                                           |
+DB_FieldOff        | III. - mezõ struktúra          n*32 byte  |   DB_FieldOff
                    |                                           |
                    +-------------------------------------------+
                    |                                           |
*DB_CFieldOff       | V.   - a mezõ számított adatai n*12 byte  |   *DB_CFieldOff
                    |                                           |
                    +-------------------------------------------+
                    |                                           |
*DB_RecSt           | IV.  - 1 db adatrekord                    |   *DB_RecSt
                    |                                           |
                    +-------------------------------------------+




I. Adatállomány jellemzõk:
--------------------------
Hossz: DE_BankHead == 128

byte      offszet név       leírás
-------+-----------------+-------------------------------------------------
0.-3.  | DB_Filehd       | a megnyitott file FILEHD-je
-------+-----------------+-------------------------------------------------
4.-7.  | DB_HeadLe       | a DBF struktúra hossza, ami magában foglalja a
       |                 | headert és a mezõ struktúrát
-------+-----------------+-------------------------------------------------
8.-9.  | DB_RecLe        | a rekord hossza
-------+-----------------+-------------------------------------------------
10.-13.| DB_RecSt        | az adatrekord kezdõcíme
-------+-----------------+-------------------------------------------------
14.-15.| DB_FieldNum     | a mezõk száma
-------+-----------------+-------------------------------------------------
16.-19.| DB_RecNum       | a rekordok száma
-------+-----------------+-------------------------------------------------
20.-23.| DB_RecOff       | IV. Adatrekord kezdõcím offszet
-------+-----------------+-------------------------------------------------
24.-27 | DB_CFieldOff    | V. A mezõ számított adatok kezdõcím offszet
-------+-----------------+-------------------------------------------------
28.-31.| DB_CurRec       | az aktuális rekord száma
-------+-----------------+-------------------------------------------------
32.-35.| DB_Order        | a rendezett mezõ száma, ill. 0>natural order
-------+-----------------+-------------------------------------------------
36.-39.| DB_PrevSel      | az elõzõ megnyitott adatállomány csatornája
-------+-----------------+-------------------------------------------------
40.    | DB_CacheValid   | -1 the cache is valid, 0 no cache, >0 invalid
-------+-----------------+-------------------------------------------------
41.    |                 |
-------+-----------------+-------------------------------------------------
42.-43.|                 |
-------+-----------------+-------------------------------------------------
44.-47.| DB_Indexhd      | az index állomány filehd-ja
-------+-----------------+-------------------------------------------------
48.-49.| DB_Deleted      | True-> a skip átugorja a deleted rekordokat
-------+-----------------+-------------------------------------------------
50.-51.| DB_MemoSize     | Size in bytes of the memo file date chunk size
-------+-----------------+-------------------------------------------------
52.-55.| DB_SAVED        |
-------+-----------------+-------------------------------------------------
56.-59.| DB_MemoFilehd   | Memo iff file file handler
-------+-----------------+-------------------------------------------------
60.-63.| DB_MemoIFFhd    | Iffparse.library iff handler for memo file
-------+-----------------+-------------------------------------------------
64.-67.| DB_CacheSize    | Reserved cache records
-------+-----------------+-------------------------------------------------
68.-71.| DB_Cachemem     | Address of the reserved cache memory
-------+-----------------+-------------------------------------------------
72.-75.| DB_RecStBnk     | The address of the 1 record puffer in the bank.
-------+-----------------+-------------------------------------------------
76.-79.| DB_CacheTop     | The record on the top of the cache
-------+-----------------+-------------------------------------------------
80.-83.| DB_CacheBottom  | The record on the bottom of the cache
-------+-----------------+-------------------------------------------------
-127.  |                 | fenntartva
-------+-----------------+-------------------------------------------------


A fenti adatok nagyrésze megtalálható az adatáll. headerben is.
Mivel ott alsó-felsõ sorrendben találhatóak a byte-ok, könnyebben
kezelhetõ formában tároljuk itt.



II. A dbase adatállomány header
-------------------------------
Hossz:   DE_DataHead == 32
Offszet: DB_HeadOff  == 128

@{"  A DbaseIII típusú adatállományok felépítése  " Link "Dbhead"}


III. Mezõ struktúra
-------------------
Hossz:    DE_FieldStruc == 32
Offszet : DB_FieldOff   == 160

@{"  A DbaseIII típusú adatállományok felépítése  " Link "Dbhead"}


IV. Adatrekord
--------------
Hossz:   *DB_RecLe
Offszet: *DB_RecSt

Az aktuális adatrekord másolata.

byte
------+------------+-------------------------------------------------------
0.    | DE_RecDel  | Deleted flag
------+------------+-------------------------------------------------------
1.-   | DE_RecData | Itt kezdõdnek az adatok
------+------------+-------------------------------------------------------


V. A mezõk számított adatai
---------------------------
Hossz:  DE_CFieldStruc == 16
Offszet *DB_CFieldOff


byte     offszet név       leírás
-------+-----------------+-------------------------------------------------
0.-3.  | DF_FieldSt      | mezõ struktúraelem offszet
-------+-----------------+-------------------------------------------------
4.-7.  | DF_FieldRec     | mezõ offszet a rekordban
-------+-----------------+-------------------------------------------------
8.-9.  | DF_LinkSel      | a mezõhöz linkelt megnyitott adatáll csatornája
-------+-----------------+-------------------------------------------------
10.-11.| DF_LinkField    | a DF_LinkSel-hez tartozó mezö
-------+-----------------+-------------------------------------------------
12.-15.| DF_AbsAddress   | a mezõ abszolút címe
-------+-----------------+-------------------------------------------------

Constansok:
-----------

-------------+--------+----------------------------------------------------
NOT_DELETED  | $20    | a nem törölt rekord jelzése a rekord 1. byteban
-------------+--------+----------------------------------------------------


@EndNode
@Node "Index_head"
Az Index file felépítése
------------------------

Header
-------+-----------------+-------------------------------------------------
0.-15. | DBI_Form        | Tartalma: "FORM    SYMBINDX" késõbbi szerep
-------+-----------------+-------------------------------------------------
16.-17.| DBI_FlenO       | Eredeti mezõhossz, ellenõrzésre
-------+-----------------+-------------------------------------------------
18.-19.| DBI_FlenE       | Even mezõhossz, ahogy az indexben fizikailag van
-------+-----------------+-------------------------------------------------
20.-23.| DBI_Recnum      | Rekordok száma, ellenõrzésre
-------+-----------------+-------------------------------------------------
24.-25.| DBI_RecOff      | Az elsõ rekord címe az index file-ban
-------+-----------------+-------------------------------------------------
26.-35.| DBI_FieldName   | A mezõ neve, ellenõrzésre
-------+-----------------+-------------------------------------------------


Rekordok
-------+-------------------------------------------------
       | Mezõ adat 
-------+-------------------------------------------------
ULONG  | Fizikai rekord szám|
-------+-------------------------------------------------

@EndNode
@Node "tools"

 @{" Create " Link Create.Guide/Main} - amigaguide documentation


 With this Amos independent stuff, you can create new databases.

 @{" Dedit " Link Dedit.guide/Main} - amigaguide documentation

 Powerful database editing/viewing tool!

 Index
 -----

 It can be started from a command line and generates an index file.

 Command template: 

 DATABASE_FILE/A INDEX_FILE/A FIELD_NAME/A

 DSort
 -----

 It can be started from a command line and sorts the database on the selected
 field.
 The argument KEYFIELD is case sensitive!

 Command template:

 DATABASE/K,KEYFIELD/K

 Example:

  8.Work:Projects/Database> sort Work:Projects/SymBill/Vevo_torzs.dbf V_nev

  SymBase Sorting Tool V1.0 by Lázi
    Sorting database :Work:Projects/SymBill/Vevo_torzs.dbf
    On the field     :V_nev
    Records          : 315
    Elapsed time     : 723
    Goto             : 3788
    Swap             : 694


@EndNode
@Node "author"
@WORDWRAP

 Ok, I am a hungarian guy, a fanatic Amiga user. I think Amiga cannot die, because this is a computer, not an organic creature. :))
 Amiga will live almost forever, as long as the silicon do the job in those great chips, which made the Amiga to just like that, what i like!

 If you want to contact me, then here are the addresses:

        Snail mail: H2013 Pomáz, Jankovich Gyula u. 5. Hungary
        e-mail    : lazi@freemail.hu
        phone     : +36 26 329 937
                    +36 70 211 5830
@EndNode
@Node "history"
SymBase.lib extension's history:

 00.45  - The projects's name changed to SymBase
          Extension's name to Sbase_ex
 00.46  - fix a small bug in Db Get$
 00.47  - fix in Db Get$ - no return string, if all char is space
          fix in Db Put - replace the moved 0 if the strint shorter
 00.48  - fix in Db Get$ - cuts the spaces from the end
          remove a recently generated bug in Db Put
 00.49  - trying to fix Db Append Blank
 00.50  - Added the Db Swap instruction
 00.51  - Added the Delete Recall instructions and the Deleted variable
 00.52  - Added the Db Pack instruction
          fix Delete and Recall
          added the L_CHANGE internal subroutine
 00.53  - added the L_STORE_RECNO internal routine
 00.54  - added the Db Zap instruction
          Db_Ftype now check param correctly
 00.55  - Db_Field$() fix
 00.56  - L_REC_SEEK and L_REC_SEEK fix to use recno>$FFFF
 00.57  - fix Db Get$() crash on the 2044th call
 00.58  - added the Db Skip instruction
 00.59  - some optimization on the Db Use
          Fix: End routine crash in L0 (4h)
 00.60  - Remove L_GOTOINT from L_GOTO. Compiler incompatibility.
          Remove L_XFLEN -"-
 00.61  - NOT FINISHED!!! Add: Db Order (1h)
 00.62  - NOT FINISHED!!! Add: index close to Db Close
 00.63  - Fix in Db Close: save the record before closing.Changed also:L_BNK_CHK
          Db Use don't close the file if an error occurs! FIXED
 00.64  - ADD: Db Setdeleted On statement
          ADD: Db Setdeleted Off statement
          FIX: Db Goto - bgt nem kell
          BUG: BNK_CHK don't make error if bank not defined
          NEED: Db Goto Top - az elsõ nem törölt rekordra áll,ha On
          NEED: Db Goto Bottom - az uccsó nem törölt rec
          BUG: A Db Skip az utolsó éles rekord után kiadva a köv rekordra áll
          BUG: Db select után az elõzõ rekord elillan, mivel a DV_SAVED nem a
          bankban, hanem a közös adatterületen van.
 00.65  - FIX: Db Goto 1-es Currec-et tolt be, akkor is ha nincs rekord
          FIX: Db Zap nem törölte az aktuális rekord számát
 00.66  - ADD: Db Cutspace On   (Db Get$)
          ADD: Db CutSpace Off
 00.67  - FIX: L_BNK_CHK to eliminate enforcer hits
 00.68  - ADD: optimalization in Db Use
 00.69  - ADD: open/close mathffp.library
 00.70    CHG: Db Put to Db Put$
          CHG: Db Ftype to Db Ftype$
          ADD: Db Get()
 00.71  - CHG: L_XFLEN to support decimal digits
          CHG: every L_XFLEN call get an and... to support the above.
          CHG: DV_SAVED moved to XBase bank with the name DB_SAVED
 00.72  - CHG: a small optim in Db Use (several bclr changed to one andi)
 00.73  - ADD: new instruction Db Notify
 00.74  - CHG: optimalizations experiment in Db Get$
 00.75  - ADD: Db Locate frame
          ADD: L_FIELD_ADDR
 00.76  - ADD: more labels
          CHG: utilize L_FIELD_ADDR in Db Put$, Db Get$, Db Get
 00.77  - ADD: Db Locate
          BUG: observed memory leaking!!!
 00.78  - ADD: Open/Close IffParse library
 00.79  - ADD: LONG2STR internal routine
 00.80  - CHG: LONG2STR remove leading zeros, add sign
 00.81  - CHG: bug fixing of the two above movement
 00.82  - CHG: sign is before the first digit
          CHG: Db Close has no effect, when no bank opened
 00.83  - ADD: Db PutN, finishing LONG2STR
          CHG: Db Ftype$ to Db Ftype (see 00.70)
 00.84  - ADD: Db Order frame
          CHG: Fix a bug in the function offset table (52->72)
          CHG: Small optim in Db Putn (move.l -> clr.l)
 00.85  - CHG: Bug fixed in LONG2STR, to work properly even with negative values.
          CHG: Small bug fixed in Dedit (V1.14)

 00.86  - ADD: feature to delay reccount storing in header for several appends
          ADD: Db Header Update Off Db Header Update
          FIX: Db Use and the nasty Db RecSaved flag. Incredible, that even Db Use isn't bugless.
 00.87  - CHG: Optimalization with L_CHANGE
          FIX: L_REC_NEW was set off DB_SAVED instead of on, i don't know why
          FIX: Db Append was not set deleted flag into new record.->Database corrupt
 00.88  - ADD: Introducing Db Alias, the magical instruction NOT FINISHED!!!
 00.89  - ADD: Several modification to handle logic field Db Get(),L_FIELD_ADDRESS
 00.90  - ADD: FFP support via Db Putf and Db Getf
          CHG: For the FFP support, Db Flen gives back 16 for FFP fields. Internal value stands 4 byte.
 00.91  - ADD: Datelib open close
          FIX: Db Pack
          ADD: Date Diff function
          ADD: Date Valid function
 00.92  - REM: Date functions removed to a separate extension
 00.93	- CHG: Reorganize source to be assemble on AsmPro
 00.94	- FIX: Trying to make it working under OS4
@EndNode
@Node "struct"

 @{" Dbf file structure   " Link "DbHead"}
 @{" Internal structure   " Link "BANK"}
 @{" Index file structure " Link "Index_head"}

@EndNode
@Node "disclaimer"
@WORDWRAP

This software is freeware. Feel free to use it.
If you want to use SymBase in a commercial product, contact the author, before do that.
@EndNode
@Node "Future"

@{B}Future:@{UB}

This version (0.84) is just a sample.
Many features will be implemeted sooner or later.

@EndNode
@Node "bugs"
Known bugs:

After the bug, there is number of the fixed version.

- After Db Pack it can accept illegal record number with Db Goto (0.42)
- Db select után az elõzõ rekord elillan (0.63)

@EndNode

@Node "server"

Standalone database server, which works via an arexx port. The Arexx commands similar
to the xBase ones.

There is also an Client icon, which starts an arexx command line pointed to
the SymBase server. You can leave this client with the EXIT command.

@EndNode
