@DATABASE "AMOSPro_GadTools.Include"
@AUTHOR "Harald Wagner"
@(C) "Copyright 1995-98"

@NODE MAIN "AMOSPro GadTools-Include Instructions"


             AMOSPro GadTools.Inc Version 1.1 - Copyright © 1995-98
             ------------------------------------------------------
                            Written by Harald Wagner
                   Ein Erweiterungs-Tool für AMOS-Professional

                                   (FreeWare)



 @{"    Einleitung   " LINK Einleitung}  Was sind die AMOSPro GadTools?
 @{"    Kurz-Index   " LINK Kurz}  Kurz Übersicht aller GadTools Befehle.
 @{"  Befehls-Index  " LINK Index}  Alle 34 GadTools Befehle im Überblick.
 @{"  Vorgehensweise " LINK Vorgehensweise}  So benutzen sie die GadTools.
 @{"    Beispiele    " LINK Beispiele}  Die Beispiel-Listings.
 @{"   Richtlinien   " LINK Richtlinien}  Was man beachten sollte.
 @{" Einschränkungen " LINK Einschränkungen}  Reservierte Lokale Variablen & Bänke.
 @{"   Anregungen    " LINK Anregungen}  Anregungen für weitere versionen.
 @{"   Copyright     " LINK Copyright}  Allgemeine Infos zu den GadTools.
 @{"   Bug Report    " LINK Report}  Bug Reports bitte an den Autor senden.
 @{"    History      " LINK History}  Die Entwicklungsgeschichte.
 @{"   Danksagung    " LINK Dank}  Ein kleines Dankeschön.

 @{"   Wichtig !!!   " LINK Wichtig}  AMOSPro-Monitor & Compiler.

@ENDNODE


@NODE Einleitung "Was sind die AMOSPro GadTools?"

Was sind die AMOSPro GadTools?
------------------------------

Die AMOSPro GadTools sind ein Include-File für AMOS Professional V2.00.
D.H. es wird mit der 'Include'-Anweisung von AMOSPro an das eigentliche
Hauptprogramm angehangen. (Bitte dazu unbedingt auch den Punkt @{"Wichtig" LINK Wichtig}
Lesen!) Danach stehen dem Anwender 34 Befehle für die verschiedensten GadGets
zur verfügung. Bei der Programmierung der GadTools ging es Mir aber nicht
nur darum irgendwelche GadGets auf dem Bildschirm zu setzen, sondern vielmehr
auch darum dem Anwender ein Packet anzubieten, mit dem man auf bequemer weise
Screens und Masken erstellen kann, die direkt im OS3.x Look erscheinen.

@ENDNODE


@NODE Kurz "Kurz Übersicht aller GadTools Befehle."

Kurz Übersicht aller GadTools Befehle.
--------------------------------------

_PushButton[Id,X,Y,Color1,Color2,Color3,Color4,"Button-Name"]  
_Del_PushButton[Id]
_PushButton_Hit
_CheckBox[Id,X,Y,Color1,Color2,Color3,Color4,On/Off]     
_Set_CheckBox_State[Id,On/Off] 
_Get_CheckBox_State[Id]  
_Del_CheckBox[Id]
_CheckBox_Hit
_RadioButton[Id,X,Y,Color1,Color2,Color3,On/Off] 
_Set_RadioButton_State[Id,On/Off]
_Get_RadioButton_State[Id] 
_Del_RadioButton[Id] 
_RadioButton_Hit
_CycleButton[Id,X,Y,Color1,Color2,Color3,Color4,"Text1|Text2..."]
_Set_CycleButton_State[Id,TextNumber]
_Get_CycleButton_State[Id] 
_Del_CycleButton[Id] 
_CycleButton_Hit
_ToggleButton[Id,X,Y,Color1,Color2,Color3,Color4,On/Off,"Button-Name"]   
_Set_ToggleButton_State[Id,On/Off] 
_Get_ToggleButton_State[Id]
_Del_ToggleButton[Id]
_ToggleButton_Hit
_StringGadget[Id,X,Y,Color1,Color2,Color3,Color4,Color5,GadLen,MaxTextLen]   
_Set_StringGadget_State[Id,String$]
_Get_StringGadget_State[Id]
_Del_StringGadget[Id]
_StringGadget_Hit
_TextGadget[Id,X,Y,Color1,Color2,Color3,Color4,MaxTextLen] 
_Set_TextGadget_Text[Id,String$] 
_Make_Mask[X1,Y1,X2,Y2,Color1,Color2,Color3] 
_Screen_Open[Screen,0-2 {Lores/Hires/Interlace} ]    
_ScreenBar["Screenname"]
_WinClone[X1,Y1,X2,Y2,"Titlename"]

@ENDNODE


@NODE Index "Alle 34 GadTools Befehle im Überblick."

Alle 34 GadTools Befehle im Überblick.
--------------------------------------

Nachdem man mit >>>Include "Device+Pfad/GadTools.Inc"<<< die GadTools
am ende des Hauptprogramms angehangen hat, stehen einem folgende Anweisungen
zur verfügung.: (Bitte dazu unbedingt auch den Abschnitt @{"Wichtig" LINK Wichtig} Lesen!)
----------------------------------------------------------------------------

_Screen_Open[ScreenNummer,Value]

Mit dieser Anweisung wird ein Screen eröffnet das im OS3.x Look erscheint.
Der erste Parameter is eine ScreenNummer im bereich von 0-7. Der zweite
Parameter (Value) bestimmt welchen Modi sie für den Screen benutzen
möchten. Dabei kann ein wert von 0-2 angegeben werden.

Value 0 = Lores (320 x 256 x 4)
Value 1 = Hires (640 x 256 x 4)
Value 2 = Laced (640 x 512 x 4)

Ein somit geöffneter Screen enthält danach automatisch die Farben
im OS3.x Look.

----------------------------------------------------------------------------

_Make_Mask[X1,Y1,X2,Y2,Color1,Color2,Color3]

Mit dieser Anweisung wird eine Maske im Screen eröffnet (Panel) das im
OS3.x Look dargestellt wird. Dabei wird die Maske an den Koordinaten
X1,Y1,X2,Y2 gezeichnet. Color1 bestimmt das FarbAtribut für den oberen
und linken teil des Borders und Color2 für den rechten und unteren teil
des Borders. Mit Color3 wird das FarbAtribut für die farbe der Maske
selbst bestimmt. Man sollte den _Make_Mask Befehl immer im zusammenhang
mit '_Screen_Open' oder nach '_WinClone' benutzen.

----------------------------------------------------------------------------

_PushButton[Id,X,Y,Color1,Color2,Color3,Color4,"Button-Name"]

Mit dieser Anweisung wird ein PushButton gezeichnet. Dabei wird das
Button mit der Id-Nummer 'Id' an den Koordinaten X,Y gezeichnet. Mit
Color1 wird das FarbAtribut für den oberen und linken teil des Borders
gewählt und mit Color2 das FarbAtribut für den unteren und rechten teil
des Borders. Mit Color3 wird das FarbAtribut für das Button selbst
bestimmt und Color4 setzt das FarbAtribut für den Text im Button.
Mit Button-Name wird der name des Buttons festgelegt. Insgesammt kann
man 30 (1-30) PushButtons definieren. Die angabe der 'Id-Nr.' darf also
nur im Bereich von 1-30 liegen.

----------------------------------------------------------------------------

_Del_PushButton[Id]

Mit dieser Anweisung wird ein PushButton mit der Id-Kennung 'Id' aus
dem Speicher entfernt. Danach lässt sich dieses Button nicht mehr
abfragen. Die Grafische darstellung bleibt jedoch auf dem Screen er-
halten. Diese Anweisung ist sehr wichtig, wenn man z.b. einen zweiten
Screen öffnet in dem sich ein Option-Panel aufbaut. Damit die Buttons
aus dem vorherigen Screen nicht mit abgefragt werden. Möchte man das
somit glöschte Button wieder aktivieren, so muss man dieses wieder
mit der _PushButton Anweisung neu definieren. (Siehe unter _PushButton)

----------------------------------------------------------------------------

_PushButton_Hit

Mit dieser Anweisung werden alle bis dato definierten PushButtons abgefragt.
Wurde eines betätigt, so wird die Id-Nummer in der Variable 'Param' zu-
rückgegeben. (z.b. '1' wenn PushButton 1 angeklickt wurde.) Wurde kein
Button angeklickt, so wird '0' in der Variable 'Param' zurückgegeben.
Diese Anweisung sollte immer mit in der Hauptschleife des Hauptprogramms
ausgeführt werden.

----------------------------------------------------------------------------

_CheckBox[Id,X,Y,Color1,Color2,Color3,Color4,On/Off]

Mit dieser Anweisung wird eine CheckBox mit der Id-Nummer 'Id' an den
Koordinaten X,Y gezeichnet. Color1 bestimmt dabei das FarbAtribut für
den oberen und linken teil des Borders und Color2 den unteren und rechten
teil des Borders. Mit Color3 wird das FarbAtribut für die CheckBox selbst
festgelegt und Color4 bestimmt das FarbAtribut für das Häckchen das bei
aktiviertem zustand angezeigt wird. Mit On/Off wird ein Value von 0-1
angegeben, wobei mit '1' sofort ein Häckchen in der Box gezeichnet wird.
Mit '0' wird die CheckBox inaktiviert gezeichnet. Auch hier lassen sich
maximal 30 CheckBoxen definieren. Die Id-Kennung darf also von 1-30
gehen.

----------------------------------------------------------------------------

_Set_CheckBox_State[Id,On/Off]

Mit dieser Anweisung wird die CheckBox mit der Id-Kennung 'Id' aktiviert
bzw. inaktiviert. Mit On/Off wird ein Value von 0-1 angegeben. Dabei
bedutet ein wert von '0' das die CheckBox inaktiviert wird (Häckchen wird
aus der CheckBox entfernt.) und ein wert von '1' aktiviert die angegebene
CheckBox. (Häckchen wird sichtbar.)

----------------------------------------------------------------------------

_Get_CheckBox_State[Id]

Mit dieser Anweisung wird der Status einer CheckBox ausgelesen. Dabei
wird in der Variable 'Param' ein wert von '0' zurückgegeben wenn die
CheckBox inaktiviert ist und '1' wenn sie aktiviert ist. Wurde ein
wert von '-1' zurückgegeben, so ist ein Fehler aufgetreten. Entweder
existiert die CheckBox noch nicht oder es wurde die grenze der maximalen
Id-Nummern von 1-30 überschritten.

----------------------------------------------------------------------------

_Del_CheckBox[Id]

Das selbe wie _Del_PushButton[Id] nur hier für CheckBoxen. (Siehe unter
_Del_PushButton.)

----------------------------------------------------------------------------

_CheckBox_Hit

Das selbe wie _PushButton_Hit nur hier für CheckBoxen. (Siehe unter
_PushButton_Hit.)

----------------------------------------------------------------------------

_RadioButton[Id,X,Y,Color1,Color2,Color3,On/Off]

Mit dieser Anweisung wird das RadioButton mit der Id-Kennung 'Id' an den
Koordinaten X,Y gezeichnet. Color1 bestimmt dabei das FarbAtribut für
das Button selbst. Color2 bestimmt das FarbAtribut für die aktivierte
darstellung und Color3 für die inaktivierte darstellung. Mit On/Off wird
ein Value von 0-1 angegeben, wobei das Button mit '0' inaktiviert und
mit '1' aktiviert gezeichnet wird. Auch hier ist eine grenze von 1-30
gesetzt. (D.H. Max. 30 Buttons können definiert werden.)

----------------------------------------------------------------------------

_Set_RadioButton_State[Id,On/Off]

Das selbe wie _Set_CheckBox_State nur hier für RadioButtons. (Siehe unter
_Set_CheckBox_State.)

----------------------------------------------------------------------------

_Get_RadioButton_State[Id]

Das selbe wie _Get_CheckBox_State nur hier für RadioButtons. (Siehe unter
_Get_CheckBox_State.)

----------------------------------------------------------------------------

_Del_RadioButton[Id]

Das selbe wie _Del_PushButton nur hier für RadioButtons. (Siehe unter
_Del_PushButton.)

----------------------------------------------------------------------------

_RadioButton_Hit

Das selbe wie _PushButton_Hit nur hier für RadioButtons. (Siehe unter
_PushButton_Hit.)

----------------------------------------------------------------------------

_CycleButton[Id,X,Y,Color1,Color2,Color3,Color4,"Text1|Text2|Text3..."]

Mit dieser Anweisung wird das CycleButton mit der Id-Kennung 'Id' an den
Koordinaten X,Y gezeichnet. Color1 bestimmt dabei das FarbAtribut für den
oberen und linken teil des Borders und Color2 den unteren und rechten
teil des Borders. Mit Color3 wird das FarbAtribut für das Button selbst
festgelegt und Color4 bestimmt die TextFarbe. Die eingegebenen Texte
werden hier durch einen senkrechten Strich '|' abgetrennt. Wie immer
lassen sich bis zu 30 Buttons definieren. (Id = Max. 1-30)

----------------------------------------------------------------------------

_Set_CycleButton_State[Id,TextNumber]

Mit dieser Anweisung wird dem CycleButton mit der Id-Kennung 'Id' einen
neuen Status zugewiesen. D.H.: Wenn man z.b. 3 Texte in dem CycleButton
mit der Id-Kennung '1' definiert hat und mit _Set_CycleButton_State[1,2]
den Status verändert, so würde dieses CycleButton den zweiten Text dar-
stellen.

----------------------------------------------------------------------------

_Get_CycleButton_State[Id]

Mit dieser Anweisung wird der Status eines CycleButtons ausgelesen. Das
Ergebnis wird dann in der Variable 'Param' zurückgegeben. Ist in dem
angegebenen Button z.b. gerade der 2. Text sichtbar, so wird in der
Variable 'Param' der wert '2' zurückgegeben. Wurde eine zu hohe (Max. 1-30)
Id-Kennung angegeben oder ein Button das noch nicht existiert, wird '-1'
zurückgegeben, das in einem solchen fall auf einen Fehler hinweist.

----------------------------------------------------------------------------

_Del_CycleButton[Id]

Das selbe wie _Del_PushButton nur hier für CycleButtons. (Siehe unter
_Del_PushButton.)

----------------------------------------------------------------------------

_CycleButton_Hit

Das selbe wie _PushButton_Hit nur hier für CycleButtons. (Siehe unter
_PushButton_Hit.)

----------------------------------------------------------------------------

_ToggleButton[Id,X,Y,Color1,Color2,Color3,Color4,On/Off,"Button-Name"]

Mit dieser Anweisung wird das ToggleButton mit der Id-Kennung 'Id' an den
Koordinaten X,Y gezeichnet. Mit Color1 wird das FarbAtribut für den
oberen und linken teil des Borders gesetzt und mit Color2 das für den
unteren und rechten teil des Borders. Mit Color3 wird das FarbAtribut für
das Button selbst festgelegt und mit Color4 das für den Button-Name.
Mit On/Off wird ein value von 0-1 angegeben, wobei das Button mit '0'
inaktiviert und mit '1' aktiviert dargestellt wird. Mit Button-Name wird
der name des Buttons festgelegt der im Button angezeigt wird. Auch hier
sind wieder Max. 30 Buttons definierbar. (Id-Kennung Max. 1-30)

----------------------------------------------------------------------------

Set_ToggleButton_State[Id,On/Off]

Das selbe wie _Set_CheckBox_State nur hier für ToggleButtons. (Siehe unter
_Set_CheckBox_State.)

----------------------------------------------------------------------------

Get_ToggleButton_State[Id]

Das selbe wie _Get_CheckBox_State nur hier für ToggleButtons. (Siehe unter
_Get_CheckBox_State.)

----------------------------------------------------------------------------

Del_ToggleButton[Id]

Das selbe wie _Del_PushButton nur hier für ToggleButtons. (Siehe unter
_Del_PushButton.)

----------------------------------------------------------------------------

_ToggleButton_Hit

Das selbe wie _PushButton_Hit nur hier für ToggleButtons. (Siehe unter
_PushButton_Hit.)

----------------------------------------------------------------------------

_StringGadget[Id,X,Y,Color1,Color2,Color3,Color4,Color5,GadLen,MaxTexLen]

Mit dieser Anweisung wird das StringGadget mit der Id-Kennung 'Id' an den
Koordinaten X,Y gezeichnet. Mit Color1 wird das FarbAtribut für den
oberen un linken teil des Borders gesetzt und mit Color2 das für den
unteren und rechten teil des Borders. Mit Color3 wird das FarbAtribut
für das StringGadget selbst gesetzt und Color4 das für den Text der
im StringGadget dargestellt wird. Mit Color5 wird das FarbAtribut für
den Cursor im StringGadget gesetzt. Mit GadLen wird die länge des
StringGadgets in zeichen angegeben und mit MaxTexLen die maximale
länge an Text die das StringGadget aufnehmen kann. Wie immer sind
auch hier maximal 30 StringGadgets definierbar. (Id = Max. 1-30)

----------------------------------------------------------------------------

_Set_StringGadget_State[Id,String$]

Mit dieser Anweisung wird das StringGadget mit der Id-Kennung 'Id' den
Text 'String$' zugewiesen.

----------------------------------------------------------------------------

_Get_StringGadget_State[Id]

Mit dieser Anweisung wird der Inhalt des StringGadgets mit der Id-Kennung
'Id' ausgelesen. Der Inhalt wird dabei dann in der Variable 'Param$'
zurückgegeben.

----------------------------------------------------------------------------

_Del_StringGadget[Id]

Das selbe wie _Del_PushButton nur hier für StringGadgets. (Siehe unter
_Del_PushButton.)

----------------------------------------------------------------------------

_StringGadget_Hit

Das selbe wie _PushButton_Hit nur hier für StringGadgets. (Siehe unter
_PushButton_Hit.)

----------------------------------------------------------------------------

_TextGadget[Id,X,Y,Color1,Color2,Color3,Color4,MaxTexLen]

Mit dieser Anweisung wird das TextGadget mit der Id-Kennung 'Id' an den
Koordinaten X,Y gezeichnet. Color1 bestimmt dabei das FarbAtribut für den
oberen und linken teil des Borders und Color2 das für den unteren und
rechten teil des Borders. Mit Color3 wird das FarbAtribut für das Gadget
selbst festgelegt und mit Color4 das für den Text der im TextGadget zu
stehen kommt. Mit MaxTexLen wird die grösse des TextGadgets in zeichen
angegeben.

Hinweis:
--------
Das TextGadget ist kein Button das man anklicken kann, sondern es dient
mehr dazu um Texte anzuzeigen. (z.b. für Status-Meldungen auszugeben.)

----------------------------------------------------------------------------

_Set_TextGadget_Text[Id,String$]

Mit dieser Anweisung wird dem TextGadget mit der Id-Kennung 'Id' dem
String 'String$' zugewiesen. Ist der angegebene String länger als das
TextGadget, so wird der String automatisch rechts abgeschnitten.

----------------------------------------------------------------------------

_ScreenBar[Title$]

Mit dieser Anweisung wird eine Screenleiste gesetzt. Mit 'Title$' kann
ein Text angegeben werden, der in der Screenleiste zu stehen kommt.

----------------------------------------------------------------------------

_WinClone[X1,Y1,X2,Y2,Title$]

Mit dieser Anweisung wird ein Ebenbild eines Intuitions-Fensters in den
Screen gezeichnet. Da es sich "nur" um ein Grafisches Ebenbild handelt
und nicht um ein echtes Fenster, wurde der Befehl auch 'WinClone'
benannt. Er dient lediglich dazu, Oberflächen vom Look & Feel her
Professioneller aussehen zu lassen. Da es sich "nur" um eine Grafische
Darstellung im Screen handelt, können sich diese Fenster natürlich auch
nicht verschieben lassen. :-)

Mit 'X1,Y1,X2,Y2' werden die Koordinaten angegeben, wo das Ebenbild
eines Fensters zu stehen kommen soll. Mit 'Title$' wird ein Text
angegeben, der dann in der Fensterleiste zu stehen kommt.

----------------------------------------------------------------------------

@ENDNODE


@NODE Vorgehensweise "So benutzen sie die GadTools."

So benutzen sie die GadTools.
-----------------------------

Um die GadTools-Befehle auch einsetzen zu können, müssen sie das Include-
File erst noch an ihr Hauptprogramm anhängen. Dazu dient die 'Include'-
Anweisung von AMOSPro V2.00. Am besten sie fahren mit dem Cursor auf
die letzte Zeile ihres Sources und tragen dort dann folgendes ein:

Include "Device+Pfad/GadTools.Inc"

Für Device+Pfad müssen sie noch das entsprechende Verzeichnis eintragen
unter dem sich das GadTools-Include befindet.

(Bitte dazu unbedingt auch den Abschnitt @{"Wichtig" LINK Wichtig} Lesen!)

@ENDNODE


@NODE Beispiele "Die Beispiel-Listings."

Die Beispiel-Listings.
----------------------

In dem Verzeichnis ':Beispiele/' befinden sich zu allen Buttons ein
Beispiel-Listing. Dabei liegen diese für alle ScreenModi zur verfügung.
(Lores/Hires/Interlace) Alle Beispiele sind direkt als ASC-Files
abgelegt und können direkt über einen TextED betrachtet werden, oder
eben direkt über 'Merge ASC' in dem AMOSPro-Interpreter eingeladen werden.
Evtl. muss aber noch in der letzten Zeile der Pfad richtig eingestellt
werden, damit die Listings das GadTools-Include auch finden und beiladen
können. Ich habe bewusst darauf verzichtet, grosse Beispiel-Listings zu
schreiben, da das alles nur unübersichtlich machen würde. Jedes Listing
beinhaltet also wirklich nur das nötigste, damit es auch leicht ver-
ständlich bleibt.

@ENDNODE


@NODE Richtlinien "Programmier-Richtlinien"

Programmier-Richtlinien, was man beachten sollte.
-------------------------------------------------

Damit auch alles reibungslos funktioniert, sollte man ein paar wichtige
dinge immer beachten, damit es später keine bösen überraschungen gibt.
Da wäre zum beispiel die verwendung der GadTools-Befehle. Will man an
diese noch weitere AMOS-Befehle anhängen, (also mit Doppelpunkt getrennte
Befehle in einer Zeile) so muss man unbedingt darauf achten, das nach einem
GadTools-Befehl erst ein Freizeichen (Space " ") gesetzt wird, bevor man
einen Doppelpunkt setzt. Beispiel:

_PushButton_Hit : If Param=1 Then Goto Label ...
               ^ ^
               | |

               2 x Freizeichen. (Space " ")


Dies wäre die richtige form der Zeileneingabe. Normalerweise fügt AMOS das
Freizeichen selbstständig ein. Da es sich beim ersten Befehl jedoch um einen
GadTools-Befehl handelt, (Proceduren) würde AMOS diesen ansonsten als 'Label'
Interpretieren.

(Bitte dazu unbedingt auch den Abschnitt @{"Einschränkungen" LINK Einschränkungen} Lesen!)

@ENDNODE


@NODE Einschränkungen "Reservierte Lokale Variablen & Bänke."

Reservierte Lokale Variablen & Bänke.
-------------------------------------

Da es sich bei den GadTools um ein Include-File (Proceduren) handelt und
nicht um eine echte AMOS-Extension, existieren in diesem File auch
Variablen und Bänke die sich im eigenen Hauptprogramm nicht überschneiden
sollten. Deshalb hier eine kurze auflistung aller Variablen & Bänke die
das GadTools-Include benötigt.:

Variablen : A-I, X-Z, A$, B$, C$
AMOS-Bänke: 501-531,601-631,701-731,801-831,901-931,1001-1031,1101-1131

Da Ich keine Globalen Variablen benutzt habe, könnte man die Variablen
auch ohne weiteres im Hauptprogramm einsetzen, solange sie Lokal bleiben,
oder man diese als die sogenannten Schmiervariablen benutzt. Eigentlich
sollte man die Variablen A-Z immer als Schmiervariablen verwenden und
nicht als standfeste werte für irgendwelche Routinen. Erfahrende
Programmierer wissen sicherlich wovon ich rede. ;-)  Was die AMOS-Bänke
betrifft.: Diese enthalten alle Button-Daten wie Position, Farben etc.
Dabei ist z.b. Bank 501 PushButton-1, Bank 502 PushButton-2 u.s.w.
All diese aufgeführten Bänke sollten/dürfen nicht vom Hauptprogramm
verändert, gelöscht, oder neu reserviert werden. Sonst dürfte es
probleme geben. ;-)

@ENDNODE


@NODE Anregungen "Anregungen für weitere versionen."

Anregungen für weitere versionen.
---------------------------------

Wenn Ihr eine idee oder eben einen verbesserungsvorschlag habt, dann
lasst es Mich wissen. Ich bin gerne bereit diese entgegen zu nehmen.
Ihr könnt mich unter folgender adresse erreichen.:


Harald Wagner
Nordring 135
52531 Übach-Palenberg

EMail: Harald@Headless.tng.oche.de

@ENDNODE


@NODE Dank "Ein kleines Dankeschön."

Ein kleines Dankeschön.
-----------------------

An dieser stelle möchte ich mich bei Jens Maertens bedanken, der sich
bereit erklärt hat die GadTools ins Aminet zu Uploaden. Ein weiteres Danke-
schön geht an allen Usern die mir PMs zu den GadTools geschickt haben.

@ENDNODE


@NODE Copyright "Allgemeine Infos zu den GadTools."

Allgemeine Infos zu den GadTools.
---------------------------------

Das GadTools-Include und alles dazugehöhrige ist FreeWare. Es ist ohne
jede einschränkung erlaubt die GadTools in eigene Programme einzubringen.
D.H.: Sie können die GadTools in ihrem Programm weitergeben ob als Source
oder als Compilat. Es ist jedoch NICHT erlaubt veränderungen an den
GadTools (Proceduren) ohne schriftliche genemigung des Autors vorzunehmen.
Von den Autoren die das GadTools-Include einsetzen, erwarte Ich zumindest
das Sie in ihren DOC-Files die herkunft der GadTools erwähnen. Dies
gebietet schliesslich schon der anstand. Es ist allerdings keine Pflicht
dies zu tun, wer das nicht möchte. Aber Ich setze mal das vertrauen in den
Autoren. ;-)

Ein wort zu den Distributoren:
------------------------------

Wer das GadTools-Packet gerne auf seine Serie nehmen möchte kann dies
ohne jede einschränkung tun. Ich habe da allerdings eine Bitte an allen
Distributoren.: Bitte nehmt das ganze Packet mit auf eurer Serie so wie
es ist. D.H.: Nicht nur das Include-File, sondern auch die kompletten
DOCS sowie die Beispiel-Listings und den MaskenEditor. Weiterhin ist das
verbreiten auf CDs sehr erwünscht.

@ENDNODE


@NODE Report "Bug Reports bitte an den Autor senden."

Bug Reports bitte an den Autor senden.
--------------------------------------

Wenn Ihr irgendwelche Fehler gefunden habt, dann bitte Ich Euch Mir
diese mitzuteilen, damit Ich diese schnell beseitigen kann. Meine
Adresse könnt Ihr unter @{"Anregungen" LINK Anregungen} finden.

@ENDNODE


@NODE Wichtig "AMOSPro-Monitor & Compiler!"

Wichtig!
--------

Leider gab es bei einigen Programmierern probleme mit dem GadTools-
Include im zusammenhang mit dem Monitor (F4) & Compiler. Ich möchte jedoch
darauf hinweisen, das dies KEIN Bug vom GadTools-Include ist, sondern ledig-
lich auf ein paar "Krankheiten" vom AMOSPro & Compiler zurückzuführen ist.

Da wäre nähmlich:

1) Kein Compilieren möglich, wenn die GadTools mit der 'Include' Anweisung
   beigeladen werden.

2) Der AMOSPro-Monitor (F4) macht keine Zeilenangabe wo sich das Programm
   gerade befindet.

Zu 1) wäre zu sagen, das der AMOSPro-Compiler grundsätzlich keine Include-
      Anweisungen akzeptiert. (Wohl ein echter AMOS-Bug)

Abhilfe
-------

Die Include-Anweisung vor dem Compilieren aus dem Hauptprogramm entnehmen
und das 'GadTools.inc' direkt am Hauptprogramm beiladen. (Merge im AMOSPro-
Menü) Dannach lässt sich das Programm wieder Compilieren.

Zu 2) wäre zu sagen, das der AMOSPro-Monitor (F4) keine Zeilenangabe machen
      kann, wenn ein AMOSPro-Programm mittels 'Include' am Hauptprogramm
      beigeladen wurde, da sich das Includete File nicht im AMOSPro-Editor
      befindet.

Abhilfe
-------

Wie oben. Include-Anweisung aus dem Hauptprogramm entnehmen und das
'GadTools.inc' direkt am Hauptprogramm beiladen. (Merge im AMOSPro-Menü)
Dann werden auch wieder die Zeilen vom AMOSPro-Monitor markiert, wo sich
der Interpreter gerade befindet.

Ich bitte Sie zu beachten, das Ich alle 'Include' erwähnungen in diesem
Guide grundsätzlich auf dem Interpreter von AMOSPro beziehe. Wer seine
Programme im zusammenhang mit den GadTools, jedoch mit dem AMOSPro-Monitor
Debuggen, oder gar Compilieren möchte, der sollte obige angaben befolgen.
Ansonsten könnte es zu unlösbaren problemen führen, da sich durch einige
unschöne BUGs im AMOSPro-System keine andere lösung finden lässt.

@ENDNODE


@NODE History "Die Entwicklungsgeschichte."

Die Entwicklungsgeschichte.
---------------------------

V1.0 Erste Veröffentlichung.

V1.1 (20.Feb.98)  - _ScreenBar & _WinClone-Anweisung hinzugekommen.
                  - AMask V1.0. Ein MaskenEditor ist hinzugekommen.
                  - E_Guide hinzugefügt.
                  - Kleinere Optimierungen.

@ENDNODE
