Code Modules:
Although placing a machine code routine in an AMOSPro program is very easy,
there are a number of disadvantages to the procedure->insert program method
provided by the editor; firstly and most importantly, it is not possible to
have multiple entries into a piece of code, and it is very difficult to
pass information between routines.  This makes it very awkward to have a
routine with accompanying initialisation code.
The second major disadvantage is that the code has to be PC-Relative.

In an attempt to solve these two problems, the GameSupport extension will
support some kind of Code Module concept.  These will be a normal AmigaDOS
segment, with a header at the front.  This header will contain a pointer to
a hash table of routines, and a pointer to a hash table of attributes, and both
tables will contain textual matchwords for easy access from AMOSPro.
I envisage a module being accessed something like this:

  _MOD1=Gsloadcodemod("code/voxelspace")

  RESULT=Gscallmod(_MOD1,"Initialise")

  Repeat

     Gsset _MOD1,"ChunkyBuffer",CHUNKYBUFFER

     RESULT=Gscallmod(_MOD1,"Render")

     CHUNKYBUFFER=Gschunky2planar

  Until Mouse Key

  Gscallmod(_MOD1,"Cleanup")

  Gsunloadcodemod _MOD1

Obviously, this is purely an example, but it shows how simple such code modules
would be to work with.
The one disadvantage to this approach is that the module needs to be a separate
file and will need to be distributed along with the program.

The text strings for the functions and attributes will need to be referenced
via some kind of hash table.  The simplest solution will be to store the function
or attribute lists in alphabetical order, and make another table containing
pointers to the start of each letter.  This will mean only about 4 or 5 entries
at the most will need to be searched, since the hash table will guide us to an
appropriate starting point.

The format of the Module Header might be something like this:

        bra     Entry   ; The module could contain code for being run outside
                        ; AMOSPro.
        dc.b    "GSModule"      ; this must start within the first 16 bytes.
        dc.l    ModuleName
        dc.l    ModuleAuthor
        dc.l    ModuleComment

        dc.l    FunctionHash

        dc.l    AttributeHash

        ; The header ends here and the following need not follow it directly.

FunctionHash
        dc.l    func_a,func_b,func_c,func_d
        dc.l    func_e,func_f,func_g,func_h
        dc.l    func_i,func_j,func_k,func_l
        dc.l    func_m,func_n,func_o,func_p
        dc.l    func_q,func_r,func_s,func_t
        dc.l    func_u,func_v,func_w,func_x
        dc.l    func_y,func_z,FunctionsEnd

Functions       ; the functions' first letters need to be in alphabetical order,
                ; for speed of search.  The func_<> labels are used to make the
                ; hash table, so the search routine can use the first letter to
                ; narrow down the search to only a few names.
func_a
func_b
func_c
        dc.l    CleanUp
        dc.l    CleanUpName
func_d
func_e
func_f
func_g
func_h
func_i
        dc.l    Initialise
        dc.l    InitialiseName
func_j
func_k
func_l
func_m
func_n
func_o
func_p
func_q
func_r
        dc.l    Render
        dc.l    RenderName
func_s
func_t
func_u
func_v
func_w
func_x
func_y
func_z
FunctionsEnd

CleanUpName
        dc.b    "CleanUp",0
InitialiseName
        dc.b    "Initialise",0
RenderName
        dc.b    "Render",0

        EVEN

AttributeHash
        dc.l    attr_a,attr_b,attr_c,attr_d
        dc.l    attr_e,attr_f,attr_g,attr_h
        dc.l    attr_i,attr_j,attr_k,attr_l
        dc.l    attr_m,attr_n,attr_o,attr_p
        dc.l    attr_q,attr_r,attr_s,attr_t
        dc.l    attr_u,attr_v,attr_w,attr_x
        dc.l    attr_y,attr_z,AttributesEnd

Attributes
attr_a
attr_b
attr_c
ChunkyBuffer
        dc.l    0
        dc.l    ChunkyBufferName
attr_d
attr_e
attr_f
attr_g
attr_h
attr_i
attr_j
attr_k
attr_l
attr_m
attr_n
attr_o
attr_p
attr_q
attr_r
attr_s
attr_t
Theta
        dc.l    0
        dc.l    ThetaName
attr_x
XPos
        dc.l    0
        dc.l    XPosName
attr_y
YPos
        dc.l    0
        dc.l    YPosName
attr_z
ZPos
        dc.l    0
        dc.l    ZPosName
AttributesEnd

ChunkyBufferName
        dc.b    "ChunkyBuffer",0
ThetaName
        dc.b    "Theta",0
XPosName
        dc.b    "XPos",0
YPosName
        dc.b    "YPos",0
ZPosName
        dc.b    "ZPos",0


A number of macros will be written to simplify/neaten the tables.

MakeFunction    MACRO
        dc.l    \1
        dc.l    \1Name
        ENDM

MakeAttr        MACRO
\1
        dc.l    0
        dc.l    \1Name
        ENDM

The lists will then look more like this:

AttributeList
attr_a
attr_b
attr_c
        MakeAttr        ChunkyBuffer
attr_d
attr_e
......
attr_t
        MakeAttr        Theta
attr_u
......
Much neater.

A macro or subroutine will also be needed for searching the lists, and will need
to return a pointer to the data accompanying the matchword.  This will allow
the same search routine to be used to calling a routine, and getting or setting
an attribute.


