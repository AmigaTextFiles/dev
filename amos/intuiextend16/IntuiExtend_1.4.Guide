@database   Intuition  AmosExtention.guide
@Author  CIERP  Philippe  ©1995
@Version  1.4

@node Main "AmosPro IntuitionExtended by CIERP Philippe from AMIGAzette 83."

          @{fg  shine}@{B}Bienvenue dans le monde d'AmosPro...@{UB}@{fg text}

        Cette extention a été codé dans le but de rendre 'AP' (AmosPro.),
    Plus... Amiga. Les commandes et fonctions de cette extention traitent un
     domaine très large dont voici la liste:

                  @{" Les Graphismes en 3d       " link 3d}
                  @{" Les gadgets                " link gad}
                  @{" Les fonctions graphiques   " link gfx}
                  @{" Les Menus                  " link men}
                  @{" La Librairie PowerPacker   " link pp}
                  @{" Les Fonctions des écrans   " link scr}
                  @{" Les fonctions des fenêtres " link wind}
                  @{" Le système                 " link sys}
                  @{" Vidéo et mode graphique    " link vid}
                  @{" Le texte                   " link txt}
                  @{" Utilisation des lecteurs   " link td}
                  @{" Miscellanéous              " link misc}
                  @{" Les requester (ReqTools)   " link Req}
                  @{" Gestion du format IFF      " link iff}
                  @{" Shareware et salutations   " link Philippe}

        P.S.
   Pour des raisons de puissance et de modularité, j'ai préféré laisser à
l'utilisateur un maximun d'action possible.
   Par exemple il aurait été simple de faire une commande pour ouvrir une
fenêtre avec comme dans Amos un numéro d'identification, moi je vois le
couple Amos-Intuition de façon qu'une commande ou une fonction qui affiche
un point ou scroll une fenêtre dans Intuition puisse faire de même dans un
écran Amos.
   Pour ces raisons, je pense que vous comprendrez pourquoi une grande
partie des commandes demandent des adresses mémoire que vous devrez stocker
dans des variables.

@endnode

@node Iff " Gestion du format IFF "

        Rechercher l'adresse d'un Chunk.. @{" Iff Find Chunk   " link Iff0}
        Créer une palette pour un écran.. @{" Iff Make Palette " link Iff1}
        Connaitre le type de fichier Iff. @{" Iff Type         " link Iff2}

NOTA (Notion préliminaire du débutant...)

    >Le format de fichier IFF (Interchange File Format):
        Ce format a ete creer a l'origine pour DPaint par ©Electronic Art.
        Il est compose de segment de donnee suivant une structure qui est
            toujour la meme, le nom du chunk (4 octets), puis la taille du chunk et
            enfin le segment de donnee.
        Le principal chunk est le fichier en lui meme (???), le nom de ce chunk
            est 'FORM' (Hex: $464F524D), sa taille correspont a la taille du fichier-8,
            vient ensuite le type de fichier Iff sur 4 octet, 'ILBM', 'SMUS' ect...
        Enfin tout les autre chunk, le dernier doit normalement etre le
        chunk 'BODY' (Hex: $424F4459).

    >Les chunks:
        A par les chunks 'FORM', et 'BODY' tout les autre sont specifique a chaque type
            de fichier, les commandes de l'extention traite essentiellement du
            format graphique 'ILBM' (Hex: $494C424D).

@endnode

@node Misc " Miscellanéous "

 Le Rastport des écrans Amos.................... @{" Amos Rastport     " link Misc0}
 Décrypter un texte............................. @{" Wb Decrypt        " link Misc1}
 Encrypter un texte............................. @{" Wb Encrypt        " link Misc2}
 Convertir en Héxadécimal....................... @{" Wb Fast Hex       " link Misc3}
 Bloquer le flipping d'Amos..................... @{" Wb Locker         " link Misc4}
 Une nouvelle Commande Peek..................... @{" Wb Peek           " link Misc5}
 Rechercher en mémoire.......................... @{" Shearch           " link Misc6}
 Un String requester facile..................... @{" Wb String Request " link Misc7}
 Un Texte Requester facile...................... @{" Wb Text Request   " link Misc8}
 Un identificateur de fichier................... @{" What Is           " link Misc9}
 Additionner une valeur avec une adresse mémoire @{" Adr Add           " link Miscb}
 Soustraire une valeur avec une adresse mémoire. @{" Adr Sub           " link Miscc}
 Incrémenter une adresse mémoire................ @{" Adr Inc           " link Miscd}
 Décrémenter une adresse mémoire................ @{" Adr Dec           " link Misce}
 Echanger deux adresses de 1 octet.............. @{" Adr Swap.b        " link Miscf}
 Echanger deux adresses de 2 octets............. @{" Adr Swap.w        " link Miscg}
 Echanger deux adresses de 4 octets............. @{" Adr Swap.l        " link Misch}
 Comparer deux segment memoire.................. @{" Wb Mem Compare    " link Misci}
 Prendre l'adresse d'un bitplane................ @{" Wb Bitplane       " link Miscj}
 Connaitre la profondeur d'un rastport.......... @{" Wb Depth          " link Misck}
 Calcul la racine du carré d'un nombre.......... @{" Int Sqr           " link Miscl}
 Ouvrir et affecter une police à un rastport.... @{" Wb Load Font      " link Miscm}
 Définir une liste de Tags (TagList)............ @{" Wb Tag            " link Miscn}


@endnode

@node 3d " Les Graphismes en 3d "

NOTA:
   Les angles de rotation vont de 0 à 359 ou de 1 à 360, cette commande
détient sa propre table des Sin et Cos, de ce fait vous n'avez pas à tenir
compte si votre programme se trouve en mode Radian ou Degrée.
   Les coordonnées dans l'espace 3d a comme centre les points X=0, Y=0 et
Z=0, en coordonnées écran cela correspond toujour au point X=Screen Width/2
et Y=Screen Height/2.

     @{fg  shine}@{B}- Les commandes d'initialisations.@{UB}@{fg text}
    Définir les angles de vue...... @{" Wb 3d Angle    " link 3d0}
    Définir le centre de l'écran... @{" Wb 3d Centre   " link 3d1}
    Position et direction de l'oeil @{" Wb 3d Eye      " link 3d2}
    Affectation de la couleur...... @{" Wb 3d Ink      " link 3dc} Obsolet

     @{fg  shine}@{B}- Les fonctions graphiques@{UB}@{fg text}
    Lignes......................... @{" Wb 3d Draw     " link 3d3}
    Points......................... @{" Wb 3d Plot     " link 3d4}
    Le curseur graphique en 3d..... @{" Wb 3d Locate   " link 3d5}

     @{fg  shine}@{B}- Autres.@{UB}@{fg text}
    Calcul des points d'un objet..  @{" Wb 3d Point    " link 3d6}
    Face cachée et autre........... @{" Wb 3d Position " link 3d7}
    Ecran Amos ou fenêtre Intuition @{" Wb 3d Screen   " link 3d8} Obsolet
    Coordonnées X.................. @{" Wb 3d X        " link 3d9}
    Coordonnées Y.................. @{" Wb 3d Y        " link 3da}
    Coordonnées Z.................. @{" Wb 3d Z        " link 3db}

@endnode

@node gad " Les gadgets "

   @{fg  shine}@{B}Initialisation des gadgets:@{UB}@{fg text}
       Gadget simple (Booleen).............. @{" Wb Init Bool Gadget    " link gad0}
       Slider horizontal.................... @{" Wb Init Hslide Gadget  " link gad1}
       Slider multidirection................ @{" Wb Init Mslide Gadget  " link gad2}
       Gadget de saisie de nombre........... @{" Wb Init Num Gadget     " link gad3}
       Gadget de saisie de texte............ @{" Wb Init Str Gadget     " link gad4}
       Gadget interrupteur (Toggle)......... @{" Wb Init Toggle Gadget  " link gad5}
       Slider vertical...................... @{" Wb Init Vslider Gadget " link gad6}

   @{fg  shine}@{B}Gestion des gadgets:@{UB}@{fg text}
       Active un gadget..................... @{" Wb Activate Gadget     " link gad7}
       Retourne la position d'un HSlider.... @{" Wb Hpos                " link gad8}
       Insérer un gadget dans une liste..... @{" Wb Insert Gadget       " link gad9}
       Redessine un HSlider................. @{" Wb New Hslide gadget   " link gada}
       Redessine un MSlider................. @{" Wb New Mslide gadget   " link gadb}
       Redessine un VSlider................. @{" Wb New Vslide gadget   " link gadc}
       Désactive un gadget.................. @{" Wb Off Gadget          " link gadd}
       Réactive un gadget................... @{" Wb On gadget           " link gade}
       Redessine tous les gadgets........... @{" Wb Refresh All Gadget  " link gadf}
       Redessine un gadget.................. @{" Wb Refresh Gadget      " link gadg}
       Efface tous les gadgets.............. @{" Wb Remove All Gadget   " link gadh}
       Efface un gadget..................... @{" Wb Remove Gadget       " link gadi}
       Retourne la position d'un VSlider.... @{" Wb Vpos                " link gadj}
       Retourne un n° de gadget............. @{" Wb Gadget Id           " link gadv}

   @{fg  shine}@{B}Libération de la mémoire. des gadgets:@{UB}@{fg text}
       d'un gadget 'normal'................. @{" Wb Free Bool Gadget    " link gadk}
       d'un gadget de saisie de nombre...... @{" Wb Free Num Gadget     " link gadl}
       d'un slider.......................... @{" Wb Free Slide gadget   " link gadm}
       d'un gadget de saisie de texte....... @{" Wb free Str Gadget     " link gadn}
       d'un gadget interrupteur............. @{" Wb Free Toggle Gadget  " link gado}

   @{fg  shine}@{B}Fonction graphique:@{UB}@{fg text}
       Assigne une bordure OS2.0 à un gadget @{" Wb Bevel Gadget        " link gadp}
       Assigne des images à un gadget....... @{" Wb Gadget Image        " link gadq}
       Switch entre les Slider 1.3 et 2.0... @{" Wb Slide Swap Look     " link gadr}

   @{fg  shine}@{B}Position du Texte dans les String Requester:@{UB}@{fg text}
       Texte centré......................... @{" Wb Set Str Centre      " link gads}
       Texte à gauche....................... @{" Wb Set Str Left        " link gadt}
       Texte à droite....................... @{" Wb Set Str Right       " link gadu}

@endnode

@node gfx " Les fonctions graphiques "

@{fg  shine}@{B}Liste des fonctions graphiques:@{UB}@{fg text}
        Rectangle plein....................... @{" Wb Bar         " link gfx0}
        Rectangle ombre....................... @{" Wb Bevel Box   " link gfx1}
        Copie avec le blitter................. @{" Wb BLit Copy   " link gfx2}
        Insère un Bob dans une Struc. Image... @{" Wb Bob Image   " link gfx3}
        Rectangle vide........................ @{" Wb Box         " link gfx4}
        Cercle*............................... @{" Wb Circle      " link gfx5}
        Ligne*................................ @{" Wb Draw        " link gfx6}
        Ellipse............................... @{" Wb Ellipse     " link gfx7}
        Affiche une image dans une fenêtre.... @{" Wb Draw Image  " link gfx8a}
        Libère une Struc. Image............... @{" Wb Free Image  " link gfx8}
        Prendre la valeur d'une couleur....... @{" Wb Get Colour  " link gfx9}
        Insère une Icône dans une Struc. Image @{" Wb Icon Image  " link gfxa}
        Remplissage........................... @{" Wb Paint       " link gfxb}
        Mode de remplissage................... @{" Wb Paint Mode  " link gfxc}
        Convertie une couleur................. @{" Wb Pal Antiq   " link gfxd}
        Convertie une couleur................. @{" Wb Pal Grey    " link gfxe}
        Convertie une couleur................. @{" Wb Pal Negativ " link gfxf}
        Convertie une couleur................. @{" Wb Pal Filter  " link gfxt}
        Plot.................................. @{" Wb Plot        " link gfxg}
        Retourne le n° de couleur d'un point*. @{" Wb Point       " link gfxh}
        Affiche un point à l'écran*........... @{" Wb Pset        " link gfxi}
        Scroll un RastPort.................... @{" Wb Scroll      " link gfxj}
        Modifie la valeur d'une couleur....... @{" Wb Set Colour  " link gfxk}
        Définie un masque de ligne............ @{" Wb Set Line    " link gfxl}
        Retourne la valeur du mode SuperHires. @{" Shires         " link gfxm}
        Affiche un Spline..................... @{" Wb Spline      " link gfxn}
        Avance le curseur en mode tortue...... @{" Wb Turtle Curs " link gfxo}
        Affiche une ligne en mode tortue...... @{" Wb Turtle Draw " link gfxp}
        Affiche un point en mode tortue....... @{" Wb Turtle Plot " link gfxq}
        Affiche une jauge..................... @{" Wb Gauge       " link gfxr}
        Calculer la longueur d'un segment..... @{" Wb Distance    " link gfxs}

* Version très optimisée, elles ne sont pas affectées par les commandes du
du type 'Gr Writting'.

@endnode

@node men " Les Menus "


@{fg  shine}@{B}Gestion des menus intuition:@{UB}@{fg text}

     Recherche d'un sous menu............... @{" Wb Find Menu Item " link men0}
     Prend le menu d'une fenêtre............ @{" Wb Get Menu Adr   " link men1}
     Eliminer un menu....................... @{" Wb Kill Menu      " link men2}
     Assigner un menu à une fenêtre......... @{" Wb Menu To Window " link men3}
     Désactiver un menu..................... @{" Wb Off Menu       " link men4}
     Activer un menu........................ @{" Wb On Menu        " link men5}
     Retourne le n° du menu sélectionné..... @{" Get Menu Msg      " link men6}
     Retourne le n° de l'item sélectionné... @{" Get Item Msg      " link men7}
     Retourne le n° du sous-item sélectionné @{" Get SubItem Msg   " link men8}
     Retourne l'adresse d'un menu........... @{" Get Menu Code    " link men9}


@endnode

@node pp " La Librairie PowerPacker "

@{fg  shine}@{B}Le compactage et décompactage de données:@{UB}@{fg text}

        Compacter une zone mémoire.... @{" Pp Crunch   " link pp0}
        Décompacter un fichier........ @{" Pp Decrunch " link pp1}
        Libérer la mémoire occupée.... @{" Pp Free     " link pp2}
        Retourne la taille du fichier. @{" Pp Len      " link pp3}
        Retourne l'adresse du fichier. @{" Pp Start    " link pp4}
        Sauvegarde une zone compactée. @{" Pp Write    " link pp5}

@endnode

@node scr " Les Fonctions des écrans "

@{fg shine}@{B}Gestion des écrans intuition:@{UB}@{fg text}
   Retourne l'adresse de l'écran sélectionné.... @{" Wb Current Screen        " link scr0}
   Retourne l'adresse de l'écran en premier plan @{" First Screen             " link scr1}
   Place un écran en arrière plan............... @{" Wb Screen Back           " link scr4}
   Retourne l'adresse du dernier écran ouvert... @{" Wb Screen Base           " link scr5}
   Ferme un écran............................... @{" Wb Screen Close          " link scr6}
   Place un écran en premier plan............... @{" Wb Screen Front          " link scr7}
   Déplace un écran............................. @{" Wb Screen move           " link scr8}
   Ouvre un écran............................... @{" Wb Screen Open           " link scr9}
   Retourne le RastPort d'un écran.............. @{" Wb Screen Rastport       " link scra}
   Assigne un écran à certaine fonction amos.... @{" Wb Screen                " link scrb}
   Ouvrir un écran avec TagList................. @{" Wb Open Screen Taglist   " link scrg}
   Placer une couleur dans la palette d'un écran @{" Wb Screen Colour         " link scrh}
   Affecter une Palette à un écran.............. @{" Wb Screen palette        " link scri}

@{fg shine}@{B}Gestion des écrans publics:@{UB}@{fg text}
   Vérrouille un écran public................... @{" Wb Lock Pubscreen        " link scr2}
   Déverrouille un écran public................. @{" Wb Unlock Pubscreen      " link scr2a}
   Retourne le nom du premier écran public...... @{" Wb Pubscreen Name        " link scr3}
   Obtenir la position d'un écran publique...... @{" Wb Next Pubscreen        " link scrc}
   Définie un écran public par défaut........... @{" Wb Set Default Pubscreen " link scrd}
   Définie un nouveau mode...................... @{" Wb Set Pubscreen Mode    " link scre}
   Définie un nouveau status.................... @{" Wb Set Pubscreen Status  " link scrf}

@endnode
@node wind " Les fonctions des fenêtres "

@{fg shine}@{B}Gestion des fenêtres intuition:@{UB}@{fg text}

  Retourne l'adresse de la fenêtre active.......... @{" Wb Current Window    " link wind0}
  Modifie les valeurs IDCMP d'une fenêtre.......... @{" Wb New Idcmp         " link wind1}
  Place une fenêtre en arrière plan................ @{" Wb Wind Back         " link wind2}
  Retourne l'adresse de la dernière fenêtre ouverte @{" Wb Wind Base         " link wind3}
  Ferme une fenêtre................................ @{" Wb Wind Close        " link wind4}
  Place une fenêtre en premier plan................ @{" Wb Wind Front        " link wind5}
  Définie les nouvelles limites d'une fenêtre...... @{" Wb Wind Limit        " link wind6}
  Déplace une fenêtre.............................. @{" Wb Wind Move         " link wind7}
  Ouvre une nouvelle fenêtre....................... @{" Wb Wind Open         " link wind8}
  Retourne le RastPort d'une fenêtre............... @{" Wb Wind Rastport     " link wind9}
  Change la taille d'une fenêtre................... @{" Wb Wind Size         " link winda}
  Change le Titre d'une fenêtre/écran.............. @{" Wb Wind Title        " link windb}
  Retoune la pos. X de la sourie dans une fenêtre.. @{" X Wind               " link windc}
  Retoune la pos. Y de la sourie dans une fenêtre.. @{" Y Wind               " link windd}
  Modifier la taille d'une fenêtre................. @{" Wb Change Window Box " link winde}
  Actionner le bouton 'Zoom' d'une fenêtre......... @{" Wb Zip Window        " link windf}

@endnode
@node sys " Le système "

@{fg shine}@{B}Gestion de la mémoire:@{UB}@{fg text}
      Alloue de la mémoire absolue.......... @{" Alloc Abs          " link sys0}
      Alloue de la mémoire.................. @{" Alloc Mem          " link sys1}
      Information sur la mémoire............ @{" Avail Mem          " link sys2}
      Copie un segment mémoire.............. @{" Copy Mem           " link sys3}
      Libère de la mémoire.................. @{" Free Mem           " link sys4}
      Sauvegarde un segment mémoire......... @{" Write Mem          " link sys5}

@{fg shine}@{B}Gestion des Messages-Ports:@{UB}@{fg text}
      Attente d'un événement................ @{" Get Msg            " link sys6}
      Retourne un événement Code............ @{" Get Msg Code       " link sys7}
      Retourne une adresse Intuition........ @{" Get Msg Iadr       " link sys8}
      Retourne un événement Qualifié........ @{" Get Msg Qualifier  " link sys9}
      Retourne la pos. X de la sourie....... @{" Get Msg Xm         " link sysa}
      Retourne la pos. Y de la sourie....... @{" Get Msg Ym         " link sysb}
      Créer un nouveau MsgPort.............. @{" Wb Create Msgport  " link sysu}
      Effacer un MsgPort.................... @{" Wb Erase Msgport   " link sysv}
      Attendre un Message à un MsgPort...... @{" Wb Get Msg         " link sysw}
      Libérer le MsgPort pour un autre Msg.. @{" Wb Reply Msg       " link sysx}

@{fg shine}@{B}Les tâches et process:@{UB}@{fg text}
      Charge un programme en segment de code @{" Load Seg           " link sysc}
      Retourne l'adresse du programme....... @{" My Task            " link sysd}
      Retourne l'adresse du premier segment. @{" Segment Base       " link syse}
      Définie une nouvelle priorité......... @{" Set Taskpri        " link sysf}
      Modifie le nom système d'une tâche.... @{" Task Name          " link sysg}
      Libère la mémoire d'un segment........ @{" Unload Seg         " link sysh}

@{fg shine}@{B}Autres:@{UB}@{fg text}
      Retourne la date système (JJ/MM/AAAA). @{" Wb Date            " link sysi}
      Affiche un requester d'alerte......... @{" Wb Display Alert   " link sysj}
      Affiche le Beep et le flash système... @{" Wb Display Beep    " link sysk}
      Retourne l'état de la sourie.......... @{" Hard Mouse Key     " link sysl}
      Reboot l'Amiga........................ @{" Wb Reset           " link sysm}
      Retourne l'heure système (HH:MM:SS)... @{" Wb Swatch          " link sysn}
      Affiche un requester système.......... @{" Wb Sys Requester   " link syso}
      Ferme le Workbench.................... @{" Wb Close           " link sysp}
      Ouvre le Workbench.................... @{" Wb Open            " link sysq}
      Retourne le type d'Agnus utilisé...... @{" Sys Agnus          " link sysr}
      Retourne le ChipSet utilisé........... @{" Sys Chip           " link syss}
      Retourne le type de KickStart utilisé. @{" Sys Kickstart      " link syst}
      Retourne le type de microprocesseur... @{" Sys Cpu            " link sys10}
      Y a-t-il un copro-Mathématique........ @{" Sys Math           " link sys11}

      Créer une AppIcon..................... @{" App Create Icon    " link app0}
      Libérer une AppIcon................... @{" App Free Icon      " link app1}
      Prendre un argument d'une AppIcon..... @{" App Get Arglist    " link app2}
      Retourne le nombre d'argument......... @{" App Get Numarg     " link app3}
      Libére une Struct. Diskobject......... @{" Wb Free Diskobject " link app4}
      Réserver une Icon 'Def_Icon'.......... @{" Wb Get Deficon     " link app5}
      Effacer le pointeur de la sourie...... @{" Wb Mouse Off      " link sysy}
      Afficher le pointeur de la sourie..... @{" Wb Mouse On       " link sysz}

@endnode

@node txt " Le texte "

@{fg shine}@{B}Le texte graphique:@{UB}@{fg text}
      Modifie la pos. du curseur graphique........ @{" Wb Curs         " link txt0}
      Affiche un texte centré..................... @{" Wb Gfx Centre   " link txt1}
      Modifie les couleurs du texte............... @{" Wb Gfx Ink      " link txt2}
      Modifie le mode d'affichage du texte........ @{" Wb Gfx Mode     " link txt3}
      Affiche du texte............................ @{" Wb Gfx Text     " link txt4}
      Modifie l'espace entre les caractères....... @{" Wb Text Spacing " link txt5}
      Modifie le style de texte................... @{" Wb Text Style   " link txt6}

@{fg shine}@{B}Le texte intuition:@{UB}@{fg text}
      Affiche un texte............................ @{" Wb Print        " link txt7}
      Modifie les couleurs du texte............... @{" Wb Print Ink    " link txt8}
      Modifie la position du Texte................ @{" Wb Print Locate " link txt9}
      Définie le mode d'affichage................. @{" Wb Print Mode   " link txta}
      Déplace le curseur en mode tortue........... @{" Wb Print Xmove  " link txtb}
      Idem........................................ @{" Wb Print Ymove  " link txtc}
      Copie du texte IntuiTexte................... @{" Wb Poke$        " link txtd}
      Retourne la position X du curseur........... @{" Wb X Locate     " link txte}
      Idem.(mais en pixel)........................ @{" Wb X Print      " link txtf}
      Retourne la position Y du curseur........... @{" Wb Y Locate     " link txtg}
      Idem.(mais en pixel)........................ @{" Wb Y Print      " link txth}

@{fg shine}@{B}Autres:@{UB}@{fg text}
      Retourne la taille d'un texte en pixel...... @{" Wb Gfx Len      " link txti}
      Reserve un emplacement memoire pour du texte @{" Str Store       " link txtj}
      Libere l'emplacement memoire................ @{" Str Free        " link txtk}

@endnode
@node td " Utilisation des lecteurs "



@{fg shine}@{B}Lecture/Ecriture sur les lecteurs:@{UB}@{fg text}

       Lecture d'un Block....... @{" Wb Block Read   " link td0}
       Mise à jour d'un block... @{" Wb Block Update " link td1}
       Ecriture d'un block...... @{" Wb Block Write  " link td2}
       Fermeture du trackdisk... @{" Wb Td Close     " link td3}
       Retourne une erreur...... @{" Wb Td Error     " link td4}
       Eteint le moteur......... @{" Wb Td Motor Off " link td5}
       Allume le moteur......... @{" Wb Td Motor On  " link td6}
       Ouvre le trackdisk....... @{" Wb Td Open      " link td7}
       Formate une piste........ @{" Wb Track Format " link td8}
       Lis une piste............ @{" Wb Track Read   " link td9}
       Ecris une piste.......... @{" Wb Track Write  " link tda}

@endnode

@node vid " Vidéo et mode graphique "

@{fg shine}@{B}Le mode vidéo:@{UB}@{fg text}

    Retourne la fréquence du PowerLed. @{" Power Frequence " link vid0}
    Modifier le ChipSet AA............ @{" Wb Set Chip Rev " link vid1}
    Passe en mode NTSC................ @{" Switch Ntsc     " link vid2}
    Passe en mode PAL................. @{" Switch Pal      " link vid3}
    Retourne la fréquence VBL moniteur @{" Vbl Frequence   " link vid4}
    Teste si le ChipSet AA existe..... @{" Wb Check Aga    " link vid5}
    Désactive le Chipset AA........... @{" Wb Kill Aga     " link vid6}

@endnode

@node Req "Les requester de la reqtools.library."

    @{fg shine}L'utilisation des requester@{fg text}

         Directory Requester................... @{" Rt Dir Req       " link Req0}
         File Requester........................ @{" Rt File Req      " link Req1}
         Libérer une Fileliste................. @{" Rt Free Flist    " link Req2}
         Prendre le répertoire sélectionné..... @{" Rt Get Dir$      " link Req3}
         Prendre un nom dans la 'FileList'..... @{" Rt Get Flist     " link Req4}
         Prendre le nom de fichier sélectionné. @{" Rt Get Name$     " link Req5}
         Fermer la reqtools.library............ @{" Rt Lib Close     " link Req6}
         Ouvrir la reqtools.library............ @{" Rt Lib Open      " link Req7}
         File Requester avec multi-sélection... @{" Rt Multifile Req " link Req8}
         Afficher un TextRequester............. @{" Rt Text Req      " link Req9}
         Afficher un NumberRequester........... @{" Rt Number Req    " link ReqA}
@endnode

@node Philippe " Shareware et salutations "

@{fg shine} IntuiExtend v1.4 ©1995                           AMOSPro Extention system
 Programmation: CIERP Philippe-AMIGAzette 83
  Beta-testeur: FONTAINE Pierre-Sullivann/Brain.Lego@{fg text}

    L'extention @{B}AMOSPro_IntuiExtend.lib@{UB}, est compatible avec @{B}AMOSPro v1.12+@{UB},
  si vous désirez vous faire enregistrer, vous pouvez m'écrire à cette
  adresse:
                          @{B} CIERP Philippe
                          La cigalière n°7
                          83136   GAREOULT@{UB}

    Le prix dérisoire de l'extention est de @{B}70 FFrs@{UB} (Frais de port+disquette
  inclus).
    Le pack comprend:
@{fg shine}
  -La dernière version de l'extention (sans le requester d'alerte).
  -De nouvelles commandes et fonctions.
  -Le programme complet du compte-chèque 'Excell'Compte-chèque'.
    * Compte-chèque tournant directement dans le Workbench, et utilisant
    * la reqtools.library, intelligent, il s'ouvre directement dans
    * l'écran en premier plan et ouvre son propre écran s'il n'en éxiste
    * pas, il gére les chèques sortis ou non en deux soldes séparés.
  -Les librairies systèmes utilisées.
  -Les exemples compilés et en fichier Ascii.
  -La version pour Amos dès sa parution (Non incluse dans cette version).
  -La documentation commande par commande est en version AmigaGuide.
  -Une aide de ma part (par courrier), pour tout problème de programmation
   incluant l'extention.@{fg text}

    Vous avez la possibilité sur simple demande lors de votre enregistrement
  de garder le requester d'alerte avec un texte de votre choix...
  NOTA: Dans ce cas, le requester sera inclus dans chaque programme compilé
  utilisant ou non l'extention.

    Cette extention est un @{B}ShareWare@{UB} et implique de ce fait, un CopyRight,
  des droits de diffusions limités (pour la version démo, pour les services
  du Domaine publique intéressés par sa diffusion, je me ferais un plaisir
  de personnaliser cette version sur leur demande, et de la leur faire parvenir.

@endnode

@node 3d0 " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Angle AX,AY,AZ@{fg text}

    Entrée: AX=Angle de rotation sur l'axe horizontal.
            AY=Angle de rotation sur l'axe vertical.
            AZ=Angle de rotation sur l'axe de profondeur.

@endnode
@node 3d1 " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Centre X,Y@{fg text}

    Entrée: X=Coord. horizontale du centre de l'écran.
            Y=Coord. verticale du centre de l'écran.

  Remarque: Ex: Wb 3d Centre Screen Width/2,Screen Height/2

@endnode
@node 3d2 " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Eye X,Y,Z@{fg text}

    Entrée: X=Position horizontale du point.
            Y=Position verticale du point.
            Z=Position de profondeur du point.

  Remarque: Placement de l'observateur dans l'espace 3d.
            La position centrale st Wb 3d Eye 0,0,0 ce qui
           correspond au centre de l'objet.

                         -Y  +Z
                          | /
                    -X -- * -- +X
                         /|
                       -Z +Y
@endnode
@node 3d3 " Date: 28/09/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Draw X,Y,Z@{fg text}

    Entrée: X=Coord. horizontale du point.
            Y=Coord. verticale du point.
            Z=Coord. de profondeur du point.

  Remarque: Affiche une Ligne du curseur graphique aux coordonnées X,Y,Z.

@endnode
@node 3d4 " Date: 28/09/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Plot X,Y,Z@{fg text}

    Entrée: X=Coord. horizontale du point.
            Y=Coord. verticale du point.
            Z=Coord. de profondeur du point.

  Remarque: Affiche un Point aux coordonnées X,Y,Z.

@endnode
@node 3d5 " Date: 28/09/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Locate X,Y,Z@{fg text}

    Entrée: X=Coord. horizontale du point.
            Y=Coord. verticale du point.
            Z=Coord. de profondeur du point.

  Remarque: Positionne le curseur graphique aux coordonnées X,Y,Z.

@endnode
@node 3d6 " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Point X,Y,Z@{fg text}

    Entrée: X=Coord. horizontale du point.
            Y=Coord. verticale du point.
            Z=Coord. de profondeur du point.

      Voir: @{" Wb 3d X " link 3d9}, @{" Wb 3d Y" link 3da} et @{" Wb 3d Z" link 3db}.

@endnode
@node 3d7 " Date: 30/08/95                                       System: v1.3+"

Synoptique: @{fg shine}C=Wb 3d Position(X0,Y0,X1,Y1,X2,Y2)@{fg text}

    Entrée: X0,Y0=Coordonnées 'écran' du 1er point du polygone.
            X1,Y1=Coordonnées 'écran' du 2ème point du polygone.
            X2,Y2=Coordonnées 'écran' du 3ème point du polygone.

    Sortie: C=Retourne l'indice correspondant à l'orientation du
            polygone.
            Si C>0 la face est orientée vers l'arrière (face cachée).

  Remarque: NOTA: L'indice peut être utilisé pour calculer rapidement
            la luminosité de chaque face.

@endnode
@node 3d8 " Date: 28/09/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb 3d Screen RPORT@{fg text}

NOTA: Cette fonction est obsolette, utilisez @{" Wb Screen " link scrb} dans vos nouveaux
      programmes, pour des raisons de compatibilité elle n'a pas été supprimée
      mais se comporte de la même manière.

@endnode
@node 3d9 " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}X=Wb 3d X@{fg text}

    Sortie: X=Coord écran du point horizontal.

      Voir: @{" Wb 3d Point " link 3d6}.

@endnode
@node 3da " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Y=Wb 3d Y@{fg text}

    Sortie: Y=Coord écran du point vertical.

      Voir: @{" Wb 3d Point " link 3d6}.

@endnode
@node 3db " Date: 13/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Z=Wb 3d Z@{fg text}

    Sortie: Z=Coord de la profondeur.

      Voir: @{" Wb 3d Point " link 3d6}.

@endnode
@node 3dc " Date: 08/11/95                                       System: v1.3+"

NOTA: Cette fonction est obsolette, Utilisez la commande AMOS 'Ink CF,CB'
      dans vos nouveaux programmes, pour des raisons de compatibilité elle
      n'a pas été supprimée mais a été désactivée...

Synoptique: @{fg shine}Wb 3d Ink COULEUR@{fg text}

    Entrée: COULEUR=Couleur prévue pour les commandes
            'Wb 3d Draw' et 'Wb 3d Plot'.

@endnode

@node Gad0 " Date: 29/04/95                                       System: v1.3+"                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Bool Gadget(NUM,X,Y,W,H,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad1 " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Hslide Gadget(NUM,X,Y,W,H,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad2 " Date: 29/04/95                                       System: v1.3+"

Synoptique:   @{fg shine}GADGET=Wb Init Mslide Gadget(NUM,X,Y,W,H,FLAG)@{fg
text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad3 " Date: 01/05/95                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Num Gadget(NUM,X,Y,W,H,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad4 " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Str Gadget(NUM,X,Y,W,H,STRADR,MAX,VIS,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            STRADR=
            MAX=Nombre max. de caractère du buffer.
            VIS=Nombre max. de caractère visible.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad5 " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Toggle Gadget(NUM,X,Y,W,H,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad6 " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}GADGET=Wb Init Vslide Gadget(NUM,X,Y,W,H,FLAG)@{fg text}

    Entrée: NUM=N° du gadget.
            X,Y=Coordonnées du point de départ
            W,H=Hauteur et largeur.
            FLAG=Flag pour le gadget.
                 0 - Inversion (not).
                 1 - Inversion du cadre exterieur du gadget.
                 2 - Active un gadget graphique.
                 3 - Pas de changement visible.

    Sortie: GADGET=Adresse d'un gadget

  Remarque: Initialise un espace mémoire pour un gadget.

@endnode
@node Gad7 " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Activate Gadget WIND,GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

  Remarque: Active un gadget.

@endnode
@node Gad8 " Date: 05/05/95                                       System: v1.3+"

Synoptique: @{fg shine}HPOS=Wb Hpos(SLID)@{fg text}

    Entrée: SLID=Adr du gadget (Slider)

    Sortie: HPOS=Compteur horizontal actuel

@endnode
@node Gad9 " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Insert Gadget WIND To GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

  Remarque: Insert le gadget GADGET dans la gadget-liste
            d'une fenêtre.

@endnode
@node Gada " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb New Hslide Gadget WINDOW To GADGET,XPOS,XLEN@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre.
            GADGET=Adresse d'un gadget.
            XPOS=Position du curseur.
            XLEN=Taille du curseur.

  Remarque: Initialise et affiche un gadget proportionnel.

@endnode
@node Gadb " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb New Mslide Gadget WINDOW To GADGET,XPOS,YPOS,XLEN,YLEN@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre
            GADGET=Adresse d'un gadget
            XPOS,YPOS=Position du curseur.
            XLEN,YLEN=Taille du curseur.

  Remarque: Initialise et affiche un gadget proportionnel.

@endnode
@node Gadc " Date: 29/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb New Vslide Gadget WINDOW To GADGET,YPOS,YLEN@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre
            GADGET=Adresse d'un gadget
            YPOS=Position du curseur.
            YLEN=Taille du curseur.

  Remarque: Initialise et affiche un gadget proportionnel.

@endnode
@node Gadd " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Off Gadget WIND,GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

  Remarque: Désactive le gadget en le grisant.

@endnode
@node Gade " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb On Gadget WIND,GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

  Remarque: Active un gadget désactivé.

@endnode
@node Gadf " Date: 24/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Refresh All Gadget WINDOW@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre.

  Remarque: Redessine TOUS les gadgets d'une fenêtre.

@endnode
@node Gadg " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Refresh Gadget WIND,GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

  Remarque: Permet de redessinner le gadget GADGET.

@endnode
@node Gadh " Date: 24/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Remove All Gadget WINDOW@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre.

  Remarque: Elimine TOUS les gadgets d'une fenêtre.

@endnode
@node Gadi " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Remove Gadget WIND,GADGET@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            GADGET=Adresse d'un gadget

@endnode
@node Gadj " Date: 05/05/95                                       System: v1.3+"

Synoptique: @{fg shine}VPOS=Wb Vpos(SLID)@{fg text}

    Entrée: SLID=Adr du gadget (Slider)

    Sortie: VPOS=Compteur vertical actuel

@endnode
@node Gadk " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Bool Gadget GADGET@{fg text}

    Entrée: GADGET=Adresse du GADGET.

  Remarque: Libère la mémoire.

@endnode
@node Gadl " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Num Gadget GADGET@{fg text}

    Entrée: GADGET=Adresse du GADGET.

  Remarque: Libère la mémoire.

@endnode
@node Gadm " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Slide Gadget GADGET@{fg text}

    Entrée: GADGET=Adresse du GADGET.

  Remarque: Libère la mémoire.

@endnode
@node Gadn " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Str Gadget GADGET@{fg text}

    Entrée: GADGET=Adresse du GADGET.

  Remarque: Libère la mémoire.

@endnode
@node Gado " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Toggle Gadget GADGET@{fg text}

    Entrée: GADGET=Adresse du GADGET.

  Remarque: Libère la mémoire.

@endnode
@node Gadp " Date: 01/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Bevel gadget GADGET@{fg text}

    Entrée: GADGET=Adresse d'un gadget

  Remarque: Insère des bordures style 2/3.0 à un gadget
            du type Bool et Toggle.

@endnode
@node Gadq " Date: 07/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gadget Image IM1,IM2 To GADGET@{fg text}

    Entrée: IM1, IM2=Adr des images à inclure dans le gadget
            voir @{" Wb Icon Image " link Gfx3} et @{" Wb Bob Image " link Gfxa}
            GADGET=Adresse du gadget.

@endnode
@node Gadr " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Slide Swap Look SLIDER@{fg text}

    Entrée: SLIDER=Adresse du Slider

  Remarque: Switch entre le look du 1.2 et 1.3+"

@endnode
@node Gads " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Set Str Centre STRGAD@{fg text}

    Entrée: STRGAD=Adresse du String ou Number Gadget.

  Remarque: Justifie la chaîne du gadget au centre

@endnode
@node Gadt " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Set Str Left STRGAD@{fg text}

    Entrée: STRGAD=Adresse du String ou Number Gadget.

  Remarque: Justifie la chaîne du gadget à gauche

@endnode
@node Gadu " Date: 20/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Set Str Right STRGAD@{fg text}

    Entrée: STRGAD=Adresse du String ou Number Gadget.

  Remarque: Justifie la chaîne du gadget à droite

@endnode
@node Gadv " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}GADNB=Wb Gadget Id(GADADR)@{fg text}

     Entré: GADADR=Adresse du gadget.

    Sortie: GADNB=Position du gadget dans la liste des gadgets d'une
                  fenêtre.

@endnode
@node Gfx0 " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Bar RPORT To X,Y,W,H@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées supérieures gauches
            W,H=Coordonnées inférieures droites

@endnode
@node Gfx1 " Date: 04/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Bevel Box RPORT To C0,C1,X,Y,BX,BY@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées supérieures gauches
            BX,BY=Coordonnées inférieures droites
            C0, C1=Couleur sup. et inf. des bordures.

@endnode
@node Gfx2 " Date: 19/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Blit Copy SRP,SX,SY,W,H To DRP,DX,DY,MODE@{fg text}

    Entrée: SRP,DRP=Rastport Source et Destination
            SX,SY,W,H=Coordonnées Source du Clip
            W,H=Hauteur et largeur.
            DX,DY=Coordonnées Destination
            MODE=Mode de copie du Blitter sur 8 Bits (%00000000)
            La combinaison des bits permet différents effets.

@endnode
@node Gfx3 " Date: 03/05/95                                       System: v1.3+"

Synoptique: @{fg shine}IMAG=Wb Bob Image(BOB)@{fg text}

    Entrée: BOB=N° du Bob

    Sortie: Adresse de la structure image

  Remarque: En conjonction avec les gadgets et l'affichage
            des images dans une fenêtre.

@endnode
@node Gfx4 " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Box RPORT To X,Y,W,H@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées supérieures gauches
            W,H=Coordonnées inférieures droites

@endnode
@node Gfx5 " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Circle X,Y,RADIUS@{fg text}

    Entrée: X,Y=Coordonnées centrales du cercle
            RADIUS=Rayon du cercle

  Remarque: Voir la commande 'Circle' dans Amos.

@endnode
@node Gfx6 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Draw X0,Y0 To X1,Y1@{fg text}
   Forme 2: @{fg shine}Wb Draw X1,Y1@{fg text}

    Entrée: RPORT=Ptr sur la Structure RPort de la fenêtre
            X0,Y0=Coordonnées du point de départ
            X1,Y1=largeur et hauteur

@endnode
@node Gfx7 " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Ellipse RPORT To X,Y,RADX,RADY@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées centrales de l'ellipse
            RADX, RADY=Rayon Horiz. et Vert. de l'ellipse

@endnode

@node Gfx8a " Date: 03/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Draw Image IMAG@ To RPORT,TOPX,TOPY@{fg text}

     Entré: IMAG=Adresse de la structure Image.
                 Voir 'Wb Icon Image' ou 'Wb Bob Image'
            RPORT=Ptr sur la Structure RPort de la fenêtre
            TOPX,TOPY=Coordonnées de départ de l'image.

@endnode


@node Gfx8 " Date: 03/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Image IMAG@{fg text}

    Entrée: IMAG=Adresse de la structure Image.

  Remarque: Libère la mémoire.

@endnode
@node Gfx9 " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}COLOUR=Wb Get Colour(SCREEN,CNB)@{fg text}

    Entrée: SCREEN=Adresse de l'écran.
            CNB=Couleur n°

    Sortie: COLOUR=Composition de la couleur n° ?

@endnode
@node Gfxa " Date: 03/05/95                                       System: v1.3+"

Synoptique: @{fg shine}IMAG=Wb Icon Image(ICON)@{fg text}

    Entrée: ICON=N° de l'icône

    Sortie: Adresse de la structure image

  Remarque: En conjonction avec les gadgets et l'affichage
            des images dans une fenêtre.

@endnode
@node Gfxb " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Paint RPORT To X,Y@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées du point de départ

      Voir: @{" Wb Paint Mode " link Gfxc}

@endnode
@node Gfxc " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Paint Mode MODE@{fg text}

    Entrée: MODE=Mode de dessin de 0 a 255

  Remarque: Définie le mode graphique pour la fonction
            de remplissage de surface.

@endnode
@node Gfxd " Date: 24/04/95                                       System: v1.3+"

Synoptique: @{fg shine}ANTIQ=Pal Antiq(COULEUR)@{fg text}

    Entrée: COULEUR=Composante RVB d'une couleur

    Sortie: ANTIQ=Nouvelle composante 'Antique'

        Ex: Colour 0,Pal Antiq(Colour(0))

@endnode
@node Gfxe " Date: 24/04/95                                       System: v1.3+"

Synoptique: @{fg shine}GREY=Pal Grey(COULEUR)@{fg text}

    Entrée: COULEUR=Composante RVB d'une couleur

    Sortie: GREY=Nouvelle composante en 'ton de gris'

        Ex: Colour 0,Pal Grey(Colour(0))

@endnode
@node Gfxf " Date: 24/04/95                                       System: v1.3+"

Synoptique: @{fg shine}NEGAT=Pal Negativ(COULEUR)@{fg text}

    Entrée: COULEUR=Composante RVB d'une couleur

    Sortie: NEGAT=Nouvelle composante 'Négative'

        Ex: Colour 0,Pal Negativ(Colour(0))

@endnode
@node Gfxg " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Plot RPORT To X,Y@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Nombre de pixel relatif au point de départ

@endnode
@node Gfxh " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}CNB=Wb Point(X,Y)@{fg text}

    Entrée: X,Y=Coordonnées du point

    Sortie: CNB=Couleur N° ?

      Voir: Cette commande optimisée fonctionne environs
            deux fois plus vite que la commande 'Point()'
            d'AmosPro.

@endnode
@node Gfxi " Date: 30/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Pset X,Y,C@{fg text}

    Entrée: X,Y=coordonnées du point à allumer.
            C=N° de la couleur.

  Remarque: NOTA: Cette commande ne modifie pas la position
            du curseur graphique de l'écran (amos), ou de
            la fenêtre (Intuition).

@endnode
@node Gfxj " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Scroll RPORT To X,Y,W,H,XSTEP,YSTEP@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Coordonnées supérieures gauches
            W,H=longueur (Width) et Largeur (Height)
            XSTEP,YSTEP=Nombre de pixel pour le Scroll

@endnode
@node Gfxk " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Set Colour SCREEN To CNB,R,G,B@{fg text}

    Entrée: SCREEN=Adresse de l'écran.
            CNB=Couleur n° ?
            R,G,B=Composante RGB de 0 à 15

  Remarque: Définie la couleur CNB, de la fenêtre

@endnode
@node Gfxl " Date: 06/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Set Line RPORT,LINEPATTERN@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            LINEPATTERN=Pattern de 32 bit.

@endnode
@node Gfxm " Date: 04/04/95                                       System: v1.3+"

Synoptique: @{fg shine}SHIRES=Shires@{fg text}

    Sortie: SHIRES=Flag pour la résolution SuperHires

  Remarque: Utilisation identique à lowres,Hires ou Laced
            ce flag est ignoré par les écrans AMOS.

@endnode
@node Gfxn " Date: 30/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Spline X0,Y0 To X1,Y1 To X2,Y2,NB@{fg text}

    Entrée: X0,Y0=Point de départ de la courbe.
            X1,Y1=Point Relatif pour la courbure.
            X2,Y2=Point d'arrivée.
            NB=Nombre de ligne qui compose le 'Spline'

  Remarque: NOTA: Plus NB est élevé, plus la courbe est...
            parfaite.

@endnode
@node Gfxo " Date: 04/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Turtle Curs RPORT To X,Y@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Nombre de pixel relatif au point de départ

@endnode
@node Gfxp " Date: 04/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Turtle Draw RPORT To X,Y@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Nombre de pixel relatif au point de départ

@endnode
@node Gfxq " Date: 05/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Turtle Plot RPORT To X,Y@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            X,Y=Nombre de pixel relatif au point de départ

@endnode
@node Gfxr " Date: 30/03/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gauge P,CJ,CF,X1,Y1 To X2,Y2@{fg text}

     Entré: P=Pourcentage de remplissage de la jauge (de gauche/0 à
            droite/100...).
            CJ,CF=Couleur de la jauge et du fond.
            X1,Y1,X2,Y2=Coordonnées de la jauge.

  Remarque: Dessine une jauge remplie à P% dans le rastport (Amos ou
            Intuition) actuelle.

@endnode
@node Gfxs " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}DIST=Wb Distance(SX,SY To DX,DY)@{fg text}

     Entré: SX,SY=Coordonées de départ.
            DX,DY=Coordonnées de fin du segment.

    Sortie: DIST=Longueur du segment en pixel.

  Remarque: Pour une meilleure précision, les calculs se font en mode
            FFP et demande de ce fait la mathtrans.library.

@endnode
@node Gfxt " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}COUL=Pal Filter(COUL,FILT)@{fg text}

     Entré: COUL=Valeur de la couleur.
            FILT=Filtre pour la couleur.

    Sortie: COUL=Valeur de la nouvelle couleur.

@endnode


@node Men0 " Date: 18/05/95                                       System: v1.3+" (Futur)

Synoptique: @{fg shine}MENUPTR=Wb Find Menu Item(MENUADR,ITEMNB)@{fg text}

    Entrée: MENUADR=Adresse du menu.
            ITEMNB=N° de l'item du menu donné par 'Get Menu Code'.

    Sortie: MENUPTR=Adresse de l'item.

@endnode
@node Men1 " Date: 17/05/95                                       System: v1.3+"

Synoptique: @{fg shine}MENUADR=Wb Get menu Adr(WINDOW)@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre

    Sortie: MENUADR=Ptr du menu

@endnode
@node Men2 " Date: 18/05/95                                       System: v1.3+" (Futur)

Synoptique: @{fg shine}Wb Kill Menu To WINDOW@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre

@endnode
@node Men3 " Date: 17/05/95                                       System: v1.3+"

Synoptique: @{fg shine}SUCCES=Wb Menu To Window(WINDOW,MENUADR)@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre
            MENUADR=Ptr du menu

    Sortie: SUCCES=True ou False (plus de mémoire etc...)

@endnode
@node Men4 " Date: 18/05/95                                       System: v1.3+" (Futur)

Synoptique: @{fg shine}Wb Off Menu WINDOW To MENUNB@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre.
            MENUNB=Adresse du menu donné par 'Get Menu Code'.

@endnode
@node Men5 " Date: 17/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb On Menu WINDOW To MENUNB@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre
            MENUNB=Adresse du menu donné par 'Get Menu Code'.

@endnode
@node Men6 " Date: 27/02/96                                       System: v1.3+"

Synoptique: @{fg shine}MENUNB=Get Menu Msg@{fg text}

    Sortie: MENUNB=N° du menu sélectionné.

@endnode
@node Men7 " Date: 27/02/96                                       System: v1.3+"

Synoptique: @{fg shine}ITEMNB=Get Item Msg@{fg text}

    Sortie: ITEMNB=N° de l'item sélectionné.

@endnode
@node Men8 " Date: 27/02/96                                       System: v1.3+"

Synoptique: @{fg shine}SUBINB=Get Subitem Msg@{fg text}

    Sortie: SUBINB=N° du sous-item sélectinné

@endnode
@node Men8 " Date: 27/02/96                                       System: v1.3+"

Synoptique: @{fg shine}MENUCODE=Get Menu Code(MENUNB,ITEMNB,SUBINB)@{fg text}

     Entré: MENUNB=N° du Menu.
            ITEMNB=N° de l'item.
            SUBINB=N° du sous item.

    Sortie: MENUCODE=Adresse du menu ou de l'item désigné.

    Voir: Get Menu Msg, Get Item Msg, Get Subitem Msg.

@endnode

@node Pp0 " Date: 08/06/95                                       System: v1.3+"

Synoptique: @{fg shine}SIZE=Pp Crunch(START,LENGTH,LARG,EFF)@{fg text}

    Entrée: START=Adresse du buffer à compacter.
            LENGTH=La taille du buffer.
            LARG=Buffer de 0/Petit à 2/Large.
            EFF=Efficacité de 0/Fast à 4/Best.

    Sortie: SIZE=Si le compactage a reussi SIZE retourne
                 la taille compactée
               0=Le compactage a été stoppé pour une raison
                 quelquonque
              -1=Overflow, la taille compactée du fichier est
                 supérieure au fichier lui- même.

@endnode
@node Pp1 " Date: 23/05/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Pp Decrunch(FILENAME$,COL,CRYPTED)@{fg text}

    Entrée: FILENAME$=Nom de fichier.
            COL=Effet pour le décompactage.
              0=Flash sur la couleur 0
              1=Flash sur la couleur 1
              2=Flash sur le pointeur de la sourie
              3=Tremblement de l'écran
              4=Pas d'effet
            CRYPTED=Flag pour les fichiers encryptés.

    Sortie: RESULT=Erreur durant l'exécution de la commande.
                 0=Tout est Ok...
                -1=Erreur d'ouverture
                -2=Erreur durant la lecture
                -3=Plus de mémoire
                -4=Fichier encrypté
                -5=Mot de passe incorrecte
                -6=Compactage inconnu

  Remarque: Vous devez avoir la PowerPacker.library dans le
            répertoire Libs:, si ce n'est pas le cas ou
            si un problème se présente la fonction
            'Pp Len' et 'Pp Start' retourneront un 0.
            Si un fichier n'est pas compacté, il sera
            tout de même chargé en mémoire.
            Pour libérer la mémoire utilisez @{" Free Mem " link Sys4}
            ou @{" Pp Free" link Pp2}, voir aussi @{" Pp Len " link Pp3} et @{" Pp Start " link Pp4}

@endnode
@node Pp2 " Date: 08/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Pp Free@{fg text}

  Remarque: Libère la mémoire occupée par le fichier
            décompacté.

@endnode
@node Pp3 " Date: 23/05/95                                       System: v1.3+"

Synoptique: @{fg shine}LEN=Pp len@{fg text}

    Sortie: LEN=Taille du dernier fichier chargé avec Pp decrunch.

  Remarque: pour sauver le fichier:
            Bsave NAME$,START To START+LEN ou Write Mem(START,LEN To NAME$)

@endnode
@node Pp4 " Date: 27/05/95                                       System: v1.3+"

Synoptique: @{fg shine}START=Pp Start@{fg text}

    Sortie: START=Adresse du dernier fichier chargé avec Pp decrunch.

  Remarque: Voir 'Pp Len'...

@endnode
@node Pp5 " Date: 08/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Pp Write NAME$,START To LENGTH,EFF@{fg text}

    Entrée: EFF=Reporter l'efficacité de 'Pp Crunch'.
            LENGTH=Taille du fichier compacté.
            START=Adresse du buffer
            NAME$=Nom du fichier, si un fichier du même nom existe il sera
            écrasé.

@endnode

@node Scr0 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}SCREEN=Wb Current Screen@{fg text}

    Sortie: SCREEN=Adresse de l'écran

  Remarque: Retourne l'Adresse de l'écran actif.

@endnode
@node Scr1 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}FSCREEN=First Screen@{fg text}

    Sortie: FSCREEN=Adresse de l'écran en premier plan

@endnode
@node Scr2 " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}PUBSCREEN=Wb Lock Pubscreen(NAME$)@{fg text}

    Entrée: NAME$=Nom de l'écran public

    Sortie: PUBSCREEN=Adresse de l'écran

@endnode
@node Scr2a " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}SCRPOS=Wb Unlock Pubscreen(NAME$,SCREEN)@{fg text}

     Entré: NAME$=Nom de l'écran public.
            SCREEN=Adresse de l'écran.

    Sortie: SCRPOS=Position de l'écran déverrouillée.
@endnode
@node Scr3 " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}NAME$=Wb Pubscreen Name@{fg text}

    Sortie: NAME$=Nom de l'écran public

  Remarque: Voir 'Wb Next Pubscreen()'

@endnode
@node Scr4 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Back SCREEN@{fg text}

    Entrée: SCREEN=Adresse de l'écran

@endnode
@node Scr5 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}SCREEN=Wb Screen Base@{fg text}

    Sortie: SCREEN=Adresse de l'écran

  Remarque: Renvois l'adresse du dernier écran ouvert

@endnode
@node Scr6 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Close SCREEN@{fg text}

    Entrée: SCREEN=Adresse de l'écran

  Remarque: ATTENTION au Gourou si l'écran n'éxiste pas !!!

@endnode
@node Scr7 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb SCreen Front SCREEN@{fg text}

    Entrée: SCREEN=Adresse de l'écran

@endnode
@node Scr8 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Move SCREEN To DELTX,DELTY@{fg text}

    Entrée: SCREEN=Adresse de l'écran
            DELTX,DELTY=Nombre de pixel pour le déplacement

@endnode
@node Scr9 " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Open X,Y,W,H,PLAN,VMODE@{fg text}

    Entrée: X,Y=Coordonnées supérieures gauches
            W,H=longueur (Width) et Largeur (Height)
            PLAN=Nombre de plan de l'écran
               1= 2 couleurs
               2= 4 couleurs
               3= 8 couleurs
               4=16 couleurs
               5=32 couleurs
               6=64,4096 couleurs
            VMODE=Voir Shires, Lowres, Hires, Laced...

  Remarque: Voir détail dans les autodocs

@endnode
@node Scra " Date: 15/03/95                                       System: v1.3+"

Synoptique: @{fg shine}RPORT=Wb Screen Rastport SCREEN@{fg text}

    Entrée: SCREEN=Adresse de l'écran

    Sortie: RPORT=Adresse du rastport de l'écran

  Remarque: Retourne l'adresse du Rastport du dernier écran ouvert.

@endnode
@node Scrb " Date: 30/08/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen SCR@{fg text}

    Entrée: SCR=Adresse de l'écran.

  Remarque: Une alternative à la commande 'Screen ECRAN' d'amos.
            Elle prend de cette façon en compte les écran intuition.

@endnode

@node Scrc " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}SCRPOS=Wb Next Pubscreen(SCREEN)@{fg text}

     Entré: SCREEN=Adresse de l'écran.

    Sortie: SCRPOS=Position de l'écran (SCREEN).
@endnode
@node Scrd " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}SCRPOS=Wb Set Default Pubscreen(NAME$)@{fg text}

     Entré: NAME$=Nom de l'écran public.

    Sortie: SCRPOS=Position d'un écran.

@endnode
@node Scre " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}OLDMODE=Wb Set Pubscreen Mode(MODE)@{fg text}

     Entré: MODE=1/Shangai (Affiche la fenêtre sur l'écran public).
                 2/PopPubScreen (Place l'écran public en avant plan
                 dès qu'une fenêtre à été ouverte).

    Sortie: OLDMODE=L'ancien mode de l'écran.

  Remarque: Définis un nouveau mode d'écran public

@endnode
@node Scrf " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}SCRPOS=Wb Pubscreen Status(SCREEN,STATUS)@{fg text}

     Entré: SCREEN=Adresse de l'écran public.
            STATUS=Nouveau status pour l'écran public.

    Sortie: SCRPOS=N° de position de l'écran public.

  Remarque: Change le status de l'écran public.

@endnode
@node Scrg " Date: 12/05/96                                       System: v2.0+"

Synoptique: @{fg shine}Wb Open Screen Taglist(TAGLIST)@{fg text}

     Entré: TAGLIST=Liste de Tag pour l'ecran.

      Voir: 'SCR=Wb Screen Base', 'Wb Screen Close SCR'

@endnode
@node Scrh " Date: 12/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Colour COUL,CNB To SCR@{fg text}

     Entré: SCR=Adresse de l'ecran.
            CNB=N° de la couleur a placer dans l'ecran.
            COUL=La couleur a placer.

@endnode
@node Scri " Date: 12/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Screen Palette PAL,CNB To SCR@{fg text}

     Entré: SCR=Adresse de l'ecran.
            CNB=Nombre de couleur a placer dans l'ecran.
            PAL=Palette a placer dans l'ecran.

@endnode

@node Wind0 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}WIND=Wb Current Window@{fg text}

    Sortie: WIND=Adresse de la fenêtre

  Remarque: Retourne l'Adresse de la fenêtre active.

@endnode
@node Wind1 " Date: 28/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb New Idcmp WIND,IDCMP@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            IDCMP=flag IDCMP pour la fenêtre (voir get msg).
          @{" Liste des codes IDCMP " link CodeIDCMP}

@endnode
@node Wind2 " Date: 17/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Back WINDOW@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)

@endnode
@node Wind3 " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}WINDOW=Wb Wind Base@{fg text}

    Sortie: WINDOW=Ptr sur la struct Window

  Remarque: Adresse de la dernière fenêtre ouverte.

@endnode
@node Wind4 " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Close WINDOW@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)

  Remarque: Ferme la fenêtre WINDOW.

@endnode
@node Wind5 " Date: 17/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Front WINDOW@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)

@endnode
@node Wind6 " Date: 17/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Limit WINDOW To MINX,MINY,MAXX,MAXY@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)
            MINX/MINY=Ouverture minimum en pixel.
            MAXX/MAXY=Ouverture maximale en pixel.

@endnode
@node Wind7 " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Move WINDOW To DELTAX,DELTAY@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)
            DELTAX,DELTAY=Déplacement relatif de la fenêtre d'après les
            coordonnées actuelles (ACTUELLE+DELTA=NOUVELLES COORDs).

  Remarque: Déplace la fenêtre WINDOW.

@endnode
@node Wind8 " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Open SCREEN To X,Y,W,H,F@{fg text}

    Entrée: SCREEN=Ecran utilisé par la fenêtre
            X,Y=Coord supérieur de la fenêtre
            W,H=Longueur (W) et Largeur (H) de la fenêtre
            F=@{" Flags " link Wind8a} de la fenêtre

  Remarque: Ouvre une fenêtre intuition.

@endnode

@node Wind8a " Date: 26/02/95                                       System: v1.3+"

            SizeGadget     = $1
            DragBar        = $2
            DepthGadget    = $4
            CloseGadget    = $8
            SizeBright     = $10
            SizeBBottom    = $20
            RefreshBits    = $C0
            Smart_Refresh  = $0
            Simple_Refresh = $40
            Super_Bitmap   = $80
            Other_Refresh  = $C0
            BackDrop       = $100
            ReportMouse    = $200
            GimmeZeroZero  = $400
            BorderLess     = $800
            Activate       = $1000
            WindowActive   = $2000
            InRequest      = $4000
            MenuState      = $8000
            RmbTrap        = $10000
            NoCareRefresh  = $20000
            NW_Extended    = $40000
            NewLookMenus   = $200000
            WindowActive   = $2000
            InRequest      = $4000
            MenuState      = $8000
            WindowRefresh  = $1000000
            WBenchWindow   = $2000000
            WindowTicked   = $4000000
            Visitor        = $8000000
            Zoomed         = $10000000
            HasZoom        = $20000000
            Super_Unused   = $fcfc0000

            Pour définir plusieur Flag, vous devez les additionner

@endnode
@node Wind9 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}RPORT=Wb Wind Rport (WINDOW)@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)

    Sortie: RPORT=Ptr sur la Structure RPort de la fenêtre

  Remarque: Ne pas inverser les pointeurs WINDOW et SCREEN.

@endnode
@node Winda " Date: 17/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Size WINDOW To DELTX,DELTY@{fg text}

    Entrée: WINDOW=Ptr de la fenêtre (Wb Wind Base)
            DELTX,DELTY=Nombre de pixel du déplacement

@endnode
@node Windb " Date: 11/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Wind Title WIND To WINDT,SCREENT@{fg text}

    Entrée: WIND=Adresse de la fenêtre
            WINDT=Adresse du titre de la fenêtre
            SCREENT=Adresse du titre de l'écran

            Ex: A$="Window Title..." : B$="Screen Title..."
                Wb Wind Title WIND To Varptr(A$),Varptr(B$)
@endnode
@node Windc " Date: 06/04/95                                       System: v1.3+"

Synoptique: @{fg shine}XWIND=X Wind(WINDOW)@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre

    Sortie: XWIND=Coordonnées Horizontales de la sourie

  Remarque: Voir 'X Mouse'

@endnode
@node Windd " Date: 06/04/95                                       System: v1.3+"

Synoptique: @{fg shine}YWIND=Y Wind(WINDOW)@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre

    Sortie: YWIND=Coordonnées verticales de la sourie

  Remarque: Voir 'Y Mouse'

@endnode
@node Winde " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}Wb Change Window Box WIND To X,Y,WIDTH,HEIGHT@{fg text}

     Entré: WIND=Adresse de la fenêtre à modifier.
            X,Y=Nouvelles positions de la fenêtre.
            WIDTH,HEIGHT=Nouvelle hauteur et largeur
                         de la fenêtre.
@endnode
@node Windf " Date: 27/05/95                                       System: v2.0+"

Synoptique: @{fg shine}Wb Zip Window WIND@{fg text}

     Entré: WIND=Adresse de la fenêtre à modifier.
@endnode

@node Sys0 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MEMABS=Alloc Abs(SIZE,LOCATE)@{fg text}

    Entrée: SIZE=Taille du segment mémoire.
            LOCATE=Adresse du segment

    Sortie: MEMABS=True ou false.

@endnode
@node Sys1 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MEMSIZE=Alloc Mem(SIZE,MEMTYPE)@{fg text}

    Entrée: SIZE=Taille du segment mémoire.
            MEMTYPE= > @{" Public   " link M0}
                     > @{" Chip     " link M1}
                     > @{" Fast     " link M2}
                     > @{" Local    " link M3}
                     > @{" 24BitDMA " link M4}
                     > @{" Clear    " link M7}

    Sortie: MEMSIZE=Adresse du segment alloué ou 0

@endnode
@node Sys2 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}SIZE=Avail Mem (MEMTYPE)@{fg text}

    Entrée: MEMTYPE= > @{" Public   " link M0}
                     > @{" Chip     " link M1}
                     > @{" Fast     " link M2}
                     > @{" Local    " link M3}
                     > @{" 24BitDMA " link M4}
                     > @{" Largest  " link M5}
                     > @{" Total    " link M6}

    Sortie: SIZE=Taille de la mémoire libre

@endnode

@node M0 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mpublic@{fg text}

    Sortie: VALEUR=Totalité de la mémoire publique libre (Chip+Fast)

@endnode
@node M1 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mchip@{fg text}

    Sortie: VALEUR=Totalité de la mémoire Chip libre (Chip)

@endnode
@node M2 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mfast@{fg text}

    Sortie: VALEUR=Totalité de la mémoire Fast libre (Fast)

@endnode
@node M3 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mlocal@{fg text}

    Sortie: VALEUR=Totalité de la mémoire Locale libre (Chip,
            sans les extentions mémoire)

@endnode
@node M4 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mdma@{fg text}

    Sortie: VALEUR=Totalité de la mémoire 24Bit DMA libre (Chip+Fast)

@endnode
@node M5 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mlargest@{fg text}

    Sortie: VALEUR=Plus grand block de mémoire libre

      Voir: Mchip, Mfast et Mpublic

@endnode
@node M6 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mtotal@{fg text}

    Sortie: VALEUR=Totalité de la mémoire publique libre (Chip+Fast)

  Remarque: MEM=Avail Mem(Mtotal)
      Amos: MEM=Chip Free+Fast Free

@endnode
@node M7 " Date: 19/11/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Mclear@{fg text}

    Sortie: VALEUR=Demande une zone de mémoire remplie de '0'.

@endnode

@node Sys3 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Copy Mem STAR,SIZE To DEST@{fg text}

    Entrée: STAR=Début de la mémoire à copier
            SIZE=Taille du segment mémoire
            DEST=Destination du segment

  Remarque: Plus rapide que la commande 'Copy' d'Amos & APro
            version optimisée de 'Copy Mem'.

@endnode
@node Sys4 " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}Free Mem START,LEN@{fg text}

    Entrée: START=Adresse de départ de la mémoire à libérer.
            LEN=Longueur de la mémoire à libérer.

  Remarque: Cette fonction utilise la librairie Exec, seule une zone
            mémoire allouée avec la fonction AllocMem, doit être libérée.

@endnode
@node Sys5 " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Write Mem(START,LEN To NAME$)@{fg text}

    Entrée: START=Adresse de départ du segment mémoire
            LEN=Longueur du segment
            NAME$=Nom de sortie (ou du fichier à créer).

    Sortie: RESULT=True si Ok, ou False.

  Remarque: Sortie possible sur Ptr: Con: Raw: ou un fichier

@endnode
@node Sys6 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg (WINDOW)@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre.

    Sortie: MSG=Code du message reçu par intuition.
          @{" Liste des code IDCMP " link CodeIDCMP}

@endnode

@node CodeIDCMP " Liste des code IDCMP "

    Liste des flags:
           SizeVerify     = $1
           NewSize        = $2
           RefreshWindow  = $4
           MouseButtons   = $8
           MouseMove      = $10
           GadgetDown     = $20
           GadgetUp       = $40
           ReqSet         = $80
           MenuPick       = $100
           CloseWindow    = $200
           RawKey         = $400
           ReqVerify      = $800
           ReqClear       = $1000
           MenuVerify     = $2000
           NewPrefs       = $4000
           DiskInserted   = $8000
           DiskRemoved    = $10000
           WBenchMessage  = $20000
           ActiveWindow   = $40000
           InactiveWindow = $80000
           DeltaMove      = $100000
           VanillaKey     = $200000
           IntuiTicks     = $400000
           IDCMPUpdate    = $800000
           MenuHelp       = $1000000
           ChangeWindow   = $2000000
           GadgetHelp     = $4000000
           LonelyMessage  = $80000000 (Réservé)

@endnode

@node Sys7 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Code@{fg text}

    Sortie: MSG=Code du message reçu 'Get Msg'.

  Remarque: Voir 'get msg()'

@endnode
@node Sys8 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Iadr@{fg text}

    Sortie: MSG=Adresse de l'objet

  Remarque: Retourne l'adresse de l'objet sélectionné
            (écran,Fenêtre,gadget ect...).
            Voir 'get msg()'

@endnode
@node Sys9 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Qualifier@{fg text}

    Sortie: MSG=Code qualifieur

  Remarque: Voir 'get msg()'

@endnode
@node Sysa " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Xm@{fg text}

    Sortie: MSG=Coord XMouse

  Remarque: Voir 'get msg()'

@endnode
@node Sysb " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Ym@{fg text}

    Sortie: MSG=Coord YMouse

  Remarque: Voir 'get msg()'

@endnode
@node Sysc " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Load Seg FILENAME$@{fg text}

    Entrée: FILENAME$=Nom+Chemin du fichier (IL DOIT IMPERATIVEMENT
            SE TERMINER PAR UN ZERO...), ex: f$="C:Avail"+Chr$(0).

  Remarque: Charge un éxécutable et décompose ses segments de code.

@endnode
@node Sysd " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}TASK=My Task@{fg text}

    Sortie: TASK=Ptr sur la tâche propre

@endnode
@node Syse " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}SEGMENT=Segment Base@{fg text}

    Sortie: SEGMENT=Pointeur sur la liste des segments du dernier
            fichier chargé avec 'Load Seg' ou -1 si Erreur.

  Remarque: Pour plus de renseignement voir 'La bible de l'Amiga'.

@endnode
@node Sysf " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}OLDTASK=Set Taskpri (TASK,PRI)@{fg text}

    Entrée: TASK=Adresse de la tâche.
            PRI=N° de priorité (Entre -127 et +128)

    Sortie: OLDTASK=N° de L'ancienne priorité.

@endnode
@node Sysg " Date: 14/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Task Name NAME$ To TASKPTR@{fg text}

    Entrée: NAME$=Nouveau nom pour la tâche ou le
                  process.
            TASKPTR=Adresse d'une tâche (ou Process.)

  Remarque: Voir 'My Task', Cette commande combine avec
            'My Task' vous permet de personnaliser le
            nom de votre programme dans la TaskList d'Exec.

@endnode
@node Sysh " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Unload Seg SEGMENT@{fg text}

    Entrée: SEGMENT=Pointeur sur la liste des segments de code.

  Remarque: Le pointeur est du type BPTR, pour obtenir l'adresse des
            segments, 'Segment Base' doit être multiplié par 4
            Structure des segments de code:
            Segment Base -> Longueur Segment
                            Ptr Segment suivant ou 0
                            Début du code du segment

@endnode
@node Sysi " Date: 22/06/95                                       System: v1.3+"

Synoptique: @{fg shine}DATE$=Wb Date@{fg text}

    Sortie: Date actuelle sous le format 'JJ/MM/AAAA'.

@endnode
@node Sysj " Date: 18/05/95                                       System: v1.3+"

Synoptique: @{fg shine}SUCESS=Wb Display Alert(HEIGHT,MSG$)@{fg text}

    Entrée: HEIGHT=Hauteur en pixel du cadre d'alerte
            MSG$=Message à afficher
     Format pour le Message:
     Pour des raisons qui me sont toujours inconnues (je ne suis
     pas biologiste...),au lieu d'un simple message en Ascii,
     les Ba'b,concepteur de l'Amiga ont sortis un format où vous
     pourrez en trouver un exemple dans le programme 'DisplayAlert.amos'
     mais pour l'heure voici le format:
     Msg0$=Chr$(0)+Chr$(X0)+chr$(Y)+'Message1...'+Chr$(0)
     Msg0$=Msg0$+Chr$(1)+Chr$(MulX)+Chr$(X1)+'$Message2..'+Chr$(0)
     Notez le signe '$' sur le message 2, en fait la 1ère lettre
     du second message est gnaquée, donc si on veut que tout le
     message soit affiché il faut lui donner autre chose à gnaq...

    Sortie: SUCCESS=0 Bouton Gauche et 1 Bouton Droit.

@endnode
@node Sysk " Date: 26/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Display Beep WIND/SCREEN@{fg text}

    Entrée: WIND/SCREEN=Adresse de l'écran ou de la
            fenêtre à faire clignoter.

@endnode
@node Sysl " Date: 06/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MKEY=Hard Mouse Key@{fg text}

    Sortie: Port A: Bouton Gauche=1
                    Bouton Droit =2
                    Bouton Milieu=3
            Port B: Bouton Gauche=4
                    Bouton Droit =5
                    Bouton Milieu=6

  Remarque: FALSE (-1) si pas de bouton pressé

@endnode
@node Sysm " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Reset@{fg text}

  Remarque: Warm Reset officiel d'après Commodore (CBM).

@endnode
@node Sysn " Date: 19/06/95                                       System: v1.3+"

Synoptique: @{fg shine}HEURE$=Wb Swatch@{fg text}

    Sortie: HEURE$=Chaîne sous le format 'HH:MM:SS'.

@endnode
@node Syso " Date: 30/05/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Wb Sys Requester(TEXT$,BOUT1$,BOUT0$)@{fg text}

    Entrée: TEXT$=Texte à afficher dans le requester.
            BOUT1$=Texte pour le bouton de gauche.
            BOUT0$=Texte pour le bouton de droite.

    Sortie: RESULT=1 pour BOUT1$ et 0 pour BOUT0$

  Remarque: le retour au programme se fait après la sélection
            de l'un des deux boutons.

@endnode
@node Sysp " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}SUCCES=Wb Close@{fg text}

    Sortie: SUCCES=True ou False

  Remarque: Ferme le Workbench.

@endnode
@node Sysq " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}WBPTR=Wb Open@{fg text}

    Sortie: WBPTR=Pointeur sur l'écran du Workbench si Ok.

  Remarque: Ouvre le Workbench.

@endnode
@node Sysr " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=Sys Agnus@{fg text}

    Sortie: TYPE= 0 - Agnus PAL
                 16 - Agnus NTSC
                 32 - Fat Agnus PAL
                 48 - Fat Agnus NTSC
                 53 - AA Alice PAL
                 ?? - AA Alice NTSC
@endnode
@node Syss " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}CHIPSET=Sys Chip@{fg text}

    Sortie: CHIPSET= 0 - Denise Wb1.2
                     8 - AA Lisa
                    12 - Denise ECS
                    15 - Denise Wb 1.3

  Remarque: Teste le type du ChipSet installé dans une machine.

@endnode
@node Syst " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Sys Kickstart(VERSION)@{fg text}

     Entré: VERSION=Version de la ROM à tester.

    Sortie: RESULT=-1 Si VERSION > que la version de la ROM.
                  = 0 Si VERSION = que la version de la ROM.
                  = 1 Si VERSION < que la version de la ROM.

  Remarque: Les versions existantes sont:
            40 > ROM 3.1 (CD32...)
            39 > ROM 3.0 (1200/4000)
            38 > ROM 2.1 (Version soft-3000/2000/600/500+)
            37 > ROM 2.0 (3000/2000/600/500+)
            36 > ROM 1.3 (2000/500/1000)
            35 > ROM 1.2 (500/1000)

@endnode

@node Sysu " Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}PORTADR=Wb Create Msgport@{fg text}

    Sortie: PORTADR=Adresse du nouveau port de message.

    Voir: Wb Erase Msgport

@endnode
@node Sysv " Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}Wb Erase Msgport PORTADR@{fg text}

     Entré: PORTADR=Adresse du message-port.

     Voir: Wb Create Msgport

@endnode
@node Sysw " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Wb Get Msg(MSGPORT)@{fg text}

     Entré: MSGPORT=Adresse du port-message.

    Sortie: MSG=Code du message reçu.
            >0 Message

@endnode
@node Sysx " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Reply Msg@{fg text}

  Remarque: Cette fonction prévient le systéme que le message a
            été reçu, ce qui permet d'en recevoir d'autre.

@endnode

@node Sysy " Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Mouse Off@{fg text}

  Remarque: Desactive le sprite de la sourie sur l'ecran actif.

@endnode
@node Sysz " Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Mouse On@{fg text}

  Remarque: Reactive le sprite de la sourie sur l'ecran actif.

@endnode
@node Sys10 " Date: 30/05/96                                       System: v1.3+"

Synoptique: @{fg shine}CPU=Sys Cpu@{fg text}

    Sortie: CPU=N° du Processeur principal (40, 30, 20, 10 ou 0).

  Remarque: Retourne le type de MicroProcesseur.
            ex: Print "CPU Type:";68000+Sys CPU

@endnode
@node Sys11 " Date: 30/05/96                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=Sys Math@{fg text}

    Sortie: TYPE=N° du type de coprocesseur arithmétique (881 ou 882).

  Remarque: Ex: MATH=81000+Sys Math
                If MATH=81000
                Print "Math Type: None"
                Else
                Print "Math Type:";MATH
                End If

@endnode



@node vid0 " Date: 11/04/95                                       System: v1.3+"

Synoptique: @{fg shine}HERTZ=Power Frequence@{fg text}

    Sortie: HERTZ=Frequence du power en Hz

@endnode
@node vid1 " Date: 14/06/95                                       System: v3.0+"

Synoptique: @{fg shine}Wb Set Chip Rev FLAGS@{fg text}

    Entrée: FLAGS=A (?) > 1
                  ECS   > 3
                  AA    > $F
                  Best  > $FFFFFFFF

@endnode
@node vid2 " Date: 24/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Switch Ntsc@{fg text}

  Remarque: Défini le mode 60 Hz (NTSC)

@endnode
@node vid3 " Date: 24/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Switch Pal@{fg text}

  Remarque: Défini le mode 50 Hz (PAL)

@endnode
@node vid4 " Date: 11/04/95                                       System: v1.3+"

Synoptique: @{fg shine}HERTZ=Vbl Frequence@{fg text}

    Sortie: HERTZ=Frequence du Raster écran en Hz

@endnode
@node vid5 " Date: 02/05/96                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Wb Check Aga@{fg text}

    Sortie: RESULT=True(-1) ou False(0) si le chipset AGA existe.

@endnode
@node vid6 " Date: 02/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Kill Aga@{fg text}

  Remarque: Désactive le chipset AGA.

@endnode

@node Txt0 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Curs RPORT,X,Y@{fg text}

    Entrée: RPORT=Ptr sur la Structure RPort de la fenêtre
            X,Y=Coordonnées du point

  Remarque: Définis les nouvelles coordonnées pour le
            curseur graphique.

@endnode
@node Txt1 " Date: 02/07/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gfx Centre TXT$,CENTX,Y To RP@{fg text}

    Entrée: TXT$=Chaîne de caractères.
            CENTX=Coord. Horizontale centrale.
            Y=Coord. Verticale du texte.
            RP=Rastport destination.

@endnode
@node Txt2 " Date: 10/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gfx Ink RPORT To PEN,PAPER@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            PEN,PAPER=N° des Couleurs

@endnode
@node Txt3 " Date: 10/04/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gfx Mode RPORT,MODE@{fg text}

    Entrée: RPORT=Adresse du rastport de la fenêtre
            MODE=Mode graphique pour le texte.

@endnode
@node Txt4     " Date: 19/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Gfx Text TXT$,X,Y To RPORT@{fg text}

    Entrée: TXT$=Texte à écrire.
            X,Y=Coordonnées du texte à afficher.
            RPORT=Adresse du rastport de la fenêtre

@endnode
@node Txt5 " Date: 19/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Text Spacing SPACE To RPORT@{fg text}

    Entrée: SPACE=Espace entre les lettres en pixels, les
            chiffres négatifs raprochent les lettres.
            RPORT=Adresse du rastport de la fenêtre

@endnode
@node Txt6 " Date: 19/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Text Style STYLE To RPOR@{fg text}T

    Entrée: STYLE=0 Texte normal
                  1 Souligné
                  2 En gras
                  4 En italique
            Pour mélanger les Styles il faut les additionner
            RPORT=Adresse du rastport de la fenêtre

@endnode
@node Txt7 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print TXT$ To RPORT@{fg text}

    Entrée: RPORT=Ptr sur la Structure RPort de la fenêtre
            TXT$=Texte à inscrire

@endnode
@node Txt8 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print Ink PEN,PAPER@{fg text}

    Entrée: PEN=N° de couleur du crayon
            PAPER=N° de couleur du papier

  Remarque: Définis les couleurs d'écriture de la fonction 'Wb Print'

@endnode
@node Txt9 " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print Locate LOCX,LOCY@{fg text}

    Entrée: LOCX=N° de la colonne
            LOCY=N° de la ligne

@endnode
@node Txta " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print Mode MODE@{fg text}

    Entrée: MODE=de 0 a 255 (Voir Gr Writing)

  Remarque: Définis le mode d'écriture de la fonction 'Wb Print'

@endnode
@node Txtb " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print Xmove LOCX@{fg text}

    Entrée: LOCX=N° de la colonne

@endnode
@node Txtc " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Print Ymove LOCY@{fg text}

    Entrée: LOCY=N° de la ligne

@endnode
@node Txtd " Date: 07/07/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Poke$ TXT$ To PTR@{fg text}

    Entrée: TXT$=Chaîne de caractères à copier.
            TR=Adresse destination

  Remarque: Effectue la copie des chaînes intuition (qui se terminent
            par un zéro), cette commande stoppera la copie lorsqu'elle
            rencontrera un zéro.

@endnode
@node Txte " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}POS=Wb X Locate@{fg text}

    Sortie: POS=Position X du curseur texte.

@endnode
@node Txtf " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}POS=Wb X Print@{fg text}

    Sortie: POS=Position X du curseur texte en pixel.

@endnode
@node Txtg " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}POS=Wb Y Locate@{fg text}

    Sortie: POS=Position Y du curseur texte.

@endnode
@node Txth " Date: 15/06/95                                       System: v1.3+"

Synoptique: @{fg shine}POS=Wb Y Print@{fg text}

    Sortie: POS=Position Y du curseur texte en pixel.

@endnode
@node Txti " Date: 19/05/95                                       System: v1.3+"

Synoptique: @{fg shine}XLEN=Wb Gfx Len(TXT$)@{fg text}

    Entrée: TXT$=Texte à calculer.

    Sortie: XLEN=Longueur du texte en pixel

  Remarque: Cette commande permet de gagner du temps.
            La même chose avec Amos:
            A$="ABCDEFG" : B=Len(A$) : B=B*8 (ou Rol.l 3,B)
            NOTA: Utilisez cette commande seulement avec une
            police de 8 pixels de large.

@endnode
@node Txtj " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}STRADR=Str Store(STR$)@{fg text}

     Entré: STR$=Chaîne à stocker.

    Sortie: STRADR=Adresse de la chaîne.

    Voir: Str Free

@endnode
@node Txtk " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}Str Free STRADR@{fg text}

     Entré: STRADR=Adresse de la chaîne retourne par 'Str Adr'

@endnode

@node Td0 " Date: 12/06/95                                       System: v1.3+ (?)"

Synoptique: @{fg shine}Wb Block Read DISKIO,BLOCK To BUFFER@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.

    Sortie: BLOCK=N° du block à lire (0 a 1759).
            BUFFER=Zone mémoire où sera copiée les données
            lues sur la disquette.

  Remarque: Lis un block de 512 octets

@endnode
@node Td1 " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Block Update DISKIO,BUFFER To BLOCK@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.
            BUFFER=Zone mémoire où sera copiée les données
            lues sur la disquette.
            BLOCK=N° du Block à Copier.

@endnode
@node Td2 " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Block Write DISKIO,BUFFER To BLOCK@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.
            BUFFER=Zone mémoire d'où sera lue les données
            à copier sur la disquette.
            BLOCK=N° du Block à écrire.

@endnode
@node Td3 " Date: 12/06/95                                       System: v1.3+ (?)"

Synoptique: @{fg shine}Wb Td Close DISKIO@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.

  Remarque: Libère la mémoire du MsgPort, de DiskExtIO et ferme
            le trackdisk.device.

@endnode
@node Td4 " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}ERROR=Wb Td Error@{fg text}

    Sortie: ERROR=N° de l'erreur lors d'une action sur
            une disquette.

@endnode
@node Td5 " Date: 12/06/95                                       System: v1.3+ (?)"

Synoptique: @{fg shine}Wb Td Motor Off DISKIO@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.

  Remarque: Eteint le moteur et la led du lecteur.
            Nota à utiliser après lecteur ou copie sur
            une disquette.

@endnode
@node Td6 " Date: 12/06/95                                       System: v1.3+ (?)"

Synoptique: @{fg shine}Wb Td Motor On DISKIO@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.

  Remarque: Allume le moteur et la led du lecteur.

@endnode
@node Td7 " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}DISKIO=Wb Td Open(UNIT,FLAGS)@{fg text}

    Entrée: UNIT=N° du lecteur à initialiser (Df0=0, Df1=1 Etc...).
            FLAGS=Doit toujours être à zéro.

    Sortie: DISKIO=Adresse de DiskExtIO

  Remarque: Initialise un MsgPort et ouvre le trackdisk.device.

@endnode
@node Td8 " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Track Format DISKIO,BUFFER To TRACK@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.
            BUFFER=Zone mémoire d'où seront lue les données
            à copier sur la disquette.
            TRACK=N° de la Piste à formater.

@endnode
@node Td9  " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Track Read DISKIO,TRACK To BUFFER@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.
            TRACK=N° de la piste a lire.
            BUFFER=Zone mémoire où sera copiée les données
            lues sur la disquette.

@endnode
@node Tda " Date: 12/06/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Track Write DISKIO,BUFFER To TRACK@{fg text}

    Entrée: DISKIO=Adresse retournée par 'Wb Td Open'.
            TRACK=N° de la piste à écrire.
            BUFFER=Zone mémoire d'où seront lues les données
            à copier sur la disquette.

@endnode

@node Misc0 " Date: 10/04/95                                       System: v1.3+"

Synoptique: @{fg shine}ARP=Amos Rastport@{fg text}

    Sortie: ARP=Adresse de l'écran Amos actif.

@endnode
@node Misc1 " Date: 10/06/95                                       System: v1.3+"

Synoptique: @{fg shine}TXT$=Wb Decrypt(CRYPT$)@{fg text}

     Entré: CRYPT$=Chaîne ou variable à Décrypter.

    Sortie: TXT$=Chaîne Décryptée.

  Remarque: Voir: @{" Wb Encrypt " link Misc2}

@endnode
@node Misc2 " Date: 10/06/95                                       System: v1.3+"

Synoptique: @{fg shine}CRYPT$=Wb Encrypt(TXT$)@{fg text}

     Entré: TXT$=Chaîne ou variable à encrypter.

    Sortie: CRYPT$=Chaîne encryptée.

      Voir: @{" Wb Decrypt " link Misc1}

@endnode
@node Misc3 " Date: 23/05/95                                       System: v1.3+"

Synoptique: @{fg shine}CHAINE$=Wb Fast Hex(NUM,lEN)@{fg text}

     Entré: lEN=Nombre de caractère Hexa en sortie.
            NUM=Nombre à convertir en chaîne hexa.

    Sortie: CHAINE$=Sortie hexa finale.

  Remarque: la chaîne finale ne comporte pas le signe '$'
            ce qui évite les soustractions de chaîne, cette
            commande comparée à la version AMOS, en
            enlevant le '$', est en moyenne deux fois plus
            rapide.

@endnode
@node Misc4 " Date: 02/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Locker FLAG@{fg text}

     Entré: FLAG=1 Désactive le flip Amos/Wb et 0 le remet.

@endnode
@node Misc5 "Date: 23/05/95                                       System: v1.3+"

Synoptique: @{fg shine}VALEUR=Wb Peek(ADR,FLAG)@{fg text}

     Entré: FLAG=Désigne le format
            1=1 octet  (AMOS / Peek(adr))
            2=2 octets (AMOS / Deek(adr))
            4=4 octets (AMOS / Leek(adr))
            le 4 est le Flag par défaut.
            ADR=L'adresse mémoire.

    Sortie: VALEUR=...

  Remarque: Cette commande tient son intérêt dans le fait
            que si l'on veut prendre 1,2 ou 4 octets avec
            la commande AMOS, il faut plusieurs lignes de tests
            et plusieurs lignes pour les 3 commandes.

@endnode
@node Misc6 "Date: 27/02/95                                       System: v1.3+"

Synoptique: @{fg shine}PTR=Shearch(START,END,OCTET)@{fg text}

     Entré: START=Début du segment mémoire.
            END=Fin du segment mémoire.
            OCTET=Valeur à rechercher de 0 à 255.

    Sortie: PTR=Adresse de la valeur ou -1 (False)

  Remarque: Si on active le bouton gauche de la sourie
            cela provoque l'arrêt de la recherche, on
            trouve à ce moment dans PTR l'adresse où a
            été stoppée la recherche, ce qui permet ensuite
            de reprendre la recherche.

@endnode
@node Misc7 "Date: 07/07/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT$=Wb String Request(SCR,TIT$,T$,STR$,UPTR,NB)@{fg text}

     Entré: SCR=Adresse de l'écran où apparaitra le requester.
            TIT$=Titre pour le requester.
            T$=Ligne de texte.
            STR$=Texte à faire apparaitre dans le requester,
            UPTR=Adresse du texte, pour le bouton 'REFAIRE' (UNDO).
            NB=Nombre maximum de caractères.

    Sortie: RESULT$=Chaîne de caractères si Ok, si le CloseGadget ou
                   le bouton 'Annuler' a été sélectionné le requester
                   retourne une chaîne vide.

  Remarque: ATTENTION: Les chaînes 'STR$' et 'UPTR' doivent contenir
            le texte et une suite de caractères nuls (Chr$(0), correspondant
            au nombre NB.
                Ex: STR$="Philippe" : NB=20
                    ST$=String$(Chr$(0),NB-len(STR$))
                    UNDO$=STR$+ST$: UNDO=Varptr(UNDO$)
                    STR$=Wb String Request(0,"AMOS Request","Salut...",STR$+ST$,UNDO,NB)

@endnode
@node Misc8 "Date: 02/07/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Wb Text Request(SCR,TIT$,TXT0$,TXT1$,B0$,B1$,B2$)@{fg text}

     Entré: SCR=Adresse de l'écran.
            TIT$=Titre de la fenêtre (30c Max.).
            TXT0$,TXT1$=Texte de 33c Max.
            B0$,B1$,B2$=Texte des boutons, si une chaîne est vide
            le bouton correspondant ne sera pas activé et dessiné.

    Sortie: RESULT=-1 CloseGadget
                    0 Bouton de gauche
                    1 Bouton du milieu
                    2 Bouton de droite

@endnode
@node Misc9 "Date: 27/02/95                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=What Is(START)@{fg text}

     Entré: START=Début du programme stocké en mémoire.

    Sortie: TYPE=Code de 4 octets désignant le @{" Type de fichier " link Misca}.

  Remarque: Voir Bload, Reserve as,Start(Bnk).

@endnode

@node Misca " "

              ->@{fg shine}STMo@{fg text} = Module Sound/Pro/Noisetracker
              ->@{fg shine}EXEC@{fg text} = Exécutable
              ->@{fg shine}Med1@{fg text} = Module Med (Format 1)
              ->@{fg shine}JPEG@{fg text} = Image compactage JPEG
              ->@{fg shine}Info@{fg text} = '.info' fichier icône
              ->@{fg shine}Geo1@{fg text} = Fichier Objet 3D Géo
              ->@{fg shine}IFFP@{fg text} = Image Iff
              ->@{fg shine}IFFT@{fg text} = Texte Iff
              ->@{fg shine}Catg@{fg text} = Catalogue (Locale 2.0+)
              ->@{fg shine}Pref@{fg text} = Préférence (Locale 2.0+)
              ->@{fg shine}IFF?@{fg text} = Format Iff Non défini
              ->@{fg shine}APro@{fg text} = Fichier AMOSPro Basic
              ->@{fg shine}ABas@{fg text} = Fichier AMOS Basic
              ->@{fg shine}PPDa@{fg text} = PowerPacker Data Cruncher
              ->@{fg shine}AmSp@{fg text} = Amos Bank Sprite
              ->@{fg shine}ABMe@{fg text} = Amos Bank Menu
              ->@{fg shine}ABMu@{fg text} = Amos Bank Musique
              ->@{fg shine}ABWk@{fg text} = Amos Bank Work
              ->@{fg shine}ABDt@{fg text} = Amos Bank Data
              ->@{fg shine}ABSp@{fg text} = Sample Bnk
              ->@{fg shine}APac@{fg text} = Amos Bank Image compactée
              ->@{fg shine}ABk?@{fg text} = Amos Bank Non défini
              ->@{fg shine}PDrw@{fg text} = Clip ProDraw
              ->@{fg shine}Med0@{fg text} = Module Med (Format 0)
              ->@{fg shine}Lha5@{fg text} = Lha/Lzh archivage 5
              ->@{fg shine}Lha1@{fg text} = Lha/Lzh archivage 1
              ->@{fg shine}Gif7@{fg text} = Image Gif 87a
              ->@{fg shine}Gif9@{fg text} = Image Gif 89a
              ->@{fg shine}Gif?@{fg text} = Image Gif inconnue
              ->@{fg shine}BMP.@{fg text} = Image BMP PC
              ->@{fg shine}Wave@{fg text} = Digit Format Wave
              ->@{fg shine}MIDI@{fg text} = Fichier MidiFile
              ->@{fg shine}.WMF@{fg text} = ClipArt Vectoriel PC
              ->@{fg shine}Warp@{fg text} = Warp Archive
              ->@{fg shine}ZOOM@{fg text} = Zoom Archive
              ->@{fg shine}.ZIP@{fg text} = Zip Archive
              ->@{fg shine}STSg@{fg text} = Sound/Pro/NoiseTracker Song
              ->@{fg shine}.PCX@{fg text} = Image PCX PC
              ->@{fg shine}MPln@{fg text} = Fichier MaxiPlan
              ->@{fg shine}TDDD@{fg text} = Fichier 3d 'TDDD' Imagine
              ->@{fg shine}DTyp@{fg text} = DataType...
              ->@{fg shine} -1 @{fg text} = Format non reconnu ou données brutes

@endnode
@node Miscb "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Add VAL To ADR@{fg text}

     Entré: ADR=Adresse de la case mémoire à additionner.
            VAL=Valeur à additionner.

@endnode
@node Miscc "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Sub VAL To ADR@{fg text}

     Entré: ADR=Adresse de la case mémoire à soustraire.
            VAL=Valeur à soustraire.

@endnode
@node Miscd "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Inc ADR@{fg text}

     Entré: ADR=Adresse de la case mémoire à incrémenter.

@endnode
@node Misce "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Dec ADR@{fg text}

     Entré: ADR=Adresse de la case mémoire à décrémenter.

@endnode
@node Miscf "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Swap.b ADR0 To ADR1@{fg text}

     Entré: ADR0/ADR1=Adresse mémoire à échanger.

  Remarque: Cette fonction travaille sur 1 octet, elle
            accepte les adresses impaire.

@endnode
@node Miscg "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Swap.w ADR0 To ADR1@{fg text}

     Entré: ADR0/ADR1=Adresse mémoire à échanger.

  Remarque: Cette fonction travaille sur 2 octets, elle
            n'accepte que les adresses paire.

@endnode
@node Misch "Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}Adr Swap.l ADR0 To ADR1@{fg text}

     Entré: ADR0/ADR1=Adresse mémoire à echanger.

  Remarque: Cette fonction travaille sur 4 octets, elle
            n'accepte que les adresses paire.

@endnode
@node Misci "Date: 02/05/96                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Wb Mem Compare(ADR0,ADR1,ADRLEN)@{fg text}

     Entré: ADR0=Adresse du premier segment mémoire à comparer.
            ADR1=Adresse du second segment mémoire.
            ADRLEN=Taille des segments à comparer.

    Sortie: RESULT=0 Si les deux segments sont identiques.
                  >0 Emplacement où se trouve la différence.

@endnode

@node Miscj "Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}BITMAP=Wb Bitplane(RP,NB)@{fg text}

     Entré: RP=Adresse du rastport.
            NB=N° du plan.

    Sortie: BITMAP=Adresse du plan s'il existe.

@endnode
@node Misck "Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}DEPTH=Wb Depth(RP)@{fg text}

     Entré: RP=Adresse du rastport.

    Sortie: DEPTH=Nombre de plan dans le Rastport.

@endnode
@node Miscl "Date: 30/05/96                                       System: v1.3+"

Synoptique: @{fg shine}RACINE=Int Sqr(CARRE)@{fg text}

     Entré: CARRE=Le carré donc la racine est recherchée.

    Sortie: RACINE=La racine du carré (CARRE).

  Remarque: Cette fontion est en moyenne 2 fois plus rapide
            que la fonction 'Sqr()' d'Amos, le nombre retourné
            est un entier (nombre sans décimale).

@endnode
@node Miscm "Date: 20/05/96                                 System: v1.3+ (???)"

Synoptique: @{fg shine}Wb Load Font NAME$,SIZE,FLAG To RP@{fg text}

     Entré: NAME$=Non de la Police de caractere.
            SIZE=Taille du corp de la police de carctere
            FLAG= ??
            RP=Rastport auquel la police sera affecter

  Remarque: Cette commande s'utilise avec la commande 'Text' d'Amos
            ou de l'extention.
@endnode
@node Miscn "Date: 10/05/96                                       System: v2.0+"

Synoptique: @{fg shine}TAG$=Wb Tag(TAG,VAL)@{fg text}

     Entré: TAG=N° de la fonction du tag.
            VAL=Valeur pour le Tag.

    Sortie: TAG$=Une chaîne formatée de huit octets

@endnode

@node Req0 "Date: 15/12/95                                       System: v2.0+"

Synoptique: @{fg shine}RES=Rt Dir Req(TITLE$,DIR$,POS)@{fg text}

     Entré: TITLE$=Titre du requester.
            DIR$=Chemin d'accès ou "" ou rien.
            POS=Position du requester
                0=Sous le pointeur.
                1=Centre de la fenêtre.
                2=Centre de l'écran.
                3=Coin supérieur gauche de la fenêtre.
                4=Coin supérieur gauche de l'écran.

    Sortie: RES=Code de l'action
                1=Bouton de gauche ou Ok, Touche RETURN.
                0=Bouton de droite ou Cancel, Touche ESC.
@endnode
@node Req1 "Date: 15/12/95                                       System: v2.0+"

Synoptique: @{fg shine}RES=Rt File Req(TITLE$,DIR$,NAME$,MPAT$,POS)@{fg text}

     Entré: TITLE$=Titre du requester.
            DIR$=Chemin d'accès ou "" ou rien.
            NAME$=Nom du fichier par défaut.
            MPAT$=MatchPattern ou "" ou rien
                Ex: "#$.info"=Affiche que les fichiers qui
                              se terminent avec .info
                   "~#$.info"=
            POS=Position du requester
                0=Sous le pointeur.
                1=Centre de la fenêtre.
                2=Centre de l'écran.
                3=Coin supérieur gauche de la fenêtre.
                4=Coin supérieur gauche de l'écran.

    Sortie: RES=Code de l'action
                1=Bouton de gauche ou Ok, Touche RETURN.
                0=Bouton de droite ou Cancel, Touche ESC.

  Remarque: Voir 'Rt Get Name$' et 'Rt Get Dir$'
@endnode
@node Req2 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}Rt Free Flist@{fg text}

  Remarque: Libère la mémoire de la liste occupée
            lors de l'appel à 'Rt Multifile Req'
@endnode
@node Req3 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}DIR$=Rt Get Dir$@{fg text}

    Sortie: DIR$=Retourne le Chemin d'accès sélectionné
            avec la commande 'Rt File Req'.
@endnode
@node Req4 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}NAME$=Rt Get Flist(F_NB)@{fg text}

     Entré: F_NB=N° du fichier de la liste.

    Sortie: NAME$=Nom du fichier sélectionné de la liste.

      Voir: 'Rt Multifile Req'

@endnode
@node Req5 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}NAME$=Rt Get Name$@{fg text}

    Sortie: NAME$=Retourne le Nom du fichier sélectionné
            avec la commande 'Rt File Req'.
@endnode
@node Req6 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}Rt Lib Close@{fg text}

  Remarque: Referme la librairie si elle a été ouverte.
@endnode
@node Req7 "Date: 15/12/95                                       System: v1.3+"

Synoptique: @{fg shine}OPEN=Rt Lib Open@{fg text}

    Sortie: OPEN=0 si pas ouvert (Retourne l'adresse de la ReqTools)

  Remarque: Il existe 2 versions de la ReqTools Wb1.3/Wb2.0+
            Attention à la compatibilité et au changement dû
            à la ROM1.3.
@endnode
@node Req8 "Date: 15/12/95                                       System: v2.0+"

Synoptique: @{fg shine}RES=Rt Multifile Req(TITLE$,DIR$,POS)@{fg text}

     Entré: TITLE$=Titre du requester.
            DIR$=Chemin d'accès ou "" ou rien.
            POS=Position du requester
                0=Sous le pointeur.
                1=Centre de la fenêtre.
                2=Centre de l'écran.
                3=Coin supérieur gauche de la fenêtre.
                4=Coin supérieur gauche de l'écran.

    Sortie: RES=Code de l'action
                0=Bouton de droite ou Cancel, Touche ESC.
               >0=Nombre de fichier sélectionné.
@endnode
@node Req9 "Date: 15/12/95                                       System: v2.0+"

Synoptique: @{fg shine}RES=Rt Text Req(TEXT$,BOUT$,TITLE$,FLAG,POS)@{fg text}

     Entré: TEXT$=Le texte à afficher se comporte comme un texte
                  en ASII, le retour à la ligne suivante utilise le
                  code 10 (RETURN)
              Ex: "Quel est votre"+Chr$(10)+"nom madame ?..."
            BOUT$=La définition des boutons se fait dans une seule chaine
                  avec une touche de séparation
              Ex: "Sylvie|Pierette|Elvira|Sandrine"
            TITLE$=Titre du requester.
            FLAG=0 >Normal
                 1 >Pas de touche RETURN pour le bouton de gauche.
                 4 >Texte centré.
            POS=Position du requester
                0=Sous le pointeur.
                1=Centre de la fenêtre.
                2=Centre de l'écran.
                3=Coin supérieur gauche de la fenêtre.
                4=Coin supérieur gauche de l'écran.

    Sortie: RES=0 > Bouton CANCEL ou bouton de droite
                1,2,3,4... > Bouton dans l'ordre de gauche à
                droite.
@endnode

@node ReqA "Date: 07/05/96                                       System: v2.0+"

Synoptique: @{fg shine}BOUT=Rt Number Req(TITLE$,VAL_ADR)@{fg text}

     Entré: TITLE$=Titre du requester.
            VAL_ADR=Adresse de la variable où se trouve la valeur,
            cela peut être:
            1) VAL=1993 : VAL_ADR=Varptr(VAL)
            2) Reserve as Work 10,4 : VAL_ADR=Start(10) : Loke VAL_ADR,1993

    Sortie: BOUT=0 Si le bouton Ok est sélectionné ou
                 1 Si c'est le bouton Annuler/Cancel.
@endnode


@node app0 "Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}APPADR=App Create Icon(0,0,2)@{fg text}

    Entrée: 0=
            0=
            2=

    Sortie: APPADR=Adresse de la structure AppIcon.

@endnode
@node app1 "Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}App Free Icon APPADR@{fg text}

     Entré: APPADR=Adresse de la structure AppIcon.

@endnode
@node app2 "Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}ARG$=App Get Arglist(NUM)@{fg text}

     Entré: NUM=N° de l'argument recherché.

    Sortie: ARG$=Nom du fichier.

    Voir: App Get Numarg

@endnode
@node app3 "Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}NUMARG=App Get Numarg@{fg text}

    Sortie: NUMARG=Retourne le nombre d'argument envoyé dans la
            AppIcon.

       Voir: App Get Arglist()

@endnode
@node app4 "Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Free Diskobject DEFICON@{fg text}

     Entré: DEFICON=Adresse de la structure IconObject.

@endnode
@node app5 "Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}DEFICON=Wb Get Deficon(DEFFLAG)@{fg text}

     Entré: DEFFLAG=Type de l'icone par défaut (Def_Icon...).

    Sortie: DEFICON=Adresse de la structure IconObject.

@endnode

@node Iff0 "Date: 12/05/96                                       System: v1.3+"

Synoptique: @{fg shine}CHK=Iff Find Chunk(CHKNAME$,BUFF,LEN)@{fg text}

     Entré: CHKNAME$=Nom du Chunk:
             Type de Chunk pour les images:
                BMHD=BitmapHeader (Definition de l'image/ecran).
                CAMG=CommodoreAmiga (ViewMode).
                AMSC=AmosScreen (Definition des ecran Amos).
                CMAP=ColorMap (Palette de couleur de l'image).
                BODY=Les données de l'image.
                ANNO=Annonceur.
                DPI =ArtDepartementalPro.
                GRAB=Definition pour les brush.
                NAME=Nom de l'image.
                CRNG=ColorRange (ColorCycling de DPaint).
                CCRT=ColorCyclingRangeAndTiming (Grafigraft).
                DEST=Destination Bitplanes.
                SPRT=Definition des Sprite.
            BUFF=Adresse de l'image chargé en memoire.
            LEN=Taille du fichier.

    Sortie: CHK=-1 Si le Chunk n'a pas ete trouvé, autrement c'est
            l'adresse de depart du chunk qui est retourné.

  Remarque: Avec CHKLEN=Leek(CHK-4) vous obtenez la taille en octet
            du Chunk.
            Cette commande fonctionne avec tout les type de fichier Iff.
@endnode
@node Iff1 "Date: 12/05/96                                       System: v1.3+"

Synoptique: @{fg shine}PAL=Iff Make Palette(CMAP,CNB)@{fg text}

     Entré: CMAP=Adresse retourne par 'Iff Find Chunk()'
            CNB=Nombre de couleur de la palette (CNB=Leek(CMAP-4)/3)

    Sortie: PAL=Adresse de la palette pour la commande 'Screen Palette'

@endnode
@node Iff2 "Date: 12/05/96                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=Iff Type(BUFFER)@{fg text}

     Entré: BUFFER=Adresse du buffer ou a ete chargé le
            fichier iff.

    Sortie: TYPE=-1 Si ce n'est pas un format Iff.
                ='ILBM' ($) Pour les Images.
                ='TEXT' ($) Pour les documents.
                ='SMUS' ($) Pour les modules de musique.
                ='SMPL' ($) Pour les echantillons sonore (Sample).
                ='ANIM' ($) Pour le format d'animation

  Remarque: Cette commande fonctionne avec tout les type de fichier Iff.

@endnode
