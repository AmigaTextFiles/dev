---------------------------------------------------------------------

				            MAKE LIB functions

---------------------------------------------------------------------

	1. Why Make Lib was made ?

	Well, my opinion is that AMOSPro is missing usable memory
	allocation routines and it doesn't have any routines to
	handle lists and nodes at all. So when I was in need of
	those I decided to code my own AMOSPro library.

	Make Lib includes most of list operating routines and many
	memory allocating routines to make your programs more system
	friendly as you can easily allocate memory blocks which are
	of needed size ONLY without using clumsy AMOS banks 
	routines. With malloc you can also make nifty Clean Up routine
	that frees all allocated memory with only ONE function call
	or even better, when you quit AMOSPro or Compiled program
	Make Lib automatically frees all memory allocated with malloc.

	Lists used by Make Lib are double linked, like amiga system's
	lists.

	Here's the structure of ListHeader (called List) in C format

	struct MinList {
		struct MinList *mlh_Head;			(4 bytes)
		struct MinList *mlh_Tail;			(4 bytes)
		struct MinList *mlh_TailPred;		(4 bytes)
	}

	As you can see list header is 12 bytes long and you MUST
	always allocate it and call funtion Ma NewList to initialize
	it.

	Here's the structure of Nodes in C format
	
	structure Node {
		struct Node *mln_Succ;
		struct Node *mln_Pred;		
	}

	--- Example ---
	
	Rem
	Rem	The structure used in this example is:
	Rem
	Rem	struct Node XYNode : Rem 8 bytes
	Rem	UBYTE       x      : Rem 1 byte
	Rem	UBYTE       y      : Rem 1 byte (= 10 bytes)
	Rem

	GLOBAL XP=9:YP=10:DATASIZE=8+2

	LIST = Ma Malloc (12,$10000) : Rem Allocate List header
	if (LIST)
		Ma Newlist LIST
	else
		Edit
	end if

	Rem Now List is initialized

	NODE = Ma Malloc (DATASIZE,$10000) : Rem Allocate node

	if (NODE)
		Poke NODE+XP,100:Poke NODE+YP,10
		Ma AddHead LIST,NODE
	else
		Edit
	end if 

	Rem Now we have made list with one node 

	Ma Free All : Rem Let's free all allocated memory

	Edit : Rem and then to editor

	--- Example ---


	2. Which extension ?

	The extension number of MakeLib is 17.


	ma AllocMem

	Usage:
		ptr = ma AllocMem (size,requirements)
	
	Inputs:
		size = Size of memblock wanted
		req. = Memory requirements (same as Exec AllocMem)
				 Bit 0  ($1) 		= Memory Public
				 Bit 1  ($2) 		= Memory Chip
				 Bit 2  ($4) 		= Memory Fast
				 Bit 16 ($10000) 	= Memory Clear

	Outputs:
		ptr  = pointer to memblock or 0 if not enough memory.

	ma FreeMem

	Usage:
		ma FreeMem ptr,size

	Inputs:
		ptr  = Memory block adress
		size = Size of memory block

	Outputs:
		None.

	ma NewList

	Usage:	
		ma NewList list

	Inputs:
		list = List to be initialized

	Outputs:
		None.

	ma AddHead 

	Usage:
		ma AddHead list,node

	Inputs:
		list = List to be Added node to
		node = Pointer to node to be added

	Outputs:
		None.

	ma Remove

	Usage:
		ma Remove node

	Inputs:
		node = Pointer to node to be removed

	Outputs:
		None.

	ma AddTail

	Usage:
		ma AddTail list,node

	Inputs:
		list = List to be added node to
		node = Pointer to node to be added

	Outputs:
		None.

	ma RemHead

	Usage:
		node = ma RemHead (list)

		ma RemHead removes first node in list and returns pointer
		to it.

	Inputs:
		list = List to remove node from.

	Ouputs:
		node = Pointer to node that was head of the list 
			or 0 if list was empty.

	ma AllocVec

		ma AllocVec allocates a memoryblock and stores the size of
		it. So when you need to free memoryblock you can do it by
		calling ma FreeVev without the size parameter (You have no
		need to store it anywhere).

	Usage:
		ptr = ma AllocVec (size,requirements)

	Inputs:
		size = Size of memblock wanted.
		req. = Memory requirements. See Ma AllocMem.

	Ouputs:
		ptr  = Pointer to memory block or 0 if not enough memory 

	ma FreeVec

	Usage:
		ma FreeVec ptr

	Inputs:
		ptr  = Pointer to memoryblock allocated by ma AllocVec.

	Ouputs:
		None.

	ma Malloc

	Usage:
		ptr = ma Malloc (size,requirements)

	Inputs:
		size = Size of memblock wanted.
		req. = Memory requirements. See Ma AllocMem.

	Ouputs:
		ptr  = Pointer to memory block or 0 if not enough memory 

	ma Free

	Usage:
		ma Free ptr

	Inputs:
		ptr = Pointer to memoryblock allocated with ma malloc.

	Ouputs:
		None. 

	ma Realloc

	Usage:
		newptr = Ma Realloc (oldptr,newsize)

	Inputs:
		ptr     = Pointer to memoryblock allocated with ma malloc.
	   newsize = New size for reallocated block

	Ouputs:
		ptr     = Pointer to new memory block or NULL if not enough
					 memory got.

	NOTE!
		The Memory attributes are same for new and old ptr. So if
		old memory was CHIP memory --> new memory will be CHIP too.

	NOTE!
		If there's not enough memory to complete this function then
	   old memory block will be deleted and NULL will be returned.
		When oldptr is reallocated all data that fits into new memory
		block will be copied into it. If old m.block is smaller than
	   new then additional bytes will be cleared.

	Examples:
	
		MAP = Ma Malloc (512,0)	: Rem We have MAP with 512 bytes
		MAP = Ma Realloc (MAP,1024) : Rem Now we have MAP with 1024 bytes +
		512 bytes of old data still exists at the beginning of MAP. Bytes
		over 512 are cleared to 0.


		MAP = Ma Malloc (1024,0)
		MAP = Ma Realloc (MAP,512)

	 	In this example we have mem block with 1024 bytes which is later
		shrunk into 512 bytes. New MAP ptr contains 512 bytes of old data.

	ma Free All

	Usage:
		ma Free All

		ma Free All frees all memoryblocks allocated with ma Malloc.
		Very useful in cleanup code to free all memory blocks with one
		command.

	Inputs:
		None.

	Ouputs:
		None. 

	ma Next

	Usage:
		ma Next (NODE)

		Ma Next returns next node in the list or NULL if node is last.

	Inputs:
		Node.

	Ouputs:
		Next node or NULL is last in list or empty list. 

	ma Prev

	Usage:
		ma Prev (NODE)

		Ma Prev returns previous node in the list or NULL if node 
		is first.

	Inputs:
		Node.

	Ouputs:
		Previous node or NULL is first in list or empty list. 

	ma First

	Usage:
		ma First (LIST)

		Ma First returns the very first node in the list.
	
	Inputs:
		List.

	Ouputs:
		The very first node in the list or NULL if list is empty.

	ma Last

	Usage:
		ma Last (LIST)

		Ma Last returns the very last node in the list.
	
	Inputs:
		List.

	Ouputs:
		The very last node in the list or NULL if list is empty.

	ma FileLen

	Usage:
		ma FileLen (Name$)

		ma FileLen  returns the file length in bytes.
	
	Inputs:
		Name with path.

	Ouputs:
		The size of file in bytes or -1 if no file present.

	ma ExtB

	Usage:
		ma ExtB (value)

		ma ExtB extends byte value to long word (AMOS integer).
	
		Example: value = maExtB(Peek(ptr))

	Inputs:
		A one byte value.

	Ouputs:
		The value in longword.

	ma ExtW

	Usage:
		ma ExtW (value)

		ma ExtW extends word value to long word (AMOS integer).
	
		Example: value = maExtW(Deek(ptr))

	Inputs:
		A one word value.

	Ouputs:
		The value in long word.

	ma Paste Icon

	Usage:
		ma Paste Icon (x,y,icon)

		ma PasteIcon is used to draw icons on AMOS screen. ma Paste Icon
		is word oriented, so x coordinate is rounded down to nearest 16
		pixels.
	
	Inputs:
		X		-X coordinate to draw icon to.
		Y  	-Y coordinate to draw icon to.
		Icon 	-Number of icon to draw 

	Ouputs:
		None.

	ma Point

	Usage:
		Color = ma Point (x,y)

		ma Point works exactly as AMOSPro's Point function.
	
	Inputs:
		X		-Number of x coordinate.
		Y  	-Number of y coordinate.

	Ouputs:
		The color under certain coordinates or -1.

	ma Plot

	Usage:
		 ma Plot x,y,color

		ma Plot works exactly as AMOSPro's Plot function.
	
	Inputs:
		X		-Number of x coordinate.
		Y  	-Number of y coordinate.
		Color -Number of color to plot.

	Ouputs:
		None.	


	Mem Chip

	Usage:
		 Mem Chip

		 Example:
			NODE = Ma Malloc (100,Mem Chip)
			Rem Allocates 100 bytes of chip memory
	
	Inputs:
		None.

	Ouputs:
		Chip memory requirement.	

	Mem Fast

	Usage:
		 Mem Fast

		 Example:
			NODE = Ma Malloc (100,Mem Fast)
			Rem Allocates 100 bytes of fast memory
	
	Inputs:
		None.

	Ouputs:
		Fast memory requirement.	

	Mem Public

	Usage:
		 Mem Public

		 Example:
			NODE = Ma Malloc (100,Mem Public)
			Rem Allocates 100 bytes of public memory
	
	Inputs:
		None.

	Ouputs:
		Public memory requirement.	

	Mem Clear

	Usage:
		 Mem Clear

		 Example:
			NODE = Ma Malloc (100,Mem Fast+Mem Clear)
			Rem Allocates 100 bytes of fast memory and Clears it to Nulls (0).

			NODE = Ma Malloc (100,Mem Chip+Mem Clear)
			Rem Allocates 100 bytes of chip memory and Clears it to Nulls (0).

			NODE = Ma Malloc (100,Mem Public+Mem Clear)
			Rem Allocates 100 bytes of public memory and Clears it to Nulls (0).
	
	Inputs:
		None.

	Ouputs:
		Clear memory requirement.	

	Ma Fopen

	Usage:
		FILE = Ma Fopen (Name$,Mode$)

	Inputs:
		Name$ = Path + Name of the file to be opened
		Mode$ = Open mode:
					"r" = Open an existing file for reading (don't create new!)
				   "w" = Open a new file (deletes older file if present!)	
					"a" = Open an old file for reading and writing (creates new
							if file named Name$ does not exists!)

	Ouputs:
		Pointer to file or NULL if couldn't open one.	
	
	Ma Fclose

	Usage:
		Ma Fclose (FILE)

	Inputs:
		FILE = pointer to file

	Ouputs:
		None.

	NOTE!
		All open files will closed when exiting AMOSPro or a compiled program.
	
	Ma Fread

	Usage:
		BYTESREAD = Ma Fread (FILE,buffer,len)

	Inputs:
		FILE   = pointer to file
		buffer = pointer to buffer to read bytes into
	   len    = number of bytes to read

	Ouputs:
		Total number of bytes read.
	
	Ma Fwrite

	Usage:
		BYTESWRITTEN = Ma Fwrite (FILE,buffer,len)

	Inputs:
		FILE   = pointer to file
		buffer = pointer to buffer to write bytes from
	   len    = number of bytes to write

	Ouputs:
		Total number of bytes written.
	
	Ma Fseek

	Usage:
		OLDPOSITION = Ma Fseek (FILE,position,mode)

	Inputs:
		FILE     = pointer to file
		position = position (in number of bytes) to seek in file
	   mode     = seek mode where:
						-1 = Seek from beginning of file
					    0 = Seek from current location
						 1 = Seek from end of file

		Examples:

		O=Ma Fseek (FILE,20,-1) : Rem Seek 20 bytes from beginning of file
		O=Ma Fseek (FILE,-20,1) : Rem Seek 20 bytes backwards from end of file
										  (Note negative value for position!)
		O=Ma Fseek (FILE,20,0) : Rem Seek 20 bytes forward from current pos.
		O=Ma Fseek (FILE,-20,0) : Rem Seek 20 bytes backward from current pos.

	   O=Ma Fseek (FILE,0,-1) : Rem Seek the beginning of file
	   O=Ma Fseek (FILE,0,1) : Rem Seek the end of file

	   NOTE! The length of file can be found by making to seeks to end of file

		O=Ma Fseek (FILE,0,1)
		O=Ma Fseek (FILE,0,1) : Rem Now O holds the length of file!

	Ouputs:
		Old position from the beginning of file.
	
