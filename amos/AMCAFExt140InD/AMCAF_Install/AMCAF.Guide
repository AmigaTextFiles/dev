@database AMCAF-Anleitung
@index sbefindex
@remark $VER: AMCAF V1.40 (17-Jan-95) manual written by Chris Hodges
@node main "AMCAF Extension Anleitung Deutsch"
AMCAF Extension V1.40 Anleitung von Chris Hodges.

*** ACHTUNG! ***

Benutzer, die AMCAF bereits von The Software Society bzw. von der
Nexus Software GmbH gekauft haben, lesen bitte @{" HIER " link ssocietysuxx} weiter!

@{" Vorwort                 " link svorwort} - Wichtige Informationen zur AMCAF-Extension

@{" Wie man sich registriert" link sregiste} - Registration von AMCAF

@{" Bank-Befehle            " link mbankbef} > Befehle zur leichten Bankverwaltung
@{" Grafik-Befehle          " link mgfx_bef} > Grafik- und Effektbefehle
@{" Disk-Befehle            " link mdiskbef} > Diskettenbefehle
@{" Zeit- und Datumsbefehle " link mzedabef} > Aktuelle Uhrzeit/Datum, etc.
@{" Joystick & Maus Support " link mjoymbef} > Weitere Befehle für die Joystickperepherie
@{" Vektor Befehle          " link mvecrbef} > Befehle zum Rotieren von Punkten in 3D
@{" Protracker Befehle      " link mprotbef} > Befehle zum Abspielen von Trackermusiken
@{" String&Integer Befehle  " link mstribef} > Funktionen für Strings und Zahlen
@{" Sonstige Befehle        " link mmiscbef} > Alles mögliche
@{" Extension-Befehle       " link mextebef} > Interne/Profi Befehle

@{" Hinweise                " link sdisks  } - Hinweise zu den beiden Disketten

 @{" Befehls-Index         " link sbefindex}  @{" Zusatz-Index          " link szusindex}  @{" Bugliste              " link sbuglist}
 @{" Grußliste             " link sgreeting}  @{" Copyrights            " link scopyright}  @{" History               " link shistory}

AMCAF is Copyright 1994/95 by Chris Hodges. Alle Rechte vorbehalten.

@endnode
@node sregiste "Wie man die Vollversion von AMCAF bekommt"
Wie man AMCAF registriert

Wenn Ihnen die Demoversion gefallen hat, können sie die vollständige,
registrierte Version für nur 30 DM erhalten. Füllen Sie einfach das
Formular unten aus und schicken sie es mir entweder per E-Mail oder
Schneckenpost. Die registrierte Version bzw das Keyfile wird Ihnen
innerhalb von zwei Wochen zugeschickt.

Snail-Mail:

Chris Hodges
Kennedystraße 8
D-82178 Puchheim
West Germany
Tel: +49-89/8005856 (Voice/Modem)

Bankkonto:

Christopher Hodges
Account 359 68 63
Sparkasse Fürstenfeldbruck
BLZ 700 530 70

E-Mail:

platon@cu-muc.de

WWW:

http://home.pages.de/~platon/
   
Registrationsformular:
~~~~~~~~~~~~~~~~~~~~~~

            An Chris Hodges
               Kennedystraße 8
             D-82178 Puchheim
               Germany

        JA, ich will AMCAF registrieren.
    Ich habe die Sharewaregebühr beigelegt (bitte ankreuzen):

    O als Bargeld (30 DM or US$20 or £15)
    O als Scheck (innerhalb Deutschlands: 30 DM)
    O als Scheck (außerhalb Deutschlands: 35 DM or US$24 or £17)
    O per Banküberweisung (30 DM)

        Sie MÜSSEN die folgenden vier Zeilen ausfüllen!

        Name: ______________________________________

      Straße: ______________________________________

    PLZ, Ort: ______________________________________

        Land: ______________________________________

        The neueste Version von AMCAF und das Keyfile
        wird an die obengenannten Adresse geschickt.

        Dies ist freiwillig:

     Telefon: ______________________________________

      E-Mail: ______________________________________

   Kickstart: ______________________________________

    Computer: ______________________________________
   (CPU, RAM
    Erweit.)  ______________________________________

   AMOS Ver.: ______________________________________

  Extensions: ______________________________________

        Schicken Sie mir:

    O die Vollversion auf zwei Disketten (es könnte sein,
      daß nicht alle Beispielprogramme auf die Disks passen)
    O die Vollversion auf zwei Disketten, mit lha gepackt
      (alle Beispiele, möglicherweise mit Bonus-Dateien)
    O nur das Keyfile und ein Update auf einer Diskette,
      da ich dieses Archiv noch da habe (welches für ein
      Update benötigt wird)
    O nur das Keyfile und ein Update per Email.

        Schicken Sie mir:

    O die englische Version des Installers & Anleitung
    O die deutsche Version des Installers & Anleitung
    O nur die deutsche Anleitung.

        Ich nutze (Mehrfachbekreuzung möglich):

    X OFS Disks (wenig Platz (837 KB), langsamer Zugriff)
    O FFS Disks (mehr Platz (878 KB), schnellerer Zugriff)
    O PFS+diskspare.device Disks (noch mehr Speicherplatz
      (1007616 Bytes pro DD Disk), sehr schneller Zugriff)
    O High-Density Disketten

        Für die zukünftigen Versionen von AMCAF:

    O Ich will über die Updates informiert werden
    O Ich möchte das Update über E-Mail erhalten (keine
      Mailgrößenbeschränkung vorhanden)
    O Ich möchte nur ein kleines Updatearchiv per E-Mail
    O Ich bekomme das Update über FTP/AmiNet
    O Ich warte auf die AmiNet CD
    O Ich rufe dich einfach an und hols mir via Modem &-)
    O Ich will garkein Update, AMCAF ist so schon gut genug ;-)

        Wie bewerten Sie AMCAF:

         sehr gut-1   2   3   4   5   6-ganz schlecht

    Eigenschaften O   O   O   O   O   O
     Installation O   O   O   O   O   O
    Beispielprogs O   O   O   O   O   O
        Anleitung O   O   O   O   O   O
   Preis/Leistung O   O   O   O   O   O
          Support O   O   O   O   O   O
      Spaß-Faktor O   O   O   O   O   O

    Kommentare, Vorschläge, neue Ideen, Bugs...:

    ____________________________________________________

    ____________________________________________________

    ____________________________________________________

    ____________________________________________________


@endnode
@node ssocietysuxx "Wichtige Informationen zum Upgraden von alten Versionen"
Verehrte Käufer der AMCAF Extension,

AMCAF ist KEIN Produkt der Software Society bzw. Nexus Software GmbH mehr.
Die desolaten Geschäftspraktiken von Herrn Heimer haben mich gezwungen,
AMCAF auf eigene Faust als Shareware zu verkaufen.

1. "Kann ich die neuen Versionen von AMCAF benutzen?"

   Das ist eine leider etwas kniffelige Sache. AMCAF V1.0 benutzte damals
   noch den Extension Slot 16. Als ich aber erfuhr, daß dieser bereits von
   einer anderen sehr beliebten Extension Namens EasyLife besetzt ist,
   mußte ich AMCAF auf Slot 8 verschieben. Das hat natürlich die
   Konsequenz, daß sie Ihre alten Programme, die AMCAF benutzen, nicht
   ohne eine Umstellung weiterbenutzen können. Diese kleine Umstellung ist
   aber nicht sehr schwierig und kostet meistens nicht sehr viel Zeit:

   - Ändern Sie den Namen der bereits installierten AMCAF-Extension in
     Slot 16 mit Hilfe des Interpreter_Config-Programmes von
     'AMOSPro_AMCAF.Lib' in 'AMOSPro_AMCAF16.Lib' um.
   - Benennen Sie entsprechende Extensiondatei in Ihrem APSystem-
     Verzeichnis in 'AMOSPro_AMCAF16.Lib' um.
   - Installieren sie das Update von AMCAF, wie es unten beschrieben ist,
     Dabei wird die neue Version der Extension in Slot 8 eingetragen.
   - Laden Sie jetzt AMOS Pro und prüfen Sie, ob beide Extensions geladen
     worden sind.
   - Repeat
     - Laden Sie eines Ihrer Programme in den Editor, welches noch die
       alte Version von AMCAF benutzt.
     - Rufen Sie das Retokenizer.AMOS Programm auf, welches die alten
       Befehle automatisch in die neuen umwandelt. Um diesen Prozess zu
       erleichtern sollten Sie sich das Programm auf eine Taste legen
       (z.B Alt-R).
     - Speichern Sie das Programm unter dem alten Namen wieder ab.
   - Until (kein altes AMCAF Programm mehr)=True
   - Nun können Sie mit Hilfe des Interpreter_Config-Programmes die alte
     AMCAF Extension aus Slot 16 entfernen.

   Dieser Prozess ist einmalig, das heißt, er muß nur bei der ersten
   Umstellung von AMCAF V1.0 auf AMCAF V1.1x erfolgen. Bei weiteren
   Updates muß er nicht wiederholt werden.

   Falls Sie nachträglich noch Programme finden, die die Fehlermeldung
   "Extension not loaded" bei einem Befehl Namens 'Extension Q' auswerfen,
   so tragen Sie einfach die AMCAF16.Lib nochmals ein und lassen den
   Retokenizer über dieses Programm laufen.

   Auch wenn diese Prozedur mit ein wenig Arbeit verbunden ist, so lohnt
   sie sich auf jeden Fall...

2. "Ich bin kein registrierter User, da ich AMCAF von der Software Society
    gekauft habe. Wie komme ich an die registrierte Version?"

   Das ist ganz einfach. Kopieren Sie einfach die Datei "SerialNumber" von
   Ihrer original AMCAF_Install-Diskette in das AMCAF_Install-Verzeichnis
   des Updates. Danach sollte die registrierte Version von AMCAF
   installiert werden können.

3. "Wie installiere ich denn nun das Update?"

   Holen Sie sich das AMCAFExt119.lha Archiv, falls sie es noch nicht
   haben sollten und entpacken Sie dieses. Entpacken Sie nun das
   AMCAFUpd130.lha-Archiv in das selbe Verzeichnis. Überschreiben Sie alle
   alten Dateien.
   Löschen Sie das "AMCAF_Install"-Verzeichnis, da es die englische Version
   enthält. Benennen Sie das "AMCAF_InstallGerman"-Verzeichnis in
   "AMCAF_Install" um und starten Sie das Script "ExecuteMeFirst!".

   Wenn Sie ein Backup Ihrer AMOSPro_Help-Files haben, sollten Sie die
   alten Help-Files restaurieren, sonst können die neuen Hilfetexte nicht
   richtig angefügt werden.

   Nun laden Sie einfach das Installationsprogramm. Installieren Sie
   einfach die Hauptdatei und die Beispielprogramme auf die Festplatte.

4. "Wie bekomme ich zukünftige Updates?"

   über das AmiNet (bzw die CDs) oder direkt bei mir. Wenn ich Sie bei mir
   registrieren soll, damit Sie über zukünftige Versionen informiert
   werden können, so schicken sie mir einfach einen Brief oder eine EMail,
   die Ihre Seriennummer (!), Ihre Anschrift und -falls vorhanden- Ihre
   EMail-Adresse enthält.

5. "Das Update passt nicht mehr auf zwei Disketten, was soll ich tun?"

   Eine Festplatte kaufen :-)

Viel Spaß noch mit dem Update von AMCAF.

@endnode
@node svorwort "Wichtige Informationen zur AMCAF-Extension"
Willkommen zur Anleitung der AMCAF Extension.

**************************************************************************
*                                                                        *
*** ACHTUNG *** ACHTUNG *** ACHTUNG *** ACHTUNG *** ACHTUNG *** ACHTUNG **
*                                                                        *
* AMCAF wird NICHT mehr von The Software Society oder der Nexus Software *
* GmbH vertrieben! Sie werden viel Ärger haben, wenn Sie AMCAF dort be-  *
* stellen, mal abgesehen davon, daß AMCAF dort ungefähr 70 DM kostet im  *
* Vergleich zu den 30 DM Sharewaregebühr.                                *
*                                                                        *
* Deshalb kaufen Sie AMCAF NICHT von der Software Society, lassen Sie es *
* sich bei MIR @{" registrieren. " link sregiste}                                          *
*                                                                        *
**************************************************************************

Vielen Dank für den Kauf der AMCAF Extension. Sie werden sicher zufrieden
mit diesem Produkt sein. Diese Erweiterung enthält über 200 Befehle und
Funktionen für die unterschiedlichsten Bereiche, mit über 40KB Länge ist
sie (soweit ich weiß) die größte Extension für AMOS Professional. Ein paar
Befehle funktionieren besser oder nur unter Kickstart 2.04, also wenn Sie
noch immer nicht auf 2.04 oder 3.1 umgestiegen sind, dann sollten Sie das
schleunigst tun, es lohnt sich wirklich!

Übrigens muß die Extension unter der Nummer 8 eingetragen werden, aber
das erledigt ja das Installationsprogramm für Sie!

Vergessen Sie nicht auch die @{" Hinweise " link sdisks} zu lesen!

Kein Programm ist fehlerfrei, und so es ist auch dieses nicht. Ich bitte
Sie deshalb, mir alle Bugs so schnell wie möglich mitzuteilen. Es nützt
mir jedoch nichts, wenn sie mir schreiben: Der Befehl xxx steigt bei mir
aus. Geben Sie mir auf jedenfall Ihre Konfiguration und vielleicht auch
den Programmteil, wo der Fehler auftritt.

Ich bin immer offen für Verbesserungen an AMCAF. Haben Sie Mut und rufen
Sie mich an, wenn Sie irgendwelche Probleme oder Vorschläge haben!

@{" Bezugsadresse für AMCAF-User " link myaddress}

Wenn Sie auf eine FTP-Distrubution Site Zugriff haben, können Sie sich
kostenlose Updates von AMCAF aus dem AmiNet in der Area dev/amos
downloaden. Bitte achten Sie darauf, daß sie sich das deutsche und nicht
das englische Update ziehen.

Viel Spaß noch mit der Extension!

Chris Hodges

@endnode
@node sdisks "Hinweise zu den beigelegten Disketten"
Hinweise zur Installations- und Beispieldiskette.

Falls Sie AMCAF noch nicht installiert haben, sollten Sie das bald tun,
denn die Beispielprogramme laufen alle nicht ohne AMCAF (logisch oder?).

Die Installation ist sehr einfach und unkompliziert. Lesen Sie einfach
die Anweisungen ganz aufmerksam durch, die beim Start des Installations-
programms erscheinen.

Bei der Installation werden Sie nach Ihrem Namen gefragt. Bitte geben
Sie diesen korrekt ein. Er wird in der Extensiondatei kodiert abgespei-
chert. Denken Sie daran, daß Sie die registrierte Version von AMCAF nicht
an Dritte weiterkopieren dürfen.

Die AMCAF-Extension kann entweder direkt auf Festplatte oder auf eine
AMOSPro_System-Diskette geschrieben werden. Für die Disketteninstallation
bietet AMCAF die Möglichkeit, entweder direkt Dateien auf der Diskette zu
löschen, um Platz zu schaffen und dann die Extension darauf zu kopieren,
oder aber eine neue Diskette zu formatieren und dorthin alle wichtigen
Dateien zu schreiben.

Leider hat die Datei "mod.no good" nicht mehr auf der Beispieldiskette
Platz gefunden, die von dem Programm "NoGood(StartTheDance).AMOS" benötigt
wird. Deswegen wurde Sie auf die Installationsdiskette kopiert.

Damit Sie den Befehl "Set Rain Colour" vollständig benutzen können, muß
die AMOS Pro Hauptbibliothek ein wenig modifiziert werden. Starten Sie
deshalb zuerst das Programm "SetRainColourPatch" und verlassen Sie danach
AMOS Pro wieder. Diese Änderung wirkt permanent, d.h sie muß nur ein
einziges mal ausgeführt werden.

Die Beispielprogramme wurden nicht nur geschrieben, damit Sie sie starten,
kurz anschauen und dann gleich das nächste hineinladen. Die meisten
Programme sind gut dokumentiert und bieten Ihnen die Möglichkeit, viel
dazuzulernen. Nehmen Sie sich bitte die Zeit, es lohnt sich wirklich!

Manche Befehle in AMCAF reagieren sehr empfindlich auf Mißbrauch.
Vergessen Sie deshalb nicht, Ihre eigenen Projekte regelmäßig abzu-
speichern.

@endnode
@node myaddress "Post geht an..."
Wenn noch Fragen auftreten, oder wenn Sie sogar einen Bug gefunden haben,
dann schreiben Sie mir oder rufen Sie mich an.

Bei Bugs senden Sie mir bitte eine DETAILLIERTE FEHLERBESCHREIBUNG mit
Ihrer Computerkonfiguration und dem Programmteil, wo der Fehler auftritt.

Snail-Mail:

Chris Hodges
Kennedystraße 8
D-82178 Puchheim
West Germany
Tel: +49-(0)89/8005856 (Voice/Modem)

Bankkonto:

Christopher Hodges
Account 359 68 63
Sparkasse Fürstenfeldbruck
BLZ 700 530 70
 
E-Mail:

platon@cu-muc.de

WWW:

http://home.pages.de/~platon/

Wenn Sie ein Modem besitzen und Zugriff auf InterNet haben gibt es da die
AMOS Mailing List, ein weltweites Netz von AMOS Programmierern. Gute
Englischkenntnisse werden vorausgesetzt. Wenn Sie die Liste bestellen
wollen, dann schicken Sie einfach eine Nachricht mit dem Betreff
"SUBSCRIBE" an amos-request@access.digex.net. Weitere Einzelheiten, sowie
alle Nachrichten eines Quartals erhalten Sie aus dem AMOSMailingList
Archiv in AmiNet dev/amos.

@endnode
@node sbuglist "Bugs mit denen Sie rechnen müssen"
Bug-Report

Dies ist eine kleine Liste mit AMOS-Bugs, mit denen Sie rechnen müssen:

1. Die AMOS Stringverwaltung ist nicht fehlerfrei. Besonders bei
   AMAL-Programmen müssen sie aufpassen!

2. Die AMOS Default Routinen werden nicht aufgerufen:
   Wenn man AMOS lädt, und dann ein Programm startet, so werden keine
   Extension-Default-Routinen aufgerufen. D.h wenn eine Musik vom
   vorherigen Programm noch läuft, so wird sie NICHT angehalten.
   Abhilfe: - Einmalig ein Accessory aufrufen
              (z.B ein Programm compilieren)

3. Programme, können nicht compiliert werden:
   Der Compiler meldet: 'Kein AMOS Programm'. Falls Banks benutzt werden,
   so müssen alle Banklängen gerade sein (außer die von Sprites-und
   Iconsbanks). Wenn das nicht der Fall ist, laufen die Programm zwar im
   Interpreter, lassen sich aber nicht compilieren.
   Abhilfe: - Ungerade Banks mit Bank Stretch um ein Byte erweitern.

4. Ein Programm, das mit Data-Zeilen arbeitet, funktioniert nicht korrekt
   als Compilat:
   Hinter einer Data-Zeile dürfen keine Kommentare stehen. Der Compiler
   interpretiert diese Kommentare als Daten.
   Abhilfe: - Kommentare in eine einzelne Zeile schreiben.

   Ein Freund hat ein ganz anderes Problem als er versuchte ein 500 KB
   Programm, welches nur aus Data-Zeilen bestand zu compilieren. Der
   Compiler stürzte einfach ab. Bis jetzt habe ich für diesen Fall noch
   keinen Ausweg gefunden.

5. Ein Programm mit Val-Funktionen arbeitet nicht richtig compiliert:
   Im Compilat gibt die Val-Funktion manchmal 0 zurück, obwohl eine
   korrekte Zahl eingegeben wurde. Tritt meistens bei sehr großen
   Programmen auf.
   Abhilfe: - Eine eigene Val-Funktion schreiben.

Bugs, die für Extensionprogrammierer interessant sind:

1. Maximal können 9 Parameter übergeben werden. Alles was darüber geht,
   wird ignoriert.

2. Alle Routinen, die direkt von einem Token angesprungen werden, müssen
   in den ersten 32-KB Code liegen, sonst gibts einen Absturz. Weiterhin
   dürfen Rbras und RBccs nicht weiter als 32 KB auseinander liegen.

@endnode
@node scopyright "Copyrights"
Amiga is a trademark of Escom AG.
MC68xxx series are trademark of Motorola Inc.

AMOS by François Lionet.      Copyright 1990 Mandarin/Jawx.
                              Copyright 1991 Europress Software Ltd.
AMOS Pro by François Lionet.  Copyright 1992 Europress Software Ltd.
AMCAF by Chris Hodges.        Copyright 1994 The Software Society.
                              Copyright 1995 Chris Hodges.
AMIPS by Thomas Nölker.       Copyright 1993 The Software Society.
TOME by Aaron Fothergill.     Copyright 1991 Shadow Software.
PowerPacker by Nico François. Copyright 1990 PowerPeak.
ProTracker 2.2 by P. Hanning. Copyright 1992 Noxious. (PD)

Turbo Imploder by P. Struijk & A. Brouver. Freeware 1991.

@endnode
@node sgreeting "Aha... Man glaubt, man wird gegrüßt? ;)"
Also erstmal einen Gruß an alle, die die Extension bei mir registriert
haben. Nochmals vielen Dank.

Dann gehen spezielle Grüße an:

Meine Eltern (Hallo!)
Meinen Bruder (Mach hin! Ich will eine schöne Raytracinganimation sehen!)
Meine Schwester (Hi Dumpfbacke!)
Hans Peter Obermeier (Na, gibts was neues? ;-))
Ralf Schulz (Oh, ich kann es immer noch nicht begreifen, warum Du Dir eine
             MS-Dose gekauft hast... :-( )
Markus Ungerer (Schreib mal wieder eine Kurzmail!)
Bernd Ungerer (Danke fürs Beta-Testen und für die guten (?) Vorschläge!)
Michael Ufer (Du kleiner Hobbyzauberer! Danke für die vielen tollen Mails)
Oliver Ufer (Danke für die vielen Vorschlage ;-) )
Oliver Seibert (Die Surprise war die beste Box, die ich kannte!)
Oliver K.
Dirk Drießen (Man gönnt sich ja sonst nix ;-))
Ralph Bernecker (Hallo jMS/Dr.Feelgood/Striker/fELON)
Alexander Kunz (Thx 4 da kewl tunes and support!)
Omer Sasic (+++)
Claude Müller (Grüße in die Schweiz! Hoffentlich kommste bald aus der Army)
Dirk Schulten (Hallo Maus-User! ;-) )
Andre Panser (Schreib mal wieder)
Andreas Duncker (Danke für Deinen aufbauenden Brief ;-) )
Mathias Mischler (Danke für Deinen Support!)
Andreas Zymny (Das Quotezeichen bleibt UNKONFIGURIERBAR! Basta! ;-) )
Kriegsheld (Jaja! Eigentlich ist ja heute schon morgen, gelle?)
Henning Baron
Rainer Benda
Robert Rothhardt (Danke für die beste Zeit in meinem ganzen Schulleben!)
Florian Fackler (Strato Impact rulez!)
Thomas Nölker (Viel Glück mit Deiner AMIPS-Extension!)
Jürgen Schäfer (Sorry wegen der Gif-Geschichte, vielleicht kommt das noch)
Greg Cox (Keep up the good work!)
Michael Cox (Thanks for adding me to the mailing list ;-) )
Carsten Albert 
Marco Eberhardt (Thanks for your nice mails)
Paul Hickman
Andy Church
Ben Wyatt (Greetings! ;-))) )
Petri Hakkinen (nice 3D engine!)
Roy Antonsen (stop drinking so much booze ;-) )
Martijn Wehrens (Immer wieder lustige PMs! Weiter so!)
Semprini (you're a REAL friend!)
Mark Wellington (nice stories from ya, keep that up!)
Daniel Rädel
Thomas Nokielski
Jari Jokivuori   
und alle anderen, die mich kennen, und die ich ausversehen vergessen habe.

Weiterhin grüße ich meine Modem-Kumpels:

Magic, Lemming, VIP, Schneemann, Killer, Marvin, Harry, Holger,
Caboose, Blue Shogun, Ralli, REYem, Nosy und Kily.

Merlin, WotaN, Vinzenz, Fritz, Braumeister, Amigaman und Kai.

Dr.Dre, Tomy, Brocker, Case, Omer and Guru.

Flüche an:

Hendrik Heimer (Sie wissen ganz genau, warum, Mr. Software Society!)
François Lionet
Jester (Christoph Steinecke)
Nobody (Horst Bressem)
Intel, IBM und MicroSoft
Deutsche Telekom
Europress
Data Becker und Sybex
R2B2 ($§%$&%§$)
Phase 5

So... ich hoffe, ich habe keinen Vergessen... huch ja... Grüße noch an
alle Mitglieder des RAMSES-Computerclubs.

CU
    ______   __  __   ______   __   _____
   /,____/\ / /\/,/\ / __ //\ /,/\ / ___/\
  ///\___\// /_/// //,/_/'/ //// //./___\/
 /'/_/_   / __ '/ ///  __/ //'/ / \__, /\
/_____/\ /_/\/_/ //_/\_\_\//_/ / /____/ /
\_____\/ \_\/\_\/ \_\/\_\  \_\/  \____\/

@endnode
@node shistory "History der AMCAF-Extension"
History der Amcaf-Extension.

V1.43 02-Nov-96
---------------
- Sload/Ssave hinzugefügt. Das sind die selben Befehle wie in der Music
  Extension. Jetzt kann man sie endlich ganz entfernen!
- Diverse Bugfixes.

V1.42 18-Oct-96
---------------
- Unterstützung für Set Tmpras für Fellipse&Fcircle eingebaut.
- Typ-Überprüfung für Protracker-Module eingebaut.

V1.41 29-Mar-96
---------------
- Bug in Xfire entdeckt und gefixt.
- Kleinere Änderungen.

V1.40 26-Dec-95
---------------
- Neue Befehle:
  - =Pt Cpattern
  - =Pt Cpos
  - =Pt Cinstr(channel)
  - =Pt Cnote(channel)
  - Pt Sam Freq channel,freq
  - =Vclip(v,lower To upper)
  - =Vin(v,lower To upper)
  - =Vmod(v,upper)
  - =Vmod(v,lower To upper)
  - =Insstr$(a$,b$,pos)
  - =Cutstr$(a$,pos1 To pos2)
  - =Replacestr$(a$,search$ To replace$)
  - =Itemstr$(a$,item)
  - =Itemstr$(a$,item,sep$)
  - =Qarc(dx,dy)
  - =Even(val)
  - =Odd(val)
  - =Ham Point(x,y)
  - Set Object Date file$,date,time
  - =Aga Detect
  - Pal Spread c1,rgb1 To c2,rgb2
  - =Ct String(time$)
  - =Cd String(date$)
  - C2p Convert st,wx,wy To screen,ox,oy
  - C2p Shift st,wx,wy To st2,shift
  - C2p Fire st,wx,wy To st2,sub
- Pal Set Screen führt nun automatisch ein 'View' aus.
- Weiteren Bug in Ptile Paste behoben.
- Sinus-Tabelle verschoben und geviertelt, dadurch spare ich in etwa
  1536 Bytes, Arctan-Tabelle hinzugefügt.

V1.31 03-Oct-95
---------------
- Leider (?) lag der Fehler nicht in Change Bank Font, sondern in
  Make Bank Font. Zwar ist dieser Fehler nun behoben, jedoch müssen
  wahrscheinlich alle alten Fontbanks neu erstellt werden!
- Rnc Unpack und =Rnp endgültig rausgeflogen.
- Bug in Pt Stop behoben, der die Kanäle abschaltete, obwohl keine
  Musik spielte.
- Neue Befehle:
  - Pt Continue
- Bug in Change Bank Font behoben.

V1.30 31-Aug-95
---------------
- NÄCHSTEST OFFIZIELLES UPDATE.
- Diverse Kürzungen und Umstellungen, damit ich wieder unter die
  32KB Grenze komme.
- Best Pen unterstützt nun den EHB Modus.
- Bug in der PlaySample-Routine gefunden und entfernt.
- Bug in Pt Raw Play gefunden und entfernt.
- Bug in Extpath$ behoben (Thx Ben!)
- Neue Befehle:
  - =Best Pen($RGB[,c1 To c2])
  - Bzoom s1,x1,y1,x2,y2 To s2,x3,y3,m
  - =X Smouse
  - =Y Smouse
  - Limit Smouse [x1,y1 To x2,y2]
  - Smouse X x
  - Smouse Y y
  - Smouse Speed speed
  - =Smouse Key
  - =Xfire(port,button)

V1.19 30-Jun-95
---------------
- Neue Befehle:
  - Exchange Bob i1,i2
  - Exchange Icon i1,i2

V1.18 21-Mar-95
---------------
- NÄCHSTES OFFIZIELLES UPDATE.
- Selten auftretenden Bug in Turbo Plot behoben.

V1.17 16-Feb-95
---------------
- Kleiner Fehler in der Protracker-Routine: Maske für FineSlideUp war $D
  anstatt $F, wodurch der $2-er Slide verschluckt wurde. (Thx Patrick)

V1.16 29-Jan-95
---------------
- Kleiner Fehler beim Protracker-CIA Replay aufgetaucht: Pt Cia Speed ver-
  weigerte bei compilierten Programmen den Dienst (warum, weiß ich nicht!)
- Aus Leichtsinn (?) einen Pt Sam Befehl vergessen:
  - Pt Sam Volume [voice,] volume
- Code ein wenig umgeordnet, damit Demoversion funktioniert (32 KB Limit!)
- Neue Palette-Handling Befehle:
  - Pal Get Screen palnr,screen
  - Pal Set Screen palnr,screen
  - =Pal Get(palnr,colindex)
  - Pal Set palnr,colindex,colour

V1.1 28-Dec-94
--------------
- Protracker Replaycode umgeschrieben, damit die Samples richtig ge-
  handhabt werden.
- Neue Befehle:
  - =Pt Data Base
  - =Pt Instr Address(samnr)
  - =Pt Instr Length(samnr)
  - Pt Bank bank
  - Pt Raw Play voice,address,length,freq
  - Pt Instr Play samnr
  - Pt Instr Play voice,samnr[,freq]
  - Pt Sam Bank bank
  - Pt Sam Play samnr
  - Pt Sam Play voice,samnr[,freq]
  - Pt Sam Stop voice
- Kleinere Optimierungen an Ham Fade.
- Weiterer Bug in Ptile Paste beseitigt.
- Bug in Speek: Speek erlaubte nur gerade Adressen.
- Blöder Fehler in Lsstr$ und Lzstr$. Erzeugten oft Müllstrings oder
  kehrten nicht zurück.

V1.0 16-Oct-94
--------------
- ERSTE VERKAUFSFERTIGE VERSION!
- Mehrere kleine Fehler bei der Registrationsabfrage entfernt.

V1.0ß 06-Oct-94
---------------
- Imploder Load gab bei erfolgreichem Laden das Lock auf die Datei
  nicht mehr frei. Fehler behoben.

V1.0ß 22-Sep-94
---------------
- Bei jeder Stringallokation zwei Bytes mehr verlangt. Jetzt scheint es
  keine Probleme mehr mit dem Stringpuffer zu geben.

V1.0ß 28-Aug-94
---------------
- Ptile Paste hatte einen Bug. Fehler behoben.
- =Extpath$ überschrieb bei leeren Strings 32KB Variablenpuffer!!! Argl...
- =Ham Best komplett neu geschrieben. Funktioniert jetzt besser.
- Coords Read und =Count Pixels haben einen Errorcheck bekommen.
- Coords Bank erzeugte eine Coords Bank, die nicht voll ausgenutzt
  wurde und genau eine Koordinate zu wenig speichern ließ.
- Coords Bank machte Speicher korrupt bzw. stürzte ab, wenn man eine 0
  Koordinaten Bank erzeugen wollte.
  Das selbe galt für Splinters Bank. Fehler behoben.
- =Ham Best umgeschrieben. Ist jetzt viel schneller als vorher!
  Tip kam von Dr. Peter Kittel! :)
- Protracker: Vumeter unterstützte nicht das C-Kommando, daher gab =Pt Vu
              meist als Lautstärke 64 zurück. Fehler behoben.
- Protracker: Wenn ein Channel abgeschalten wurde, konnten weder Signale von
              diesem empfangen werden, noch wurden Speed-Befehle und anderes
              beachtet. Unterroutine eingebaut, um das zu handlen.
- Secexp in Binexp und Seclog in Binlog renamed.
- Protracker: 99%igen Init-Code geschrieben. Jetzt sollten viele verschiedene
              Tunes hintereinander nicht mehr die Funks oder die
              Patternrepeats durcheinander bringen.
- Database vom Chip ins Fastram gelegt (Hätte ich schon lang tun sollen!).
- Durch die obengenannten Verbesserungen wurde der Code zu lang, um einen
  Branch Befehl auszuführen. Dadurch hängte AMOS sich auf. Fehler behoben.

V0.992ß 27-Jul-94
-----------------
- Hab jetzt endlich Ferien, und kann mich voll auf die Anleitung
  konzentrieren. Releasedate für V1.0 wurde auf den 1.9.94 gesetzt.
- Extension umstrukturiert, sodaß jetzt die Funktionen, die ein Token
  haben, in den oberen 32 KB sitzen. Jetzt sollte wieder alles funzen :))
- Jetzt kann man während des Spielens von Modulen zwischen CIA und VBL um-
  schalten.
- Kleiner Bug in Bank Copy gefunden und eleminiert.
- Befehle wieder reingehaun: Rnc Unpack und =Rnp
- Neue Befehle:
  - =Qsqr(value)
  - Bcircle x,y,r,c
- Turbo Plot, Shade Pix und Turbo Point haben jetzt endlich einen Randcheck,
  sind also genauso sicher wie die normalen Plot- und Point Befehle.
- Ham Fade ist jetzt ein wenig schneller.
- Pt Signal liefert jetzt $FF, wenn das Songende erreicht wurde.

V0.991ß 18-Jul-94
-----------------
- Neue Befehle:
  - Set Rain Colour rainnr,colour
  - Rain Fade rainnr,colour
  - Rain Fade rainnr To rainnr

V0.990ß 01-Jul-94
-----------------
- Befehle rausgeschmissen, um die Ext kleiner zu machen:
  - Rnc Unpack
  - =Rnp
- Ein paar Fehlermeldungen von Io Error$ rausgenommen.

V0.990ß 04-Jun-94
-----------------
- Durch die Umsortierung der Befehlsgruppen einen tödlichen Bug 'erzeugt'.
  Anscheinend ein AMOS interner Bug, allerdings solange ich die Befehle
  Audio Lock und Audio Free an die letzte Stelle schreibe, sollten alle
  anderen Befehle funktionieren. Ich konnte aber noch nicht alle Befehle
  auf Funktionalität prüfen, also Vorsicht! Auf jedenfall funktionieren
  alle Befehle compiliert, was die These eines AMOS Bugs verstärkt.
  DIE BEFEHLE AUDIO LOCK UND AUDIO UNLOCK NICHT IM INTERPRETER VERWENDEN!!!
- Neue Befehle:
  Blitter Copy Limit screen
  Blitter Copy Limit x1,y1 To x2,y2     [Für Bernd: x2,y2 Koordinatenbasis 1]
  Blitter Copy sc1,pl1 [,sc2,pl2 [,sc3,pl3]] To sc4,pl4 [,minterm]

V0.989ß 03-Jun-94
-----------------
- Bugs in Blitter Fill und Blitter Clear entdeckt, die seltsame
  Programmstrukturfehler erzeugten (z.B Ausstieg aus For-Next-Schleifen)

V0.989ß 03-Jun-94
-----------------
- Blitter Fill ist jetzt sicherer als vorher.
- Neue Befehle:
  - Blitter Clear screen,plane
  - Blitter Clear screen,plane,x1,y1 To x2,y2
  - Blitter Wait
  - flag=Blitter Busy
  - Shade Pix x,y
  - Shade Pix x,y,planes

V0.988ß 02-Jun-94
-----------------
- Turbo Draw unterstützt jetzt Clipping!!! Auch spezielle Checkroutinen
  für den Blitter Mode eingebaut.

V0.988ß 31-May-94
-----------------
- Hurra!!! Endlich funktionieren die Splinters Befehle 100%!!!
- Diverse Optimierungen an den Splinters und Td Stars Befehlen.
  - Speicherverbrauch pro Splinter von 32 auf 22 Bytes reduziert.
  - Speicherverbrauch pro Td Star von 16 auf 12 Bytes reduziert.

V0.987ß 29-May-94
-----------------
- Neue Befehle, damit Markus endlich Ruhe gibt!
  - Make Bank Font bank
  - Change Bank Font bank
- Neue Funktion:
  - =Cop Pos
- Kleiner Fehler: Bei Pt Play wurde das Signal nicht auf 0 zurückgesetzt.
- Neue Funktion:
  - =Vec Pos Z(x,y,z)
  - =Vec Pos Z
- Private Befehle entfernt.

V0.986ß 27-May-94
-----------------
- Drei ganz private temporäre Befehle eingebaut (für ne Postdisk).
  Werden bei Fertigstellung der Postdisk wieder gelöscht.
  - Private A bank1,bank2,bitplane,maxrand
  - =Private B(bank2)
  - =Private C(bank2)
  NICHT VERWENDEN!!! Falsche Anwendung führt zum Absturz!!!
- Neue Funktion
  - =Qrnd(value) als Ersatz für Rnd... benötigt kein Randomize
    und ist schneller.
- Fehler in der Tokenliste bewirkte bei falschem Syntax von
  Blitter Fill, daß es in Pt Play umgewandelt wurde. Lustig :)
- Fehler in den Blitter Fill Befehlen gefunden und behoben. Blitter Fill
  füllte immer eine Zeile zu tief -> Speicherkorruption.
- Bug in der Vektor Rotationsberechnung bei negativen Positionen behoben.

V0.986ß 25-May-94
-----------------
- Neuer Befehl, damit Bernd endlich Ruhe gibt!!!
  - Change Print Font bank

V0.986ß 24-May-94
-----------------
- Vec Rot Befehle fertiggestellt. =Vec Rot Adr wieder entfernt.
- Vec Rot Befehle:
  - Vec Rot Pos posx,posy,posz
  - Vec Rot Angles angx,angy,angz
  - Vec Rot Precalc
  - =Vec Rot X(x,y,z)
  - =Vec Rot X
  - =Vec Rot Y(x,y,z)
  - =Vec Rot Y

V0.985ß 24-May-94
-----------------
- Bug in Cd Date$ entfernt. (Thx Bernd)
- Billiger Bug in Blitter Fill screen,plane entdeckt und korrigiert.
- Turbo Draw Bug im Blitter Mode hoffentlich endgültig entfernt.
- Neue Befehle:
  - =Qsin(angle,factor)                 angle ist ein Winkel von 0 bis 1023
  - =Qcos(angle,factor)                 factor ein Wert, mit dem der Sinus
                                        multipiziert werden soll.
  - Vec Rot Pos midx,midy,midz          Positionen für die Vektor-Rotation
  - Vec Rot Angles angx,angy,angz       Rotationswinkel der Rotation
- Noch fehlerhaft:
  - Vec Rot Precalc                     Erstellen der Matrize
  - =Vec Rot X(x,y,z)                   Ermitteln des neuen X-Wertes
  - =Vec Rot Y(x,y,z)                   Ermitteln des neuen Y-Wertes
- Zu Testzwecken die Funktion =Vec Rot Adr eingebaut.

V0.984ß 21-May-94
-----------------
- Neue Synti zu Blitter Fill:
  - Blitter Fill screen,plane
  - Blitter Fill screen,plane,x1,y1,x2,y2
  - Blitter Fill s1,p1 To s2,p2
  - Blitter Fill s1,p1,x1,y1,x2,y2 To s2,p2
- Turbo Draw zeichnet jetzt nicht mehr auf nicht existenten Bitplanes.
  (Thx Marc)
- Change Font hängt selbständig ein '.font' an, wenn nötig. (Thx Markus)

Leider existieren für das erste halbe Jahr keine History Einträge.

@endnode
@node mbankbef "Befehle zur leichten Bankverwaltung"
Bankverwaltung und -manipulation.

Die AMCAF-Extension beinhaltet eine Vielzahl von Befehlen, die sich den
AMOS Memory Banks widmen. Bei allen Befehlen ist es wichtig, daß, falls
Adressen vorkommen, diese GERADE sind, da es sonst bei einem MC68000 zum
Absturz Ihres Amigas kommt. Außerdem muß die Länge jeder Bank gerade
sein, da sonst der Compiler die Fehlermeldung 'Kein AMOS Programm
ausgibt', aber das ist ein AMOS Problem nicht eines von AMCAF.

@{" Allgemeines        " link dbanks} - Ein paar Informationen zu AMOS Banks

Befehle:

@{" Bank Permanent     " link cbnkperm} - Macht eine Bank @{" permanent " link dpermanent}
@{" Bank Temporary     " link cbnktemp} - Macht eine Bank @{" temporär  " link dtemporaer}
@{" Bank To Fast       " link cbnkfast} - Verschiebt eine Bank ins @{" Fast-Ram " link dfastram}
@{" Bank To Chip       " link cbnkchip} - Verschiebt eine Bank ins @{" Chip-Ram " link dchipram}
@{" Bank Stretch       " link cbnkstre} - Vergrößert eine Bank nachträglich
@{" Bank Copy          " link cbnkcopy} - Kopiert eine Bank
@{" Bank Name          " link cbnkname} - Nennt eine Bank um
@{" Bank Code xxx.y    " link mbnkcode} > Befehle zum Kodieren einer Bank
@{" Bank Delta Encode  " link cbnkdlte} - Kodiert eine Bank mit dem Delta-Verfahren
@{" Bank Delta Decode  " link cbnkdltd} - Entfernt die Delta-Codierung wieder.
 
Funktionen:

@{" =Bank Checksum     " link fbnkchec} - Berechnet die Checksumme einer Bank
@{" =Bank Name$        " link fbnkname} - Gibt den Namen einer Bank zurück

@endnode
@node mbnkcode "Bank Code Befehle"
Bank Code Befehle

Mit diesen Befehlen lassen sich Banks in verschiedener Weise kodieren, um
sie vor Einsicht und Zugriff von Unbefugten zu schützen.
Besonders für Kopierschütze, die nach einem Wort aus einem Handbuch
fragen, lassen sich so besser schützen.

Alle Befehle gibt es in zwei Ausführungen, eine mit der Endung @{" .b " link dbyte} und
eine mit @{" .w " link dword}. Bei .b kann der Code einen Wert von 1 bis 255 annehmen,
bei .w von 1 bis 65535. Ausnahmen bilden die Rotationsbefehle, dort sollte
der Code immer nur von 1 bis 7 bzw. von 1 bis 15 reichen.

Und alle Befehle haben den Syntax

Bank Code xxx.y code,bank
Bank Code xxx.y code,startaddress To endaddress

Befehlsversionen:

@{" Bank Code Add.y    " link cbcodadd} - Additionsverfahren
@{" Bank Code Xor.y    " link cbcodxor} - Exklusiv-oder-Verknüpfung
@{" Bank Code Mix.y    " link cbcodmix} - Mischung aus Add und Xor
@{" Bank Code Rol.y    " link cbcodrol} - Rotation der Bits nach links
@{" Bank Code Ror.y    " link cbcodror} - Rotation der Bits nach rechts

@endnode
@node mdiskbef "Diskettenbefehle"
Diskettenbefehle

AMCAF will auch diesen Bereich abdecken und in AMOS vermißte Befehle
liefern.

@{" Primäre Befehle    " link mdskprim} > Befehle zum Laden, Sichern, Kopieren, etc.
@{" Dateizugriff       " link mdskobje} > Befehle zur Dateiverwaltung
@{" Hilfsfunktionen    " link mdskhelp} > Hilfsfunktionen für Filehandling, etc.
@{" Packersupport      " link mdskpack} > Powerpacker und Imploderbefehle

@endnode
@node mdskhelp "Disk Hilfsfunktionen"
Disk Hilfsfunktionen

Diverse Hilfsfunktionen, damit Sie auch morgens noch kraftvoll zubeissen
können.

@{" =Io Error          " link fioerror} - Gibt die Nummer des letzten DOS-Fehlers aus
@{" =Io Error$         " link fioerstr} - Gibt einen DOS-Fehlerstring zurück
@{" =Filename$         " link ffilname} - Gibt den Dateinamen zurück
@{" =Path$             " link fpathstr} - Gibt den Pfad zurück
@{" =Extpath$          " link fextpath} - Fügt dem Pfad ein "/" hinzu, wenn nötig
@{" =Object Protection$" link fobjprst} - Gibt einen @{" Schutzbits-String  " link dprotflags} zurück
@{" =Pattern Match     " link fpatmatc} - Vergleicht einen String mit einem Muster
@{" =Disk State        " link fdskstat} - Gibt den Status der Diskette zurück
@{" =Disk Type         " link fdsktype} - Gibt den Typ der Diskette zurück
@{" =Dos Hash          " link fdoshash} - Berechnet den Hashwert einer Datei

@endnode
@node mdskobje "Befehle zum Objekthandling"
Befehle zum Objekthandling

AMOS bietet mit Dir First$ und Dir Next$ weder zuverlässige, noch leicht
zu verarbeitende Funktionen. Auch war über ein Objekt nur der Name und die
Länge bekannt, was war aber wenn man mehr wissen wollte? Nun gibt es ja
AMCAF, die Lösung dieser Probleme.

Befehle:

@{" Examine Object     " link cexamobj} - Holt Informationen zu einem @{" Objekt " link dobject}
@{" Examine Dir        " link cexamdir} - Initialisiert das Lesen eines Verzeichnisses
@{" Examine Stop       " link cexastop} - Stoppt das Lesen des Verzeichnisses

Funktionen:

@{" =Examine Next$     " link fexanext} - Liest den nächsten Eintrag eines Verzeichnisses
@{" =Object Name$      " link fobjname} - Gibt den Namen eines @{" Objekts " link dobject} aus
@{" =Object Type       " link fobjtype} - Gibt den Typ eines @{" Objekts " link dobject} zurück
@{" =Object Size       " link fobjsize} - Gibt die Länge einer Datei zurück
@{" =Object Blocks     " link fobjblks} - Gibt die Länge einer Datei in Blocks aus
@{" =Object Protection " link fobjprot} - Gibt die @{" Schutzbits " link dprotflags} eines @{" Objekts " link dobject} zurück
@{" =Object Time       " link fobjtime} - Gibt die Erstellungszeit eines @{" Objekts " link dobject} an
@{" =Object Date       " link fobjdate} - Gibt das Erstellungsdatum eines @{" Objekts " link dobject} zurück
@{" =Object Comment$   " link fobjcomm} - Gibt den Kommentar eines @{" Objekts " link dobject} aus

@endnode
@node mdskpack "Packer Support"
Packer Support

Packer sind ein wichtiges Hilfsmittel, wenn man viele Daten auf einer
Diskette unterbringen will. Powerpacker und File-Imploder sind zwei von
den besten und natürlich werden sie von AMCAF unterstützt.

@{" Ppfromdisk         " link cppfrdsk} - Lädt und entpackt eine powergepackte Datei
@{" Ppunpack           " link cppunpak} - Entpackt eine powergepackte Bank
@{" Pptodisk           " link cpptodsk} - Packt und speichert eine Bank im PP20-Format

@{" Imploder Load      " link cimpload} - Lädt und entpackt eine FileImploder-Datei
@{" Imploder Unpack    " link cimpunpk} - Entpackt eine FileImploder-Datei

@endnode
@node mdskprim "Primäre Befehle"
Primäre Befehle

Simple Befehle für das Lesen, Schreiben und Ändern von Dateien.

@{" File Copy          " link cfilcopy} - Kopiert eine Datei
@{" Wload              " link cfiwload} - Lädt eine Datei @{" temporär " link dtemporaer} ein
@{" Dload              " link cfidload} - Lädt eine Datei @{" permanent " link dpermanent} ein
@{" Wsave              " link cfiwsave} - Speichert eine Datei
@{" Dsave              " link cfidsave} - Speichert eine Datei
@{" Protect Object     " link cprotobj} - Ändert die @{" Schutz-Bits " link dprotflags} eines @{" Objekts " link dobject}
@{" Set Object Comment " link cobjcomm} - Ändert den Kommentar eines @{" Objekts " link dobject}
@{" Set Object Date    " link cobjdate} - Ändert das Datum eines @{" Objekts " link dobject}
@{" Launch             " link claunchp} - Startet einen neuen Prozeß

@endnode
@node mextebef "Interne Extension-Befehle"
Interne Extension-Befehle/Befehle für Profis

Wieder Befehle und Funktionen für Profis. Bevor Sie diese verwenden,
denken Sie drüber nach was Sie tun, dann nochmal und ein drittes Mal, und
dann speichern Sie Ihr Programm ab, bevor Sie es starten.

Befehle:

@{" Extdefault         " link cextdefa} - Ruft die Default-Routine einer Extension auf
@{" Extremove          " link cextremo} - Entfernt eine Extension aus dem Speicher
@{" Extreinit          " link cextrein} - Versucht, eine Extension wieder einzubinden

Funktionen:

@{" =Amos Task         " link famostsk} - Gibt die Adresse der AMOS Task-Struktur aus

@{" =Amcaf Version$    " link famcafvs} - Gibt einen Versionsstring zurück
@{" =Amcaf Base        " link famcafba} - Ermittelt den internen Amcaf-Datenbereich
@{" =Amcaf Length      " link famcafle} - Gibt die Länge des Datenbereichs aus

@endnode
@node mfourbef "Vier-Spieler Adapter Support"
Vier-Spieler Adapter

Wenn Sie Spiele schreiben, so macht sich das immer gut, wenn mehrere
Spieler gleichzeitig spielen können. Sind es vier oder mehr, dann sollten
Sie über eine Implementation des 4-Player-Adapters nachdenken, denn
meistens spielt es sich angenehmer und besser über Joystick als mit
Tastatur.

@{" Wie baue ich einen 4-Player-Adapter? " link dfourplayer}

Funktionen:

@{" =Pjoy              " link ffourjoy} - Richtungen eines Joysticks ermitteln
@{" =Pjup              " link ffourjup} - Joystick nach oben abfragen
@{" =Pjdown            " link ffourjdo} - Joystick nach unten abfragen
@{" =Pjleft            " link ffourjle} - Joystick nach links abfragen
@{" =Pjright           " link ffourjri} - Joystick nach rechts abfragen
@{" =Pfire             " link ffourfir} - Überprüft den Feuerknopf

@endnode
@node mgfx_bef "Grafik- und Effektbefehle"
Grafik- und Effektbefehle

Die AMCAF-Extension beinhaltet viele Grafikbefehle, die sicher gut in
Spielen oder Demos verwendet werden können. Jedoch müssen Sie bitte be-
achten, daß die meisten Befehle die Parameter NICHT überprüfen! Dadurch
ergibt sich ein Geschwindigkeitsvorteil, den man nicht unbeachtet lassen
sollte. Speichern Sie Ihre Programme regelmäßig ab, denn ein kleiner
Tippfehler kann schon den Absturz bedeuten.

@{" Graphische Grundbefehle   " link mgfxgrun} > Neue Grafikbefehle
@{" Graphische Effektbefehle  " link mgfxeffe} > Effekte
@{" Zeichensatz-Befehle       " link mgfxfont} > Anweisungen für Zeichensätze
@{" Farbanweisungen           " link mgfxcolo} > Befehle und Funktionen mit Farbwerten
@{" Blitter-Befehle           " link mgfxblit} > Direkte Ansteuerung des Blitters
@{" Andere Befehle            " link mgfxmisc} > Diverse Funktionen und Befehle
@{" Befehle für System-Hacker " link mgfxprof} > Für Profis.

@endnode
@node mgfxblit "Befehle für die direkte Ansteuerung des Blitters"
Blitter Befehle

AMCAF ermöglicht es, den @{" Blitter " link dblitter} ganz gezielt anzusteuern und einzelne
@{" Bitplanes " link dbitplane} zu löschen, zu füllen, zu kopieren und modifizieren.

Befehle:

@{" Blitter Copy       " link cbltcopy} - Kopieren und Verknüpfen einer Bitplane
@{" Blitter Copy Limit " link cbltcplm} - Einstellen des Bereichs für Blitter Copy
@{" Blitter Fill       " link cbltfill} - Füllen von Flächen mit dem Blitter
@{" Blitter Clear      " link cbltcler} - Löschen einer Bitplane mit dem Blitter
@{" Blitter Wait       " link cbltwait} - Warten auf das Ende der Blittertätigkeit
@{" Turbo Draw         " link cturdraw} - Schneller Draw-Ersatz
@{" Bcircle            " link cbcircle} - Zeichnen eines Kreises zum Füllen mit dem Blitter

Funktionen:

@{" =Blitter Busy      " link fbltbusy} - Ermittelt, ob der Blitter gerade arbeitet

@endnode
@node mgfxcolo "Hilfsfunktionen für die Farbverwaltung"
Hilfsfunktionen für die Farbverwaltung

Farbspielereien waren oft mit komplizierten Formeln verbunden. Doch jetzt
gibt es eine Reihe hilfreicher Befehle - natürlich nur in AMCAF.

Befehle:

@{" Rain Fade          " link crainfad} - Blendet einen Regenbogen aus oder um
@{" Set Rain Colour    " link csetrain} - Ändert die eingestellte Farbe eines Regenbogens

@{" Pal Spread         " link cpspread} - Erzeugt einen Farbverlauf zwischen zwei Farben
@{" Pal Get Screen     " link cpgetscr} - Speichert die Palette eines Schirms ab
@{" Pal Set Screen     " link cpsetscr} - Setzt die Palette eines Bildschirms
@{" Pal Set            " link cpsetcol} - Setzt einen Eintrag der gespeicherten Palette

@{" Amcaf Aga Notation " link camcafaa} - Ein- und Abschaltung des @{" AGA-Amiga " link dagaamiga} Farbformats

Funktionen:

@{" =Pal Get           " link fpgetcol} - Liest einen gespeicherten Paletteneintrag aus

@{" =Red Val           " link fcredval} - Ermittelt den Rotanteil einer Farbe
@{" =Green Val         " link fcgreval} - Ermittelt den Grünanteil einer Farbe
@{" =Blue Val          " link fcbluval} - Ermittelt den Blauanteil einer Farbe
@{" =Glue Colour       " link fgluecol} - Berechnet die Farbe unter Angabe der Farbanteile
@{" =Mix Colour        " link fmixcolo} - Mischt zwei Farben

@{" =Best Pen          " link fbestpen} - Berechnet die am nähesten liegende Farbe 
@{" =Ham Point         " link fhampoin} - Beschafft sich den Farbwert eines HAM-Pixels
@{" =Ham Colour        " link fhamcolo} - Berechnet die Farbe im @{" HAM-Modus " link dham}
@{" =Ham Best          " link fhambest} - Berechnet die beste Farbe im @{" HAM-Modus " link dham}

@{" =Rgb To Rrggbb     " link frgbtaga} - Rechnet eine Farbe ins neue @{" AGA-Farbformat " link dagaamiga} um
@{" =Rrggbb To Rgb     " link fagatrgb} - Rechnet eine @{" AGA-Farbe " link dagaamiga} ins alte Format zurück

@endnode
@node mgfxeffe "Graphische Effektbefehle"
Graphische Effektbefehle

Ein großer Teil der AMCAF-Extension beschäftigt sich mit graphischen
Effekten. Ob Sie nur mal ein paar Sterne haben oder einfach Schriftsätze
sprengen wollen oder nur Colorcyclen, mit AMCAF wird (fast)
alles möglich.

@{" Mask Copy          " link cmskcopy} - Screen Copy mit Schablone
@remark {" Ptile              " link mprotile} > Ptile Befehlsgruppe
@{" Pix Shift          " link mpixshif} > Pix Shift Befehlsgruppe
@{" Shade Bobs         " link mshadbob} > Shade Bobs Befehlsgruppe
@{" Td Stars           " link mtdstars} > Td Stars Befehlsgruppe
@{" Splinters          " link msplinte} > Splinters Befehlsgruppe

@endnode
@node mgfxfont "Font-Befehle"
Zeichensatz-Befehle

AMCAF bietet Ihnen machtvolle Anweisung zur Verwaltung von Zeichensätzen.
Der Change Font-Befehl z.B erlaubt es, einen Font ohne den Umweg über
Get Disk Fonts etc. einzustellen und reduziert damit die Diskettenzu-
griffszeit erheblich. Festplattenbesitzer werden besonders gefallen an
diesen Befehlen finden. Mit dieser Extension erhalten Sie die noch nie
dagewesene Möglichkeit, einen beliebigen Zeichensatz in einer Speicherbank
zu konservieren und werden dadurch total unabhängig von dem Fonts-Ver-
zeichnis und der diskfont.library.

Befehle:

@{" Change Font        " link cchafont} - Laden eines Zeichensatzes direkt von der Diskette
@{" Make Bank Font     " link cmkbkfnt} - Erstellen einer Font-Bank
@{" Change Bank Font   " link cchbkfnt} - Laden eines Zeichensatzes aus einer Bank
@{" Change Print Font  " link cchprfnt} - Ändern des Fonts, mit dem Print arbeitet

Funktionen:

@{" =Font Style        " link ffontsty} - Attribute eines Fonts ermitteln

@endnode
@node mgfxgrun "Graphische Grundbefehle"
Graphische Grundbefehle

AMCAF erweitert den Grundbefehlssatz von AMOS um einige wichtige Befehle.

Befehle:

@{" Bzoom              " link cblkzoom} - Vergrößert einen Bereich
@{" Ham Fade Out       " link chamfade} - Blendet ein HAM-Bild aus
@{" Convert Grey       " link ccongrey} - Graustufenbild erzeugen
@{" Turbo Plot         " link cturplot} - Schneller Plot-Ersatz
@{" Turbo Draw         " link cturdraw} - Schneller Draw-Ersatz
@{" Fcircle            " link cfcircle} - Ausgefüllter Kreis
@{" Fellipse           " link cfellips} - Ausgefüllte Ellipse
@{" Raster Wait        " link craswait} - Wartet auf den Rasterstrahl

Funktionen:

@{" =Turbo Point       " link fturpoin} - Schneller Point-Ersatz
@{" =X Raster          " link fxraster} - X-Position des Rasterstrahls
@{" =Y Raster          " link fyraster} - Y-Position des Rasterstrahls

@endnode
@node mgfxmisc "Diverse weitere Grafikbefehle"
Weitere Befehle

@{" Set Ntsc           " link csetntsc} - Wechselt in den 60Hz-Modus
@{" Set Pal            " link cset_pal} - Wechselt zurück in den 50Hz-Modus
@{" Set Sprite Priority" link csetspri} - Ändert die Sprite Priorität im Dual Playfield

@endnode
@node mgfxprof "Funktionen für Profis"
Funktionen für Profis

Hier noch ein paar Funktionen für Assembler/C Freaks.

@{" =Scrn Rastport     " link fscrrast} - Gibt den Rastport eines Screens zurück
@{" =Scrn Bitmap       " link fscrbitm} - Gibt die Bitmap eines Screens zurück
@{" =Scrn Layer        " link fscrlaye} - Gibt den Layer zurück
@{" =Scrn Layerinfo    " link fscrlayi} - Gibt das Layerinfo zurück
@{" =Scrn Region       " link fscrregi} - Gibt die Region eines Screens zurück

@endnode
@node mjoymbef "4-Spieler Adapter, zweite Maus, Joypad"
Gameportperipherie-Unterstützung

AMCAF macht es möglich einen zusätzlich angeschlossenen 4-Player Adapter
sowie eine zweite Maus im Joystick Port 1 abzufragen. Weiterhin kann der
zweite Feuerknopf eines Joysticks oder, falls die Lowlevel.library
vorhanden ist, sogar die anderen 5 Knöpfe eines Gamepads überprüft werden.

@{" 4-Player Adapter   " link mfourbef} > Unterstützung des Vier-Spieler Adapters
@{" Zweite Maus        " link msmoubef} > Macht es möglich, eine zweite Maus zu benutzen

@{" =Xfire             " link fextfire} - Feuerknöpfe eines Joypads auslesen

@endnode
@node mmiscbef "Sonstige andere Befehle und Funktionen"
Sonstige andere Befehle und Funktionen

Tja, bleiben noch die Befehle und Funktionen, die sich nicht so ganz in
eine Gruppe einteilen lassen.

Befehle:

@{" Exchange Bob       " link cexchbob} - Tauscht zwei Bilder der Spritebank aus
@{" Exchange Icon      " link cexchico} - Tauscht zwei Bilder der Iconbank aus
@{" Audio Lock         " link caudlock} - Reserviert das Audio Device
@{" Audio Free         " link caudfree} - Gibt das Audio Device wieder frei
@{" Open Workbench     " link copenwor} - Öffnet die Workbench wieder
@{" Flush Libs         " link cflushli} - Gibt den so viel wie möglich Speicher frei
@{" Write Cli          " link cwritcli} - Schreibt ins aktuelle CLI-Fenster
@{" Reset Computer     " link crescomp} - Macht einen Reset
@{" Nop                " link cnoopera} - Keine Wirkung

Funktionen:

@{" =Aga Detect        " link fagadtct} - Überprüft, ob der Computer das AGA Chipset hat
@{" =Scanstr$          " link fscanstr} - Gibt den Namen einer Taste aus
@{" =Command Name$     " link fcomname} - Ermittelt den Programmnamen
@{" =Tool Types$       " link ftooltyp} - Liest die Tool-Types eines Piktogramms
@{" =Amos Cli          " link famoscli} - Gibt die Nummer des CLI-Prozesses zurück
@{" =Speek             " link fsgnpeek} - Lesen eines @{" Bytes " link dbyte} mit Vorzeichen
@{" =Sdeek             " link fsgndeek} - Lesen eines @{" Worts " link dword} mit Vorzeichen
@{" =Cpu               " link fcpu    } - Gibt die Nummer des Prozessors zurück
@{" =Fpu               " link ffpu    } - Ermittelt die Nummer eines Coprozessors
@{" =Nfn               " link fnofunct} - Keine Wirkung
@{" =Cop Pos           " link fcop_pos} - Gibt die aktuelle Adresse der Copperliste zurück
 
@endnode
@node mpixshif "Pix Shift Befehlsgruppe"
Pix Shift Befehlsgruppe

Mit diesen Befehlen lassen sich die Farbwerte der Pixel rechteckiger
Bereiche um eins erhöhen oder erniedrigen. Diese Befehle wirken pixelweise
und lassen daher eine Farbbegrenzung zu, sind aber dafür langsamer als
@{" Shade Bobs " link mshadbob}.

@{" Pix Shift Up       " link cpixshup} - Farbwerte erhöhen (@{" cyclic " link dcyclic})
@{" Pix Shift Down     " link cpixshdo} - Farbwerte erniedrigen (@{" cyclic " link dcyclic})
@{" Pix Brighten       " link cpixbrig} - Farbwerte erhöhen (nicht @{" cyclic " link dcyclic})
@{" Pix Darken         " link cpixdark} - Farbwerte erniedrigen (nicht @{" cyclic " link dcyclic})
@{" Make Pix Mask      " link cpixmask} - Berechnet eine Schablone für das Shiften

@{" Shade Pix          " link cshadpix} - Zeichnen eines Shade-Pixels

@endnode
@node mprotbef "Befehle zum Abspielen von Protracker Musikstücken"
Befehle für Protracker Musiken

Da die AMOS Tracker Befehle wirklich nicht gut sind, und jede Menge Bugs
enthalten, gibt es auch in der AMCAF-Extension einen Ersatz.

In der neuen Version 1.1 kamen neue Befehle zur Wiedergabe von Sound-
effekten während des Abspielens von Protracker Musik hinzu. Die AMOS
Music-Extension wird damit fast vollständig ersetzt.

Hier nochmal schnell alle Vorteile aufgezählt:
- CIA Timing oder VBL Timing.
- Lautstärkeregelung.
- Kanal-Auswahl.
- Vu Meter.
- Signalübermittlung vom Musikstück.
- Support aller Protracker-Effekt-Befehle.
- Wiedergabe von Soundeffekten beim gleichzeitigen Abspielen der Musik.

Befehle:

@{" Pt Play            " link cpt_play} - Spielt ein Module ab
@{" Pt Stop            " link cpt_stop} - Stoppt das aktuelle Musikstück
@{" Pt Continue        " link cpt_cont} - Startet eine zuvor gestoppte Musik wieder
@{" Pt Volume          " link cptvolum} - Einstellen der Lautstärke
@{" Pt Voice           " link cptvoice} - Auswahl der abzuspielenden Kanäle
@{" Pt Cia Speed       " link cptspeed} - Einstellen der Wiedergabegeschwindigkeit

@{" Pt Raw Play        " link cptrawpl} - Spielt einen Speicherbereich ab
@{" Pt Bank            " link cpt_bank} - Setzt die Protrackerbank für Pt Instr Play
@{" Pt Instr Play      " link cptinspl} - Spielt ein Instrument eines Musikstücks
@{" Pt Sam Bank        " link cptsambk} - Stellt die Bank für AMOS-Samples ein
@{" Pt Sam Play        " link cptsampl} - Spielt ein Sample aus einer AMOS-Bank
@{" Pt Sam Stop        " link cptsamst} - Stoppt die Soundausgabe bestimmter Kanäle
@{" Pt Sam Volume      " link cptsamvo} - Setzt die Lautstärke eines Soundeffekts
@{" Pt Sam Freq        " link cptsamfr} - Ändert die Wiedergabefrequenz eines Sounds
 
Funktionen:

@{" =Pt Vu             " link fptvumet} - Abfragen des Vumeters
@{" =Pt Signal         " link fptsigna} - Abfragen nach Signalen vom Musikstück

@{" =Pt Cpattern       " link fptcpatt} - Holt die aktuelle Songposition
@{" =Pt Cpos           " link fptcposi} - Gibt die aktuelle Patternzeile zurück
@{" =Pt Cinstr         " link fptcinst} - Gibt zurück, welches Instrument gerade spielt
@{" =Pt Cnote          " link fptcnote} - Holt die Frequenz des aktuellen Instruments
 
@{" =Pt Instr Address  " link fptinadr} - Gibt die Adresse eines Instruments zurück
@{" =Pt Instr Length   " link fptinlen} - Gibt die Länge eines Instruments zurück
@{" =Pt Data Base      " link fptdatab} - Gibt die Adresse der PT-Variablen zurück

@endnode
@node mprotile "Processor Tile Befehlsgruppe"
Processor Tile (Ptile) Befehlsgruppe

PTiles sind ein kleiner Ersatz für @{" TOME " link dtome} 16x16 Kacheln. Anstatt den
@{" Blitter " link dblitter} zu benutzen, wird der Prozessor verwendet, der bei solch kleinen
Objekten auch schon bei MC68000 deutlich schneller ist. Noch deutlicher
sieht man es mit einer Turbokarte und @{" Fast-Ram " link dfastram}.

Bis jetzt sind es nur 2 Befehle, das wird sich sicher mit neuen Versionen
ändern.

Vorteile:
- Schneller Aufbau.
- Kein @{" Chip-Ram " link dchipram} benötigt.

Nachteile:
- Nur 16x16 große Kacheln.
- Nur in Abständen von 16x16 Pixeln setzbar.
- Anderes Bankformat (keine @{" Iconbanks " link diconbanks})

Befehle:

@{" Ptile Bank         " link cptilbnk} - Setzen einer Ptile Bank
@{" Paste Ptile        " link cpasptil} - Plotten eines Ptiles

@endnode
@node mshadbob "Shade Bobs Befehlsgruppe"
Shade Bobs Befehlsgruppe

Shade Bobs sind eigentlich keine "richtigen" Bobs, die Bezeichnung ist
aber "in der Szene" für diese Effekte üblich. Shade Bobs erhöhen oder
erniedrigen die Farbwerte, über denen sie stehen. Das ähnelt dem Color-
cycling, jedoch werden hier wirklich nur die Pixel in einem Bereich erhöht
und nicht die Palettenwerte! Bei Shade Bobs kann man als Farbbegrenzung
nur angeben, wieviele Bitplanes modifiziert werden sollen, die dann immer
@{" gecycelt " link dcyclic} werden. Shade Bobs dürfen außerdem den Bildschirm-
rand verlassen.

@{" Shade Bob Mask     " link cshbmask} - Festlegen der zu benutzenden Grafik
@{" Shade Bob Planes   " link cshbplan} - Einstellen der zu benutzenden Bitplanes
@{" Shade Bob Up       " link cshbshup} - Ein Shade Bob setzen, welches die Farben erhöht
@{" Shade Bob Down     " link cshbshdo} - Ein Shade Bob setzen, welches die Farben erniedrigt

@endnode
@node msmoubef "Befehle für die Verwendung einer zweiten Maus"
Befehle für eine Maus in Port 1

AMCAF unterstützt auf Anfrage diverser User nun auch das Abfragen einer in
Joystick Port 1 eingesteckten Maus. Dadurch kann man endlich Spiele
realisieren, die zwei Mäuse im Zweispieler-Modus benötigen.

Befehle:

@{" Limit Smouse       " link climsmou} - Legt den Mausbereich fest
@{" Smouse Speed       " link csmouspd} - Setzt die Geschwindigkeit für die Maus
@{" Smouse X           " link csmousex} - Setzt die X-Koordinate der Maus
@{" Smouse Y           " link csmousey} - Setzt die Y-Koordinate 

Funktionen:

@{" =X Smouse          " link fxsmouse} - Liest die X-Koordinate der Maus
@{" =Y Smouse          " link fysmouse} - Liest die Y-Koordinate 
@{" =Smouse Key        " link fsmousek} - Testet die Mausknöpfe

@endnode
@node msplinte "Splinters Befehlsgruppe"
Splinters Befehlsgruppe

Splinters sind ähnlich wie Td Stars, nur das Splinters den Hintergrund
nicht zerstören, die Farbe des Pixels annehmen, den sie weggesprengt haben
und eine Koordinatenliste benötigen. Leider benötigt eine Koordinate vier
Bytes, d.h. ein 64x64 großes Koordinatenfeld frißt schon 16KB.

Befehle:

@{" Coords Bank        " link ccrdbank} - Bank für Koordinatenspeicherung setzen
@{" Coords Read        " link ccrdread} - Einlesen der Koordinaten in die Bank
@{" Splinters Bank     " link csplbank} - Speicher für die Splitter reservieren
@{" Splinters Colour   " link csplcolo} - Einstellen der zu benutzenden Bitplanes
@{" Splinters Limit    " link cspllimi} - Setzen der Splittergrenzen
@{" Splinters Max      " link csplimax} - Festlegen der maximal neu auftretenden Splitter
@{" Splinters Fuel     " link csplfuel} - Setzen der Reichweite eines Splitters
@{" Splinters Gravity  " link csplgrav} - Einstellen der Gravitation
@{" Splinters Init     " link csplinit} - Initialisieren der Splitter
@{" Splinters Do       " link csplindo} - Komplettes Bewegen und Zeichnen
@{" Splinters Del      " link csplidel} - Löschen der Splitter
@{" Splinters Move     " link csplmove} - Bewegen der Splitter
@{" Splinters Draw     " link cspldraw} - Zeichnen der Splitter
@{" Splinters Back     " link csplback} - Holen des Hintergrunds

Funktionen:

@{" =Count Pixels      " link fcounpix} - Abzählen der Pixel in einem Bereich
@{" =Splinters Active  " link fspliact} - Gibt zurück, wieviele Splitter sich noch bewegen

@endnode
@node mstribef "Sonstige String und Integer unterstützende Befehle"
Sonstige String und Integer unterstützende Befehle

Funktionen:
                
@{" =Binexp            " link fbinexpo} - Exponentialfunktion von 2
@{" =Binlog            " link fbinloga} - Logarithmusfunktion der Basis 2
@{" =Lsl               " link flogleft} - Schnelle Multiplikation mit einer Potenz von 2
@{" =Lsr               " link flogrigh} - Schnelle Division mit einer Potenz von 2
@{" =Wordswap          " link fwrdswap} - Tausch der oberen und unteren 16-Bits
@{" =Qarc              " link fqarc   } - Schnelle Winkel-Funktion
@{" =Qsin              " link fqsine  } - Schnelle Sinus-Funktion
@{" =Qcos              " link fqcosine} - Schnelle Cosinus-Funktion
@{" =Qrnd              " link fqrandom} - Schneller Ersatz für Rnd
@{" =Qsqr              " link fqsquare} - Schnelle Wurzelfunktion
@{" =Asc.w             " link fascword} - Konvertieren eines @{" Wort-Strings " link dword} in eine Zahl
@{" =Asc.l             " link fasclong} - Konvertieren eines @{" Long-Strings " link dlong} in eine Zahl
@{" =Vclip             " link fvalclip} - Grenzt einen Wert in einen gegebenen Bereich ein
@{" =Vin               " link fvaluein} - Testet, ob ein Wert innerhalb eines Bereichs ist
@{" =Vmod              " link fvalmodu} - Führt eine Modulo-Operation auf einen Wert aus
@{" =Even              " link feven   } - Gibt zurück, ob ein Wert gerade ist
@{" =Odd               " link fodd    } - Gibt zurück, ob ein Wert ungerade ist

@{" =Pattern Match     " link fpatmatc} - Vergleicht einen String mit einem Muster
@{" =Chr.w$            " link fchrword} - Erzeugen eines @{" Wort-Strings " link dword}
@{" =Chr.l$            " link fchrlong} - Erzeugen eines @{" Long-Strings " link dlong}
@{" =Lzstr$            " link flzstrin} - Gibt eine Zahl rechtsbündig mit führenden 0-en aus
@{" =Lsstr$            " link flsstrin} - Gibt eine Zahl rechtsbündig aus
@{" =Insstr$           " link finsstrg} - Fügt einen String in einen anderen ein
@{" =Cutstr$           " link fcutstrg} - Schneidet einen Teil eines Strings ab
@{" =Replacestr$       " link frplcstr} - Ersetzt einen String durch einen anderen
@{" =Itemstr$          " link fitemstr} - Gibt ein 'Item' aus einem String zurück
 
@endnode
@node mtdstars "Td Stars Befehlsgruppe"
Td Stars Befehlsgruppe

Mit diesen Befehlen lassen sich nicht nur 3D-Sterneffekte realisieren, die
Befehle sind relativ vielseitig.

@{" Td Stars Bank      " link ctdstbnk} - Reservieren von Speicher für Sterne
@{" Td Stars Planes    " link ctdstpla} - Auswahl der von den Sternen benutzen Bitplanes
@{" Td Stars Limit     " link ctdstlim} - Setzen der Sterngrenzen
@{" Td Stars Origin    " link ctdstorg} - Setzen des Feldmittelpunkts
@{" Td Stars Gravity   " link ctdstgra} - Einstellen der Gravitation
@{" Td Stars Accelerate" link ctdstacc} - An- und Abstellen der Beschleunigung
@{" Td Stars Init      " link ctdstini} - Initialisieren der Sterne
@{" Td Stars Do        " link ctdstado} - Komplettes Bewegen und Zeichen
@{" Td Stars Del       " link ctdstdel} - Löschen der Sterne vom Bildschirm
@{" Td Stars Move      " link ctdstmov} - Bewegen der Sterne
@{" Td Stars Draw      " link ctdstdra} - Zeichnen der Sterne

@endnode
@node mvecrbef "Vektorrotations-Befehle"
Befehle zur Rotation von Punkten im dreidimensionalen Raum.

Zu allererst: DAS SOLL KEIN ERSATZ FÜR DIE 3D-EXTENSION SEIN...
jedenfalls noch nicht. Man kann damit aber trotzdem ohne weiteres
Vektorgrafik machen, wie die Beispielprogramme demonstrieren.

Befehle:

@{" Vec Rot Pos        " link cvecrpos} - Einstellen der Kameraposition
@{" Vec Rot Angles     " link cvecrang} - Einstellen der Blickwinkel
@{" Vec Rot Precalc    " link cvecrpre} - Errechnen der Matrix

Funktionen:

@{" =Vec Rot X         " link fvecrotx} - Rechnet den 2D X-Wert aus
@{" =Vec Rot Y         " link fvecroty} - Berechnet den 2D Y-Wert
@{" =Vec Rot Z         " link fvecrotz} - Gibt die Z-Koordinate aus

@endnode
@node mzedabef "Zeit- und Datumsfunktionen"
Zeit und Datumsfunktionen

Diese Funktionen dienen zum Konvertieren der Disk-Objekt- und der System-
zeit.

Funktionen:

@{" =Current Time      " link fcurtime} - Ermittelt die aktuelle Uhrzeit
@{" =Ct Time$          " link fcttimes} - Gibt einen vollständigen Zeitstring zurück
@{" =Ct Hour           " link fct_hour} - Extrahiert die Stunde aus einer Uhrzeit
@{" =Ct Minute         " link fctminut} - Ermittelt die Minute einer Uhrzeit
@{" =Ct Second         " link fctsecon} - Gibt die Sekunde einer Uhrzeit zurück
@{" =Ct Tick           " link fct_tick} - Extrahiert die Fünfzigstel aus einer Uhrzeit
@{" =Ct String         " link fct_strg} - Rechnet einen Zeit-String in einen Zeit-Wert um
 
@{" =Current Date      " link fcurdate} - Ermittelt das aktuelle Datum
@{" =Cd Date$          " link fcddates} - Gibt einen vollständigen Datumsstring zurück
@{" =Cd Year           " link fcd_year} - Gibt das Jahr eines Datums aus
@{" =Cd Month          " link fcdmonth} - Extrahiert den Monat eines Datums
@{" =Cd Day            " link fcd__day} - Gibt den Monatstag eines Datums zurück
@{" =Cd Weekday        " link fcdweekd} - Ermittelt den Wochentag eines Datums
@{" =Cd String         " link fcd_strg} - Rechnet einen Datums-String in ein Datum um
 
@endnode
@node szusindex "Übersicht über alle zusätzlichen Informationen"
 @{" Allgemeines zu Banks  " link dbanks}  @{" Icon und Sprite-Banks " link diconbanks}  @{" Permanente Banks      " link dpermanent}
 @{" Temporäre Banks       " link dtemporaer}  @{" Chip-Ram              " link dchipram}  @{" Fast-Ram              " link dfastram}
 @{" Ranger-Ram            " link drangram}  @{" Byte                  " link dbyte}  @{" Wort                  " link dword}
 @{" Langwort              " link dlong}  @{" Cyclic                " link dcyclic}  @{" Aga-Amigas            " link dagaamiga}
 @{" HAM-Modus             " link dham}  @{" Disk-Objekt           " link dobject}  @{" Blitter               " link dblitter}
 @{" Blitter-Miniterme     " link dblitterminiterms}  @{" Schutzbits            " link dprotflags}  @{" TOME                  " link dtome}
 @{" 4-Player Adapter      " link dfourplayer}  @{" AMCAF-Struktur        " link dstructur}  @{" Bitplanes             " link dbitplane}

@endnode
@node dagaamiga "Informationen zur neuen Produktreihe A1200/A4000/CD³²"
Informationen zu AGA-Amigas

Die neuen Amigas A1200, A4000 und CD³² verfügen über das AGA-Chipset. Dies
ermöglicht es, nicht nur bis zu 6 @{" Bitplanes " link dbitplane}, sondern bis 8 Bitplanes in
fast allen Auflösungen zu benutzen. Außerdem verwenden diese Amigas zu den
normalen 12-Bit Farbwerten ($0RGB), zusätzlich noch 12 weitere Bits, sodaß
ein 24-Bit Wert entsteht ($00RRGGBB). Auch wenn AMOS Pro in der Version
V2.0 noch keine AGA-Amigas unterstützt, so enthält AMCAF trotzdem Befehle
zur zukünftigen Implementation.

Die wesentlichen Vorteile eines AGA-Amigas aufgezählt:

- Lokal konfigurierbar, die Programme passen sich der Landessprache an
- Kickstart 3.0 mit verbesserten Grafikroutinen
- Viele, neue, hohe Auflösungen
- bis zu 256 Farben in fast allen Auflösungen
- neuer @{" HAM8-Modus " link dham} für über 262.000 Farben
- 16-farbige Dual Playfields möglich
- MC68020+ für Rechenpower
- 2 MB @{" Chip-Ram " link dchipram}

Meine Empfehlung: Wenn Sie noch einen alten Amiga haben, dann sollten Sie
mal über den Kauf eines AGA-Amigas nachdenken, es lohnt sich!

@endnode
@node dbanks "Bank"
Ein paar Informationen zu Banks

AMOS Banks bilden einen zusammenhängenden Block des Speichers dar (es gibt
zwei @{" Ausnahmen " link diconbanks}). In diesen Speicherbereichen können eine Vielzahl von
Daten gespeichert werden. AMOS verwendet sie meistens für komprimierte
Grafiken, Geräusche, Musik, Amalprogramme, Menüs, Resourcen und sonstige
Daten.

Es gibt im wesentlichen vier verschiedene Typen von Banks:
- Banks, die im @{" Chip-Ram " link dchipram} stehen und @{" permanent " link dpermanent} sind,
- Banks, die im @{" Fast-Ram " link dfastram} stehen und @{" permanent " link dpermanent} sind,
- Banks, die im @{" Chip-Ram " link dchipram} stehen und @{" temporär  " link dtemporaer} sind,
- Banks, die im @{" Fast-Ram " link dfastram} stehen und @{" temporär  " link dtemporaer} sind.

@endnode
@node dbitplane "Bitplanes und was man mit ihnen machen kann"
Bitplanes

Es folgt nun ein kleines Tutorial, indem die Bitplanes und ihre Funktions-
weise aufgezeigt werden.

1. Was ist eine Bitplane?

   Beim Amiga wird das Bild über sog. Bitplanes aufgebaut. Dies sind
   lineare Speicherbereiche, bei dem jeder Bildpunkt als ein Bit darge-
   stellt wird.
   Mit einer Bitplane lassen sich nun also 2 Farben anzeigen (Bit gesetzt
   oder Bit gelöscht). Legt man nun mehrere Bitplanes übereinander, so
   erhält man für n-Bitplanes 2^n Farben.

   Beispiel:

   Wir haben einen 16 Farben Screen. Dieser besitzt also 4 Bitplanes.
   Normalerweise werden die Bitplanes von 0 bis n-1 durchgezählt...

   Binär 0 1 0 1 = Dezimal 5
         | | | |    .---v---v---v---v--------------------
         | | | `----+ 1 |   |   |   | Bitplane 0
         | | |      |--v^--v^--v^--v^--v-------------------
         | | `------+--+ 0 |   |   |   | Bitplane 1
         | |        |  |--v^--v^--v^--v^--v------------------
         | `--------+--+--+ 1 |   |   |   | Bitplane 2
         |          |  |  |--v^--v^--v^--v^--v-----------------
         `----------+--+--+--+ 0 |   |   |   | Bitplane 3
                    |  |  |  |---^---^---^---'
                    |  |  |  |
                    |  |  |
                    |  |
                    |

   Sie müssen sich die Bitplanes 'übereinander liegend' vorstellen. Der
   Farbindex 5 wird also so in den Bitplanes dargestellt. Welche Farbe
   der Punkt auf dem Bildschirm letztendlich hat, wird ja mit der Farb-
   palette festgelegt.

2. Überlappung und Transparenz.

   Stellen Sie sich vor, Sie zeichnen eine Figur A nur in Bitplane 0 und
   eine Figur B in Bitplane 1. Es ergibt sich folgendes:

   Die Fläche, auf der sich keine der beiden Figuren befinden, hat die
   Farbe 0 (beide Bitplanes sind ja gelöscht: %00). Dort, wo sich nur
   Figur A befindet, Farbe 2^0=1 (Bit 0 gesetzt, Bit 1 gelöscht: %01).
   Figur B alleine setzt das Bit in Bitplane 1 und damit Farbe
   2^1=2 (=%10). Überlappen sich beide Figuren, dann sind ja die Bits in
   beiden Bitplanes gesetzt, es ergibt sich als resultierende Farbe
   2^0+2^1=3 (=%11).

   Nun können wir die Palette festlegen. Hier ein Beispiel:
   Palette 0,$F00,$F0,$FF0

   Der Hintergrund ist schwarz ($000), Figur A ist rot ($F00) und Figur B
   ist grün ($0F0), bei Überlappung entsteht die Farbe gelb ($FF0).

   Mit solchen einfachen Überlegungen lassen sich gute Effekte erzielen.

   Versuchen Sie sich zu überlegen, wie sich die Figuren bei folgenden
   Beispielen verhalten:

   1. Palette 0,$FFF,$888,$FFF
   2. Palette 0,0,0,$FFF

   Die Auflösung finden Sie weiter unten.

3. Glenz und Fade

   Von Glenz-Effekten spricht man dann, wenn z.B ein Würfel
   'durchsichtig', Gläsern oder 'elektrisch' erscheint. Meist wird dies
   für Vektoreffekte benutzt. Man unterscheidet zwei wesentliche Typen von
   Glenz-Vektoren:

 a) Wire-Frame Objekte:

   Bei diesen Drahtgitter-Objekten werden einfach die Linien immer in
   einer anderen Bitplane gezeichnet und die alten zwei oder drei zuvor
   gezeichneten Objekte überlappen sich dann. Durch eine geschickte Wahl
   der Palette (additive Farbwerte pro Bitplane) erscheinen dann die
   Punkte heller, bei denen sich die Linien überlappen.

   Beispiel für eine additive Farbpalette (8-farbiger Bildschirm):

   DUNKEL=$333 : HELLER=$666 : HELLST=$FFF

   '    %000   %001   %010   %011   %100   %101   %110   %111
   Palette 0,DUNKEL,DUNKEL,HELLER,DUNKEL,HELLER,HELLER,HELLST

   Wie Sie hier sehen können, werden einfach die Anzahl der gesetzten Bits
   gezählt.

   Durch ständiges Ändern der Farbpalette kann man natürlich auch einen
   'Nachzieh'- oder Fade-Effekt herstellen. Dazu müssen alle Farben mit
   dem Bit der aktuellen Bitplane, in der gerade gezeichnet wird, auf die
   hellste Farbe gestellt, alle Farben mit dem Bit der vorherigen Bit-
   plane, die aber nicht das Bit der aktuellen Bitplane haben, auf eine
   mittlere Farbe gesetzt und die Farbe mit dem Bit der vorvorherigen Bit-
   plane auf eine dunkle Farbe gestellt werden.

 b) Solide Objekte:

   Hierbei werden die Flächen, die vom Betrachter abgewand sind (also
   eigentlich unsichtbar sind) in einer anderen Bitplane gezeichnet, als
   die Flächen, die in Richtung des Betrachters blicken. Durch die
   entsprechende Palette kann dann das Objekt 'transparent' gemacht wer-
   den. Dazu müssen Sie einfach nur die Farben der Bitplanes mischen, in
   denen die verschiedenen Flächen gezeichnet werden.

4. Bitplane-Modi und Besonderheiten.

   Die alten Amigas können bis zu 6 Bitplanes gleichzeitig anzeigen. Das
   sind also maximal 2^6=64 Farben. Es gibt dabei allerdings ein paar
   Besonderheiten:

   a) ExtraHalfBright (EHB). Da bei dem OCS und ECS-Chipset nur
      32-Farbregister existieren, werden die anderen auf die halbe Hellig-
      keit gestellt. Kann man also hübsche Schatten-Effekte erzeugen,
      indem einfach in die 6te Bitplane schreibt. Allerdings können EHB-
      Grafiken nicht perfekt ausgeblendet werden.
   b) Hold And Modify (HAM). Quasi eine Methode, um 6-Bitplanes hardware-
      mäßig auf 12-Bitplanes zu dekomprimieren. Dazu werden die Farben von
      16 bis 63 benutzt um jeweils entweder den Rot-, Grün- oder Blau-
      anteil der vorherigen Farbe zu erreichen. Gut für statische Bilder
      oder vorberechnete Animationen, jedoch nicht für Spiele und berech-
      nete Grafik geeignet.
      Die einzige sinnvolle Methode bewegte Grafiken auf einem HAM-Screen
      anzuzeigen, beruht auf der Nutzung von Sprites.
      Siehe auch @{" Kurze Erklärung zu HAM " link dham}.
   c) Dual Playfield. Der Amiga kann die geraden Bitplanes (0,2,4) und die
      ungerade (1,3,5) voneinander getrennt darstellen oder besser gesagt,
      er legt sie übereinander, wobei die Farbe 0 des einen Playfields
      transparent ist, sodaß man hinter dieses blicken kann. Durch die
      Aufspaltung ergeben sich maximal 2^3=8 Farben für Dual Playfields.

   Der Amiga besitzt jeweils für die geraden und die ungerade Bitplanes
   viele seperate Kontrollregister. Das kommt daher, weil Dual Playfields
   fast völlig unabhängig voneinander sein müssen.

   - Das Bitplanecontrollregister (BPLCON0) $100.
     Hier wird die Farbtiefe und die Auflösung, sowie die Spezialmodi
     eingestellt. Bitbelegung:

        15      HIRES           Hochauflösenden Modus einschalten
        14-12   BPUx            Anzahl der Bitplanes
        11      HOMOD           @{" HoldAndModify " link dham} einschalten
        10      DBPLF           Dual Playfield einschalten
         9      COLOR           Videoausgang farbig
         8      GAUD            Audio von Genlock einschalten
         7      8BPL            8 Bitplanes (AGA)
         6      SHIRES          Superhires (ECS/AGA)
         3      LPEN            Lightpen aktivieren
         2      LACE            Interlace einschalten.
         1      ERSY            auf externe Synchronisations schalten

   - Das Scrollregister (BPLCON1) $102.
     Über dieses Register kann der Bildschirm bis zu 15 Pixel nach links
     gescrollt werden. Die Bits 0-3 beschreiben den Scrollwert der geraden
     Bitplanes, die Bits 4-7 die der ungeraden.

   - Die Moduloregister (BPL1MOD/BPL2MOD) $108/$10A.
     Hier wird eingestellt, wieviele Bytes am Ende jeder Rasterzeile über-
     sprungen werden sollen. Wird für Playfields benutzt, die größer als
     der sichtbare Bereich sind. Durch das Einstellen negativer Werte
     lassen sich vertikale Zoomer oder Spiegel-Effekte erreichen.

   Wenn Sie ein Register über Set Rain Colour verändern lassen wollen, so
   wird die neue 'Farbe' mit folgender Formel berechnet: (REGADR-$180)/2

   Weiterhin gilt folgendes zu beachten: Bei 5-6 aktivierten Bitplanes in
   Lowres oder 3-4 in Hires kostet das Anzeigen (!) des Bildes Rechenzeit,
   sofern sich das Programm im Chip-Ram befindet bzw. auf Chip-Ram
   zugreifen muß.

5. Wie kann man dieses Effekte nutzbar machen?

   Ganz einfach: Einen Regenbogen definieren, @{" Set Rain Colour " link csetrain} benutzen
   und anstatt der Farbwerte die neuen Werte für das Register mit Rain()
   angeben. Es gibt jedoch eine Einschränkung:
   Es kann wegen der AMOS-Regenbogenbeschränkung immer nur EIN (!)
   Register pro Zeile geändert werden.

   Schauen sie sich die Beispielprogramme ganz genau an. Dort werden
   alle hier genannten Effekte demonstriert.

   Übrigens bekommen Sie die Zeiger auf die einzelnen Bitplanes eines
   Bildschirms über Logbase(screennr) und Phybase(screennr).

Viel Spaß noch!

Auflösung zu den Fragen in 2:

   1. Palette 0,$FFF,$888,$FFF
      Figur A ist weiß und bewegt sich immer 'über' Figur B, die grau ist
      hinweg, da bei Überlappung wieder die Farbe weiß entsteht.

   2. Palette 0,0,0,$FFF
      Figur A und Figur B sind unsichtbar solange sie sich nicht über-
      schneiden. Denn erst bei Überlappung entsteht Farbe 3, die auf
      $FFF (weiß) gestellt ist.

@endnode
@node dblitter "Der Blitter"
Der Blitter

Der Blitter ist ein Coprozessor im Amiga, der hauptsächlich für das Ko-
pieren und Verknüpfen von Daten benutzt wird (daher BLockImageTransferER).
Zusätzlich kann er noch Flächen füllen und Linien ziehen. Dabei arbeitet
er mit unglaublicher Geschwindigkeit (bis zu 16 Millionen Pixel pro
Sekunde). Die Daten des Blitters müssen im @{" Chip-Ram " link dchipram} liegen.
AMOS benutzt ihn für Bobs, Icons, Screen Copy und viele andere Befehle.
Der MC68020 und höher ist beim reinen Kopieren von Daten schneller als der
Blitter.

Der Blitter arbeitet wortweise, deshalb werden die X Koordinaten bei Be-
grenzungen auf das nächste vielfache von 16 gerundet.

Um mit dem Blitter eine Fläche füllen zu können, dürfen die Begrenzungs-
linien nur einen Pixel breit sein. Deswegen gibt es zwei verschiedene
Arten Linien zu zeichnen.

Siehe auch:

@{" Turbo Draw         " link cturdraw}
@{" Bcircle            " link cbcircle}
@{" Blitter Fill       " link cbltfill}
@{" Blitter Copy       " link cbltcopy}
@{" Blitter Clear      " link cbltcler}

@{" Blitter-Miniterme  " link dblitterminiterms}

@endnode
@node dblitterminiterms "Erklärung zu Blitter-Minitermen"
Blitter Miniterme:

Der Blitter kennt 256 verschiedene Verknüpfungen. Diese entstehen in zwei
Stufen:

1. Es werden acht verschiedene boolsche Gleichungen auf die drei Daten-
   Bits angewandt. Jede davon liefert bei einer anderen Kombination aus
   A, B und C eine 1 als Ergebnis.
2. Die acht Ergebnisse obiger Gleichungen werden wahlweise miteinander
   durch ein logisches ODER verknüpft. Das Ergebnis ist das Ziel-Bit D.

Bit    Miniterm    Eingangs-Bits
       ___
 0     ABC         000
       __
 1     ABC         001
       _ _
 2     ABC         010
       _ 
 3     ABC         011
        __
 4     ABC         100
        _
 5     ABC         101
         _
 6     ABC         110

 7     ABC         111

Vorgehensweise:
1. Bei welchen der acht Kombinationen von ABC soll D gleich 1 werden?
2. Die Bits der Bitmaske setzen.
3. Werden nicht alle drei Quellen benötigt, müssen sämtliche Kombinationen
   gewählt werden, in denen die unbenutzten Bits vorkommen und die ge-
   wünschten Bits den richtigen Wert besitzen.

Siehe auch:

@{" Blitter Copy       " link cbltcopy}

@endnode
@node dbyte "Byte"
Ein Byte

Ein Byte hat 8 Bits, daher kann man mit einem Byte Werte von 0 bis 255
darstellen. Ein Byte hat in Assembler das Suffix '.b'. Zwei Bytes zusammen
ergeben ein @{" Wort " link dword}, vier ein @{" Langwort " link dlong}.

@endnode
@node dchipram "Chip-Ram"
Chip-Ram

Als Chip-Ram wird der Speicher beim Amiga bezeichnet, auf dem die Custom-
Chips zugreifen können. Derzeit ist die Größe auf maximal 2 MB begrenzt
(auch beim A1200 und A4000), und im A500 existiert standardmäßig nur 512KB
Chip-Ram. Deswegen sollten Ihre Programme auch nicht mehr als einem halben
MB Chip-Ram benutzen, das heißt aber nicht, daß Ihre Programme nur auf
insgesamt 512KB laufen müssen!

Durch den Zugriff der Custom-Chips wird der Prozessor gebremst, wenn das
auszuführende Programm im Chip-Ram liegt. Besonders ab 32 Farben Lowres
und ab 8 Farben Hires (nicht A1200/A4000) wird der Amiga langsamer!

Chip-Ram wird vorallem benötigt für Bildschirme, Bobs und Sprites, Musik,
Sounds, Diskettenlaufwerke, Copperlisten.

Siehe auch:

@{" Fast-Ram   " link dfastram}
@{" Ranger-Ram " link drangram}

@endnode
@node dcyclic "Cyclic"
Cyclic (deutsch: kreisförmig)

Wenn eine Zahl den oberen Grenzwert überschreitet, dann wird diese Zahl
gleich dem unteren Grenzwert, und umgekehrt.

Beispiel:

OG=31 (obere Grenze)
UG=1  (untere Grenze)
Z=3   (Zahl)
Do
  Inc Z
  If Z>OG Then Z=UG
  If Z<UG Then Z=OG
  Print Z
Loop

@endnode
@node dfastram "Fast-Ram"
Fast-Ram

Fast-Ram nennt man den Speicher, auf den die Custom-Chips keinen Zugriff
haben. Dadurch wird der Prozessor -wenn das Programm im Fast-Ram läuft-
nicht gebremst. ABER: Es dürfen keine Daten für Bildschirme, Bobs und
Sprites, Musik oder Sounds ins Fast-Ram abgelegt werden und dann darauf
zugegriffen werden, das hat meist unschöne, wenn nicht sogar tödliche
Folgen.

Standardmäßig haben alle Amigas außer dem A3000/A4000 kein Fast-Ram.

Siehe auch:

@{" Chip-Ram   " link dchipram}
@{" Ranger-Ram " link drangram}

@endnode
@node dfourplayer "Wie baue ich einen 4-Player Adapter"
Bauanleitung für einen 4-Player Adapter

Zuerst: Ich über keine Gewähr für die Richtigkeit dieser Beschreibung,
        noch komme ich für Schäden auf, die Sie in irgendeiner Weise hier-
        durch erzeugen. Wenn Sie sich nicht geschickt genug fühlen, dann
        können Sie diesen Adapter auch in einem gut sortierten Elektro-
        fachgeschäft für wenig Geld kaufen.

Bauteile: 1 25-poliger Parallelstecker männlich.
          2 9-polige Joystickbuchsen weiblich.
          1 25-strähnig Flachbandkabel.

Schaltplan des Parallelsteckers und der Joystickbuchsen.

                              Parallelport
  ____________________________________________________________________
 (                                                                    )
  \  1    2    3    4    5    6    7    8    9   10   11   12   13   /
   \   14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22   23 | 24   25 |  /
    \___|_|____|____|____|__|_|____|____|____|_________|_________|_/
        | |    |    |    |  | |    |    |    |         |         |
        | |    | .--|----|--^-|----|----|----|---------|-.       |
        `-|----|-|--|-v--|----|----|----|----|------.  `-|-------|-.
          |    | |  | |  |    |    |    |    |      `----|----.  | |
          |  .-|-|--|-|--' .--|----|----|----|-----------|----|--' |
          |  | | | /  |    |  `--. |    |    `--------.  |    |    |
          |  | `-|-|--|-.  |     | |    `-------------|--|-.  |    |
          |   \  | |  | |  |     | `------------------|--|-|--|-.  |
          `---|--|-|--|-|--|-.   `--------------------|--|-|--|-|--|-.
      ________|__|_|__|_|__|_|___             ________|__|_|__|_|__|_|___
     (        |  | |  | |  | |   )           (        |  | |  | |  | |   )
      \  5    4  | 3  | 2  | 1  /             \  5    4  | 3  | 2  | 1  /
       \    9    8    7    6   /               \    9    8    7    6   /
        \_____________________/                 \_____________________/

                 Joy 3                                   Joy 4

Und wem das zu unübersichtlich ist:

      Parallelport:     Joy 3:     Joy 4:
      P0     2                     UP     1
      P1     3                     DOWN   2
      P2     4                     LEFT   3
      P3     5                     RIGHT  4
      P4     6          UP     1
      P5     7          DOWN   2
      P6     8          LEFT   3
      P7     9          RIGHT  4
      BUSY  11          FIRE   6
      SEL   13                     FIRE   6
      +5 V  14          +5 V   7   +5 V   7
      GND   18          GND    8   GND    8

Wie gesagt, keine Gewähr!

@endnode
@node dham "Kurze Erklärung zum HAM-Modus"
Kurze Erklärung zum HAM-Modus

Da die Amigas "nur" bis zu 6 bzw. 8 Bitplanes darstellen können, man aber
für Photoqualität viel mehr als 64 bzw. 256 Farben braucht, haben sich die
Entwickler des Amigas einen Trick einfallen lassen: Der HAM-Modus (Abkürz-
ung für "Hold And Modify").

- HAM6 (ohne @{" AGA-Chipset " link dagaamiga}):
  Den ersten 16 Farben können ganz normale Werte zugewiesen werden, sie
  werden ganz genau so auf dem Bildschirm dargestellt.
  Die Farben 16-31 verändern den Blauanteil der links nebenstehenden Farbe
  auf den entsprechenden Farbindex. Die Farben 32-47 ändern den Grünanteil
  wie oben, und die Farben 48-63 den Rotanteil ebenso.
  So lassen sich mit nur 6 Bitplanes alle 4096 Farben darstellen.

- HAM8 (@{" AGA-Amigas " link dagaamiga}):
  Wie auch beim HAM6-Modus, werden die ersten Farben korrekt dargestellt,
  jedoch reicht hier die Grundpalette von 0-63.
  Ebenso wie oben verhalten sich auch die Farben 64-255, nur daß hier
  immer 64 Farben für die Änderung eines Farbanteils verantwortlich sind.
  So lassen sich, bei entsprechender Grundpalette alle 16777216 Farben
  darstellen.

@endnode
@node diconbanks "Icons"
Icons- und Sprites-Banks

Diese Banks bestehen NICHT aus einem zusammenhängenden Speicherbereich,
daher kann man sie weder verschieben, kopieren, kodieren, packen oder eine
Checksumme machen. Außerdem müssen Icons und Sprites immer im @{" Chip-Ram " link dchipram}
liegen.

@endnode
@node dlong "Langwort"
Ein Langwort (engl. Longword)

4 Bytes ergeben eine Einheit von 64 Bits. Mit diesen Langwörtern lassen
sich bis zu 4 Gigabyte adressieren. Daher werden für sie alle absoluten
Adressen verwendet. Wie auch bei @{" Words " link dword} müssen diese an geraden Adressen
liegen.

Siehe auch:

@{" Byte     " link dbyte}

@endnode
@node dobject "Disk-Objekt"
Disk-Objekt

Ein Disk-Objekt kann sein:
a) eine Datei auf einem Datenträger
b) ein Verzeichnis
c) ein Assign
d) eine Diskette

@endnode
@node dpermanent "permanent"
Permanente Banks

Als permanent werden Banks bezeichnet, die auch nach einem Default,
Erase Temp und einem Programmstart, erhalten bleiben. Sie werden auch
zusammen mit dem Programm abgespeichert. Normalerweise heißen permanente
Banks 'Datas'.

Siehe auch:

@{" Temporäre Banks  " link dtemporaer}

@endnode
@node dprotflags "Die Schutzbits"
Die Schutzbits

Die Schutzbits oder auch Protection Flags geben Auskunft über den Status
eines @{" Objekts " link dobject}.
Sie besteht aus einer Bitmap mit folgendem Format:

Bit 0=0: Datei kann gelöscht werden
Bit 1=0: Datei kann gestartet werden
Bit 2=0: Datei kann überschrieben werden
Bit 3=0: Datei kann gelesen werden
Bit 4=1: Datei ist nach dem Kopieren nicht verändert worden
Bit 5=1: Datei kann resident gemacht werden
Bit 6=1: Datei ist eine Batchdatei
Bit 7=1: Datei ist unsichtbar

Wie man sieht, ist dies recht unübersichtlich. Deswegen gibt es die
Funktion Object Protection$, die diese Bitmap in einen String im Format
"hsparwed" verwandelt.

Siehe auch:

@{" Protect Object     " link cprotobj}
@{" =Object Protection " link fobjprot}
@{" =Object Protection$" link fobjprst}

@endnode
@node drangram "Ranger-Ram"
Ranger-Ram

Ranger-Ram ist ein Spezialfall: Es ist weder Chip- noch Fast-Ram und kommt
nur bei einem A500 mit interner Speichererweiterung vor. Die Custom-Chips
haben keinen Zugriff, trotzdem ist der Speicher nicht schneller.

Es gibt eine Möglichkeit, Ranger-Ram in Chip-Ram umzuwandeln.
Dazu muß der Jumper 2 auf der Hauptplatine umgelötet werden.
Ich übernehme keine Verantwortung für irgendwelche Schäden, die dabei ent-
stehen könnten.

Siehe auch:

@{" Chip-Ram   " link dchipram}
@{" Fast-Ram   " link dfastram}

@endnode
@node dstructur "Die interne Struktur des AMCAF Datenbereichs"
Version  : V1.15
Länge    : 1964 Bytes
Anmerkung: Im Gegensatz zu den meisten anderen Extensions, ist der
           Datenbereich nicht der AMCAF.Lib Datei gespeichert. Daher
           ist sie auch sehr kompakt (*nur* 40KB!?).

                rsreset         ;Stars
St_X            rs.w    1       ;0
St_Y            rs.w    1       ;2
St_DbX          rs.w    1       ;4
St_DbY          rs.w    1       ;6
St_Sx           rs.w    1       ;8
St_Sy           rs.w    1       ;10
St_SizeOf       rs.b    0       ;12

                rsreset         ;Splinters
Sp_X            rs.w    1       ;0
Sp_Y            rs.w    1       ;2
Sp_Pos          rs.l    1       ;4
Sp_DbPos        rs.l    1       ;8
Sp_Sx           rs.w    1       ;12
Sp_Sy           rs.w    1       ;14
Sp_Col          rs.b    1       ;16
Sp_BkCol        rs.b    1       ;17
Sp_DbBkCol      rs.b    1       ;18
Sp_First        rs.b    1       ;19
Sp_Fuel         rs.w    1       ;20
Sp_SizeOf       rs.b    0       ;22

                rsreset         ;Blitterqueue
Bn_Next         rs.l    1
Bn_Function     rs.l    1
Bn_Stat         rs.w    1
Bn_Dummy        rs.w    1
Bn_BeamPos      rs.w    1
Bn_CleanUp      rs.l    1
Bn_B40l         rs.l    1       ;BLTCON0&BLTCON1
Bn_B44l         rs.l    1       ;Masks
Bn_B48l         rs.l    1       ;Source Address C
Bn_B50l         rs.w    1
Bn_B52w         rs.w    1       ;Source Address A.w
Bn_B54l         rs.l    1       ;Target Address D
Bn_B58w         rs.w    1       ;BLTSIZE
Bn_B60w         rs.w    1       ;Modulo C
Bn_B62l         rs.w    1       ;Modulo B&A
Bn_B64w         rs.w    1       ;Modulo A
Bn_B66w         rs.w    1       ;Modulo D
Bn_B72w         rs.w    1       ;BLTBDAT
Bn_B74w         rs.w    1       ;BLTADAT
Bn_XPos         rs.w    1
Bn_SizeOf       rs.b    0

                rsreset         ;AMCAF Main Datazone
O_TempBuffer    rs.b    80
O_FileInfo      rs.b    260
O_Blit          rs.b    Bn_SizeOf
O_BobAdr        rs.l    1
O_BobMask       rs.l    1
O_BobWidth      rs.w    1
O_BobHeight     rs.w    1
O_BobX          rs.w    1
O_BobY          rs.w    1
O_StarBank      rs.l    1
O_StarLimits    rs.w    4
O_StarOrigin    rs.w    2
O_StarGravity   rs.w    2
O_StarAccel     rs.w    1
O_StarPlanes    rs.w    2
O_NumStars      rs.w    1
O_CoordsBank    rs.l    1
O_SpliBank      rs.l    1
O_SpliLimits    rs.w    4
O_SpliGravity   rs.w    2
O_SpliBkCol     rs.w    1
O_SpliPlanes    rs.w    1
O_SpliFuel      rs.w    1
O_NumSpli       rs.w    1
O_MaxSpli       rs.w    1
O_SBobMask      rs.w    1
O_SBobPlanes    rs.w    1
O_SBobWidth     rs.w    1
O_SBobImageMod  rs.w    1
O_SBobLsr       rs.w    1
O_SBobLsl       rs.w    1
O_SBobFirst     rs.b    1
O_SBobLast      rs.b    1
O_QRndSeed      rs.w    1
O_QRndLast      rs.w    1
O_PTCiaVbl      rs.w    1
O_PTCiaResource rs.l    1
O_PTCiaBase     rs.l    1
O_PTCiaTimer    rs.w    1
O_PTCiaOn       rs.w    1
O_PTInterrupt   rs.b    22
O_PTVblOn       rs.w    1
O_PTAddress     rs.l    1
O_PTBank        rs.l    1
O_PTSamBank     rs.l    1
O_PTTimerSpeed  rs.l    1
O_PTDataBase    rs.l    1
O_PTSamVolume   rs.w    1
O_AgaColor      rs.w    1
O_HamRed        rs.b    1
O_HamGreen      rs.b    1
O_HamBlue       rs.b    1
                rs.b    1       ;Pad
O_VecRotPosX    rs.w    1
O_VecRotPosY    rs.w    1
O_VecRotPosZ    rs.w    1
O_VecRotAngX    rs.w    1
O_VecRotAngY    rs.w    1
O_VecRotAngZ    rs.w    1
O_VecRotResX    rs.w    1
O_VecRotResY    rs.w    1
O_VecRotResZ    rs.w    1
O_VecCosSines   rs.w    6
O_VecConstants  rs.w    9
O_BlitTargetPln rs.l    1
O_BlitSourcePln rs.l    1
O_BlitTargetMod rs.w    1
O_BlitSourceMod rs.w    1
O_BlitX         rs.w    1
O_BlitY         rs.w    1
O_BlitWidth     rs.w    1
O_BlitHeight    rs.w    1
O_BlitMinTerm   rs.w    1
O_BlitSourceA   rs.l    1
O_BlitSourceB   rs.l    1
O_BlitSourceC   rs.l    1
O_BlitSourceAMd rs.w    1
O_BlitSourceBMd rs.w    1
O_BlitSourceCMd rs.w    1
O_BlitAX        rs.w    1
O_BlitAY        rs.w    1
O_BlitAWidth    rs.w    1
O_BlitAHeight   rs.w    1
O_PTileBank     rs.l    1
O_BufferAddress rs.l    1
O_BufferLength  rs.l    1
O_PowerPacker   rs.l    1
O_PPCrunchInfo  rs.l    1
O_DiskFontLib   rs.l    1
O_DirectoryLock rs.l    1
O_DateStamp     rs.l    3
O_OwnAreaInfo   rs.b    1
O_OwnTmpRas     rs.b    1
                rs.w    1       ;Pad
O_AreaInfo      rs.b    24
O_Coordsbuffer  rs.b    20*5
O_TmpRas        rs.b    8
O_FontTextAttr  rs.b    8
O_AudioPort     rs.b    32
O_AudioIO       rs.b    68
O_ChanMap       rs.w    1
O_AudioOpen     rs.w    1
O_AudioPortOpen rs.w    1
                rs.w    1       ;Pad
O_PaletteBufs   rs.w    32*8
O_ParseBuffer   rs.b    512
O_SizeOf        rs.l    0

@endnode
@node dtemporaer "temporär"
Temporäre Banks

Temporäre Banks existieren nur während des Ablaufs des Programms, sie
werden bei jedem Neustart, Test oder Speicherung des Programms oder mit
den Befehlen Default oder Erase Temp gelöscht. Meistens haben temporäre
Banks den Namen 'Work'.

Siehe auch:

@{" Permanente Banks " link dpermanent}

@endnode
@node dtome "TOME-Extension"
Die TOME-Extension

TOME ist eine Erweiterung für AMOS Creator und neuerdings auch für AMOS
Professional, die sich der Kachelprogrammierung widmet. Kacheln kommen in
vielen Spielen vor z.B Jump'n'Runs, Strategie. Da die ganze Spielwelt als
Grafik zu viel Speicher kosten würde, zerlegt man sie in wesentliche Ele-
mente und baut dann mit Hilfe der Kacheln die Karte auf.

Die aktuelle Version von TOME ist TOME V4.30.

@endnode
@node dword "Wort"
Ein Wort (engl. Word)

Ein Wort besteht aus zwei @{" Bytes " link dbyte}, also 16 Bits. Damit
kann man 64KB (65536) adressieren bzw. darstellen. Ein Wort muß beim
MC68000 noch an einer gerade Adresse im Speicher stehen, sonst gibt es
einen schönen Guru mit der Nummer $80000003. Ab einem MC68020 ist das
egal, doch sollten sie NIE davon ausgehen, das kein MC68000 im Rechner ist
und wild ungerade Adressen benutzen!

Wenn Sie unbedingt ungerade Adressen benutzen wollen, checken sie vorher
mit Hilfe der @{" Cpu-Funktion " link fcpu}, ob ein 68020 oder höher vorhanden ist.

Siehe auch:

@{" Langwort " link dlong}

@endnode
@node fagadtct "Funktion: =Aga Detect"
flag=Aga Detect

Dies ist eine einfache Funktion, die überprüft, ob das AGA Chipset,
das man in A1200, A4000 und CD³² Rechnern findet, vorhanden ist.
Falls es vorhanden ist, wird -1 (True) zurückgegeben, wenn er nur ein ECS
oder gar OCS Rechner ist, enthält flag 0 (False).

Beachten Sie, daß Aga Detect nicht nur die Kickstartversion testet, so daß
A2000 und A500 Rechner mit Kickstart 3.0 oder höcher wirklich als Non-AGA
Maschinen erkannt werden. Diese Funktion ist 100% systemfreundlich und
hackt für das Ergebnis nicht die Hardware. Dadurch liefert Aga Detect 0,
wenn das Aga Chipset mit Hilfe des Bootmenüs oder des "Setpatch NOAGA"
Befehls abgeschaltet wurde.

@endnode
@node famcafba "Funktion: =Amcaf Base"
adr=Amcaf Base

Liefert die Basisadresse der @{" AMCAF-Datenstruktur " link dstructur}.

Siehe auch:

@{" =Amcaf Length      " link famcafle}

@endnode
@node famcafle "Funktion: =Amcaf Length"
le=Amcaf Length

Gibt die Länge des @{" AMCAF-Datenbereichs " link dstructur} zurück.

Siehe auch:

@{" =Amcaf Base        " link famcafba}

@endnode
@node famcafvs "Funktion: =Amcaf Version$"
Print Amcaf Version$

Gibt die Versionsnummer und eine Grußliste aus.

@endnode
@node famoscli "Funktion: =Amos Cli"
n=Amos Cli

Diese Funktion liefert die Nummer des Cli's aus dem das Programm bzw. AMOS
gestartet wurde, oder 0, wenn von der Workbench gestartet wurde. So kann
man entscheiden, ob man die Optionen über die Parameter der Kommandozeile
lesen soll, oder über die Tool Types des Icons.

Siehe auch:

@{" =Command Name$     " link fcomname}
@{" =Tool Types$       " link ftooltyp}

@endnode
@node famostsk "Funktion: =Amos Task"
address=Amos Task

Für professionelle Programmierer. Mit dieser Funktion bekommt man die AMOS
Task-Struktur. Über diese läßt sich z.B auch die Task Priorität erhöhen:

Areg(1)=Amos Task
Dreg(0)=3
dummy=Execall(-$12C)

Dieses Programm erhöht die Task Priorität auf +3.

@endnode
@node fasclong "Funktion: =Asc.l"
long=Asc.l(long$)

Die Asc.l-Funktion wandelt einen @{" 4-Bytes " link dlong} langen String in einen Zahlen-
wert zurück. Dieser Wert kann zwischen -2147483648 und +2147483647 liegen.
Wird ein String übergeben, dessen Länge kleiner als 4 Bytes ist, so wird
eine Fehlermeldung zurück gegeben.

Siehe auch:

@{" =Chr.l$            " link fchrlong}
@{" =Asc.w             " link fascword}
@{" =Chr.w$            " link fchrword}

@endnode
@node fascword "Funktion: =Asc.w"
word=Asc.w(word$)

Asc.w dient der Umwandlung von @{" Wordstrings " link dword} in einen Zahlenwert. Dadurch
liegt das Ergebnis immer im Bereich zwischen 0 und 65535. Ist die Länge
des übergebenen Strings kleiner als 2, wird die Funktion mit einer Fehler-
meldung abgebrochen.

Siehe auch:

@{" =Chr.w$            " link fchrword}
@{" =Asc.l             " link fasclong}
@{" =Chr.l$            " link fchrlong}

@endnode
@node fbnkchec "Funktion: =Bank Checksum"
number=Bank Checksum(bank)
number=Bank Checksum(startaddress To endaddress)

Diese Funktion berechnet eine Checksumme für eine Bank mit bestimmten
Inhalt. Mit dieser Checksumme kann festgestellt werden, ob sich der Inhalt
der Bank verändert hat. Die zweite Version der Anweisung berechnet eine
Checksumme des Speicherabschnittes von startaddress bis endaddress.

@endnode
@node fbnkname "Funktion: =Bank Name$"
name$=Bank Name(bank)

Die Funktion Bank Name$ gibt den Namen der Bank mit der Nummer bank
zurück.

Siehe auch:

@{" Bank Name          " link cbnkname}

@endnode
@node fbestpen "Funktion: =Best Pen"
pen=Best Pen($RGB)
pen=Best Pen($RGB,c1 To c2)

Diese Funktion ermittelt den Zeichenstift, der am nähesten an der Farbe
$RGB liegt. Zusätzlich können Sie den Bereich festlegen, in dem nach der
besten Farbe gesucht werden soll. Die Best Pen-Funktion kann dazu benutzt
werden, Bilder mit begrenzter Palette umzufärben.

@endnode
@node fbinexpo "Funktion: =Binexp"
v=Binexp(a)

Diese Funktion liefert das Ergebnis der Exponentialfunktion 2^a, ist
jedoch um einiges schneller als der normale AMOS-Ausdruck.
Der Parameter a muß im Bereich von 0 bis 31 liegen.

Beispiele: Binexp(1)=2, Binexp(3)=8, Binexp(16)=65536, Binexp(24)=16777216

Siehe auch:

@{" =Binlog            " link fbinloga}
@{" =Lsl               " link flogleft}
@{" =Lsr               " link flogrigh}

@endnode
@node fbinloga "Funktion: =Binlog"
a=Binlog(v)

Binlog ist die Umkehrfunktion zu Binexp. Sie liefert den Logarithmus der
Zahl v zur Basis 2. v muß deshalb eine Potenz von 2 sein, sonst erhalten
Sie eine Fehlermeldung. So läßt auch ganz leicht ermitteln, wieviele Bit-
planes ein Screen mit v Farben hat (Ausnahme: @{" HAM " link dham}).

Beispiele: Binlog(2)=1, Binlog(8)=3, Binlog(65536)=16, Binlog(16777216)=24

Siehe auch:

@{" =Binexp            " link fbinexpo}
@{" =Lsl               " link flogleft}
@{" =Lsr               " link flogrigh}

@endnode
@node fbltbusy "Funktion: =Blitter Busy"
flag=Blitter Busy

Diese Funktion gibt -1 (True) zurück, wenn der @{" Blitter " link dblitter} gerade
beschäftigt ist, also z.B noch Flächen löscht oder füllt, oder Linien
zeichnet. Dies kann benutzt werden, um auf das Ende der Blittertätigkeit
zu warten, obwohl dafür eher Blitter Wait geeignet ist. Oder man verwendet
Blitter Busy, um zu entscheiden, andere Berechnung mit dem Prozessor in
der Zwischenzeit zu machen, oder die nächste Blitter-Arbeit zu beginnen.

Siehe auch:

@{" Blitter Wait       " link cbltwait}
@{" Blitter Copy       " link cbltcopy}
@{" Blitter Fill       " link cbltfill}
@{" Blitter Clear      " link cbltcler}

@endnode
@node fcbluval "Funktion: =Blue Val"
b=Blue Val(rgb)

Diese Funktion ermittelt den Blauanteil einer Farbe. Zusammen mit den
anderen Val-Funktionen laßt sich so eine Farbe in die einzelnen Teil
aufspalten.

Siehe auch:

@{" =Red Val           " link fcredval}
@{" =Green Val         " link fcgreval}
@{" =Glue Colour       " link fgluecol}

@endnode
@node fcddates "Funktion: =Cd Date$"
date$=Cd Date$(date)

Diese einfache Funktion gibt das Datum date als String im Format
'WWW DD-MMM-YY' zurück.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}
@{" =Cd String         " link fcd_strg}

@endnode
@node fcd__day "Funktion: =Cd Day"
day=Cd Day(date)

Diese Funktion liefert den Tag im Monat des Datums date. Das Ergebnis day
liegt zwischen 1 und 31.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Weekday        " link fcdweekd}
@{" =Cd String         " link fcd_strg}

@endnode
@node fcdmonth "Funktion: =Cd Month"
month=Cd Month(date)

Cd Month ermittelt den Monat des Datums date. month liegt also im Bereich
von 1 bis 12.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}
@{" =Cd String         " link fcd_strg}

@endnode
@node fcd_strg "Funktion: =Cd String"
date=Cd String(date$)

Diese Funktion errechnet aus dem gültigen Datum in date$ einen Datumswert
date, oder gibt -1 zurück, wenn der String kein gültiges Datum enthielt.

date$ muß im Format "DD-MMM-YY" oder "DD-monat-YY" vorliegen.
Zeichenketten wie "Heute" oder "Morgen" sind auch gültig, Namen von
Wochentagen beziehen sich auf das letzte Auftreten dieses Tages, d.h
mit "Montag" ist der letzte Montag gemeint und nicht der nächste.

Dieser Befehl funktioniert erst ab OS2.0.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}

@endnode
@node fcdweekd "Funktion: =Cd Weekday"
weekday=Cd Weekday(date)

Liefert den Wochentag des Datums date. Er liegt im Bereich von 1 (Montag)
bis 7 (Sonntag).

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd String         " link fcd_strg}

@endnode
@node fcd_year "Funktion: =Cd Year"
year=Cd Year(date)

Gibt die Jahreszahl aus dem DOS-Datum date zurück.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Cd Date$          " link fcddates}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}
@{" =Cd String         " link fcd_strg}

@endnode
@node fchrlong "Funktion: =Chr.l$"
long$=Chr.l$(long)

Die Funktion Chr.l wandelt einen Zahlenwert in einen 4-Bytes String um.
Dabei kann long ein beliebiger Zahl sein. So kann man z.B Zahlenwerte als
ganz normale String abspeichern.

Siehe auch:

@{" =Asc.l             " link fasclong}
@{" =Chr.w$            " link fchrword}
@{" =Asc.w             " link fascword}

@endnode
@node fchrword "Funktion: =Chr.w$"
word$=Chr.w$(word)

Diese Funktion wandelt einen Zahlenwert in einen 2-Bytes String um. Die
oberen 16 Bits des Wertes werden abgeschnitten, so ist es sinnvoll nur
Werte von 0 bis 65535 zu verwenden.

Siehe auch:

@{" =Asc.w             " link fascword}
@{" =Chr.l$            " link fchrlong}
@{" =Asc.l             " link fasclong}

@endnode
@node fcomname "Funktion: =Command Name$"
fname$=Command Name$

Gibt den Namen zurück, unter dem AMOS oder das compilierte Programm ge-
startet wurde. Das wird benötigt, um z.B die Tool Types zu lesen.

Siehe auch:

@{" =Tool Types$       " link ftooltyp}
@{" =Amos Cli          " link famoscli}

@endnode
@node fcop_pos "Funktion: =Cop Pos"
address=Cop Pos

Wenn Sie einen eigenen Copper aufbauen, dann können Sie mit dieser
Funktion ermitteln, wo sich gerade der Zeiger für den nächsten Copper-
befehl befindet. Mit dieser Adresse können Sie dann später direkt die
Werte der Anweisungen verändern.

@endnode
@node fcounpix "Funktion: =Cound Pixels"
amount=Count Pixels(screen,colour,x1,y1 To x2,y2)

Zählt die Bildpunkte im rechteckigen Bereich x1,y1 bis x2,y2 im Bildschirm
screen, die nicht die Farbe colour haben. Diese Funktion kann benutzt wer-
den, um erstmal die Anzahl der Punkte zu erhalten und dann die Koordina-
tenbank zu reservieren.

Siehe auch:

@{" Coords Bank        " link ccrdbank}
@{" Coords Read        " link ccrdread}

@endnode
@node fcpu     "Funktion: =Cpu"
chip=Cpu

Die Funktion Cpu liefert die Prozessornummer des Amigas. Diese kann von
68000 bis 68060 liegen. Kickstart 1.3 kennt leider nur CPUs bis 68020.

Siehe auch:

@{" =Fpu               " link ffpu    }

@endnode
@node fct_hour "Funktion: =Ct Hour"
hour=Ct Hour(time)

Spaltet von der gepackten Zeit die Stunden heraus.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fctminut "Funktion: =Ct Minute"
minute=Ct Minute(time)

Gibt die Anzahl der Minuten aus dem Zeitlangwort time zurück.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fctsecon "Funktion: =Ct Second"
second=Ct Second(time)

Die Ct Second-Funktion liefert die Anzahl der Sekunden aus der Zeit time.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fct_strg "Funktion: =Ct String"
time=Ct String(time$)

Diese Funktion errechnet aus der gültigen Zeit in time$ einen Zeitwert
time, oder gibt -1 zurück, wenn der String keine gültige Zeit enthielt.

Der time$ muß im Format "HH:MM" oder "HH:MM:SS" vorliegen.

Dieser Befehl funktioniert erst ab OS2.0.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fct_tick "Funktion: =Ct Tick"
tick=Ct Tick(time)

Berechnet die Anzahl der Vertical Blanks (=50stel Sekunde) aus der Zeit
time.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}

@endnode
@node fcttimes "Funktion: =Ct Time$"
time$=Ct Time$(time)

Diese hilfreiche Funktion wandelt die Zeit time in eine Zeichenkette im
Format 'HH:MM:SS' um.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fcurdate "Funktion: =Current Date"
date=Current Date

Liefert das aktuelle System-Datum. Dieser Wert zählt die vergangenen Tage
seit dem 1. Januar 1978. Um daraus die Anzahl der Jahre, Monate und Tage
herauszufiltern existieren naturlich Funktionen.

Siehe auch:

@{" =Current Time      " link fcurtime}
@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}
@{" =Cd String         " link fcd_strg}

@endnode
@node fcurtime "Funktion: =Current Time"
time=Current Time

Diese Funktion gibt die aktuelle Uhrzeit zurück. Es handelt sich dabei
NICHT um einen Wert im Standard-DOS-Format, da dieser zwei Langwörter
verbrauchen würde.

Wen es interessiert, das Format lautet: Wordswap(minuten)+ticks.

Siehe auch:

@{" =Current Date      " link fcurdate}
@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}

@endnode
@node fcutstrg "Funktion: =Cutstr$"
newstr$=Cutstr$(s$,pos1 To pos2)

Schneidet einen Teil des Strings s$ von der Stelle pos1 beginnend bis zu
pos2 aus und gibt das Ergebnis in newstr$ zurück.

Beispiele:

Print Cutstr$("Hallo lieber Ben!",7 To 13) erzeugt 'Hallo Ben!'.

Siehe auch:

@{" =Insstr$           " link finsstrg}
@{" =Replacestr$       " link frplcstr}

@endnode
@node fdskstat "Funktion: =Disk State"
flags=Disk State(directory$)

Ermittelt den Status eines Laufwerks. flags ist eine Bit-Map, von denen
nur zwei Bits benutzt sind:

Bit
 0=0: Die Diskette ist nicht schreibgeschützt, es kann geschrieben werden.
 0=1: Der Datenträger ist schreibgeschützt oder wird gerade validiert.
 1=0: Von der Diskette wird momentan nicht gelesen oder geschrieben.
 1=1: Der Datenträger wird gerade benutzt.

Falls sich keine Diskette im Laufwerk befindet, so sollte eigentlich -1
zurückgegeben werden, leider wird aber in diesem Fall ein Requester mit
dem Titel "No disk in drive xxx:" geöffnet, welches beim Abbrechen den
Fehler 'File not found' erzeugt.

Verwenden Sie dazu folgende Konstruktion:

Request Off
Trap FLAGS=Disk State(DIRECTORY$)
Request On
If Errtrap Then FLAGS=-1

@endnode
@node fdsktype "Funktion: =Disk Type"
type=Disk Type(directory$)

Die Funktion Disk Type gibt den Typ eines Verzeichnisses zurück.
Dieser Wert kann sein:

0: Es handelt sich um ein echtes Gerät (z.B. 'DF0:')
1: Das Gerät ist ein Verzeichnis (Assign) (z.B. 'LIBS:')
2: Es ist der Name einer Diskette (z.B. 'Workbench2.0:')

So lassen sich z.B. Geräte aus einer Device-Liste herausfiltern.

@endnode
@node fdoshash "Funktion: =Dos Hash"
hash$=Dos Hash$(file$)

Gibt den Hashwert einer Datei zurück. Nur für fortgeschrittene Pro-
grammierer, die direkt von der Diskette lesen wollen.

@endnode
@node feven    "Funktion: =Even"
flag=Even(value)

Gibt True (-1) zurück, wenn die Zahl gerade ist oder False (0), falls sie
ungerade ist.

Siehe auch:

@{" =Odd               " link fodd    }

@endnode
@node fexanext "Funktion: =Examine Next$"
file$=Examine Next$

Holt die Daten des sich als nächstes im Verzeichnis befindlichen @{" Objekts " link dobject}
und gibt den Dateinamen zurück. Andere Daten können mit Hilfe der Object-
Funktionen beschafft werden. Ist file$ eine leerer String, so ist das Ende
der Dateiliste erreicht und das Verzeichnis wird geschlossen.

Siehe auch:

@{" Examine Dir        " link cexamdir}
@{" Examine Stop       " link cexastop}
@{" =Object Name$      " link fobjname}
@{" =Object Type       " link fobjtype}
@{" =Object Size       " link fobjsize}
@{" =Object Blocks     " link fobjblks}
@{" =Object Protection " link fobjprot}
@{" =Object Time       " link fobjtime}
@{" =Object Date       " link fobjdate}
@{" =Object Comment$   " link fobjcomm}

@endnode
@node fextpath "Funktion: =Extpath$"
newpath$=Extpath$(directory$)

Erweitert einen Pfad um einen Schrägstrich, wenn es sich um ein Verzeich-
nis handelt. Nützlich, wenn man einem Pfad einen Dateinamen anfügen will.

Beispiel: Extpath$("DH2:AMOS")+"AMOSPro" ergibt "DH2:AMOS/AMOSPro",
          Extpath$("DH2:")+"AMOS" ergibt "DH2:AMOS".

Siehe auch:

@{" =Path$             " link fpathstr}
@{" =Filename$         " link ffilname}

@endnode
@node ffilname "Funktion: =Filename$"
file$=Filename$(pathfile$)

Gibt den Dateinamen aus dem String path$ zurück, der aus Pfad- und Datei-
namen bestehen kann.

Beispiel: Filename$("DH2:AMOS/AMOSPro") ergibt "AMOSPro".

Siehe auch:

@{" =Path$             " link fpathstr}
@{" =Extpath$          " link fextpath}

@endnode
@node ffontsty "Funktion: =Font Style"
style=Font Style

Diese Funktion ersetzt die AMOS Funktion Text Styles, da diese nicht an-
gibt, ob es sich hierbei um einen Multicolor-Font handelt (Bit 6).
Ansonsten ist sie jedoch mit der AMOS Funktion identisch.

Siehe auch:

@{" Change Font        " link cchafont}

@endnode
@node ffpu     "Funktion: =Fpu"
chip=Fpu

Diese Funktion liefert die Nummer des mathematischen Koprozessors oder 0,
wenn keiner vorhanden ist. Auch hier kennt die Kickstart 1.3 nur den
68881.

Bei 68040 und 68060 Cpus wird auch bei der Fpu-Funktion 68040 oder 68060
zurückgegeben, da hier der Koprozessors in die CPU eingebaut ist.

Siehe auch:

@{" =Cpu               " link fcpu    }

@endnode
@node fgluecol "Funktion: =Glue Colour"
rgb=Glue Colour(r,g,b)

Fügt Rot-, Grün- und Blauanteil einer Farbe wieder zu einem Farbwert
zusammen.

Siehe auch:

@{" =Red Val           " link fcredval}
@{" =Green Val         " link fcgreval}
@{" =Blue Val          " link fcbluval}

@endnode
@node fcgreval "Funktion: =Green Val"
b=Green Val(rgb)

Diese Funktion ermittelt den Grünanteil einer Farbe. Zusammen mit den
anderen Val-Funktionen läßt sich so eine Farbe in die einzelnen Teil
aufspalten.

Siehe auch:

@{" =Red Val           " link fcredval}
@{" =Blue Val          " link fcbluval}
@{" =Glue Colour       " link fgluecol}

@endnode
@node fhambest "Funktion: =Ham Best"
c=Ham Best(newrgb,oldrgb)

Da man im @{" HAM-Mode " link dham} selten mit dem Setzen eines Punktes auf die ge-
wünschte Farbe kommt, kann man die Ham Best-Funktion verwenden, um die
geeignetste Farbe zu suchen. newrgb gibt dabei die Zielfarbe an, und
oldrgb die Farbe, die genau vor dem Punkt steht. Achten Sie darauf, daß
der aktuelle Screen, der HAM-Screen ist!

Siehe auch:

@{" =Ham Colour        " link fhamcolo}
@{" =Ham Point         " link fhampoin}

@endnode
@node fhamcolo "Funktion: =Ham Colour"
newrgb=Ham Colour(c,oldrgb)

Diese Funktion berechnet den neuen Farbwert, der entsteht, wenn man genau
nach dem Punkt die Farbe c setzt.

Siehe auch:

@{" =Ham Best          " link fhambest}
@{" =Ham Point         " link fhampoin}

@endnode
@node fhampoin "Funktion: =Ham Point"
rgb=Ham Point(x,y)

Diese Funktion vereinfacht den Prozess die sichtbare Farbe eines Pixels
an den Koordinaten x,y auf einem @{" HAM " link dham} Screen zu finden.
Obwohl die Methode mit Ham Colour ein wenig schneller ist, wenn man das
Bild von links nach rechts abfrägt, so erlaubt es Ham Point jeden
beliebigen Punkt auf dem Bildschirm sofort zu lesen.

Falls der Punkt x,y nicht auf dem Bildschirm liegt, so enthält rgb -1 und
nicht den Rot-Grün-Blau-Wert des Punktes.

Siehe auch:

@{" =Ham Colour        " link fhamcolo}
@{" =Ham Best          " link fhambest}

@endnode
@node finsstrg "Funktion: =Insstr$"
newstr$=Insstr$(a$,b$,pos)

Fügt die Zeichenkette b$ an der Stelle pos in den String a$ ein.

Beispiel:

Print Insstr$("Hallo Ben!","lieber ",6) erzeugt 'Hallo lieber Ben!'.

Siehe auch:

@{" =Cutstr$           " link fcutstrg}
@{" =Replacestr$       " link frplcstr}

@endnode
@node fioerror "Funktion: =Io Error"
errnumber=Io Error

Die Io Error-Funktion gibt die Nummer des zuletzt aufgetretenen Dos-
Fehlers zurück.

Siehe auch:

@{" =Io Error$         " link fioerstr}

@endnode
@node fioerstr "Funktion: =Io Error$"
error$=Io Error$(errnumber)

Gibt den String der entsprechenden DOS-Fehlermeldung zurück. Falls zu
einer Fehlernummer keine Fehlermeldung existiert, wird ein leerer String
zurückgegeben. Ab Kickstart 2.0 wird jedoch nicht die interne Liste ge-
nommen, sondern eine DOS-Funktion benutzt, die auch Locale unterstützt.

Siehe auch:

@{" =Io Error          " link fioerror}

@endnode
@node fitemstr "Funktion: =Itemstr$"
item$=Itemstr$(s$,itemnum)
item$=Itemstr$(s$,itemnum,sep$)

Dies ist eine sehr praktische Funktion, die Ihnen hilft, kleine String-
arrays zu vermeiden, wo man eigentlich keine benötigt. s$ enthält eine 
Reihe sogenannter 'Items', die von Null an steigend durchnummeriert sind.
Normalerweise werden diese durch ein '|' Zeichen voneinander getrennt, Sie
können jedoch das Trennzeichen durch den optionalen String sep$ selbst
einstellen. Achten Sie darauf, daß sep$ genau ein Zeichen enthält.

Leere Zeichenketten für s$ sind nicht erlaubt und erzeugen eine Fehler-
meldung. Jedoch können Sie leere Items ohne zu zögern anwenden. Beim
Versuch, auf ein Item zuzugreifen, daß nicht existiert wird auch eine
Fehlermeldung erzeugt.

Beispiele:

Print Itemstr$("Ben|Semprini|Petri|Andy",1) erzeugt 'Semprini'.

Print Itemstr$("The quick brown fox",2," ") erzeugt 'brown'.

Print Itemstr$("null|eins|zwei||vier|fünf,5) erzeugt 'fünf'.

Print "Das Wetter ist "+Itemstr$("spitze|toll|schön|solala|regnerisch|schrecklich|endzeitmäßig",WEATHER)

hätte einen ähnlichen Effekt wie:

Dim W$(6)
For A=0 To 6
  Read W$(A)
Next
Print "Das Wetter ist "+W$(WEATHER)
[...]
Data "spitze","toll","schön","solala","regnerisch"
Data "schrecklich","endzeitmäßig"

@endnode
@node flogleft "Funktion: =Lsl"
nv=Lsl(v,n)

Verschiebt die Zahl v um n Bits nach links. D.h daß eine Zahl v, die um
1 Bit nach links geschoben wurde, den Wert v*2 hat, bei 2 Bits v*4, bei
3 Bits v*8 etc.. Die Funktion ist extrem schnell und sie sollte wo es
auch immer möglich ist, anstelle von Multiplikationen eingesetzt werden.

Siehe auch:

@{" =Lsr               " link flogrigh}

@endnode
@node flogrigh "Funktion: =Lsr"
nv=Lsr(v,n)

Verschiebt eine Zahl v um n Bits nach rechts. Die Funktion entspricht also
einer Division mit 2^n, ist aber um ein vielfaches schneller.

Siehe auch:

@{" =Lsl               " link flogleft}

@endnode
@node flsstrin "Funktion: =Lsstr$"
s$=Lsstr$(v,n)

Ähnlich der AMOS Funktion Str$ erzeugt diese Funktion einen String aus
einer Zahl, jedoch wird in diesem Fall die Zahl rechtsbündig mit n Stellen
ausgeben, wobei führende Nullen durch Leerzeichen ersetzt werden. Ein
eventuell vorhandenes Vorzeichen wird nicht ausgegeben. n muß im Bereich
von 1 bis 10 liegen.

Siehe auch:

@{" =Lzstr$            " link flzstrin}

@endnode
@node flzstrin "Funktion: =Lzstr$"
s$=Lzstr$(v,n)

Diese Funktion ist fast identisch zu Lsstr$, nur das hier führende Nullen
nicht ersetzt werden. Auch hier gibt n die Anzahl der auszugebenden
Stellen an, und darf nur zwischen 1 und 10 sein.

Siehe auch:

@{" =Lsstr$            " link flsstrin}

@endnode
@node fmixcolo "Funktion: =Mix Colour"
newrgb=Mix Colour(rgb1,rgb2)
newrgb=Mix Colour(oldrgb,addrgb,lrgb To urgb)

Die erste Version der Funktion mischt die beiden Farben rgb1 und rgb2 und
gibt das Ergebnis zurück.
Die zweite Version verhält sich anders: Zu dem Farbwert oldrgb wird die
Farbe addrgb addiert, wenn addrgb ein positiver Wert ist oder subtrahiert,
wenn addrgb negativ ist. lrgb definiert die untere Grenze und urgb die
Obergrenze der erlaubten Farben.

@endnode
@node fnofunct "Funktion: =Nfn"
dummy=Nfn

Diese "Funktion" liefert nichts sinnvolles. Sie dient, genau wie Nop, nur
dazu, herauszufinden wie schnell eine Funktion ist.

Siehe auch:

@{" Nop                " link cnoopera}

@endnode
@node fodd     "Funktion: =Odd"
flag=Odd(value)

Gibt True (-1) zurück, wenn die Zahl ungerade ist oder False (0), wenn sie
gerade ist.

Siehe auch:

@{" =Even              " link feven   }

@endnode
@node fobjblks "Funktion: =Object Blocks"
numblks=Object Blocks
numblks=Object Blocks(pathfile$)

Object Blocks liefert die Anzahl der durch das aktuelle oder das @{" Objekt " link dobject}
pathfile$ benutzten Diskettenblöcke zurück.

Siehe auch:

@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjcomm "Funktion: =Object Comment$"
comment$=Object Comment$
comment$=Object Comment$(pathfile$)

Diese Funktion gibt den Kommentar eines @{" Objekts " link dobject} zurück.

Siehe auch:

@{" Set Object Comment " link cobjcomm}
@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjdate "Funktion: =Object Date"
date=Object Date
date=Object Date(pathfile$)

Gibt das Datum eines @{" Objekts " link dobject} als DOS-Zahlenwert zurück. Dieser kann mit
den Datumsbefehlen in Jahr, Monat, Tag und Wochentag zerlegt werden.

Siehe auch:

@{" =Cd Date$          " link fcddates}
@{" =Cd Year           " link fcd_year}
@{" =Cd Month          " link fcdmonth}
@{" =Cd Day            " link fcd__day}
@{" =Cd Weekday        " link fcdweekd}
@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjname "Funktion: =Object Name$"
file$=Object Name$
file$=Object Name$(pathfile$)

Object Name$ gibt den Namen des @{" Objekts " link dobject} pathfile$ zurück. Diese Funktion
entspricht etwa der Filename$-Funktion mit den Unterschieden, daß die
Existenz des Objekts geprüft wird, weitere Daten im Info-Block abgelegt
werden und der korrekte Name des Objekts mit richtiger Groß-/Kleinschrei-
bung zurückgegeben wird. Die erste Version holt sich den Namen des Objekts
aus dem schon mit Examine Object beschafften Info-Block.

Siehe auch:

@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjprot "Funktion: =Object Protection"
prot=Object Protection
prot=Object Protection(pathfile$)

Object Protection liefert die @{" Schutzbits " link dprotflags} eines @{" Objekts " link dobject}.
Die Funktion Object Protection$, wandelt diesen Zahlenwert in einen String
im Format "hsparwed".

Siehe auch:

@{" Protect Object     " link cprotobj}
@{" =Object Protection$" link fobjprst}
@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjprst "Funktion: =Object Protection$"
prot$=Object Protection$(prot)

Wandelt die @{" Schutz-Bits " link dprotflags} in einen String im Format "hsparwed".

Siehe auch:

@{" Protect Object     " link cprotobj}
@{" =Object Protection " link fobjprot}

@endnode
@node fobjsize "Funktion: =Object Size"
length=Object Size
length=Object Size(pathfile$)

Gibt die Größe eines Objekts zurück. Bei der ersten Version werden die
Daten aus dem aktuellen Info-Block geholt, bei der zweiten wird gleich-
zeitig der ganze Info-Block mit den Daten des @{" Objekts " link dobject} pathfile$
gefüllt.

Siehe auch:

@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjtime "Funktion: =Object Time"
time=Object Time
time=Object Time(pathfile$)

Ermittelt die Zeit des letzten Schreibzugriffs auf das @{" Objekt " link dobject}. Dieser
kann mittels den Zeitbefehlen in Stunde, Minute, Sekunde und fünfzigstel
Sekunde umgewandelt werden.

Siehe auch:

@{" =Ct Time$          " link fcttimes}
@{" =Ct Hour           " link fct_hour}
@{" =Ct Minute         " link fctminut}
@{" =Ct Second         " link fctsecon}
@{" =Ct Tick           " link fct_tick}
@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fobjtype "Funktion: =Object Type"
type=Object Type
type=Object Type(pathfile$)

Diese Funktion ermittelt, ob es sich bei pathfile$ oder der sich im
aktuellen Info-Block befindlichen @{" Objekt " link dobject} um ein Verzeichnis, oder eine
Datei handelt. Im Falle einer Datei ist type größer als 0, bei einem Ver-
zeichnis kleiner als 0.

Siehe auch:

@{" Examine Object     " link cexamobj}
@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node fpgetcol "Funktion: =Pal Get"
colour=Pal Get(palnr,index)

Diese Funktion liest den Farbwerte der Farbe index aus der internen
Palette palnr aus.

Siehe auch:

@{" Pal Set Screen     " link cpsetscr}
@{" Pal Get Screen     " link cpgetscr}
@{" Pal Set            " link cpsetcol}

@endnode
@node fpathstr "Funktion: =Path$"
pathway$=Path$(pathfile$)

Gibt den Pfad aus dem gemischten Pfad-Dateinamen-String zurück. Kann auch
als eine Art Parent$-Funktion verwendet werden.

Beispiel: Path$("DH2:AMOS/AMOSPro") ergibt "DH2:AMOS".

Siehe auch:

@{" =Filename$         " link ffilname}
@{" =Extpath$          " link fextpath}

@endnode
@node fpatmatc "Funktion: =Pattern Match"
flag=Pattern Match(sourcestring$,pattern$)

Pattern Match überprüft, ob der String sourcestring$ in das Muster
pattern$ paßt. Ist das der Fall, so wird True (-1) zurückgegeben, sonst
False (0). Als Muster dürfen alle normalen DOS Joker verwendet werden, ein
'*' wird automatisch in ein '#?' umgewandelt.

Dieser Befehl funktioniert erst ab OS2.0.

@endnode
@node ffourfir "Funktion: =Pfire"
flag=Pfire(j)

Entspricht Fire(j) eines normalen Joysticks. Pfire testet, ob der Feuer-
knopf des Joystick im Parallelport gedrückt wurde. Wenn das der Fall sein
sollte, liefert flag den Wert True (-1), sonst False (0).

Siehe auch:

@{" =Pjoy              " link ffourjoy}
@{" =Pjup              " link ffourjup}
@{" =Pjleft            " link ffourjle}
@{" =Pjdown            " link ffourjdo}
@{" =Pjright           " link ffourjri}

@endnode
@node ffourjdo "Funktion: =Pjdown"
flag=Pjdown(j)

Entspricht Jdown(j) eines normalen Joysticks. Pjdown testet, ob der Joy-
stick im Parallelport nach unten gedrückt wurde. Wenn ja, ist flag gleich
True (-1), sonst False (0).

Siehe auch:

@{" =Pjoy              " link ffourjoy}
@{" =Pjup              " link ffourjup}
@{" =Pjleft            " link ffourjle}
@{" =Pjright           " link ffourjri}
@{" =Pfire             " link ffourfir}

@endnode
@node ffourjle "Funktion: =Pjleft"
flag=Pjleft(j)

Entspricht Jleft(j) eines normalen Joysticks. Pjleft testet, ob der Joy-
stick im Parallelport nach links gedrückt wurde. Wenn ja, ist flag gleich
True (-1), sonst False (0).

Siehe auch:

@{" =Pjoy              " link ffourjoy}
@{" =Pjup              " link ffourjup}
@{" =Pjdown            " link ffourjdo}
@{" =Pjright           " link ffourjri}
@{" =Pfire             " link ffourfir}

@endnode
@node ffourjoy "Funktion: =Pjoy"
bitmap=Pjoy(j)

Entspricht der AMOS Funktion Joy, nur daß diese nicht einen Joystick an
den beiden Joystickports abfrägt, sondern einen Joystick am Parallelport.
j muß entweder 0 oder 1 sein.

Die Bitmap enthält folgende Bits:

Bit 0=1: Joystick wird gerade nach oben gedrückt
Bit 1=1: Joystick wird nach unten gedrückt
Bit 2=1: Joystick wird gerade nach links bewegt
Bit 3=1: Joystick wird nach rechts bewegt
Bit 4=1: Der Feuerknopf wurde gedrückt

Siehe auch:

@{" =Pjup              " link ffourjup}
@{" =Pjdown            " link ffourjdo}
@{" =Pjleft            " link ffourjle}
@{" =Pjright           " link ffourjri}
@{" =Pfire             " link ffourfir}

@endnode
@node ffourjri "Funktion: =Pjright"
flag=Pjright(j)

Entspricht Jright(j) eines normalen Joysticks. Pjright testet, ob der Joy-
stick im Parallelport nach rechts gedrückt wurde. Wenn ja, ist flag gleich
True (-1), sonst False (0).

Siehe auch:

@{" =Pjoy              " link ffourjoy}
@{" =Pjup              " link ffourjup}
@{" =Pjdown            " link ffourjdo}
@{" =Pjleft            " link ffourjle}
@{" =Pfire             " link ffourfir}

@endnode
@node ffourjup "Funktion: =Pjup"
flag=Pjup(j)

Entspricht Jup(j) eines normalen Joysticks. Pjup testet, ob der Joystick
im Parallelport nach oben gedrückt wurde. Wenn ja, ist flag gleich
True (-1), sonst False (0).

Siehe auch:

@{" =Pjoy              " link ffourjoy}
@{" =Pjdown            " link ffourjdo}
@{" =Pjleft            " link ffourjle}
@{" =Pjright           " link ffourjri}
@{" =Pfire             " link ffourfir}

@endnode
@node fptcinst "Funktion: =Pt Cinstr"
num=Pt Cinstr(chan)

Pt Cinstr gibt die Nummer des Instruments zurück, das gerade auf dem
Musikkanal chan gespielt wird. num ist daher immer ein Wert zwischen 0 und
31, wobei 0 bedeutet, daß gerade kein Instrument angespielt wird.

Siehe auch:

@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}
@{" =Pt Cnote          " link fptcnote}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}

@endnode
@node fptcnote "Funktion: =Pt Cnote"
num=Pt Cnote(chan)

Pt Cnote gibt die Frequenz des gerade abgespielten Instruments auf dem
Musikkanal chan zurück.

Siehe auch:

@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}
@{" =Pt Cinstr         " link fptcinst}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}

@endnode
@node fptcpatt "Funktion: =Pt Cpattern"
songpos=Pt Cpattern

Diese Funktion gibt die aktuelle Pattern bzw. Songposition zurück. Diese
kann z.B verwendet werden, um ein Musikstück mit dem Pattern neuzustarten,
an dem es mit Pt Stop unterbrochen wurde.

Siehe auch:

@{" =Pt Cpos           " link fptcposi}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}

@endnode
@node fptcposi "Funktion: =Pt Cpos"
row=Pt Cpos

Diese Funktion gibt die aktuelle 'Zeile' des gerade abgespielten Patterns
zurück und kann zwischen 0 und 63 liegen.

Siehe auch:

@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}

@endnode
@node fptdatab "Funktion: =Pt Data Base"
address=Pt Data Base

Gibt die Startadresse der internen Datentabelle der Abspielroutine zurück.
Bitte nicht mutwillig dort hineinschreiben.

@endnode
@node fptinadr "Funktion: =Pt Instr Address"
address=Pt Instr Address(instnr)

Liefert die Startadresse eines Instruments der aktuellen Protracker-Musik.

Siehe auch:

@{" =Pt Instr Length   " link fptinlen}
@{" Pt Bank            " link cpt_bank}
@{" Pt Instr Play      " link cptinspl}

@endnode
@node fptinlen "Funktion: =Pt Instr Length"
length=Pt Instr Length(instnr)

Gibt die Länge des Instruments instnr aus.

Siehe auch:

@{" =Pt Instr Address  " link fptinadr}
@{" Pt Bank            " link cpt_bank}
@{" Pt Instr Play      " link cptinspl}

@endnode
@node fptsigna "Funktion: =Pt Signal"
signal=Pt Signal

Bei den Musiktrackern Soundtracker, Noisetracker, Startrekker oder
Protracker gibt es Effektbefehle, z.B um die Lautstärke einer Note zu
setzen oder für Portamento. Beispiel an einer Protracker Notenzeile:

00 C-1 1000 --- 0000 G-2 2000 --- 0000
   ^ ^ ^
   | | `--------------------------------------------.
   | `-------------------------.                    |
   `---------------.           |                    |
   Spielt die Note C in Oktave 1 mit dem Instrument 1.

Optional kann man Effekte angeben, wie z.B bei dieser Zeile hier:

00 C-1 1C20 --- 0F04 G-2 2E00 --- 0801
        ^^^      ^^^      ^^^      ^^^
Lautstärke $20  Geschw.  Filter    \|/
         (=32)  4 VBLs   aus        Y
 .----------------------------------'
 |
Das ist jetzt ein Effekt, der keine Wirkung auf die Musik hat. Er wurde
unbenutzt gelassen, damit man die Musik mit irgendwelchen Ereignissen
synchronisieren kann. Die Zahl hinter der 8 wird direkt an Pt Signal über-
geben, wenn die Musik diese Stelle erreicht. (Achtung! Der Wert wird im
Protracker als Hexadezimalzahl eingegeben!)

So kann man z.B auf ein bestimmtes akustisches Signal warten, oder
Musiker-Bobs synchronisieren.

Liegt kein Signal an, wird der Wert 0 in die Variable signal übergeben.
Nach einer Abfrage des Pt Signal wird das Signal automatisch wieder ge-
löscht. Pt Signal kann maximal ein Signal auf einmal halten, d.h wenn das
letzte Signal noch nicht ausgelesen wurde, so überschreibt das nächste
Signal diesen Wert, und geht damit verloren.

Wird das Ende des Musikstücks erreicht, so wird automatisch das Signal $FF
gesendet.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Volume          " link cptvolum}
@{" Pt Voice           " link cptvoice}
@{" =Pt Vu             " link fptvumet}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}

@endnode
@node fptvumet "Funktion: =Pt Vu"
vol=Pt Vu(channel)

Erlaubt das Auslesen der Lautstärke des Kanals channel. Wenn eine Note
angespielt wurde, so liefert vol den Lautstärkenwert, sonst 0.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Volume          " link cptvolum}
@{" Pt Voice           " link cptvoice}
@{" =Pt Signal         " link fptsigna}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}

@endnode
@node fqarc    "Funktion: =Qarc"
angle=Qarc(deltax,deltay)

Diese Funktion gibt den Winkel zu einem Punkt mit der relativen Entfernung
deltax,deltay zurück. angle ist eine Zahl im selben Format, wie es bei
Qsin und Qcos angewendet wird. Das heißt, daß ein Winkel von 360 Grad dem
Wert 1024 entspricht. Weiterhin zeichnet sich diese Funktion dadurch aus,
daß sie *sehr* schnell und ziemlich genau ist.

Normalerweise wird Qarc für alle möglichen Arten von 'Ziel-auf' Routinen
verwendet, z.B um den Winkel von einem Spieler zu einem anderen zu bekom-
men, um eine Rakete auf ihn abzufeuern ;-)

Siehe auch:

@{" =Qsin              " link fqsine  }
@{" =Qcos              " link fqcosine}

@endnode
@node fqcosine "Funktion: =Qcos"
value=Qcos(angle,radius)

Dies ist eine Funktion, die die ursprüngliche Cosinus Funktion von AMOS
ersetzen soll. Sie ist schneller, und erlaubt es, den Wert gleich mit dem
Faktor radius zu mulitplizieren. Außerdem werden keine Mathematik-
Libraries benötigt. Allerdings wird der Winkel angle nicht wie bei der
normalen Winkelfunktionen im Bogen oder Gradmaß angegeben sondern hier
entspricht 360 Grad dem Wert 1024.

Siehe auch:

@{" =Qsin              " link fqsine  }
@{" =Qarc              " link fqarc   }

@endnode
@node fqrandom "Funktion: =Qrnd"
value=Qrnd(maxrnd)

Ist identisch zu der Rnd-Funktion, nur daß diese schneller ist.

@endnode
@node fqsine   "Funktion: =Qsin"
value=Qsin(angle,radius)

Dies ist eine Funktion, die die ursprüngliche Sinus Funktion von AMOS
ersetzen soll. Sie ist schneller, und erlaubt es, den Wert gleich mit dem
Faktor radius zu mulitplizieren. Außerdem werden keine Mathematik-
Libraries benötigt. Allerdings wird der Winkel angle nicht wie bei der
normalen Winkelfunktionen im Bogen oder Gradmaß angegeben sondern hier
entspricht 360 Grad dem Wert 1024.

Siehe auch:

@{" =Qcos              " link fqcosine}
@{" =Qarc              " link fqarc   }

@endnode
@node fqsquare "Funktion: =Qsqr"
root=Qsqr(value)

Zieht die Wurzel aus dem Wert value, arbeitet jedoch nur auf Integerbasis
und ist schneller als die AMOS Wurzelfunktion =Sqr.

@endnode
@node fcredval "Funktion: =Red Val"
r=Red Val(rgb)

Diese Funktion ermittelt den Rotanteil einer Farbe. Zusammen mit den
anderen Val-Funktionen läßt sich so eine Farbe in die einzelnen Teil
aufspalten.

Siehe auch:

@{" =Green Val         " link fcgreval}
@{" =Blue Val          " link fcbluval}
@{" =Glue Colour       " link fgluecol}

@endnode
@node frplcstr "Funktion: =Replacestr$"
newstr$=Replacestr$(s$,search$ To replace$)

Diese Funktion such in der Zeichenkette s$ nach allen Vorkommnissen von
search$ und ersetzt sie durch replace$.

Siehe auch:

@{" =Insstr$           " link finsstrg}
@{" =Cutstr$           " link fcutstrg}

@endnode
@node frgbtaga "Funktion: =Rgb To Rrggbb"
rrggbb=Rgb To Rrggbb(rgb)

Diese Funktion wandelt einen 12-Bit Farbwert in einen 24-Bit AGA-Farbwert
um. Dabei werden die fehlenden Bits durch Null-Bits ersetzt. In diesem
Farbformat kann man je für den Rot-, Grün- oder Blau-Anteil 256 verschie-
dene Farbwerte angeben, also insgesamt 16777216 verschiedene Werte.

Siehe auch:

@{" Rrggbb To Rgb      " link fagatrgb}

@endnode
@node fagatrgb "Funktion: =Rrggbb To Rgb"
rgb=Rrggbb To Rgb(rrggbb)

Die Funktion Rrggbb To Rgb wandelt einen 24-Bit Farbwert um, dabei gehen
die anderen 12-Bits natürlich verloren.

Siehe auch:

@{" Rgb To Rrggbb      " link frgbtaga}

@endnode
@node fscanstr "Funktion: =Scanstr$"
key$=Scanstr$(scancode)

Diese manchmal ganz hilfreiche Funktion wandelt einen Tastaturcode, den
man mit der AMOS-Funkion Scancode erhalten kann in einen String mit dem
Namen der Taste. Existiert für den Scancode keine Taste, so wird ein
leerer String zurückgegeben.

@endnode
@node fscrbitm "Funktion: =Scrn Bitmap"
bitmap=Scrn Bitmap

Ermittelt die Graphics-Bitmap Struktur des aktuellen AMOS Screens.

Siehe auch:

@{" =Scrn Rastport     " link fscrrast}
@{" =Scrn Layer        " link fscrlaye}
@{" =Scrn Layerinfo    " link fscrlayi}
@{" =Scrn Region       " link fscrregi}

@endnode
@node fscrlaye "Funktion: =Scrn Layer"
layer=Scrn Layer

Ermittelt die Graphics-Layer Struktur des aktuellen AMOS Screens.

Siehe auch:

@{" =Scrn Rastport     " link fscrrast}
@{" =Scrn Bitmap       " link fscrbitm}
@{" =Scrn Layerinfo    " link fscrlayi}
@{" =Scrn Region       " link fscrregi}

@endnode
@node fscrlayi "Funktion: =Scrn Layerinfo"
layerinfo=Scrn Layerinfo

Ermittelt die Graphics-LayerInfo Struktur des aktuellen AMOS Screens.

Siehe auch:

@{" =Scrn Rastport     " link fscrrast}
@{" =Scrn Bitmap       " link fscrbitm}
@{" =Scrn Layer        " link fscrlaye}
@{" =Scrn Region       " link fscrregi}

@endnode
@node fscrrast "Funktion: =Scrn Rastport"
rastport=Scrn Rastport

Ermittelt den Graphics-Rastport des aktuellen AMOS Screens.

Siehe auch:

@{" =Scrn Bitmap       " link fscrbitm}
@{" =Scrn Layer        " link fscrlaye}
@{" =Scrn Layerinfo    " link fscrlayi}
@{" =Scrn Region       " link fscrregi}

@endnode
@node fscrregi "Funktion: =Scrn Region"
region=Scrn Region

Ermittelt die Graphics-Region Struktur des aktuellen AMOS Screens.

Siehe auch:

@{" =Scrn Rastport     " link fscrrast}
@{" =Scrn Bitmap       " link fscrbitm}
@{" =Scrn Layer        " link fscrlaye}
@{" =Scrn Layerinfo    " link fscrlayi}

@endnode
@node fsgndeek "Funktion: =Sdeek"
value=Sdeek(address)

Die Sdeek-Funktion liest genau wie Deek ein @{" Wort " link dword} aus der GERADEN
Speicheradresse address. Jedoch anders als bei Deek wird Bit 15 als Vor-
zeichen gewertet, daher ergibt sich als Rückgabewert eine Zahl zwischen
-32678 und 32677. Diese Funktion wird unbedingt empfohlen, wenn Sie
negative Werte mit Doke in eine Speicherzelle schreiben und dann wieder
lesen wollen.

Siehe auch:

@{" =Speek             " link fsgnpeek}

@endnode
@node fsmousek "Funktion: =Smouse Key"
mk=Smouse Key

Liefert den Status der Maustasten in Port 1.

Bit
 0 Linke Maustaste
 1 Rechte Maustaste
 2 Mittlere Maustaste

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Y Smouse          " link fysmouse}
@{" Limit Smouse       " link climsmou}
@{" Smouse Speed       " link csmouspd}
@{" Smouse X           " link csmousex}
@{" Smouse Y           " link csmousey}

@endnode
@node fsgnpeek "Funktion: =Speek"
value=Speek(address)

Diese Funktion liest genau wie Peek ein @{" Byte " link dbyte} aus der Speicheradresse
address. Jedoch anders als bei Peek wird Bit 7 als Vorzeichen gewertet,
daher ergibt sich als Rückgabewert eine Zahl zwischen -128 und 128.
Diese Funktion wird unbedingt empfohlen, wenn sie negative Werte mit Poke
in eine Speicherzelle schreiben und dann wieder lesen wollen.

Siehe auch:

@{" =Sdeek             " link fsgndeek}

@endnode
@node fspliact "Funktion: =Splinters Active"
amount=Splinters Active

Diese Funktion gibt zurück, wieviele Splinter sich im Moment noch bewegen.
Dies kann benutzt werden, um zu ermitteln, wann die Animation zu Ende ist.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}

@endnode
@node ftooltyp "Funktion: =Tool Types$"
tools$=Tool Types$(filename$)

Mit Hilfe dieser Funktion können die Tool Types eines Icons ermittelt wer-
den. Dabei muß der Dateiname filename$ OHNE ".info" angegeben werden! Die
einzelnen Tool Types werden im String tools$ mit einem Linefeed-Zeichen
(Chr$(10)) voneinander getrennt gespeichert. Dadurch können sie ganz
einfach mit Print ausgegeben werden.
Den Namen des eigenen Programms bekommen Sie mit Command Name$.

Siehe auch:

@{" =Command Name$     " link fcomname}

@endnode
@node fturpoin "Funktion: =Turbo Point"
c=Turbo Point(x,y)

Diese Funktion frägt die Farbe des Punktes an den Koordinaten x,y ab. Sie
ist um ein vielfaches schneller als der normale Point-Befehl.

Siehe auch:

@{" Turbo Plot         " link cturplot}

@endnode
@node fvalclip "Funktion: =Vclip"
newval=Vclip(val,lower To upper)

Die Vclip-Funktion funktioniert wie ein Min(Max(val,lower),upper)-Ausdruck
der den Wert val zwischen seinen unteren und oberen Grenzen limitiert.

Siehe auch:

@{" =Vin               " link fvaluein}
@{" =Vmod              " link fvalmodu}

@endnode
@node fvecrotx "Funktion: =Vec Rot X"
newx=Vec Rot X(x,y,z)
newx=Vec Rot X

Diese Funktion berechnet die X-Koordinate, die aus der Vektorrotation des
dreidimensionalen Punktes x,y,z um die drei Achsen entsteht. Diese
Koordinate wird automatisch von 3D auf 2D mit Hilfe der Entfernung
projeziert.

Beim Aufruf der Funktion mit den Parametern x,y,z, werden alle drei neuen
Koordinaten berechnet, auch der y,z Punkt. Brauchen Sie auch die
Y-Koordinate, dann schreiben Sie beim Vec Rot Y-Befehl NICHT die Parameter
x,y,z. Gleiches gilt für Vec Rot Z.

Wurde zuerst Vec Rot Y aufgerufen, so können die Parameter bei Vec Rot X
weglassen werden.

Siehe auch:

@{" =Vec Rot Y         " link fvecroty}
@{" =Vec Rot Z         " link fvecrotz}
@{" Vec Rot Pos        " link cvecrpos}
@{" Vec Rot Angles     " link cvecrang}
@{" Vec Rot Precalc    " link cvecrpre}

@endnode
@node fvecroty "Funktion: =Vec Rot Y"
newy=Vec Rot Y(x,y,z)
newy=Vec Rot Y

Ermittelt die neue Y-Koordinate nach der Rotation. Für Näheres siehe
Vec Rot X.

Siehe auch:

@{" =Vec Rot X         " link fvecrotx}
@{" =Vec Rot Z         " link fvecrotz}
@{" Vec Rot Pos        " link cvecrpos}
@{" Vec Rot Angles     " link cvecrang}
@{" Vec Rot Precalc    " link cvecrpre}

@endnode
@node fvecrotz "Funktion: =Vec Rot Z"
newz=Vec Rot Z(x,y,z)
newz=Vec Rot Z

Ermittelt die neue Z-Koordinate nach der Rotation, wobei jedoch die
Kamera-Z-Position bereits dazugezählt wurde. Die Z-Koordinate kann ver-
wendet werden, um Objekte nach der Entfernung zu sortieren, oder um eine
Pseudo-Helligkeitsberechnung durchzuführen.

Näheres zu den Synti oder den Parametern siehe Vec Rot X.

Siehe auch:

@{" =Vec Rot X         " link fvecrotx}
@{" =Vec Rot Y         " link fvecroty}
@{" Vec Rot Pos        " link cvecrpos}
@{" Vec Rot Angles     " link cvecrang}
@{" Vec Rot Precalc    " link cvecrpre}

@endnode
@node fvaluein "Funktion: =Vin"
flag=Vin(val,lower To upper)

Die Vin-Funktion erstellt eine exquisite Weinflasche... haha ;-)

Ne, eigentlich überprüft diese Funktion, ob ein Wert innerhalb von lower
und upper liegt. Ist dies der Fall, so gibt flag True (-1) zurück,
ansonsten False (0).

Siehe auch:

@{" =Vclip             " link fvalclip}
@{" =Vmod              " link fvalmodu}

@endnode
@node fvalmodu "Funktion: =Vmod"
newval=Vmod(val,upper)
newval=Vmod(val,lower To upper)

Vmod begrenzt einen Wert val auf die unterer und obere Grenze. Jedoch tut
diese Funktion das auf eine andere Weise verglichen mit Vclip. Wenn der
Wert val die Grenze upper um 1 übersteigt, so beträgt newval=lower, wenn
er um 2 größer ist, liegt der neue Wert bei lower+1. Geht der Wert tiefer
als lower um 1, wird der neue Wert upper annehmen, während er bei 2 unter
lower bei upper-1 liegen wird usw.

Das heißt, daß diese Funktion nicht genauso arbeitet wie

Add val,delta,lower To upper

Wenn lower weggelassen wird, wird 0 als untere Grenze angenommen.

Beispiele:

Print Vmod(100,50 To 150) ergibt 100 (sollte klar sein).

Print Vmod(151,50 To 150) ergibt 50.

Print Vmod(152,50 To 150) ergibt 51.

Print Vmod(49,50 To 150) ergibt 150.

Print Vmod(0,50 To 150) ergibt 101.

Siehe auch:

@{" =Vclip             " link fvalclip}
@{" =Vin               " link fvaluein}

@endnode
@node fwrdswap "Funktion: =Wordswap"
newval=Wordswap(value)

Vertauscht das obere und das untere @{" Wort " link dword} eines Wertes.

@endnode
@node fxraster "Funktion: =X Raster"
x=X Raster

Diese Funktion gibt die aktuelle X-Position des Rasterstrahls als Hard-
warekoordinate zurück.

Siehe auch:

@{" Raster Wait        " link craswait}
@{" =Y Raster          " link fyraster}

@endnode
@node fxsmouse "Funktion: =X Smouse"
xpos=X Smouse

Liefert die X-Koordinate der zweiten Maus.

Siehe auch:

@{" =Y Smouse          " link fysmouse}
@{" =Smouse Key        " link fsmousek}
@{" Limit Smouse       " link climsmou}
@{" Smouse Speed       " link csmouspd}
@{" Smouse X           " link csmousex}
@{" Smouse Y           " link csmousey}

@endnode
@node fextfire "Funktion: =Xfire"
flag=Xfire(port,button)

Diese Funktion liefert den Status eines möglicherweise vorhanden zweiten
Feuerknopfes des Steuerknüppels oder Joypads in Port Nummer port. Wenn
die lowlevel.library vorhanden ist, dann lassen sich sogar alle Knöpfe
des CD³² Gamepads abfragen. Diese Library wird ab 3.1 ausgeliefert,
funktioniert aber auch auf Kickstart 2.0.

Mögliche Werte für den Parameter button:

0: Dies ist der normale, bei jedem Joystick vorhandene Feuerknopf.
1: Zweiter Feuerknopf eines Joysticks oder der blaue Knopf eines Gamepads.

2: Gelber Feuerknopf auf dem CD³² Controller
3: Grüner Feuerknopf
4: Reverse-Taste des Gamepads
5: Forward-Taste am Joypad
6: Play/Pause-Taste

Die Abfragemöglichkeiten von 2 bis 6 funktionieren nur mit vorhanderner
lowlevel.library. Wenn diese nicht geöffnet werden kann, erhalten Sie eine
Fehlermeldung.

@endnode
@node fyraster "Funktion: =Y Raster"
y=Y Raster

Y Raster gibt die aktuelle Y-Position des Rasterstrahls zurück. Diese
Funktion kann benutzt werden, um die Dauer eines Programmteils herauszu-
finden.

Siehe auch:

@{" Raster Wait        " link craswait}
@{" =X Raster          " link fxraster}

@endnode
@node fysmouse "Funktion: =Y Smouse"
ypos=Y Smouse

Liefert die Y-Koordinate der zweiten Maus.

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Smouse Key        " link fsmousek}
@{" Limit Smouse       " link climsmou}
@{" Smouse Speed       " link csmouspd}
@{" Smouse X           " link csmousex}
@{" Smouse Y           " link csmousey}

@endnode
@node camcafaa "Befehl: Amcaf Aga Notation"
Amcaf Aga Notation On
Amcaf Aga Notation Off

Normalerweise verlangen Amcaf-Befehle, die etwas mit Farbe zu tun haben
einen normalen 12-Bit Farbwert im Format $RGB. Seit dem @{" A4000/A1200 " link dagaamiga} gibt
es aber auch 24-Bit Farbwerte im Format $RRGGBB. Nach dem Aufruf von
Amcaf Aga Notation On verwenden alle Befehle und Funktionen nur noch Farb-
werte mit 24-Bit, ausgenommen @{" Rrggbb To Rgb " link fagatrgb} und @{" Rgb To Rrggbb " link frgbtaga}.
Der Defaultwert ist 12-Bit.

@endnode
@node caudfree "Befehl: Audio Free"
Audio Free

Mit Audio Free können Sie bereits reservierte Audiokanäle wieder frei-
geben.

Siehe auch:

@{" Audio Lock         " link caudlock}

@endnode
@node caudlock "Befehl: Audio Lock"
Audio Lock

Wenn man AMOS startet, dann wird das audio.device nicht 'informiert', das
AMOS die Soundkanäle haben will. Dadurch können andere Programme, die im
Hintergrund laufen, jederzeit einen Sound abspielen und damit das AMOS
Soundsystem durcheinander zubringen. Um das zu verhindern kann man sich
mit dem Befehl Audio Lock die Soundkanäle reservieren. Da AMOS aber einen
Bug hat, muß man so vorgehen:

Extremove 1 : Rem Entfernt die Music-Extension
Trap Audio Lock : Rem Reserviert die Audio-Kanäle
ERR=Errtrap : Rem Überprüft, ob Audio Lock erfolgreich war
Extreinit 1 : Rem Meldet die Music-Extension wieder an
Extdefault 1 : Rem Ruft die Default-Routine der Music-Extension auf

Diese Routine sollte so früh wie möglich aufgerufen werden, BEVOR sie
Musik oder Sounds benutzen.

Falls die Audiokanäle bereits einem anderen Programm benutzt werden, ent-
hält ERR eine Fehlernummer, sonst 0.

Um die Kanäle wieder freizugeben, muß Audio Free eingegeben werden.

Siehe auch:

@{" Audio Free         " link caudfree}
@{" Extremove          " link cextremo}
@{" Extreinit          " link cextrein}
@{" Extdefault         " link cextdefa}

@endnode
@node cbcodadd "Befehl: Bank Code Add"
Bank Code Add.b code,bank
Bank Code Add.b code,startaddress To endaddress
Bank Code Add.w code,bank
Bank Code Add.w code,startaddress To endaddress

Verschlüsselt die Bank mit der Nummer bank mit dem Code code. Um die Bank
zu entschlüsseln, muß die Anweisung mit dem negativen Code eingeben
werden.

Bemerkung: Diese Verschlüsselung arbeitet mit einer Addition mit Überlauf
und ist daher leicht zu entschlüsseln.

Siehe auch:

@{" Bank Code Xor.y    " link cbcodxor}
@{" Bank Code Mix.y    " link cbcodmix}

@endnode
@node cbcodmix "Befehl: Bank Code Mix"
Bank Code Mix.b code,bank
Bank Code Mix.b code,startaddress To endaddress
Bank Code Mix.w code,bank
Bank Code Mix.w code,startaddress To endaddress

Die dritte Möglichkeit, eine Bank zu kodieren ist mit Bank Code Mix. Mit
diesem Befehl kodierte Banks, dürften schwer bis unmöglich zu knacken
sein. Um eine Bank zu entschlüsseln, muß, wie bei Bank Code Xor auch, der
selbe Code eingeben werden.

Siehe auch:

@{" Bank Code Add.y    " link cbcodadd}
@{" Bank Code Xor.y    " link cbcodxor}

@endnode
@node cbcodrol "Befehl: Bank Code Rol"
Bank Code Rol.b code,bank
Bank Code Rol.b code,startaddress To endaddress
Bank Code Rol.w code,bank
Bank Code Rol.w code,startaddress To endaddress

Diese Befehle eignen sich weniger zum Kodieren von Banks, als zum Erzeugen
schöner Grafikeffekte. Es werden alle Bits im Byte/Wort um code nach links
verschoben (Rol=RotateLeft). Logischerweise darf code nur Werte von 1 bis
7 bei '.b' und von 1 bis 15 bei '.w' annehmen. Um eine Bank zu dekodieren,
muß entweder der negative Code oder die Anweisung Bank Code Ror mit dem
selben Code verwendet werden.

Siehe auch:

@{" Bank Code Ror.y    " link cbcodror}

@endnode
@node cbcodror "Befehl: Bank Code Ror"
Bank Code Ror.b code,bank
Bank Code Ror.b code,startaddress To endaddress
Bank Code Ror.w code,bank
Bank Code Ror.w code,startaddress To endaddress

Entspricht Bank Code Rol mit dem Unterschied, daß die Bits nicht nach
links sondern nach rechts verschoben werden.

Siehe auch:

@{" Bank Code Rol.y    " link cbcodrol}

@endnode
@node cbcodxor "Befehl: Bank Code Xor"
Bank Code Xor.b code,bank
Bank Code Xor.b code,startaddress To endaddress
Bank Code Xor.w code,bank
Bank Code Xor.w code,startaddress To endaddress

Bank Code Xor verschlüsselt eine Bank ähnlich wie Bank Code Add, jedoch
mit einem anderen Algorythmus. Hier wird jedes Byte/Wort der Bank mit dem
"logischen exlusiv oder" verknüpft. Um die Bank zu entschlüsseln, muß die
SELBE Anweisung mit dem SELBEN Code verwendet werden.
Bemerkung: Xor-Codierungen sind sehr nicht so leicht ohne den richtigen
Code zu knacken. Gute Codes sind $AA und $55.

Siehe auch:

@{" Bank Code Add.y    " link cbcodadd}
@{" Bank Code Mix.y    " link cbcodmix}

@endnode
@node cbnkcopy "Befehl: Bank Copy"
Bank Copy sourcebank To targetbank
Bank Copy startaddress,endaddress To targetbank

Erstellt eine exakte Kopie der Bank sourcebank, die in der Bank targetbank
abgesichert wird. Die zweite Version des Befehls kopiert nur einen Teil
der Quellbank in die Zielbank, hierbei wird eine @{" 'Work'-Bank " link dtemporaer} erstellt.

@endnode
@node cbnkdltd "Befehl: Bank Delta Decode"
Bank Delta Decode bank
Bank Delta Decode startaddress To endaddress

Diese Befehle entschlüsseln einen zuvor Delta-codierte Speicherbereich.
Nähere Erläuterungen über das Delta-Verfahren finden Sie bei
Bank Delta Encode.

Siehe auch:

@{" Bank Delta Encode  " link cbnkdlte}

@endnode
@node cbnkdlte "Befehl: Bank Delta Encode"
Bank Delta Encode bank
Bank Delta Encode startaddress To endaddress

Bank Delta Encode verschlüsselt eine Speicherbank mit dem sogenannten
Delta-Algorithmus. Es ist zwar keine Packmethode, führt jedoch zu besseren
Packraten bei 8-bit Soundsamples. Delta Encoding speichert nur den
Unterschied zum vorherigen Byte ab, wodurch bestimmte Hüllkurvenmuster in
Samples leichter von den Packalgorithmen 'erkannt' werden.

Bei Protracker-Modules könnten sie

Pt Bank 3
Bank Delta Encode Pt Instr Address(1) To Start(3)+Length(3)

benutzen, um nur die Samples der Musik zu codieren und

Pt Bank 3
Bank Delta Decode Pt Instr Address(1) To Start(3)+Length(3)

um den Effekt wieder rückgängig zu machen.

Siehe auch:

@{" Bank Delta Decode  " link cbnkdltd}
 
@endnode 
@node cbnkname "Befehl: Bank Name"
Bank Name bank,name$

Gibt der Bank mit der Nummer bank den Namen name$, der maximal 8 Zeichen
betragen darf. Die meisten AMOS Befehle ignorieren diese Kennung, aber zum
Beispiel die Tracker-Befehle erwarten eine Bank mit dem Namen 'Tracker '.

Siehe auch:

@{" =Bank Name$        " link fbnkname}

@endnode
@node cbnkperm "Befehl: Bank Permanent"
Bank Permanent bank

Wenn Sie eine Bank als "Work" definiert haben, Sie sie aber doch noch
nachträglich @{" permanent " link dpermanent} im Speicher bzw. im Programm haben wollen, so
können Sie Bank Permanent benutzen. Dieser Befehl findet auch Verwendung
bei MED-Modulen, die mit dem AMOS Befehl Med Load nachgeladen worden sind
und bei Power- und Imploder-Entpackten Banks.

Siehe auch:

@{" Bank Temporary     " link cbnktemp}
@{" Dload              " link cfidload}
@{" Ppfromdisk         " link cppfrdsk}
@{" Imploder Load      " link cimpload}
@{" Imploder Unpack    " link cimpunpk}

@endnode
@node cbnkstre "Befehl: Bank Stretch"
Bank Stretch bank To length

Vergrößert die Bank mit der Nummer bank auf die angegebene Länge length.
Dabei ändert sich die Adresse der Bank! Dieser Befehl funktioniert nicht
mit @{" Icons- und Sprites-Banks " link diconbanks}.

@endnode
@node cbnktemp "Befehl: Bank Temporary"
Bank Temporary bank

Definiert eine Bank als @{" temporär " link dtemporaer}, das heißt sie wird vor jedem Start des
Programms oder bei Default gelöscht.

Siehe auch:

@{" Bank Permanent     " link cbnkperm}
@{" Wload              " link cfiwload}

@endnode
@node cbnkchip "Befehl: Bank To Chip"
Bank To Chip bank

Bank To Chip macht genau das Gegenteil von Bank To Fast. Er bewegt eine
Bank ins @{" Chip-Ram " link dchipram}. Auch hiernbei ändert sich die Anfangsadresse.

Siehe auch:

@{" Bank To Fast       " link cbnkfast}

@endnode
@node cbnkfast "Befehl: Bank To Fast"
Bank To Fast bank

Verschiebt eine Bank ins @{" Fast-Ram " link dfastram}, falls welches vorhanden ist. Eine
natürliche Folge ist, daß die Bank eine neue Anfangsadresse erhält.
Bank To Fast funktioniert nicht mit @{" Icons- und Sprites-Banks " link diconbanks}.
Warnung: Versuchen Sie nicht ins Fast-Ram verschobene Musiken oder Sounds
abzuspielen!

Siehe auch:

@{" Bank To Chip       " link cbnkchip}

@endnode
@node cbcircle "Befehl: Bcircle"
Bcircle x,y,r,plane

Zeichnet eine Kreislinie um den Punkt x,y mit dem Radius r in der Bitplane
mit der Nummer plane. Diese Linie ist wirklich nur einen Pixel breit,
damit der Kreis mit Hilfe des @{" Blitters " link dblitter} gefüllt werden kann.

Siehe auch:

@{" Blitter Fill       " link cbltfill}

@endnode
@node cbltcler "Befehl: Blitter Clear"
Blitter Clear screen,bitplane
Blitter Clear screen,bitplane,x1,y1 To x2,y2

Der @{" Blitter " link dblitter} kann ebensogut zum Löschen von @{" Bitplanes " link dbitplane} verwendet werden.
Im Vergleich zu dem AMOS-Befehl Cls können hier gezielt einzelne Bitplanes
gelöscht werden.

Optional kann auch hier wieder ein rechteckiger Bereich angegeben werden.

Siehe auch:

@{" Blitter Copy       " link cbltcopy}
@{" Blitter Fill       " link cbltfill}
@{" Blitter Wait       " link cbltwait}
@{" =Blitter Busy      " link fbltbusy}

@endnode
@node cbltcopy "Befehl: Blitter Copy"
Blitter Copy sourcescreen,sourceplane To targetscreen,targetplane
Blitter Copy sourcescreen,sourceplane To targetscreen,targetplane,miniterm
Blitter Copy s1,p1,s2,p2 To targetscreen,targetplane
Blitter Copy s1,p1,s2,p2 To targetscreen,targetplane,miniterm
Blitter Copy s1,p1,s2,p2,s3,p3 To targetscreen,targetplane
Blitter Copy s1,p1,s2,p2,s3,p3 To targetscreen,targetplane,miniterm

Mit Hilfe von Blitter Copy können Sie eine @{" Bitplane " link dbitplane} eines Screens auf
eine andere oder die selbe Bitplane eines anderen oder des selben Screens
kopieren. Dazu wird der @{" Blitter " link dblitter} verwendet. Wenn zwei oder drei Quell-
screens und Quellbitplanes angegeben werden, so kann man diese logisch
miteinander verknüpfen und dann das Ergebnis in die Zielbitplane des
Zielscreens schreiben.

*** WICHTIG ***

1. Bevor Sie Blitter Copy benutzen, MÜSSEN Sie mit Hilfe von
   Blitter Copy Limit den Bereich angeben, der für den Kopiervorgang ver-
   wendet werden soll.
2. Achten Sie darauf, daß alle angegebenen Screens überhaupt über diesen
   Bereich verfügen, bzw. daß alle Screens groß genug.

Der optionale Parameter miniterm enthält eine Bitmaske, die angibt, wie die
Quellen miteinander verknüpft werden sollen.
Wird dieser Wert nicht angegeben gilt als default:

Eine Quelle : die Bitplane wird ganz normal kopiert (=%11110000).
Zwei Quellen: die Bitplanes werden miteinander verodert (=%11111100).
Drei Quellen: die Bitplanes werden miteinander verodert (=%11111110).

Häufig benutzte miniterm-Werte:

Quellen Plane 1, Plane 2 und Plane 3 entsprechen A,B und C.

1: %11110000: Kopieren der Bitplane    : A
1: %00001111: Invertieren der Bitplane : NOT A
2: %11111100: Planes verodern          : A OR B
2: %00000011: Planes verodern, invert. : NOT (A OR B)
2: %11000000: Planes verunden          : A AND B
2: %00111111: Planes verunden, invert. : NOT (A AND B)
2: %00111100: Planes verxodern         : A XOR B
2: %11000011: Planes verxodern, invert.: NOT (A XOR B)
3: %11111110: Alle Planes verodern     : A OR B OR C
3: %00000001: Alle Planes verodern, inv: NOT (A OR B OR C)
3: %10000000: Alle Planes verunden     : A AND B AND C
3: %01111111: Alle Planes verunden, inv: NOT (A AND B AND C)

Wollen Sie andere Verknüpfungen haben, so können Sie das durch aus-
probieren herausfinden (außer unschöner Bildschirmresultate kann nichts
passieren), oder, falls Sie mit der Materie der booleschen Algebra ver-
traut sind, lesen Sie @{" Blitter-Miniterme " link dblitterminiterms}.

Siehe auch:

@{" Blitter Copy Limit " link cbltcplm}
@{" Blitter Fill       " link cbltfill}
@{" Blitter Clear      " link cbltcler}
@{" Blitter Wait       " link cbltwait}
@{" =Blitter Busy      " link fbltbusy}

@endnode
@node cbltcplm "Befehl: Blitter Copy Limit"
Blitter Copy Limit screen
Blitter Copy Limit x1,y1 To x2,y2

Mit diesem Befehl setzen Sie den rechteckigen Bereich, der für
Blitter Copy verwendet wird. Wird als Parameter nur screen benutzt, so
wird automatisch die volle Größe des Bildschirms screen verwendet. Sonst
stellt x1,y1 die linke, obere Ecke und x2,y2 die rechte, untere Ecke des
Bereichs dar, auf dem der Kopier- und Verknüpfvorgang wirkt. Dieser gilt
für ALLE Screens, sodaß darauf geachtet werden muß, daß die verwendeten
Bildschirme mindestens so groß sind wie die rechte, untere Ecke des
angegebenen Bereichs.

Siehe auch:

@{" Blitter Copy       " link cbltcopy}

@endnode
@node cbltfill "Befehl: Blitter Fill"
Blitter Fill screen,bitplane
Blitter Fill screen,bitplane,x1,y1,x2,y2
Blitter Fill sourcescreen,sourceplane To targetscreen,targetplane
Blitter Fill ss,sp,x1,y1,x2,y2 To ts,tp

Mit Blitter Fill können Flächen gefüllt werden. Jedoch gibt es da ein paar
Einschränkungen: der Füllalgorithmus des @{" Blitters " link dblitter} ist extrem primitiv.
Er füllt nur die Lücke zwischen zwei Punkten einer horizontalen Zeile aus.
Aus diesem Grund müssen die Begrenzungen spezielle Linien sein, mit nur je
einem Punkt pro Zeile. Diese können entweder mit Turbo Draw oder mit
Bcircle erzeugt werden.

Der Parameter screen und bitplane geben den Bildschirm an, der die zu
füllende Fläche enthält. Optional kann ein rechteckiger Bereich angegeben
werden der die Koordinatenpaare x1,y1 und x2,y2 umschließt.

Weiterhin kann als Alternative ein zweiter Screen targetscreen und
eine zweite Bitplane targetplane angegeben werden, in den die gefüllten
Flächen geschrieben werden, dabei wird der Bildschirm sourcescreen, der
die Begrenzungslinien enthält, nicht verändert.

Wenn mehrere gefüllte Figuren gezeichnet werden sollen, die sich nicht
überlappen, so können zuerst alle Begrenzungslinien gezeichnet werden und
dann mit einem Durchgang alle Flächen gefüllt werden.

Der Blitter füllt immer von rechts unten nach links oben. Daher sollte man
um ein geflackere zu vermeiden nur auf Double Buffered oder unsichtbaren
Bildschirmen Flächen füllen, und vor einem Wait Vbl ein Blitter Wait ein-
fügen.

Siehe auch:

@{" Turbo Draw         " link cturdraw}
@{" Bcircle            " link cbcircle}
@{" Blitter Copy       " link cbltcopy}
@{" Blitter Clear      " link cbltcler}
@{" Blitter Wait       " link cbltwait}
@{" =Blitter Busy      " link fbltbusy}

@endnode
@node cbltwait "Befehl: Blitter Wait"
Blitter Wait

Dieser Befehl wartet, bis der @{" Blitter " link dblitter} seine Arbeit beendet hat. Dies muß
geschehen, wenn bevor sie z.B mit Print oder einem anderen Befehl, der
nicht den Blitter benutzt den Bildschirm manipulieren wollen, der gerade
vom Blitter verändert wird. Auch sollte vor Wait Vbl ein Blitter Wait
stehen.

Siehe auch:

@{" =Blitter Busy      " link fbltbusy}
@{" Blitter Copy       " link cbltcopy}
@{" Blitter Fill       " link cbltfill}
@{" Blitter Clear      " link cbltcler}

@endnode
@node cblkzoom "Befehl: Bzoom"
Bzoom s1,x1,y1,x2,y2 To s2,x3,y3,factor

Mit diesem Befehl können Sie einen Bildschirmbereich schnell auf ein
ganzzahliges Vielfaches vergrößern. Dabei wird die Grafik entweder
doppelt, viermal oder achtmal so breit und doppelt bis fünfzehnmal so
hoch. Der Befehl vergrößert den rechteckigen Bereich von x1,y1 bis x2,y2
auf dem Screen mit der Nummer s1 an die Anfangskoordinaten x3 und y3 auf
dem Screen s2. Die Endkoordinaten ergeben sich dabei direkt aus dem
Vergrößerungsfaktor.

Die Koordinaten x1 und x2 werden auf das nächste Vielfache von 8 gerundet,
x3 sogar auf ein Vielfaches von 16. Weiterhin müssen Sie darauf achten,
daß der zu vergrößernde Bereich auf den Zielbildschirm paßt, es wird kein
Clipping durchgeführt.

Der Parameter factor bestimmt, wie stark das Originalbild gezoomt werden
soll und ist in Nibbles unterteilt: $yx. y darf ein Wert zwischen 1 und F
sein, x muß entweder 1,2,4 oder 8 betragen.

Beispiele für factor:
$11 kopiert die Grafik, ohne sie zu vergrößern.
$22 zoomt die Grafik auf die vierfache Dimensionen. Die Originalpixel
    werden nun als 2*2 Pixel dargestellt.
$34 vergrößert die Grafik auf 3fache Höhe und vierfache Breite.

@endnode
@node cchbkfnt "Befehl: Change Bank Font"
Change Bank Font bank

Diese wirklich sinnvolle Anweisung setzt den Textfont des aktuellen Bild-
schirms auf den Font, der in der Speicherbank bank abgelegt ist.

Wird mit diesem Befehl der Font eingestellt, so wird keine
diskfont.library oder ähnliches benötigt. Sehr wichtig ist dieser Befehl,
für Programm, die auf HD installiert werden können, jedoch eigene Fonts
benutzen.

Bank Fonts können mit Hilfe der Make Bank Font-Anweisung erstellt werden.

Siehe auch:

@{" Make Bank Font     " link cmkbkfnt}
@{" Change Font        " link cchafont}

@endnode
@node cchafont "Befehl: Change Font"
Change Font "fontname.font"
Change Font "fontname.font",height
Change Font "fontname.font",height,style

Öffnet einen Font von der Diskette. Dieser wird dann für künftige Textaus-
gaben benutzt. height gibt dabei die Höhe des Zeichensatzes an, wird er
weggelassen, wird 8 dafür angenommen. Der Parameter style wird nur in
wenigen Fällen benötigt, er gibt an, welcher Stil des Zeichensatzs ge-
laden werden soll (siehe Set Text).

Seit OS 2.0 ist es möglich, auch mehrfarbige Fonts zu benutzen. Kickstart
1.3 Besitzer, die DPaint besitzen, können das beigelieferte Programm
ColorText benutzen, um die graphics.library zu patchen. OS 2.0 Benutzer
finden auf der Fonts-Diskette noch eine andere Version der
diskfont.library (Länge=51200 Bytes). Diese Version kann jeden Font be-
liebig skalieren, d.h es ist jede Größe möglich.

Wenn Sie viele Fonts benutzen, sollten Sie regelmäßig den Befehl
@{" Flush Libs " link cflushli} aufrufen, um die alten Zeichensätze aus dem Speicher zu
löschen.

Mit dem Befehl Make Bank Font können sie diesen Font dann in eine
Speicherbank umwandeln, sodaß die diskfont.library und der Font nicht mehr
auf Diskette gebraucht wird.

Mit einem weiteren Befehl, kann der Font verändert werden, den die
Anweisung Print verwendet, dieser lautet Change Print Font.

Siehe auch:

@{" =Font Style        " link ffontsty}
@{" Make Bank Font     " link cmkbkfnt}
@{" Change Bank Font   " link cchbkfnt}
@{" Change Print Font  " link cchprfnt}

@endnode
@node cchprfnt "Befehl: Change Print Font"
Change Print Font bank

Change Print Font ändert den Zeichensatz, mit dem der Print-Befehl
arbeitet. Dieser ist immer ein 8x8 Pixel großer Font mit 256 Zeichen, der
genau 2 KB (=2048 Bytes) lang ist. Der Parameter bank muß deswegen genau
auf so eine Speicherbank zeigen. So eine spezielle Print-Font-Bank können
Sie sich entweder per Hand erstellen (Bank reservieren, 8 Bytes pro
Zeichen hineinschreiben), oder dazu den mit gelieferten Font-Editor be-
nutzen (AMOSPro_Accessories:Font8x8_Editor.AMOS) und dann mit Dload laden.

@endnode
@node ccongrey "Befehl: Convert Grey"
Convert Grey sourcescreen To targetscreen

Mit diesem Befehl können Sie einen beliebigen Screen in Graustufen
umrechnen, dabei werden auch @{" HAM- " link dham} und ExtraHalfBright-Bildschirme
unterstützt.
Das einzige was Sie machen müssen, ist den Screen zu öffnen, die Palette
einzustellen und den Befehl anzuwenden. Der Parameter sourcescreen gibt
an, welcher Screen eingegraut werden soll, und targetscreen enthält
die Nummer des Screen, auf den Graustufenbild geschrieben wird. Dabei ist
die Anzahl der Farben in targetscreen beliebig, nur ist es nicht sinnvoll
einen HAM-Bildschirm zu öffnen.

@endnode
@node ccrdbank "Befehl: Coords Bank"
Coords Bank bank,coords
Coords Bank bank

Reserviert die Speicherbank mit der Nummer bank für die Ablegung von
Koordinaten. Diese Banks werden z.B für Splinters verwendet. coords gibt
an, für wieviele Koordinaten maximal Speicher reserviert werden soll. Jede
Koordinate benötigt 4 Bytes. Wird dieser Parameter weggelassen, so wird
nur auf die angegebene Bank gewechselt, ohne sie zu löschen. So können Sie
zwischen vorberechneten Banken hin und her springen.

Siehe auch:

@{" Coords Read        " link ccrdbank}
@{" =Count Pixel       " link fcounpix}

@endnode
@node ccrdread "Befehl: Coords Read"
Coords Read screen,colour,x1,y1 To x2,y2,bank,mode

Dieser Befehl wird gebraucht, um die Koordinaten für die Splinters in eine
Bank einzulesen. Diese Speicherbank mit der Nummer bank muß vorher mit
Coords Bank definiert worden sein. Der Parameter screen gibt den Bild-
schirm an, auf dem sich die Punkte befinden. colour gibt die Hintergrund-
farbe an, die beim Herausnehmen außer acht gelassen werden soll. Die
Koordinatenpaare x1,y1 und x2,y2 schließen einen rechteckigen Bereich ein,
aus dem die Koordinaten gelesen werden. Das Argument mode kann entweder 0
oder 1 sein. Wird 0 eingegeben, so werden die Punkte in strikter Reihen-
folge Zeile für Zeile eingelesen. Ist mode jedoch 1, so werden die
Koordinaten durcheinandergewürfelt.

Siehe auch:

@{" Coords Bank        " link ccrdbank}
@{" =Count Pixel       " link fcounpix}

@endnode
@node cfidload "Befehl: Dload"
Dload file$,bank

Genau wie Wload lädt diese Anweisung eine Datei in den Speicher, jedoch
als @{" permanente " link dpermanent} "Datas"-Bank.

Siehe auch:

@{" Wload              " link cfiwload}
@{" Bank Permanent     " link cbnkperm}

@endnode
@node cfidsave "Befehl: Dsave"
Dsave file$,bank

Dsave entspricht exakt Wsave in jeder hinsicht.

Siehe auch:

@{" Wsave              " link cfiwsave}

@endnode
@node cexamdir "Befehl: Examine Dir"
Examine Dir directory$

Dieser Befehl besorgt sich Informationen über das Verzeichnis directory$.
Zusätzlich kann der Inhalt des Verzeichnisses mit Examine Next$ abgefragt
werden.

Siehe auch:

@{" =Examine Next$     " link fexanext}
@{" Examine Stop       " link cexastop}
@{" =Object Name$      " link fobjname}
@{" =Object Type       " link fobjtype}
@{" =Object Size       " link fobjsize}
@{" =Object Blocks     " link fobjblks}
@{" =Object Protection " link fobjprot}
@{" =Object Time       " link fobjtime}
@{" =Object Date       " link fobjdate}
@{" =Object Comment$   " link fobjcomm}

@endnode
@node cexamobj "Befehl: Examine Object"
Examine Object file$

Examine Object beschafft sich Informationen über das @{" Objekt " link dobject} mit dem Na-
men file$. Diese Daten können dann mit den File-Funktion abgefragt werden,
dazu müssen die Funktionen ohne Parameter aufgerufen werden.

Siehe auch:

@{" =Object Name$      " link fobjname}
@{" =Object Type       " link fobjtype}
@{" =Object Size       " link fobjsize}
@{" =Object Blocks     " link fobjblks}
@{" =Object Protection " link fobjprot}
@{" =Object Time       " link fobjtime}
@{" =Object Date       " link fobjdate}
@{" =Object Comment$   " link fobjcomm}

@endnode
@node cexastop "Befehl: Examine Stop"
Examine Stop

Bricht das Lesen eines Verzeichnisses vorzeitig ab. Es dürfen jetzt keine
weiteren Examine Next$-Anweisungen folgen.

Siehe auch:

@{" Examine Dir        " link cexamdir}
@{" =Examine Next$     " link fexanext}

@endnode
@node cexchbob "Command: Exchange Bob"
Exchange Bob i1,i2

Dieser Befehl vertauscht einfach die beiden Bilder i1 und i2, die sich in
der aktuellen Spritebank befinden. i1 und i2 müssen gültige, bereits
existierende Bilder sein, sonst wird eine Fehlermeldung ausgegeben.

Siehe auch:

@{" Exchange Icon      " link cexchico}

@endnode
@node cexchico "Command: Exchange Icon"
Exchange Icon i1,i2

Dieser Befehl vertauscht einfach die beiden Bilder i1 und i2, die sich in
der aktuellen Iconbank befinden. i1 und i2 müssen gültige, bereits
existierende Bilder sein, sonst wird eine Fehlermeldung ausgegeben.

Siehe auch:

@{" Exchange Bob       " link cexchbob}

@endnode
@node cextdefa "Befehl: Extdefault"
Extdefault extnb

Dieser Befehl ist mehr was für Profis. Damit kann die Routine der Exten-
sion mit der Nummer extnb angesprungen werden, die normalerweise nur beim
Start oder bei dem Befehl Default aufgerufen wird. Meistens setzt diese
Routine die meisten internen Datenbasen auf die Grundwerte zurück.

Extdefault sollte aufgerufen werden, falls man die Extension nach dem
Ausklinken mit Extremove, mit dem Befehl Extreinit wiedereingebunden hat.

Ist keine Extension der Nummer extnb geladen, hat die Anweisung keine
Wirkung.

Siehe auch:

@{" Extreinit          " link cextrein}
@{" Extremove          " link cextremo}
@{" Audio Lock         " link caudlock}

@endnode
@node cextrein "Befehl: Extreinit"
Extreinit extnb

Dieser Befehl bewirkt einen Neustart der Extension mit der Nummer extnb.
Extreinit darf nur auf eine mit Extremove entfernte Extension angewandt
werden, sonst kann dies zu Speicherverlust oder Abstürzen führen.

Siehe auch:

@{" Extremove          " link cextremo}
@{" Extdefault         " link cextdefa}
@{" Audio Lock         " link caudlock}

@endnode
@node cextremo "Befehl: Extremove"
Extremove extnb

Der Befehl Extremove entfernt die Extension mit der Nummer extnb aus dem
Speicher, als ob AMOS verlassen worden wäre. Danach sollten kein Befehle
mehr folgen, die sich auf diese Extension beziehen. Da AMOS beim Verlassen
erneut versucht, die Extension auszuklinken, kann das zu einem Fehler
führen, daher sollte eine Extension nur sehr kurz abgeschaltet werden. Um
die Extension wieder zu aktivieren, muß Extreinit aufgerufen werden.

Siehe auch:

@{" Extreinit          " link cextrein}
@{" Extdefault         " link cextdefa}
@{" Audio Lock         " link caudlock}

@endnode
@node cfcircle "Befehl: Fcircle"
Fcircle x,y,r

Fcircle ist der in AMOS schmerzlich vermißte Befehl für einen ausgefüllten
Kreis. Die Parameter x,y geben dabei die Koordinaten des Mittelpunktes an,
r ist der Radius des Kreises.

Siehe auch:

@{" Fellipse           " link cfellips}

@endnode
@node cfellips "Befehl: Fellipse"
Fellipse x,y,rx,ry

Dieser Befehl zeichnet eine Ellipse, ähnlich dem AMOS Ellipse-Befehl, nur
daß diese ausgefüllt ist.

Siehe auch:

@{" Fcircle            " link cfcircle}

@endnode
@node cfilcopy "Befehl: File Copy"
File Copy sourcefile$ To targetfile$

Kopiert die Datei mit dem Namen sourcefile$ auf die Datei targetfile$. Mit
diesem Befehl ist es durchaus möglich, eine 3 MB Datei zu kopieren, auch
wenn man nur 100KB frei hat.

@endnode
@node cflushli "Befehl: Flush Libs"
Flush Libs

Dieser Befehl schließt alle Libraries, Fonts und Devices, die nicht mehr
gebraucht werden, und versucht so viel wie möglich Speicher zu beschaffen.
Dabei wird auch die Powerpacker- und die Diskfont.library 'weggespühlt'.

@endnode
@node chamfade "Befehl: Ham Fade Out"
Ham Fade Out screen

Da @{" HAM-Screens " link dham} nicht mit den normalen Fade-Befehlen ausgeblendet werden
können, hat AMCAF eine Weltsensation: Der HAM-Ausblender! Zwar kann man
nur ausblenden, aber das ist doch auch schon etwas, oder?

Ham Fade Out färbt den Bildschirm screen eine Stufe dunkler, nach
16-maligem Aufruf ist der Ham-Screen völlig schwarz.

Technisch ist es nicht ohne großen Rechenaufwand möglich, einen Ham-Screen
einzublenden, aber das Ausblenden funktioniert wie eine ein wenig umge-
baute Shade Bobs Routine.

@endnode
@node cimpload "Befehl: Imploader Load"
Imploder Load file$,bank

Diese Anweisung versucht, eine File-Imploder gepackte Datei zu laden und
gleichzeitig zu entpacken. Das Ergebnis liegt dann in Bank bank. Ist die
angegebene Datei nicht File-Imploder gepackt, so wird sie ganz normal
eingelesen. Ist der Parameter bank negativ, so wird die Datei ins
@{" Chip-Ram " link dchipram} entpackt.

Imploder Load braucht zum Entpacken kein Byte mehr Speicher als für die
entpackte Bank. Imploder Load ist außerdem noch extrem schnell.

Der File-Imploder gehört zum Turbo Imploder 4.0 Paket. Turbo Imploder 4.0
ist ein schneller Programmpacker geschrieben von Albert-Jan Brouwer und
Peter Struijk.

Der File-Imploder befindet sich auf der Installationsdiskette im C:-
Verzeichnis (AMCAF_Install:C/Fimp) mit der dazugehörigen Anleitung
(AMCAF_Install:C/Fimp.man).

Siehe auch:

@{" Imploder Unpack    " link cimpunpk}

@endnode
@node cimpunpk "Befehl: Imploder Unpack"
Imploder Unpack sbank to tbank

Entpackt die File-Imploder gepackte Datei, die in der Speicherbank sbank
steht auf die Bank tbank. Ist die Bank sbank keine File-Imploder-Bank
(zu Erkennen an dem ersten Langwort mit dem Inhalt 'IMP!'), so wird eine
Fehlermeldung zurückgegeben. Bei negativer tbank wird die Bank tbank ins
@{" Chip-Ram " link dchipram} gelegt.

Siehe auch:

@{" Imploder Load      " link cimpload}

@endnode
@node claunchp "Befehl: Launch"
Launch file$
Launch file$,stack

Der Launch-Befehl startet einen neuen Task der auf der Diskette unter dem
Namen file$ abgespeichert ist. Der optionale Parameter stack gibt die
Größe des Stapelspeichers an (default ist 4096).
Bemerkung: Manche Programme haben Probleme, wenn sie von AMOS aus ge-
startet werden, da sie ja weder von der Workbench noch vom CLI laufen.

@endnode
@node cmkbkfnt "Befehl: Make Bank Font"
Make Bank Font bank

Mit dieser mächtigen Anweisung können Sie beliebige Amiga-Fonts in eine
Memory Bank konservieren. Dabei wird der aktuelle Font des aktuellen
Screens in die Speicherbank bank geschrieben. Ändern können Sie den
aktuellen Textfont mit der Anweisung Change Font.

Diese Banks benötigen, einmal abgespeichert, keine 'diskfont.library' oder
sonstigen Zugriff auf Disk, sie können einfach mit dem Befehl
Change Bank Font den Font wieder aus der Bank 'laden'.

Siehe auch:

@{" Change Bank Font   " link cchbkfnt}
@{" Change Font        " link cchafont}

@endnode
@node climsmou "Befehl: Limit Smouse"
Limit Smouse
Limit Smouse x1,y1 To x2,y2

Legt den Bereich fest, in dem sich die Maus bewegen kann. Werden die
Parameter weggelassen, so wird der volle Bildbereich des aktuellen
Bildschirms verwendet.

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Y Smouse          " link fysmouse}
@{" =Smouse Key        " link fsmousek}
@{" Smouse Speed       " link csmouspd}
@{" Smouse X           " link csmousex}
@{" Smouse Y           " link csmousey}

@endnode
@node cpixmask "Befehl: Make Pix Mask"
Make Pix Mask screen,x1,y1 To x2,y2,bank

Nimmt einen Teil des Bildschirms heraus und speichert ihn in der Bank mit
der Nummer bank. Dieser Befehl kann verwendet werden, um eine Maske für
die Pix Shift-Anweisungen zu erzeugen. Wenn Sie diese Maske verwenden, so
müssen die Ausmaße der herausgenommenen Schablone exakt mit der Größe des
bei den Pix Shift-Befehlen angegebenen Bereichs übereinstimmen.

Siehe auch:

@{" Pix Shift Up       " link cpixshup}
@{" Pix Shift Down     " link cpixshdo}
@{" Pix Brighten       " link cpixbrig}
@{" Pix Darken         " link cpixdark}

@endnode
@node cmskcopy "Befehl: Mask Copy"
Mask Copy screen1,x1,y1,x2,y2 To screen2,x3,y3,maskaddress

Kopiert wie Screen Copy einen Teil eines Bildschirms auf einen anderen.
Dabei wird jedoch eine Maske verwendet. maskaddress gibt die Startadresse
der @{" Bitplane " link dbitplane} an.

@endnode
@node cnoopera "Befehl: Nop"
Nop

Dieser "Befehl" hat überhaupt keine Wirkung. Er dient lediglich, um
herauszufinden, wie schnell ein bestimmter Befehl ist.

Siehe auch:

@{" =Nfn               " link fnofunct}

@endnode
@node copenwor "Befehl: Open Workbench"
Open Workbench

Versucht die Workbench zu öffnen, falls diese geschlossen war. Die Work-
bench kann mit dem AMOS-Befehl Close Workbench geschlossen werden, um mehr
Speicher zu bekommen.

@endnode
@node cpgetscr "Befehl: Pal Get Screen"
Pal Get Screen palnr,screen

Diese Funktion speichert die vollständige Palette des Bildschirms mit der
Nummer screen im internen Palettenspeicher mit der Nummer palnr ab. palnr
muß im Bereich zwischen 0 und 7 liegen.

Dieser Befehl wird benutzt, um schnell eine bestimmte Palette eines Bild-
schirms zwischenzuspeichern. Um die Palette wieder zurück zu schreiben
können Sie den Befehl Pal Set Screen benutzen.

Siehe auch:

@{" Pal Set Screen     " link cpsetscr}
@{" Pal Set            " link cpsetcol}
@{" =Pal Get           " link fpgetcol}

@endnode
@node cpsetcol "Befehl: Pal Set"
Pal Set palnr,index,colour

Setzt den Farbeintrag mit der Nummer index der Palette palnr auf den
Farbwert colour. palnr muß zwischen 0 bis 7 liegen.

Siehe auch:

@{" Pal Set Screen     " link cpsetscr}
@{" Pal Get Screen     " link cpgetscr}
@{" =Pal Get           " link fpgetcol}

@endnode
@node cpsetscr "Befehl: Pal Set Screen"
Pal Set Screen palnr,screen

Schreibt die zuvor in der internen gespeicherten Palette palnr in den
Bildschirm mit der Nummer screen.

Siehe auch:

@{" Pal Get Screen     " link cpgetscr}
@{" Pal Set            " link cpsetcol}
@{" =Pal Get           " link fpgetcol}

@endnode
@node cpspread "Befehl: Pal Spread"
Pal Spread c1,rgb1 To c2,rgb2

Erzeugt einen weichen Übergang zwischen den beiden Farbwerten rgb1 und
rgb2, welcher dann im Farbbereich von c1 bis c2 abgespeichert wird.

@endnode
@node cpasptil "Befehl: Paste Ptile"
Paste Ptile x,y,t

Setzt ein Ptile an die Position x,y. Diese Koordinaten müssen als Block-
positionen angegeben werden, das heißt: Position 1,4 entspricht den
Screenkoordinaten 16,64.

Siehe auch:

@{" Ptile Bank         " link cptilbnk}

@endnode
@node cpixbrig "Befehl: Pix Brighten"
Pix Brighten screen,c1,c2,x1,y1 To x2,y2
Pix Brighten screen,c1,c2,x1,y1 To x2,y2,bank

Mit diesem Befehl können Sie die Farbwerte in dem rechteckigen Bereich
x1,y1 bis x2,y2 erhöhen. Der Parameter screen gibt dabei die Bildschirm-
nummer an, auf der dieser Bereich liegt. c1 und c2 bilden die Grenzfarben,
die zur Erhöhung herangezogen werden sollen, alle anderen Farben bleiben
unberührt.

Wird der optionale Parameter bank angegeben, so kann eine zuvor mit
Make Pix Mask berechnete Schablone verwendet werden.

Der Unterschied zu Pix Shift Up liegt darin, daß die Farbwerte c2 nicht
überschreiten.

Siehe auch:

@{" Pix Darken         " link cpixdark}
@{" Pix Shift Up       " link cpixshup}
@{" Pix Shift Down     " link cpixshdo}
@{" Make Pix Mask      " link cpixmask}

@endnode
@node cpixdark "Befehl: Pix Darken"
Pix Darken screen,c1,c2,x1,y1 To x2,y2
Pix Darken screen,c1,c2,x1,y1 To x2,y2,bank

Mit diesem Befehl können Sie die Farbwerte in dem rechteckigen Bereich
x1,y1 bis x2,y2 erniedrigen. Der Parameter screen gibt dabei die Bild-
schirmnummer an, auf der dieser Bereich liegt. c1 und c2 bilden die
Grenzfarben, die zur Erniedrigung herangezogen werden sollen, alle anderen
Farben bleiben unberührt.

Wird der optionale Parameter bank angegeben, so kann eine zuvor mit
Make Pix Mask berechnete Schablone verwendet werden.

Der Unterschied zu Pix Shift Down liegt darin, daß die Farbwerte c1 nicht
unterschreiten können.

Siehe auch:

@{" Pix Brighten       " link cpixbrig}
@{" Pix Shift Up       " link cpixshup}
@{" Pix Shift Down     " link cpixshdo}
@{" Make Pix Mask      " link cpixmask}

@endnode
@node cpixshdo "Befehl: Pix Shift Down"
Pix Shift Down screen,c1,c2,x1,y1 To x2,y2
Pix Shift Down screen,c1,c2,x1,y1 To x2,y2,bank

Mit diesem Befehl können Sie die Farbwerte in dem rechteckigen Bereich
x1,y1 bis x2,y2 erniedrigen. Der Parameter screen gibt dabei die Bild-
schirmnummer an, auf der dieser Bereich liegt. c1 und c2 bilden die
Grenzfarben, die zur Erniedrigung herangezogen werden sollen, alle anderen
Farben bleiben unberührt.

Wird der optionale Parameter bank angegeben, so kann eine zuvor mit
Make Pix Mask berechnete Schablone verwendet werden.

Der Unterschied zu Pix Darken liegt darin, daß die Farbwerte beim
unterschreiten von c1 wieder auf c2 gesetzt werden.

Siehe auch:

@{" Pix Shift Up       " link cpixshup}
@{" Pix Brighten       " link cpixbrig}
@{" Pix Darken         " link cpixdark}
@{" Make Pix Mask      " link cpixmask}

@endnode
@node cpixshup "Befehl: Pix Shift Up"
Pix Shift Up screen,c1,c2,x1,y1 To x2,y2
Pix Shift Up screen,c1,c2,x1,y1 To x2,y2,bank

Mit diesem Befehl können Sie die Farbwerte in dem rechteckigen Bereich
x1,y1 bis x2,y2 erhöhen. Der Parameter screen gibt dabei die Bildschirm-
nummer an, auf der dieser Bereich liegt. c1 und c2 bilden die Grenzfarben,
die zur Erhöhung herangezogen werden sollen, alle anderen Farben bleiben
unberührt.

Wird der optionale Parameter bank angegeben, so kann eine zuvor mit
Make Pix Mask berechnete Schablone verwendet werden.

Der Unterschied zu Pix Brighten liegt darin, daß die Farbwerte beim
Überschreiten von c2 wieder auf c1 gesetzt werden.

Siehe auch:

@{" Pix Shift Down     " link cpixshdo}
@{" Pix Brighten       " link cpixbrig}
@{" Pix Darken         " link cpixdark}
@{" Make Pix Mask      " link cpixmask}

@endnode
@node cppfrdsk "Befehl: Ppfromdisk"
Ppfromdisk file$,bank

Lädt die Datei file$ in den Speicher und entpackt sie, falls sie mit
PowerPacker gepackt wurde. Ist bank negativ, so wird die Datei ins
@{" Chip-Ram " link dchipram} entpackt. Ist die Datei Imploder-gepackt, so wird zum Befehl
Imploder Load gesprungen, ist die Datei nicht gepackt, wird sie mit Wload
geladen.

Siehe auch:

@{" Pptodisk           " link cpptodsk}
@{" Ppunpack           " link cppunpak}

@endnode
@node cpptodsk "Befehl: Pptodisk"
Pptodisk file$,bank
Pptodisk file$,bank,efficiency

Der Befehl Pptodisk packt und sichert die Bank mit der Nummer bank in die
Datei file$ ab. Der Parameter efficiency gibt an, wie stark die Bank ge-
packt werden soll und liegt zwischen 0 (sehr schnell) und 4 (am besten).
Für diesen und die zwei weiteren Befehle wird die powerpacker.library
benötigt.

Tut mir leid wegen dem Namen "Pptodisk" aber "Ppsave" war schon vergeben.

Siehe auch:

@{" Ppfromdisk         " link cppfrdsk}
@{" Ppunpack           " link cppunpak}

@endnode
@node cppunpak "Befehl: Ppunpack"
Ppunpack sourcebank To targetbank

Entpackt die mit PowerPacker gepackte Bank sourcebank in die Bank
targetbank. Ist targetbank negativ, so wird ins @{" Chip-Ram " link dchipram} entpackt.
Powergepackte Dateien erkennt man übrigens an dem Inhalt des ersten
@{" Langworts " link dlong} 'PP20'.

Siehe auch:

@{" Pptodisk           " link cpptodsk}
@{" Ppfromdisk         " link cppunpak}

@endnode
@node cprotobj "Befehl: Protect Object"
Protect Object pathfile$,prot

Setzt die @{" Schutzbits " link dprotflags} des @{" Objekts " link dobject} pathfile$ auf den Wert prot.

Siehe auch:

@{" =Object Protection " link fobjprot}

@endnode
@node cpt_bank "Befehl: Pt Bank"
Pt Bank bank

Dieser Befehl wird benutzt, wenn Sie Instrumente eines Musikstücks ab-
spielen wollen, jedoch die Bank des Musikstück nicht bereits mit Pt Play
angegeben haben.

Siehe auch:

@{" Pt Play            " link cpt_play}
@{" Pt Continue        " link cpt_cont}
@{" Pt Instr Play      " link cptinspl}
@{" =Pt Instr Address  " link fptinadr}
@{" =Pt Instr Length   " link fptinlen}

@endnode
@node cptspeed "Befehl: Pt Cia Speed"
Pt Cia Speed bpm

Mit diesem Befehl läßt sich die Geschwindigkeit einstellen, die für die
Wiedergabe des Protracker Modules verwendet werden soll. Trotzdem kann das
Musikstück seine Geschwindigkeit selbsttätig ändern, wenn es für
CIA-Timing konzipiert wurde. Der Parameter bpm gibt die Schläge pro Minute
an, oder falls dieser auf 0 gesetzt wird, so wird von CIA-Timing auf
Vertical Blank Timing umgeschaltet. Damit liegen die Beats per minute
exakt auf 125, und es werden auch CIA-Timing Einstellungen des Modules
ignoriert, falls dieses solche Geschwindigkeitsangaben enthält.

CIA-Timing wirft im Zusammenhang mit AMOS-Sprites ein paar Probleme auf,
die sich in periodisch auftauchendem Ruckeln widerspiegeln. Wenn mit
Sprites gearbeitet wird, sollten Sie auf VBL-Timing mit der Anweisung
Pt Cia Speed 0 stellen.

Wenn die Musik mit VBL-Timing nicht korrekt wiedergegeben wird, d.h zu
schnell oder zu langsam ist, so muß auf Cia-Timing gestellt werden. Dies
kann z.B mit Pt Cia Speed 125 vor der Pt Play Anweisung geschehen.

Der Defaultwert liegt bei CIA-Timing und 125 Bpm.

Siehe auch:

@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}
@{" Pt Volume          " link cptvolum}
@{" Pt Voice           " link cptvoice}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}

@endnode
@node cpt_cont "Befehl: Pt Continue"
Pt Continue

Startet die Protracker Musik von dem Punkt an wieder, wo sie zuvor mit dem
Pt Stop-Befehl angehalten wurde. Versuchen Sie niemals Pt Continue zu be-
nutzen, wenn Sie nicht vorher einmal die Musik mit Pt Play gestartet
haben.

Siehe auch:

@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Cia Speed       " link cptspeed}
@{" Pt Bank            " link cpt_bank}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}

@endnode
@node cptinspl "Befehl: Pt Instr Play"
Pt Instr Play instnr
Pt Instr Play voice,instnr
Pt Instr Play voice,instnr,freq

Die Pt Instr Play Anweisung spielt ein Instrument des aktuellen Protracker
Musikstücks ab.

Der Parameter voice bildet eine Bitmaske, die angibt, auf welchen Kanälen
das Instrument mit der Nummer instnr gespielt werden soll. Wird er wegge-
lassen, so wird der Soundeffekt auf allen 4 Kanälen wiedergegeben. instnr
muß zwischen 1 und 31 liegen. Das optionale Argument freq stellt die
Wiedergabefrequenz dar, die verwendet werden soll.

Wenn Sie ein Instrument wiederholend abspielen lassen wollen, dann geben
Sie einfach instnr als negativen Wert an. Die Lautstärke des Samples läßt
sich mit Pt Sam Volume einstellen.

Bevor Sie ein Instrument aus einem Musikstück abspielen können, müssen
Sie erstmal festlegen, in welcher Bank die Musik enthalten ist. Dies
geschieht entweder über Pt Bank oder Pt Play.

Siehe auch:

@{" Pt Bank            " link cpt_bank}
@{" Pt Play            " link cpt_play}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}
@{" Pt Sam Play        " link cptsampl}
@{" Pt Raw Play        " link cptrawpl}
@{" =Pt Instr Address  " link fptinadr}
@{" =Pt Instr Length   " link fptinlen}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}

@endnode
@node cpt_play "Befehl: Pt Play"
Pt Play bank
Pt Play bank,songpos

Pt Play startet ein Protracker-Musikstück, welches sich in der Speicher-
bank bank befinden muß. Optional kann auch eine Songposition angegeben
werden, ab der das Musikstück gespielt werden soll.

Vor dem Start des Musikstücks mit Pt Play sollte mit Pt Cia Speed angege-
ben werden, ob das Module mit Vertical Blank-Timing oder mit CIA-Timing
gespielt werden soll.

Mit Hilfe der Pt Instr Play Anweisung können ein beliebiges Instrument des
Musikstücks abspielen. Diese Methode hat den Vorteil, daß Sie ein be-
stimmtes Sample sowohl in der Musik als auch als Soundeffekt verwenden
können.

Wenn Sie nur die Instrumente benutzen wollen, ohne die Musik abzuspielen,
dann können Sie den Befehl Pt Bank benutzen.

Mit der Anweisung Pt Stop wird das Musikstück wieder abgeschaltet.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}
@{" Pt Volume          " link cptvolum}
@{" Pt Voice           " link cptvoice}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Bank            " link cpt_bank}
@{" =Pt Instr Address  " link fptinadr}
@{" =Pt Instr Length   " link fptinlen}
@{" =Pt Vu             " link fptvumet}
@{" =Pt Signal         " link fptsigna}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}
@{" =Pt Cinstr         " link fptcinst}
@{" =Pt Cnote          " link fptcnote}

@endnode
@node cptrawpl "Befehl: Pt Raw Play"
Pt Raw Play voice,address,length,freq

Dieser Befehl entspricht dem normalen AMOS-Befehl Sam Raw. Mit Pt Raw Play
können Sie ein Stückchen Speicher als Sample ausgeben. Der Parameter voice
beschreibt die Ausgabekanäle, address die Startaddresse des Samples im
Speicher, length die Länge in Bytes und freq die Wiedergabefrequenz in Hz.

Siehe auch:

@{" Pt Sam Play        " link cptsampl}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}

@endnode
@node cptsambk "Befehl: Pt Sam Bank"
Pt Sam Bank bank

Wenn Sie mit AMCAF Standard AMOS Samples ausgeben wollen, so müssen Sie
die Sample-Bank angeben, die die Soundeffekte enthält. Und genau dies tut
die Pt Sam Bank-Anweisung. bank gibt die Banknummer der AMOS-Samplebank
an.

Denken Sie daran, daß Sie auch Instrumente von Musikstücken direkt ab-
spielen können.

Siehe auch:

@{" Pt Sam Play        " link cptsampl}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Raw Play        " link cptrawpl}

@endnode
@node cptsamfr "Befehl: Pt Sam Freq"
Pt Sam Freq chan,freq

Dieser Befehl ändert die Frequenz des Samples, das gerade auf Kanal chan
gespielt wird auf den neuen Wert freq. Falls kein Sample gerade gespielt
wurde, hat dieser Befehl keinen Effekt, nichtmal eine Wirkung auf die
Protracker Musik, die möglicherweise gerade gespielt wird.

Siehe auch:

@{" Pt Sam Play        " link cptsampl}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Raw Play        " link cptrawpl}

@endnode
@node cptsampl "Befehl: Pt Sam Play"
Pt Sam Play samnr
Pt Sam Play voice,samnr
Pt Sam Play voice,samnr,freq

Die Pt Sam Play Anweisung spielt ein Sample aus einer AMOS SampleBank ab.
Der Vorteil zum normalen Sam Play Befehl liegt darin, daß sich die Sounds
mit der Protracker-Musik 'vertragen'. Weiterhin werden keine Noten ver-
schluckt, wie es AMOS bei beschleunigten Amigas macht.

Der Parameter voice bildet eine Bitmaske, die angibt, auf welchen Kanälen
das Sample mit der Nummer samnr gespielt werden soll. Wird er weggelassen,
so wird der Soundeffekt auf allen 4 Kanälen wiedergegeben. Das optionale
Argument freq stellt die Wiedergabefrequenz dar, die verwendet werden
soll.

Wenn Sie ein Sample wiederholend abspielen lassen wollen, dann geben Sie
einfach samnr als negativen Wert an. Die Lautstärke des Samples läßt sich
mit Pt Sam Volume einstellen.

Siehe auch:

@{" Pt Sam Bank        " link cptsambk}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Raw Play        " link cptrawpl}

@endnode
@node cptsamst "Befehl: Pt Sam Stop"
Pt Sam Stop voice

Stoppt einen Soundeffekt in den Kanälen, die über die Bitmap voice
angegeben wurden. Dies gilt sowohl für Samples, die mit Pt Sam Play, mit
Pt Instr Play als auch mit Pt Raw Play gestartet worden sind.

Siehe auch:

@{" Pt Sam Play        " link cptsampl}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Raw Play        " link cptrawpl}
@{" Pt Sam Bank        " link cptsambk}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Sam Volume      " link cptsamvo}

@endnode
@node cptsamvo "Befehl: Pt Sam Volume"
Pt Sam Volume volume
Pt Sam Volume voice,volume

Mit dieser Anweisung können Sie die Lautstärke für zukünftige Sampleaus-
gaben festlegen. Der Parameter volume muß im Bereich zwischen 0 und 64
liegen. Wird zusätzlich der Parameter voice angegeben, so wirkt der Befehl
sofort auf die im Moment gespielten Soundeffekte, jedoch nicht für
zukünftige Ausgaben.

Siehe auch:

@{" Pt Sam Play        " link cptsampl}
@{" Pt Sam Bank        " link cptsambk}
@{" Pt Sam Stop        " link cptsamst}
@{" Pt Instr Play      " link cptinspl}
@{" Pt Raw Play        " link cptrawpl}

@endnode
@node cpt_stop "Befehl: Pt Stop"
Pt Stop

Stoppt das Musikstück, das gerade gespielt wird.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Play            " link cpt_play}
@{" Pt Continue        " link cpt_cont}
@{" Pt Volume          " link cptvolum}
@{" Pt Voice           " link cptvoice}
@{" =Pt Vu             " link fptvumet}
@{" =Pt Signal         " link fptsigna}
@{" =Pt Cpattern       " link fptcpatt}
@{" =Pt Cpos           " link fptcposi}

@endnode
@node cptvoice "Befehl: Pt Voice"
Pt Voice bitmask

Mit diesem Befehl können Sie angeben, welche Kanäle gespielt werden
sollen, und welche frei bleiben sollen für z.B Soundeffekte.

Der Parameter bitmask enthält ähnlich wie bei dem AMOS Befehl Voice vier
Bits, die je einem Kanal zugeordnet werden. Wird ein Bit gesetzt, so ist
dieser Kanal zu hören. Pt Voice %1111 schaltet alle Soundkanäle ein.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}
@{" Pt Volume          " link cptvolum}
@{" =Pt Vu             " link fptvumet}
@{" =Pt Signal         " link fptsigna}

@endnode
@node cptvolum "Befehl: Pt Volume"
Pt Volume value

Mit der Pt Volume-Anweisung stellen Sie die Lautstärke des Musikstücks
ein. Der Parameter value darf im Bereich von 0 (stumm) bis 64 (volle
Lautstärke) angegeben werden.

Siehe auch:

@{" Pt Cia Speed       " link cptspeed}
@{" Pt Play            " link cpt_play}
@{" Pt Stop            " link cpt_stop}
@{" Pt Continue        " link cpt_cont}
@{" Pt Voice           " link cptvoice}
@{" =Pt Vu             " link fptvumet}
@{" =Pt Signal         " link fptsigna}

@endnode
@node cptilbnk "Befehl: Ptile Bank"
Ptile Bank bank

Stellt die eine Ptile-Bank ein. Eigentlich sollten Sie diesen Befehl ja
gar nicht lesen. Die Ptile-Befehle haben sich als zu sporadisch einsetzbar
erwiesen und so sind sie für Sie uninteressant.

Siehe auch:

@{" Paste Ptile        " link cpasptil}

@endnode
@node crainfad "Befehl: Rain Fade"
Rain Fade rainbownr,$RGB
Rain Fade rainbownr To targetrainbow

Mit dieser machtvollen Anweisung können Sie den Regenbogen mit der Nummer
rainbownr aus- oder umblenden. In der ersten Version von Rain Fade
können Sie die Zielfarbe $RGB angeben, zu der alle Farbwerte des Regen-
bogens umgeblendet werden. Die andere Version tönt genau zu den ent-
sprechenden Farben eines anderen Regenbogens mit der Nummer targetrainbow.

Rain Fade färbt schrittweise um. Daher brauchen Sie maximal 16 Aufrüfe,
bis die neuen Farben erreicht sind.

@endnode
@node craswait "Befehl: Raster Wait"
Raster Wait y
Raster Wait x,y

Diese Funktion kann benutzt werden um auf eine bestimmte Position des
Rasterstrahls zu warten. Die Parameter x und y bilden die Hardwarekoordi-
naten, ab denen das Programm weiterläuft.

Siehe auch:

@{" =X Raster          " link fxraster}
@{" =Y Raster          " link fyraster}

@endnode
@node crescomp "Befehl: Reset Computer"
Reset Computer

Diese gefährliche Anweisung führt einen Warmstart durch. Logischerweise
kehrt dieser Befehl nicht mehr zum Programm zurück.

@endnode
@node csetntsc "Befehl: Set Ntsc"
Set Ntsc

Dieser Befehl schaltet in den 60hz NTSC-Modus.

Siehe auch:

@{" Set Pal            " link cset_pal}

@endnode
@node cobjcomm "Befehl: Set Object Comment"
Set Object Comment pathfile$,comment$

Dieser Befehl gibt dem @{" Objekt " link dobject} pathfile$ den Kommentar comment$.

Siehe auch:

@{" =Object Comment$   " link fobjcomm}

@endnode
@node cobjdate "Befehl: Set Object Date"
Set Object Date pathfile$,date,time

Dieser Befehl ändert das Datum des @{" Objekts " link dobject} 'pathfile$' zu den angegebenen
Datums- und Zeitangaben.

Dieser Befehl funktioniert erst ab OS2.0.

Siehe auch:

@{" =Object Date       " link fobjdate}
@{" =Object Time       " link fobjtime}

@endnode
@node cset_pal "Befehl: Set Pal"
Set Pal

Set Pal kehrt in den normalen 50hz PAL-Modus zurück.

Siehe auch:

@{" Set Ntsc           " link csetntsc}

@endnode
@node csetrain "Befehl: Set Rain Colour"
Set Rain Colour rainbownr,newcolour

Mit Hilfe dieses Befehls können Sie die Farbnummer eines Regenbogen neu
setzen, die Sie mit Set Rainbow eingestellt haben. Damit können Sie
endlich die unsinnige Begrenzung auf die ersten 16 Farben aufheben und
alle 32 Farben ansprechen. Es gibt aber noch weitere Möglichkeiten! Ein
Farbwert von -63 läßt Sie das Hardwarescrollregister verändern! Damit
lassen sich Wasser- und Schwabbeleffekte erzeugen.

Für weitere Effekte müssen Sie den SetRainPatch installiert haben. Siehe
auch @{" Hinweise " link sdisks}.

Schauen Sie sich doch einfach mal die Beispielprogramme an.

@endnode
@node csetspri "Befehl: Set Sprite Priority"
Set Sprite Priority bitmap

Setzt die Priorität der Sprites in Bezug auf die Playfields auf den Wert
bitmap. bitmap hat folgendes Format:

Bits 0-2: 0=Alle Sprites befinden sich hinter dem Playfield 1
          1=Die Sprites 0-1 erscheinen vor Playfield 1
          2=Die Sprites 0-3 werden vor dem ersten Playfield abgebildet
          3=Die Sprites 0-5 erscheinen vor dem Playfield 1
          4=Alle Sprites befinden sich vor Playfield 1
Bits 3-5: 0=Alle Sprites befinden sich hinter dem Playfield 2
          1=Die Sprites 0-1 erscheinen vor Playfield 2
          2=Die Sprites 0-3 werden vor dem zweiten Playfield abgebildet
          3=Die Sprites 0-5 erscheinen vor dem Playfield 2
          4=Alle Sprites befinden sich vor Playfield 2

Zugegeben, ein bißchen verwirrend ist das schon, aber probieren geht über
studieren.

@endnode
@node cshbshdo "Befehl: Shade Bob Down"
Shade Bob Down screen,x,y,image

Diese Anweisung zeichnet ein Shade Bob auf den Bildschirm screen an den
Koordinaten x,y. Das Bob erniedrigt dabei die Farbwerte. image gibt die
Imagenummer der Spritebank an, welches für das Zeichnen des Bobs verwendet
werden soll. Es wird entweder die Maske des Objekts oder die erste
Bitplane dafür verwendet, je nach dem, wie Sie es mit der Anweisung
Shade Bob Mask eingestellt haben.

Denken Sie daran, daß dieser Befehl den Hot Spot der Bobimages
unterstützen.

Siehe auch:

@{" Shade Bob Up       " link cshbshup}
@{" Shade Bob Mask     " link cshbmask}
@{" Shade Bob Planes   " link cshbplan}

@endnode
@node cshbplan "Befehl: Shade Bob Planes"
Shade Bob Planes amount

Gibt an, durch wieviele @{" Bitplanes " link dbitplane} gecycelt werden soll. Dies kann ver-
wendet werden, um z.B eine in den hinteren Bitplanes befindliche Grafik
vor den Einflüssen der Shade Bobs zu schützen. amount gibt die Anzahl der
Bitplanes an, die für das Zeichen benutzt werden sollen und liegt im
Bereich von 1 bis 6.

@{" Shade Bob Up       " link cshbshup}
@{" Shade Bob Down     " link cshbshdo}
@{" Shade Bob Mask     " link cshbmask}

@endnode
@node cshbshup "Befehl: Shade Bob Up"
Shade Bob Up screen,x,y,image

Diese Anweisung zeichnet ein Shade Bob auf den Bildschirm screen an den
Koordinaten x,y. Das Bob erhöht dabei die Farbwerte. image gibt die
Imagenummer der Spritebank an, welches für das Zeichnen des Bobs verwendet
werden soll. Es wird entweder die Maske des Objekts oder die erste
Bitplane dafür verwendet, je nach dem, wie Sie es mit der Anweisung
Shade Bob Mask eingestellt haben.

Denken Sie daran, daß dieser Befehl den Hot Spot der Bobimages
unterstützen.

Siehe auch:

@{" Shade Bob Down     " link cshbshdo}
@{" Shade Bob Mask     " link cshbmask}
@{" Shade Bob Planes   " link cshbplan}

@endnode
@node cshadpix "Befehl: Shade Pix"
Shade Pix x,y
Shade Pix x,y,planes

Diese Anweisung erhöht den Farbwert am angegebenen Punkt x,y des aktuellen
Bildschirms. Wenn die höchste Farbe erreicht wurde, so wird zurück zur
Farbe 0 gestellt. Der optionale Parameter planes gibt an, in wievielen
@{" Bitplanes " link dbitplane} gecycelt werden soll und reicht somit von 1 bis 6.

@endnode
@node cshbmask "Befehl: Shade Bob Mask"
Shade Bob Mask flag

Mit Shade Bob Mask könnten Sie einstellen, ob die Maske eines Objekts oder
die erste Bitplane für das Zeichnen verwendet werden soll. Ist flag gleich
0, so wird Bitplane 0 für die Anweisungen Shade Bob Up und Shade Bob Down
benutzt, sonst wird die Maske verwendet.

Siehe auch:

@{" Shade Bob Up       " link cshbshup}
@{" Shade Bob Down     " link cshbshdo}
@{" Shade Bob Planes   " link cshbplan}

@endnode
@node csmouspd "Befehl: Smouse Speed"
Smouse Speed value

Setzt die Geschwindigkeit der Maus. Dabei gibt value an, um welche Potenz
von 2 die Maus verlangsamt werden soll. 0 ist die Maximalgeschwindigkeit
und 1 entspricht ungefähr der original Maus in AMOS. Höhere Werte als 4
sind nicht sinnvoll.

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Y Smouse          " link fysmouse}
@{" =Smouse Key        " link fsmousek}
@{" Limit Smouse       " link climsmou}
@{" Smouse X           " link csmousex}
@{" Smouse Y           " link csmousey}

@endnode
@node csmousex "Befehl: Smouse X"
Smouse X xpos

Setzt die X-Koordinate der Maus.

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Y Smouse          " link fysmouse}
@{" =Smouse Key        " link fsmousek}
@{" Limit Smouse       " link climsmou}
@{" Smouse Speed       " link csmouspd}
@{" Smouse Y           " link csmousey}

@endnode
@node csmousey "Befehl: Smouse Y"
Smouse Y ypos

Setzt die Y-Koordinate der Maus.

Siehe auch:

@{" =X Smouse          " link fxsmouse}
@{" =Y Smouse          " link fysmouse}
@{" =Smouse Key        " link fsmousek}
@{" Limit Smouse       " link climsmou}
@{" Smouse Speed       " link csmouspd}
@{" Smouse X           " link csmousex}

@endnode
@node csplback "Befehl: Splinters Back"
Splinters Back

Sichert den Hintergrund, wo demnächst die Splinter gezeichnet werden.

Siehe auch:

@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplbank "Befehl: Splinters Bank"
Splinters Bank bank,splinters

Reserviert eine Speicherbank für maximal splinters Splitter. Jeder
Splinter benötigt 22 Bytes.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplcolo "Befehl: Splinters Colour"
Splinters Colour bkcolour,planes

Stellt ein, welche Farbe zurückgelassen wird, wenn ein Splinter aus der
Grafik getrennt wird. Der Parameter planes beschreibt, wieviele Bitplanes
für die Splinters verwendet werden. Normalerweise sollte dieser Wert
gleich der Anzahl der verfügbaren Bitplanes gesetzt werden. Allerdings
kann es manchmal für spezielle Effekte sinnvoll sein, den Wert zu
erniedrigen.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplidel "Befehl: Splinters Single Del/Splinters Double Del"
Splinters Single Del
Splinters Double Del

Löscht die Splinters wieder vom Bildschirm. Da für das Löschen je nach
Bildschirmtyp entweder die vorletzten (bei Double Buffering) oder die
letzten (bei Single Buffering) verwendet werden, müssen Sie entweder
Splinters Double Del oder Splinters Single Del.

Der Hintergrund wird automatisch restauriert.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplindo "Befehl: Splinters Single Do/Splinters Double Do"
Splinters Single Do
Splinters Double Do

Löscht, zeichnet und bewegt die Splinters in einem Durchgang. Für Double-
Buffered-Screens muß der Befehl Splinters Double Do, für normale
Splinters Single Do verwendet werden. Wollen Sie dagen den Prozess per
Hand steuern, so müssen Sie die Befehle Splinters Single Del bzw.
Splinters Double Del, Splinters Move, Splinters Back und Splinters Draw in
dieser Reihenfolge ausführen.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node cspldraw "Befehl: Splinters Draw"
Splinters Draw

Zeichnet die Splinters auf den Bildschirm.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplfuel "Befehl: Splinters Fuel"
Splinters Fuel time

Gibt an, wielange die Splitter fliegen, bevor sie automatisch verschwin-
den. Der Parameter time gibt die Anzahl der Durchgänge an, die die
Splitter bewegt werden. Wird time auf 0 gesetzt, so fliegen die Splinter
so lange, bis sie den Bildschirm verlassen.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplgrav "Befehl: Splinters Gravity"
Splinters Gravity sx,sy

Stellt ein, in welche Richtung die Splinters driften. Dabei gibt sx an,
wieviel bei jedem Aufruf von Splinters Move die Geschwindigkeit in
X-Richtung erhöht oder erniedrigt werden soll. Gleiches gilt für sy, nur
daß diese auf die Y-Richtung wirkt.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplinit "Befehl: Splinters Init"
Splinters Init

Initialisiert die Splitter. Sie werden mit den Koordinaten und
Geschwindigkeiten gefüttert, die Sie vorher eingestellt haben.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node cspllimi "Befehl: Splinters Limit"
Splinters Limit
Splinters Limit x1,y1 To x2,y2

Begrenzt die Splinter auf einen bestimmten rechteckigen Bereich auf dem
Bildschirm. Werden keine Parameter angegeben, so verwendet AMCAF die Aus-
maße des aktuellen Screens.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplimax "Befehl: Splinters Max"
Splinters Max amount

Stellt ein, wieviele Splinter pro Durchgang maximal neu erscheinen dürfen.
Dadurch läßt sich ein Impulseffekt vermeiden. Wird der Parameter amount
auf 0 gestellt, so erscheinen keine weiteren neuen Splitter mehr auf dem
Bildschirm. Steht er auf -1, so besteht kein Limit.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" Splinters Move     " link csplmove}
@{" =Splinters Active  " link fspliact}

@endnode
@node csplmove "Befehl: Splinters Move"
Splinters Move

Diese Anweisung bewegt die Splinter um einen Schritt.

Siehe auch:

@{" Splinters Back     " link csplback}
@{" Splinters Bank     " link csplbank}
@{" Splinters Colour   " link csplcolo}
@{" Splinters Del      " link csplidel}
@{" Splinters Do       " link csplindo}
@{" Splinters Draw     " link cspldraw}
@{" Splinters Fuel     " link csplfuel}
@{" Splinters Gravity  " link csplgrav}
@{" Splinters Init     " link csplinit}
@{" Splinters Limit    " link cspllimi}
@{" Splinters Max      " link csplimax}
@{" =Splinters Active  " link fspliact}

@endnode
@node ctdstacc "Befehl: Td Stars Accelerate"
Td Stars Accelerate On
Td Stars Accelerate Off

Bestimmt, ob die Sterne während des Flugs an Geschwindigkeit zunehmen
sollen. Mit Td Stars Accelerate On können Sie die Beschleundigung
aktivieren, mit Td Stars Accelerate Off abschalten.

Siehe auch:

@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstbnk "Befehl: Td Stars Bank"
Td Stars Bank bank,stars

Diese Anweisung reserviert eine Bank für 3D-Sterne. Der Parameter bank
gibt die Speicherbank an, die für diese Sterne verwendet werden soll. Das
Argument stars gibt die Anzahl der Sterne an, die in dieser Bank dann
gespeichert werden.

Jeder Stern verbraucht 12 Bytes.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstdel "Befehl: Td Stars Single Del/Td Stars Double Del"
Td Stars Single Del
Td Stars Double Del

Entfernt die Sterne vom Bildschirm. Dabei wird zwischen Single- und
Doublebuffered-Bildschirmen unterschieden. Verwenden Sie
Td Stars Double Del auf Double Buffer-Screens.

Denken Sie daran, daß der Hintergrund nicht restauriert wird.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstado "Befehl: Td Stars Single Do/Td Stars Double Do"
Td Stars Single Do
Td Stars Double Do

Löscht, zeichnet und bewegt die Sterne mit einer Anweisung. Wenn Sie
diesen Prozess per Hand kontrollieren wolen, so müssen Sie die
Td Stars Single Del- bzw. Td Stars Double Del-, die Td Stars Draw- und die
Td Stars Move-Anweisungen verwenden.

Td Stars Single Do sollte für normale Bildschirme benutzt werden, da diese
die letzten Koordinaten der Sterne zum Löschen verwendet. Dagegen ver-
wendet Td Stars Double Do die vorletzten Koordinaten, um die Sterne von
einem Double Buffer-Bildschirm entfernen zu können.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstdra "Befehl: Td Stars Draw"
Td Stars Draw

Dieser Befehl zeichnet alle Sterne auf den Bildschirm. Um die Sterne wie-
der zu löschen müssen Sie je nach Schirmtyp entweder Td Stars Single Del
oder Td Stars Double Del aufrufen.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstgra "Befehl: Td Stars Gravity"
Td Stars Gravity sx,sy

Stellt ein, in welche Richtung die Sterne driften. Dabei gibt sx an,
wieviel bei jedem Aufruf von Td Stars Move die Geschwindigkeit in
X-Richtung erhöht oder erniedrigt werden soll. Gleiches gilt für sy, nur
daß diese auf die Y-Richtung wirkt.

Normalerweise stehen diese Werte auf 0. Aber Sie können diese Werte im
Zusammenhang mit Td Stars Accelerate einstellen, um den Effekt sprühender
Funken zu erzeugen.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstini "Befehl: Td Stars Init"
Td Stars Init

Initialisiert die Sterne. Das heißt, daß die Sterne um zufällige Werte
bewegt werden, damit nicht alle gleichzeitig aus dem Ursprung erscheinen.
Daher sollte diese Anweisungen einmal kurz nach dem Einstellen der Para-
meter erfolgen.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstlim "Befehl: Td Stars Limit"
Td Stars Limit
Td Stars Limit x1,y1 To x2,y2

Grenz die Sterne in einen bestimmten Bereich auf dem Bildschirm ein.
Werden bei Td Stars Limit keine Parameter angegen, so wird die volle Größe
des aktuellen Bildschirms verwendet.

x1,y1 und x2,y2 bilden den rechteckigen Bereich, in dem die Sterne ge-
zeichnet werden sollen. Diese Koordinaten, besonders aber die Y-Werte
müssen INNERHALB des Bildschirms liegen, sonst könnte der Speicher korrupt
werden.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstmov "Befehl: Td Stars Move"
Td Stars Move
Td Stars Move [star]

Die Td Stars Move-Anweisung bewegt alle Sterne einen Schritt. Um das
Ergebnis sehen zu können, müssen Sie die Sterne mit Td Stars Draw zeichnen
lassen.

Die zweite Version des Befehls wird eher selten gebraucht. Mit ihr lassen
sich die Sterne einzeln bewegen. Dabei gibt star die Nummer des Sterns an.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Origin    " link ctdstorg}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstorg "Befehl: Td Stars Origin"
Td Stars Origin x,y

Setzt den Ursprung, aus dem die Sterne neu entstehen, sobald Sie den Bild-
schirm verlassen haben. Die Koordinaten x,y müssen innerhalb des Schirms
und innerhalb des Anzeigebereichs sein, den Sie mit Td Stars Limit ein-
stellen können.

Durch Td Stars Limit wird der Ursprung automatisch in den Mittelpunkt ge-
legt. Daher sollte diese Anweisung erst nach Td Stars Limit aufgerufen
werden.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Planes    " link ctdstpla}

@endnode
@node ctdstpla "Befehl: Td Stars Planes"
Td Stars Planes pl1,pl2

Stellt die @{" Bitplanes " link dbitplane} ein, die für die Sterne verwendet werden sollen.
Normalerweise sind das die Bitplanes 0 und 1. Sie können diese jedoch über
diese Anweisung ändern. Denken Sie daran, daß danach nicht mehr die Farben
danach 1,2 und 3 verwendet werden.

Siehe auch:

@{" Td Stars Accelerate" link ctdstacc}
@{" Td Stars Bank      " link ctdstbnk}
@{" Td Stars Del       " link ctdstdel}
@{" Td Stars Do        " link ctdstado}
@{" Td Stars Draw      " link ctdstdra}
@{" Td Stars Gravity   " link ctdstgra}
@{" Td Stars Init      " link ctdstini}
@{" Td Stars Limit     " link ctdstlim}
@{" Td Stars Move      " link ctdstmov}
@{" Td Stars Origin    " link ctdstorg}

@endnode
@node cturdraw "Befehl: Turbo Draw"
Turbo Draw x1,y1 To x2,y2,c
Turbo Draw x1,y1 To x2,y2,c,bitplanes

Diese Anweisung ersetzt die Draw Anweisung von AMOS. Die Koordinaten x1,y1
stellen den Anfangspunkt der Linie dar und x2,y2 den Endpunkt. Die
Koordinaten dürfen auch außerhalb des Bildschirms liegen, dann wird
automatisch geclippt. Die Farbe c muß angegeben werden, dagegen ist der
Parameter bitplanes optional. Er gibt an, in welchen @{" Bitplanes " link dbitplane} die Linie
gezeichnet werden soll. Dabei stellt Bit 0 Bitplane 0 dar, Bit 1
Bitplane 1 etc. Ist das Bit gesetzt, so wird in dieser Bitplane die Linie
gezeichnet sonst nicht. Wird bitplanes weggelassen, so wird in allen Bit-
planes gezeichnet. Turbo Draw unterstützt ein Linienmuster, welches mit
dem AMOS Befehl Set Line eingestellt werden kann.

Aber mit Turbo Draw kann man noch andere, besondere Linien zeichnen,
sog. Blitter-Linien. Diese Linien besitzen nur einen Pixel pro Zeile, und
werden verwendet, um Flächen festzulegen, die dann der Blitter füllen
kann. Um auf diesen Blitter Modus zu schalten muß der Parameter bitplanes
mit negativem Vorzeichen angegeben werden, sonst kann alles gleich
bleiben. Beachten Sie, daß falls eine Linie den Bildschirm am rechten Rand
verläßt, automatisch eine zusätzliche Linie gezeichnet wird.

Siehe auch:

@{" Blitter Fill       " link cbltfill}

@endnode
@node cturplot "Befehl: Turbo Plot"
Turbo Plot x,y,c

Zeichnet einen Punkt an die Koordinaten x,y mit der Farbe c. Dieser Befehl
ist ca. 3-14 mal schneller als der AMOS Plot-Befehl, berücksichtigt aber
keine logische Verknüpfung, wie sie mit Gr Writing eingestellt werden
kann.

Siehe auch:

@{" =Turbo Point       " link fturpoin}

@endnode
@node cvecrang "Befehl: Vec Rot Angles"
Vec Rot Angles angx,angy,angz

Stellt die drei Blickwinkel ein, die für die Vektorrotation verwendet wer-
den. Anders gesehen stellt angx den Winkel dar, um den die Koordinaten an
der X-Achse gedreht werden soll. Dasselbe gilt für angy und angz, die sich
auf die Y- und Z-Achse beziehen. Die Winkel werden wie auch bei Qsin und
Qcos weder im Bogen- noch im Gradmaß angegeben, sondern eine Umdrehung
(360 Grad) entspricht dem Wert 1024.

Nachdem Sie sowohl die Winkel als auch die Position angegeben haben,
können Sie die Vectormatrize mit dem Befehl Vec Rot Precalc berechnen.

Siehe auch:

@{" Vec Rot Pos        " link cvecrpos}
@{" Vec Rot Precalc    " link cvecrpre}
@{" =Vec Rot X         " link fvecrotx}
@{" =Vec Rot Y         " link fvecroty}
@{" =Vec Rot Z         " link fvecrotz}
@{" =Qsin              " link fqsine  }
@{" =Qcos              " link fqcosine}

@endnode
@node cvecrpos "Befehl: Vec Rot Pos"
Vec Rot Pos posx,posy,posz

Mit Vec Rot Pos können Sie die Position des Blickwinkels einstellen.
posx und posy geben dabei die Verschiebung der Kamera in X und Y
Richtung an. Der Wert in posz entspricht der Entfernung zur Kamera.

Ein erneutes Berechnen der Matrize mit Vec Rot Precalc ist beim alleinigen
Verschieben nicht nötig.

Siehe auch:

@{" Vec Rot Angles     " link cvecrang}
@{" Vec Rot Precalc    " link cvecrpre}
@{" =Vec Rot X         " link fvecrotx}
@{" =Vec Rot Y         " link fvecroty}
@{" =Vec Rot Z         " link fvecrotz}

@endnode
@node cvecrpre "Befehl: Vec Rot Precalc"
Vec Rot Precalc

Dieser Befehl muß vor allen Vektor-Rotationen ausgeführt werden und jedes-
mal, wenn die Blickwinkel bewegt wurden. Er berechnet eine interne
Matrize, mit der die Vektor-Rotationsbefehle arbeiten. Die Matrize enthält
Ergebnisse häufiggebrauchter Rechnungen, wie sie für die Rotation benötigt
werden.

Nach dem Aufruf von Vec Rot Precalc können die Vec Rot X,Y und Z
Funktionen verwendet werden.

Siehe auch:

@{" Vec Rot Pos        " link cvecrpos}
@{" Vec Rot Angles     " link cvecrang}
@{" =Vec Rot X         " link fvecrotx}
@{" =Vec Rot Y         " link fvecroty}
@{" =Vec Rot Z         " link fvecrotz}

@endnode
@node cfiwload "Befehl: Wload"
Wload file$,bank

Dieser Befehl lädt die Datei file$ vollständig in den Speicher unter der
Bank mit der Nummer bank. Die Bank wird als @{" 'Work' " link dtemporaer} definiert.
Ist bank negativ, so wird die Datei ins @{" Chip-Ram " link dchipram} geladen.
Wload entspricht

Open In 1,FILE$ : LE=Lof(1) : Close 1
Reserve As Work BANK,LE
Bload FILE$,BANK

Siehe auch:

@{" Dload              " link cfidload}
@{" Bank Temporary     " link cbnktemp}

@endnode
@node cwritcli "Befehl: Write Cli"
Write Cli text$

Die Write Cli-Anweisung schreibt die Zeichenfolge text$, in das
CLI-Fenster, von dem aus das Programm bzw. AMOS gestartet wurde. Existiert
dieses Fenster nicht, so wird kein Text ausgegeben.

@endnode
@node cfiwsave "Befehl: Wsave"
Wsave file$,bank

Sichert die Bank mit der Nummer bank als Datei file$ auf der Diskette ab.
Diese Datei hat keinen AMOS-Overhead, also besitzt nur den reinen, binären
Inhalt der Bank.

Siehe auch:

@{" Dsave              " link cfidsave}

@endnode
@node sbefindex "Übersicht über alle Befehle"
Funktionen:

@{" =Aga Detect        " link fagadtct} - Überprüft, ob der Computer das AGA Chipset hat
@{" =Amcaf Base        " link famcafba} - Ermittelt den internen Amcaf-Datenbereich
@{" =Amcaf Length      " link famcafle} - Gibt die Länge des Datenbereichs aus
@{" =Amcaf Version$    " link famcafvs} - Gibt einen Versionsstring zurück
@{" =Amos Cli          " link famoscli} - Gibt die Nummer des CLI-Prozesses zurück
@{" =Amos Task         " link famostsk} - Gibt die Adresse der AMOS Task-Struktur aus
@{" =Asc.l             " link fasclong} - Convertieren eines @{" Long-Strings " link dlong} in eine Zahl
@{" =Asc.w             " link fascword} - Convertieren eines @{" Wort-Strings " link dword} in eine Zahl
@{" =Bank Checksum     " link fbnkchec} - Berechnet die Checksumme einer Bank
@{" =Bank Name$        " link fbnkname} - Gibt den Namen einer Bank zurück
@{" =Best Pen          " link fbestpen} - Berechnet die am nähesten liegende Farbe 
@{" =Binexp            " link fbinexpo} - Exponentialfunktion von 2
@{" =Binlog            " link fbinloga} - Logarithmusfunktion der Basis 2
@{" =Blitter Busy      " link fbltbusy} - Ermittelt, ob der Blitter gerade arbeitet
@{" =Blue Val          " link fcbluval} - Ermittelt den Blauanteil einer Farbe
@{" =Cd Date$          " link fcddates} - Gibt einen vollständigen Datumsstring zurück
@{" =Cd Day            " link fcd__day} - Gibt den Monatstag eines Datums zurück
@{" =Cd Month          " link fcdmonth} - Extrahiert den Monat eines Datums
@{" =Cd String         " link fcd_strg} - Rechnet einen Datums-String in ein Datum um
@{" =Cd Weekday        " link fcdweekd} - Ermittelt den Wochentag eines Datums
@{" =Cd Year           " link fcd_year} - Gibt das Jahr eines Datums aus
@{" =Chr.l$            " link fchrlong} - Erzeugen eines @{" Long-Strings " link dlong}
@{" =Chr.w$            " link fchrword} - Erzeugen eines @{" Wort-Strings " link dword}
@{" =Command Name$     " link fcomname} - Ermittelt den Programmnamen
@{" =Cop Pos           " link fcop_pos} - Ermittelt die aktuelle Adresse des Copperprogramms
@{" =Count Pixels      " link fcounpix} - Abzählen der Pixel in einem Bereich
@{" =Cpu               " link fcpu    } - Gibt die Nummer des Prozessors zurück
@{" =Ct Hour           " link fct_hour} - Extrahiert die Stunde aus einer Uhrzeit
@{" =Ct Minute         " link fctminut} - Ermittelt die Minute einer Uhrzeit
@{" =Ct Second         " link fctsecon} - Gibt die Sekunde einer Uhrzeit zurück
@{" =Ct String         " link fct_strg} - Rechnet einen Zeit-String in einen Zeit-Wert um
@{" =Ct Tick           " link fct_tick} - Extrahiert die Fünfzigstel aus einer Uhrzeit
@{" =Ct Time$          " link fcttimes} - Gibt einen vollständigen Zeitstring zurück
@{" =Current Date      " link fcurdate} - Ermittelt das aktuelle Datum
@{" =Current Time      " link fcurtime} - Ermittelt die aktuelle Uhrzeit
@{" =Cutstr$           " link fcutstrg} - Schneidet einen Teil eines Strings ab
@{" =Disk State        " link fdskstat} - Gibt den Status der Diskette zurück
@{" =Disk Type         " link fdsktype} - Gibt den Typ der Diskette zurück
@{" =Dos Hash          " link fdoshash} - Berechnet den Hashwert einer Datei
@{" =Even              " link feven   } - Gibt zurück, ob ein Wert gerade ist
@{" =Examine Next$     " link fexanext} - Liest den nächsten Eintrag eines Verzeichnisses
@{" =Extpath$          " link fextpath} - Fügt dem Pfad ein "/" hinzu, wenn nötig
@{" =Filename$         " link ffilname} - Gibt den Dateinamen zurück
@{" =Font Style        " link ffontsty} - Attribute eines Fonts ermitteln
@{" =Fpu               " link ffpu    } - Ermittelt die Nummer eines Coprozessors
@{" =Glue Colour       " link fgluecol} - Berechnet die Farbe unter Angabe der Farbanteile
@{" =Green Val         " link fcgreval} - Ermittelt den Grünanteil einer Farbe
@{" =Ham Best          " link fhambest} - Berechnet die beste Farbe im @{" HAM-Modus " link dham}
@{" =Ham Colour        " link fhamcolo} - Berechnet die Farbe im @{" HAM-Modus " link dham}
@{" =Ham Point         " link fhampoin} - Beschafft sich den Farbwert eines HAM-Pixels
@{" =Insstr$           " link finsstrg} - Fügt einen String in einen anderen ein
@{" =Io Error          " link fioerror} - Gibt die Nummer des letzten DOS-Fehlers aus
@{" =Io Error$         " link fioerstr} - Gibt einen DOS-Fehlerstring zurück
@{" =Itemstr$          " link fitemstr} - Gibt ein 'Item' aus einem String zurück
@{" =Lsl               " link flogleft} - Schnelle Multiplikation mit einer Potenz von 2
@{" =Lsr               " link flogrigh} - Schnelle Division mit einer Potenz von 2
@{" =Lsstr$            " link flsstrin} - Gibt eine Zahl rechtsbündig aus
@{" =Lzstr$            " link flzstrin} - Gibt eine Zahl rechtsbündig mit führenden 0-en aus
@{" =Mix Colour        " link fmixcolo} - Mischt bzw. addiert zwei Farben
@{" =Nfn               " link fnofunct} - Keine Wirkung
@{" =Odd               " link fodd    } - Gibt zurück, ob ein Wert ungerade ist
@{" =Object Blocks     " link fobjblks} - Gibt die Länge einer Datei in Blocks aus
@{" =Object Comment$   " link fobjcomm} - Gibt den Kommentar eines @{" Objekts " link dobject} aus
@{" =Object Date       " link fobjdate} - Gibt das Erstellungsdatum eines @{" Objekts " link dobject} zurück
@{" =Object Name$      " link fobjname} - Gibt den Namen eines @{" Objekts " link dobject} aus
@{" =Object Protection " link fobjprot} - Gibt die @{" Schutzbits " link dprotflags} eines @{" Objekts " link dobject} zurück
@{" =Object Protection$" link fobjprst} - Gibt einen @{" Schutzbits-String  " link dprotflags} zurück
@{" =Object Size       " link fobjsize} - Gibt die Länge einer Datei zurück
@{" =Object Time       " link fobjtime} - Gibt die Erstellungszeit eines @{" Objekts " link dobject} an
@{" =Object Type       " link fobjtype} - Gibt den Typ eines @{" Objekts " link dobject} zurück
@{" =Pal Get           " link fpgetcol} - Liest einen gespeicherten Paletteneintrag aus
@{" =Path$             " link fpathstr} - Gibt den Pfad zurück
@{" =Pattern Match     " link fpatmatc} - Vergleicht einen String mit einem Muster
@{" =Pfire             " link ffourfir} - Überprüft den Feuerknopf
@{" =Pjdown            " link ffourjdo} - Joystick nach unten abfragen
@{" =Pjleft            " link ffourjle} - Joystick nach links abfragen
@{" =Pjoy              " link ffourjoy} - Richtungen eines Joysticks ermitteln
@{" =Pjright           " link ffourjri} - Joystick nach rechts abfragen
@{" =Pjup              " link ffourjup} - Joystick nach oben abfragen
@{" =Pt Cinstr         " link fptcinst} - Gibt zurück, welches Instrument gerade spielt
@{" =Pt Cnote          " link fptcnote} - Holt die Frequenz des aktuellen Instruments
@{" =Pt Cpattern       " link fptcpatt} - Holt die aktuelle Songposition
@{" =Pt Cpos           " link fptcposi} - Gibt die aktuelle Patternzeile zurück
@{" =Pt Data Base      " link fptdatab} - Gibt die Adresse der PT-Variablen zurück
@{" =Pt Instr Address  " link fptinadr} - Gibt die Adresse eines Instruments zurück
@{" =Pt Instr Length   " link fptinlen} - Gibt die Länge eines Instruments zurück
@{" =Pt Signal         " link fptsigna} - Abfragen nach Signalen vom Musikstück
@{" =Pt Vu             " link fptvumet} - Abfragen des Vumeters
@{" =Qarc              " link fqarc   } - Schnelle Winkel-Funktion
@{" =Qcos              " link fqcosine} - Schnelle Cosinus-Funktion
@{" =Qrnd              " link fqrandom} - Schneller Ersatz für Rnd
@{" =Qsin              " link fqsine  } - Schnelle Sinus-Funktion
@{" =Qsqr              " link fqsquare} - Schnelle Wurzelfunktion
@{" =Red Val           " link fcredval} - Ermittelt den Rotanteil einer Farbe
@{" =Replacestr$       " link frplcstr} - Ersetzt einen String durch einen anderen
@{" =Rgb To Rrggbb     " link frgbtaga} - Rechnet eine Farbe ins neue @{" AGA-Farbformat " link dagaamiga} um
@{" =Rrggbb To Rgb     " link fagatrgb} - Rechnet eine @{" AGA-Farbe " link dagaamiga} ins alte Format zurück
@{" =Scanstr$          " link fscanstr} - Gibt den Namen einer Taste aus
@{" =Scrn Bitmap       " link fscrbitm} - Gibt die Bitmap eines Screens zurück
@{" =Scrn Layer        " link fscrlaye} - Gibt den Layer zurück
@{" =Scrn Layerinfo    " link fscrlayi} - Gibt das Layerinfo zurück
@{" =Scrn Rastport     " link fscrrast} - Gibt den Rastport eines Screens zurück
@{" =Scrn Region       " link fscrregi} - Gibt die Region eines Screens zurück
@{" =Sdeek             " link fsgndeek} - Lesen eines @{" Worts " link dword} mit Vorzeichen
@{" =Smouse Key        " link fsmousek} - Testet die Mausknöpfe
@{" =Speek             " link fsgnpeek} - Lesen eines @{" Bytes " link dbyte} mit Vorzeichen
@{" =Splinters Active  " link fspliact} - Gibt zurück, wieviele Splitter sich noch bewegen
@{" =Tool Types$       " link ftooltyp} - Liest die Tool-Types eines Piktogramms
@{" =Turbo Point       " link fturpoin} - Schneller Point-Ersatz
@{" =Vclip             " link fvalclip} - Grenzt einen Wert in einen gegebenen Bereich ein
@{" =Vec Rot X         " link fvecrotx} - Rechnet den 2D X-Wert aus
@{" =Vec Rot Y         " link fvecroty} - Berechnet den 2D Y-Wert
@{" =Vec Rot Z         " link fvecrotz} - Gibt die Z-Koordinate aus
@{" =Vin               " link fvaluein} - Testet, ob ein Wert innerhalb eines Bereichs ist
@{" =Vmod              " link fvalmodu} - Führt eine Modulo-Operation auf einen Wert aus
@{" =Wordswap          " link fwrdswap} - Tausch der oberen und unteren 16-Bits
@{" =X Raster          " link fxraster} - X-Position des Rasterstrahls
@{" =X Smouse          " link fxsmouse} - Liest die X-Koordinate der Maus
@{" =Xfire             " link fextfire} - Feuerknöpfe eines Joypads auslesen
@{" =Y Raster          " link fyraster} - Y-Position des Rasterstrahls
@{" =Y Smouse          " link fysmouse} - Liest die Y-Koordinate 

Befehle:

@{" Amcaf Aga Notation " link camcafaa} - Ein- und Abschaltung des @{" AGA-Amiga " link dagaamiga} Farbformats
@{" Audio Free         " link caudfree} - Gibt das Audio Device wieder frei
@{" Audio Lock         " link caudlock} - Reserviert das Audio Device
@{" Bank Code Add.y    " link cbcodadd} - Additionsverfahren
@{" Bank Code Mix.y    " link cbcodmix} - Mischung aus Add und Xor
@{" Bank Code Rol.y    " link cbcodrol} - Rotation der Bits nach links
@{" Bank Code Ror.y    " link cbcodror} - Rotation der Bits nach rechts
@{" Bank Code Xor.y    " link cbcodxor} - Exklusiv-oder-Verknüpfung
@{" Bank Copy          " link cbnkcopy} - Kopiert eine Bank
@{" Bank Delta Decode  " link cbnkdltd} - Entfernt die Delta-Codierung wieder.
@{" Bank Delta Encode  " link cbnkdlte} - Kodiert eine Bank mit dem Delta-Verfahren
@{" Bank Name          " link cbnkname} - Nennt eine Bank um
@{" Bank Permanent     " link cbnkperm} - Macht eine Bank @{" permanent " link dpermanent}
@{" Bank Stretch       " link cbnkstre} - Vergrößert eine Bank nachträglich
@{" Bank Temporary     " link cbnktemp} - Macht eine Bank @{" temporär  " link dtemporaer}
@{" Bank To Chip       " link cbnkchip} - Verschiebt eine Bank ins @{" Chip-Ram " link dchipram}
@{" Bank To Fast       " link cbnkfast} - Verschiebt eine Bank ins @{" Fast-Ram " link dfastram}
@{" Bcircle            " link cbcircle} - Zeichnen eines Kreises zum Füllen mit dem @{" Blitter " link dblitter}
@{" Blitter Clear      " link cbltcler} - Löschen einer Bitplane mit dem @{" Blitter " link dblitter}
@{" Blitter Copy       " link cbltcopy} - Kopieren und Verknüpfen einer Bitplane
@{" Blitter Copy Limit " link cbltcplm} - Einstellen des Bereichs für Blitter Copy
@{" Blitter Fill       " link cbltfill} - Füllen von Flächen mit dem @{" Blitter " link dblitter}
@{" Blitter Wait       " link cbltwait} - Warten auf das Ende der Blittertätigkeit
@{" Bzoom              " link cblkzoom} - Vergrößert einen Bereich
@{" Change Bank Font   " link cchbkfnt} - Laden eines Zeichensatzes aus einer Bank
@{" Change Font        " link cchafont} - Laden eines Zeichensatzes direkt von der Diskette
@{" Change Print Font  " link cchprfnt} - Ändern des Fonts, mit dem Print arbeitet
@{" Convert Grey       " link ccongrey} - Graustufenbild erzeugen
@{" Coords Bank        " link ccrdbank} - Bank für Koordinatenspeicherung setzen
@{" Coords Read        " link ccrdread} - Einlesen der Koordinaten in die Bank
@{" Dload              " link cfidload} - Lädt eine Datei @{" permanent " link dpermanent} ein
@{" Dsave              " link cfidsave} - Speichert eine Datei
@{" Examine Dir        " link cexamdir} - Initialisiert das Lesen eines Verzeichnisses
@{" Examine Object     " link cexamobj} - Holt Informationen zu einem @{" Objekt " link dobject}
@{" Examine Stop       " link cexastop} - Stoppt das Lesen des Verzeichnisses
@{" Exchange Bob       " link cexchbob} - Tauscht zwei Bilder der Spritebank aus
@{" Exchange Icon      " link cexchico} - Tauscht zwei Bilder der Iconbank aus
@{" Extdefault         " link cextdefa} - Ruft die Default-Routine einer Extension auf
@{" Extreinit          " link cextrein} - Versucht, eine Extension wieder einzubinden
@{" Extremove          " link cextremo} - Entfernt eine Extension aus dem Speicher
@{" Fcircle            " link cfcircle} - Ausgefüllter Kreis
@{" Fellipse           " link cfellips} - Ausgefüllte Ellipse
@{" File Copy          " link cfilcopy} - Kopiert eine Datei
@{" Flush Libs         " link cflushli} - Gibt den so viel wie möglich Speicher frei
@{" Ham Fade Out       " link chamfade} - Blendet ein HAM-Bild aus
@{" Imploder Load      " link cimpload} - Lädt und entpackt eine FileImploder-Datei
@{" Imploder Unpack    " link cimpunpk} - Entpackt eine FileImploder-Datei
@{" Launch             " link claunchp} - Startet einen neuen Prozess
@{" Limit Smouse       " link climsmou} - Legt den Mausbereich fest
@{" Make Bank Font     " link cmkbkfnt} - Erstellen einer Font-Bank
@{" Make Pix Mask      " link cpixmask} - Berechnet eine Schablone für das Shiften
@{" Mask Copy          " link cmskcopy} - Screen Copy mit Schablone
@{" Nop                " link cnoopera} - Keine Wirkung
@{" Open Workbench     " link copenwor} - Öffnet die Workbench wieder
@{" Pal Get Screen     " link cpgetscr} - Speichert die Palette eines Schirms ab
@{" Pal Set            " link cpsetcol} - Setzt einen Eintrag der gespeicherten Palette
@{" Pal Set Screen     " link cpsetscr} - Setzt die Palette eines Bildschirms
@{" Pal Spread         " link cpspread} - Erzeugt einen Farbverlauf zwischen zwei Farben
@remark {" Paste Ptile        " link cpasptil} - Plotten eines Ptiles
@{" Pix Brighten       " link cpixbrig} - Farbwerte erhöhen (nicht @{" cyclic " link dcyclic})
@{" Pix Darken         " link cpixdark} - Farbwerte erniedrigen (nicht @{" cyclic " link dcyclic})
@{" Pix Shift Down     " link cpixshdo} - Farbwerte erniedrigen (@{" cyclic " link dcyclic})
@{" Pix Shift Up       " link cpixshup} - Farbwerte erhöhen (@{" cyclic " link dcyclic})
@{" Ppfromdisk         " link cppfrdsk} - Lädt und entpackt eine powergepackte Datei
@{" Pptodisk           " link cpptodsk} - Packt und speichert eine Bank im PP20-Format
@{" Ppunpack           " link cppunpak} - Entpackt eine powergepackte Bank
@{" Protect Object     " link cprotobj} - Ändert die @{" Schutz-Bits " link dprotflags} eines @{" Objekts " link dobject}
@remark {" Ptile Bank         " link cptilbnk} - Setzen einer Ptile Bank
@{" Pt Bank            " link cpt_bank} - Setzt die Protrackerbank für Pt Instr Play
@{" Pt Cia Speed       " link cptspeed} - Einstellen der Geschwindigkeit
@{" Pt Continue        " link cpt_cont} - Startet eine zuvor gestoppte Musik wieder
@{" Pt Instr Play      " link cptinspl} - Spielt ein Instrument eines Musikstücks
@{" Pt Play            " link cpt_play} - Spielt ein Module ab
@{" Pt Raw Play        " link cptrawpl} - Spielt einen Speicherbereich ab.
@{" Pt Sam Bank        " link cptsambk} - Stellt die Bank für AMOS-Samples ein
@{" Pt Sam Freq        " link cptsamfr} - Ändert die Wiedergabefrequenz eines Sounds
@{" Pt Sam Play        " link cptsampl} - Spielt ein Sample aus einer AMOS-Bank
@{" Pt Sam Stop        " link cptsamst} - Stoppt die Soundausgabe bestimmter Kanäle
@{" Pt Sam Volume      " link cptsamvo} - Setzt die Lautstärke eines Soundeffekts
@{" Pt Stop            " link cpt_stop} - Stoppt das aktuelle Musikstück
@{" Pt Voice           " link cptvoice} - Auswahl der abzuspielenden Kanäle
@{" Pt Volume          " link cptvolum} - Einstellen der Lautstärke
@{" Rain Fade          " link crainfad} - Blendet einen Regenbogen aus oder um
@{" Raster Wait        " link craswait} - Wartet auf den Rasterstrahl
@{" Reset Computer     " link crescomp} - Macht einen Reset
@{" Set Ntsc           " link csetntsc} - Wechselt in den 60Hz-Modus
@{" Set Object Comment " link cobjcomm} - Ändert den Kommentar eines @{" Objekts " link dobject}
@{" Set Object Date    " link cobjdate} - Ändert das Datum eines @{" Objekts " link dobject}
@{" Set Pal            " link cset_pal} - Wechselt zurück in den 50Hz-Modus
@{" Set Rain Colour    " link csetrain} - Ändert die eingestellte Farbe eines Regenbogens
@{" Set Sprite Priority" link csetspri} - Ändert die Sprite Priorität im Dual Playfield
@{" Shade Bob Down     " link cshbshdo} - Ein Shade Bob setzen, welches die Farben erniedrigt
@{" Shade Bob Mask     " link cshbmask} - Festlegen der zu benutzenden Grafik
@{" Shade Bob Planes   " link cshbplan} - Einstellen der zu benutzenden Bitplanes
@{" Shade Bob Up       " link cshbshup} - Ein Shade Bob setzen, welches die Farben erhöht
@{" Shade Pix          " link cshadpix} - Zeichnen eines Shade-Pixels
@{" Smouse Speed       " link csmouspd} - Setzt die Geschwindigkeit für die Maus
@{" Smouse X           " link csmousex} - Setzt die X-Koordinate der Maus
@{" Smouse Y           " link csmousey} - Setzt die Y-Koordinate 
@{" Splinters Back     " link csplback} - Holen des Hintergrunds
@{" Splinters Bank     " link csplbank} - Speicher für die Splitter reservieren
@{" Splinters Colour   " link csplcolo} - Einstellen der zu benutzenden Bitplanes
@{" Splinters Del      " link csplidel} - Löschen der Splitter
@{" Splinters Do       " link csplindo} - Komplettes Bewegen und Zeichnen
@{" Splinters Draw     " link cspldraw} - Zeichnen der Splitter
@{" Splinters Fuel     " link csplfuel} - Setzen der Reichweite eines Splitters
@{" Splinters Gravity  " link csplgrav} - Einstellen der Gravitation
@{" Splinters Init     " link csplinit} - Initialisieren der Splitter
@{" Splinters Limit    " link cspllimi} - Setzen der Splittergrenzen
@{" Splinters Max      " link csplimax} - Festlegen der maximal neu auftretenden Splitter
@{" Splinters Move     " link csplmove} - Bewegen der Splitter
@{" Td Stars Accelerate" link ctdstacc} - An- und Abstellen der Beschleunigung
@{" Td Stars Bank      " link ctdstbnk} - Reservieren von Speicher für Sterne
@{" Td Stars Del       " link ctdstdel} - Löschen der Sterne vom Bildschirm
@{" Td Stars Do        " link ctdstado} - Komplettes Bewegen und Zeichen
@{" Td Stars Draw      " link ctdstdra} - Zeichnen der Sterne
@{" Td Stars Gravity   " link ctdstgra} - Einstellen der Gravitation
@{" Td Stars Init      " link ctdstini} - Initialisieren der Sterne
@{" Td Stars Limit     " link ctdstlim} - Setzen der Sterngrenzen
@{" Td Stars Move      " link ctdstmov} - Bewegen der Sterne
@{" Td Stars Origin    " link ctdstorg} - Setzen des Feldmittelpunkts
@{" Td Stars Planes    " link ctdstpla} - Auswahl der von den Sternen benutzen Bitplanes
@{" Turbo Draw         " link cturdraw} - Schneller Draw-Ersatz
@{" Turbo Plot         " link cturplot} - Schneller Plot-Ersatz
@{" Vec Rot Angles     " link cvecrang} - Einstellen der Blickwinkel
@{" Vec Rot Pos        " link cvecrpos} - Einstellen der Kameraposition
@{" Vec Rot Precalc    " link cvecrpre} - Errechnen der Matrix
@{" Wload              " link cfiwload} - Lädt eine Datei @{" temporär " link dtemporaer} ein
@{" Write Cli          " link cwritcli} - Schreibt ins aktuelle CLI-Fenster
@{" Wsave              " link cfiwsave} - Speichert eine Datei

@endnode
