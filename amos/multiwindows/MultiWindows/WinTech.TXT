Multiwindows Documentation thingy.

This is just a gathering of all the information I have about these Amos 
interface systems. I wasn`t going to write this, but decided that the 
programs were too complicated to leave out at least some documentation. 
Knowledge of the arrays is essential if you want to write anything slightly 
complicated for Multiwindows.

I wrote the whole thing for fun - I don't know how well it works, but 
feel free to email me if you want help or anything. The windows system 
was a bit of a disappointment, as it tends to slow down rapidly, and takes 
a lot of ram. At least the gadgets are stil responsive, though. You`ve got 
to admit that custon windows are a bit cool!

I've moved on to c coding now, mostly using windoze/linux, but I've yet to 
code anything good in it :)

Multiwindows gadgets are just an extension of AGads, which moves the gadget 
zones onto moveable windows. It's pretty much a kludge, but I've put in a 
few neat algorithmic optimizations to speed it up - no code optimizing 
though :(


Ok, some features :

 - Nice, professional looking interface - much nicer than that Amos 
   pro effort :)

 - Buttons, textboxes, sliders, checkboxes, radio gadgets, requesters
   and a file selector

 - Completely free and unrestricted - treat the code as if it were your
   own ( you might try not taking all the credit for it though :)


The technical details:
----------------------

First of all, when opening windows or gadgets, don't use number 0, since 
I probably use that for some global things, and it could really foul up!

Also, use set buffer to increase the variable buffer space, as the interface 
is pretty variable hungry :)
Use the free command to find out how much free buffer space there is, and 
set the buffer to an appropriate value.

Set GADCOUNT and WINCOUNT to the number you are going to use. GADCOUNT means 
number of gadgets PER WINDOW!

Remember the first four gadgets on each window are close, depth, size, drag. 
Creating a textbox as gadget no 4 will act as a drag bar. Your buttons can 
start at number 5.
As a consequence, GADCOUNT must be 4 or above.

The last window is reserved for the fileselector/requester, so don't use it 
if you intend to use these procedures!

The global variable WINCLOSED is normally zero, but if a close gadget is 
clicked, it will be the window number to be closed.
The same is true for WINSIZED. If a window is to be resized, 
the new dimensions should be determined, the graphics redrawn, and the 
gadgets moved/sized.

After 1 loop of WINSCAN[], WINCLOSED and WINSIZED are reset to zero so as 
not to confuse things.
The Procedures
--------------

WIN_SETCOLOURS[black,white,grey,blue,darkgrey]

   Sets the palette indexes for the interface. If using a 4 colour
   screen, let darkgrey=grey.

   Colour values are stored in the global variables vblue,vdgrey etc.

WIN_SETUP[screen]

   Call this after opening screens and setting up colours. 2 screens are 
   used, the one specified by screen and the one after it, screen+1. The
   2nd screen is a double buffer and must be out of sight.
   ** Always bring the first screen to the front **.

WIN_CREATE[Number,x,y,xsize,ysize,min-xsize,min-ysize,max-xsize,max-ysize]

   Creates a window area at the specified coordinates. Resize limits
   should also be given even if you do not intend the window to be
   sizeable - just to be on the safe side :)

WINTOFRONT[number]

   Brings a window to the front. You must do this before changing the
   graphics in a window, or the changes won't be stored properly!

   To draw in a window, simply bring it to the front and place graphics
   in it's screen area. The changes are stored when you drag the window
   or bring another one to the front.

WIN_FRAMEWORK[number,type,pattern,patterncolour1,patterncolour2,title$]

   Draws a framework on a window with some options, such as a pattern,
   and can also create gadgets such as a dragbar, close, size, and depth.

   To use this, you must first create a window with WIN_CREATE[].

   type has 3 options : 1 - Depth gadget and dragbar
                        2 - Depth, drag, close
                        3 - Depth, drag, close, size

   pattern is the same as the number used in the Set Pattern command,
   and the two colors are those to be used in the pattern. Experiment!

   ** You don't have to use this command to draw window graphics - you
      can set the zones yourself, using WIN_SET_ZONE[], or
      GAD_SBUT_CREATE[], and draw any graphics you want in them. The
      gadgets can be anywhere you want - a window with a dragbar at the
      side is pretty cool stuff :)

      The close gadget has to be plain though, but a little
      reprogramming can sort that out!

WINTOBACK[number]

   Sends the specified window to the back. Like pressing depth gadget.

WIN_CLOSE[number]

   Erases the specified window, and deletes it from the screen. You
   can't get it back once deleted - you must recreate the window and
   recreate the gadgets.

WIN_SETGFX[number]

   Copies the contents of the screen occupied by a window to the
   window's own gfx buffer.
   The window must be at the front for this to work properly. Use
   WINSELECTED to determine which window is at the front.

   You should never need to use this procedure - it is handled
   automatically.

WINDRAG[number]

   Have a guess - this is called automatically in winscan, so you should
   never have to call it yourself.

WIN_SET_ZONE[winnum,gadnum,x,y,width,height]

   Defines a zone or gadget on a window. Co-ordinates are given as
   window co-ordinates. ie) NOT SCREEN coordinates!! 
   x=0,y=0 is the top left of the window, wherever it is.

   Using GAD_BUTTON_CREATE[] etc calls this procedure automatically, so
   you may not have to use this procedure at all.

   You will need it for complicated programs such as painting programs
   or spreadsheets etc.

WINSCAN[]

   This procedure MUST BE CALLED as part of an endless loop. It controls
   the windowing system, and scans for mouse clicks etc.

   If a gadget or zone is clicked in a window, this procedure returns
   the number in param. See the example program.



There are other window procedures, but they`re pretty low-level - and 
they sort of document themselves.

See AGads2.1.doc for some documentation on the GAD procedures - they're 
pretty straight forward. If you're not sure, (e)mail me or check the 
RasterMaster1.6 source. There are some minor differences between the 
multiwindows Agads and the standard ones. You can only create gadgets 
on the foremost window, so bring it to the front if you haven't just 
created it.

The Arrays
----------

WININFO(WINCOUNT,8)

 0 - True if window exists, else false.
 1 - x  (top left)
 2 - y
 3 - x2 (bottom right)
 4 - y2
 5 - xsizemin
 6 - ysizemin
 7 - xsizemax
 8 - ysizemax

WINORDER(WINCOUNT)

 1 - id of foremost window
 2 - next one down ...
 3 - etc

WINZONE(WINCOUNT,GADCOUNT,4)

 0 - Type of zone (different types for different gads)
 1 - x
 2 - y
 3 - x2
 4 - y2

Hope this helps ..

Martin Cameron
46 Ribby Road
Kirkham
PR4 2BA
Lancs, UK

E-mail : M.D.Cameron@durham.ac.uk


EndOfFile.