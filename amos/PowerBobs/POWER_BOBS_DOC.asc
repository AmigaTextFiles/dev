Power Bobs doc file. (18/05/1995) V1.0
======================================

Goes with Shareware version.

First I want to thank all these folks for their great support :
	Andy Dobinson
	Paul Overy

	Gavin C. Symons for f*ck*ing up this project.



What is this aniway?
====================

A HIGH-speed AMOS/Pro extension, adding numerous new commands to give your
work the extra speed AMOS/Pro lacks.
It is in fact a welcome addition to the AMOS/Pro Turbo Plus extension, also
written by me.

Included are :
 Pbobs replacing the entire AMOS/Pro Bob system.
 Psprites replacing the entire AMOS/Pro Sprite system.
 Pbob and Psprite Amal support.
 New Amal command allowing all 64 channels to run under interrupts!
 Superfast collision detection for each type of object using coordinate checking.
 Various commands allowing arithmetics on entire arrays (a lot faster).
 Probably some BUGS... :-)

Excluded are :
 All commands/functions you failed to mention. ;-)



Why SHAREWARE?
==============

It allows you to try the extension first, and if satisfied, you can
decide to buy it for a fair price.

It allows me to get full control on the development and sales of this extension
without deadlines and without seeing the fee disappear in someone elses
pocket.



Legal stuff.
============

Disclaimer.

I cannot be held responsible for any damage to you, your computing 
equipment, your programs, or any data as a result of use of the PowerBobs
extension, either directly or consequentially as a result of its use.  
By using the PowerBobs extension you agree to these terms and agree not 
to hold me liable for any damages arising from the use of this 
package.  Use the PowerBobs extension package at your own risk.

This manual and extension was created with Devpac Amiga Version 2.14 © HiSoft.



Distribution.
=============

Being Shareware, this package may be distributed freely.
The cost for distribuing it should not exceed $5, covering p&p and disk.


Contact and registration.
=========================

	MANUEL ANDRE
	Arbeidersstraat Nr. 9
	2600	Berchem
	BELGIUM

For registration, send 450 BEF (Belgian Francs) in cash along with a disk
and suggestions to my adress.
 450 Belgian Francs is about :  16 (US dollars)
				10 (UK pounds)

Or, transfer 500 BEF (Belgian Francs) directly to my account.
All additional transfer costs should be covered by you.

	 BACOB BANK C.V.
	 TRIERSTRAAT 25
	 1040 BRUSSEL

Account: 789-5820863-08

Subject: PowerBobs registration fee.

As an extra, you will get the TURBO Plus V2 extension for FREE!!!
The somewhat updated TURBO V1.0 manual will be included on disk.


What do you get?
----------------

The latest version of PowerBobs without the Shareware Screen, including
all new commands/functions/bugfixes/256 Pbobs instead of 64/...


What do you want?
-----------------

If you find that PowerBobs is missing a command that would come handy for
most Amos/Pro users.  Just send me a disk containing the routine in Amos/Pro
code and a small letter explaining your routine.
You might be lucky to find it in the next version of PowerBobs!

Any serious request will be examined and replied for!


About the example programs.
----------------------------

Most of the demo's include two lines that will not be recognized when you load
them in AMOS/Pro, if the Turbo_Plus extension is not installed.
These are Multi No and Multi Yes, just remove them and run the program.
They are ment to disable/enable multitasking in a comprehensive way.

Remember : all demos are written in ASCII-format, you cannot load them in
a usual manner. Use Merge Ascii to bring them in the editor.



Installation.
=============

Uses extension slot 13.
The extension is available for :
	Amos Classic : V1.3+
	AMOSPro	     : V1.12+

For BEST speed, programs are to be compiled!!!


Installation is simple.
The AMOS and AMOSPro versions use slot number 13.  
If you were running a previous version of the PowerBobs extension, please be
sure to remove it from the extensions list.
It is strongly recommended that you read this entire chapter before 
proceeding with the INSTALLATION.
Operate only with a BACKUP of your system disk!


CONVERSION from an older PowerBobs.

If you have worked with an older version of the PowerBobs extension, you
must follow this procedure to convert your older PowerBobs programs to 
work with your new PowerBobs version.  

If you do not need to perform the conversion, skip to straight to 
INSTALLATION, and begin installing your new PowerBobs extension.
Otherwise, proceed with the conversion process, then install your 
new PowerBobs extension. 

To convert your older PowerBobs programs, you will need to save all 
of your PowerBobs programs in ASCII format.
After saving all programs in this manner, perform the INSTALLATION, 
then bring the old ASCII saved programs back into memory.


CONVERSION PROCESS:
-------------------

STEP 1: Save your program in ASCII format

In AMOS: 
Load the program to convert
Move to the top of the text by pressing Ctrl-Shift and the Up Arrow key 
Press Ctrl-B to mark the beginning of the text
Press Ctrl-Shift- Down arrow to move to then end of the text
Hold Ctrl and use the mouse to click on the top right hand button, Save ASCII
Save the program in ASCII format as 'filename.ASC', as opposed to 
'filename.AMOS'

In AMOS Pro:
Load the program to convert
Press Ctrl A to select all the text
Press Ctrl S to store the text
Press Ctrl Shift A to save the text as an ASCII file.  
Save the program in ASCII format as 'filename.ASC', as opposed to 
'filename.AMOS'


STEP 2: Install the new PowerBobs extension

Read the next section, INSTALLATION and perform the necessary operations 
to install the new PowerBobs extension into your AMOS or AMOS Pro 
system.

STEP 3: Bring your ASCII saved programs back into memory

An ASCII saved program will not contain the banks (graphics, sound, etc)
that the original program used for its operation.
You will need to first Load the program in normally using the Load option,
erase all the text, then Merge the ASCII saved program into memory:

In AMOS: 
Load the program to convert.  If you look through the program, or click 
on test, some commands may say "Extension I".  The program will not run.
Press Ctrl A to select all the text
Press Ctrl C to cut the text (it is stored in a buffer)
The current program now contains just the banks the program used for 
operation, none of the program text.
We will bring the program text back into the program and it will be
tokenized (converted to an internal AMOS format) for the new PowerBobs
extension.
Hold the Shift Key and use the mouse to select Merge ASCII from the top right 
hand menu item.
Select the ASCII version of the program you are converting ('filename.asc' 
instead of 'filename.AMOS')
The ASCII text program will be merged into the program window
Save the program to disk ('filename.AMOS')  (Amiga-S)
Your program is now converted.  Perform this operation for all relevent 
programs.

In AMOS Pro:
Load the program to convert.  If you look through the program, or click 
on test, some commands may say "Extension I".  The program will not run.

Press Ctrl A to select all the text
Press Ctrl C to cut the text (it is stored in a buffer)
Press Ctrl F to erase the cut text from the buffer (optional if you have lots 
of free RAM)

The current program now contains just the banks the program used for 
operation, none of the program text.
We will bring the program text back into the program and it will be 
tokenized (converted to an internal AMOS format) for the new PowerBobs extension
Press Amiga-M to Merge an ASCII file into the current program
Select the ASCII version of the program you are converting ('filename.asc' 
instead of 'filename.AMOS')
The ASCII text program will be merged into the program window
Save the program to disk ('filename.AMOS')  (Amiga-S)
Your program is now converted.  Perform this operation for all relevent 
programs.


INSTALLATION
------------

HARD DRIVE USERS:
You can perform the installation easily right on your hard drive.  See  
instructions below.

ATTENTION FLOPPY USERS:
Perform the installation only on a COPY of your system disk!
Before installing PowerBobs, you need to make sure there is enough room 
on your AMOS or AMOS Pro system disk for Amos/Pro_PowerBobs.Lib (apx 18,000 
bytes as of this writing).  If not, you will have to erase or move
enough files to make room.

On an AMOS system disk, you can move or erase Config1_3.AMOS to make 
enough room.  Make sure you have a good copy of this program on another 
disk for later use.  You will need it for the installation process!

On an AMOS Pro system disk, you can erase Install.AMOS to free up 40,000 
bytes.  Make sure you keep a good copy somewhere in case you need it at a 
later date.

After freeing up some space, procede with the installation:

AMOS installation

1	Copy the AMOS_PowerBobs.Lib into the AMOS_SYSTEM drawer.
2	Load AMOS.
3	Load and run the CONFIG1_3.AMOS program.
4	Select 'Load default configuration' from the 'Disc' menu.
5 	Select 'Loaded extensions' from the 'Set' menu.
6	Click onto line number 13.  
	Now enter the path and the name of the new extension.  
	Ex.: AMOS_SYSTEM/Amos_PowerBobs.Lib [enter]
7	Click onto the QUIT gadget.
8	Select 'Save configuration' from the 'Disc' menu.
9	Very Important! You must also change the AMOS1_3_NTSC.ENV and the 
	RAMOS1_3.ENV configurations in this same way!  Instead of 
	selecting 'Load default configuration' (step 4 above), select
	'Load other configuration'.
10	Select 'Exit to system' from the 'Amos' menu.

The PowerBobs Extension is now installed.  Reload your AMOS system.

ATTENTION : A screen will be opened with some text every time you load
	    AMOS. Also several actions like Load, Run, Quit, etc... will
	    bring up this Screen.
	    Just press the Enter key when asked.
	    Also Compiled programs will bring up this screen when loaded.



AMOS PRO installation

1	Copy the AMOSPro_PowerBobs.Lib into the APSYSTEM drawer.  
	Floppy users: use a COPY of your system disk and erase 
	Install.AMOS to make enough room for the PowerBobs library.
2	Load AMOSPro.
3	Load and run the Interpreter_Config.AMOS program.
4	Select 'Load Default Configuration'. 
5	Select 'Set Loaded Extensions'.
6	 Click onto line number 13.
	Now enter the name of the new extension.
	AMOSPro_PowerBobs.Lib [ENTER]
7	Click onto the Ok gadget.
8	Exit the Loaded Extensions setup
9	Select 'Save configuration'.
10	Quit the Interpreter_config program.
11	Exit AMOSPro.

The PowerBobs Extension is now installed.  Reload your AMOSPro system.

ATTENTION : A screen will be opened with some text every time you load
	    AMOS. Also several actions like Load, Run, Quit, etc... will
	    bring up this Screen.
	    Just press the Enter key when asked.
	    Also Compiled programs will bring up this screen when loaded.



Main PowerBob commands.
=======================

Reserve Pbobs

Reserve Pbobs AMOUNT
 Reserves a static memory list for AMOUNT of Pbobs.
 You can reserve a list for a maximum of 64 Pbobs.
 I can change this if you want more of them, but 64 seems to be
 enough for most applications...

 Bytes reserved : AMOUNT * 8

 Type of memory : Chip or Fast if available.


Pbob Erase

Pbob Erase
 Erase all Pbobs and their structure. This instruction is executed 
 internally every time you run the AMOS/Pro program or when leaving 
 AMOS/Pro.


Pbob Dbuf

Pbob Dbuf True/False
 If you are going to use Pbobs with the double buffering system, set it
 to True. Else set it to False.
 This command MUST preceed all following commands !


Pbob Height

Pbob Height NR,MAXIMUM_HEIGHT
 Reserves a PBOB_STRUCTURE for Pbob NR and initialises it with default
 values.
 If Pbob Dbuf is set to True, a second PBOB_STRUCTURE will be reserved
 for use with the double buffering system.

 Bytes reserved : PBOB_STRUCTURE  	  Chip or Fast if available.
		  MAXIMUM_HEIGHT * 36     Chip
		  \--> 6 bytes for each line to save * 6 bitplanes.
		  (See Pbob instruction for more details)
		  If Pbob Dbuf is set to True, the amount of bytes reserved
		  is doubled.


Pbob

Pbob NR,X,Y,IMAGE
 Does almost the same thing as the normal Bob command.
 The only differences are :
 1) the maximum width of the IMAGE is 32 pixels wide.
    There are no restrictions on the height of the Pbob.

 2) the height of the IMAGE that will be displayed may NOT exceed
    the maximum height for this Pbob.
    See the Pbob Height command.

 3) the amount of colours of the IMAGE may NOT exceed the amount
    of screen colours where the Pbob will be displayed.
    Else a crash is certain!
    So if you open a screen with 4 colours, do not try to display a Pbob
    with 8 or more colours. But it is valid to, for example, to open a screen
    with 32 colours and	display Pbob's with fewer colours (bitplanes).
    Only the bitplanes defining the Pbob will be copied on screen.
    

 4) all parameters must be included.

 5) the Pbob numbering starts at 1, not 0 like the AMOS/Pro Bobs...

 6) it is important to know that the coordinates for the Pbob's are
    measured from the top left-hand corner of the image.
    The current hot spot setting in not taken into account!

 7) the Pbob commands have to be executed in the screen where they are
    to be displayed !
    This is because a part of the Clipping routine is done inside the
    Pbob command.
    Ex.:
	Repeat
   	   Screen 1
	   Proc UPDATE_SCORE
	   Screen 0
	   Proc MOVE_BADDIES : Rem move the BAD_GUYS with Pbob NR,X,Y,IMAGE
	   Proc MOVE_GOODIE : Rem  move the GOOD_GUYS with Pbob NR,X,Y,IMAGE
	   Proc UPDATE_BADDIES_AND_GOODIES : Rem Pbob Clear : Pbob Draw : Screen Swap : Wait Vbl
	Until AMOUNT_OF_GOODIES=0

Pbob ARRAY_X,ARRAY_Y,ARRAY_IMAGE,START_BOB To END_BOB
 This is a superfast replacement for the original Pbob command.
 Normally you have to define all Pbob's whithin a loop like this :
	
  For I=START_BOB To END_BOB
    Pbob I,ARRAY_X(I),ARRAY_Y(I),ARRAY_IMAGE(I)
  Next I
 
 This loop can be replaced with one command !

  Pbob Varptr(ARRAY_X(N)),Varptr(ARRAY_Y(N)),Varptr(ARRAY_IMAGE(N)),START_BOB To END_BOB

 It looks very complicated and slow because of the use of the Varptr()
 functions, but when compiled it is very effective and fast.
 (I know this for sure, because I've examined the resulting compiled code...)

 Varptr(N) is only returning the adress where the N th element of the array
 is stored in memory.  N doesn't have to be zero, you can start from any
 element in the array, passing the values to the Pbob's.
 It is also possible to use AMOS/Pro banks for storing the X/Y coordinates
 and the Image of the Pbob's.
 Beware, the X/Y and Image values stored in the banks have to be LONGWORDS
 (32 bits).

 It has been carefully optimised to give the best speed possible!
 A few tests, normally done by the usual Pbob command, have been
 ommited.
  1) It does not check if the Pbob IMAGE is wider than 32 pixels.
  2) It does not check if the HEIGHT of the Pbob IMAGE exceeds the
     maximum height for this Pbob.
  3) Also the lenght of the ARRAY's or Banks are not checked for !

 So I advise you to test your program in the usual manner and, if 
 everything works fine, you can use the new version of the Pbob
 command.


Pbob Off

Pbob Off NR
 Does the same thing as the Amos Bob Off NR command...

Pbob Off START To END
 Discard a range of Pbobs.

Pbob Off
 Does the same thing as the Amos Bob Off command...


Set Pbob

Set Pbob NR,REPLACE_MODE,PLANEMASK
 Set Pbob drawing mode.
 There are two types of REPLACE_MODE :
   1) a value of 0 will save and restore the background under your Pbob,
      this is the default value.
   2) any other value will turn off the save and restore process.

The PLANEMASK is a bit-map, defining which plane(s) of the Pbob will be
 copied onto the screen.
 If a bit is set to zero, this particular plane of the Pbob will not
 be copied onto the screen.
 Ex.: Set Pbob 1,0,%100001  --> copy plane 6 and 1 onto the screen.
	      plane 654321


Set Fastpbob Mode

Set Fastpbob Mode True/False
 This is a global swith, turning off the background saving/restoring process
 for ALL Pbob's when set to True.
 If set to False, every Pbob will be checked for, to see if the background
 saving/restoring process has to be done.
 By default, this switch is allways set to False.


Pbob Update

Pbob Update
 Does the same thing as the Amos Bob Update command, except that
 the Logical and Physical Screens are not swapped.
 This allows a better control on the updating process if you are using
 multiple double buffered screens.


Pbob Clear 

Pbob Clear START_BOB To END_BOB
 Clear a range of Pbobs by restoring the original background.


Pbob Draw 

Pbob Draw START_BOB To END_BOB
 Draw a range of Pbobs on screen.


Pdraw 25fps

Pdraw 25fps True/False
 Set the Pbob Clear and Pbob Draw command in 25 frames per second
 mode.
 When you run your program, it is allways reset to 50 frames per second!
 Beware, this mode does not influence the Pbob Update command!

 In ProjectX and Alien Breed and quite a lot of other games, the main
 Sprite etc., is updated at 50 frames per second, but the Bobs are only
 updated at 25 frames per second.
 So the program looks like this:

DO 
`
A=1-A : rem a simple toggle 1st frame = 1, next frame =0  etc
`
`
READ JOYSTICK AND STUFF EVERY FRAME
`
`
If A=1
   CLEAR ALL BOBS
`
   Pbob Clear 1 To 20

   CALCULATE NEW POSTIONS FOR BOBS 11 TO 20
`
   Pbob DRAW 11 TO 20 
   ETC.......
`
Else
`
   CALCALCULATE NEW POSTIONS FOR BOBS 1 TO 10
`
   Pbob Draw 1 TO 10
   ETC.....
'
   Screen Swap 
'
End If
'UPDATE MAIN SPRITE EVERY FRAME
Sprite 0,X,Y,3
Wait Vbl
Loop

As you can see, Pbobs 11 to 20 are drawn in the first frame.
The next frame, Pbobs 1 to 10 are drawn and screen swapped into view.
But the joystick reading and anything else are updated every frame!


Pswap Clear
 In the old Pbob Clear command the background buffer adresses where
 swapped inside the Pbob Clear command.
 Normally you used to do :
 	Pbob Clear
	Screen Swap
	Pbob Clear

 The new way is :
	Pbob Clear START_BOB To END_BOB
	Screen Swap
	Pswap Clear
	Pbob Clear START_BOB To END_BOB



PowerBob functions.
-------------------

=I Pbob()

IMAGE=I Pbob(NR)
 Return the actual image for Pbob NR.


=X Pbob()

X=X Pbob(NR)
 Return X coordinate of Pbob NR.
 

=Y Pbob()

Y=Pbob Y(NR)
 Return Y coordinate of Pbob NR. 



Main PowerSprite commands.
==========================

Set Psprite Colours

Set Psprite Colours AMOUNT
 Set the amount of colours for the Psprites.
 This command MUST be executed before the Convert Sprites BNKNR command!
 You can set it to 4 or 16 colours, but you have to be sure that all
 Sprites in the bank to convert share the same amount of colours (bitplanes).


Convert Sprites

Convert Sprites BANKNR
 Convert all Sprites in bank BANKNR to special hardware format.
 As you know, Bob's and Sprites share the same format in memory.
 Normally, when displaying a Sprite, it has to be converted into the
 special hardware format (interleaved bitplane format), before it
 can be displayed by the Sprite DMA-channels.
 The Psprite commands skip this conversion giving an enormous speed-gain!
 It is best to keep you Sprites and Bobs into separate banks, because
 this command will convert all Bobs/Sprites in the bank, wasting a lot
 of your precious memory !
 At this moment the conversion works fine for 4 or 16 coloured Sprites
 that are 16 pixels wide, any height is allowed.
 When the conversion process is done, the original bank can be erased from
 memory, because the converted images are stored in a different format 
 and memory location.
 You can even replace the converted bank by another one!


Psprite Max

Psprite Max AMOUNT
 Set the maximum amount of Psprites that will be used.
 A maximum of 128 Psprites is allowed !
 By default it is set to 64, so Psprite 0 to 63 can be used.


Psprite NR,X,Y,IMAGE
 Does the same thing as the AMOS/Pro command.
 All parameters must be given !


Psprite ARRAY_X,ARRAY_Y,ARRAY_IMAGE,START_SPRITE To END_SPRITE
 This is a superfast replacement for the original Psprite command.
 Normally you have to define all Psprite's whithin a loop like this :
	
  For I=START_SPRITE To END_SPRITE
    Psprite I,ARRAY_X(I),ARRAY_Y(I),ARRAY_IMAGE(I)
  Next I
 
 This loop can be replaced with one command !

  Psprite Varptr(ARRAY_X(N)),Varptr(ARRAY_Y(N)),Varptr(ARRAY_IMAGE(N)),START_SPRITE To END_SPRITE

 It looks very complicated and slow because of the use of the Varptr()
 functions, but when compiled it is very effective and fast.
 (I know this for sure, because I've examined the resulting compiled code...)

 Varptr(N) is only returning the adress where the N th element of the array
 is stored in memory.  N doesn't have to be zero, you can start from any
 element in the array, passing the values to the Psprite's.
 It is also possible to use AMOS/Pro banks for storing the X/Y coordinates
 and the Image of the Psprite's.
 Beware, the X/Y and Image values stored in the banks have to be LONGWORDS
 (32 bits).

 It has been carefully optimised to give the best speed possible!
 A few tests, normally done by the usual Psprite command, have been
 ommited.
  1) The lenght of the ARRAY's or Banks are not checked for !

 So I advise you to test your program in the usual manner and, if 
 everything works fine, you can use the new version of the Psprite
 command.


Psprite Off

Psprite Off NR
 Does the same thing as the Amos/Pro Sprite Off NR command...

Psprite Off START To END
 Discard a range of Psprites.

Psprite Off
 Does the same thing as the Amos/Pro Sprite Off command...


Psprite Update

Psprite Update
 This is a very powerfull updating command.
 First it checks if the maximum amount of Psprites <= 8, if so
 the Psprite images are copied directly to their corresponding
 sprite DMA-channels.

 If the maximum amount of Psprites >8 and the number of actually
 defined sprites with the Psprite command is <=8, the Psprite images
 are copied directly to the sprite DMA-channels without sorting.

 In any other case the Psprites are first sorted on their Y-coordinates.
 Then every Psprite is checked if it can be fitted in a particular
 sprite DMA-channel.
 It is possible to have 128 Psprites on screen using only 1 sprite 
 DMA-channel!



PowerSprite functions.
----------------------

=X Psprite()

HARD_XCOOR=X Psprite(NR)
 Returns the actual hardware X coordinate for Psprite NR


=Y Psprite()

HARD_YCOOR=Y Psprite(NR)
 Returns the actual hardware Y coordinate for Psprite NR



Bob and Bob to Sprite collision detection.
==========================================

=Pbob Fastcol()

RESULT=Pbob Fastcol(PBOB,STARTPBOB To ENDPBOB)
 Does the same thing as the Bob Col function except that I use
 coordinate checking.
 This method is much faster than using the BLITTER to check if a
 collision has occured, but is not so accurate.
 It can be used even if the BOB's have no mask.

RESULT=Pbob Fastcol(BOB To OTHER_BOB)
 This one is handy if you want to detect a collision between two BOB's.
 It does the same thing as Pbob Fastcol(PBOB,OTHER_PBOB To OTHER_PBOB) but
 is a bit faster.
 Since you are only checking for collision between one PBOB and another PBOB,
 the flag in the collision array is not set.
 This means that the Pfast Bobcol() function is useless in this case.
  

=Pbobsprite Fastcol()

RESULT=Pbobsprite Fastcol(PBOB,START_PSPRITE To END_PSPRITE)
 Does the same thing as the Bobsprite Col function except that I use
 coordinate checking.
 This method is much faster than using the BLITTER to check if a
 collision has occured, but is not so accurate.
 It can be used even if the PBOB's and PSPRITE's have no mask.


RESULT=Pbobsprite Fastcol(PBOB To PSPRITE)
 This one is handy if you want to detect a collision between a PBOB and
 one PSPRITE.
 It does the same thing as Pbobsprite Fastcol(PBOB,PSPRITE To PSPRITE) but
 is a bit faster.
 Since you are only checking for collision between one PBOB and another PSPRITE,
 the flag in the collision array is not set.
 This means that the Pfast BobCol() function is useless in this case.


=Pfast Bobcol()

NR=Pfast Bobcol(BOB_NR)
 Does the same thing as the Col(BOB_NR) function in AMOS/Pro.
 But it only works when using Pbobs!
 To be used when doing FAST collision detection.


=Pfast Bobsprcol()

NR=Pfast Bobsprcol(BOB_NR)
 Does the same thing as the Col(SPRITE_NR) function in AMOS/Pro.
 But it only works when using Pbobs and Psprites!
 To be used when doing FAST collision detection.



Sprite and Sprite to Bob collision detection.
=============================================

=Psprite Fastcol()

RESULT=Psprite Fastcol(PSPRITE,STARTPSPRITE To ENDPSPRITE)
 Does the same thing as the Sprite Col function except that I use
 coordinate checking.
 This method is much faster than using the BLITTER to check if a
 collision has occured, but is not so accurate.
 It can be used even if the PSPRITE's have no mask.

RESULT=Psprite Fastcol(PSPRITE To OTHER_PSPRITE)
 This one is handy if you want to detect a collision between two PSPRITE's.
 It does the same thing as 
 Psprite Fastcol(PSPRITE,OTHER_PSPRITE To OTHER_PSPRITE) but is a bit faster.
 Since you are only checking for collision between one PSPRITE and another
 PSPRITE, the flag in the collision array is not set.
 This means that the Pfast Sprcol() function is useless in this case.


=Pfast Sprcol()

NR=Pfast Sprcol(PSPRITE_NR)
 Does the same thing as the Col(SPRITE_NR) function in AMOS/Pro.
 But it only works when using Psprites!
 To be used when doing FAST collision detection.


=Pspritebob Fastcol()

RESULT=Pspritebob Fastcol(PSPRITE,STARTPBOB To ENDPBOB)
 Does the same thing as the Spritebob Col function except that I use
 coordinate checking.
 This method is much faster than using the BLITTER to check if a
 collision has occured, but is not so accurate.
 It can be used even if the PSPRITE's/PBOB's have no mask.

RESULT=Pspritebob Fastcol(PSPRITE To PBOB)
 This one is handy if you want to detect a collision between a PSPRITE and
 one Pbob.
 It does the same thing as 
 Pspritebob Fastcol(PSPRITE,OTHER_PBOB To OTHER_PPBOB) but is a bit faster.
 Since you are only checking for collision between one PSPRITE and a
 PBOB, the flag in the collision array is not set.
 This means that the Pfast Sprbobcol() function is useless in this case.


=Pfast Sprbobcol()

NR=Pfast Sprbobcol(PBOB_NR)
 Does the same thing as the Col(BOB_NR) function in AMOS/Pro.
 But it only works when using Psprites/Pbob's.
 To be used when doing FAST collision detection.


As you can see, there are four functions to examine FAST collisions between
objects.
I also use four collision detection arrays, one for each type of collision
checking.
It provides a method of keeping the collisions between different types of
objects,Pbobs or Psprites, separated.
This whas simply not possible with the AMOS/Pro original Col() function!



PowerBob Amal support.
======================

Pchannel To Pbob

Pchannel To Pbob AMAL_CHANNEL To PBOB_NR
 Assigns Pbob PBOB_NR to Channel AMAL_CHANNEL.
 As normal with Amal programs, the X/Y and A variables define the
 Pbob X/Y coordinates and it's image.
 It is important to assign the channel(s) to the Pbob(s) after the
 Amal CHAN_NR,ANIM$
 Also the X/Y and A values must be declared within the Amal program!
 This means that the Amal driven Pbob's don't require initial values.
 These are transferred by the Psync Pbob command.


Psync Pbob

Psync Pbob START_BOB To END_BOB
 It does the same thing as the Amos/Pro Synchro command, but as an
 additional bonus a range of Pbobs can be updated, this is :
 the new X/Y and A values are transferred to the Pbobs.
 It whas also necessary to include a range to be compatible with the
 new 25 frames per second mode.
 You still have to call the Pbob Update or the Pbob Clear/Draw duo
 to update your Pbobs on screen.
 Beware ! The Psync Pbob command has to be executed in the screen 
 where the Pbobs are to be displayed !
 This is because a part of the Clipping routine is done inside the
 Psync Pbob command.


Psync Every Pbob

Psync Every Pbob FRAME_COUNT
 Normally the Psync Pbob transfers the X/Y and A values every time the
 Psync Pbob command is called, this is the default mode.
 In some occasions it is preferable to update these values at a slower
 rate.  The FRAME_COUNT delay ranges from 1 to 32767.



PowerSprite Amal support.
=========================

Pchannel To Psprite

Pchannel To Psprite AMAL_CHANNEL To PSPRITE_NR
 Assigns Psprite PSPRITE_NR to Channel AMAL_CHANNEL.
 As normal with Amal programs, the X/Y and A variables define the
 Psprite X/Y coordinates and it's image.
 It is important to assign the channel(s) to the Psprite(s) after the
 Amal CHAN_NR,ANIM$
 Also the X/Y and A values must be declared within the Amal program!


Psync Psprite

Psync Ppsprite START_SPRITE To END_SPRITE
 It does the same thing as the Amos/Pro Synchro command for Sprites, but as an
 additional bonus a range of Psprites can be updated, this is :
 the new X/Y and A values are transferred to the Psprites.
 You don't have to execute the Psprite Update command, because it is auto-
 matically performed within the Psync Psprite command!
 It whas necessary to include a range because you are limited to only 64
 Amal channels that can control the Psprites with an Amal program.
 But as you allready know, the Psprite system can display upto 128 Psprites
 on a single screen.
 What you can do is :
  Set up 64 Amal channels that will control the first 64 Psprites in the usual
  manner.
  Then create a Procedure that will handle the rest of the Psprites in
  normal AMOS/Pro code, using the Psprite NR,X,Y,IMAGE command.
  Execute this Procedure BEFORE the Psync Psprite command and then call the
  Psync Psprite command.
	Ex.:	Proc _SET_UP_PSPRITE_AMAL_CHANNELS_0_TO_63
		Proc _SET_UP_PSPRITES_64_TO_127_IN_AMOS/PRO_CODE
		Repeat
		  Proc _GET_SOME_INPUT_FROM_THE_USER
		  Proc _CHANGE_COORDINATES_OF_PSPRITES_64_TO_127
		  Psync Psprite 0 To 63
		Until BORED=True


Psync Every Psprite

Psync Every Psprite FRAME_COUNT
 Normally the Psync Psprite transfers the X/Y and A values every time the
 Psync Psprite command is called, this is the default mode.
 In some occasions it is preferable to update these values at a slower
 rate.  The FRAME_COUNT delay ranges from 1 to 32767.



Additional commands and functions.
==================================

Psync Every

Psync Every FRAME_COUNT
 This command will synchronize the Pbob's and Psprite's at the same FRAME_COUNT.
 But it is more effective to synchronise them at different FRAME_COUNTS,
 if you are displaying lot's of Pbob's and Psprite's on screen.
 Ex.: The main characters are Psprite's, so you want to display them as smooth
      as possible, because your eyes are following them most of the time.
      The other characters (the ennemies) are Pbob's that are only displayed to
      kill them and are not followed constantly by your eyes.
      You just aim at them and shoot.
 But since the main characters are updated at 50 frames per second, the overall
 gameplay will be very smooth.


Set 68020 Amal

Set 68020 Amal CHANNEL,AMAL$
 When AMOS The Creator came out, most of the Amiga computers where equipped 
 with the allready powerfull but limited MC68000 processor.
 He could not have foreseen that many companies where going to design a wide
 variety of accelerator boards and that later Amiga's would be equipped
 with faster processors.

 F. Lionet, the author of the package, knew about these limitations and
 decided that no more than 16 Amal programs should be run under interrupts
 without a possible crash of the system.

 If you are the lucky owner of an accelerator board or a fast Amiga you
 are now able to use all this power to execute even more Amal programs
 under interrupts!

 The command format has not changed, but you are now able to run all
 64 channels under interrupts.
 So you don't have to use the Synchro Off command when setting up your
 Amal programs!

 If you are one of those lucky guys, I advise you to make two versions
 of your programs :
  1) one that will run on a standard machine.
  2) one designed for all those other faster Amiga's.


Progams using 64 channels under interrupts will work on :

  standard A3000           68(EC)030   processor available. 
  standard A1200           68EC020     processor available. 
  standard A4000/30        68(EC)030   processor available. 
  standard A4000/40        68(LC)040   processor available. 

  standard A500 and A500+  with 68(EC)020 or higher accelerator board.
  standard A600            with 68(EC)020 or higher accelerator board.
  standard A2000           with 68(EC)020 or higher accelerator board.
  standard A1000           with 68(EC)020 or higher accelerator board.

  (EC) means : with or without MMU.
  (LC) means : with or without FPU.

They could be working on : 

  standard A500 and A500+  with 68000 clocked at 14Mhz or higher with FASTRAM.
  standard A600            with 68000 clocked at 14Mhz or higher with FASTRAM.
  standard A2000           with 68000 clocked at 14Mhz or higher with FASTRAM.
  standard A1000           with 68000 clocked at 14Mhz or higher with FASTRAM.


=Xscr Sprite()

XSCREEN_COORD=Xscr Sprite(NR)
 This is a full replacement for XSCREEN_COORD=X Screen(X Sprite(NR)).
 

=Yscr Sprite()

YSCREEN_COORD=Yscr Sprite(NR)
 This is a full replacement for YSCREEN_COORD=Y Screen(Y Sprite(NR)).


=Xscr Mouse

XSCREEN_COORD=Xscr Mouse
 This is a full replacement for XSCREEN_COORD=X Screen(X Mouse).
 

=Yscr Mouse

YSCREEN_COORD=Yscr Mouse
 This is a full replacement for YSCREEN_COORD=Y Screen(Y Mouse).
 


Array arithmetics.
------------------

Pinc 

Pinc ARRAY1,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for the original Inc command.
 The values from an array can be incremented in one go!
 Normally you have to increment all array elements whithin a loop like this:
	
  For I=START_ELEMENT To END_ELEMENT
    Inc X(I)
  Next I
 
 This loop can be replaced with one command !

  Pinc Varptr(X(0)),START_ELEMENT To END_ELEMENT

 It looks very complicated and slow because of the use of the Varptr()
 functions, but when compiled it is very effective and fast.

 Varptr(0) is only returning the adress where element 0 (zero) of the array
 is stored in memory.
 Beware!  You MUST use Varptr(ARRAY(0)), START_ELEMENT and END_ELEMENT define
 the range of the variables that will be incremented.
 The only limitation is that only elements 0 through 16383 can be incremented.
 It is also possible to use AMOS/Pro banks instead of array's. 
 Beware! The values stored in the banks have to be LONGWORDS (32 bits).


Set Pinc Range

Set Pinc Range BOTTOM To TOP
 This command sets the range for the Pinc command.
 If you want to change for example the bottom value without changing the other
 range, you can use the Same function.
 Ex.: 1) Normal AMOS/Pro code.
	 Dim X(100)
	 For I=1 To 100
	     Add X(I),1,0 To 319
	 Next I

      2) PowerBob code.
	 Dim X(100),Y(100)
	 Set Pinc Range 0 To 319
	 Pinc Varptr(X(0)),1 To 100


Unset Pinc Range 

Unset Pinc Range
 With this command you can discard the ranges that are used with the
 Pinc command.
 Ex.: Set Pinc Range 10 To 20
      'Set a range when using Pinc.
      Unset Pinc Range
      'Unset the range when using Pinc.
 Beware!
 The Unset command does NOT clear the range values, they are only cleared
 when doing a Default or Run.


Pdec

Pdec ARRAY1,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for the original Dec command.
 The values from an array can be decremented in one go!
 Look at the Pinc command for more information.


Set Pdec Range

Set Pdec Range BOTTOM1 To TOP1
 This command sets the range for the Pdec command.
 If you want to change for example the bottom value without changing the other
 range, you can use the Same function.
 Ex.: 1) Normal AMOS/Pro code.
	 Dim X(100)
	 For I=1 To 100
	     Add X(I),1,10 To 255
	 Next I

      2) PowerBob code.
	 Dim X(100)
	 Set Pdec Range 10 To 255
	 Pdec Varptr(X(0)),1 To 100


Unset Pdec Range 

Unset Pdec Range NR
 With this command you can discard the ranges that are used with the
 Pdec command.


Padd

Padd ARRAY1,VALUE1,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for the original Add command.
 Beware!  You MUST use Varptr(ARRAY(0)), START_ELEMENT and END_ELEMENT define
 the range of the variables that will be added with the correspondent values. 
 Normally you have to add a value to all array elements whithin a loop 
 like this:
	
  For I=START_ELEMENT To END_ELEMENT
    Add X(I),VALUE1
  Next I
 
 This loop can be replaced with one command !

  Padd Varptr(X(0)),VALUE1,START_ELEMENT To END_ELEMENT

 Beware!  You MUST use Varptr(ARRAY(0)), START_ELEMENT and END_ELEMENT define
 the range of the variables that will be added with VALUE1
 The only limitation is that only elements 0 through 16383 can be added.
 It is also possible to use AMOS/Pro banks instead of array's. 
 The values stored in the banks have to be LONGWORDS (32 bits).


Set Padd Range

Set Padd Range BOTTOM1 To TOP1
 This command sets the range for the Padd command.
 If you want to change for example the bottom value without changing the other
 range, you can use the Same function.
 Ex.: 1) Normal AMOS/Pro code.
	 Dim X(100),Y(100)
	 For I=1 To 100
	     Add X(I),10,0 To 319
	 Next I

      2) PowerBob code.
	 Dim X(100),Y(100)
	 Set Padd Range 0 To 319
	 Padd Varptr(X(0))10,1 To 100


Unset Padd Range 

Unset Padd Range NR
 With this command you can discard the ranges that are used with the
 Padd command.


Psum

Psum ARRAY1,ARRAY2,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for adding the values of ARRAY2 to ARRAY1.
 Normally you have to add a two array's whithin a loop like this:
	
  For I=START_ELEMENT To END_ELEMENT
    Add X(I),X_OFFSET(I)
  Next I
 
 This loop can be replaced with one command !

  Psum Varptr(X(0)),Varptr(X_OFFSET(0)),START_ELEMENT To END_ELEMENT

 Beware!  You MUST use Varptr(ARRAY(0)), START_ELEMENT and END_ELEMENT define
 the range of the variables that will be added to eachother.
 The only limitation is that only elements 0 through 16383 can be summed.
 It is also possible to use AMOS/Pro banks instead of array's. 
 The values stored in the banks have to be LONGWORDS (32 bits).


Set Psum Range

Set Psum Range BOTTOM1 To TOP1
 This command sets the range for the Psum command.
 If you want to change for example the bottom value without changing the other
 range, you can use the Same function.


Unset Psum Range 

Unset Psum Range NR
 With this command you can discard the ranges that are used with the
 Psum command.


=Same

=Same
 Use of the Same function.
 Set Pinc Range 0 To 100
 Set Pinc Range Same To 300
 This one will leave the bottom value for array 1 unchanged, but will 
 initialise the TOP value to 300.


Pmul

Pmul RESULT,ARRAY1,FACTOR,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for multiplying the values in ARRAY1 with
 FACTOR.  The results are placed in array RESULT.
 Ex.: Pmul Varptr(RESULT(0)),Varptr(X(0)),5,1 To 100
      Multiply elements 1 to 100 of array X with 5.

 Beware! Make sure that the resulting array can hold the range of values
         defined by START_ELEMENT to END_ELEMENT.


Pmul shift

Pmul Shift RESULT,ARRAY,FACTOR,SHIFT,START_ELEMENT To END_ELEMENT
 This command can be handy when doing some scaled arithmetic.
 All values defined by START_ELEMENT to END_ELEMENT of ARRAY1 are multiplied by
 FACTOR and shifted 2^SHIFT places to the right.  The results are placed in
 array RESULT.
 Ex.: Normal AMOS/Pro code.
      Dim RESULT(100),ARRAY(100),FACTOR(360)
      SHIFT=8
      SCALED=2^8 : Rem 256
      For I=0 To 360
	FACTOR(I)=Cos(I)*SCALED
      Next I
      ANGLE=36

      For I=1 To 100
	RESULT(I)=ARRAY(I)*FACTOR(ANGLE)/SCALED
      Next I

      Enhanced PowerBobs code.
      Pmul Shift Varptr(RESULT(0)),Varptr(ARRAY(0)),FACTOR(ANGLE),SHIFT,1 To 100

 Beware! Make sure that the resulting array can hold the range of values
         defined by START_ELEMENT to END_ELEMENT.


Pdiv

Pdiv RESULT,ARRAY,FACTOR,START_ELEMENT To END_ELEMENT
 This is a superfast replacement for dividing the values in ARRAY with
 FACTOR.  The results are placed in array RESULT.
 Ex.: Pdiv Varptr(RESULT(0)),Varptr(X(0)),5,1 To 100
      Divide elements 1 to 100 of array X with 5.

 Beware! Make sure that the resulting array can hold the range of values
         defined by START_ELEMENT to END_ELEMENT.


Plsr

Plsr ARRAY,SHIFT,START_ELEMENT To END_ELEMENT
 A superfast command for array logical shift.
 This can be used as a very quick way of dividing a positive number by a
 power of 2.
 i.e. 2^SHIFT, this does only however allow divs of 2^N.
 EX.: Plsr Varptr(ARRAY(0)),3,1 To 100                     
                            
                            
Plsl

Plsl ARRAY,SHIFT,START_ELEMENT To END_ELEMENT
 A superfast command for array logical shift.
 This can be used as a very quick way of multiplying a positive number by a
 power of 2.
 i.e. 2^SHIFT, this does only however allow muls of 2^N.
 EX.: Plsl Varptr(ARRAY(0)),3,1 To 100
 

Pasr

Pasr ARRAY,SHIFT,START_ELEMENT To END_ELEMENT
 A superfast command for array logical shift.
 This can be used as a very quick way of dividing a -/+number by a
 power of 2.
 i.e. 2^SHIFT, this does only however allow divs of 2^N.
 EX.: Plsr Varptr(ARRAY(0)),3,1 To 100


Pasl

Pasl ARRAY,SHIFT,START_ELEMENT To END_ELEMENT
 A superfast command for array logical shift.
 This can be used as a very quick way of multiplying a -/+number by a
 power of 2.
 i.e. 2^SHIFT, this does only however allow muls of 2^N.
 EX.: Plsl Varptr(ARRAY(0)),3,1 To 100
 
 

Additional information.
=======================

Since this extension is still growing and changing, I advise you to
save all your programs in ASCII format with separate graphic banks.
You are warned !!!


The Pbob Update command :
 The updating process is divided into 3 stages.
 1) Background replacement.

 2) Background saving.
    This is only done if the X/Y coordinates or the Pbob IMAGE width/height
    have changed since the last update.

 3) Image drawing.
    This is performed every time for all Pbob's.

The Pbob Clear command :
 The background is replaced every time for all Pbob's from their
 safe places.

The Pbob Draw command :
 The drawing process is divided into 2 stages.
 1) Define the area where the Pbob's will be displayed and
    copy this area to a safe place.
 2) Draw the images for all Pbob's.

So the Pbob Clear/Draw should be used when a lot of changes are done
onto the screen.
 Ex.:
	Do
	   Pbob Clear START_BOB To END_BOB
	   'do all other drawing stuff...
	   Pbob Draw START_BOB To END_BOB
	Loop


Problem solving :
=================

The Pbob's are scrambled on screen :
 Be sure that the following commands are executed on the screen you want
 to display them.
 1) Pbob NR,X,Y,IMAGE
 2) the Pbob Clear and Pbob Draw duo.
 3) the Pbob Update command.
 4) the Psync Pbob command.

The Pbob's disappear at certain X/Y coordinates :
 Be sure to execute the Pbob commands on the screen you will display them.
 A part of the Clipping routine is done by the Pbob/Psync Pbob command!

The Pbob's don't appear on screen :
 Are you using a double buffered screen, and you haven't set the
 Pbob Dbuf flag to True ?

The Pbob's leave traces on screen :
 Are you using a single buffered screen, and you haven't set the
 Pbob Dbuf flag to False ?

The Pbob's don't appear on a double buffered screen, even when the
Pbob Dbuf flag is set to True :
 Have you set the Autoback system to 0 or 1 ?
 The Pbob's are only displayed on the Logical screen, so a
 Screen Swap has to be put somewhere in your program.
 Remember ! The Pbob Update command does NOT swap the Logical and
 Physical screens.

When using Amal programs controlling Pbob's or Psprites, rubbish appears
on your screen :
 You have to disable the Updating process for the normal Bob and Sprite
 routines using the Bob/Sprite Update Off commands!

When using Amal programs controlling Pbob's or Psprites, the Amal
Bob Col() and Sprite Col() collision routines don't work :
 You have to check for collisions in your main program with the new
 collision detection routines.

Your program crashes when using PowerBobs :
 Put your program on disk and send it to me for investigation of the problem.



Bugfixes (04/04/1995)
---------------------

 Result=PspriteBob Fastcol()  | \
 Result=PbobSprite Fastcol()  | /--> result used to be allways true. Fixed.
 Result=Pbob Fastcol()	      |
 Result=Psprite Fastcol()      \---> result used to be 255 when true, now
				     returns -1.

Bugfixes (17/05/1995)
---------------------

 No more memory loss when using Psprites/Pbobs.



Speed enhancements (04/04/1995)
-------------------------------

 All collision routines have been sped up, should be a lot faster now.

 Pbob ARRAY_X,ARRAY_Y,ARRAY_I,START To End made faster.

 Psprite ARRAY_X,ARRAY_Y,ARRAY_I,START To End made faster.

 Some minor enhancements have been made.



Other information and future updates. 
=====================================

 Does anyone need some arithmetic done on matrixes?
 If so, send me a docfile and the AMOS/Pro code to see what is needed.

 You want to have Bobs flying around your Intuition screens?
 Send me info on 'how to get the Rastport/Screen/Bitmap adress' in
 the Intuition extension you are using.

 I Psprite(N) does not exist, the actual image number is not stored, 
 mainly for speed reasons: remember, the Sprites are converted into
 an alternate format and the image number simply gets in the way :(
 It is faster to get the Sprite image from a normal array than from a new
 function.
 This also counts for I Pbob(NR).


 Pbob/Psprite with params ommitted :
 I didn't include this option because this would make the Pbob and Psprite
 routines slower.
 A test would have to be included for all params (like Amos/Pro does):
 Ex.:  CMPI.L	#$80000000,D3	D3 CONTAINS IMAGE NR.
       BEQ.S	NO_NEW_IMAGE
       MOVE.W	D3,PBOB_NEW_IMAGE-MB(A2)
     NO_NEW_IMAGE
       etc....

 This would take : 14 cycles for the CMPI.L instruction.
		    9 cycles (average) for the BEQ.S instruction
		   --
		   23 cycles total
		  * 3 tests
		   --
		   69 additional cycles per Pbob/Psprite !

 If you don't care about the extra cycles per Pbob/Psprite, I can change
 the routines.
 This would also affect the Pbob/Psprite array commands...


 Pbob Dbuf : I could set the internal default value to true, so you don't
	     have to call this instruction when using Pbobs in conjunction
	     with double buffering.


 I would like to have an example explaining the problem that you can't
 directly pass parameters to a Pchannel.
