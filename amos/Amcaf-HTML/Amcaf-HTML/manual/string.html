<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <!--
      AMCAF Extension V1.40 Manual for Amos Professional, written by Chris Hodges (1994/95) and compiled by asymetrix for the Amiga community and should stay completely FREE FOREVER.
      Created 2009. :)
  -->
  <title>AMCAF Extension V1.40 Manual</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="keywords" content="AMCAF Extension V1.40 Manual, Amos Professional, Amiga, Programming, Basic, Chris Hodges, Extension, computing, code, AmigaDOS, Aminet.net">
  <meta name="author" content="asymetrix">

</head>

<body bgcolor="white">
<a href="../index.html">AMCAF Extension V1.40 Manual</a>&nbsp; <a href="../command.html">Index</a>

<hr align="center" size="1" width="100%">

<h1>String and Integer Functions</h1>

<br>

<p>AMCAF provides a vast number of useful functions to assist with integer math and string manipulation.</p>

<ul>
  <li><a href="#binexp">=Binexp</a></li>
  <li><a href="#binlog">=Binlog</a></li>
  <li><a href="#lsl">=Lsl</a></li>
  <li><a href="#lsr">=Lsr</a></li>
  <li><a href="#wordswap">=Wordswap</a></li>
  <li><a href="#qarc">=Qarc</a></li>
  <li><a href="#qsin">=Qsin</a></li>
  <li><a href="#qcos">=Qcos</a></li>
  <li><a href="#qrnd">=Qrnd</a></li>
  <li><a href="#qsqr">=Qsqr</a></li>
  <li><a href="#asc.w">=Asc.w</a></li>
  <li><a href="#asc.l">=Asc.l</a></li>
  <li><a href="#vclip">=Vclip</a></li>
  <li><a href="#vin">=Vin</a></li>
  <li><a href="#vmod">=Vmod</a></li>
  <li><a href="#even">=Even</a></li>
  <li><a href="#odd">=Odd</a></li>
  <li><a href="disksupport.html#patternmatch">=Pattern Match</a></li>
  <li><a href="#chr.w">=Chr.w$</a></li>
  <li><a href="#chr.l">=Chr.l$</a></li>
  <li><a href="#lzstr">=Lzstr$</a></li>
  <li><a href="#lsstr">=Lsstr$</a></li>
  <li><a href="#insstr">=Insstr$</a></li>
  <li><a href="#cutstr">=Cutstr$</a></li>
  <li><a href="#replacestr">=Replacestr$</a></li>
  <li><a href="#itemstr">=Itemstr$</a></li>
</ul>


<br>

<a name="binexp"></a>
<p><b>BINEXP</b><br>
<i>function: return the result of two to the power n</i><br>
v=<b>Binexp</b>(a)</p>

<p>
This function calculates the result of the exponential function 2^a, but is much faster than the normal AMOS expression.<br>
The parameter a must lie between 0 and 31.</p>

<pre>
Examples: Binexp(1)=2, Binexp(3)=8, Binexp(16)=65536, Binexp(24)=16777216
</pre>

<br>

<a name="binlog"></a>
<p><b>BINLOG</b><br>
<i>function: return logarithmic function on a basis of two</i><br>
a=<b>Binlog</b>(v)</p>

<p>
Binlog is the reverse function to Binexp. It returns the logarithm to the
value 'v' with basis 2.<br>
'v' therefore must be a power of 2, otherwise you will get an error.</p>

<p>
Binlog is handy to get the number of bitplanes out from the amount of colours of a screen (exception: <a href="additional.html#ham">HAM</a>).</p>

<pre>
Examples: Binlog(2)=1, Binlog(8)=3, Binlog(65536)=16, Binlog(16777216)=24
</pre>

<br>

<a name="lsl"></a>
<p><b>LSL</b><br>
<i>function: return a value as a quick multiplication by a power of two</i><br>
nv=<b>Lsl</b>(v,n)</p>

<p>
Rotates the number 'v' to the left by 'n' bits. I.e that a number 'v',
which is shifted one bit to the left contains the value v*2, with two bits v*4, with 3 bits v*8 etc.</p>

<p>This function is very quick and should be used instead of multiplications wherever possible.</p>

<br>

<a name="lsr"></a>
<p><b>LSR</b><br>
<i>function: return a value as a quick division by a power of two</i><br>
nv=<b>Lsr</b>(v,n)</p>

<p>LSR shifts a number 'v' to the right by 'n' bits. This function does the same as a division by 2^n, but is much quicker.</p>

<br>

<a name="wordswap"></a>
<p><b>WORDSWAP</b><br>
<i>function: return the swap of the upper and lower 16 bits of a value</i><br>
newval=<b>Wordswap</b>(value)</p>

<p>This command swaps the upper and the lower <a href="additional.html#word">Word</a> of a value.</p>

<br>

<a name="qarc"></a>
<p><b>QARC</b><br>
<i>function: return an angle from the coordinates</i><br>
angle=<b>Qarc</b>(deltax,deltay)</p>

<p>
This function will return the angle to a point at the relative coordinates
deltax,deltay.<br>
Angle is in the same format used with Qsin and Qcos, so an angle of 360 degree is equivalent to 1024.<br>
This function is <b>very</b> fast and rather accurate.</p>

<p>
It's normally used for all kinds of 'aiming-at' routines, e.g to get the
angle from one player to another to shoot a missile at ;-)</p>

<br>

<a name="qsin"></a>
<p><b>QSIN</b><br>
<i>function: return a sine of an angle</i><br>
value=<b>Qsin</b>(angle,radius)</p>

<p>
This is a function to replace the original sine function of AMOS.<br>
It is faster and even allows you to multiple the value with the a parameter.</p>

<p>
No math libraries are required.<br>
The angle of the sine 'angle' is not a value in radians or degrees, but with Qsin, an angle of
360 degrees equals a value of 1024.</p>

<br>

<a name="qcos"></a>
<p><b>QCOS</b><br>
<i>function: return the cosine of an angle</i><br>
value=<b>Qcos</b>(angle,radius)</p>

<p>
This is a function to replace the original cosine function of AMOS.<br>
It is faster and even allows you to multiple the value with the a parameter.</p>

<p>
No math libraries are required.<br>
The angle of the sine 'angle' is not value in radians or degrees, but with Qcos, an angle of
360 degrees equals a value of 1024.</p>

<br>

<a name="qrnd"></a>
<p><b>QRND</b><br>
<i>function: return a random number</i><br>
value=<b>Qrnd</b>(maximum number)</p>

<p>
Qrnd is totally identical to the Rnd function, with the only difference, that this one is much faster.</p>

<br>

<a name="qsqr"></a>
<p><b>QSQR</b><br>
<i>function: return the square root of a value</i><br>
root=<b>Qsqr</b>(value)</p>

<p>
This function calculates the square root from the value 'value'.<br>
However, it only works with integer and is faster than the AMOS square root function =Sqr.</p>

<br>

<a name="asc.w"></a>
<p><b>ASC.W</b><br>
<i>function: convert a word string into a number</i><br>
word=<b>Asc.w</b>(word$)</p>

<p>
Asc.w is used to convert a <a href="additional.html#word">word string</a> to a number value. Therefore the result will be between 0 and 65535.<br>
If the length of 'word$' is less than two, the function is aborted and an error message is returned.</p>

<br>

<a name="asc.l"></a>
<p><b>ASC.L</b><br>
<i>function: convert a long string into a number</i><br>
long=<b>Asc.l</b>(long$)</p>

<p>
The Asc.l-function converts a <a href="additional.html#longword">4 bytes</a> long string back into a number.
This value can range between -2147483648 and +2147483647.<br>
If 'long$' contains less than four characters, you will get an error message immediately.</p>

<br>

<a name="vclip"></a>
<p><b>VCLIP</b><br>
<i>function: restrict a value to a given range</i><br>
newval=<b>Vclip</b>(val,lower <b>To</b> upper)</p>

<p>
The Vclip function works like a Min(Max(val,lower),upper) expression, it
restricts a value val into its lower and upper boundaries.</p>

<br>

<a name="vin"></a>
<p><b>VIN</b><br>
<i>function: return a flag to test if a value is within a range</i><br>
flag=<b>Vin</b>(val,lower <b>To</b> upper)</p>

<p>
This function will check if a value lies between lower
and upper. If this is the case, flag will return True (-1), otherwise False (0).</p>

<br>

<a name="vmod"></a>
<p><b>VMOD</b><br>
<i>function: return a value from a modulo operation on a value</i><br>
newval=<b>Vmod</b>(val,upper)<br>
newval=<b>Vmod</b>(val,lower <b>To</b> upper)

<p>
Vmod restricts a value val into the lower and upper boundaries. However,
it does it in another way compared to Vclip.<br>
If val exceeds upper by 1, it will be set to lower, if it exceeds upper by 2, it will be set to
lower+1.<br>
If it goes deeper than lower by 1, it will be set to upper and so on.</p>

<pre>
So this function is not the same as

Add val,delta,lower To upper

If lower is omitted, zero is taken as lower boundary.

Example:

Print Vmod(100,50 To 150) would return 100 (should be clear).

Print Vmod(151,50 To 150) would return 50.

Print Vmod(152,50 To 150) would return 51.

Print Vmod(49,50 To 150) would return 150.

Print Vmod(0,50 To 150) would return 101.
</pre>

<br>

<a name="even"></a>
<p><b>EVEN</b><br>
<i>function: return a flag if a number is even</i><br>
flag=<b>Even</b>(value)</p>

<p>This function returns True (-1), if a number is even or False (0), if a number is odd.</p>

<br>

<a name="odd"></a>
<p><b>ODD</b><br>
<i>function: return a flag if a number is odd</i><br>
flag=<b>Odd</b>(value)</p>

<p>This function returns True (-1), if a number is odd or False (0), if a number is even.</p>

<br>

<a name="patternmatch"></a>
<p><b>PATTERN MATCH</b><br>
<i>function: match a string with a certain pattern</i><br>
flag=<b>Pattern Match</b>(sourcestring$,pattern$)</p>

<p>
Pattern Match checks, if the string 'sourcestring$' matches the pattern 'pattern$'.<br>
If this is the case, then True (-1) will be returned otherwise False (0).<br>
The pattern may contain any regular DOS jokers a asterisk (*) will be converted into '#?' automatically.</p>

<p>This command only works on OS2.0 and higher.</p>

<br>

<a name="chr.w"></a>
<p><b>CHR.W$</b><br>
<i>function: return a two byte string from a number</i><br>
word$=<b>Chr.w$</b>(word)</p>
<p>
This function converts a number into a 2 bytes string.<br>
The upper 16 bits of the value are ignored and therefore you should only use values from 0 to 65535.</p>

<br>

<a name="chr.l"></a>
<p><b>CHR.L$</b><br>
<i>function: return a four byte string from a number</i><br>
long$=<b>Chr.l$</b>(long)</p>

<p>
The Chr.l$ function converts a number into a 4 bytes string. 'long' can be any number you like.<br>
Using this technique, you can save numbers as normal strings.</p>

<br>

<a name="lzstr"></a>
<p><b>LZSTR$</b><br>
<i>function: return a right adjusted number with leading zeros</i><br>
s$=<b>Lzstr$</b>(v,n)</p>

<p>
This function is nearly identical to Lsstr$ with the difference that
leading zeros are not replaced by space characters.<br>
The parameter 'n' sets the number of digits the string should contain and can range from 1 to 10.</p>

<br>

<a name="lsstr"></a>
<p><b>LSSTR$</b><br>
<i>function: return a right adjusted number</i><br>
s$=<b>Lsstr$</b>(v,n)</p>

<p>
Similar to the AMOS function Str$, Lsstr$ creates a string out of a number.<br>
However, with Lsstr$ the number will be created right justified with 'n' digits, leading zeros are replaced by spaces.<br>
The sign of the number will not be printed. 'n' must lie within 1 to 10.</p>

<br>

<a name="insstr"></a>
<p><b>INSSTR$</b><br>
<i>function: insert the second string into the first string</i><br>
newstr$=<b>Insstr$</b>(a$,b$,pos)</p>

<p>This function inserts the string b$ at the position pos into string a$.</p>

<pre>
Example:

Print Insstr$("Hello Ben!","dear ",6) creates 'Hello dear Ben!'.
</pre>

<br>

<a name="cutstr"></a>
<p><b>CUTSTR$</b><br>
<i>function: cut out a piece of a string</i><br>
newstr$=<b>Cutstr$</b>(s$,pos1 <b>To</b> pos2)</p>

<p>This function cuts out part of the string s$ from letter position pos1 to pos2.</p>

<pre>
Example:

Print Cutstr$("Hello dear Ben!",7 To 11) would generate 'Hello Ben!'.
</pre>

<br>

<a name="replacestr"></a>
<p><b>REPLACESTR$</b><br>
<i>function: replace a string with another one</i><br>
newstr$=<b>Replacestr$</b>(s$,search$ <b>To</b> replace$)</p>

<p>This function searches in the string s$ for occurrences of search$ and replaces them with the string replace$.</p>

<br>

<a name="itemstr"></a>
<p><b>ITEMSTR$</b><br>
<i>function: returns an item contained in a string</i><br>
item$=<b>Itemstr$</b>(s$,itemnum)<br>
item$=<b>Itemstr$</b>(s$,itemnum,sep$)</p>

<p>
This is a very handy function that helps you to avoid little string arrays
where actually no are required.<br>
s$ contains a number of so called items, which are numbered increasingly from zero onwards.</p>

<p>
Normally, the items are separated with a '|' character, but you can give your own single character
for separation in the optional string sep$.</p>

<p>
Empty strings for s$ are not allowed and will create an error message,
however, empty items can be used without hesitation.<br>
Trying to access an item, that does not exist, will create an error as well.</p>

<pre>
Example:

Print Itemstr$("Ben|Semprini|Petri|Andy",1) would return 'Semprini'.

Print Itemstr$("The quick brown fox",2," ") would return 'brown'.

Print Itemstr$("zero|one|two||four|five,5) would return 'five'.

Print "The weather is "+Itemstr$("great|fine|nice|not bad|rainy|awful|apocalyptic",WEATHER)

would have a similar effect to:

Dim W$(6)
For A=0 To 6
  Read W$(A)
Next
Print "The weather is "+W$(WEATHER)
[...]
Data "great","fine","nice","not bad","rainy","awful","apocalyptic"
</pre>

</body>
</html>
