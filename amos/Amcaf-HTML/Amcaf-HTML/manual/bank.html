<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
  <!--
      AMCAF Extension V1.40 Manual for Amos Professional, written by Chris Hodges (1994/95) and compiled by asymetrix for the Amiga community and should stay completely FREE FOREVER.
      Created 2009. :)
  -->
  <title>AMCAF Extension V1.40 Manual</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="keywords" content="AMCAF Extension V1.40 Manual, Amos Professional, Amiga, Programming, Basic, Chris Hodges, Extension, computing, code, AmigaDOS, Aminet.net">
  <meta name="author" content="asymetrix">

</head>

<body bgcolor="white">
<a href="../index.html">AMCAF Extension V1.40 Manual</a>&nbsp; <a href="../command.html">Index</a>

<hr align="center" size="1" width="100%">

<h1>Bank Commands</h1>

<br>

<p>AMCAF contains many commands that are dedicated to AMOS memory banks.<br>
With all these commands it's important to use EVEN addresses, if there are some demanded.<br>
Otherwise you will crash any computer with MC68000 processor.<br>
In addition, the lengths of every bank must be even, or the compiler will
report a "Not an AMOS program" error, but this is a problem of AMOS and not of AMCAF.</p>

<br>

<a name="bankcommand"></a>
<h2>Bank Commands</h2>

<ul>
  <li><a href="#bankperm">Bank Permanent</a></li>
  <li><a href="#banktemporary">Bank Temporary</a></li>
  <li><a href="#banktofast">Bank To Fast</a></li>
  <li><a href="#banktochip">Bank To Chip</a></li>
  <li><a href="#bankstretch">Bank Stretch</a></li>
  <li><a href="#bankcopy">Bank Copy</a></li>
  <li><a href="#bankname">Bank Name</a></li>
  <li><a href="#bankencode">Bank Code xxx.y</a></li>
  <li><a href="#bankdeltaencode">Bank Delta Encode</a></li>
  <li><a href="#bankdeltadecode">Bank Delta Decode</a></li>
  <li><a href="#bankchecksum">=Bank Checksum</a></li>
  <li><a href="#banknamestring">=Bank Name$</a></li>
</ul>

<br>

<a name="amosmemorybanks"></a>
<h2>AMOS Memory Banks</h2>

<p>
AMOS banks are a linear block of memory (there are two <a href="additional.html#iconsandsprites">Exceptions</a>). In
these chunks various kinds of data is stored. AMOS uses them mostly for
packed graphics, sound, music, AMAL programs, menus, resources and other data.</p>

<p>Generally, there are four main types of memory banks:</p>

<ul>
  <li>Banks, that are stored in <a href="additional.html#chipram">Chip ram</a> and remain there <a href="additional.html#permanentbanks">permanently</a>.</li>
  <li>Banks, that are stored in <a href="additional.html#fastram">Fast ram</a> and remain there <a href="additional.html#permanentbanks">permanently</a>.</li>
  <li>Banks, that are stored in <a href="additional.html#chipram">Chip ram</a> and remain there <a href="additional.html#temporarybanks">temporarily</a> only.</li>
  <li>Banks, that are stored in <a href="additional.html#fastram">Fast ram</a> and remain there <a href="additional.html#temporarybanks">temporarily</a> only.</li>
</ul>

<br>

<a name="bankperm"></a>
<h2>Permanent and Temporary Memory Banks</h2>

<p><b>BANK PERMANENT</b><br>
<i>instruction: make a memory bank permanent</i><br>
<b>Bank Permanent</b> bank number</p>

<p>
If you defined a bank as 'Work', but afterwards want this bank to be
<a href="additional.html#permanentbanks">Permanently</a> in memory and in the program, you could use Bank Permanent.<br>
This will make the bank stay resident in your program until it is erased.<br>
This command also has use on MED-Modules, which were loaded with the
Med Load command and on Power and Imploder unpacked banks.
</p>

<br>

<a name="banktemporary"></a>
<p><b>BANK TEMPORARY</b><br>
<i>instruction: make a memory bank temporary</i><br>
<b>Bank Temporary</b> bank number</p>

<p>
Changes a bank to <a href="additional.html#temporarybanks">Temporary-type</a>, i.e it will be erased on the start of
your program or when calling the Default-Command.</p>

<br>

<a name="banktofast"></a>
<p><b>BANK TO FAST</b><br>
<i>instruction: move a memory bank to fast ram</i><br>
<b>Bank To Fast</b> bank number</p>

<p>
Moves a bank into <a href="additional.html#fastram">Fast ram</a>, if any is available. Naturally, the
bank will get a new starting address.<br>
Bank To Fast won't work with <a href="additional.html#iconsandsprites">Icon and sprite bank</a>.<br>
<b>Warning: Do not try to replay music or sound that exist in fast ram</b>.</p>

<br>

<a name="banktochip"></a>
<p><b>BANK TO CHIP</b><br>
<i>instruction: move a memory bank to chip ram</i><br>
<b>Bank To Chip</b> bank number</p>

<p>
Bank To Chip is the reverse command to Bank To Fast. It moves a bank into
<a href="additional.html#chipram">Chip ram</a>. Obviously, the starting address will therefore change.</p>

<br>

<a name="bankstretch"></a>
<p><b>BANK STRETCH</b><br>
<i>instruction: extend the size of a bank to a new length</i><br>
<b>Bank Stretch</b> bank number <b>TO</b> length</p>

<p>
Extents the bank numbered 'bank' to the given new length 'length'.<br>
During this process, the starting address of the bank is changed. This command
does not work on <a href="additional.html#iconsandsprites">Icon and sprite banks</a>.
</p>

<br>

<a name="bankcopy"></a>
<p><b>BANK COPY</b><br>
<i>instruction: copy a memory bank</i><br>
<b>Bank Copy</b> sourcebank <b>TO</b> targetbank<br>
<b>Bank Copy</b> startaddress,endaddress <b>To</b> targetbank</p>

<p>
Creates a identical copy of the bank with the number 'sourcebank' in the
bank numbered 'targetbank'.<br>
The second version copies a specific part of the source bank into the
target bank, creating a <a href="additional.html#temporarybanks">temporary</a> bank of same content.</p>

<br>

<a name="bankname"></a>
<p><b>BANK NAME</b><br>
<i>instruction: rename a memory bank</i><br>
<b>Bank Name</b> bank number,name$</p>

<p>
This command renames a bank to the 8 characters long name
'name$'. Most AMOS commands ignore this ID, but e.g the AMOS Tracker
commands require a bank named 'Tracker'.</p>

<br>

<a name="bankencode"></a>
<h2>Encoding and Decoding Memory Banks</h2>

<p>
Using these commands you can encode banks in many different ways to
protect them from unauthorized access and insight. Especially manual copy
protections can be made more secure by encoding the specific keyword bank.</p>

<p>
Each command comes in two versions, one with the suffix <a href="additional.html#byte">.b</a> and
one with <a href="additional.html#word"> .w</a>. By using the .b version the codenumber can
range from 1 to 255, the .w version allows codes from 1 to 65535.<br>However,
the rotational commands are an exception as the codes may only reach from
1 to 7 and from 1 to 15 respectively.</p>

<p>Every command has the following syntax</p>

<p>
Bank Code xxx.y code,bank<br>
Bank Code xxx.y code,startaddress To endaddress</p>

<br>

<a name="bankcodeadd"></a>
<p><b>BANK CODE ADD</b><br>
<i>instruction: encode or decode a memory bank using addition</i><br>
<b>Bank Code Add.b</b> code,bank number<br>
<b>Bank Code Add.b</b> code,startaddress <b>To</b> endaddress<br>
<b>Bank Code Add.w</b> code,bank number<br>
<b>Bank Code Add.w</b> code,startaddress <b>To</b> endaddress<br>
</p>

<p>
Encodes the bank using the key code 'code'. To decode the
bank, the same instruction has to be used with the negative key code.</p>

<p><b>Note:</b> This encoding routine works by adding the value and is therefore very easy to decode.</p>

<br>

<a name="bankcodexor"></a>
<p><b>BANK CODE XOR</b><br>
<i>instruction: encode or decode a memory bank using xor</i><br>
<b>Bank Code Xor.b</b> code,bank number<br>
<b>Bank Code Xor.b</b> code,startaddress <b>To</b> endaddress<br>
<b>Bank Code Xor.w</b> code,bank number<br>
<b>Bank Code Xor.w</b> code,startaddress <b>To</b> endaddress<br>
</p>

<p>
Bank Code Xor encrypts a bank in a similar way to Bank Code Add using another algorithm.
Each byte or word of the bank is combined by a 'logical exclusive or'.<br>
To decode the bank simply use the same command along with the same key code.</p>

<p><b>Note:</b> A Xor encryption is not so easy to crack without the right code. Good codes are $AA and $55.</p>

<br>

<a name="bankcodemix"></a>
<p><b>BANK CODE MIX</b><br>
<i>instruction: encode or decode a memory bank using mix</i><br>
<b>Bank Code Mix.b</b> code,bank number<br>
<b>Bank Code Mix.b</b> code,startaddress <b>To</b> endaddress<br>
<b>Bank Code Mix.w</b> code,bank number<br>
<b>Bank Code Mix.w</b> code,startaddress <b>To</b> endaddress<br>
</p>

<p>
The third possibility to encode a bank, is with Bank Code Mix. So coded banks should be hard to decode.<br>
To decode a bank you should use the same key code as seen with Bank Code Xor.</p>

<br>

<a name="bankcoderol"></a>
<p><b>BANK CODE ROL</b><br>
<i>instruction: encode or decode a memory bank using rol</i><br>
<b>Bank Code Rol.b</b> code,bank number<br>
<b>Bank Code Rol.b</b> code,startaddress <b>To</b> endaddress<br>
<b>Bank Code Rol.w</b> code,bank number<br>
<b>Bank Code Rol.w</b> code,startaddress <b>To</b> endaddress<br>
</p>

<p>
Using this command every bit in each byte or word is rotated by 'code'
bits to the left. (Rol=Rotate Left). This results in a restriction of the
'code' parameter from 1 to 7 on '.b' and 1 to 15 on '.w' command version.<br>
To decode a bank either use the negative code with the same instruction or
the same key code along with the Bank Code Ror command.
</p>

<br>

<a name="bankcoderor"></a>
<p><b>BANK CODE ROR</b><br>
<i>instruction: encode or decode a memory bank using ror</i><br>
<b>Bank Code Ror.b</b> code,bank number<br>
<b>Bank Code Ror.b</b> code,startaddress <b>To</b> endaddress<br>
<b>Bank Code Ror.w</b> code,bank number<br>
<b>Bank Code Ror.w</b> code,startaddress <b>To</b> endaddress<br>
</p>

<p>
Similar to Bank Code Rol, but this time the bits are shifted to the right instead of left.</p>

<br>

<h2>Delta Encoding and Decoding</h2>

<a name="bankdeltaencode"></a>
<p><b>BANK DELTA ENCODE</b><br>
<i>instruction: encode a memory bank using delta algorithm</i><br>
<b>Bank Delta Encode</b> bank number<br>
<b>Bank Delta Encode</b> startaddress <b>To</b> endaddress
</p>

<p>
Bank Delta Encode encodes a memory bank with the so-called delta algo.<br>
This is not packing, however, but yields better pack ratios on 8-bit sound samples.<br>
Delta encoding just stores the difference from one byte to the next, so it is certain full curve patterns in
samples can be seen more 'clearly' for packing algorithms.</p>

<pre>
On Protracker Modules, you could use:

Encode samples only:

Pt Bank 3
Bank Delta Encode Pt Instr Address(1) To Start(3)+Length(3)

Decode:

Pt Bank 3
Bank Delta Decode Pt Instr Address(1) To Start(3)+Length(3)
</pre>

<br>

<a name="bankdeltadecode"></a>
<p><b>BANK DELTA DECODE</b><br>
<i>instruction: decode a memory bank using delta algorithm</i><br>
<b>Bank Delta Decode</b> bank number<br>
<b>Bank Delta Decode</b> startaddress <b>To</b> endaddress
</p>

<p>
This command decodes a previously delta encoded memory region.<br>
See Bank Delta Encode for more details on delta encoding.</p>

<br>

<h2>Functions</h2>

<a name="bankchecksum"></a>
<p><b>BANK CHECKSUM</b><br>
<i>function: calculate the checksum of a memory bank</i><br>
number=<b>Bank Checksum</b>(bank number)<br>
number=<b>Bank Checksum</b>(startaddress <b>To</b> endaddress)
</p>

<p>
This function calculates a checksum of a bank with specific contents.
Using this checksum you can find out if the contents of a bank has been changed.<br>
The second version of this command calculates the checksum from the memory area from startaddress to endaddress.</p>

<br>

<a name="banknamestring"></a>
<p><b>BANK NAME$</b><br>
<i>function: get the name of a memory bank</i><br>
name$=<b>Bank Name$</b>(bank number)<br></p>

<p>The function Bank Name$ returns the name of a memory bank.</p>

</body>
</html>
