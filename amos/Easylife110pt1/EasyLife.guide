@database Easylife.guide
@author "Paul Hickman"
@$VER: Easylife.guide 1.10 (09.09.94)
@width 77
@index SubjectIndex
@node main "Easylife - An Extension For AMOS Creator & AMOS Professional"
@next Introduction

		  @{u}@{b}Easylife Extension V1.10 - By Paul Hickman@{uu}


			E-Mail: ph@doc.ic.ac.uk@{ub}


Welcome to Easylife. Use the @{"Browse >>" link Introduction} Button to read the entire manual
for the first time, or the hypertext links for reference.

	@{"Introduction/Distribution    " link Introduction}

@{u}Section 1: Internal AMOS Improvements@{uu}

	@{"Zone Commands                " link ZoneContents}
	@{"String Commands              " link StringContents}
	@{"Bitwise Commands             " link BitContents}
        @{"Structured Variables         " link EasyLifeSTRUCT.guide/main}
	@{"Miscellaneuos Commands       " link MiscContents}


@{u}Section 2: Amiga OS & Library utilisation@{uu}

	@{"Powerpacker & XPK Commands   " link PackContents}
	@{"Pattern Matching             " link PatternContents}
	@{"AmigaDOS / Intuition Commands" link DosContents}


@{u}Section 3: Magic User Interface programming@{uu}

	@{"MUI Introduction             " link EasylifeMUI.guide/MUIintro}
	@{"Taglist Parsing              " link EasylifeMUI.guide/TagContents}
	@{"MUI Commands & Functions     " link EasylifeMUI.guide/MUIContents}


@{u}Section 4: Support Program & Accessoriess@{uu}

	@{"AMOS Guide Viewer            " link /Accessories/AmosGuide.guide/main}
        @{"Editor Enhancer              " link /Accessories/Editor_Enhancer.guide/main}
	@{"Variable Checker             " link /Accessories/Var_Checker.guide/main}
	@{"Program Optimser             " link /Accessories/Optimse.guide/main} (Program Not Written Yet)
	@{"Equates To Tags              " link EquatesToTags.guide/main} (Documentation Not Written Yet)
	@{"Taglist Editor               " link TaglistEditor.guide/main} (Documentation Not Written Yet)
        @{"Tabifier                     " link /Applications/Tabifier.guide/main}
        @{"Structures Compiler          " link EasylifeSTRUCT.guide/Compiler}
	@{"Zone Editor                  " link /Accessories/Zone_Editor.guide/main}

@{u}Section 5: Appendices@{uu}

	@{"Complete Command Index       " link CommandIndex}
	@{"Complete Subject Index       " link SubjectIndex}
	@{"Changes To AMOS Commands     " link CommandEffects}
	@{"To-Do List                   " link todo}

@endnode

@node Introduction "Introduction"

			  @{u}@{b}Welcome To Easylife V1.10@{ub}@{uu}

This manual is presented as a amigaguide document, to allow quick reference.
However, this often hinders reading it as an instruction manual for the first
time. To overcome this use the @{"Browse >>" link howtolead} button to move
through the pages in a logical order. You will see all pages of the manual 
except Menus/Indexes. Press @{"Browse >>" link howtolead} now to continue. 

        @{"How To Lead An EASY LIFE       " link howtolead}
    	@{"What Else To I Need?           " link alsoneeded}
    	@{"Installation of Easylife       " link installation}
    	@{"Coventions used in this manual " link conventions}
        @{"Compatibility with old versions" link compatibility}
@endnode 

@node howtolead "Introduction / How to lead an EASY LIFE"
@toc Introduction

			  @{u}@{b}How To Lead An EASY LIFE@{ub}@{uu}


The EASY LIFE extension is designed to do just that - make life easier -
especially the parts of said life spent writing AMOS programs. The 
commands included are not designed to speed up graphics to amazing 
levels, even on an bog standard A500 which has the MC68000 pulled out, 
and replaced with a lego brick, or to put a starfield in the background
(Why is it virtually every AMOS extension written has starfied 
commands???), but to speed up the actual computing work done in the 
background, to allow you access to some of AMOS's internal variables,
and to provide support for powerpacker, pattern matching, message banks,
zone banks, and in the latest version XPK and MUI.
@endnode

@node alsoneed "Introduction / What else to I need?"
@toc Introduction

                           @{u}@{b}What else do I need?@{ub}@{uu}

This distribution contains everything you need for the majority of easylifes
commands & functions to run. However, you will also need:

 - The XPKmaster & XPK compressors libraries, if you wish to use the
   @{"Elxpk commands" link PackContents}. These can be obtained from
   aminet in the directory /pub/aminet/util/pack/. I think the filename
   is xpk25usr.lha, but don't quote me on that...

 - The MUI user & developers archives, if you wish to use the Elmui
   commands. You will also need Kickstart 2.04+ to use MUI. Download
   /pub/aminet/dev/gui/mui22usr.lha & mui22dev.lha. (The version numbers
   may be 23, 24 or even 30 (hope) by the time you read this...) I have
   tested versions 2.1 & 2.2. Don't use anything lower. Install the user
   archive with the installer program, and copy the AUTODOCS, mui-developer's
   guide, C examples, and assembler mui.i files from the mui22dev archive
   to somewhere on your harddisk (Don't even *think* of running MUI from
   a floppy - I suppose it is theoretically possible), and ditch the rest
   of the developers archive, unless you also want to program MUI from other
   languages.

These are not required, but you will benefit from having them:

 - The AMOS intuition extension.

 - Powerpacker V3.0 / V4.0
@endnode



@node installation "Introducton / Installation"
@toc Introduction

                               @{u}@{b}Installation@{ub}@{uu}

There are 2 parts to installing easylife - getting the files in the right
places on your system, and telling AMOS they are there. The Installer script
will to the first part, but you must do the second. If you don't have the
installer:

 - Copy the /libs directory to your AMOSPro bootdisk / harddisk LIBS:,
   checking that these are *newer* versions of any library you replace.

 - Copy the accesories to AMOSPro_Accessories: , or some other permanent
   location if there is no space.

 - Copy the demo, docs, Procedures and Mui drawers somewhere permanent

 - Edit you user startup to add the docs drawer to the HELP: path. For
   KS 1.3 people, thsi means assign HELP: to the docs drawer. For KS2.0+
   if HELP: is already assigned (And it should be), use Assign ADD.



To install for AMOS Creator:

    (NOTE: AMOS Creator version is not in this archive)

 - Copy Lib/Easylife.Lib to the AMOS_System directory if you didn't
   run the installer script. 

 - Run Config1_3.AMOS, load the default configuration, select 'Loaded
   Extensions' and enter :AMOS_System/Easylife.Lib" into slot 16. Then
   save the default configuration.



To install for AMOS Professional

 - Copy Lib/AMOSPro_Easylife.Lib to AMOSPro_System:APSystem/ if
   you didn't run the installer script.

 - Load AMOSPro, and select "Set Interpreter" from the config menu. Load
   the default configuration, click on loaded extensions, and enter
   'AMOSPro_Easylife.Lib' into slot 16. Then save the default configuration.


Both Versions.

 - Now quit & reload your version of AMOS.


NOTE: Additional installation may be required to use @{"MUI" link EasylifeMUI.guide/MUIIntro}
@endnode




@node Conventions "Introduction / Conventions"
                  @{u}@{b}Conventions Used In This Manual@{ub}@{uu}

Each page of this manual describes a group of related commands, and/or
function calls, and is divided into the following sections.

@{u}Command Syntax@{uu}
@toc Introduction

    This shows the syntax of all commands & functions covered on the page.
    If a keyword is preceeded with an '=' sign, then it defines a function 
    call. This means that it should be used as an AMOS expession - E.g.

	A = Znsx(10)
	Print Pp Len(0);

    If it does not, then it is an AMOS command, and should only be used at
    the start of a statement - E.g.

	Set Bank Name 10,"Fred    "
	If A=10 Then Pp Load 1,"RAM:Test",2
        
    The command/function name is followed by it's arguments, which are in
    capitals. If a particular command/function can have several argument 
    formats, all are listed here.

    Any words in @{i}italics @{ui}are the formal parameters of the command /
    function, in all sections.


@{u}Description@{uu}

    This section contains a few paragraphs describing the usual action of
    the command / function in general terms.


@{u}Notes@{uu}

    This section describes any special cases for the command where it does
    not behave in the expected manner, exceptions to the explanation given
    in the description section, and any conditions under which it should not 
    be used etc.


@{u}Errors@{uu}

    This section lists all possible errors messages generated by the
    command / function, and explains their most likely causes.

    NOTE: 'Out of variable space', and 'Out of memory' may also occur with
    some commands, but are not listed, as they as generally not a result of
    a problem with the specific instruction, but with the entire program.

@{u}See Also@{uu}

    This section list related commands that are not in the same sub-section
    of the manual that you are reading, or are not easylife commands.

@{u}Bugs@{uu}

    This section is non-existant (I Hope) :-)

@endnode
        
@node Compatibility "Introduction / Compatibility with older versions of easylife"


               @{b}@{u}Compatibility with older versions of easylife@{ub}@{uu}


    Firstly, this may be a little confusing, since I changed version numbers
    halfway thourgh development to comform to commodore standards. The
    versions so far are:

    Phase 1
    =======

    V1.0        Original AMOS Creator Version
    
    V1.1        Improved Version Creator Version

    V1.2        Ditto.


    Phase 2
    =======

    V1.3.1      Dual Creator / Pro version. Some new commands.

    V1.3.2      Bugfix to previous version.

    V1.3.3      More Bugfixes / AMOSPro specified optimisations.

   
    Phase 3
    =======

    V1.3.4      Added the 'El' prefix to all command names.

    V1.4        Internal restructuring - Bug fixes.

    V1.4.1      XPK commands added.

    V1.4.2      Bug fixes.

    V1.4.3      Bug fixes.

    V1.4.4      Elf Char now search for many characters.

    V1.5        Primitive MUI support added. Intuition routines
                improved.

    V1.06       Switched to commodore version numbering. Refined MUI
                functions.


    Phase 4
    =======

    
    V1.07       Taglist editor support added & all MUI commands renamed.
                Various other improvements. Structure variable commands
                added.

    V1.08       Easylife.Library created. Structure variable commands
                moved to library.

    V1.09       Amigaguide Viewer Written & AMOSPro help replaced. Minor
                bug fixes & changes to the other programs. Due to an error
                in the V1.08 token table, programs which use the new font
                commands will need retokenising.
    

    This version should be nearly 100% compatible with other Phase 4
    versions. The only changes are that the Ellock Font & Elunlock Fonts
    commands were removed in V1.08. Use Elopen Font instead.

    Converting Phase 3 programs should mainly be done by Retokenising 
    them (AMOSPro_Tutorials/ReTokenise.AMOS) - A few commands may need
    changing (E.g. Old style MUI comands / XPK commands). Phase 1 & 2
    versions would have to changed by hand from a text editor using
    AMOSPro's Save AscII as the command names have all changed.
@endnode













@node ZoneContents "Zone Commands & Functions - Contents"
@toc main
			   @{u}@{b}Screen Zone Support@{ub}@{uu}


The AMOS Manuals imply that the only use of screen zones is to detect when 
objects or points lie within them. Easylife provides the commands necessary 
for you to use zones for any purpose that requires an area of the screen to
be marked, and is particularly useful for control buttons.

There are three types of zone support command:

@{u}Section 1: Reading / Modifing standard zones@{uu}

	@{"Reading a zones co-ordinates" link C_Elznsx}
	@{"Moving zones                " link C_ElznShift}


@{u}Section 2: Multi-Zones@{uu}

	@{"What is a multi-zone    " link WhatIsMultiZone}
	@{"Reserving multi-zones   " link C_ElmzReserve}
	@{"Deallocating multi-zones" link C_ReserveZone}
	@{"Defining a multi-zone   " link C_ElmzSet}
	@{"Reading co-ordinates    " link C_Elmznsx}
	@{"Checking  multi-zones   " link C_Elmzone}
	@{"Erasing a multi-zone    " link C_ElmzSet}
	@{"Erasing groups of zones " link C_ElmzErase}
        
        

@{u}Section 3: Zonebanks@{uu}

	@{"What is a zone bank                 " link ZoneBank}
	@{"Installing a group as standard zones" link C_ElzbAdd}
	@{"Installing a group as multi zones   " link C_ElzbMultiAdd}
	@{"Installing all groups as multi zones" link C_ElzbInstall}

@endnode

@node C_Elznsx "Zones / Read a zones co-ordinates"
@toc ZoneContents

@{b}Command Syntax@{ub}

	=ElZnsx( @{i}ZONE @{ui})               
	=ElZnsy( @{i}ZONE @{ui})
	=ElZnex( @{i}ZONE @{ui})
	=ElZney( @{i}ZONE @{ui})

	=ElZnsx( @{i}SCREEN , ZONE @{ui})
	=ElZnsy( @{i}SCREEN , ZONE @{ui})
	=ElZnex( @{i}SCREEN , ZONE @{ui})
	=ElZney( @{i}SCREEN , ZONE @{ui})



@{b}Description@{ub}

    When you use the AMOS command Set Zone, you supply it with the 
    parameters 'sx,sy to ex,ey' to define the co-ordinates of the zone. 
    These function calls allow you to read back the current values of 
    these parameters for a given @{i}ZONE@{ui}. E.g.

	Set Zone 1,10,20 To 30,40
	Print ElZnsx(1);",";ElZnsy(1)
	Print ElZnex(1);",";ElZney(1)

    Will display the values:

	10, 20
	30, 40
    

    The optional @{i}SCREEN @{ui}parameter specifies the screen number the 
    zones are defined on. If as above, it is omitted, it is assumed they 
    are defined on the current screen.



@{b}Notes@{ub}
         
    These commands return signed integers. (-32768 to 32767)

    If a zone has been reserved, but not defined with Set Zone, all four 
    functions will return 0.



@{b}Errors@{ub}

    @{u}Screen Not Opened@{uu}

    The @{i}SCREEN @{ui}number you have defined is not open. If you have omitted 
    this parameter, this error means that no screens are open.


    @{u}Illegal Function Call@{uu}

    This means the specified @{i}ZONE @{ui}has not been reserved on the specified
    @{i}SCREEN@{ui}.

@endnode        

@node C_ElznShift "Zones / Moving Zones"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElZn Shift @{i}SCREEN , DX , DY @{ui}

	ElZn Shift @{i}SCREEN , DX , DY , START @{ui}To @{i}FINISH @{ui}



@{b}Description@{ub}

    The first instruction will scroll all the zones defined on the given
    @{i}SCREEN DX @{ui}pixels to the right, and @{i}DY @{ui}pixels downwards. 

    To scroll to the left, make @{i}DX @{ui}negative. To scroll upwards, make 
    @{i}DY @{ui}negative.

    If specified @{i}START @{ui}and @{i}FINISH @{ui}allow only the zones with
    numbers between @{i}START @{ui}and @{i}FINISH @{ui}(Inclusive) to be scrolled. E.g.
    
	Elzn Shift 0,-16,10,4 To 7
        
    Will scroll zoes 4,5,6 & 7 to the left by 16 pixels, and down 10 on
    screen 0.    



@{b}Notes@{ub}

    - Scrolling a zone does not change the image displayed on the screen,
      it merely moves the co-ordinates of your zones to reflect the changes
      to the image made by screen copy, scroll, or the AMOS Turbo Plus Blit
      commands.

    - You can shift a single zone by making both @{i}START @{ui}and @{i}FINISH @{ui}equal to
      the zone number.

    - ElZn Shift does not work with multi-zones.

    - It is not an error to shift a zone off the screen.

    - The arithmatic for zone co-ordinates is done modulo 65536. This means
      if you shift a zone with co-ordinates 10,10 to 50,20 by 20 pixels to
      the left, the new co-ordinates will be 65526,10 to 30,20.

      This will confuse the AMOS =Zone(X,Y), Mouse Zone, and related 
      functions, but not @{"Elznsx" link C_Elznsx} and the other easylife
      zone reading commands.



@{b}Errors@{ub}

    @{u}Screen Not Opened@{uu}

    The given @{i}SCREEN @{ui}is not open.


    @{u}Illegal function call@{uu}

    Either:

    - No zones are reserved on the given screen

    - @{i}START @{ui}or @{i}FINSH @{ui}is greater than the number of zones reserved

    - @{i}START @{ui}is greater than @{i}FINISH @{ui}

@endnode


@node WhatIsMultiZone "Multi Zones / What is a multi zone"
@toc ZoneContents

			   @{b}@{u}What Is A Multi Zone?@{ub}@{uu}

A multi zone is similar to a normal screen zone. It is a rectangular area 
of the screen, and you can detect if given co-ordinates fall within it. 
The differences are:

  - Multi zones are identified by a GROUP number, and a ZONE
    number. Neither need be sequential, you can define zones
    1,3,10 of group 1, then zone 431 of group 839 if you want -
    it will still only take 4 zones worth of memory.

  - All Multi zones can in one group can be erased with one
    command, without affecting the other groups.

  - You can detect if co-ordinates lie in any multi zone, or if
    they lie in any multi zone from one particular group.

  - You can find all the zones a point lies in, not just the
    first one in the list (unlike standard zones).

@endnode

@node C_ElmzReserve "Multi Zones / Reserving Space"
@toc ZoneContents
@{b}Command Syntax@{ub}

	ElMz Reserve @{i}NUM @{ui}



@{b}Description@{ub}

    This command is the equivilent of the Reserve Zone command. It reserves
    memory for the chosen number of zones. NUM should be even. If the value
    you supply is not, it is rounded up. A maximum of 5460 multi zones can
    be defined. (There is a good reason for that number!)

    The Multi zones take the place of the normal screen zones in the screen
    data structure, so they cannot be used at the same time. Multi zone
    commands will produce an error message if you attempt to use them when
    normal screen zones are defined. Normal screen zones will not work with
    multi zones installed, but will not produce error messages, just 
    unreliable results.




@{b}Notes@{ub}

  - When you call ElMz Reserve, the previously installed
    zones/multi zones are erased - you do not get a Zones
    already reserved error.



@(b}Errors@{ub}

    @{u}Out of memory@{uu}

    Not enough memory could be reseved for the zone table.

@endnode

@node C_ReserveZone "Multi Zones / Eraseing All Multi Zones"
@toc ZoneContents

@{b}Command Syntax@{ub}

	Reserve zone



@{b}Description@{ub}

    This the standard AMOS reserve zone command. Used with no parameters,
    it will erase all multi zones. They are also erased properly when the
    screen is closed / default command used, or under any other
    circumstance when normal screen zones are removed.


    
@{b}See Also @{ub}

    @{"Changes to AMOS Commands" link CommandEffects}

@endnode    

@node C_ElmzSet "Multi Zones / Defining & Erasing A Multi Zone"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElMz Set @{i}GROUP , ID , X1 , Y1 @{ui}To @{i}X2 , Y2 @{ui}
	ElMz Set @{i}GROUP , ID @{ui}



@{b}Description@{ub}

    This is virtually identical to Set Zone command, except you must supply
    a @{i}GROUP @{ui}number. @{i}GROUP @{ui}and @{i}ID @{ui}can be any number between 1 and 65535.
    @{i}X1,Y1,X2,Y2 @{ui}can be between -32768 and 32767.

    @{i}X1,Y1 @{ui}and @{i}X2,Y2 @{ui}are automatically sorted so @{i}X1 @{ui}<= @{i}X2@{ui}, and @{i}Y1 @{ui}<= @{i}Y2@{ui}, so
    @{"Elmznsx" link C_Elmznsx} etc. always return the correct values.

    The second form of the instruction erases the specified zone.


@{b}Notes@{ub}


  - If you call ElMz Set twice with the same @{i}GROUP & ID @{ui}
    numbers, the old co-ordinates are overwritten.


@{b}Errors@{ub}

    @{u}Illegal Funciton Call@{uu}

    Neither @{i}GROUP @{ui}or @{i}ID @{ui}can be 0, or greater than 65535.


    @{u}Zone table full@{uu}

    You have already used all @{"Reserved" link C_ElmzReserve} multi zone space.


    @{u}Multi Zones Not Reserved@{uu}

    You have not reserved any multi zone space with the @{"ElMz Reserve" link C_ElmzReserve}, or have since
    used the standard @{"Reserve Zone" link C_ReserveZone} command.

@endnode

@node C_Elmznsx "Multi Zones / Reading multi zone co-ordinates"
@toc ZoneContents

@{b}Command Syntax@{ub}

	= ElMznsx( @{i}GROUP , ID @{ui})
	= ElMznsy( @{i}GROUP , ID @{ui})
	= ElMznex( @{i}GROUP , ID @{ui})
	= ElMzney( @{i}GROUP , ID @{ui})



@{b}Description@{ub}

   These are multi zone equvilents of the commands to read a standard AMOS
   zone's co-ordinates, @{"Elznsx" link C_Elznsx} etc. Each function call returns the
   coresponding co-ordinate of the edge of the zone.



@{b}Notes@{ub}

  - All operate on the current screen only.

  - @{"Elmz Set" link C_ElmzSet} sorts X1,X2,Y1,Y2 so ElMznsx/y are always 
    greater than ElMznex/y.

  - The values returned are signed (-32768 to 32767).


@{b}Errors@{ub}

    @{u}Multi Zone Not Defined@{uu}

    The zone with the specified (@{i} GROUP , ID @{ui}) does not exist.


    @{u}Screen Not Opened@{uu}

    Since these commands operate on the current screen, this
    error means that no screen was open.
@endnode



@node C_Elmzone "Multi Zones / Find the multi-zones containing a point"
@toc ZoneContents

@{b}Command Syntax@{ub}

	= ElMzone( @{i}X , Y @{ui})
	= ElMzone( @{i}X , Y , GROUP @{ui})
	= ElMzonen
	= ElMzoneg



@{b}Description@{ub}

   The first form of ElMzone returns the zone ID of the first multi zone
   on the current screen that the point @{i}X,Y @{ui}lies within. The second form of
   Mzone only checks the zones in one particular @{i}GROUP@{ui}.

   ElMzonen returns the zone ID of the next multi zone that the point 
   specified in the last ElMzone command lies within. If the second form 
   of ElMzone was used to specify the point, ElMzonen will return the next
   zone in the searched @{i}GROUP @{ui}that contains the point.

   Mzoneg returns the group number of the last multi-zone ID returned by the
   previous ElMzone or ElMzonen commnad.



@{b}Notes@{ub}

  - All of these commands return 0 if there is no remaining zone which
    contains the point specified.

  - ElMzoneg will still work if you specify a group in the ElMzone command,
    but it will only ever return group number @{i}GROUP@{ui}, or 0 if no zone was
    found in the @{i}GROUP @{ui}that contained the point.

  - The zones containing the point won't be returned in any particular
    order.



@{b}Errors@{ub}

    @{u}Multi Zones Not Reserved@{uu}

    No multi zones have been reserved on the current screen.
@endnode



@node C_ElmzErase "MultiZones / Removeing A Multi Zone Group"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElMz Erase @{i}GROUP @{ui}



@{b}Description@{ub}

    This command erases all zones in the given @{i}GROUP@{ui}. Unlike standard AMOS
    zones, when you reserve multi-zones, you reserve space for a certain
    number of zones, but those zones may have any group and zone id numbers.
    Erasing a group of zones frees the space in the zone table for use by 
    other groups.



@{b}Notes@{ub}

  - This command does not deallocated any memory.
  
  - To remove all multi zones & deallocate the memory, use the standard AMOS
    @{"Reserve Zone" link C_ReserveZone} command.

  - A single zone can be erased with the {"ElMz Set" link C_ElmzSet} command.

  

@{b}Errors@{ub}

    @{u}Multi Zones Not Reserved@{uu}

    You have not reserved any multi zones on the current screen.

@endnode



@node ZoneBank "Zone Banks / What Is A Zone Bank?"
@toc ZoneContents
                            @{u}@{b}What Is A Zone Bank@{ub}@{uu}

A zone bank is an AMOS bank, which contains one or more sets of AMOS zone
descriptions, created by the @{"Zone Editor" link /Accessories/Zone_Editor.guide}  program. Zone banks have the same
structure as multi zones - the bank is split into groups, and each group
contains any number of zones, However unlike multi zones, a zone bank has
all groups defined in numerical increasing order, e.g. With multi zones you
can just define groups 1 & 10, but with a zone bank groups 2 - 9 must also be
defined. The same applies to the zone numbers within each group of the bank.

Easylife allows you to use zones from a zone bank in 3 ways:

	@{"Install A Single Group As AMOS Zones " link C_ElzbAdd}
	@{"Install A Single Group As Multi Zones" link C_ElzbMultiAdd}
	@{"Install All Groups As Multi Zones    " link C_ElzbInstall}

@endnode



@node C_ElzbAdd "Zone Bank / Installing A Group As AMOS Screen Zones"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElZb Add @{i}SCREEN , BANK , GROUP @{ui}



@{b}Description@{ub}

    This command installs zones from a @{"Zone Bank" link C_ZoneBank}, created by the zone editor
    program. @{i}SCREEN @{ui}is the screen you wish to set the zones on. @{i}BANK @{ui}is the
    bank number containing the zones, and @{i}GROUP @{ui}is the set of zones within
    the bank you wish to install.



@{b}Notes@{ub}
     
  - Any previously reserved zones or multi zones are removed when this
    command is executed.
  
  - Once installed, all normal AMOS & Easylife zone operations can be
    performed on the zones as if they were created by set zone instructions



@{b}Errors@{ub}

    @{u}Bank does not exist@{uu}

    The bank number given is that of a non-existant bank.


    @{u}Not a Zone Bank@{uu}

    The bank number given is that of another type of bank. Zone banks are 
    identified by them having the name "Zones   "

              
    @{u}Illegal Function Call@{uu}

    The group number you have specified does not exist in the selected
    zone bank.


    @{u}Screen not opened@{uu}

    The screen number you have selected is not open.

@endnode



@node C_ElzbMultiAdd "Zone Bank / Installing A Zone Bank Group As Multi Zones"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElZb Multi Add @{i}BANK , GROUP @{ui}



@{b}Description@{ub}

    This command installs all zones from the chosen group as multi zones.
    Unlike the other install instructions, this does not erase the
    currently defined zones. This means that you will have to reserve
    enough multi zones to contain the group first. The only zones overwriten
    by the command are those with the same GROUP & ID numbers as those in
    the bank.



@{b}Errors@{ub}

    @{u}Bank does not exist@{uu}

    The bank number given is that of a non-existant bank.


    @{u}Not a Zone Bank@{uu}

    The bank number given is that of another type of bank. Zone banks are
    identified by them having the name "Zones   "

              
    @{u}Illegal Function Call@{uu}

    The group number you have specified does not exist in the selected zone
    bank.


    @{u}Screen not opened@{uu}

    The screen number you have selected is not open.


    @{u}Multi Zones Not Reserved@{uu}

    You must have already reserved some multi zones to contain the zone
    bank group.

   
    @{u}Zone Table Full@{uu}

    There is not enough room in the space reserved for multi zones remaining
    to hold the entire group.

@endnode



@node C_ElzbInstall "Zone Bank / Installing an entire zone bank as Multi Zones"
@toc ZoneContents

@{b}Command Syntax@{ub}

	ElZb Multi Add @{i}BANK @{ui}



@{b}Description@{ub}

    This command installs all zones in all groups the @{i}BANK @{ui}as multi zones.



@{b}Notes@{ub}

  - This command erases any previously defined (multi) zones and reserves
    the exact number of multi zones required to hold the entire zone bank.
  
  - The zones are installed on the current screen.



@{b}Errors@{ub}

    @{u}Bank does not exist@{uu}

    The bank number given is that of a non-existant bank.


    @{u}Not a Zone Bank@{uu}

    The bank number given is that of another type of bank. Zone banks are 
    identified by them having the name "Zones   "

              
    @{u}Screen not opened@{uu}

    The screen number you have selected is not open.
@endnode




||
@node StringContents "String Functions - Contents"
@toc main
                         @{u}@{b}String support functions@{ub}@{uu}

@{u}Section 1: Character Search Functions@{uu}

	@{"Character Searching       " link SearchIntro}
	@{"Forwards Searches         " link C_ElfAsc}
	@{"Backward Searches         " link C_ElfLastAsc}
	@{"Control Character Searches" link C_ElfControl}
	@{"Nth Occurance Searches    " link C_ElfNthAsc}
	@{"Character Counting        " link C_ElfNumasc}


@{u}Section 2: Bank Name Strings@{uu}

	@{"Reading A Bank Name       " link C_ElBankName}
	@{"Changing A Bank Name      " link C_ElsBankName}

@{u}Section 3: String Storage@{uu}

	@{"Strings & Integers        " link C_Ellong}
	@{"Reading Memory As A String" link C_ElmemRead}
	@{"Writing Strings To Memory " link C_ElmemWrite}
	@{"Padded Strings            " link C_ElpadAsc}

@{u}Section 4: Message Bank Support@{uu}

	@{"Strings From Message Banks" link C_Elmessage}
	@{"Check if Messages Exist" link C_ElmessageExists}


@endnode



@node SearchIntro "Character Search Functions"
@toc StringContents

                        @{u}@{b}Character Search Functions@{ub}@{uu}

If you want to find the first occurance of a character in a string, you can
use the AMOS functinon =instr$, but as this is designed to find substrings,
it is in-efficient for single characters. 

However more sigificantly, to find the last occurance of a character, or the
first occurance of any of a set of characters in a string requies a loop in 
AMOS which is *very* inefficient. To overcome this, Easy Life provides a
variety of string searching commands, most of which accept either AscII 
values to search for a single character, or a second string to search for
any of the characters that occur in the string. There are also commands to
search for any character but those list, and to search backwards.

All EasyLife 'Find' character commands begin with the prefix 'Elf'.
@endnode



@node C_ElfAsc "String Searches / Forwards Searhing"
@toc StringContents

@{b}Command Syntax@{ub}

	=Elf Asc( @{i}S$ , A @{ui})
	=Elf Char( @{i}S$ , A$ @{ui})
	=Elf Asc( @{i}S$ , A , P @{ui})
	=Elf Char(@{i}S$ , A$ , P @{ui})

	=Elf Not Asc( @{i}S$ , A @{ui})       
	=Elf Not Char( @{i}S$ , A$ @{ui})
	=Elf Not Asc( @{i}S$ , A , P @{ui})
	=Elf Not Char( @{i}S$ , A$ , P @{ui})



@{b}Description@{ub}

   The Asc & Char varients of each form of the find function are identical,
   except the second argument (The character to find) is given as either
   an AscII value between 0 and 255, or a second string of characters. When
   a string is given, the search is for any of the characters in the string.
   These commands will not search for substrings.


   The first form, =Elf Asc(@{i}S$,A@{ui}) returns the first occurance of the
   character in the string @{i}S$@{ui}. The second form, =Elf Asc(@{i}S$,A,P@{ui}) begins
   searching a position @{i}P@{ui}+1. Any occurance in position @{i}P@{ui}, or before are
   ignored.

   The "Elf Not" forms are equivilent to the simple forms with the same
   arguments, except they return the position of the first character found
   that is not the character specifed in @{i}A@{ui}, or the first character that does
   not occur in the string @{i}A$@{ui}.


@{b}Notes@{ub}

  - If no character is found, these functions return all return 0.
  
  - When you specify the argument @{i}P@{ui}, the search begins at position @{i}P@{ui}+1. 
    The AMOS =instr$ function would begin at position @{i}P@{ui}. The reason for
    what at first seems strange behaviour is that the most frequent use
    of these commands is to parse a string which contains seperator
    characters e.g. spaces. With my method, to find the next occurance, you
    simply put the position of the last occurance as the @{i}P @{ui}parameter of the
    next search.

  - Any value of @{i}P @{ui}is accepted, but is taken to be unsigned,
    so negative numbers are treated as very high positive
    numbers. If @{i}P @{ui}is greater than the length of the string,
    0 is returned.


  
@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    Either @{i}A$ @{ui}is an empty string, or @{i}A @{ui}is not between 0 and 255.
@endnode



@node C_ElfLastAsc "String Searches / Backwards Searching"
@toc StringContents

@{b}Command Syntax@{ub}

	=Elf Last Asc( @{i}S$ , A @{ui})            
	=Elf Last Char( @{i}S$ , A$ @{ui})
	=Elf Last Asc( @{i}S$ , A , P @{ui})          
	=Elf Last Char( @{i}S$ , A$ , P @{ui})

	=Elf Last Not Asc( @{i}S$ , A @{ui})
	=Elf Last Not Char( @{i}S$ , A$ @{ui})
	=Elf Last Not Asc( @{i}S$ , A , P @{ui})
	=Elf Last Not Char( @{i}S$ , A$ , P @{ui})



@{b}Description@{ub}

    Each of these commands coresponds to a @{"Forward Searching" link C_ElfAsc} command, but 
    begins the search from the end of the string @{i}S$@{ui}, and works backwards. 
    The Asc varients take the AscII value of the character to search for, 
    whereas the Char varients take a second string containing the set of
    characters to search for.

    = Elf Last searches from the end of the string for the chosen character,
      returning the first position from which it occurs. If the optional
      parameter @{i}P @{ui}is specified, the search begins at position @{i}P@{ui}-1.

    = Elf Last Not searches from the end of the string for any character 
      other than the chosen character, and is very useful for removing the 
      padding from padded strings, or for removing trailing spaces.



@{b}Notes@{ub}

  - If no character is found, these functions return 0.
  
  - When you specify the argument @{i}P@{ui}, the search begins at position @{i}P@{ui}-1.
    This is so the second occurance can be found by returning the position 
    of the first as the argument @{i}P@{ui}.

  - Any value of @{i}P @{ui}is accepted, but is taken to be unsigned, so negative 
    numbers are treated as very high positive numbers. If @{i}P @{ui}is greater than
    the length of the string, the search begins at the end of the string.


  
@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    Either @{i}A$ @{ui}is an empty string, or @{i}A @{ui}is not between 0 and 255.

@endnode



@node C_ElfControl "String Searches / Finding Control Characters"
@toc StringContents

@{b}Command Syntax@{ub}

	= Elf Control( @{i}S$ @{ui})
	= Elf Control( @{i}S$ , P @{ui})



@{b}Description@{ub}

    These special versions of the forward search commands find the first
    occurance of a character with AscII below 32 in the string S$ (Starting 
    at position P+1 if P is supplied). The position of the first control
    character is returned, or 0 if the string contains no control characters.

    E.g. This can be used to determine if a string is printable. A string
    which contains control characters may invoke any of the AMOS text
    formatting functions in chapter 8 of the AMOS Creator manual such as 
    At(X,Y), Pen$(C), Cdown$, etc. (Chapter 5.06 of the AMOS Pro manual)

	If Not Elf Control(A$) 
	   Print A$ 
	Else 
	   Print "String Is Unprintable"
	End If

@endnode



@node C_ElfNthAsc "String Searches / Finding the Nth Occurance"

@{b}Command Syntax@{ub}

	= Elf Nth Char( @{i}S$ , A$ , N @{ui})
	= Elf Nth Asc( @{i}S$ , A , N @{ui})



@{b}Description@{ub}

    This varient of the find function finds the Nth occurance a character
    in a string. @{i}S$ @{ui}is the string to search, and @{i}N @{ui}is the occurance number
    you wish to find. The character to search for is the character with
    AscII value @{i}A @{ui}in the Elf Nth Asc function, or the any characters in the
    string @{i}A$ @{ui}in the Elf Nth Char functino.

    The position of the Nth occurance of the character is returned, or 0 if
    the character(s) does/do not occur @{i}N @{ui}times in the string.


@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    Either @{i}A$ @{ui}is an empty string, or @{i}A @{ui}is not between 0 and 255.

@endnode



@node C_ElfNumAsc "String Searches / Character Counting"
@toc StringContents

@{b}Command Syntax@{ub}

	= Elf Num Char( @{i}S$ , A$ @{ui})
	= Elf Num Asc( @{i}S$ , A @{ui})



@{b}Description@{ub}

    These functions return the number of times the specified character(s) are 
    found in the string S$. In the Asc varient, A is the AscII code of the
    character to be counted. In the Char varient, occurances of any character
    from A$ are counted. 



@{b}Notes@{ub}

  - If the string A$ contains more than one occurance of the same character
    it is still only counted once.

       
@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    Either @{i}A @{ui}is not between 0 and 255, or @{i}A$ @{ui} is an empty string.
@endnode



@node C_ElBankName "Strings / Read a banks name"
@toc StringContents

@{b}Command Syntax@{ub}

	= ElBank Name$( @{i}BANK @{ui})



@{b}Description@{ub}

    This function call returns the name of the given @{i}BANK@{ui}. This is the 8
    character string displayed when you use the AMOS listbank command.

    The string returned is always 8 characters long, and is padded with trailing
    spaces, which may be removed with:

	NAME$ = ElBank Name$(BANK)
	NAME$ = Left$(NAME$,Elf Last Not Asc(NAME$,32))



@{b}Errors@{ub}

    @{u}Bank Not Reserved@{uu}

    The obvious - you can't get the name of a non-existant bank.

@endnode



@node C_ElsBankName "Strings / Setting A Banks Name String"
@toc StringContents

@{b}Command Syntax@{ub}

	Els Bank Name BANK , NAME$



@{b}Description@{ub}

    This command changes the name of the @{i}BANK @{ui}which is returned by the
    @{"ElBank Name$" link C_ElBankName} function and the ListBank command to @{i}NAME$ @{ui}



@{b}Notes@{ub}
  
  - NAME$ must be exactly 8 characters long, so shorter strings should be
    padded with spaces E.g.

	Els Bank Name BANK,ElPad Asc(NAME$,32,8)
  
  - Some AMOS commands / programs use the bank name to detect the bank type,
    so you should be careful when changing the name of bank types other than
    Work or Data. Easylife itself uses the bank name to detect Message Banks
    and @{"Zone Banks" link ZoneBank}
  

  
@{b}Errors@{ub}

    @{u}Bank Not Reserved@{uu}

    The bank specified does not exist.


    @{u}Illegal Function Call@{uu}

    Either the bank number specified was not a legal bank number (e.g. it
    was negative), or @{i}NAME$ @{ui}was not exactly 8 characters long.

@endnode




@node C_Ellong "Strings / String <--> Integer Conversion"
@toc StringContents

@{b}Command Syntax@{ub}

	= ElLong$( @{i}NUM @{ui})
	= ElLong( @{i}NUM$ @{ui})

	= ElWord$( @{i}NUM @{ui})
	= ElWord( @{i}NUM$ @{ui})



@{b}Description@{ub}

    ElLong$ converts the integer into a 4 byte string holding that integer,
    so that it may be output to a file compactly with a fixed length, or so
    that a list of integers may be built within a string easily.

    ElLong converts the first 4 bytes of a string back into an AMOS integer.


    ElWord$ and ElWord do the same thing, except only two bytes are used. 
    This means that the integer must be between -32768 and 32767.



@{b}Notes@{ub}

  - The integer is stored in the string as it is stored in  memory - most
    sigificant byte first.

  - ElWord$ does not give error messages if the value is out of range, it
    simply stores the lower 2 bytes. Therefore you can use word$ to store
    unsigned words (0-65535), but you must then read them bank with:

    NUM = Asc(NUM$)*256+Asc(Mid$(NUM$,2))
    
    As Elword will return negative numbers for 32768-65535.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    The @{i}NUM$@{ui} string must be at least 2 bytes long in ElWord$, and at least
    4 bytes in length in ElLong$.
@endnode



@node C_ElmemRead "Strings / Reading Memory As A String"
@toc StringContents

@{b}Command Syntax@{ub}

	=ElMem$( @{i}ADDR , SLENGTH @{ui})
	=ElMem$( @{i}ADDR , SLENGTH , DELIMITER @{ui})



@{b}Description@{ub}

    The first format copies then next @{i}SLENGTH@{ui} bytes from address @{i}ADDR@{ui} into 
    an AMOS string, and returns that string. The second version attempts to
    do the same thing, but stops when it finds the first occurance of a
    character with AscII code @{i}DELIMETER@{ui}.

    AMOS already has peek,deek & leek - thing of this as 'Seek' (!)



@{b}Notes@{ub}
  
  - A COPY of the memory area is returned. It may be modified like any other
    string, without affecting the memory area, and conversly any changes to
    the memory made since it was read are not reflected in the string.
  
  - If the memory reading is terminated by reading a @{i}DELIMETER@{ui} character,
    that character is not returned as the last character of the string -
    only those characters up to the @{i}DELIMETER@{ui} are returned. 0 is a useful
    delimeter for reading strings from Amiga OS functions, which are null-
    terminated.

  

@{b}Errors@{ub}

    @{u}Variable Buffer Full / Out Of Memory @{uu}

    These may occur at any time, but this command is  particularly
    susceptable if the string is very large, or the delimeter does not
    occur where you expect it to.


    @{u}Illegal Function Call@{uu}

    @{i}SLENGTH@{ui} must be between 1 and 65535 inclusive, and @{i}DELIMETER@{ui} between 0
     and 255.
@endnode



@node C_ElmemWrite "Strings / Writing A String To Memory"
@toc StringContents

@{b}Command Syntax@{ub}

	Elmem @{i}ADDR , S$ @{ui}
	= Elmem inc( @{i}ADDR , S$ @{ui})



@{b}Description@{ub}

    This command copies the string @{i}S$@{ui} into memory begining at address @{i}ADDR@{ui}.
    Only the actual characters in the string are copied - the length does not
    preceed it as with AMOS strings within the variable buffer, and it is not
    automatically null terminated like C strings. 

    The second format returns ADDR+Len(S$) as a result, allowing many strings
    to be copied into consecutive memory addresses easily using:

	ADDR = Elmem Inc(ADDR,S1$)
	ADDR = Elmem Inc(ADDR,S2$)
	Elmem ADDR,S3$



@{b}Notes@{ub}

  - If @{i}S$@{ui} is an empty string, this command has effect.



@{b}Errors@{ub}

    If you write to just any memory address, *anything* can happen - make
    sure you know what is at the address you write to.

@endnode




@node C_ElpadAsc "Strings / Padded Strings"
@toc StringContents

@{b}Command Syntax@{ub}

	= ElPad Asc(S$,A,L)
	= ElPad Char(S$,A$,L)



@{b}Description@{ub}

    If the length of the string @{i}S$@{ui} is greater than or equal to @{i}L@{ui}, these two
    functions return @{i}S$@{ui}. Otherwise they return a string which is @{i}S$@{ui} followed
    by enough repetitons of the character @{i}A/A$@{ui} to make it's length L. The
    first varient takes the AscII code of the "pad character" in the @{i}A@{ui}
    argument. The second varient uses the first character of @{i}A$@{ui}.


@{b}Notes@{ub}

  - If A$ contains more than one character, the second and subsequent
    characters are ignored. In the future I intend to change this to
    repeatedly use the whole of A$ to pad S$.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    @{i}A@{ui} must be between 0 and 255, and @{i}A$@{ui} must not be and empty string.

@endnode



@node C_Elmessage "Strings / Message Banks"
@toc StringContents

@{b}Command Syntax@{ub}

	= ElMessage$( BANK , GROUP , NUMBER )
	= ElMessage$( ADDR , GROUP , NUMBER )



@{b}Description@{ub}

    Easy Life makes life much easier when using the Message Bank Compiler
    PratchED extension program. This command reads a message from a bank
    into a string.

    @{i}BANK@{ui} is the bank number to read the message from, @{i}GROUP@{ui} and @{i}NUMBER@{ui} give
    the identifier of the message your wish to read. Alternatively, you may
    give the absolute address of the message bank in memory in the @{i}ADDR@{ui}
    parameter.

    For more information, read the message bank compiler documentation.
    (Which one day, I might even release!)


    Example:

    To read a message 1,2 from a crunched message bank that has been loaded
    into powerpacker buffer 0, use the call:

	M$ = ElMessage$(ElPp Buf(0)+20,1,2)

    The +20 is because all AMOS banks have a header of 20 bytes.



@{b}Notes@{ub}

  - The method defined in the above example is not the only way to read
    crunched message banks - you can use {"Elxpk Load" link C_Elxpkload}

  - A COPY of the message is returned in the string, and modifying it will
     not affect the stored message.

  - The use of message banks in AMOS professional is limited in AMOSPRO,
    as the text string part of resource banks do pretty much the same thing,
    except message banks will be AMOS Creator compatible.



@{b}Errors@{ub}

    @{u}Bank Not Reserved@{uu}

    The first parameter is a valid bank number, but that bank does not
    exist. If the first parameter is not a legal bank number, it is taken
    to be the absolute address of the message bank.


    @{u}Not A Message Bank@{uu}

    The chosen bank exists, but is not a message bank, or there is not
    message bank at the specified address. Message banks are recognised by
    thier name, so you must not rename them with the @{"Els Bank Name" link C_ElsBankName} command.


    @{u}Illegal Function Call@{uu}

    Either the GROUP or message NUMBER is illegal for this particular bank.
    The error can be avoided using the @{"Message Exists" link C_ElmessageExists} function
    first.

@endnode



@node C_ElmessageExists "Strings / Testing if a message exists"
@toc StringContents

@{b}Command Syntax@{ub}

	= ElMessage Exists( @{i}BANK , NAME , START @{ui})
	= ElMessage Exists( @{i}ADDR , NAME , START @{ui})


@{b}Description@{ub}

    This command is used to return whether a given message has been defined
    within a message bank, or not as a boolean. The arguments, and error 
    conditions are the same as for the @{"ElMessage$" link C_Elmessage} function, but you
    will never get an illegal function call as the purpose of this function 
    is to determine whether the message exists.
@endnode




@node BitContents "Bitwise Commands - Contents"
@toc main
                             @{u}@{b}Bitwise Commands@{ub}@{uu}


	@{"Bit Testing   " link C_ElWtst}
	@{"Bit Modifying " link C_ElWset}
	@{"Sign Extension" link C_Elextw}
@endnode



@node C_ElWtst "Bits / Bit Testing"
@toc BitContents

@{b}Command Syntax@{ub}

	=ElWtst( @{i}BIT , ADDR @{ui})
	=ElLtst( @{i}BIT , ADDR @{ui})



@{b}Description@{ub}

    The AMOS =Btst function allows you to detect if a bit is set in a given
    byte of memory, or in an integer variable. EasyLife provides these two
    functions to test if a bit is set in words/longwords of memory.

    @{i}BIT @{ui}is the bitnumber to test. Bits are numbered from the right, 15
    being the highest bit of a word, and 31 the highest bit of a longword.

    @{i}ADDR@{ui} is the address of the word/longword to test. 

    True is returned if the bit is set in the given word/longword.



@{b}Notes@{ub}

 - The second argument @{i}ADDR @{ui}is always taken as an address, even if it is a
   simple variable, and not a complex expression. To test the bits of a 
   variable use the AMOS =btst function - this allows you to test all 31
   bits of integer variables.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    BIT must be in the range 0-15 for words, and 0-31 for longwords. @{i}ADDR @{ui}
    must be a valid even address.
@endnode



@node C_ElWset "Bits / Bit Modifying"
@toc BitContents

@{b}Command Syntax@{ub}

	ElWset @{i}BIT , ADDR @{ui}
	ElLset @{i}BIT , ADDR @{ui}

	ElWclr @{i}BIT , ADDR @{ui}
	ElLclr @{i}BIT , ADDR @{ui}

	ElWchg @{i}BIT , ADDR @{ui}
	ElLchg @{i}BIT , ADDR @{ui}



@{b}Description@{ub}

    These commands are equivilent to AMOS Bset,Bclr and Bchg instructions,
    but they allow you to modify the bits of words & longwords of memory.

    ElWset sets bit @{i}BIT @{ui}of the word at address @{i}ADDR@{ui}.
    ElWclr clears bit @{i}BIT @{ui}of the word at address @{i}ADDR@{ui}.
    ElWchg inverts bit @{i}BIT @{ui}of the word at address @{i}ADDR@{ui}.

    The ElL... commands perform the same functions on longwords.



@{b}Errors @{ub}

    @{u}Illegal Function Call@{uu}

    @{i}BIT @{ui}must be in the range 0-15 for words, and 0-31 for longwords. @{i}ADDR @{ui}
    must be a valid even address.
@endnode



@node C_Elextw "Bits / Sign Extension"
@toc BitContents

@{b}Command Syntax@{ub}


	= ElExtb( @{i}NUM @{ui})
	= ElExtw( @{i}NUM @{ui})



@{b}Descrition@{ub}

    These functions will sign extend numbers from bytes/words to long words.
    To see what this means, imagine AMOS integers as 32 bit binary numbers
    e.g. 42 is:


        00000000 00000000 00000000 00101010
                                   *

    Sign extending from a byte (ElExtb) looks at bit 7 (*) and copies it's
    value into all the bits to it's left. This has no effect on the number
    42, but 139 is changed:

        00000000 00000000 00000000 10001011
                                   *
    returns:

        11111111 11111111 11111111 10001011


    AMOS will interpret the new bit pattern as -117,because 10001011 is the bit
    pattern for -117 in signed 8 bit arithmatic, but for 139, in unsigned 8 bit
    arithmatic.

    ElExtw copies bit 15 into all the places to it's left. Extb & Extw can be used
    to translate signed bytes & words into AMOS integers.



@{b}Notes@{ub}

  - The state of bits 32-16 (Elextw) / 32-8 (Elextb) is ignored by the sign 
    extension. Only bits 15/7 count.

  - Both commands sign extend to a longword unlike the 68000 sign extension
    instructions on which they are based.
@endnode













@node FontContents "Fonts / Contents"
@toc main

                             @{b}@{u}New Font Commands@{ub}@{uu}


    The original font handling of AMOS was, to put it mildly abyssmal.
    Easylife provides you with a system to locate the font you want
    quickly & easily, and you won't have to worry about it being flushed
    out of memory because AMOS thinks your not using it anymore.

        @{"=Elopen Font    " link C_ElopenFont}
        @{" Elset Font     " link C_ElsetFont}
        @{" Elclose Font   " link C_ElcloseFont}
        @{" Elclose Fonts  " link C_ElcloseFont}

        @{"=Ellock Font    " link C_EllockFont}
        @{" Elunlock Fonts " link C_EllockFont}
@endnode

@node C_ElopenFont "Fonts / Opening A Font"

@{b}Command Syntax@{ub}

        =Elopen Font ( @{i}NAME$ , SIZE @{ui})



@{b}Description@{ub}

    When you want to use a new font, call Elopen Font giving the name
    of the font (Including a ".font" at the end), and the point size
    of the font, and you will be returned a font ID number to use
    with Elset Font.

    If the font you request is not in memory, it will be loaded from
    disk.



@{b}Notes@{ub}

  - The value returned is a pointer, not a consecutive integer like
    AMOS font numbers.

  - You do not need to use any of the AMOS 'Get Fonts' commands -
    Elopen Font is a replacement for these.

  - If you open the same font twice, you are returned the original
    pointer the second time, and the font is only actually opened
    once. Therefore you should only close it once.

  - You can access the AmigaOS 'TextFont' structure of the opened
    font with:

        F=Open Font("topaz.font",8)
        TF=Leek(F+4)

    TF is now the address of the TextFont structure for topaz 8.


@{b}Errors@{ub}

    @{u}Can't open diskfont.library@{uu}

    Either diskfont.library is not in LIBS:, or there is not enough
    memory to load it.


    @{u}Unable to lock font@{uu}

    The font you have specified cannot be found.
@endnode



@node C_ElsetFont "Fonts / Using Fonts"

@{b}Command Syntax@{ub}

    Elset Font @{i}FONTID@{ui}



@{b}Description@{ub}

    This command behaves the same as the AMOS 'Set Font' command, except
    it take a FONTID returned from Elopen Font as a parameter instead
    of an AMOS font number. See the AMOSPro manual on Set Font for more
    information.



@{b}Notes@{ub}

  - You do not need to use any of the 'Get Fonts' commands before
    using Elset Font.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    The parameter you supplied is not a FONTID returned from Elopen Font
    (Or it has been closed again).
@endnode



@node C_ElCloseFont "Fonts / Closing A Font"

@{b}Command Syntax@{ub}

        Elclose Font @{i}FONTID@{ui}
        Elclose Fonts



@{b}Description@{ub}

    Elclose Font is called to tell the OS that you are finished using a
    font you have previously opened, and that it is free to deallocate
    the memory assigned to that font if no other task is using it. The
    parameter must be a font returned by Elopen Font.

    Elclose Fonts closes all fonts that are currently open. This command
    is automatically called by the easylife default routine.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    The parameter you have passed to Elclose Font is not an open FONTID.

    
@endnode




@node C_EllockFont "Fonts / Old Commands"

@{b}Command Syntax@{ub}

        =Ellock Font( @{i}NAME$ , SIZE @{ui})
        Elunlock Fonts



@{b}Description@{ub}

    These 2 commands have been removed from easylife, as they were
    unreliable with KS2.0+, and have been superceeded by the new
    Open/Close/Set font commands.
@endnode







@node PackContents "XPK / Powerpacker Compression - Contents"
@toc main

                       @{u}@{b}Powerpacker & XPK Compression@{ub}@{uu}


@{u}Section 1: Powerpacker@{uu}

	@{"What Is Powerpacker?    " link WhatIsPp}
	@{"Loading The Library     " link C_ElppKeep}
	@{"Loading Crunched Data   " link C_ElppLoad}
	@{"Accessing Buffers       " link C_ElppBuf}
	@{"Removing Buffers        " link C_ElppFree}
	@{"Manual Buffer Allocation" link C_ElppAllocate}
	@{"Saving Crunched Data    " link C_ElppCrunch}
	@{"Loading via XPK         " link C_ElxpkBload}

@{u}Section 2: XPK@{uu}

	@{"What Is XPK?          " link WhatIsXPK}
	@{"Loading Crunched Banks" link C_ElxpkLoad}
	@{"Loading Crunched Data " link C_ElxpkBload}
	@{"Saving Crunched Banks " link C_ElxpkSave}
	@{"Saving Crunched Data  " link C_ElxpkBSave}
	@{"Length of an XPK file " link C_ElxpkLof}
	@{"Listing Packers       " link C_ElxpkList}
	@{"Handling XPK Errors   " link C_ElxpkError}
@endnode



@node WhatIsPp "Compression / What Is Powerpacker?"
@toc PackContents

                           @{u}@{b}What Is Powerpacker ?@{ub}@{uu}

Powerpacker is a popular Program and Data cruncher for the amiga, written by
nico francois (Also author of reqtools). Early versions were public domain,
but more recent & much faster, not to mention more efficient versions are 
commerical programs. 

Easylife not only allows you to load data crunched with powerpacker into your
AMOS programs, but also lets you save data crunched with the powerpacker 
algorithmn using the speed & high compression ration of the latest commerical
version. (I.E. It calls powerpacker.library :-)


You Can:
  
  - Read files crunched in data mode by powerpacker or any
    compatable program.
  
  - Load the files crunched by Easylife into powerpacker, ppmore etc.
  
  - Crunch any block of memory and save it to a file.
  
  
However, you cannot:

  - Read or Write crunched executable files / segments. Easylife only loads
    & crunches as data.

  - Use Powerpackers encrypted mode for reading or crunching. This is 
    because it pops the password window up on an intuition screen.


You can also load powerpacked data directly to an AMOS bank using the
@{"Elxpk Bload" link C_ElxpkBload} function.
@endnode



@node C_ElppKeep "Compression /  Loading The Powerpacker Library"
@toc PackContents
@{b}Command Syntax@{ub}

	ElPp Keep On
	ElPp Keep Off


@{b}Description@{ub}

    To use the commands @{"ElPp Load" link C_ElppLoad} & @{"ElPp Crunch" link C_ElppCrunch}, the powerpacker library
    version 35 or greater is needed, therefore the file powerpacker.library 
    (supplied) must be in LIBS:

    The library is loaded into memory when you first use either of these 
    commands, but may sometimes be removed again by the exec memory manger
    afterwards. To make sure the library stays in memory these two commands
    are provided.

    Using Pp Keep On makes Easylife load the powerpacker library if it is
    not already in memory, and prevents being removed from memory until you 
    use Pp Keep Off.

    Pp Keep Off does not always removed the library from memory - other
    processes may also be using it, but it informs the memory manager that
    EasyLife has no objection to it being removed.


@{b}Notes@{ub}

  - Pp Keep Off is automatically called when you use the AMOS
    @{"Default" link CommandEffects} command.


@{b}Errors@{ub}

    @{u}Unable To Load PowerPacker Library V35+@{uu}

    Either the file powerpacker.library is not in LIBS:, the device
    LIBS: could not be accessed, or the version of the library in LIBS: is
    not high enough.

    A suitable version of the library is supplied with EasyLife.
@endnode



@node C_ElppLoad "Loading Powerpacked Data"
@toc PackContents

@{b}Command Syntax@{ub}

        ElPp Load @{i}BUF , FILE$ , DECRUNCH @{ui}



@{b}Description@{ub}

    This command will load a file into memory, then decrunch it, if it was 
    compacted with powerpacker. @{i}BUF @{ui}is a number from 0-7 used to choose 
    which of the 8 buffers to load the file into.

    @{i}FILE$ @{ui}is the name of the file to load. It is important that the full
    path be given, and that the file exists. E.g.

        If F$<>""
            If Exist(F$)
                Pp Load 0,F$,2
            Else
                Print "File Not Found"
            End If
        End If


    @{i}DECRUNCH @{ui}must be an integer between 0 and 4, and determines what happens
    while the file is decrunched. I recommend that option 3 is not used with
    AMOS screens, but it does not generate an error message, as your program
    may run on an intuition screen, if you have the intuition extension.

    0 : Flash colour 0 
    1 : Flash colour 1 
    2 : Flash colour 17 (Mouse Pointer - Recomended)
    3 : Wobble Screen (No effect on AMOS screens)
    4 : Do nothing while decrunching



@{b}Notes@{ub}

  - If the chosen buffer already contained data, it is freed first.

  - Pp Load will load uncrunched data without any problems, so you don't
    have to worry about whether the file you are loading is crunched or
    not. The only problem is if it was not crunched with powerpacker.

  - AMAL & Bobupdates etc. are temporarily suspended while decrunching
    takes place.


@{b}Errors@{ub}

    @{u}Can't Load Powerpacker Library V35+@{uu}
  
    The [4\2\Powerpacker Library] is required to be in LIBS: even if the
    file your are loading in not crunched.


    @{u}Illegal Powerpacker Header@{uu}

    Either the file is corrupt, was crunched with unrecognised version of
    powerpacker, or was not crunched as a "Data File".


    @{u}File Encrypted - Can't Decrunch@{uu}

    Easylife does not support decrunching encrypted files.


    @{u}Out of Memory while Loading / Decrunching File@{uu}

    Oh no! (As the lemming said to the warhead...)


    @{u}Unable To Open File@{uu}

    Powerpacker library could not open the filename you passed it. It
    probably means it doesn't exist, but it could be read protect bits,
    or another reason.


    @{u}Error Reading File@{uu}

    A Disk Error occured while reading in the crunched file.
@endnode



@node C_ElppBuf "Compression / Accessing PowerPacker Buffers"
@toc PackContents

@{b}Command Syntax@{ub}

	= ElPp Buf( @{i}NUM @{ui})
	= ElPp Len( @{i}NUM @{ui})



@{b}Description@{ub}

    An Easylife Powerpacker Buffer is similar to an AMOS bank of type "work".
    ElPp Buf returns the address of the start of the buffer. It is similar 
    to the start() function for banks. ElPp len returns the length of the
    buffer. It is similar to the length() function for banks. Vaild buffer
    numbers are 0 - 7.
  
    The main differences between buffers & 'work' banks are:
  
    - A Buffer can be created explicitly with the ElPp Allocate command,
      or implicitly by the ElPp load function. ElPpLoad cannot load directly
      to a bank. (However this can be done via the @{"Elxpk Load" link C_ElxpkLoad} function.
  
    - If you try to recreate an existing buffer, the old buffer is freed
      first. You do not get an error, as you would with AMOS banks.
    
    - In AMOS Creator, one set of powerpacker buffers is shared between all
      AMOS programs. If you have two programs loaded into AMOS, and one
      Prun's the other, the second will share the same buffers with the 
      first. Therefore powerpacker buffers can be used to hold shared data.

  

@{b}Notes  @{ub}

  - ElPp Buf & ElPp Len do not require the powerpacker library.

  - The buffer can be saved with either Bsave, or @{"ElPp Crunch" link C_ElppCrunch}, or
    @{"Elxpk Bsave" link C_ElxpkBsave}.

  - If the buffer is not allocated, both functions return 0.

  - You can also use @{"Elmem$" link C_ElmemRead} to transfer the buffer contents to the AMOS
    variable buffer. If the file is a text file, you can read it one line
    at a time with:

	ElPp Load 0,file$,2
	POS=0
	While POS<ElPp Len(0)
	   A$=ElMem$(ElPp Buf(0)+POS,Pp Len(0)-POS,10)
	   POS=POS+Len(A$)+1
	   '
	    'Now do whatever your going to do with the
	    'line in A$
	    '
	Wend
	ElPp Free 0

    This segment of code will read the buffer up to asc code 10 (Line Feed)
    into the string A$, and point POS to the next line. If no Line Feed is
    found, the remainder of the buffer is read into A$




@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    You must supply a valid buffer number (0-7).
@endnode



@node C_ElppFree "Compression / Disposing of Powerpacker Buffers"
@toc PackContents

@{b}Command Syntax@{ub}

	ElPp Free @{i}NUM @{ui}
	ElPp Free All



@{b}Description@{ub}

   The first form of this command removes buffer @{i}NUM @{ui}, returning the memory
   to the system. The second form removes all buffers.



@{b}Notes@{ub}

  - Freeing a buffer which is not allocated does not cause an error, it 
    does nothing.
  
  - ElPp Free All can also be @{"Implictly called" link CommandEffects}.

    

@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    You must give a valid buffer number (0 - 7)
@endnode





@node C_ElppCrunch "Compression / Saving Powerpacked Data"
@toc PackContents

@{b}Command Syntax@{ub}

	= ElPp Crunch( @{i}FILE$ , START , LENGTH , EFFICIENCY , BUFFER @{ui})


@{b}Description@{ub}

    Easy life allows you to save any block of memory, after crunching it with
    the powerpacker routine - it does not have to be a powerpacker buffer.

    ElPp Crunch will crunch a block of memory, save it to a file, and return
    the length of the crunched file.

    @{i}FILE$ @{ui}= The name to save the crunched file to. It must have a full path,
            and the directory must exist.

    @{i}START@{ui}, and @{i}LENGTH@{ui} define the block of memory to save. 

    @{i}EFFICIENCY@{ui}  is  an  integer  between  0  and  4  setting the crunch
                effeciency (0 = Fastest Speed, Poorest Compaction, 4 =
                Slowest Speed, Best Compaction).

    @{i}BUFFER@{ui} is the size of crunch speedup buffer to use. 0=Large, 1=Medium, 
           2=Small. If there is not enough memory for the buffer you choose,
           a smaller one will be used



@{b}Notes@{ub}

  - To save a powerpacker buffer, use the call:
  
    NL = ElPpCrunch(FILE$,ElPp Buf(NO),ElPp Len(NO),EFF,0)
  
  
  - To save the string S$, use:
  
    NL = ElPpCrunch(FILE$,Varptr(S$),Len(S$),EFF,0)
  
  - Don't confuse the speedup buffer of ElPp Crunch with the powerpacker
    buffers. The speedup buffer, is used to accelerate the crunching speed
    and is internal to the powerpacker.library. 

  - @{b}IMPORTANT@{ub}: The crunched data overwrites the uncrunched data before it
    is saved - If you need to keep the original, make a copy before 
    crunching.

  

@{b}Errors  @{ub}
  
  
    @{u}Illegal Function Call@{uu}
  
    @{i}LENGTH @{ui}must be a positive integer. 
    @{i}EFFICENCY @{ui}must be in the range 0-4.
    @{i}BUFFER @{ui}must be in the range 0-2.


    @{u}Crunched File Longer Than Source@{uu}

    If the crunched file becomes longer than the uncrunched file, an error
    occurs, as crunched data overwrites the original, and if it is longer,
    next bit of original data to crunch is corrupted. Therefore you should
    always place On Error commands around the section code using ElPp Crunch,
    so you have save the file uncrunched if crunching fails. (Or use the
    AMOSPro 'Trap' instruction).


    Various I/O errors can also occur when saving the file.
@endnode



@node C_ElppAllocate "Manual Buffer Allocation"
@toc PackContents

@{b}Command Syntax@{ub}

	ElPp Allocate @{i}NO, LENGTH @{ui}


@{b}Description@{ub}

   If you are using powerpacker buffers to load crunched files, you do not 
   need to allocate the buffer, as this is automatically done by the
   ElPp Load instruction. However, if you want to take advantage of the fact
   that all AMOS Creator programs share one set of buffers to pass data
   between them, or if you have simply run out of banks for AMOS 'work' 
   banks, you can use ElPp Allocate to manually reserve a buffer.

   @{i}NO @{ui}is the buffer number to allocate (0-7).

   @{i}LENGTH @{ui}is the number of bytes to allocate to the buffer.


@{b}Notes@{ub}

  - Powerpacker buffers will be allocated in fast memory if possible,
    otherwise chip memory will be used.

  - I can see no reason for using Elpp Allocate in AMOSPro, apart from
    not having to convert creator programs.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    @{i}NO @{ui}must be in the range 0 - 7. @{i}LENGTH@{ui} must be a positive
    integer.
@endnode




@node WhatIsXPK	"Compression / What Is XPK ?"
@toc PackContents

                               @{u}@{b}What Is XPK ?@{ub}@{uu}

XPK is an acronym for eXternal PacKing, and is a collection of libraries. All
outside programs interact with XPK via the xpkmaster.library, which provides
routines to crunch & decrunch data, the source of which may be a block of
memory, or a file, as may the destination. When calling the XPK library, you
specify a packing method in the form of a 4 character string e.g NUKE. This
is the name of the XPK compression library which contains the actual packing
algorithmn you wish to use. 

The different compressors vary in their speed of compression / decompression,
their compression ratio, and their suitablitity to certain types of file, but
all share a common interface and calling commands from Easylife.

I recomend the use of XPK over powerpacker, as it is more general purpose,
and has a better interface in easylife, plus the fact that the xpkmaster
library will load & decrunch powerpacked files anyway.

NOTE: The XPK libraries are not included in this distribution, you must
obtain the @{"XPK compression archive" link alsoneed} seperately.
@endnode



@node C_ElxpkLoad "Compession / Loading XPK crunched banks"
@toc PackContents

@{b}Command Syntax@{ub}

	Elxpk Load @{i}FILENAME$ @{ui}
	Elxpk Load @{i}FILENAME$ @{ui}To @{i}BNKNO @{ui}

	Elxpk Load @{i}FILENAME$ , PASSWORD$ @{ui}
	Elxpk Load @{i}FILENAME$ , PASSWORD$ @{ui}To @{i}BNKNO @{ui}



@{b}Desscription@{ub}
 
    The Elxpk Load command loads an AMOSPro bank that has been saved with
    the @{"Elxpk Save" link C_ElxpkSave} command. The bank may be packed with any XPK compressor,
    as long as the required compressor library is available. If no bank
    number is specified, the bank is loaded back to the number from which
    it was saved.



@{b}Notes@{ub}

  - You cannot load uncrunched or powerpacked banks with this method since
    they are normal .Abk files, as the .Abk format is different to the
    format in which Elxpk Save stores the bank file. However, if you
    save your banks with:

	 Bsave FILENAME$,Start(BNKNO-24) To Start(BNKNO)+Length(BNKNO)
    
    You can load them back with this command if they are uncrunched, or
    powerpacked. 

  - This command does not work for sprite / icon banks (Yet)



@{b}Errors@{ub}

    See the @{"Elxpk Error" link C_ElxpkError} function for details.
@endnode



@node C_ElxpkBload "Compression / Loading XPK Crunched Data"
@toc PackContents

@{b}Command Syntax@{ub}

	Elxpk Bload @{i}FILENAME$ @{ui}To @{i}ADDR @{ui}
	Elxpk Bload @{i}FILENAME$ , PASSWORD$ @{ui}To @{i}ADDR @{ui}



@{b}Description@{ub}

    These commands load XPK crunched data directly into memory at address
    @{i}ADDR. @{ui}You must have allocated enough memory for the uncompressed file,
    plus 256 bytes decompression space. Elxpk Bload will transparently
    load uncrunched data & @{"powerpacked" link WhatIsPp} data, but you must still allocate
    the 256 bytes.



@{b}Notes@{ub}

  - @{"Elxpk Lof" link C_ElxpkLof} can be used to find the uncompressed length.

  - If the address you are loading to is an AMOS work bank, you can
    use the AMOSPro bank shrink command to remove the extra 256 bytes
    after loading.

  - The value 256 is from the xpk.i file's XPK_MARGIN equate for version
    2.4 of the XPK master library. For newer versions, check this file to
    see if the margin is increased.



@{b}Errors@{ub}

   See the @{"Elxpk Error" link C_ElxpkError} function for details.
@endnode




@node C_ElxpkSave "Compession / Saving XPK Crunched Banks"
@toc PackContents

@{b}Command Syntax@{ub}

	Elxpk Save @{i}BNKNO @{ui}To @{i}FILENAME$ , METHOD$ @{ui}
	Elxpk Save @{i}BNKNO @{ui}To @{i}FILENAME$ , METHOD$ , PASSWORD$ @{ui}



@{b}Description@{ub}

    These commands will compress bank @{i}BNKNO, @{ui}and save the compressed data
    to @{i}FILENAME$. METHOD$ @{ui}is the 7 character string. The first 4 letters
    are then name of the compressor library to use. These are followed by 
    a '.' and a two digit decimal number to indicate the depth of compression
    - e.g. "HUFF.23" will use the dynamic huffman packing method, at 23%
    of its maximum efficiency. Some methods will ignore the efficiency
    setting as they only operate at one level. Others may have say 4 levels,
    in which caes the values 0 - 24 will the first level, 25-50 the second
    etc.

    If the packing method you select also encrypts the data, you must supply
    a password string for the encryption. See the XPK documentation for
    details of the various packing methods.



@{b}Notes@{ub}

  - You may not save sprite or icon banks with this command @{"Yet" link todo}

  - In general, the higher the efficiency value, the smaller the file, but
    the longer it takes to (de)crunch.

  - Crunched banks can only be reloaded with the @{"Elxpk Load" link C_Elxpkload}
    command.

  - Unlike @{"Elpp Crunch" link C_ElppCrunch}, Elxpk save does not destroy the original copy
    of the data that your are crunching & saving.


@{b}Errors@{ub}

    See the @{"Elxpk Error" link C_ElxpkError} function for details.
@endnode




@node C_ElxpkBsave "Compression / Saving XPK Crunched Raw Data"
@toc PackContents

@{b}Command Syntax@{ub}

	Elxpk Bsave @{i}START , LENGTH @{ui}To @{i}FILENAME$ , METHOD$ @{ui}
	Elxpk Bsave @{i}START , LENGTH @{ui}To @{i}FILENAME$ , METHOD$ , PASSWORD$@{ui}



@{b}Description@{ub}

    These commands save the block of memory from @{i}START, @{ui}for @{i}LENGTH @{ui}bytes to
    @{i}FILENAME$@{ui}. The byte at address @{i}START@{ui} is saved. The byte at address 
    @{i}END@{ui} is not, as with the normal AMOS Bsave command. @{i}METHOD$ @{ui}is the XPK
    packing method to use, using the same format for the string as the
    @{"Elxpk Save" link C_ElxpkSave} function. @{i}PASSWORD$@{ui} contains the encryption string for those
    packing methods which support encryption.



@{b}Notes@{ub}

  - Unlike @{"Elpp Crunch" link C_ElppCrunch}, Elxpk Bsave does not destroy the original copy
    of the data that your are crunching & saving.



@{b}Errors@{ub}

    See the @{"Elxpk Error" link C_ElxpkError} function for details.
@endnode



@node C_ElxpkLof "Compression / Finding the length of an XPK crunched file" 
@toc PackContents

@{b}Command Syntax@{ub}

	=Elxpk Lof( @{i}FILENAME$ @{ui})



@{b}Description@{ub}

    This function will return the length of the file @{i}FILENAME$@{ui}, just like
    the normal AMOS Lof function (Except it take the filename, not a channel
    number). However, if the file has been compresed with @{"XPK" link WhatIsXpk}, or
    @{"Powerpacker" link WhatIsPp} the length of the file once it has been uncompressed is returned.



@{b}Notes@{ub}

  - Elxpk Lof does not actually need to decrunch the file to find its 
    length, so this command is reasonably fast & uses little memory.



@{b}Errors@{ub}

    See the @{"Elxpk Error" link C_ElxpkError} function for details.
@endnode



@node C_ElxpkList "Compression / Listing XPK Packing methods"
@toc PackContents

In the @{ "Future" link todo} I intend to provide EasyLife functions for listing the types
of XPK compression method that are available, and some of their properties
to aid the building of packing method requesters. Until then, the only way
to list the methods is to use Dir First$ / Dir Next$ on the directory
'LIBS:Compressors/'.

@endnode



 
@node C_ElxpkError "Compression / Handling XPK Errors"
@toc PackContents

@{b}Command Syntax@{ub}

	=Elxpk Error




@{b}Description@{ub}

   When an error occurs with any of the XPK functions, one of 2 things will
   happen:

   - It it is an obvious error in one of the parameters (e.g. BNKNO=0 in
     Elxpk Save) an 'Illegal Function Call' error will occur.

   - It it is an error generated by the XPK library, the error message
     'An XPK Error Has Occured' is displayed.

   When this happens, you should call Elxpk Error to return the error number.
   The meanings of the various error numbers are listed below. Those marked
   with a '*' are most likely to occur from Easylife. If any marked with a
   '!' occur, please E-Mail @{"me" link /EasylifeIntro.Guide/Author} with the code that caused the error, as this
   probably means a bug in Easylife. This information is from the xpk.i file,
   by Christian Schneider * U. Dominik Mueller.

	 0	No error has occured. 
	-1!	This function not is implemented
	-2!	No files allowed for this function
	-3	Input error happened.
	-4	Output error happened.
	-5*	Check sum test failed - corrupt file
	-6*	Packed file's version newer than your libraries
	-7*	Out of memory
	-8!	For not-reentrant libraries
	-9	Was not packed with this library
	-10!	Output buffer too small
	-11!	Input buffer too large
	-12	This packing mode not supported
	-13*	Password needed for decoding this file
	-14*	Packed file is corrupt
	-15*	Required library is missing
	-16!	Caller's TagList was screwed up
	-17*	Would have caused data expansion
	-18	Can't find requested method
	-19!	Operation aborted by user
	-20	Input file is truncated
	-21	Better CPU required for this library
	-22	Data are already XPacked
	-23	Data not packed
	-24*	File already exists
	-25	Master library too old
	-26	Sub library too old
	-27*	Cannot encrypt
	-28!	Can't get info on that packer
	-29	This compression method is lossy
	-30	Compression hardware required
	-31	Compression hardware failed
	-32*	Password was wrong
@endnode



@node PatternContents "Patterm Matching Commands - Contents"
@toc main

                         @{b}@{u}Pattern Matching Commands@{uu}@{ub}


	@{"What Is A Pattern ?       " link WhatIsPattern}
	@{"Pattern Control Characters" link PatChars}
	@{"Simple Pattern Matching   " link C_ElpatCase}
	@{"Repeated Pattern Matching " link C_ElpatDef}
	@{"Testing for patterns      " link C_ElpatTest}
	@{"Escaping A String         " link C_ElpatEscape}


NOTE: The Easylife pattern matching commands require pattern.library to be
      in your LIBS: directory.
@endnode



@node WhatIsPattern "Patterns / What is a Pattern ?"
@toc PatternContents

                            @{b}@{u}What is a pattern ?@{uu}@{ub}

   A pattern is a string with some special characters which match to one
   or more characters in another target string. The most common use of
   patterns is in the Amiga Shell / CLI windows, when you use:

        Copy DF0:C/#? RAM:


   To copy every file in the DF0:c directory to RAM:. '#?' is a pattern
   which matches any filename string. 'a?b' is also a pattern which only
   matches 3 character strings in which the first characters is 'a' and the
   last is 'b'.

   Easylife uses the pattern.library to provide the pattern matching. This 
   is loaded from your LIBS: directory when you first use a pattern command 
   (Except ElPat free, which doesn't load the library if no pattern has been
   defined). This libarary is also used by the CSH command shell program,
   so users of this program should already be familar with the syntax of
   @{"Pattern Expressions" link PatChars}.
@endnode



@node PatChars "Patterns / Pattern Control Characters"
@toc PatternContents

@{b}Expressions@{ub}

An expression in a pattern is a single character, or any string of
characters in parenthesis (). Every expression will match itself, and
only itself in the target string it is matched with, unless it contains
control characters. Examples:
        
	"a" only matches the string "a"
	"fred" only matches the string "fred"
	"(hello) world" only matches the string "hello world"


@{b}Control Characters@{ub}
        

%   This character matches the empty string "". Although it seems of
    little use, it can be important when used  with the | character



?   This character matches any single character, as with AmigaDOS.
    Example:

	"b?b" matches the string "bab", but not "baab". 



#   Preceeding any expression with a # means it can be repeated 0 or more
    times. Example:

	The pattern "#(ab)" matches the strings "","ab",
	"abab","ababab" etc. This can be combined with the
	? to match anything as with AmigaDos - "#?".

    NOTE: If an unescaped # is the last character of a pattern, any commands 
          attempting to use the pattern will produce an Illegal Function
          Call error.



*   This is a shortcut for the pattern "#?", and means match anything
    E.g.

	 "a*" matches "a","and","aardvark" etc.

        

|  This is the 'or' character, and allows alternative patterns e.g. 

	"ab|cd" will match the strings "ab" and "cd", but nothing else.

    Usually you will have to suround the optional patterns with parenthesis
    to make them appear to be a single expression. The % character can be 
    used as an alternative to allow the empty pattern - Example:

	"(ab|cd|%)" matches the strings "","ab","cd" only.

    NOTE: If any of the alternative patterns is empty, any command using 
          the pattern will produce an illegal function call.

        

~   Negates the following expression.  Example:

	"~(ab*)" matches "","and","bass","can", etc. and anything else
        that doesn't begin with "ab".

    NOTE: "~ab*" is different to "~(ab*)", as "~ab*" 
	matches anything that doesn't begin with "a", but
	does have a "b" as the second character.

    NOTE: If an unescaped ~ is the last character of the pattern, any
          commands using the pattern will produce an illegal function call.



[]  A string of expressions enclosed in square brackets will match any one
    of the expressions in the target string. Example:

	"[abc]" matches "a", "b" and "c", but nothing else. 
	It is a shorthand for "(a|b|c)".

    Remember that expressions can be single characters (As Above) or 
    parethansised strings - Exmaple:

	"[(ab)c(de)]" matches "ab","c" and "de" only.

    You can also specify character ranges in square brackets, e.g "[0-9]*"
    will match any positive integer. This means if you want to match the "-"
    character, it must be either the first or last character in the brackets
    E.g. "[-0-9a-z ]*" means any lower case word, spaces, digits, and the 
    "-" character.

    Also, if the first character in the square brackets is a ~, all
    characters except those in the in the brackets are matched, E.g.
    "[~a-z]" will match all single characters that are not lower case 
    letters.

    NOTE: The string in square brackets is always treated as a single
          expression - you never need to put parenthesis around the square
          brackets.
        
        

'   This character "Escapes" the next character. This means that if the
    next character in another control character, that special meaning is
    ignored, so "a'*" will only match the string "a*". "'" can be used
    to escape itself E.g. "''" matches the string "'".
       
    NOTE: You can also use ' to escape parenthesis.
        

@{b}Important Note: @{ub}
    
    All parenthesis & square brackets must be paired (Unless they are 
    escaped), otherwise any command using the pattern will produce an
    illegal function call.
@endnode



@node C_ElPatCase "Patterns / Simple Pattern Matching"
@toc PatternContents

@{b}Command Syntax@{ub}

	= ElPat Case( @{i}P$ , S$ @{ui})
	= ElPat NoCase( @{i}P$ , S$ @{ui})



@{b}Description@{ub}

    These commands return True (-1) if the string @{i}S$ @{ui}matches the pattern
    @{i}P$@{ui}, or false (0) if it doesn't. The first form is case sensitive to
    alphabetic characters, the second isn't.



@{b}Errors@{ub}

    @{u}Illegal Funciton Call@{uu}

    There is an error in the @{"Pattern Definition" link PatChars}.
@endnode




@node C_ElpatDef "Patterns / Repeated Pattern Matches"
@toc PatternContents

@{b}Command Syntax@{ub}

	Elpat Set Case @{i}P$ @{ui}
	Elpat Set Nocase @{i}P$ @{ui}

	=El Pat Def( @{i}S$ @{ui})

	ElPat Free 



@{b}Description@{ub}

   The @{"Pat Case & El Pat Nocase" link C_ElpatCase} functions are not very efficient when you 
   have to repeatedly match many strings with the same pattern, as the 
   pattern has to be checked & converted to an internal format every time
   you test a string against the pattern. These commands split the pattern
   matching into 3 phases:

   ElPat Set Case & ElPat Set Nocase are used to select a pattern to match
   strings against. These commands check the validity of the pattern, and 
   compile it to the internal format.

   You can then test any string @{i}S$ @{ui}against the most recently defined pattern 
   with the =El Pat Def instruction, which will return true if the pattern
   matches, and false if it doesn't.

   To free the memory containing the compiled pattern when it is no longer 
   needed, call ElPat Free.


  
@{b}Notes@{ub}

  - You can call El Pat Set Case / El Pat Set Nocase again to change the 
    pattern to match against without calling ElPat Free first.
  
  - You can use the @{"Pat Case & ElPat Nocase" link C_ElpatCase} commands for simple pattern
    matching while a default pattern is defined, without overwriting the
    default pattern.

  - ElPat Free is also @{"Called Implicilty" link CommandEffects} by other
    AMOS commands.
  


@{b}Errors  @{ub}

    @{u}Illegal Function Call@{uu}

    ElPat Set Case & ElPat Set Nocase will produce this error if the 
    pattern is not @{"Correctly Defined" link PatChars}.


    @{u}No Default Pattern Defined@{uu}

    You have called = ElPat Def, without first defining a default pattern 
    with ElPat Case or ElPat Nocase. This also occurs if you try to use a 
    default pattern after freeing it.
@endnode




@node C_ElpatTest "Patterns / Testing for patterns"
@toc PatternContents

@{b}Command Syntax@{ub}

	= ElPat Test( @{i}S$ @{ui})



@{b}Description@{ub}

   This funciton returns True if the string S$ contains any special pattern
   matching control characters, or False if it doesn't. It can be used to 
   decide whether to compare that pattern with pattern matching, or with 
   the much faster AMOS string comparison.

@endnode




@node C_ElpatRemove "Patterns / Optimising Patterns"
@toc PatternContents

@{b}Command Syntax@{ub}
                
	= ElPat Remove( @{i}P$ @{ui})
        


@{b}Description@{ub}

    This funciton removes all unecessary pattern matching characters from
    the string @{i}P$@{ui}. A common test is:

	'
	'P$ is an arbitary pattern
	'        
	P$ = ElPat Remove(P$)
	If [6\5\ElPat Test](P$)
	   '
	   ' Code to operate on P$ as a pattern
	   '
	Else
	   '
	   ' Code to operate on P$ as a string
	   '
	End If
@endnode



@node C_ElpatEscape "Patterns / Escaping A String"
@toc PatternContents

@{b}Command Syntax@{ub}

	= ElPat Escape( @{i}S$ @{ui})



@{b}Description@{ub}

    This function escapes all the special pattern characters in @{i}S$@{ui}, by
    preceeding them with an '. It is usefull where a string input by the
    user is to become part of a pattern - by escaping that string first,
    you prevent it from changing the pattern behaviour - E.g.


	Input "Enter Sub-String to find :";S$
	ElPat Set Nocase "*"+ElPat Escape(S$)+"*"
	'
	For A = 1 To ARRAYSIZE
	   If ElPat Def(ARRAY$(A)) Then Print ARRAY$(A)
	Next A


    This code fragment finds all occurances of a sub-string in an array,
    without being case-sensitive. ElPatEscape is used to ensure that all
    user inputs are valid - without it, the substring "abc(de" would cause
    an illegal function call as "*abc(de*" is not a valid pattern because 
    it has an unescaped unpaired parenthesis, whereas "*abc'(de*" is 
    valid. 
@endnode



@node DosContents "AmigaDos / Intuiton Commands - Contents"

                       @{b}@{u}AmigaDos / Intuiton Commands@{uu}@{ub}

@{u}Section 1: AmigaDos Commands@{uu}

	@{"File Protection Bits" link C_Elprotect}
	@{"Console Output      " link C_Elstdout}
	@{"Console Input       " link C_Elstdin}
	@{"Executing Programs  " link C_Elexec}

@{u}Section 2: Intuition@{uu}

	@{"The Workbench Screen" link C_Elwb}
	@{"Iconifying AMOS     " link C_Eliconify}
@endnode



@node C_Elprotect "AmigaDos / File Protection Bits"
@toc DOSContents

@{b}Command Syntax@{ub}

	= ElProtect( @{i}FILENAME$ @{ui})
	Els Protect @{i}FILENAME$ , BITS @{ui}



@{b}Description@{ub}

   Each AmigaDos file or directory has a set of 8 protection bits, which
   are usually set to '----rwed'. The full set is 'hsparwed'.

   
   h = Hidden file/dir. 

       When a file/dir has it's h bit set, it is not listed in many
       directory listing & file selectors - well thats the theory anyway - 
       I've never come across anything that takes any notice of it!


   s = script file.

       When a file has it's s bit set, it means it is a script file. Under
       KickStart 2/3 this means you can execute the script as if it was a
       program by typing it's filename into the CLI/Shell.


   p = pure file.

       A file's pure bit is used by the AmigaDos resident comand to indicate
       that it can be made resident safely. Pure means that it is re-
       execuatable (If you loaded the code into memory, executed it, then
       executed the same copy again, it would still work the second time),
       and re-enterant (If you loaded the code into memory, then executed it
       twice as two processes simultaneously,  both would work).


   a = archived file / directory.

       In general, whenever a program writes to a file, it's archive bit is
       cleared. Archivers such as lha, and harddisk backup programs can be
       made to set the archive bit of the files they make a backup of. Then 
       at a later date, when you come to update your backup , you can make
       the archiver ignore all files with the archive bit set, as you know 
       that they have not been changed since the last time you made a backup.
    

    r = readable file.

       If a file does not have it's readable bit set, many programs will
       refuse to read from / load it. 


    w = writeable file.

       If a file does not have it's writeable bit set, many programs will
       refuse to overwrite it, or append to it.


    e = executable file.
  
       If a file does not have it's executable bit set, it cannot be run as 
       a program.


    d = deletable file.

       If a file does not have it's deletable bit set, you cannot delete it.
    

    The =ElProtect function call returns the protection bits of the given
    file or directory name as an integer. Els Protect allows you to 
    overwrite the bits of the given filename with a new set. The integer
    returned from ElProtect, and passed to Els Protect, has it's lower 8
    bits corresponding to the 8 protection bits.

    For the lower 4 bits, a value of 0 means on, and 1 off, but for the
    upper 4 bits, 0 is off, and 1 is not. This means that the default flags
    "----rwed" have a value of 0.
      
        
	Bit         Meaning Clear (0)       Meaning Set (1)        
	----------------------------------------------------------
	 0          Can be deleted          Can't be deleted     
	 1          Can be executed         Can't be executed  
	 2          Can be read from        Can't be read from 
	 3          Can be writen to        Can't be writen to  
	 4          File not archived       File is archived 
	 5          File not pure           File Pure          
	 6          File not a DOS script   File is a DOS script 
	 7          File visible in lists   File hidden is lists

                        

@{b}Notes@{ub}

  - You should not set any of the upper 24 bits of the integer passed
    to Elsprotect.

  - Bits s & p should not be set on directories.

  - Not all programs abide by the protection bits - they are often ignored.



@{b}Errors@{ub}

    Any I/O error such as 'File Not Found', 'Device Not Available' etc. may
    occur if the filename given is not valid, or there the disk is corrupted.
@endnode



@node C_Elstdout "AmigaDos / Console Output"
@toc DOSContents

@{b}Command Syntax@{ub}

	=Elout Exists
	Elout STRING$



@{b}Description@{ub}

    The Elout Exists function will return True (-1) when there is a standard
    output console window availble to write to, and False when there isn't.

    The Elout command sends the string to the standard output. It may 
    contain AmigaDOS formating codes:

    AscII characters 32-127 and 160-255 are sent directly. The following
    ANSI control sequences are also accepted. Hex values refer to AscII
    codes - e.g. in AMOS $9B $40 is Chr$($9B)+Chr$($40).

    NOTE: Wherever $9B occurs, you can either send $9B, or $1B followed by
          a '[' character.

    NOTE: N refers to a ascII number - i.e. A string of digits. [] around a
          term means it is an optional parameter and may be omited.

	Value		Action

	$8		Backspace

	$A		Line Feed (See Below)

	$B		Move Cursor Up One Line

	$C		Clear Console Window

	$D		Carriage Return (Without Line Feed)

	$E		Shift Mode Off

	$F		Shift Mode On. If Shift Mode is On, the Most 
			significant bit of each character is set. I.E. Each
			character is bitwise or'd with $80.

	$1B $63		Reset Console to its initial state.

	$9B [N] $40	Insert N spaces at cursor position (Defaults to 1)
	$9B [N] $41	Move cursor up N lines (Default 1)
	$9B [N] $42	Move cursor down N lines (Default 1)
	$9B [N] $43	Move cursor right N positions (Default 1)
	$9B [N] $44	Move cursor left N positions (Default 1)
	$9B [N] $45	Move cursor down N lines, and to column 1 (Default 1)
	$9B [N] $46	Move cursor up N lines, and to column 1 (Defualt 1)

	$9B [Y] [$3B X] $48
			Move cursor to co-ordinates X,Y - Although both
			are optional, at least one of X and Y must be 
			specified. Note that the $3B (;) always preceeds 
			X even if there is no Y.

	$9B $4A		Clear from current cursor position to the end of
			the window

	$9B $4B		Clear from current cursor posiiton to the end of
			the line

	$9B $4C		Insert a new line above the line containing the 
			cursor. This shifts all lines below the current
			line down one line.

	$9B $4D		Remove the line containing the cursor. This shifts
			all lines below up one line, and clears the bottom
			line.        
        
	$9B [N] $50	Delete N characters to the right of the cursor,
			including the one under the cursor (Default 1).

	$9B [N] $53	Scroll display up N lines (Default 1).

	$9B [N] $54	Scroll display down N lines (Default 1).
        
	$9B $32 $30 $68 Set PC Line feed mode (See below)

	$9B $32 $30 $6C Set Amiga Line feed mode (See below)


   The line feed code ($A) usually only sends a line feed. However, if the
   PC line feed mode sequence has been sent, a carriage return is also sent
   along with each line feed. Amiga line feed mode disables this again.


   You can also send ANSI text colour / style change commands. These are of
   arbitary length, but always start with character $9B, and end with
   character $6D. In between are strings of AscII digits seperated by
   semi-colons. The digits strings have the following meanings:

        0       Plain text
        1       Bold Face
        3       Italics
        4       Underscore
        7       Inverse video

        30 - 37 Change foreground colour to N-30
        40 - 47 Chagge background colour to N-40

   E.g. $9B "31;43;1m" sets pen 1, paper 3, in boldface. (m=$6D)

        
   You can also include the following character sequences in the output
   string. These are not ANSI sequences - they only apply to the amiga
   console device:

	$9B N $74	Set Number of lines to N. NOTE: This doesn't
			change the window size, just allows you to use
			only part of it.

	$9B N $75	Set Number of columns to N. This also doesn't
			affect the window size.

	$9B N $78	Set the offset from the left of the window
			to the first column to N pixels.

	$9B N $79	Set the offset from the top of the window
			to the first row to N pixels.
               
	$9B $30 $20 $70	Make the cursor invisible
	$9B $20 $70	Make the cursor visible

@endnode



@node C_Elstdin "AmigaDOS / Console Input"
@toc DOSContents

@{b}Command Syntax@{ub}

	=Elin Exists
	=Elin$( @{i}NUMCHARS @{ui})
	=Elin Get$



@{b}Description@{ub}

    The Elin Exists function returns True (-1) when there is an active
    standard input available for AMOS to read from. Elin$ will read up
    to @{i}NUMCHARS @{ui}characters from the standard input, but will stop reading
    at the first linefeed character. (I.E. Where the user pressed return).

    Elin Get$ will return a single character from the standard input, or
    "" if nothing has been typed

@{b}Notes@{ub}

  - @{i}NUMCHARS @{ui}should be 256 for normal Console user input.

  - Elin$ will wait until enough characters, or a linefeed is read,
    suspending AMOS for the intervening period. Elin Get$ always
    returns immediately.

  - Make sure that the Amos To Back command has been used when waiting
    for interactive input, or AMOS will freeze.
@endnode


@node C_Elexec "AmigaDos / Executing Programs"
@toc DosContents

@{b}Command Syntax@{ub}

	=Elexec( @{i}FILENAME$ @{ui})



@{b}Description@{ub}

    This function is similar to the AMOSPro Exec function except it 
    executes the specified file and passes it AMOS's standard input,
    and standard output, and it also gives the AmigaDos return code
    of the program as a result

@{b}Notes@{ub}

  - Standard Result Codes are:

    0 = No Error
 
    5 = Warning

    10 = Error
  
    20 = Fail

    But not all programs use them.


  - When STDIN or STDOUT don't exist, the program is passed a NIL: input or
    output.



@{b}Errors@{ub}

    Standard AmigaDos error return codes for File Not Found, Out of Memory
    etc. may be returned in the Return Code.

@endnode



@node C_Elwb "Intuition / The Workbench"
@toc DOSContents

@{b}Command Syntax@{ub}

	= Elwb Close
	= Elwb Open
	= Elwb Test



@{b}Description@{ub}

AMOS provides a close workbench command, but it does not tell you whether
the workbench did actually close or not. =Elwb Close closes the workbench,
and returns True if it was successful.

=Elwb Open can be used to reopen a closed workbench screen. If the workbench
program was running on the screen (I.E. You had called LoadWb), it will be
restarted. It too returns a boolean to indicate if it was sucessfull.

=Elwb Test simply returns True if the workbench is currently open.



@{b}Notes@{ub}

  - Elwb close returns true if the workbench is closed when the function
    has finished executing, even if it didn't close it because it was
    already closed.

  - Similarly Elwb open returns true if the workbench is open when it
    finishes executing, even if it was already open.
  

  - Elwb Close and Elwb Test have the side effect of bringing the workbench
    screen to the front of all other  intuition screens (But not in front 
    of AMOS Screens). This means:
      
    o If Elwb Close fails, the workbench screen will be put in front of
      other screens.
        
    o After an Elwb Test, the workbench screen is brought to the front if
      it is open. You may like to call Elwb Test simply for this purpose
      after an Elwb Open.
@endnode



@node C_Eliconify "Intuition / Iconifying AMOS"
@toc DOSContents

@{b}Command Syntax@{ub}

	=ElIconify Amos( @{i}X , Y , TITLE$ @{ui})

	=ElIconify Begin( @{i}X , @{i}Y , TITLE$ @{ui})
	=ElIconify Test
	ElIconify End



@{b}Description@{ub}

    ElIconify AMOS opens the workbench screen, and opens a small window on 
    it at co-ordinates ( @{i}X,Y @{ui}) with the name @{i}TITLE$. @{ui}It has a close window
    gadget, depth gadget(s), and is moveable. 
        
    If you activate the window, then press the right mouse button, or you
    press the close window gadget, the window is closed, and one of the
    following values is returned:
        
    -1 = The close window gadget was pressed.

    0  = Then right mouse button was pressed with the window active.

    1  = Couldn't open workbench screen (There was not enough free chipmem).
        
    2  = Couldn't open window (Usually means that It wouldn't fit on the screen at the
         given co-ordinates).


        
    ElIconify AMOS suspends your AMOS program until the user de-iconifies it.
    You may keep your program running while iconified by using the other
    three functions instead.
        

    =ElIconify Begin takes the same arguments are ElIconify AMOS, but returns
     immediately. The values returned are:

        0  = Window opened successfully,
        
        1  = Couldn't open workbench screen.
        
        2  = Couldn't open window.


    =ElIconify Test also returns immediately, and if returns the following
    values:

        -1 = The user has pressed the right mouse button in
             the window title bar since the last call.

        0  = The user has done nothing since the last call.

        1  = The user has pressed the close window gadget
             since the last call.

    ElIconify End closes the window opened by ElIconify Begin.



@{b}Notes@{ub}

  - Since ElIconfiy AMOS suspends your program, you should always use the
    following procedure:

	Procedure ICONIFY[X,Y,TITLE$]
	    Amos Lock
	    Amos To Back
	    A=Iconify Amos[X,Y,TITLE$]
	    Amos To Front
	    Amos Unlock
	End Proc[A]

    The Lock/Unlock disable Left-Amiga-A switching, as the program is frozen
    while the window is displayed. An alternative method is to lock amos at 
    the start of your program, and leave it locked, and remove the lock / 
    unlock commands from this procedure.
        
    If possible you should close your AMOS screens when iconifing, and free
    other resources as this saves some memory, which is the whole point of 
    iconification.



@{b}Errors@{ub}

    @{u}Illegal Function Call@{uu}

    You called =ElIconfiy Test, or ElIconify End without first creating an 
    iconified window with =ElIconfiy Begin

    Other error conditions are returned as result values.
@endnode



@node MiscContents "Miscellanous Commands - Contents"

                   @{u}@{b}Miscellaneous Commands & Functions@{ub}@{uu}

	@{"Reading AMOS Internal Data " link C_Elbase}
	@{"Waiting For The Raster Beam" link C_ElrasterWait}
	@{"Envoironment Testing       " link C_Elpro}
	@{"Reseting AMOS Extensions   " link C_Elreset}
	@{"Overlapping Rectangles     " link C_Eloverlap}
	@{"Bank Existance Checking    " link C_ElbnkHere}
	@{"File Existance Checking    " link C_ElExists}

@endnode



@node C_Elbase "Misc / Reading AMOS Internal Data"
@toc MiscContents

@{b}Command Syntax@{ub}
        
	= Elbase @{i}NUM@{ui}



@{b}Description@{ub}

   AMOS has a rather large internal datazone, which is documented in the
   |lequ.s file in the extensions drawer on AMOSPro_Tutorial:. (The AMOS
   Creator version is in Extras:Extensions/"). If you call Elbase with
   a parameter of 0, the address of this data structure is returned. 

   NOTE: For extension programmers, this is the value of register A5.


   Also, each AMOS extension can have its own data zone. To obtain the
   address of any extensions data zone, pass the extension number as the
   parameter.




@{b}Notes@{ub}

  - It goes without saying that the contents of the data zones will change
    with different versions of AMOS / The extensions, but this can be 
    useful for debugging extensions (I should know :-)

  - Negative valus of Elbase may return various values I use to debug
    easylife, or for Easylife support programs to communicate with the
    extension. Do not use these.

  - A 0 will be returned for non-existant extensions, or extensions without
    any data.
@endnode



@node C_ElrasterWait "Misc / Waiting On The Raster Beam Position"
@toc MiscContents

@{b}Command Syntax@{ub}

	ElRaster Wait @{i}SCANLINE@{ui}



@{b}Description@{ub}

This is an enhancement to Wait Vbl - It waits for the raster beam to reach the
given Scanline. Easylife checks all 9 bits of the scan position, so you can
wait on values >256. 



@{b}Notes@{ub}

  - The scanline check is done with a busy wait loop, so it eats processor
    time - don't use it when multi-tasking!
@endnode



@node C_Elpro "Misc / Detecting Your Runtime Envoironment"
@toc MiscContents

@{b}Command Syntax@{ub}

        = ElPro
        = ElCompiled



@{b}Description@{ub}

    =ElPro returns true when your program is being run from AMOS Pro, or if
     it was compiled from the AMOS Pro compiler. It returns False if it was
     run from AMOS Creator, or was compiled with the AMOS Creator compiler.

    =ElCompiled returns true if your program is running as a stand-alone
     program, and false when it is being run under AMOS.



@{b}Notes@{ub}

  - If your program is compiled in AMOS mode - I.E. to be loaded into the
    AMOS interpreter when compiled and run from there, ElCompiled will
    return false. ElCompiled will only return True if it is being run as a
    stand-alone program outside the AMOS envoironment.
  
  - The compiler extenion has an equivilent instruction, but it is not a lot
    of use to people who haven't bought the compiler!
@endnode




@node C_Elreset "Misc / Reseting AMOS Extensions"
@toc MiscContents

@{b}Command Syntax@{ub}

	El Reset @{i}NUM@{ui}



@{b}Description@{ub}

   This command will make extension number @{i}NUM @{ui}think that the AMOS 'Default'
   command has been called, and the extension will reset itself. However
   the default command is not called, so the screen etc. is not reset.



@{b}Notes@{ub}

  - To reset easylife use 'Elreset 16'. The effects on easylife will be
    the same as the effects of the @{"Default" link CommandEffects} command.
@endnode




@node C_Eloverlap "Misc / Overlaping Rectangles"
@toc MiscContents

@{b}Command Syntax@{ub}

	=El Overlap( @{i}A1 , B1 , A2 , B2@{ui} To @{i}X1 , Y1 , X2, Y2@{ui} )
	=El Lapsx
	=El Lapsy
	=El Lapex
	=El Lapey



@{b}Description@{ub}

    These functions returns the co-ordinates of the portion of two rectangles
    which overlap. The two rectangles are described as follows:

    A1 , B1  : The co-ordinates of the top-left hand corner of rectangle 1
    A2 , B2  : The co-ordinates of the bottom-right had corner of rectangle 1 

    X1 , Y1  : The co-ordinates of the top-left hand corner of rectangle 2
    X2 , Y2  : The co-ordinates of the bottom-right had corner of rectangle 2 

    Eloverlap returns True if the two rectangle overlap, and false if they
    do not. If they do overlap, the other 4 functions will return the
    co-ordinates of the rectangle which describes the overlaping area.

@{b}Notes@{ub}

  - If Eloverlap returns False, the values of the other functions are
    undefined.

  - This may seem fairly useless, but try writting a program that creates
    windows with depth gadgets on an AMOS screen :-)
@endnode

@node C_ElbnkHere "Misc / Bank Existance Checking"
@toc MiscContents

@{b}Command Syntax@{ub}

	=Elbnk Here ( @{i}BNKNO @{ui})



@{b}Description@{ub}

    This function will return True (-1) if the specified bank has been
    reserved for the current program, or False (0) if it has not.
@endnode


@node C_ElExists " Misc / File Existance Checking"
@toc MiscContents

@{b}Command Syntax@{ub}

	=Elexists ( @{i}FILENAME$ @{ui})



@{b}Description@{ub}

    This is similar to the AMOS exists function, except:

    - If the file does not exist, a 'Please Insert Volume...'
      requester will appear.

    - If it returns 0, the file did not exist.

    - If it returns a negative number, the file did exist.

    - If it returns a positive number, then this is the name of an
      existing directory, not a file.



@{b}Errors@{ub}

    Various Disk I/O Errors may occur.
@endnode










@node SubjectIndex "Index - By Subject"
@toc main
@prev main


                           @{b}@{u}Index - By Subject@{uu}@{ub}

This is a complete index of all subjects covered in this Easylife
manual. There is also an index to all @{"Commands & Functions" link CommandIndex}.

AMOS Commands:
    @{"Default                         " link CommandEffects}
    @{"ReserveZone                     " link C_ReserveZone}
@{"AMOS Internal Datazone              " link C_elbase}
@{"AMOS Mailing List                   " link credits}
@{"AMOS World-Wide-Web Site            " link credits}
@{"ANSI Control Strings                " link C_Elstdout}

Banks:
    @{"Loading XPK Compressed          " link C_ElxpkLoad}
    @{"Reading Name                    " link C_ElBankName}
    @{"Saving With XPK Compression     " link C_ElxpkSave}
    @{"Setting Name                    " link C_ElsBankName}
    @{"Testing For Existance Of        " link C_ElBnkHere}
Bitwise Operations:
    @{"Modifing                        " link C_Elwset}
    @{"Testing                         " link C_Elwtst}

@{"Console Input                       " link C_Elstdin}
@{"Console Output                      " link C_Elstdout}
@{"Contacting The Author               " link /EasylifeIntro.Guide/Author}
@{"Conventions used in this manual     " link Conventions}

@{"Distribution Conditions             " link Distribution}

@{"Effects of Easylife On AMOS Commands" link CommandEffects}
@{"Executing Other Programs            " link C_Elexec}
Extensions:
    @{"Finding The Internal Datazone   " link C_Elbase}
    @{"Reseting Extensions             " link C_Elreset}

@{"File Existance Checking             " link C_ElExists}
@{"File Protection Bits                " link C_Elprotect}
@{"Finding The Runing Envoironment     " link C_Elpro}
@{"Font Locking                        " link C_EllockFont}

@{"Garuntee                            " link garuntee}

@{"Iconifying AMOS                     " link C_Eliconify}
@{"Installing Easylife                 " link installation}
Integers:
    @{"Converting To Strings           " link C_Ellong}
    @{"Sign Extension                  " link C_Elextw}
@{"Introduction                        " link Introduction}

Message Banks:
    @{"Reading Messages                " link C_Elmessage}
    @{"Testing Existance Of Messages   " link C_ElmessageExists}
Magic User Interface:
    @{"Disposing Of Objects            " link EasylifeMUI.guide/C_MuiDispose}
    Dynamic Children:
        @{"Adding                      " link EasylifeMUI.guide/C_MuiAdd}
        @{"Removing                    " link EasylifeMUI.guide/C_MuiRemove}
    @{"Flushing Strings                " link EasylifeMUI.guide/C_MuiFlush}
    @{"Introduction                    " link EasylifeMUI.guide/C_Muiintro}
    @{"Hook Functions                  " link EasylifeMUI.guide/C_MuiHook}
    @{"Methods                         " link EasylifeMUI.guide/C_MuiDo}
    @{"Notification                    " link EasylifeMUI.guide/C_MuiNotify}
    Object Attributes:
        @{"Reading                     " link EasylifeMUI.guide/C_MuiGet}
        @{"Setting                     " link EasylifeMUI.guide/C_MuiSet}
    Object Creation:
        @{"Application Object          " link EasylifeMUI.guide/C_MuiApp}
        @{"Built-ing Objects           " link EasylifeMUI.guide/MuiMake}
        @{"Other Objects               " link EasylifeMUI.guide/C_MuiNew}
    @{"Reading User Input              " link EasylifeMUI.guide/C_MuiInput}
    @{"Requesters                      " link EasylifeMUI.guide/C_MuiRequest}
    Taglists    (See Taglists below)
@{"Mailing List                        " link credits}
Multi Zones:
    @{"Erasing                         " link C_ElmzErase}
    @{"Reading Co-ordinates            " link C_Elmznsx}
    @{"Reserving                       " link C_ElmzReserve}
    @{"Setting                         " link C_ElmzSet}
    @{"Testing A Point Against         " link C_Elmzone}

@{"Overlapping Rectanges               " link C_Eloverlap}

Pattern Matching:
    @{"Converting A Pattern To A String" link C_ElpatConv}
    @{"Escaping A String               " link C_ElpatEscape}
    @{"Format Of Patterns              " link PatChar}
    @{"Multiple Matches                " link C_ElpatDef}
    @{"Single Match                    " link C_ElpatCase}
    @{"Testing If It is required       " link C_ElpatTest}
    @{"What Is A Pattern?              " link WhatIsPattern}
Powerpacker:
    @{"Allocating Buffers              " link C_ElppAllocate}
    @{"Crunching Data                  " link C_ElppCrunch}
    @{"Freeing Buffers                 " link C_Elppbuf}
    @{"Library Loading                 " link C_ElppKeep}
    @{"Loading Crunched Data           " link C_ElppLoad}
    @{"Loading Crunched Data via XPK   " link C_ElxpkBload}
    @{"Reading Buffers                 " link C_ElppBuf}
    @{"What Is Powerpacker?            " link WhatIsPp}
@{"Protection Bits                     " link C_Elprotect}

@{"Raster Bean Position                " link C_Elraster Wait}
@{"Requirements to run easylife        " link alsoneed}
@{"Reseting Extensions                 " link C_Elreset}

@{"Sign Extension                      " link C_Elextw}
@{"Standard Input                      " link C_Elstdin}
@{"Standard Output                     " link C_Elstdout}
Strings:
    @{"Counting Characters             " link C_ElfNumAsc}
    @{"Converting To Integers          " link C_Ellong}
    @{"Padding                         " link C_ElpadAsc}
    @{"Reading From Memory             " link C_ElmemRead}
    Searching For Characters:
        @{"From Start                  " link C_ElfAsc}
        @{"From End                    " link C_ElfLastAsc}
        @{"Control Characters          " link C_ElfControl}
        @{"Nth Occurance               " link C_ElfNthAsc}
    @{"Writing To Memory               " link C_ElmemWrite}
Structured Variables:
    Compiler:
        @{"Installing                  " link EasylifeSTRUCT.guide/CompilerInstall}
        @{"Using                       " link EasylifeSTRUCT.guide/Compiler}
    Defintions:
        @{"Overview                    " link EasylifeSTRUCT.guide/DefGeneral}
        @{"Arrays                      " link EasylifeSTRUCT.guide/DefArrays}
        @{"Booleans                    " link EasylifeSTRUCT.guide/DefBoolean}
        @{"Constants                   " link EasylifeSTRUCT.guide/DefConstant}
        @{"Enumerations                " link EasylifeSTRUCT.guide/DefEnum}
        @{"Integers                    " link EasylifeSTRUCT.guide/DefInteger}
        @{"Macro Structures            " link EasylifeSTRUCT.guide/DefMacro}
        @{"Real Numbers                " link EasylifeSTRUCT.guide/DefReal}
        @{"Strings                     " link EasylifeSTRUCT.guide/DefString}
        @{"Structures                  " link EasylifeSTRUCT.guide/DefGeneral}
        @{"Sub-Structures              " link EasylifeSTRUCT.guide/DefSub}
    Elements:
        @{"Modifying                   " link EasylifeSTRUCT.guide/C_StSet}
        @{"Reading                     " link EasylifeSTRUCT.guide/C_StGet}
        @{"Pointers                    " link EasylifeSTRUCT.guide/pointers}
    @{"Freeing All Structures          " link EasylifeSTRUCT.guide/C_StFreeAll}
    Instances:
        @{"Creating                    " link EasylifeSTRUCT.guide/C_StNew}
        @{"Copying                     " link EasylifeSTRUCT.guide/C_StCopy}
        @{"Duplicating                 " link EasylifeSTRUCT.guide/C_StDup}
        @{"Freeing                     " link EasylifeSTRUCT.guide/C_StFree}
        @{"Reading Type & Length       " link EasylifeSTRUCT.guide/C_StType}
    @{"Internal Formats                " link EasylifeSTRUCT.guide/StorageContents}
    @{"Introduction                    " link EasylifeSTRUCT.guide/WhatIs}
    I/O:
        @{"Saving A Structure          " link EasylifeSTRUCT.guide/C_StOutput}
        @{"Loading A Structure         " link EasylifeSTRUCT.guide/C_StInput}
        @{"Saving A Graph              " link EasylifeSTRUCT.guide/C_StSave}
        @{"Loading A Graph             " link EasylifeSTRUCT.guide/C_StSave}
    @{"Library Calls                   " link EasylifeSTRUCT.guide/LibraryContents}
    String Elements:
        @{"Comparing                   " link EasylifeSTRUCT.guide/C_StCmp}
        @{"Modifying                   " link EasylifeSTRUCT.guide/C_StSetStr}
        @{"Reading                     " link EasylifeSTRUCT.guide/C_StGet}
    @{"Tutorials                       " link EasylifeSTRUCT.guide/Tutorials}        
    


Taglists:    
    @{"Block Size                      " link EasylifeMUI.guide/C_TagBlockSize}
    Creation:
        @{"Simple                      " link EasylifeMUI.guide/C_Tag}
        @{"With Integers               " link EasylifeMUI.guide/C_TagInt}
        @{"With Strings                " link EasylifeMUI.guide/C_TagStr}
        @{"MUI Child Object taglists   " link EasylifeMUI.guide/C_TagAttach }
    @{"Lifetime of strings             " link EasylifeMUI.guide/C_TagKeep}
Taglist Banks:
    @{"Creating                        " link TagCompiler.guide/main}
    @{"Using Taglists From             " link EasylifeMUI.guide/C_TagList}
@{"Thanks to...                        " link credits}
@{"To-Do List                          " link todo}

@{"Upgrades                            " link Upgrades }

@{"Workbench Screen                    " link C_Elwb}
@{"World-Wide-Web Site                 " link credits}

XPK Compression: 
    @{"Errors                          " link C_ElxpkError}
    @{"Length Of File                  " link C_ElxpkLof}
    @{"Loading Banks                   " link C_ElxpkLoad}
    @{"Loading Data                    " link C_ElxpkBload}
    @{"Saving Banks                    " link C_ElxpkSave}
    @{"Saving Data                     " link C_ElxpkSave}
    @{"What Is XPK?                    " link WhatIsXPK}

Zones:
    @{"Reading Co-ordinates            " link C_Elznsx}
    @{"Shifting                        " link C_ElznShift}

@{"Zone Banks                          " link ZoneBank}
    
@endnode





    
@remark *******************************************************************


@node CommandIndex "Index - By Commands & Functions"
@toc main


                          @{b}@{u}Command & Funcion Index@{ub}@{uu}

This is a complete index of all Easylife Commands & Functions, along with
AMOS command whose behaviour has been modified. These is also an index to
all @{"Subjects" link SubjectIndex} covered in this manual.


@{u}Easylife Commands:@{uu}

@{"=Elbank Name$           " link C_ElbankName}
@{"=Elbnk Here             " link C_ElbnkHere}
@{"=Elbase                 " link C_Elbase}

@{" Elclose Font           " link C_ElcloseFont}
@{" Elclose Fonts          " link C_ElcloseFonts}
@{"=Elexec                 " link C_ElExec}
@{"=Elexists               " link C_ElExists}
@{"=Elextb                 " link C_Elextw}
@{"=Elextw                 " link C_Elextw}

@{"=Elcompiled             " link C_Elpro}

@{"=Elf Asc                " link C_ElfAsc}
@{"=Elf Char               " link C_ElfAsc}
@{"=Elf Control            " link C_ElfControl}
@{" Elf Fail End           " link C_ElfFailStart}
@{" Elf Fail Start         " link C_ElffailStart}
@{"=Elf Last Asc           " link C_ElfLastAsc}
@{"=Elf Last Char          " link C_ElfLastAsc}
@{"=Elf Last Not Asc       " link C_ElfLastAsc}
@{"=Elf Last Not Char      " link C_ElfLastAsc}
@{"=Elf Not Asc            " link C_ElfAsc}
@{"=Elf Not Char           " link C_ElfAsc}
@{"=Elf Nth Asc            " link C_ElfNthAsc}
@{"=Elf Nth Char           " link C_ElfNthAsc}
@{"=Elf Num Asc            " link C_ElfNumAsc}
@{"=Elf Num Char           " link C_ElfNumAsc}

@{"=Eliconify Amos         " link C_Eliconify}
@{"=Eliconify Begin        " link C_Eliconify}
@{" Eliconify End          " link C_Eliconify}
@{"=Eliconify Test         " link C_Eliconify}
@{"=Elin$                  " link C_Elstdin}
@{"=Elin Exists            " link C_Elstdin}
@{"=Elin Get$              " link C_Elstdin}

@{"=El lapex               " link C_Eloverlap}
@{"=El lapey               " link C_Eloverlap}
@{"=El lapsx               " link C_Eloverlap}
@{"=El lapsy               " link C_Eloverlap}
@{" Ellchg                 " link C_Elwset}
@{" Ellclr                 " link C_Elwset}
@{"=Ellock Font            " link C_EllockFont}
@{"=Ellong                 " link C_Ellong}
@{"=Ellong$                " link C_Ellong}
@{" Ellset                 " link C_Elwset}
@{"=Elltst                 " link C_Elwtst}

@{" Elmem                  " link C_ElmemWrite}
@{"=Elmem Inc              " link C_ElmemWrite}
@{"=Elmem$                 " link C_ElmemRead}
@{"=Elmessage Exists       " link C_ElmessageExists}
@{"=Elmessage$             " link C_Elmessage}

@{" Elmz Erase             " link C_ElmzErase}
@{" Elmz Reserve           " link C_ElmzReserve}
@{" Elmz Set               " link C_ElmzSet}
@{"=Elmzone                " link C_Elmzone}
@{"=Elmzoneg               " link C_Elmzone}
@{"=Elmzonen               " link C_Elmzone}
@{"=Elmznex                " link C_Elmznsx}
@{"=Elmzney                " link C_Elmznsx}
@{"=Elmznsx                " link C_Elmznsx}
@{"=Elmznsy                " link C_Elmznsx}

@{"=Elopen Font            " link C_ElopenFont}
@{" Elout                  " link C_Elstdout}
@{"=Elout Exists           " link C_Elstdout}
@{"=Eloverlap              " link C_Eloverlap}

@{"=Elpad Asc              " link C_ElpadAsc}
@{"=Elpad Char             " link C_ElpadAsc}
@{"=Elpat Case             " link C_ElpatCase}
@{"=Elpat Def              " link C_ElpatDef}
@{"=Elpat Escape           " link C_ElpatEscape}
@{" Elpat Free             " link C_ElpatDef}
@{"=Elpat Nocase           " link C_ElpatCase}
@{"=Elpat Remove           " link C_ElpatRemove}
@{" Elpat Set Case         " link C_ElpatDef}
@{" Elpat Set Nocase       " link C_ElpatDef}
@{"=Elpat Test             " link C_ElpatTest}

@{"=Elpp Allocate          " link C_ElppAllocate}
@{"=Elpp Buf               " link C_ElppBuf}
@{"=Elpp Crunch            " link C_ElppCrunch}
@{" Elpp Free              " link C_ElppFree}
@{" Elpp Free All          " link C_ElppFree}
@{" Elpp Keep Off          " link C_ElppKeep}
@{" Elpp Keep On           " link C_ElppKeep}
@{" Elpp Load              " link C_ElppLoad}
@{"=Elpp Len               " link C_ElppBuf}
@{"=Elpro                  " link C_Elpro}
@{"=Elprotect              " link C_Elprotect}

@{" Elraster Wait          " link C_ElrasterWait}
@{" Elreset                " link C_Elreset}

@{" Els protect            " link C_Elprotect}
@{" Els Bank Name          " link C_ElsBankName}
@{" Elset Font             " link C_ElsetFont}

@{" Elunlock Fonts         " link C_EllockFont}

@{"=Elwb Close             " link C_Elwb}
@{"=Elwb Open              " link C_Elwb}
@{"=Elwb Test              " link C_Elwb}
@{" Elwchg                 " link C_Elwset}
@{" Elwclr                 " link C_Elwset}
@{"=Elword                 " link C_Ellong}
@{"=Elword$                " link C_Ellong}
@{" Elwset                 " link C_Elwset}
@{"=Elwtst                 " link C_Elwtst}

@{" Elxpk Bload            " link C_ElxpkBload}
@{" Elxpk Bsave            " link C_ElxpkBsave}
@{"=Elxpk Error            " link C_ElxpkError}
@{" Elxpk Load             " link C_ElxpkLoad}
@{"=Elxpk Lof              " link C_ElxpkLof}
@{" Elxpk Save             " link C_ElxpkSave}

@{" ElZb Add               " link C_ElzbAdd}
@{" ElZb Multi Add         " link C_ElzbMultiAdd} 		 Installing Single Groups
@{" ElZb Muiti Add         " link C_ElzbInstall}		 Installing Whole Banks 
@{" ElZn Shift             " link C_ElznShift}
@{"=ElZnex                 " link C_Elznsx}
@{"=ElZney                 " link C_Elznsx}
@{"=ElZnsx                 " link C_Elznsx}
@{"=ElZnsy                 " link C_Elznsx}


@{u}MUI Commands / Functions@{uu}

@{" Mui Add                " link EasylifeMUI.guide/C_MuiAdd}
@{"=Mui App                " link EasylifeMUI.guide/C_MuiApp}
@{"=Mui Application        " link EasylifeMUI.guide/C_MuiApp}
@{" Mui Begin              " link EasylifeMUI.guide/C_MuiNew}
@{" Mui Dispose            " link EasylifeMUI.guide/C_MuiDispose}
@{" Mui Do                 " link EasylifeMUI.guide/C_MuiDo}
@{" Mui Flush              " link EasylifeMUI.guide/C_MuiFlush}
@{"=Mui Fn                 " link EasylifeMUI.guide/C_MuiDo}
@{"=Mui Get                " link EasylifeMUI.guide/C_MuiGet}
@{"=Mui Get$               " link EasylifeMUI.guide/C_MuiGet}
@{"=Mui Hook               " link EasylifeMUI.guide/C_MuiHook}
@{"=Mui Input              " link EasylifeMUI.guide/C_MuiInput}
@{"=Mui Make Button        " link EasylifeMUI.guide/C_MuiMakeButton}
@{"=Mui Make PopButton     " link EasylifeMUI.guide/C_MuiMakePopButton}
@{"=Mui New                " link EasylifeMUI.guide/C_MuiNew}
@{" Mui Notify             " link EasylifeMUI.guide/C_MuiNotify}
@{" Mui Remove             " link EasylifeMUI.guide/C_MuiRemove}
@{"=Mui Request            " link EasylifeMUI.guide/C_MuiRequest}
@{" Mui Set                " link EasylifeMUI.guide/C_MuiSet}
@{" Mui Set Str            " link EasylifeMUI.guide/C_MuiSetStr}

@{"=Tag                    " link EasylifeMUI.guide/C_Tag}
@{"=Tag$                   " link EasylifeMUI.guide/C_Tag}
@{"=Tag$                   " link EasylifeMUI.guide/C_TagInt}		Integer Form
@{"=Tag Attach$            " link EasylifeMUI.guide/C_TagAttach}
@{" Tag Block Size         " link EasylifeMUI.guide/C_TagBlockSize}
@{" Tag Keep               " link EasylifeMUI.guide/C_TagKeep}
@{"=Tag list$              " link EasylifeMUI.guide/C_TagList}
@{"=Tag Str$               " link EasylifeMUI.guide/C_TagStr}


@{u}Structured Variables Commands & Functions@{uu}

@{"=St Cmp                 " link EasylifeSTRUCT.guide/C_StCmp}
@{" St Copy                " link EasylifeSTRUCT.guide/C_StCopy}
@{"=St Dup                 " link EasylifeSTRUCT.guide/C_StDup}
@{" St Free                " link EasylifeSTRUCT.guide/C_StFree}
@{" St Free All            " link EasylifeSTRUCT.guide/C_StFreeAll}
@{"=St Get                 " link EasylifeSTRUCT.guide/C_StGet}
@{"=St Get$                " link EasylifeSTRUCT.guide/C_StGet}
@{" St Input               " link EasylifeSTRUCT.guide/C_StInput}
@{"=St Len                 " link EasylifeSTRUCT.guide/C_StType}
@{"=St Load                " link EasylifeSTRUCT.guide/C_StSave}
@{"=St New                 " link EasylifeSTRUCT.guide/C_StNew}
@{"=St Output              " link EasylifeSTRUCT.guide/C_StOutput}
@{" St Save                " link EasylifeSTRUCT.guide/C_StSave}
@{" St Set                 " link EasylifeSTRUCT.guide/C_StSet}
@{" St Set Str             " link EasylifeSTRUCT.guide/C_StSet}
@{"=St Type                " link EasylifeSTRUCT.guide/C_StType}


@{u}AMOS Commands@{uu}

@{" Default                " link CommandEffects}
@{" Reserve Zone           " link C_ReserveZone}
@endnode



@node CommandEffects "Changes to the behaviour of other AMOS commands"


                   @{b}@{u}Effects Of Easylife On AMOS Commands@{ub}@{uu}

  - The @{"Reserve Zone" link C_ReserveZone} command will erase multi zones.

  - The Default command (And @{"Elreset 16" link C_Elreset}) will have the following effects
    on easylife:

    o @{"All powerpacker buffers are deallocated" link C_ElppFree}.

    o The @{"Default Pattern" link C_ElpatDef} is removed.

    o The MUI Application object & all MUI Root objects are @{"Disposed" link EasylifeMUI.guide/C_MuiDispose} of

    o All @{"Strings Stored" link EasylifeMUI.guide/C_TagStr} with MUI objcets are disposed of, and the 
      @{"Memory Blocks" link EasylifeMUI.Guide/C_TagBlockSize} are also deallocated.

    o All fonts are @{"unlocked" link C_EllockFont}

    o @{"Elf Fail Start" link C_ElfFailStart} is called.

    o @{"Elpp Keep Off" link C_Elppkeep} is called.

    o Any libraries Easylife has open are closed.

    o @{"St Free All link EasylifeSTRUCT.guide/main} is called.

    These are actions are also performed when you run a program from the
    AMOS / AMOSPro editor, and when you quit AMOS / AMOSPro, either via
    the Editor's Quit opition, the system command, or a compiled program
    quitting / crashing.

    They are not performed when you Prun a program, or run an accessory.    

@endnode



@node todo "To-Do List"


                                   @{b}@{u}Todo@{ub}@{uu}

 - Make Elxpk Load & Save work with sprite / icon banks.

 - Write Elxpk First$() & Elxpk Next$ to get packer information.
  
 - Write XPK versions of Open, Close, Input$, Print# & Sload.

@endnode

