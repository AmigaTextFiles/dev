Short:	Use bsdsocket.library calls in AmosPro
Uploader:	John Bintz (uv334@victoria.tc.ca)
Author:	John Bintz (uv334@victoria.tc.ca)
Type:	dev/amos

These procedures directly call bsdsocket.library, the TCP library created by
your Internet Dialer (Miami, AmiTCP, TermiteTCP).  They are much faster and more
friendly than the TCP: device equivalents, as they allow transfers to be
Non-Blocking.  Normally, with TCP:, if there was no data to get, TCP: would lock
until it got some.  Now, the program will simply ignore lack of data and move
on.

You need a lot of memory to run a Stack and Amos at the same time.  I would say
three or four meg would do it, depending on what else you have running.

Commands (port 80 is http):

BSD_OPEN
  Open the bsdsocket.library
BSD_CLOSE
  Close the bsdsocket.library and all sockets attached
SOCK_OPENCONNECTION[HOST$,SPORT]
  Open a connection to a computer in the fashion tcp://HOST$:SPORT/
  Returns Socket ID
  Example: SOCK_OPENCONNECTION["www.yahoo.com",80]
SOCK_OPENSERVER[SPORT]
  Create a server port on your computer
  Returns Socket ID
  Example: SOCK_OPENSERVER[80]
SOCK_CHECKHOSTPORT[SOCKET]
  Check Host Socket for a connection
  Returns Connected Socket ID (use this for transfers) or -1
  Example: SOCK_CHECKHOSTPORT[MYPORT]
SOCK_GETYOURHOST
  Returns your host computer's name
  Example: SOCK_GETYOURHOST : Print Param$
           "as1s23-wmn.erols.com"
SOCK_SENDSTRING[SOCKET,A$]
SOCK_READSTRING[SOCKET,MXSIZE]
  Writes and reads strings over a socket
  SENDSTRING returns characters sent
  READSTRING returns string received
SOCK_SEND[SOCKET,ADR,LEN]
SOCK_READ[SOCKET,ADR,LEN]
  Send and receive large chunks of data over a socket
  Both return numbers of characters sent/received
SOCK_CLOSE[SOCKET]
  Close a socket and save some memory
SOCK_ERR[VARADDR]
  Set a certain 4-byte memory address to receive TCP errors
SOCK_NEW
  Create a new socket
  Returns socket ID of new socket
SOCK_SETIO[SOCKET]
  Set Non-Blocking, Asynchronous IO on a Socket

There are also a collection of commands especially for working with FTP, as it
uses a crazy system of ports and data links.  I decided to save youall the
trouble of figuring out FTP.  Grab the RFC for FTP.  With these commands, you'll
have it all figured out.

FTP_OPENCONNECTION[HOST$,SPORT]
  Open an FTP connection (ftp://HOST$:SPORT/)
FTP_HOSTSOCK
  Returns Socket ID of Host machine (where to send FTP commands)
FTP_YOURSOCK
  Returns your Socket ID for transfers (where to check for files)
FTP_YOURPORT$
  Returns the PORT string to use
FTP_CLOSECONNECTION
  Close FTP connections
  
'A Sample TCP/FTP Session
'All the major commands are used in here

(FTP port is 23)

FTP_OPENCONNECTION["ftp.wustl.edu",23]
Proc FTP_HOSTSOCK : HOSTSOCK=Param
Proc FTP_YOURSOCK : YOURSOCK=Param
Proc FTP_YOURPORT$ : YOURPORT$=Param$

E$=Chr$(13)+Chr$(10)

SOCK_SENDSTRING[HOSTSOCK,"USER anonymous"+E$]
SOCK_SENDSTRING[HOSTSOCK,"PASS uv334@victoria.tc.ca"+E$]
Repeat
  SOCK_READSTRING[HOSTSOCK,256]
  Print Param$
Until Param$=""

SOCK_SENDSTRING[HOSTSOCK,"CD /pub/aminet/game/rpg/"+E$]
SOCK_SENDSTRING[HOSTSOCK,YOURPORT$]
Repeat
  SOCK_READSTRING[HOSTSOCK,256]
  Print Param$
Until Param$=""

SOCK_SENDSTRING[HOSTSOCK,"GET FinalExistence.lha"] : Rem Shameless, aren't I?
CONN=-1
Repeat
  SOCK_CHECKHOSTPORT[YOURSOCK]
  If Param>-1
    CONN=Param
    Reserve As Work 23,2048
    Open Out 1,"FinalExistence.lha"
    Repeat
      SOCK_READ[CONN,Start(23),2048] : BYTES=Param
      If BYTES>-1
        Ssave 1,Start(23) to Start(23)+BYTES-1
      End If
    Until BYTES=-1
  End If
Until CONN>-1
SOCK_CLOSE[CONN]

FTP_CLOSECONNECTION