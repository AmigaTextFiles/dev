ADT V1.0 for AMOS1.3 and above.
 
By: Mike Sikorsky (MAY/94)

    DISTRIBUTION:
    -------------
       ADT (Amos Data Types) is freely distributable.  All I ask is if you 
    make changes, improvements, bug fixes, or add new datatypes (etc) that 
    you mail me a copy.  Also it would be great if you send me some mail
    if you use/like this program.  Somekind of acknowledgment in your 
    greetings/credits/manual/etc would be appreciated if you use these
    procedures in your program, thanks. 

    You can mail me at:

       internet: sikorsky@bode.ee.ualberta.ca


    DISCLAIMER:
    -----------
       All the usual... You are using this program at your own risk.
     I can not be held responsible for any damage or whatsoever.


    WHAT IS THIS?:
    --------------
       This is a package of routines that will let you add abstract data 
    types to Amos.  If you don't know what an Abstract Data type is, well
    thats okay because you don't need to understand what they are or how
    to create them to use them.


    ARCHIVE CONTENTS:
    -----------------
       Following is a list of the Files that Should be in the Archive:
                
         ADT.Doc                         12168
         ADT_Include.AMOS                10394
         ADT_Include.Asc                  8553
         ADT_Include_LIST.AMOS           12956
         ADT_Include_LIST.Asc            10480
         ADT_Include_Small.AMOS           3508
         ADT_Include_Small.Asc            2512
         LinkedList_Example.AMOS         23958
         LinkedList_Example.Asc          19112

         Descriptions:

           ADT_Include        --> Contains the Procedures for making a new
                                  data type and nothing else.

           ADT_Include_Small  --> Same as 'ADT_Include' but without any
                                  comments... use this after you know what
                                  you are doing.

           ADT_Include_List   --> Same as 'ADT_Include' but with a Linked
                                  List DataType Added.  To see how to add
                                  a new data type definition you should 
                                  compare this file with 'ADT_Include'.

           LinkedList_Example --> This is an Example of using the Linked List
                                  data type.  It of course uses 
                                  'ADT_Include_LIST'.


           NOTE: The .AMOS files were saved with AMOS Pro v2.00... incase
                 of compatibilty problems I also included the .Asc files.
                 To use the .Asc files you have to use 'Merge Acsii' inside
                 Amos. 
                

    HOW TO CREATE A NEW ADT:
    ------------------------
       The best to learn is to look at the Linked List example.  But here are
    the steps needed to create a new ADT.

    1. Define the Structures Used with the ADT's in the Procedure "_ADT_DEFS"
       (this is found in "ADT_Include" )

       A Structure definition is just a Global Array with the following
       properties:

                Array Element 0  = The total Number of bytes your Structure
                                   is.
                Array Element 1  = The number of fields (or elements) within
                                   your structure.
                Array Element 2  = The offset to the first field in your 
                                   structure. (this should always equal 0 )

                Array Element 3  = The offset to the second field in your
                                   structure (ie. equal to size of the 1st
                                   field in your structure)
                .       
                .       
                .

                Array Element N  = The offset to the last field in your
                                   structure (ie. equal to SUM of the sizes
                                   for field (N-1) to 1 )
                   

        Example: 

          struct List {            --> _LIST_STRUCT(0) = 2*UWORD+APTR=8 bytes
                                   --> _LIST_STRUCT(1) = 3
                 UWORD x;          --> _LIST_STRUCT(2) = 0
                 UWORD y;          --> _LIST_STRUCT(3) = UWORD = 2 bytes
                 struct List *next;--> _LIST_STRUCT(4) = UWORD+UWORD =4 bytes
          }

          Just to be clear: field #1 = x // field #2 = y // field #3 = next
          (this is what any procedure who wants a '_FIELD' parameter is
           expecting) 


          * Remember This Array Must Be Made Global and Should be declared
            Global and dimensioned in the file "ADT_Include" in the section
            '**** ADT Data Type Global Declaration ***' above the Procedure
            "_INITIALIZE_ADTS".  In this Same Section you should also add
            Globals for the data type pointer and for accessing the fields
            inside the structure.

            Example: 
                    '*** ADT Data Type Global Declaration ***'
                    '
                    '
                    Dim _LIST_STRUCT(4)
                    Global _LIST_STRUCT(),_LIST_TYPE  <-- Data Type ptr
                    Global X_FIELD,Y_FIELD,NEXT_FIELD <-- Field Access
                
                    ...
                    _INITIALIZE_ADTS
                    ...
       
            
            
            Data type Pointer:  This is equal to the Address in memory of the
                                zero element of the Structure Definition Array.
                                ie. _LIST_TYPE = Varptr( _LIST_STRUCT(0) ).
                                This is what Any procedure who wants a 
                                parameter '_DATA_TYPE' is expecting.

            Globals For Field Access:  This makes the program more readable
                                       and also makes it a lot easier to change
                                       a structure def'n.
                                       ie. X_FIELD = 1 // Y_FIELD = 2 // ...
      


        Sounds Confusing eh ?  Well its not too bad... but it is easy to make
        mistakes. That was why I was going to write a routine to take a C type
        structure and convert it... well i still might... Looking at the Linked
        List Example Should Clarify this step. 


    2.  Okay now you just need to write the ADT Support Routines.  The
        routines for creating/freeing/accessing fields are in the File
        "ADT_Include".  These routines will work on any defined structure.  
        A breif description of the routines follows:

        (See the Procedure's for a more Complete description.)

        _CREATE[_DATA_TYPE,_MEM_TYPE]:

                This will Allocate the memory needed for a structure.

                _DATA_TYPE = is the data type pointer described above.
                            
                _MEM_TYPE  = this lets you specify what type of memory should
                             be used with this structure.  look in the 
                             Procedure "_LVOS_AND_DEFINES" for a complete
                             list of the _MEM_TYPE flags.

                It returns a pointer to the structure or NULL (=0) on error.
                
                Example: _CREATE[ _LIST_TYPE , MEMF_FAST + MEMF_CLEAR ] 

                         List = Param : Rem this is the '_PTR' param...



        _SET_FIELD[_DATA_TYPE,_PTR,_FIELD,_VAL]:

                This will let you set a field in a structure.

                Example: _CREATE[ _LIST_TYPE , MEMF_FAST + MEMF_CLEAR ] 

                         List = Param

                         _SET_FIELD[ _LIST_TYPE , List , X_FIELD , 20 ]


        _GET_FIELD[_DATA_TYPE,_PTR,_FIELD]:

                This will get you a field in a structure.

                Example: _CREATE[ _LIST_TYPE , MEMF_FAST + MEMF_CLEAR ] 

                         List = Param

                         _SET_FIELD[ _LIST_TYPE , List , X_FIELD , 20 ]

                         _GET_FIELD[ _LIST_TYPE , List , X_FIELD ] 

                         ? Param -O/P-> "20"
        

        _DESTROY[_DATA_TYPE,_PTR]:

                This will De-Allocate the memory needed for a structure.

                _DATA_TYPE = is the data type pointer described above.
                            
                Example: _CREATE[ _LIST_TYPE , MEMF_FAST + MEMF_CLEAR ] 

                         List = Param

                         _SET_FIELD[ _LIST_TYPE , List , X_FIELD , 20 ]

                         _GET_FIELD[ _LIST_TYPE , List , X_FIELD ] 

                         ? Param -O/P-> "20"
                
                         _DESTROY[ _LIST_TYPE , List ] : Rem mem freed
                          


        This provides all the tools you need to create a new ADT... I
        strongly suggest that you look at the LinkedList Example.. as
        I know I don't write very good instructions... so it is easier
        to see how to write an ADT than it is for me to explain it.
        

    PUTTING IT ALL TOGETHER:
    ------------------------
       Okay so know you can add a structure definition to 'ADT_Include'
    ( I hope ).  Well that is the Hard part... know you just need to
    create your own ADT.  When creating your own ADT you should either
    use Amos Pro 'Include' command, or Amos(or Pro) Merge Command to
    the Amos Program where your writing your ADT.  You must merge
    (or include) the 'ADT_Include' file before you call any procedures,
    so at or near the top should be fine.  Of course this is just
    the way I set up... you can do it differently once you look at what
    I did.

       For example I was using Amos Pro when I wrote the Linked List
    ADT so I was just 'including' the ADT procedures and structure
    defs.  But for this example I just merged it in at the top.
    Anyways if you have not already looked at the LinkedList_Example
    now is the time...

       
    IMPORTANT NOTES:
    ----------------
       Because the GET and SET Field Procedures use Loke(), Doke(),
    and Poke() (and their reverse leek/deek/peek ) you must be aware
    that any 'words/longs/aptrs' must be even alligned.. this is your
    responsibilty... example:

        struct NO_Pad {      --> this would mean that the 'next' field is
                              on an odd value so you would have to pad
               BYTE x;        the structure...
               APTR next;
                              ( ie. Addr of Struct--> $10000 then to get 
                                    the 'next' field' Leek( $10000 + 1 )
                                    which would cause an error )

        }

        struct Pad {

                BYTE x;     --> note: you could have changed BYTE x to WORD x
                BYTE pad;
                APTR next;

        }

        This isn't a problem if you never use bytes... and not really a big
        one even if you do...
        
    

       Also you are responsible for your own garbage collection... so you
       can add your own garbage collection routines or you can be nicer
       on the memory.. for example if your using Linked Lists to store names
       that are say on average 100 chars then you should change your Linked
       list definiton should store maybe 20 chars in one node of the linked
       list instead on one...  Actually depending on the application you
       may not have to worry about this (esp. if your turning multi-tasking
       off )...


       One last point... I wouldn't store the address of a Amos String then
       try to use it again later... because Amos does it's own garbage 
       collection and may change where the string is in memory. instead
       I suggest you copy the string to a safe location in mem (just use
       _ALLOCMEM[] procedure supplied.)       



       I hope this manual is not too bad... If it you can't make sense out this
       manual just check out the Linked List Example... it really isn't very
       hard... see ya later.. mike.

       (remember you can always mail me if you have any questions..)

