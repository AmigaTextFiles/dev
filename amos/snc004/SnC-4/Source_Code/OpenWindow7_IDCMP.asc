' This is a little program that Opens up A window on the WB screen...
' and lets you hit the close gadget to quit... 
' I wrote it just because all the talk with Amos and Intuition, it is
' in no way complete support for windows.. its just a little example.. 
'    
' note: Defines should be handled differently than the way I handled them  
'       ...way inefficient... possibly a look up table could be used or just 
'       have the programmer remember some numbers and or take away some
'       functionality ?? I am not sure.. like I said I was just fooling
'       around... Any suggestions... after we know how we are going to 
'       handle defines and stuff I will write the routines to go through 
'       the includes and convert...
'
' note: You can only open one window with this because I have not added
'       support to remove all memory allocated automatically... but you
'       can remove the memory allocated for the newWindow struct yourself
'       so then you can have anynumber of windows... you can use arrays
'       or linked lists easily to accomplish this. 
'  
'       Also this program is pretty useless... just for example... but 
'       it could be stripped down and then used as an De-Iconify or
'       Amos to Front Button on the WorkBench Screen... just an idea 
'       (better than saying.. oh ya you have to press LAmiga + A do
'        get back to the program...) 
'
'  if you have any questions or whatever you can contact me at:
'  
'                   sikorsky@bode.ee.ualberta.ca 
'
'                   see ya later.... mike. 
'
'     .. oh ya this worked under KS1.3 & KS3.0 .... bye  
'
'************* Private ************* 
'Lvo's:
'
Global _LVOALLOCMEM,_LVOFREEMEM
Global _LVOOPENLIB,_LVOCLOSELIB,_LVOOPENWINDOW,_LVOCLOSEWINDOW
Global _LVOWAIT,_LVOGETMSG,_LVOREPLYMSG
'
'Defines:
'
Global MEMF_ANY,MEMF_PUBLIC,MEMF_CHIP,MEMF_FAST,MEMF_CLEAR

Global NULL
Global SMART_REFRESH,WBENCHSCREEN

Global WFLG_SIZEGADGET,WFLG_DRAGBAR,WFLG_DEPTHGADGET,WFLG_CLOSEGADGET,WFLG_SIZEBRIGHT,WFLG_SIZEBBOTTOM
Global WFLG_REFRESHBITS,WFLG_SMART_REFRESH,WFLG_SIMPLE_REFRESH,WFLG_SUPER_BITMAP,WFLG_OTHER_REFRESH
Global WFLG_BACKDROP,WFLG_REPORTMOUSE,WFLG_GIMMEZEROZERO,WFLG_BORDERLESS,WFLG_ACTIVATE
Global WFLG_RMBTRAP,WFLG_NOCAREREFRESH,WFLG_NW_EXTENDED,WFLG_NEWLOOKMENUS
Global WFLG_WINDOWACTIVE,WFLG_INREQUEST,WFLG_MENUSTATE,WFLG_WINDOWREFRESH,WFLG_WBENCHWINDOW
Global WFLG_WINDOWTICKED,WFLG_VISITOR,WFLG_ZOOMED,WFLG_HASZOOM,_DEFAULTMOUSEQUE

Global IDCMP_CLOSEWINDOW,IDCMP_MOUSEBUTTONS

Global SELECTDOWN
'
'Types:
'
Global WORD,UWORD,BYTE,UBYTE,LONG,ULONG,APTR
'
'System:   
'
Global _NEWWINDOW_STRUCT_SIZE
'
'
'Shared: 
'  _WINDOW_PTR --> _OPEN_WINDOW & _CLOSE_WINDOW
'                  * Needed to de-allocate memory allocated for newwindow struct 
'
'
'
   _LVOALLOCMEM=-198 : _LVOFREEMEM=-210
   _LVOOPENLIB=-552 : _LVOCLOSELIB=-414
   _LVOOPENWINDOW=-204 : _LVOCLOSEWINDOW=-72

   _LVOWAIT=-318 : _LVOGETMSG=-372 : _LVOREPLYMSG=-378

   '/* mem requirements for AllocMem() */'  
   'Add (or OR) them together to get 2 or more options
   MEMF_ANY=0
   MEMF_PUBLIC=1 : Rem ** means mean block can't move once alloced
   MEMF_CHIP=2
   MEMF_FAST=4
   MEMF_CLEAR=65536
   '
   _WINDOW_DEFINES : Rem Set up the Window Defines....

   IDCMP_CLOSEWINDOW=$200
   IDCMP_MOUSEBUTTONS=$8

   SELECTDOWN=$68

   'type sizes in bytes 
   '
   WORD=2 : UWORD=2 : BYTE=1 : UBYTE=1 : LONG=4 : ULONG=4 : APTR=4

'********** Public *********** 

MEM[0]

   Print "--> get ready " : Print " Press the close gadget of Window to Quit..." : Print "Hit a Key"

   Wait Key : Amos To Back 

   '  this will Open a Window That Responds to the "CloseGadget & Mouse Buttons" with Smart Refresh.... 
   '
   _OPEN_WINDOW[150,25,150,100,0,1,IDCMP_CLOSEWINDOW+IDCMP_MOUSEBUTTONS,WFLG_SMART_REFRESH+WFLG_CLOSEGADGET+WFLG_DEPTHGADGET+WFLG_DRAGBAR+WFLG_ACTIVATE+WFLG_SIZEGADGET,NULL,NULL,"Mike's Window",NULL,NULL,150,100,300,200,WBENCHSCREEN]

   WIN=Param : Rem Holds Address of the Window Struct returned (pointer)

   '
_CLOSE_ME=0

While(_CLOSE_ME=0)

   MP_SIGBIT=Peek(Leek(WIN+86)+15) : Rem  Leek(WIN+86) --> Gives the Address of the MsgPort Struct
                                     Rem  Leek(WIN+86)+15 --> Gives the Address of the field mp_SigBit for the MsgPort Struct 
                                     Rem  Peek(Leek(WIN+86)+15) --> gets the mp_SigBit (ie. reads a byte from Address of the field mp_SigBit  

   Print MP_SIGBIT

   SIGNAL=1

   Rol.l MP_SIGBIT,SIGNAL : Rem  1 << window_ptr->UserPort->mp_SigBit

   Print SIGNAL

   Dreg(0)=SIGNAL
   R=Execall(_LVOWAIT) : Rem *** Wait() for a Message *** 
   Print R

   Print "Got the message"

   Areg(0)=Leek(WIN+86) : Rem  window_ptr->UserPort  
   _INTUI_MSG=Execall(_LVOGETMSG) : Rem *** GetMsg() *** 

   While(_INTUI_MSG>0)

      CLASS=Leek(_INTUI_MSG+20)
      CODE=Deek(_INTUI_MSG+24)

      Areg(1)=_INTUI_MSG
      DUMMY=Execall(_LVOREPLYMSG) : Rem *** ReplyMsg() *** 

      If(CLASS=IDCMP_CLOSEWINDOW) : Rem ***Pressed the Close Gadget ***
         _CLOSE_ME=1
      End If 

      If(CLASS=IDCMP_MOUSEBUTTONS)

        If(CODE=SELECTDOWN)
            Print "LMB Pressed"
            Bell 50
        End If 


      End If 

      Areg(0)=Leek(WIN+86) : Rem  window_ptr->UserPort  
      _INTUI_MSG=Execall(_LVOGETMSG) : Rem *** GetMsg() *** 

   Wend 

   'Amos To Front 

   'Wait Key  

Wend 

   _CLOSE_WINDOW[WIN]

   Amos To Front 

MEM[0]

Procedure _WINDOW_DEFINES
'
   NULL=0
   SMART_REFRESH=0
   WBENCHSCREEN=1

'/* --- Flags requested at OpenWindow() time by the application --------- */ 
WFLG_SIZEGADGET=$1 : Rem  /* include sizing system-gadget? */ 
WFLG_DRAGBAR=$2 : Rem /* include dragging system-gadget? */
WFLG_DEPTHGADGET=$4 : Rem /* include depth arrangement gadget? */
WFLG_CLOSEGADGET=$8 : Rem/* include close-box system-gadget? */
WFLG_SIZEBRIGHT=$10 : Rem /* size gadget uses right border */
WFLG_SIZEBBOTTOM=$20 : Rem /* size gadget uses bottom border */ 
'/* --- refresh modes ------------------------------------------------------ */
'/* combinations of the WFLG_REFRESHBITS select the refresh type */
WFLG_REFRESHBITS=$C0
WFLG_SMART_REFRESH=$0
WFLG_SIMPLE_REFRESH=$40
WFLG_SUPER_BITMAP=$80
WFLG_OTHER_REFRESH=$C0
WFLG_BACKDROP=$100 : Rem/* this is a backdrop window */ 
WFLG_REPORTMOUSE=$200 : Rem/* to hear about every mouse move */
WFLG_GIMMEZEROZERO=$400 : Rem/* a GimmeZeroZero window */
WFLG_BORDERLESS=$800 : Rem/* to get a Window sans border */ 
WFLG_ACTIVATE=$1000 : Rem/* when Window opens, it's Active */
'/* --- Other User Flags --------------------------------------------------- */
WFLG_RMBTRAP=$10000 : Rem/* Catch RMB events for your own */ 
WFLG_NOCAREREFRESH=$20000 : Rem/* not to be bothered with REFRESH */ 
'/* - V36 new Flags which the programmer may specify in NewWindow.Flags */ 
WFLG_NW_EXTENDED=$40000 : Rem/* extension data provided */ 
    Rem /* see struct ExtNewWindow */
'/* - V39 new Flags which the programmer may specify in NewWindow.Flags */ 
WFLG_NEWLOOKMENUS=$200000 : Rem/* window has NewLook menus */

'/* These flags are set only by Intuition.  YOU MAY NOT SET THEM YOURSELF! */
WFLG_WINDOWACTIVE=$2000 : Rem/* this window is the active one */ 
WFLG_INREQUEST=$4000 : Rem/* this window is in request mode */
WFLG_MENUSTATE=$8000 : Rem/* Window is active with Menus on */
WFLG_WINDOWREFRESH=$1000000 : Rem /* Window is currently refreshing */ 
WFLG_WBENCHWINDOW=$2000000 : Rem /* WorkBench tool ONLY Window */ 
WFLG_WINDOWTICKED=$4000000 : Rem /* only one timer tick at a time */
'/* V36 and higher flags to be set only by Intuition: */ 
WFLG_VISITOR=$8000000 : Rem/* visitor window  */ 
WFLG_ZOOMED=$10000000 : Rem/* identifies "zoom state" */ 
WFLG_HASZOOM=$20000000 : Rem/* window has a zoom gadget */

'/* --- Other Window Values ---------------------------------------------- */
_DEFAULTMOUSEQUEUE=5 : Rem/* no more mouse messages */



'
End Proc

'****

Procedure _OPEN_LIB[_LIB_NAME$,VER]
'
      _LIB_NAME$=_LIB_NAME$+Chr$(0)
      Dreg(0)=VER
      Areg(1)=Varptr(_LIB_NAME$)
      BASE=Execall(_LVOOPENLIB)
'
End Proc[BASE]
Procedure _CLOSE_LIB[BASE]
'
         Areg(1)=BASE
         _RESULT=Execall(_LVOCLOSELIB)
'
End Proc

'****
'
Procedure _ALLOCMEM[BYTESIZE,REQUIREMENTS]
'
   Dreg(0)=BYTESIZE : Dreg(1)=REQUIREMENTS

   _PTR=Execall(_LVOALLOCMEM)

'
End Proc[_PTR]
Procedure _FREEMEM[MEMORY_PTR,BYTESIZE]
'
   Areg(1)=MEMORY_PTR : Dreg(0)=BYTESIZE

   RESULT=Execall(_LVOFREEMEM)

'
End Proc[RESULT]
'
Procedure _OPEN_WINDOW[__X,__Y,__W,__H,__DPEN,__BPEN,__IDCMPFLAGS,__FLAGS,__FIRSTGAD,__CHECKMARK,__TITLE$,__SCREEN,__BITMAP,__MINW,__MINH,__MAXW,__MAXH,__TYPE]
'
Shared _WINDOW_PTR

   _STRUCT_NEWWINDOW[__X,__Y,__W,__H,__DPEN,__BPEN,__IDCMPFLAGS,__FLAGS,__FIRSTGAD,__CHECKMARK,__TITLE$,__SCREEN,__BITMAP,__MINW,__MINH,__MAXW,__MAXH,__TYPE]

   _WINDOW_PTR=Param

   Areg(0)=_WINDOW_PTR : WIN=Intcall(_LVOOPENWINDOW)


'
End Proc[WIN]
Procedure _CLOSE_WINDOW[WIN]
'
Shared _WINDOW_PTR

   Areg(0)=WIN
   R=Intcall(_LVOCLOSEWINDOW)

   _FREEMEM[_WINDOW_PTR,_NEWWINDOW_STRUCT_SIZE]

'
End Proc[R]
Procedure _STRUCT_NEWWINDOW[__X,__Y,__W,__H,__DPEN,__BPEN,__IDCMPFLAGS,__FLAGS,__FIRSTGAD,__CHECKMARK,__TITLE$,__SCREEN,__BITMAP,__MINW,__MINH,__MAXW,__MAXH,__TYPE]
'
'struct NewWindow
'{ 
'    WORD LeftEdge, TopEdge;  /* screen dimensions of window */
'    WORD Width, Height;   /* screen dimensions of window */ 
'
'    UBYTE DetailPen, BlockPen;  /* for bar/border/gadget rendering */ 
'
'    ULONG IDCMPFlags;   /* User-selected IDCMP flags */ 
'
'    ULONG Flags;   /* see Window struct for defines */
'
'    /* You supply a linked-list of Gadgets for your Window. 
'     * This list DOES NOT include system Gadgets.  You get the standard 
'     * system Window Gadgets by setting flag-bits in the variable Flags (see
'     * the bit definitions under the Window structure definition) 
'     */ 
'    struct Gadget *FirstGadget; 
'
'    /* the CheckMark is a pointer to the imagery that will be used when 
'     * rendering MenuItems of this Window that want to be checkmarked 
'     * if this is equal to NULL, you'll get the default imagery 
'     */ 
'    struct Image *CheckMark;
'
'    UBYTE *Title;     /* the title text for this window */
'
'    /* the Screen pointer is used only if you've defined a CUSTOMSCREEN and 
'     * want this Window to open in it. If so, you pass the address of the 
'     * Custom Screen structure in this variable.  Otherwise, this variable
'     * is ignored and doesn't have to be initialized. 
'     */ 
'    struct Screen *Screen;
'
'    /* WFLG_SUPER_BITMAP Window?  If so, put the address of your BitMap 
'     * structure in this variable.  If not, this variable is ignored and
'     * doesn't have to be initialized 
'     */ 
'    struct BitMap *BitMap;
'
'    /* the values describe the minimum and maximum sizes of your Windows. 
'     * these matter only if you've chosen the WFLG_SIZEGADGET option, 
'     * which means that you want to let the User to change the size of
'     * this Window.  You describe the minimum and maximum sizes that the
'     * Window can grow by setting these variables.  You can initialize
'     * any one these to zero, which will mean that you want to duplicate
'     * the setting for that dimension (if MinWidth == 0, MinWidth will be 
'     * set to the opening Width of the Window). 
'     * You can change these settings later using SetWindowLimits(). 
'     * If you haven't asked for a SIZING Gadget, you don't have to
'     * initialize any of these variables. 
'     */ 
'    WORD MinWidth, MinHeight;     /* minimums */
'    UWORD MaxWidth, MaxHeight;      /* maximums */
'
'    /* the type variable describes the Screen in which you want this Window to
'     * open.  The type value can either be CUSTOMSCREEN or one of the 
'     * system standard Screen Types such as WBENCHSCREEN.  See the
'     * type definitions under the Screen structure. 
'     */ 
'    UWORD Type; 
'
'};
'
   _NEWWINDOW_STRUCT_SIZE=(4*WORD+2*UBYTE+2*ULONG+5*APTR+2*WORD+2*UWORD+UWORD)

   _ALLOCMEM[_NEWWINDOW_STRUCT_SIZE,MEMF_ANY+MEMF_PUBLIC] : _PTR=Param

   If _PTR=0 Then Edit : Rem memexhaust 

   _APTR=_PTR : _TITLE$=_TITLE$+Chr$(0)

'set up struct 

   Add _APTR,0 : Doke _APTR,__X
   Add _APTR,WORD : Doke _APTR,__Y
   Add _APTR,WORD : Doke _APTR,__W
   Add _APTR,WORD : Doke _APTR,__H
   Add _APTR,WORD : Poke _APTR,__DPEN
   Add _APTR,UBYTE : Poke _APTR,__BPEN
   Add _APTR,UBYTE : Loke _APTR,__IDCMPFLAGS
   Add _APTR,ULONG : Loke _APTR,__FLAGS
   Add _APTR,ULONG : Loke _APTR,__FIRSTGAD
   Add _APTR,APTR : Loke _APTR,__CHECKMARK
   Add _APTR,APTR : Loke _APTR,(Varptr(__TITLE$))
   Add _APTR,APTR : Loke _APTR,__SCREEN
   Add _APTR,APTR : Loke _APTR,__BITMAP
   Add _APTR,APTR : Doke _APTR,__MINW
   Add _APTR,WORD : Doke _APTR,__MINH
   Add _APTR,WORD : Doke _APTR,__MAXW
   Add _APTR,WORD : Doke _APTR,__MAXH
   Add _APTR,WORD : Doke _APTR,__TYPE

'
End Proc[_PTR]
'
Procedure MEM[DUMMY]
'
   Print Fast Free+Chip Free

'
End Proc

