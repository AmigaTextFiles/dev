'
' This Demonstrates How to use ADT to make a Linked List...
'
' Format of Linked List: 
'
'    List Info:
'    +------------+
'    | # Nodes =2 |    Node 1:             Node 2: 
'    +------------+    +-------------+    +-------------+
'    | Head PTR ---->  | X | Y | NEXT --->| X | Y | NEXT --> NULL
'    +------------+    +-------------+    +-------------+
'    | Tail PTR -------------------------^ 
'    +------------+
'
'    When you create a new List you get a pointer to the 'List info' 
'    struct Above... 
'
'    This is just a little example of a link list... I stress tested 
'    it with 200,000 nodes... and it worked... 
'
'



'
' AMOS PRO Users Could Have Just DONE This---> 
'        Include "Projects:Amos/ADT/ADT_Include_LIST.AMOS"   
'
' Which is just what I did here except Using Merge.... 
'
'
'************* ADT Global Variable Declaration ************* 
'
'note: These Declarations must be included for any program 
'      using ADT.
'
'Lvo's:
'
   Global _LVOALLOCMEM,_LVOFREEMEM
'
'Defines:
'
   Global MEMF_ANY,MEMF_PUBLIC,MEMF_CHIP,MEMF_FAST,MEMF_CLEAR,NULL
'
'Types:
'
   Global WORD,UWORD,BYTE,UBYTE,LONG,ULONG,APTR
'
'************* ADT Data Type Global Declaration *************  
'
'note:  You Must declare your Data Type Def'n (ie. _LIST_STRUCT(4) ) 
'       Global, and it is Strongly Urged that you declare a Global 
'       Variable that is equal to the Varptr(of you data type def'n) 
'       ie. _LIST_TYPE = Varptr( _LIST_STRUCT(0) ).... It is Also
'       suggested that you make Defines (globals) for accessing the
'       fields inside a structure (data type), this will make it your
'       code more readable/less prone to errors and easier to edit your
'       datatype in the future.
'
' Place Your Definitions here... 
'
'ie. Dim _LIST_STRUCT(4) --> Global _LIST_STRUCT(),_LIST_TYPE,...
'

'
' List Definition... 
'
   Dim _LIST_STRUCT(4)
   Global _LIST_STRUCT(),_LIST_TYPE
   ' Defines for accessing the fields in the structure... 
   Global X_FIELD,Y_FIELD,_NEXT_FIELD

   Dim _LIST_INFO_STRUCT(4)
   Global _LIST_INFO_STRUCT(),_LIST_INFO_TYPE
   Global NUM_NODES_FIELD,HEAD_FIELD,TAIL_FIELD


   _INITIALIZE_ADTS

'
'****************  Abstract Data Type Routines  **************** 
'
' Put your ADT Definitions in here...
'
Procedure _ADT_DEFS
'
' Your ADT Definitions... ie. STRUCT Def's and Global Defs should
' go in here...
'

'
' struct List {        -->  _LIST_STRUCT[0] = Total Struct Size = 2*UWORD + List = 8 bytes 
'                           _LIST_STRUCT[1] = # of Fields = 3
'        UWORD x;           _LIST_STRUCT[2] = Offset to Fist Element   (x)  = 0    
'        UWORD y;           _LIST_STRUCT[3] = Offset to Second Element (y)  = UWORD   = 2    
'        List *next_node;   _LIST_STRUCT[4] = Offset to Third Element(List*)= 2*UWORD = 4  
'
'    } 
'
'    x = Field #1  //  y = Field #2  //  next_node = Field #3  
'
'
   '
   ' Set up the List Struct...  
   '
   _LIST_STRUCT(0)=2*UWORD+APTR
   _LIST_STRUCT(1)=3
   _LIST_STRUCT(2)=0 : Rem         x
   _LIST_STRUCT(3)=UWORD : Rem     y
   _LIST_STRUCT(4)=2*UWORD : Rem   next 

   _LIST_TYPE=Varptr(_LIST_STRUCT(0)) : Rem This Sets the List Type....

   '
   ' this is just a easy way to remeber where the fields are... also good 
   ' incase you change your struct definition...  
   '
   X_FIELD=1 : Y_FIELD=2 : _NEXT_FIELD=3


'
'   struct List_Info {       -->  _LIST_INFO_STRUCT(0) = UWORD + 2*APTR = 10 bytes 
'                                 _LIST_INFO_STRUCT(1) = 3 
'         UWORD # of nodes;       _LIST_INFO_STRUCT(2) = 0 
'         List *head_of_list;     _LIST_INFO_STRUCT(3) = UWORD = 2 
'         List *tail_of_list;     _LIST_INFO_STRUCT(4) = UWORD + APTR = 6
'
'    } 
'

   'set up the struct...

    _LIST_INFO_STRUCT(0)=UWORD+2*APTR
    _LIST_INFO_STRUCT(1)=3
    _LIST_INFO_STRUCT(2)=0
    _LIST_INFO_STRUCT(3)=UWORD
    _LIST_INFO_STRUCT(4)=UWORD+APTR

    _LIST_INFO_TYPE=Varptr(_LIST_INFO_STRUCT(0))

    NUM_NODES_FIELD=1 : HEAD_FIELD=2 : TAIL_FIELD=3

'
'
End Proc
'
' These Are the Routines that you are to use to work with  
' structures...
'
Procedure _CREATE[_DATA_TYPE,_MEMORY_TYPE]
'
'  Description:  Will Allocate the Mem Needed for a new instance   
'                of a Data Type. 
'
'  Parameters:   _DATA_TYPE = Must Be a Pointer to A Data Type 
'                             Definition.  eg. if your data type 
'                             definition (you know the Array) is 
'                             _LIST_ADT() then you would pass  
'                             Varptr(_LIST_ADT(0)) into the _DATA_TYPE 
'                             parameter.  When Making a new Data Type  
'                             you should always create a new global that 
'                             equals this and ends with _TYPE.  For example  
'                             Global _LIST_TYPE : _LIST_TYPE=Varptr(_LIST_ADT(0))  
'
'              _MEMORY_TYPE = This should be equal to the type of memory that
'                             should be allocated for this DataType... see the 
'                             MEMF_* globals.. note: multiple selections are 
'                             made by ORing or Adding Flags togther for  
'                             example to use CHIP memory and have it cleared 
'                             (to 0's) you would use: MEMF_CHIP+MEMF_CLEAR.  
'
'  Returns:    _PTR = this will point to newly allocated block of memory 
'                     (will equal NULL ie. 0 on Error... meaning there is
'                      not enough memory to meet your request )
'
'  Side Effects: Memory is allocated... it must be Freed By you... using 
'                _FREEMEM[]... 
'
'  
    _ALLOCMEM[Leek(_DATA_TYPE),_MEMORY_TYPE]

    _PTR=Param

'
End Proc[_PTR]
Procedure _DESTROY[_DATA_TYPE,_PTR]
'
' basically just a wrapper for _FREEMEM[]
'

   _FREEMEM[_PTR,Leek(_DATA_TYPE)]

'
End Proc
Procedure _SET_FIELD[_DATA_TYPE,_PTR,_FIELD,_VAL]
'
'  Description:  This will set a field inside a data type.  For example
'                if you had a Linked list type then: 
'                   _SET_FIELD[_LIST_TYPE,list,X_FIELD,20]  --> list->x = 20 
'                As you can see you must also specify what data type 
'                you are using so that it knows how to use the generic or
'                void _PTR... it is Strongly Suggested that when creating a
'                new Data Type you define this Function for that data type 
'                see Example Linked List Datatype --> "_SET_LIST_FIELD"
'
'  Parameters:   _DATA_TYPE = see _CREATE[]
'                _PTR       = pointer to the instance of your data type..
'                             (returned form _CREATE[])
'                _FIELD     = the Field that you are accesing in the structure 
'                             or data type... they are counted in order of 
'                             appearance starting from 1.
'                _VAL       = the value you are setting the field to equal to. 
'
'  Returns:      nothing.
'
'
   If(_DATA_TYPE<>0 and _PTR<>0)

      _SIZE_OF_FIELD[_DATA_TYPE,_FIELD] : _OFFSET_TO_FIELD=Leek(_DATA_TYPE+(_FIELD+1)*4)

      If Param=BYTE
                              Poke _PTR+_OFFSET_TO_FIELD,_VAL
      Else 
            If Param=WORD
                              Doke _PTR+_OFFSET_TO_FIELD,_VAL
            Else 

               If Param=APTR
                              Loke _PTR+_OFFSET_TO_FIELD,_VAL
               End If 

            End If 

      End If 

   End If 
'
End Proc
Procedure _GET_FIELD[_DATA_TYPE,_PTR,_FIELD]
'
'  Description:  This will get a field inside a data type.  For example
'                if you had a Linked list type then: 
'                   _GET_FIELD[_LIST_TYPE,list,X_FIELD]  --> val = list->x   
'                As you can see you must also specify what data type 
'                you are using so that it knows how to use the generic or
'                void _PTR... it is Strongly Suggested that when creating a
'                new Data Type you define this Function for that data type 
'                see Example Linked List Datatype --> "_GET_LIST_FIELD"
'
'  Parameters:   _DATA_TYPE = see _CREATE[]
'                _PTR       = pointer to the instance of your data type..
'                             (returned form _CREATE[])
'                _FIELD     = the Field that you are accesing in the structure 
'                             or data type... they are counted in order of 
'                             appearance starting from 1.
'
'
'  Returns:      _VAL       = the value you are getting..  
'
'
   If(_DATA_TYPE<>0 and _PTR<>0)

      _SIZE_OF_FIELD[_DATA_TYPE,_FIELD] : _OFFSET_TO_FIELD=Leek(_DATA_TYPE+(_FIELD+1)*4)

      If Param=BYTE
                              _VAL=Peek(_PTR+_OFFSET_TO_FIELD)
      Else 
            If Param=WORD
                              _VAL=Deek(_PTR+_OFFSET_TO_FIELD)
            Else 

               If Param=APTR
                              _VAL=Leek(_PTR+_OFFSET_TO_FIELD)
               End If 

            End If 

      End If 

   End If 
'
End Proc[_VAL]
'
' Below Are Routines that Are Used by the ADT Procedures...
'
Procedure _INITIALIZE_ADTS
'
'  This will Set Up and Intialize Everything to do with the ADT... 
'
   ' This Procedure Initializes all The ADT Global Variable Declaration 
   ' vars...  
   _LVOS_AND_DEFINES

   ' This Procedure is Where you Should Put your Data Type Def's... 
   _ADT_DEFS

'
End Proc
Procedure _LVOS_AND_DEFINES
'
' Set Up the Globals...
'

   _LVOALLOCMEM=-198 : _LVOFREEMEM=-210
   _LVOOPENLIB=-552 : _LVOCLOSELIB=-414

   '/* mem requirements for AllocMem() */'  
   'Add (or OR) them together to get 2 or more options
   MEMF_ANY=0
   MEMF_PUBLIC=1 : Rem ** means mean block can't move once alloced
   MEMF_CHIP=2
   MEMF_FAST=4
   MEMF_CLEAR=65536
   '
   'type sizes in bytes 
   '
   WORD=2 : UWORD=2 : BYTE=1 : UBYTE=1 : LONG=4 : ULONG=4 : APTR=4 : NULL=0
'
End Proc
Procedure _SIZE_OF_FIELD[_DATA_TYPE,_FIELD]
'
'  Figures out the Size of a Data Filed... 1,2,or4 bytes.... 
'
'  NOTE: _FIELD + 1 = to the spot in the list struct where the offset
'                     for this field is stored.. ie: spots 0 & 1 are used
'                     for control info.. so FIELD #1 is actually the 2nd 
'                     Element in the Struct Array. 
'
'
'  _DATA_TYPE --> points to Structure Array Definition... eg. _LIST_STRUCT 
'  
'                  this makes it a generic routine that will work for any
'                  data structure....
'

  'if(_field<> the last field in the struct )
   If(_FIELD<>Leek(_DATA_TYPE+1*4))

      'size = (the offset of the next field) - (the offset to current field) 
       _SIZE=Leek(_DATA_TYPE+((_FIELD+1)+1)*4)-Leek(_DATA_TYPE+(_FIELD+1)*4)

   Else 

      'size = (the total size of the struct) - (the offset to current field) 
      _SIZE=Leek(_DATA_TYPE+0*4)-Leek(_DATA_TYPE+(_FIELD+1)*4)

   End If 

'
End Proc[_SIZE]
Procedure _ALLOCMEM[BYTESIZE,REQUIREMENTS]
'
   Dreg(0)=BYTESIZE : Dreg(1)=REQUIREMENTS

   _PTR=Execall(_LVOALLOCMEM)

'
End Proc[_PTR]
Procedure _FREEMEM[MEMORY_PTR,BYTESIZE]
'
   Areg(1)=MEMORY_PTR : Dreg(0)=BYTESIZE

   RESULT=Execall(_LVOFREEMEM)

'
End Proc[RESULT]
'
'*******************  End of ADT Include File ********************** 



   Print "Free Mem:"+Str$(Fast Free+Chip Free)

   '
   'this Creates an Instance of the List type.... 
   '  
   _CREATE_LIST : LIST=Param

   For I=1 To 7
       _ADD_TAIL[LIST,I,I*I]
   Next 

   For I=8 To 15
       _ADD_HEAD[LIST,I,I*I]
   Next 

   _PRINT_LIST[LIST]

   _CREATE_LIST : LIST2=Param

   For I=1 To 4
       _ADD_TAIL[LIST2,I,I*2]
   Next 

   _PRINT_LIST[LIST2]

   _FREE_LIST[LIST2]

   _FREE_LIST[LIST]

   Print "Free Mem:"+Str$(Fast Free+Chip Free)





'
'**********************  List Abstract Data Type  ********************** 
'
' Public: these FCNs are what the user of the ADT should only Call.. 
'         _CREATE_LIST --> the list constructor
'         _ADD_TAIL    --> add to end of the list
'         _ADD_HEAD    --> add to start of the list
'         _GET_NODES   --> will return the # of nodes in the List
'         _PRINT_LIST  --> will print the list 
'         _FREE_LIST   --> destructor for the list 
'
' Private: These fcns are only supposed to be used in the Public Fcns
'          (ie. the creator of the ADT uses these) 
'         _CREATE_LIST_NODE -->  Creates an instance of a list node..  
'         _SET_LIST_FIELD   -->  Sets a field in a list node 
'         _GET_LIST_FIELD   -->  gets a field in a list node 
'
'
' Public 
'
Procedure _CREATE_LIST
'
' This Creates A list info structure... Which is are List ADT... 
'
'  We are using Fast Ram and Having it cleared for us... Because 
'  it is being cleared for us we don't have to initialize the  
'  the fields in the structure to NULL... especially useful when 
'  you have pointers in your structures. 
'
'
   _CREATE[_LIST_INFO_TYPE,MEMF_FAST+MEMF_CLEAR]
   _PTR=Param
'
End Proc[_PTR]
Procedure _ADD_TAIL[_PTR,X,Y]
'
' this will add a new node to the end of the list... 
'
'
   If _PTR=0 Then Pop Proc : Rem Some Kinda Error...

   _CREATE_LIST_NODE : _NEW_NODE=Param

   If _NEW_NODE=NULL Then Pop Proc : Rem Should have some kinda error...

   _SET_LIST_FIELD[_NEW_NODE,X_FIELD,X] : Rem new_list_node->x = x   
   _SET_LIST_FIELD[_NEW_NODE,Y_FIELD,Y] : Rem new_list_node->y = y 
   _SET_LIST_FIELD[_NEW_NODE,_NEXT_FIELD,NULL] : Rem new_list_node->next = NULL (you don't need to do this if you use the MEMF_CLEAR Flag...) 

   _GET_FIELD[_LIST_INFO_TYPE,_PTR,TAIL_FIELD] : _TAIL_PTR=Param

   If _TAIL_PTR=NULL
      ' okay this means that there are no nodes yet in the list... 

      ' list_info -> tail = new node created 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,TAIL_FIELD,_NEW_NODE]

      ' list_info -> head = new node created... tail and head both 
      ' point to the same spot because there is only one node in the 
      ' list know... 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD,_NEW_NODE]

       ' list_info -> num_nodes = 1 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD,1]

   Else 
      'okay this means that we already have guys in the list...

      ' tail -> next = new node created  
        _SET_LIST_FIELD[_TAIL_PTR,_NEXT_FIELD,_NEW_NODE]

      ' now We update the List Info Structure... 
      ' list_info -> tail = new node created 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,TAIL_FIELD,_NEW_NODE]

      ' we leave the Head ptr alone but we have to update the # of Nodes.. 

      ' list_info -> num_nodes ++
        _GET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD]
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD,Param+1]

   End If 

'
End Proc
Procedure _ADD_HEAD[_PTR,X,Y]
'
'  Will Add to the Head of a List... 
'
'
'
   If _PTR=0 Then Pop Proc : Rem Error... 

   _CREATE_LIST_NODE : _NEW_NODE=Param

   If _NEW_NODE=NULL Then Pop Proc : Rem Should have some kinda error...

   _SET_LIST_FIELD[_NEW_NODE,X_FIELD,X] : Rem new_list_node->x = x   

   _SET_LIST_FIELD[_NEW_NODE,Y_FIELD,Y] : Rem new_list_node->y = y 

   _GET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD] : _HEAD_PTR=Param

   If _HEAD_PTR=NULL
      ' okay this means that there are no nodes yet in the list... 

      ' list_info -> head = new node created 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD,_NEW_NODE]

      ' list_info -> head = new node created... tail and head both 
      ' point to the same spot because there is only one node in the 
      ' list know... 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,TAIL_FIELD,_NEW_NODE]

       ' list_info -> num_nodes = 1 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD,1]

   Else 
      'okay this means that we already have guys in the list...

      ' new node created -> next = old head of list
        _SET_LIST_FIELD[_NEW_NODE,_NEXT_FIELD,_HEAD_PTR]

      ' now We update the List Info Structure... 
      ' list_info -> head = new node created 
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD,_NEW_NODE]

      ' we leave the Head ptr alone but we have to update the # of Nodes.. 

      ' list_info -> num_nodes ++
        _GET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD]
        _SET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD,Param+1]

   End If 

'
End Proc
Procedure _GET_NODES[_PTR]
'
' Just Makes Getting the Number Of Nodes nicer...  If you look for 
' example in _ADD_TAIL[] you see that I didn't use this Procedure... 
' Why?  Just to do it a different way... To make a nice ADT you can
' supply procedures Like this for most of the fields... for example
' I should a _SET_NODES[]/_(GET|SET)_HEAD[]/_(GET|SET)_TAIL[]... etc...
'
'
         _GET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD]

'
End Proc[Param]
Procedure _PRINT_LIST[_PTR]
'
' _PTR points to a List Info Structure... so we must get the Start or
' head of the List...
'

   If _PTR=NULL Then Pop Proc

   ' get number of nodes....
   _GET_FIELD[_LIST_INFO_TYPE,_PTR,NUM_NODES_FIELD] : Print "Num Nodes:"+Str$(Param)

   '
   ' get the head pointer...
   '
   _GET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD] : _PTR=Param

   ' Now _PTR points to the head of the list

   While(_PTR<>NULL)
         _GET_LIST_FIELD[_PTR,X_FIELD] : Print "X:"+Str$(Param)+" ";
         _GET_LIST_FIELD[_PTR,Y_FIELD] : Print "Y:"+Str$(Param)+" "
         _GET_LIST_FIELD[_PTR,_NEXT_FIELD]
         _PTR=Param
   Wend 

'
'
End Proc
Procedure _FREE_LIST[_PTR]
'
' This Frees up the memory for the List... 
'
'
'    NON Recursive Version:
'
        If _PTR=0 Then Pop Proc

        _LIST_INFO_PTR=_PTR

        _GET_FIELD[_LIST_INFO_TYPE,_PTR,HEAD_FIELD] : _PTR=Param
        ' Now _PTR points to the head of the list

        If _PTR=0 Then Pop Proc

        _GET_LIST_FIELD[_PTR,_NEXT_FIELD] : _NEXT_PTR=Param

        '_FREEMEM[_PTR,_LIST_STRUCT(0)]

         _DESTROY[_LIST_TYPE,_PTR]

        While(_NEXT_PTR<>NULL)

               _OLD_PTR=_NEXT_PTR
               _GET_LIST_FIELD[_NEXT_PTR,_NEXT_FIELD] : _NEXT_PTR=Param
               '_FREEMEM[_OLD_PTR,_LIST_STRUCT(0)]
               _DESTROY[_LIST_TYPE,_OLD_PTR]

        Wend 

        ' now you have to free up the memory associated w/the list info structure

        '_FREEMEM[_LIST_INFO_PTR,_LIST_INFO_STRUCT(0)] 

         _DESTROY[_LIST_INFO_TYPE,_LIST_INFO_PTR]

'
End Proc
'
' Private
'
Procedure _CREATE_LIST_NODE
'
' Just Squirt some new mem for a list.... for the list were are
' using fast memory and we are having it cleared to 0's for us, how nice.  
'
   _CREATE[_LIST_TYPE,MEMF_ANY+MEMF_FAST+MEMF_CLEAR]
   _PTR=Param
'
End Proc[_PTR]
Procedure _SET_LIST_FIELD[_PTR,_FIELD,_VAL]
'
' Specialized to Set a field in the data structure for Lists...
'
' Just makes it so you don't have to add '_LIST_TYPE' every time...
'
'
   _SET_FIELD[_LIST_TYPE,_PTR,_FIELD,_VAL]
'
End Proc
Procedure _GET_LIST_FIELD[_PTR,_FIELD]
'
'  Just Makes it So you don't have to put '_LIST_TYPE' everytime...  
'  improves readability... at least to me... 
'
    _GET_FIELD[_LIST_TYPE,_PTR,_FIELD] : _VAL=Param
'
End Proc[_VAL]
'
'*********************************************************************** 
