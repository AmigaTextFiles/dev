@database Intuition System.guide @Author CIERP Philippe ©1995-98
@Version 2.0

@node Sys0 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MEMABS=Alloc Abs(SIZE,LOCATE)@{fg text}

    Entrée: SIZE=Taille du segment mémoire.
            LOCATE=Adresse du segment

    Sortie: MEMABS=True ou false.

Alloue un block de mémoire absolue, cette commande et extremement dangeureuse
pour le system, car si vous alloué un block deja utiliser vous risquez un
bloquage du system...

@endnode
@node Sys1 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MEMSIZE=Alloc Mem(SIZE,MEMTYPE)@{fg text}

    Entrée: SIZE=Taille du segment mémoire.
            MEMTYPE= > @{" Public   " link "Documentation/MemFlags.guide/M0"}
                     > @{" Chip     " link "Documentation/MemFlags.guide/M1"}
                     > @{" Fast     " link "Documentation/MemFlags.guide/M2"}
                     > @{" Local    " link "Documentation/MemFlags.guide/M3"}
                     > @{" 24BitDMA " link "Documentation/MemFlags.guide/M4"}
                     > @{" Clear    " link "Documentation/MemFlags.guide/M7"}

    Sortie: MEMSIZE=Adresse du segment alloué ou 0

Alloue un block de mémoire, en demandant au system de le faire, c'est >LA<
methode a utiliser car le system vous donneras un block non utiliser et vous
le reserveras pour vous.

Attention a ne pas oublier de liberer le block des que vous en avez plus besoin
avec la commande @{" Free Mem " link "sys4"}

@endnode
@node Sys2 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}SIZE=Avail Mem (MEMTYPE)@{fg text}

    Entrée: MEMTYPE= > @{" Public   " link "Documentation/MemFlags.guide/M0"}
                     > @{" Chip     " link "Documentation/MemFlags.guide/M1"}
                     > @{" Fast     " link "Documentation/MemFlags.guide/M2"}
                     > @{" Local    " link "Documentation/MemFlags.guide/M3"}
                     > @{" 24BitDMA " link "Documentation/MemFlags.guide/M4"}
                     > @{" Clear    " link "Documentation/MemFlags.guide/M7"}

    Sortie: SIZE=Taille de la mémoire libre

Permet de connaitre la mémoire libre dans chaque type de mémoire.

Ex:
' taille de la mémoire chip.
C=Avail Mem(Mchip)
Print "Chip:";C

' taille de la mémoire chip et de la mémoire fast.
C=Avail Mem(Mchip+Mfast)
Print "Chip+Fast:";C

@endnode
@node Sys3 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Copy Mem STAR,SIZE To DEST@{fg text}

    Entrée: STAR=Début de la mémoire à copier
            SIZE=Taille du segment mémoire
            DEST=Destination du segment

  Remarque: Plus rapide que la commande 'Copy' d'Amos & APro
            version optimisée de 'Copy Mem'.

Copy un block de mémoire d'un endroit a un autre, la difference essentiel avec
la commande Copy d'Amos c'est qu'il suffit de donner la taille réelle du block
de mémoire et non pas la position de fin du block.

Ex:
' Copy un block de la Bnk 1 a la Bnk 2
Reserve as Work 1,500
Reserve as Work 2,500
' IntuiExtend version
Copy Mem Start(1),Length(1) To Start(2)
' Amos Version
Copy Start(1),Start(1)+Length(1) To start(2)

@endnode
@node Sys4 " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}Free Mem START,LEN@{fg text}

    Entrée: START=Adresse de départ de la mémoire à libérer.
            LEN=Longueur de la mémoire à libérer.

  Remarque: Cette fonction utilise la librairie Exec, seule une zone
            mémoire allouée avec la fonction AllocMem, doit être libérée.

@endnode
@node Sys5 " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Write Mem(START,LEN To NAME$)@{fg text}

    Entrée: START=Adresse de départ du segment mémoire
            LEN=Longueur du segment
            NAME$=Nom de sortie (ou du fichier à créer).

    Sortie: RESULT=True si Ok, ou False.

  Remarque: Sortie possible sur Ptr: Con: Raw: ou un fichier

Ecrit un block de mémoire dans un fichier (réel ou virtuel).

Ex:
' Sauvegarde du kickstart dans le Ram Disk

@endnode
@node Sys6 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg (WINDOW)@{fg text}

    Entrée: WINDOW=Adresse de la fenêtre.

    Sortie: MSG=Message reçu par intuition.
          @{" Liste des code IDCMP " link "IDCMP.guide/CodeIDCMP"}

Pour fonctionner une fenetre a besoin d'avoir un relaie entre l'utilisateur
et le system, pour cela chaque 'objet' dans intuition a un 'MsgPort' une
sorte de boite à lettre dans laquelle Intuition va placer les message en
fonction de ce qui a ete fait par l'utilisateur, un clic par-ci, deplacer une
fenetre, appuye sur un bouton, etc...

Le prg à besoin de savoir se que fait l'utilisateur dans l'interface, Get Msg
attend les messages et les retourne au prg au fur et a mesure, les messages
pouvant etre interceptés depende des @{" codes IDCMP " link "IDCMP.guide/CodeIDCMP"} données à
la fenetre.

Attention: Si vous limiter les codes, Get Msg attendras un message et votre programme
risque de se trouvé bloqué, Get Msg attendant un message pour eviter de bloquer
votre programme, incluer le code IntuiTicks ($400000) au code IDCMP de votre fenetre.

@endnode
@node Sys7 " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Code@{fg text}

    Sortie: MSG=Code du message reçu @{" Get Msg " link Sys6}.

Retourne le Code du dernier message fournie par @{" Get Msg " link Sys6}
comme le n° du Menu selectionné.

Description des groupes de code:

Msg CHANGEWINDOW
MOVESIZE=0 -La fenetre a ete deplacé ou retaillé
   DEPTH=1 -la fenetre a changé sa profondeur (Depth Gadget), 3.0+ seulement

@endnode
@node Sys8 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Iadr@{fg text}

    Sortie: MSG=Adresse de l'objet

  Remarque: Retourne l'adresse de l'objet sélectionné
            (écran,Fenêtre,gadget ect...).

Retourne l'adresse de l'objet qui a produit le dernier message fournie
par @{" Get Msg " link Sys6}, comme l'adresse d'un gadget apres un click
ou l'adresse d'un écran.

@endnode
@node Sys9 " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Qualifier@{fg text}

    Sortie: MSG=Code qualifieur

    Voir @{" Get Msg " link Sys6}.

@endnode
@node Sysa " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Xm@{fg text}

    Sortie: MSG=Coord XMouse

Retourne la position horizontale de la sourie lors du dernier méssage.

@endnode
@node Sysb " Date: 30/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Get Msg Ym@{fg text}

    Sortie: MSG=Coord YMouse

Retourne la position verticale de la sourie lors du dernier méssage.

@endnode
@node Sysc " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Load Seg FILENAME$@{fg text}

    Entrée: FILENAME$=Nom+Chemin du fichier (IL DOIT IMPERATIVEMENT
            SE TERMINER PAR UN ZERO...), ex: f$="C:Avail"+Chr$(0).

  Remarque: Charge un éxécutable et décompose ses segments de code.

@endnode
@node Sysd " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}TASK=My Task@{fg text}

    Sortie: TASK=Ptr sur la tâche propre du programme.

@endnode
@node Syse " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}SEGMENT=Segment Base@{fg text}

    Sortie: SEGMENT=Pointeur sur la liste des segments du dernier
            fichier chargé avec 'Load Seg' ou -1 si Erreur.

  Remarque: Pour plus de renseignement voir 'La bible de l'Amiga'.

@endnode
@node Sysf " Date: 18/03/95                                       System: v1.3+"

Synoptique: @{fg shine}OLDTASK=Set Taskpri (TASK,PRI)@{fg text}

    Entrée: TASK=Adresse de la tâche.
            PRI=N° de priorité (Entre -127 et +128)

    Sortie: OLDTASK=N° de L'ancienne priorité.

Change la priorité du programme a l'adresse TASK, utiliser @{"My Task " link sysd} pour
connaitre l'adresse de votre programme.

Attention: Une valeur trop haute bloque Intuition et une valeur superieure a 18 peu
empeché l'utilisation du clavier...

@endnode
@node Sysg " Date: 14/05/95                                       System: v1.3+"

Synoptique: @{fg shine}Task Name NAME$ To TASKPTR@{fg text}

    Entrée: NAME$=Nouveau nom pour la tâche ou le
                  process.
            TASKPTR=Adresse d'une tâche (ou Process.)

Cette commande combine avec @{"My Task " link sysd} vous permet de
personnaliser le nom de votre programme dans la TaskList d'Exec.

This for the fun... :)

@endnode
@node Sysh " Date: 12/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Unload Seg SEGMENT@{fg text}

    Entrée: SEGMENT=Pointeur sur la liste des segments de code.

  Remarque: Le pointeur est du type BPTR, pour obtenir l'adresse des
            segments, 'Segment Base' doit être multiplié par 4
            Structure des segments de code:
            Segment Base -> Longueur Segment
                            Ptr Segment suivant ou 0
                            Début du code du segment

@endnode
@node Sysi " Date: 22/06/95                                       System: v1.3+"

Synoptique: @{fg shine}DATE$=Wb Date@{fg text}

    Sortie: Date actuelle sous le format 'JJ/MM/AAAA'.

@endnode
@node Sysj " Date: 18/05/95                                       System: v1.3+"

Synoptique: @{fg shine}SUCESS=Wb Display Alert(HEIGHT,MSG$)@{fg text}

    Entrée: HEIGHT=Hauteur en pixel du cadre d'alerte
            MSG$=Message à afficher

     Format pour le Message:
     Pour des raisons qui me sont toujours inconnues (je ne suis
     pas biologiste...), au lieu d'un simple message en Ascii,
     les Ba'b, concepteur de l'Amiga ont sortis un format dont vous
     pourrez en trouver un exemple dans le programme 'DisplayAlert.amos'
     mais pour l'heure voici le format:

     Msg0$=Chr$(0)+Chr$(X0)+chr$(Y)+'Message1...'+Chr$(0)
     Msg0$=Msg0$+Chr$(1)+Chr$(MulX)+Chr$(X1)+'$Message2..'+Chr$(0)

     Notez le signe '$' sur le message 2, en fait la 1ère lettre
     du second message est gnackée!!!, donc si on veut que tout le
     message soit affiché il faut lui donner autre chose à gnack...

    Sortie: SUCCESS=0 Bouton Gauche et 1 Bouton Droit.

@endnode
@node Sysk " Date: 26/03/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Display Beep WIND/SCREEN@{fg text}

    Entrée: WIND/SCREEN=Adresse de l'écran ou de la
            fenêtre à faire clignoter.

@endnode
@node Sysl " Date: 06/04/95                                       System: v1.3+"

Synoptique: @{fg shine}MKEY=Hard Mouse Key@{fg text}

    Sortie: Port A: Bouton Gauche=1
                    Bouton Droit =2
                    Bouton Milieu=4
            Port B: Bouton Gauche=8
                    Bouton Droit =16
                    Bouton Milieu=32

  Remarque: FALSE (0) si pas de bouton pressé

Attention: Les valeur retournées sont au format Bits, plusieurs teste permettent
de connaitre les boutons utilisés.

Ex: Verifie seulement si le bouton Gauche Port 1 est pressé

'Forme 1
BOUT=Hard Mouse Key And 1

'Forme 2
BOUT=Btst(0,Hard Mouse Key)

@endnode
@node Sysm " Date: 24/01/95                                       System: v1.3+"

Synoptique: @{fg shine}Wb Reset@{fg text}

  Remarque: Warm Reset officiel d'après Commodore (CBM).

Si vous executer cette commande l'Amiga fera un Reset a chaud...

@endnode
@node Sysn " Date: 19/06/95                                       System: v1.3+"

Synoptique: @{fg shine}HEURE$=Wb Swatch@{fg text}

    Sortie: HEURE$=Chaîne sous le format 'HH:MM:SS'.

@endnode
@node Sysp " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}SUCCES=Wb Close@{fg text}

    Sortie: SUCCES=True ou False

  Remarque: Ferme le Workbench si rien ne l'en empeche...

@endnode
@node Sysq " Date: 26/02/95                                       System: v1.3+"

Synoptique: @{fg shine}WBPTR=Wb Open@{fg text}

    Sortie: WBPTR=Pointeur sur l'écran du Workbench si Ok.

  Remarque: Ouvre le Workbench.

Permet d'ouvrir et de connaitre l'adresse de l'écran du Wb.

@endnode
@node Sysr " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=Sys Agnus@{fg text}

    Sortie: TYPE= 0 - Agnus PAL
                 16 - Agnus NTSC
                 32 - Fat Agnus PAL
                 35 - ???
                 48 - Fat Agnus NTSC
                 53 - AA Alice PAL
                 ?? - AA Alice NTSC

@endnode
@node Syss " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}CHIPSET=Sys Chip@{fg text}

    Sortie: CHIPSET= 0 - Denise Wb1.2
                     8 - AA Lisa
                    12 - Denise ECS
                    15 - Denise Wb 1.3

  Remarque: Teste le type du ChipSet installé dans une machine.

@endnode
@node Syst " Date: 01/02/96                                       System: v1.3+"

Synoptique: @{fg shine}RESULT=Sys Kickstart(VERSION)@{fg text}

     Entré: VERSION=Version de la ROM à tester.

    Sortie: RESULT=-1 Si VERSION > que la version de la ROM.
                  = 0 Si VERSION = que la version de la ROM.
                  = 1 Si VERSION < que la version de la ROM.

  Remarque: Les versions existantes sont:
            40 > ROM 3.1 (CD32...)
            39 > ROM 3.0 (1200/4000)
            38 > ROM 2.1 (Version soft-3000/2000/600/500+)
            37 > ROM 2.0 (3000/2000/600/500+)
            36 > ROM 1.3 (2000/500/1000)
            35 > ROM 1.2 (500/1000)

@endnode

@node Sysu " Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}PORTADR=Wb Create Msgport@{fg text}

    Sortie: PORTADR=Adresse du nouveau port de message.

    Voir: @{" Wb Erase Msgport " link SysV}

@endnode
@node Sysv " Date: 22/04/96                                       System: v2.0+"

Synoptique: @{fg shine}Wb Erase Msgport PORTADR@{fg text}

     Entré: PORTADR=Adresse du message-port.

     Voir: @{" Wb Create Msgport " link SysU}

@endnode
@node Sysw " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}MSG=Wb Get Msg(MSGPORT)@{fg text}

     Entré: MSGPORT=Adresse du port-message.

    Sortie: MSG=Code du message reçu.
            >0 Message

Attention: A ne pas confondre 'Get Msg', avec cette commande, 'Get Msg'
           demande l'adresse d'une fenetre, alors que cette commande demande
           un port de message...

@endnode
@node Sysx " Date: 22/04/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Reply Msg@{fg text}

  Remarque: Cette fonction prévient le systéme que le message a
            été reçu, ce qui permet d'en recevoir d'autre.

     Voir: @{" Wb Create Msgport " link SysU}

@endnode

@node Sysy " Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Mouse Off@{fg text}

  Remarque: Desactive le sprite de la sourie sur l'ecran actif.

@endnode
@node Sysz " Date: 20/05/96                                       System: v1.3+"

Synoptique: @{fg shine}Wb Mouse On@{fg text}

  Remarque: Reactive le sprite de la sourie sur l'ecran actif.

@endnode
@node Sys10 " Date: 30/05/96                                       System: v1.3+"

Synoptique: @{fg shine}CPU=Sys Cpu@{fg text}

    Sortie: CPU=N° du Processeur principal (40, 30, 20, 10 ou 0).

  Remarque: Retourne le type de MicroProcesseur.

Ex:
Print "CPU Type:";68000+Sys CPU

@endnode
@node Sys11 " Date: 30/05/96                                       System: v1.3+"

Synoptique: @{fg shine}TYPE=Sys Math@{fg text}

    Sortie: TYPE=N° du type de coprocesseur arithmétique (881 ou 882).

Ex:
MATH=68000+Sys Math
If MATH=68000
   Print "Math Type: None"
Else
   Print "Math Type:";MATH
End If

@endnode

@node SysSc " Date: 20/12/98                                       System: v1.3+"

Synoptique: @{fg shine}SC=Get Msg Scancode@{fg text}

    Sortie: SC=Scancode de la toucche pressé.

Renvoie le Scan Code de la touche pressé par l'utilisateur, cette commande
fonction apres avoir recue par 'Get Msg' le code IDCMP 'RawKey/$400'.

@endnode
