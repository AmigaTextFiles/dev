## version
## language
## codeset 0
;=========================================================================
;     $RCSfile: ErrorMessages.ct $
;  Description: Catalog description file for compiler error messages
;
;   Created by: ferr (Johan Ferreira)
;    $Revision: 1.2 $
;      $Author: fjc $
;        $Date: 1995/07/02 16:55:48 $
;=========================================================================
;
;
;A. Incorrect use of language Oberon
;
msgErr0

;Undeclared identifier
msgErr1

;Multiply defined identifier
msgErr2

;Illegal character in number
msgErr3

;Illegal character in string
msgErr4

;Identifier does not match procedure name
msgErr5

;Comment not closed
msgErr9

;"=" expected
msgErr10

;Identifier expected
msgErr12

;Type definition starts with incorrect symbol
msgErr13

;Factor starts with incorrect symbol
msgErr14

;Statement starts with incorrect symbol
msgErr15

;Declaration followed by incorrect symbol
msgErr16

;MODULE expected
msgErr17

;Integer constant expected
msgErr18

;"." missing
msgErr19

;"," missing
msgErr20

;":" missing
msgErr22

;")" missing
msgErr23

;"]" missing
msgErr24

;"}" missing
msgErr25

;OF missing
msgErr26

;THEN missing
msgErr27

;DO missing
msgErr28

;TO missing
msgErr29

;"(" missing
msgErr33

;":=" missing
msgErr34

;"," or OF expected
msgErr38

;";" missing
msgErr40

;END missing
msgErr43

;UNTIL missing
msgErr45

;EXIT not within loop statement
msgErr46

;Object must be global
msgErr47

;Illegally marked identifier
msgErr48

;Forward declared pointer unsatisfied
msgErr49

;Attempting to import self
msgErr50

;Expression should be constant
msgErr51

;Constant not an integer
msgErr52

;Identifier does not denote a type
msgErr53

;Identifier does not denote a record type
msgErr54

;Result type of procedure is not a basic type
msgErr55

;Procedure call of a function
msgErr56

;Assignment to non-variable
msgErr57

;Pointer not bound to record or array type
msgErr58

;Recursive type definition
msgErr59

;Illegal open array parameter
msgErr60

;Wrong type of case label
msgErr61

;Inadmissible type of case label
msgErr62

;Case label defined more than once
msgErr63

;Index out of bounds
msgErr64

;More actual than formal parameters
msgErr65

;Fewer actual than formal parameters
msgErr66

;Element types of actual array and formal open array differ
msgErr67

;Actual parameter corresponding to open array is not an array
msgErr68

;Array bound out of range
msgErr81

;Index out of specified bounds
msgErr82

;Object being indexed is not an array
msgErr83

;Undefined record field
msgErr84

;Dereferenced variable is not a pointer
msgErr85

;Guard or test type is not an extension of variable type
msgErr86

;Guard or test type is not a pointer
msgErr87

;Guarded or tested variable is neither a pointer nor a VAR-parameter record
msgErr91

;x IN y : constant x is out of range (0 <= p < 32)
msgErr92

;Operand of IN not an integer, or not a set
msgErr93

;Set element type is not an integer
msgErr94

;Operand of & is not of type BOOLEAN
msgErr95

;Operand of OR is not of type BOOLEAN
msgErr96

;Operand not applicable to (unary) +
msgErr97

;Operand not applicable to (unary) -
msgErr98

;Operand of ~ is not of type BOOLEAN
msgErr100

;Incompatible operands of dyadic operator
msgErr101

;Operand type inapplicable to *
msgErr102

;Operand type inapplicable to /
msgErr103

;Operand type inapplicable to DIV
msgErr104

;Operand type inapplicable to MOD
msgErr105

;Operand type inapplicable to +
msgErr106

;Operand type inapplicable to -
msgErr107

;Operand type inapplicable to = or #
msgErr108

;Operand type inapplicable to relation
msgErr109

;Arithmetic overflow in constant expression
msgErr110

;Operand is not a type
msgErr111

;Operand inapplicable to (this) function
msgErr112

;Operand is not a variable
msgErr113

;Incompatible assignment
msgErr114

;String too long to be assigned
msgErr115

;Parameter doesn't match
msgErr116

;Number of parameters doesn't match
msgErr117

;Number of parameters doesn't match
msgErr118

;Result type doesn't match
msgErr119

;Procedure is not assignable
msgErr120

;Type of expression following IF, WHILE, UNTIL, or ASSERT is not BOOLEAN
msgErr121

;Called object is not a procedure (or is an interrupt procedure)
msgErr122

;Actual VAR-parameter is not a variable
msgErr123

;Type of actual parameter is not identical with that of formal VAR-parameter
msgErr124

;Type of result expression differs from that of procedure
msgErr125

;Type of case expression is neither INTEGER nor CHAR
msgErr126

;Illegal mode of operand
msgErr127

;Illegal mode of addressed operand
msgErr129

;Forward declared procedure not implemented
msgErr130

;WITH clause does not specify a variable
msgErr131

;LEN not applied to array
msgErr132

;Dimension in LEN too large or negative
msgErr150

;Key inconsistency of imported module
msgErr151

;Incorrect symbol file
msgErr152

;Symbol file of imported module not found
msgErr153

;Object or symbol file not opened (disk full?)
msgErr155

;Generation of new symbol file not allowed
msgErr156

;String in symbol file
msgErr157

;Symbol file tag illegal
;B. Limitations of implementation
;
msgErr202

;Set element greater than MAX(SET) or less than 0
msgErr203

;Number too large
msgErr205

;Division by zero
msgErr209

;Too much variable space needed
msgErr212

;Buffer for identifiers and strings full
msgErr214

;Too many exit statements
msgErr215

;Not enough registers: simplify expression
msgErr216

;Object is not a register item
msgErr219

;Illegal value of parameter  (0 <= p < 15)
msgErr221

;String cannot be exported / too many pointers in a record
msgErr224

;Too many pointer types
msgErr226

;Too many exported procedures
msgErr227

;Too many imported modules
msgErr228

;Too many exported structures
msgErr229

;Too many nested records for import
msgErr230

;Too many constants (strings) in module
msgErr231

;Code buffer overflow
msgErr233

;Type descriptor buffer overflow
msgErr234

;Too many external libraries
msgErr235

;Global variables not accessable
msgErr236

;Type extension is too deep (max 15 extension levels)
;C. Compiler Warnings - Amiga specific
;
msgErr300

;Parameter must be an exportable procedure or procedure variable
msgErr301

;Procedure must be paramaterless and typeless
msgErr302

;Parameter must be a procedure variable
msgErr303

;Library procedure must have a receiver parameter.
msgErr304

;Library procedure receiver cannot be VAR parameter.
msgErr305

;Receiver cannot be an imported type.
msgErr306

;Receiver type must be a pointer type.
msgErr307

;Receiver type must be a record type.
msgErr308

;Receiver type must be a C pointer type.
msgErr310

;Name buffer overflow
msgErr311

;Library procedure cannot be used in this manner
msgErr312

;Global variables too large to zero (> 260kB)
msgErr313

;Union type cannot have a base type
msgErr314

;Control variable of FOR loop must be an integer type
msgErr315

;Start and end values of FOR loop must be integers
msgErr316

;Step value of FOR loop must be non-zero
msgErr317

;Start, end or step value(s) too large for control variable of FOR loop
msgErr318

;Sign of step value is wrong for given start and end values.
msgErr319

;ASSERT (x,n): constant x evaluates to FALSE, should be HALT (n)
msgErr320

;ASSERT (x,n): constant x evaluates to TRUE, statement is meaningless
msgErr322

;Illegal mode in array index calculation
msgErr323

;Cannot alias imported strings > 1 character
msgErr324

;Operations that modify read-only variables are not allowed
msgErr325

;Open arrays are restricted to pointer base types, element types of open arrays and formal parameter types
msgErr326

;CPointers and BPointers to open arrays are not yet implemented
msgErr327

;Control variable must be a simple variable local to the procedure or module
msgErr328

;Integer expression expected
msgErr329

;Type-bound procedure has the same name as a record field
msgErr330

;Redefined procedure must be exported
msgErr331

;Cannot assign a type-bound procedure
msgErr332

;Super-call only allowed for receiver parameter
msgErr333

;Super-call not defined for base type
msgErr334

;Module name too long (limit 26 characters)
msgErr335

;RETURN statement missing in function procedure
msgErr336

;Parameter cannot be a vararg
msgErr337

;Vararg parameter must be the last parameter
msgErr338

;Parameter does not denote a traced pointer or record type
msgErr339

;SYSTEM.NEW cannot be used to allocate this type, use NEW instead
msgErr340

;Formal parameter must include a register specification
msgErr341

;Cannot assign a foreign procedure
msgErr342

;External name (string) expected
msgErr343

;Foreign procedures and LibCalls cannot be forward declared
msgErr344

;Foreign procedure cannot be bound to a type
msgErr345

;Cannot copy open arrays when SaveAllRegs is set
msgErr346

;Illegal character in in-line command
msgErr347

;Unrecognised in-line command
msgErr348

;Pragma or option specifier ["+"|"-"] missing.
msgErr349

;Pragma stack empty
msgErr350

;ELSIF, ELSE or END without matching IF
msgErr351

;Pragmas and options are not interchangeable
msgErr352

;Variable cannot be used as a base for a LibCall
msgErr353

;Illegal value for system flag
msgErr354

;Traced type cannot extend untraced type, and vice-versa
msgErr355

;Untraced record cannot contain traced fields
msgErr356

;Tagged type not allowed
msgErr357

;Options not permitted after MODULE keyword
msgErr358

;Pragma must start with '<*$'
msgErr359

;Error in inline command or pragma
;D. Oberon-Amiga specific
;
msgErr900

;Not implemented yet
msgErr901

;Register parameters only allowed in LibCall procedure
msgErr902

;Illegal type for register specification
msgErr903

;Illegal register number
msgErr904

;Parameter type is too big for register
msgErr905

;LibCallSpec only allowed for library procedure
msgErr906

;Function offset must be integer
msgErr907

;Library base variable must be pointer type
msgErr915

;Language extensions not allowed when STANDARD option is OFF
msgErr916

;String constants not allowed when createObj switch is off
msgErr917

;Tagged record types not allowed when createObj switch is off
msgErr918

;Variables not allowed when createObj switch is off
msgErr919

;Procedure or module body not allowed when createObj switch is off
msgErr920

;Cannot import module with object code when createObj switch is off
msgErr922

;Too many search paths specified
msgErr923

;Feature not properly tested
msgErr924

;Underscores in identifiers not permitted when STANDARD option is on
;E1. The following are internal compiler errors.  If you see one of
;    these, something is seriously wrong.  Report the bug immediately.
;    EC 950 is use to describe 951 - 999.
;
msgErr950

;Internal error -
msgErr951

;attempt to free an unused register
msgErr952

;illegal reference type
msgErr953

;wrong number of operands for opcode
msgErr954

;address alignment error
msgErr955

;branch too large
msgErr956

;addressing mode error
msgErr957

;data size error
msgErr958

;error in operand
msgErr959

;illegal reference size specified
msgErr960

;block length must be a constant
msgErr961

;patching past end of code buffer
msgErr962

;addressing string not in constant buffer
msgErr963

;no pointer to open array descriptor
msgErr964

;reference name missing
msgErr965

;type-bound procedure missing
msgErr966

;dereferencing NIL pointer
msgErr967

;procedure return overlaps allocated registers
;E2. Internal error - unrecognised case in CASE statement
;    EC 1000 is used to describe 1001 - 1099.
;
msgErr1000

;Internal error - unrecognised case in CASE statement:
msgErr1001

;OCS.Get
msgErr1002

;OCT.Import / CASE obj.typ.form
msgErr1003

;OCT.Import / CASE class (far inner)
msgErr1004

;OCT.Import / CASE class (inner)
msgErr1005

;OCT.Import / CASE class (outer)
msgErr1006

;OCT.OutStr
msgErr1007

;OCT.OutObj
msgErr1008

;OCC.PutArg
msgErr1009

;OCE.RealMath
msgErr1010

;OCE.MOp
msgErr1011

;OCE.CheckOverflow
msgErr1012

;OCE.Op / CASE f
msgErr1013

;OCE.Op / CASE op
msgErr1014

;OCP.StPar1
msgErr1015

;OCP.StPar2
msgErr1016

;OCH.Assign
