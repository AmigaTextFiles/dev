;=========================================================================
;     $RCSfile: ErrorMessages.cd $
;  Description: Catalog description file for compiler error messages
;
;   Created by: ferr (Johan Ferreira)
;    $Revision: 1.3 $
;      $Author: fjc $
;        $Date: 1995/07/30 18:16:36 $
;=========================================================================
;
#language english
#version 0
#basename ErrorMessages
;
;A. Incorrect use of language Oberon
;
;
;Undeclared identifier
msgErr0 (0//)
Undeclared identifier
;
;Multiply defined identifier
msgErr1 (1//)
Multiply defined identifier
;
;Illegal character in number
msgErr2 (2//)
Illegal character in number
;
;Illegal character in string
msgErr3 (3//)
Illegal character in string
;
;Identifier does not match procedure name
msgErr4 (4//)
Identifier does not match procedure name
;
;Comment not closed
msgErr5 (5//)
Comment not closed
;
;"=" expected
msgErr9 (9//)
"=" expected
;
;Identifier expected
msgErr10 (10//)
Identifier expected
;
;Type definition starts with incorrect symbol
msgErr12 (12//)
Type definition starts with incorrect symbol
;
;Factor starts with incorrect symbol
msgErr13 (13//)
Factor starts with incorrect symbol
;
;Statement starts with incorrect symbol
msgErr14 (14//)
Statement starts with incorrect symbol
;
;Declaration followed by incorrect symbol
msgErr15 (15//)
Declaration followed by incorrect symbol
;
;MODULE expected
msgErr16 (16//)
MODULE expected
;
;Integer constant expected
msgErr17 (17//)
Integer constant expected
;
;"." missing
msgErr18 (18//)
"." missing
;
;"," missing
msgErr19 (19//)
"," missing
;
;":" missing
msgErr20 (20//)
":" missing
;
;")" missing
msgErr22 (22//)
")" missing
;
;"]" missing
msgErr23 (23//)
"]" missing
;
;"}" missing
msgErr24 (24//)
"}" missing
;
;OF missing
msgErr25 (25//)
OF missing
;
;THEN missing
msgErr26 (26//)
THEN missing
;
;DO missing
msgErr27 (27//)
DO missing
;
;TO missing
msgErr28 (28//)
TO missing
;
;"(" missing
msgErr29 (29//)
"(" missing
;
;":=" missing
msgErr33 (33//)
":=" missing
;
;"," or OF expected
msgErr34 (34//)
"," or OF expected
;
;";" missing
msgErr38 (38//)
";" missing
;
;END missing
msgErr40 (40//)
END missing
;
;UNTIL missing
msgErr43 (43//)
UNTIL missing
;
;EXIT not within loop statement
msgErr45 (45//)
EXIT not within loop statement
;
;Object must be global
msgErr46 (46//)
Object must be global
;
;Illegally marked identifier
msgErr47 (47//)
Illegally marked identifier
;
;Forward declared pointer unsatisfied
msgErr48 (48//)
Forward declared pointer unsatisfied
;
;Attempting to import self
msgErr49 (49//)
Attempting to import self
;
;Expression should be constant
msgErr50 (50//)
Expression should be constant
;
;Constant not an integer
msgErr51 (51//)
Constant not an integer
;
;Identifier does not denote a type
msgErr52 (52//)
Identifier does not denote a type
;
;Identifier does not denote a record type
msgErr53 (53//)
Identifier does not denote a record type
;
;Result type of procedure is not a basic type
msgErr54 (54//)
Result type of procedure is not a basic type
;
;Procedure call of a function
msgErr55 (55//)
Procedure call of a function
;
;Assignment to non-variable
msgErr56 (56//)
Assignment to non-variable
;
;Pointer not bound to record or array type
msgErr57 (57//)
Pointer not bound to record or array type
;
;Recursive type definition
msgErr58 (58//)
Recursive type definition
;
;Illegal open array parameter
msgErr59 (59//)
Illegal open array parameter
;
;Wrong type of case label
msgErr60 (60//)
Wrong type of case label
;
;Inadmissible type of case label
msgErr61 (61//)
Inadmissible type of case label
;
;Case label defined more than once
msgErr62 (62//)
Case label defined more than once
;
;Index out of bounds
msgErr63 (63//)
Index out of bounds
;
;More actual than formal parameters
msgErr64 (64//)
More actual than formal parameters
;
;Fewer actual than formal parameters
msgErr65 (65//)
Fewer actual than formal parameters
;
;Element types of actual array and formal open array differ
msgErr66 (66//)
Element types of actual array and formal open array differ
;
;Actual parameter corresponding to open array is not an array
msgErr67 (67//)
Actual parameter corresponding to open array is not an array
;
;Array bound out of range
msgErr68 (68//)
Array bound out of range
;
;Index out of specified bounds
msgErr81 (81//)
Index out of specified bounds
;
;Object being indexed is not an array
msgErr82 (82//)
Object being indexed is not an array
;
;Undefined record field
msgErr83 (83//)
Undefined record field
;
;Dereferenced variable is not a pointer
msgErr84 (84//)
Dereferenced variable is not a pointer
;
;Guard or test type is not an extension of variable type
msgErr85 (85//)
Guard or test type is not an extension of variable type
;
;Guard or test type is not a pointer
msgErr86 (86//)
Guard or test type is not a pointer
;
;Guarded or tested variable is neither a pointer nor a VAR-parameter record
msgErr87 (87//)
Guarded or tested variable is neither a pointer nor a VAR-parameter record
;
;x IN y : constant x is out of range (0 <= p < 32)
msgErr91 (91//)
x IN y : constant x is out of range (0 <= p < 32)
;
;Operand of IN not an integer, or not a set
msgErr92 (92//)
Operand of IN not an integer, or not a set
;
;Set element type is not an integer
msgErr93 (93//)
Set element type is not an integer
;
;Operand of & is not of type BOOLEAN
msgErr94 (94//)
Operand of & is not of type BOOLEAN
;
;Operand of OR is not of type BOOLEAN
msgErr95 (95//)
Operand of OR is not of type BOOLEAN
;
;Operand not applicable to (unary) +
msgErr96 (96//)
Operand not applicable to (unary) +
;
;Operand not applicable to (unary) -
msgErr97 (97//)
Operand not applicable to (unary) -
;
;Operand of ~ is not of type BOOLEAN         
msgErr98 (98//)
Operand of ~ is not of type BOOLEAN         
;
;Incompatible operands of dyadic operator
msgErr100 (100//)
Incompatible operands of dyadic operator
;
;Operand type inapplicable to *
msgErr101 (101//)
Operand type inapplicable to *
;
;Operand type inapplicable to /
msgErr102 (102//)
Operand type inapplicable to /
;
;Operand type inapplicable to DIV
msgErr103 (103//)
Operand type inapplicable to DIV
;
;Operand type inapplicable to MOD
msgErr104 (104//)
Operand type inapplicable to MOD
;
;Operand type inapplicable to +
msgErr105 (105//)
Operand type inapplicable to +
;
;Operand type inapplicable to -
msgErr106 (106//)
Operand type inapplicable to -
;
;Operand type inapplicable to = or #
msgErr107 (107//)
Operand type inapplicable to = or #
;
;Operand type inapplicable to relation      
msgErr108 (108//)
Operand type inapplicable to relation      
;
;Arithmetic overflow in constant expression
msgErr109 (109//)
Arithmetic overflow in constant expression
;
;Operand is not a type
msgErr110 (110//)
Operand is not a type
;
;Operand inapplicable to (this) function
msgErr111 (111//)
Operand inapplicable to (this) function
;
;Operand is not a variable
msgErr112 (112//)
Operand is not a variable
;
;Incompatible assignment
msgErr113 (113//)
Incompatible assignment
;
;String too long to be assigned
msgErr114 (114//)
String too long to be assigned
;
;Parameter doesn't match
msgErr115 (115//)
Parameter doesn't match
;
;Number of parameters doesn't match
msgErr116 (116//)
Number of parameters doesn't match
;
;Number of parameters doesn't match
msgErr117 (117//)
Number of parameters doesn't match
;
;Result type doesn't match
msgErr118 (118//)
Result type doesn't match
;
;Procedure is not assignable
msgErr119 (119//)
Procedure is not assignable
;
;Type of expression following IF, WHILE, UNTIL, or ASSERT is not BOOLEAN
msgErr120 (120//)
Type of expression following IF, WHILE, UNTIL, or ASSERT is not BOOLEAN
;
;Called object is not a procedure (or is an interrupt procedure)
msgErr121 (121//)
Called object is not a procedure (or is an interrupt procedure)
;
;Actual VAR-parameter is not a variable
msgErr122 (122//)
Actual VAR-parameter is not a variable
;
;Type of actual parameter is not identical with that of formal VAR-parameter
msgErr123 (123//)
Type of actual parameter is not identical with that of formal VAR-parameter
;
;Type of result expression differs from that of procedure
msgErr124 (124//)
Type of result expression differs from that of procedure
;
;Type of case expression is neither INTEGER nor CHAR
msgErr125 (125//)
Type of case expression is neither INTEGER nor CHAR
;
;Illegal mode of operand
msgErr126 (126//)
Illegal mode of operand
;
;Illegal mode of addressed operand
msgErr127 (127//)
Illegal mode of addressed operand
;
;Forward declared procedure not implemented
msgErr129 (129//)
Forward declared procedure not implemented
;
;WITH clause does not specify a variable
msgErr130 (130//)
WITH clause does not specify a variable
;
;LEN not applied to array
msgErr131 (131//)
LEN not applied to array
;
;Dimension in LEN too large or negative
msgErr132 (132//)
Dimension in LEN too large or negative
;
;Key inconsistency of imported module
msgErr150 (150//)
Key inconsistency of imported module
;
;Incorrect symbol file
msgErr151 (151//)
Incorrect symbol file
;
;Symbol file of imported module not found
msgErr152 (152//)
Symbol file of imported module not found
;
;Object or symbol file not opened (disk full?)
msgErr153 (153//)
Object or symbol file not opened (disk full?)
;
;Generation of new symbol file not allowed
msgErr155 (155//)
Generation of new symbol file not allowed
;
;String in symbol file
msgErr156 (156//)
String in symbol file
;
;Symbol file tag illegal
msgErr157 (157//)
Symbol file tag illegal
;
;
;B. Limitations of implementation
;
;
;Set element greater than MAX(SET) or less than 0
msgErr202 (202//)
Set element greater than MAX(SET) or less than 0
;
;Number too large
msgErr203 (203//)
Number too large
;
;Division by zero
msgErr205 (205//)
Division by zero
;
;Too much variable space needed
msgErr209 (209//)
Too much variable space needed
;
;Buffer for identifiers and strings full
msgErr212 (212//)
Buffer for identifiers and strings full
;
;Too many exit statements
msgErr214 (214//)
Too many exit statements
;
;Not enough registers: simplify expression
msgErr215 (215//)
Not enough registers: simplify expression
;
;Object is not a register item
msgErr216 (216//)
Object is not a register item
;
;Illegal value of parameter  (0 <= p < 15)
msgErr219 (219//)
Illegal value of parameter  (0 <= p < 15)
;
;String cannot be exported / too many pointers in a record
msgErr221 (221//)
String cannot be exported / too many pointers in a record
;
;Too many pointer types
msgErr224 (224//)
Too many pointer types
;
;Too many exported procedures
msgErr226 (226//)
Too many exported procedures
;
;Too many imported modules
msgErr227 (227//)
Too many imported modules
;
;Too many exported structures
msgErr228 (228//)
Too many exported structures
;
;Too many nested records for import
msgErr229 (229//)
Too many nested records for import
;
;Too many constants (strings) in module
msgErr230 (230//)
Too many constants (strings) in module
;
;Code buffer overflow
msgErr231 (231//)
Code buffer overflow
;
;Type descriptor buffer overflow
msgErr233 (233//)
Type descriptor buffer overflow
;
;Too many external libraries
msgErr234 (234//)
Too many external libraries
;
;Global variables not accessable
msgErr235 (235//)
Global variables not accessable
;
;Type extension is too deep (max 15 extension levels)
msgErr236 (236//)
Type extension is too deep (max 15 extension levels)
;
;
;C. Compiler Warnings - Amiga specific
;
;
;Parameter must be an exportable procedure or procedure variable
msgErr300 (300//)
Parameter must be an exportable procedure or procedure variable
;
;Procedure must be paramaterless and typeless
msgErr301 (301//)
Procedure must be paramaterless and typeless
;
;Parameter must be a procedure variable
msgErr302 (302//)
Parameter must be a procedure variable
;
;Library procedure must have a receiver parameter.
msgErr303 (303//)
Library procedure must have a receiver parameter.
;
;Library procedure receiver cannot be VAR parameter.
msgErr304 (304//)
Library procedure receiver cannot be VAR parameter.
;
;Receiver cannot be an imported type.
msgErr305 (305//)
Receiver cannot be an imported type.
;
;Receiver type must be a pointer type.
msgErr306 (306//)
Receiver type must be a pointer type.
;
;Receiver type must be a record type.
msgErr307 (307//)
Receiver type must be a record type.
;
;Receiver type must be a C pointer type.
msgErr308 (308//)
Receiver type must be a C pointer type.
;
;Name buffer overflow
msgErr310 (310//)
Name buffer overflow
;
;Library procedure cannot be used in this manner
msgErr311 (311//)
Library procedure cannot be used in this manner
;
;Global variables too large to zero (> 260kB)
msgErr312 (312//)
Global variables too large to zero (> 260kB)
;
;Union type cannot have a base type
msgErr313 (313//)
Union type cannot have a base type
;
;Control variable of FOR loop must be an integer type
msgErr314 (314//)
Control variable of FOR loop must be an integer type
;
;Start and end values of FOR loop must be integers
msgErr315 (315//)
Start and end values of FOR loop must be integers
;
;Step value of FOR loop must be non-zero
msgErr316 (316//)
Step value of FOR loop must be non-zero
;
;Start, end or step value(s) too large for control variable of FOR loop
msgErr317 (317//)
Start, end or step value(s) too large for control variable of FOR loop
;
;Sign of step value is wrong for given start and end values.
msgErr318 (318//)
Sign of step value is wrong for given start and end values.
;
;ASSERT (x,n): constant x evaluates to FALSE, should be HALT (n)
msgErr319 (319//)
ASSERT (x,n): constant x evaluates to FALSE, should be HALT (n)
;
;ASSERT (x,n): constant x evaluates to TRUE, statement is meaningless
msgErr320 (320//)
ASSERT (x,n): constant x evaluates to TRUE, statement is meaningless
;
;Illegal mode in array index calculation
msgErr322 (322//)
Illegal mode in array index calculation
;
;Cannot alias imported strings > 1 character
msgErr323 (323//)
Cannot alias imported strings > 1 character
;
;Operations that modify read-only variables are not allowed
msgErr324 (324//)
Operations that modify read-only variables are not allowed
;
;Open arrays are restricted to pointer base types, element types of open arrays and formal parameter types
msgErr325 (325//)
Open arrays are restricted to pointer base types, element types of open arrays and formal parameter types
;
;CPointers and BPointers to open arrays are not yet implemented
msgErr326 (326//)
CPointers and BPointers to open arrays are not yet implemented
;
;Control variable must be a simple variable local to the procedure or module
msgErr327 (327//)
Control variable must be a simple variable local to the procedure or module
;
;Integer expression expected
msgErr328 (328//)
Integer expression expected
;
;Type-bound procedure has the same name as a record field
msgErr329 (329//)
Type-bound procedure has the same name as a record field
;
;Redefined procedure must be exported
msgErr330 (330//)
Redefined procedure must be exported
;
;Cannot assign a type-bound procedure
msgErr331 (331//)
Cannot assign a type-bound procedure
;
;Super-call only allowed for receiver parameter
msgErr332 (332//)
Super-call only allowed for receiver parameter
;
;Super-call not defined for base type
msgErr333 (333//)
Super-call not defined for base type
;
;Module name too long (limit 26 characters)
msgErr334 (334//)
Module name too long (limit 26 characters)
;
;RETURN statement missing in function procedure
msgErr335 (335//)
RETURN statement missing in function procedure
;
;Parameter cannot be a vararg
msgErr336 (336//)
Parameter cannot be a vararg
;
;Vararg parameter must be the last parameter
msgErr337 (337//)
Vararg parameter must be the last parameter
;
;Parameter does not denote a pointer or record type
msgErr338 (338//)
Parameter does not denote a traced pointer or record type
;
;SYSTEM.NEW cannot be used to allocate this type, use NEW instead
msgErr339 (339//)
SYSTEM.NEW cannot be used to allocate this type, use NEW instead
;
;Formal parameter must include a register specification
msgErr340 (340//)
Formal parameter must include a register specification
;
;Cannot assign a foreign procedure
msgErr341 (341//)
Cannot assign a foreign procedure
;
;External name (string) expected
msgErr342 (342//)
External name (string) expected
;
;Foreign procedures cannot be forward declared
msgErr343 (343//)
Foreign procedures and LibCalls cannot be forward declared
;
;Foreign procedure cannot be bound to a type
msgErr344 (344//)
Foreign procedure cannot be bound to a type
;
;Cannot copy open arrays when SaveAllRegs is set.
msgErr345 (345//)
Cannot copy open arrays when SaveAllRegs is set
;
;Illegal character in in-line command
msgErr346 (346//)
Illegal character in in-line command
;
;Unrecognised in-line command
msgErr347 (347//)
Unrecognised in-line command
;
;Pragma or option specifier ["+"|"-"] missing.
msgErr348 (348//)
Pragma or option specifier ["+"|"-"] missing.
;
;Pragma stack empty
msgErr349 (349//)
Pragma stack empty
;
;ELSIF, ELSE or END without matching IF
msgErr350 (350//)
ELSIF, ELSE or END without matching IF
;
;Pragmas and options are not interchangeable
msgErr351 (351//)
Pragmas and options are not interchangeable
;
;Variable cannot be used as a base for a LibCall
msgErr352 (352//)
Variable cannot be used as a base for a LibCall
;
;Illegal value for system flag
msgErr353 (353//)
Illegal value for system flag
;
;Traced type cannot extend untraced type, and vice-versa
msgErr354 (354//)
Traced type cannot extend untraced type, and vice-versa
;
;Untraced record cannot contain traced fields
msgErr355 (355//)
Untraced record cannot contain traced fields
;
;Tagged type not allowed
msgErr356 (356//)
Tagged type not allowed
;
;Options not permitted after MODULE keyword
msgErr357 (357//)
Options not permitted after MODULE keyword
;
;Pragma must start with '<*$'
msgErr358 (358//)
Pragma must start with '<*$'
;
;Error in inline command or pragma
msgErr359 (359//)
Error in inline command or pragma
;
;
;D. Oberon-Amiga specific
;
;
;Not implemented yet
msgErr900 (900//)
Not implemented yet
;
;Register parameters only allowed in LibCall procedure
msgErr901 (901//)
Register parameters only allowed in LibCall procedure
;
;Illegal type for register specification
msgErr902 (902//)
Illegal type for register specification
;
;Illegal register number
msgErr903 (903//)
Illegal register number
;
;Parameter type is too big for register
msgErr904 (904//)
Parameter type is too big for register
;
;LibCallSpec only allowed for library procedure
msgErr905 (905//)
LibCallSpec only allowed for library procedure
;
;Function offset must be integer
msgErr906 (906//)
Function offset must be integer
;
;Library base variable must be pointer type
msgErr907 (907//)
Library base variable must be pointer type
;
;Language extensions not allowed when portableCode switch is on
msgErr915 (915//)
Language extensions not allowed when STANDARD option is OFF
;
;String constants not allowed when createObj switch is off
msgErr916 (916//)
String constants not allowed when createObj switch is off
;
;Tagged record types not allowed when createObj switch is off
msgErr917 (917//)
Tagged record types not allowed when createObj switch is off
;
;Variables not allowed when createObj switch is off
msgErr918 (918//)
Variables not allowed when createObj switch is off
;
;Procedure or module body not allowed when createObj switch is off
msgErr919 (919//)
Procedure or module body not allowed when createObj switch is off
;
;Cannot import module with object code when createObj switch is off
msgErr920 (920//)
Cannot import module with object code when createObj switch is off
;
;Too many search paths specified
msgErr922 (922//)
Too many search paths specified
;
;Feature not properly tested
msgErr923 (923//)
Feature not properly tested
;
;Underscores in identifiers not permitted when STANDARD option is on
msgErr924 (924//)
Underscores in identifiers not permitted when STANDARD option is on
;
;
;E1. The following are internal compiler errors.  If you see one of
;    these, something is seriously wrong.  Report the bug immediately.
;    EC 950 is use to describe 951 - 999.
;
;
;Internal error -
msgErr950 (950//)
Internal error -
;
;attempt to free an unused register
msgErr951 (951//)
attempt to free an unused register
;
;illegal reference type
msgErr952 (952//)
illegal reference type
;
;wrong number of operands for opcode
msgErr953 (953//)
wrong number of operands for opcode
;
;address alignment error
msgErr954 (954//)
address alignment error
;
;branch too large
msgErr955 (955//)
branch too large
;
;addressing mode error
msgErr956 (956//)
addressing mode error
;
;data size error
msgErr957 (957//)
data size error
;
;error in operand
msgErr958 (958//)
error in operand
;
;illegal reference size specified
msgErr959 (959//)
illegal reference size specified
;
;block length must be a constant
msgErr960 (960//)
block length must be a constant
;
;patching past end of code buffer
msgErr961 (961//)
patching past end of code buffer
;
;addressing string not in constant buffer
msgErr962 (962//)
addressing string not in constant buffer
;
;no pointer to open array descriptor
msgErr963 (963//)
no pointer to open array descriptor
;
;reference name missing
msgErr964 (964//)
reference name missing
;
;type-bound procedure missing
msgErr965 (965//)
type-bound procedure missing
;
;dereferencing NIL pointer
msgErr966 (966//)
dereferencing NIL pointer
;
;procedure return overlaps allocated registers
msgErr967 (967//)
procedure return overlaps allocated registers
;
;
;E2. Internal error - unrecognised case in CASE statement
;    EC 1000 is used to describe 1001 - 1099.
;
;
;Internal error - unrecognised case in CASE statement:
msgErr1000 (1000//)
Internal error - unrecognised case in CASE statement:
;
;OCS.Get
msgErr1001 (1001//)
OCS.Get
;
;OCT.Import / CASE obj.typ.form
msgErr1002 (1002//)
OCT.Import / CASE obj.typ.form
;
;OCT.Import / CASE class (far inner)
msgErr1003 (1003//)
OCT.Import / CASE class (far inner)
;
;OCT.Import / CASE class (inner)
msgErr1004 (1004//)
OCT.Import / CASE class (inner)
;
;OCT.Import / CASE class (outer)
msgErr1005 (1005//)
OCT.Import / CASE class (outer)
;
;OCT.OutStr
msgErr1006 (1006//)
OCT.OutStr
;
;OCT.OutObj
msgErr1007 (1007//)
OCT.OutObj
;
;OCC.PutArg
msgErr1008 (1008//)
OCC.PutArg
;
;OCE.RealMath
msgErr1009 (1009//)
OCE.RealMath
;
;OCE.MOp
msgErr1010 (1010//)
OCE.MOp
;
;OCE.CheckOverflow
msgErr1011 (1011//)
OCE.CheckOverflow
;
;OCE.Op / CASE f
msgErr1012 (1012//)
OCE.Op / CASE f
;
;OCE.Op / CASE op
msgErr1013 (1013//)
OCE.Op / CASE op
;
;OCP.StPar1
msgErr1014 (1014//)
OCP.StPar1
;
;OCP.StPar2
msgErr1015 (1015//)
OCP.StPar2
;
;OCH.Assign
msgErr1016 (1016//)
OCH.Assign
