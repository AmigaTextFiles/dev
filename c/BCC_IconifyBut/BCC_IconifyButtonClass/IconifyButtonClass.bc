/*
 *  File:           IconifyButtonClass.bc
 *
 *  Description:    An IconifyButton BOOPSI Class with BCC syntax.
 *                  class implementation file
 *                  for demonstration/educational purpose
 *
 *  Tab Size:       4
 *
 *  Notes:          Based on original Code by Ketil Hunn
 *                  (Aminet: IconifyButtonC.lha)
 *
 *                  transcribed to BCC syntax by Christian Buchner
 *
 *                  basic knowledge about BOOPSI programming helps
 *                  a lot to understand this code.
 *
 *                  BCC rulez!
 *
 *  Copyright:      (c) 1998, Christian Buchner
 *                  flowerp@eikon.e-technik.tu-muenchen.de
 *
 */


/*** CLASS HEADER FILE ******************************************************************/

#include "IconifyButtonClass.bh"


/*** PROTOTYPES *************************************************************************/

__asm void RenderIconifyButton(	register __a0 Object *obj,
								register __a1 struct GadgetInfo	*gi );

__asm void drawFrame(	register __a0 struct RastPort *rp,
						register __d4 UWORD	pen1,
						register __d5 UWORD	pen2,
						register __d0 WORD	x,
						register __d1 WORD	y,
						register __d2 WORD	w,
						register __d3 WORD	h );


/*** METHOD IMPLEMENTATION **************************************************************/

/* Constructor */

Method IconifyButtonClass::IconifyButtonClass()
{
	
}


Method IconifyButtonClass::~IconifyButtonClass()
{
	
}


super Method IconifyButtonClass::GM_HITTEST()
{
	_ret = GMR_GADGETHIT;
}


super Method IconifyButtonClass::GM_GOACTIVE()
{
	if(((struct gpInput *)msg)->gpi_IEvent)
	{
		SETBIT(((struct Gadget *)obj)->Flags, GFLG_SELECTED);
		RenderIconifyButton(obj, ((struct gpInput *)msg)->gpi_GInfo);
		_ret = GMR_MEACTIVE;
	}
	else
		_ret = GMR_NOREUSE;
}


super Method IconifyButtonClass::GM_GOINACTIVE()
{
	CLEARBIT(((struct Gadget *)obj)->Flags, GFLG_SELECTED);
	RenderIconifyButton(obj, ((struct gpGoInactive *)msg)->gpgi_GInfo);
}


super Method IconifyButtonClass::GM_RENDER()
{
	struct Gadget	*g	= (struct Gadget *)obj;
	struct RastPort	*rp	= ((struct gpRender *)msg)->gpr_RPort;
	UWORD	*pens		= ((struct gpRender *)msg)->gpr_GInfo->gi_DrInfo->dri_Pens;
	_ret				= FALSE;
	
	if(rp && pens)
	{
		register BYTE selected=(g->Flags & GFLG_SELECTED);
		register UWORD	x = g->LeftEdge+1,
						y = g->TopEdge,
						w = g->Width-2,
						h = g->Height;
		
		UWORD	hmarg = 5,	//g->Width/5,
				vmarg = g->Width/7-(g->Height<11 ? 1:0);
		
		if(ISBITSET(g->Flags, GFLG_RELRIGHT))
			x+=((struct gpRender *)msg)->gpr_GInfo->gi_Domain.Width-1;
		
		SetAPen(rp, pens[SHADOWPEN]);
		
		Move(rp, x-1, y+1);
		Draw(rp, x-1, y+h);
		
		if(selected)
		{
			drawFrame(rp, pens[SHADOWPEN], pens[SHINEPEN], x,y,w,h);
			drawFrame(rp, pens[SHINEPEN], pens[SHADOWPEN], x+hmarg,y+vmarg,w-hmarg*2,h-vmarg*2);
			drawFrame(rp, pens[SHADOWPEN], pens[SHINEPEN], x+hmarg+1,y+h-vmarg-3,2,2);
		}
		else
		{
			drawFrame(rp, pens[SHINEPEN], pens[SHADOWPEN], x,y,w,h);
			drawFrame(rp, pens[SHADOWPEN], pens[SHINEPEN], x+hmarg,y+vmarg,w-hmarg*2,h-vmarg*2);
			drawFrame(rp, pens[SHINEPEN], pens[SHADOWPEN], x+hmarg+1,y+h-vmarg-3,2,2);
		}
		
		_ret=TRUE;
	}
}


super Method IconifyButtonClass::GM_HANDLEINPUT()
{
	struct Gadget		*g	 = (struct Gadget *)obj;
	struct gpInput		*gpi = (struct gpInput *)msg;
	struct InputEvent	*ie	 = gpi->gpi_IEvent;
	
	_ret=GMR_MEACTIVE;
	
	if(ie->ie_Class==IECLASS_RAWMOUSE)
	{
		switch (ie->ie_Code)
		{
			case SELECTUP:
				if(	(gpi->gpi_Mouse.X<0)		||
					(gpi->gpi_Mouse.X>g->Width)	||
					(gpi->gpi_Mouse.Y<0)		||
					(gpi->gpi_Mouse.Y>g->Height))
					_ret=GMR_REUSE;
				else
					_ret=GMR_NOREUSE|GMR_VERIFY;
				break;
			
			case MENUDOWN:
				_ret=GMR_REUSE;
				break;
			
			case IECODE_NOBUTTON:
				if(	(gpi->gpi_Mouse.X<0)			||
					(gpi->gpi_Mouse.X>g->Width)		||
					(gpi->gpi_Mouse.Y<0)			||
					(gpi->gpi_Mouse.Y>g->Height))
				{
					if(ISBITSET(g->Flags, GFLG_SELECTED))
					{
						CLEARBIT(g->Flags, GFLG_SELECTED);
						RenderIconifyButton(obj, gpi->gpi_GInfo);
					}
				}
				else if(ISBITCLEARED(g->Flags, GFLG_SELECTED))
				{
					SETBIT(g->Flags, GFLG_SELECTED);
					RenderIconifyButton(obj, gpi->gpi_GInfo);
				}
				break;
		}
	}
}


/*** MISC FUNCTIONS ********************************************************************/

__asm void RenderIconifyButton(	register __a0 Object *obj,
								register __a1 struct GadgetInfo	*gi )
{
	register struct RastPort *rp;

	if(rp=ObtainGIRPort(gi))
	{
		DoMethod(obj, GM_RENDER, gi, rp, GREDRAW_REDRAW);
		ReleaseGIRPort(rp);
	}
}


__asm void drawFrame(	register __a0 struct RastPort *rp,
						register __d4 UWORD	pen1,
						register __d5 UWORD	pen2,
						register __d0 WORD	x,
						register __d1 WORD	y,
						register __d2 WORD	w,
						register __d3 WORD	h )
{
	SetAPen(rp, pen1);
	Move(rp, x,		y+h-1);
	Draw(rp, x,		y);
	Draw(rp, x+w-1,	y);
	
	SetAPen(rp, pen2);
	Move(rp, x+w, y+1);
	Draw(rp, x+w, y+h);
	Draw(rp, x+1, y+h);
}
