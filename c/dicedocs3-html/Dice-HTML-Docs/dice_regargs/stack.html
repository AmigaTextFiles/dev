<html>
<head>
  <title>Forcing Stack Based Procedures</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="entry.html">PREV</a> | <a href="callback.html">NEXT</a>
<hr>
<pre>


                     <b>FORCING STACK BASED PROCEDURES</b>

 Here is an example of a prototype and its procedure definition
 to force stack based arguments:

     extern __stkargs void fubar(char *);

     __stkargs void
     fubar(char *ptr)
     {
     ...
     }

 Note that BOTH THE PROTOTYPE AND THE PROCEDURE ITSELF MUST
 specify the __stkargs flag.  Assigning any procedure qualified
 with only __stkargs (rather than both __stkargs and __stkregs)
 always assigns the stack based entry point rather than the
 (possibly non-existant) register based entry point.

 Any call-back procedure you pass to the Amiga OS or any library
 must be prototyped and defined like this because the library will
 always call it back with stack based arguments unless otherwise
 specified by the library.

 FORCING STACK BASED INDIRECT FUNCTION POINTERS

 Lets go back to that structure.. lets say you want any procedures
 called through the indirect function pointer to be called using
 stack based arguments.  You would then specify:

     struct entry {
     char *funcName;
     __stkargs void (*funcPtr)(char *);
     } *En;

 But BE CAREFUL.  Any function assigned to this structure entry
 must also be __stkargs:

     extern __stkargs void fubar(char *);    /*  RIGHT   */
     extern void fubar(char *);              /*  WRONG   */

     ...

     En-&#062;funcPtr = fubar;

 If you do NOT match the argument type properly, DICE will
 generate incorrect code.  Again, this is when you use the -mRR
 option.  If you use only -mr or -mR (and specify __stkargs for
 the procedures in question), this kind of problem will not
 crop up.

</pre>
</body>
</html>
