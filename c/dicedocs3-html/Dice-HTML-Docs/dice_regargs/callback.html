<html>
<head>
  <title>Call Backs (C and Amiga Lib)</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="stack.html">PREV</a> | <a href="main.html">NEXT</a>
<hr>
<pre>
                    
                   <b>CALL-BACKS (C.LIB, AMIGA.LIB)</b>

 C.LIB and AMIGA.LIB handle call-backs differently.  With C.LIB,
 if you link without -m[r,R,RR] then everything uses stack based
 arguments.  However, if you link with -mr, -mR, or -mRR then
 CR.LIB is linked in instead of C.LIB, and any call-back functions
 you supply to it (for example, qsort()) must use the registerized
 entry point.

 Therefore, if you use C.LIB call-backs you cannot use -mr or -mR
 ... you MUST use -mRR or not use registerization at all.  This is
 because, if you remember, -mr and -mR always pass the
 unregisterized entry point for anything but a direct call to the
 routine (-mR exists to make porting code easier)

 AMIGA.LIB works the flip-side.  Since these are commodore-standard
 routines any call-backs will be using stack-based arguments.  Thus,
 any procedure you pass to an AMIGA.LIB routine must be declared
 __stkargs.  This is a special case:

     <b>int ben(int (*)(int));

     __stkargs int fubar(int x)
     {
     ben(fubar);
     }</b>

 Even though ben() is fully prototyped to take a function pointer
 that is fully prototyped, since fubar has been declared as a
 stack-only routine, _fubar will be passed to ben instead of
 @fubar.

 Thus, Amiga.Lib routines may be fully prototyped but as long as
 you pass a stack-args only routine to them, the stack-args entry
 point will be passed instead of the reg-args entry point.

</pre>
</body>
</html>
