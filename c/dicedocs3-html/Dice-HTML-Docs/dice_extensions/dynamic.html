<html>
<head>
  <title>Dynamic Stack (wow)</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="typestore.html">PREV</a> | <a href="unix.html">NEXT</a>
<hr>
<pre>


                    <b>DYNAMIC STACKS (-gs option)</b>
   
 DICE now has a new option, -gs, which generates stack checking code for
 every subroutine.  But, unlike SAS/C or MANX, DICE is able to allocate
 new stack chunks when the current stack runs out.  Essentially this
 means that you can compile and run programs which expect a lot of stack
 without having to remember to give a larger STACK command in your
 CLI.  Since DICE allocates and deallocates stack chunks according to
 program usage, an efficient use of the amiga's memory is made.
   
 There are two global variables associated with this option.  You, the
 programmer, may override either or both of them by declaring them
 yourself.  The variables are:
   
 long _stack_fudge = 4096;
 long _stack_chunk = 32768;
   
 The defaults are shown above.  You can modify these variables either
 by declaring them globally or changing them on the fly (usually from
 main()).
   
 _stack_fudge specifies the minimum amount of stack before DICE creates
 a new stack.  This should be AT LEAST 2048 BYTES!  This parameter MUST
 be able to handle the worst case stack usage for any given subroutine.
   
 The second parameter specifies the chunk size for any new stacks
 created.  A new stack is created whenever the current available
 stack goes below _stack_fudge, but only applies to the next level
 of subroutine... the current subroutine (that detected the low stack
 condition) must be able to run in the old stack.  Stacks are freed
 as they become unused.
   
 If for any reason DICE is unable to allocate a new stack, it will
 call the stack_abort() routine.  If you do not define such a routine,
 the one from the library will be used (which abort()s the program).
   
 If you DO define a stack_abort() routine, then you must take one
 of two actions:
   
 (1) abort() or exit() the program
   
 (2) return (causes DICE to retry allocating the stack)
   
 If DICE is unable to reallocate the stack after (2), it will call
 stack_abort() again.
   
</pre>
</body>
</html>
