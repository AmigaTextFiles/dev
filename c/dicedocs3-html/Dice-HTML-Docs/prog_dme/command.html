<html>
<head>
  <title>DME Command Sequences</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="key.html">PREV</a> | <a href="file.html">NEXT</a>
<hr>
<pre>
                         <b>COMMAND SEQUENCES</b>


 DME has a rich command set which allows you to embed commands within
 commands, or specify multiple commands in a row.  A command consists of a
 KEYWORD followed by a FIXED number of arguments (0, 1, 2...).  The argument
 delimeter in DME is a SPACE.  Therefore, to embed strings containing spaces
 as a single argument, you must surround the string with (string)
 (backsinglequote-string-singlequote).  TEXT to be written as if typed is
 also specified via a string in backquote-quotes.  For example:

    right right (hello) right right (hello) enter down
    map f4 (right right) map f5 (left left)
    map f4 ((hello))

 Reiterating (because this is important!)... If a command expects ONE
 argument, then it really does expect a single argument, and any remaining
 arguments are thought to be the next command... so:

    map f4 right
                    -right is only one word, so no need
                     for ().
    map f4 (right right)
                    -we want to map f4 to two rights... we
                     need the () or the second right will
                     not be part of the map.

    map c-del (repeat cright del)
                    -this is already implimented as REMEOL,
                     but shown here for clarity.

 Some arguments will eventually be fed through the command interpreter more
 than once.  The MAP command is a good example.  When you execute a MAP
 command, the first run through the command interpreter installs the map
 string minus a set of quotes.  So, if you want to specify text, you must
 enclose the text in two sets of ((text)) because the map string gets passed
 through the command interpreter again when you hit the mapped key.  Here
 are some more complex examples:

    map f4 (right right (hello) left left)  *RIGHT*
    map f4 right right hello left left      *WRONG*

    map f4 (map f4 ((hello)))
                    -the first time you hit F4, it's command
                     is to re-map itself to the TEXT (hello).
                     (gads!).

    map c-i (repeat tr (( )))
                    -example of how to embed a space in a
                     map and repeat (goes through command
                     interpreter three times!).


 An easy way to fool around executing commands or making maps is either to
 use the ESC key (which enters command mode), or  a-S (alt-shift-s), which
 EXECUTES the current DME line that the cursor is on.... so you can use DME
 to edit and test your new keymappings.


 <b>STRING VARIABLES</b>

 String variables are replaced with their contents.  Three specification
 forms are allowed:

 $varname        - varname can only consist of a-z,A-Z,0-9,-,_
 $(varname)      - anything not containing a '(' or ')'
 $`varname'      - anything not containing a '`' or '''

 Two special variables exist:

 filename    - the current filename
 scanf       - the current scanf'd string (see SCANF below)
 lineno      - the current cursor line number (1 .. N)
 colno       - the current cursor column number (1 .. N)

 Other variables cause a search of three variable domains to find the
 contents.  For example, if you give  $DMEFONT:

 (1) An Internal variable named DMEFONT is searched for.  Internal
     variables are case sensitive.  (see SET, UNSET)

 (2) An Enviroment variable name DMEFONT is searched for.  Enviroment
     variables are NOT case sensitive.  (see SETENV, UNSETENV).  The
     1.3 ENV: is used.

 (3) A DME keymap or menu definition named DMEFONT is searched for.
     This allows you to say something like $sa-tab to insert the
     contents of the shift-alt-tab keymap.   (see MAP, UNMAP, and
     MENU oriented commands).

 The reason for the other two forms of variable specifiction is to allow
 one to access strangely named variables (with puncuation and other crap).

 SPECIAL NOTE:  What is wrong with this command?

 repeat 100 (first ($myvar))

 What is wrong is that $myvar is evaluated BEFORE the repeat is
 executed.  myvar might contain characters that would confuse the
 command specification when.  That is, if myvar contained a '(' you
 could get something like:   repeat 100 (fist ((())  which is obviously
 incorrect.  By using  you can cause $myvar to be evaluated at
 loop-execution time rather than before:

 repeat 100 (first ($myvar))

 These kinds of problems can also occur when you do keymaps... you
 probably do not want to evaluate the variable at keymap-entry time,
 but rather would want the variable evaluated at keymap-execution time.

 On the otherhand, this is perfectly allowable:

 set x (tlate +1)
 repeat 100 ($x)

 Which executes the command (tlate +1) 100 times... By NOT surrounding
 the variable with parens (depends on the situation), the variable is
 executed rather than inserted as text.


 <b>SPECIAL CHARACTERS</b>

 ^ is used to introduce a control character.  For example, ^c would
 embed a control-c.  You cannot embed c-@ (ascii code 0).

 backslash  is used to override special meanings.  The next character
 is overriden.

 map c-a ((^l))      -map control a to produce a control l
 map c-a ((\^l))   -map control a to produce a &quot;^l&quot;.  The first
           overides the second, and the third overides
          the ^.


 <b>COMMAND LIST:</b>

 (text)          -enter text as if typed.
 key         -execute a keymap as a macro (example:  c-a)
 header-item     -execute a menu item as a macro (example: Project-Save)
          (case independant)
 ADDPATH path    -Add the specified symbolic directory to DME's special
          search path (see REF and CTAGS).
 ARPINSFILE      -INSFILE filerequestor, only if ARP.LIBRARY installed
 ARPLOAD     -NEWFILE filerequestor, only if ARP.LIBRARY installed
 ARPSAVE     -SAVEAS  filerequestor, only if ARP.LIBRARY installed
 BACK        -same as BS
 BACKTAB     -backward tab
 BCOPY       -copy block before cursor line
 BDELETE     -delete the block
 BGPEN pen   -set background pen
 BLOCK       -Set start or end of block
 BMOVE       -move block before cursor line
 BOTTOM      -Move to Bottom of File
 BS          -backspace, (delete char to left of cursor)
 BSAVE file  -save the block to a file
 BSOURCE     -source current text block as if it were a script file
 CHFILENAME name -change the name of the working file
 CTAGS       -search for the tag under the cursor (see below)
 DEL         -delete, (deletes char under cursor)
 DELINE      -delete line
 DOWN        -cursor down
 DOWNADD     -cursor down.  If at bottom of text, add a line.
 ESC         -toggle manual command entry mode
 ESCIMM arg  -go into command entry mode prompting with a
          predefined string.
 EXECUTE comm    -Execute a CLI command
 FGPEN pen       -Set foreground pen
 FIND string     -SET the search pattern and do a NEXT
 FINDR s1 s2     -Set find and replace patterns and do one find/rep.
 FINDSTR string  -SET the search string pattern
 FIRST       -move to column 1
 FIRSTNB     -Move to first non-blank in line.
 GOTO BLOCK      -Goto the beginning of the marked block.
 GOTO START      -same as GOTO BLOCK.  undefined if no block
 GOTO END        -goes to the END of the marked block.  undef. if no blk.
 GOTO [+/-]N     -Goto an absolute or relative line number
 HEIGHT N        -set height in PIXELS for any new windows
 HGPEN pen       -set highlight pen
 ICONIFY         -iconify the window
 IF cnd act      -IF/WHILE/IFELSE.. SEE BELOW
 IFELSE cnd ifact elseact
 IGNORECASE what -set case ignore for seaches.  what = on, off, or toggle
 INSERTMODE what -set INSERTMODE.  what = on, off, or toggle
 INSFILE name    -insert a file into the current text.
 INSLINE         -insert line
 JOIN            -join next line to line at cursor
 JUSTIFY how     -simple text justification.  Currently only 'full'
          justification supported (justify full).
 LAST            -move one beyond the last non-space in a line.
 LEFT            -cursor left
 LEFTEDGE N      -set leftedge on the screen in PIXELS for any new window
 MAP key map     -map a key to a keymap
 MARGIN N        -set WordWrap and paragraph formatting margin
          (related to WORDWRAP and REFORMAT)
 MENUADD hdr item cmd    -add menu item
 MENUDEL hdr item        -delete menu item
 MENUDELHDR hdr      -delete menu header
 MENUCLEAR           -delete entire menu
 MENUON          -enable menus  (multiple calls are stacked)
 MENUOFF         -disable menus (multiple calls are stacked)
 MODIFIED on/off/toggle
         -set modified flag manually

 NEWFILE name    -replace current text with new file
 NEWWINDOW       -open new window using default window parameters
 NEXT        -find next occurance of search pattern
 NEXTR       -find next occurance and replace
 NULL        -no operation
 OPENWINDOW geo  -open new window using specified geometry.  Geometry is
          specified as:  +/-leftedge+/-topedge+/-width+/-height,
          where negative numbers denote values relative to the
          width or height of the screen.  For example, the
          following opens a nearly full-screen window leaving
          10 pixels above, below, to the left, and to the right:

         openwindow +10+10-10-10

          The following opens a window in the upper right hand
          corner of width 320 and height 100.

         openwindow  -320+0+320+100
         openwindow  -320+0-0+100    (same thing)
         openwindow  -320-100-0-0    (lower rght hand corner)

 PAGEDOWN        -pagedown a partial page (see PAGESET)
 PAGESET n       -n PERCENT (0 to 100). page step size relative to the
          current number of rows in the window.
 PAGEUP      -pageup a partial page (see PAGESET)
 PING n      -set a text marker (0-9).
 PONG n      -move to a previously set text marker (0-9)
 PREV        -find previous occurance of search pattern
 PREVR       -find previous occurance and replace
 PUSHMARK        -push the currently marked block onto a stack and
          unhighlight the block
 POPMARK     -pop the block stack and highlight the popped block
 PURGEMARK       -clear the mark stack
 QUIT        -quit
 RECALL      -recall most recently entered command.  Must be used
          from a keymap (c-esc).
 REF         -reference string under cursor (see below)
 REFORMAT        -reformat paragraph using the margin.
 REMEOL      -Remove text under and beyond the cursor.
 REMPATH wild    -Remove one or more symbolic directorys from DME's
          special path... a */? wildcard is acceptable.
 REPEAT cnt comm -SEE BELOW
 REPSTR string   -SET the replace string pattern
 RESETTOGGLE N   -clear toggle array entry N(0..31)
 RESIZE cols rows-Resize current window. E.G:  (resize 70 23)
 RETURN      -same as (FIRST DOWNADD)
 RIGHT       -cursor right
 RX          -ARexx macro, no args   (RX macname)
 RX1         -ARexx macro, one arg   (RX1 macname arg1)
 RX2         -ARexx macro, two args  (RX2 macname arg1 arg2)
 SAVEAS file     -save current text under a different name (title
          line name does not change)
 SAVECONFIG      -save current editor configuration to s:dme.config
 SAVEMAP file    -save user keymappings
 SAVEOLD     -save current text under current name
 SAVESMAP file   -save all keymappings, including system keymaps
 SAVETABS on/off -Optimize file saves by crunching spaces to tabs.
          The default is OFF.
 SCANF ctlstr    -scan the string at the current text position (C scanf)
          example:   (scanf %s)          SEE BELOW
 SCREENBOTTOM    -Move cursor to the bottom of the screen.
 SCREENTOP       -Move cursor to the top of the screen
 SCROLLUP        -Scroll up without moving cursor
 SCROLLDOWN      -Scroll down without moving cursor

 SET var str     -create/modify an internal variable (access w/ $)
 SETENV var str  -create/modify an enviroment variable (1.3 ENV:)
 SETFONT font sz -Set the window's font.  ex:   (setfont topaz.font 11)

 SETPARCOL col   -Set the LEFT margin for word wrap mode paragraphing &amp;
          reformat.  MUST be less than MARGIN.

 SETTOGGLE N     -set toggle array entry N  (0..255)
 SOURCE file     -source a script file. '#' in first column for comment
 SPLIT       -Split line at cursor
 SWAPMARK        -PUSHMARK, swap top two marks on stack, POPMARK
 TAB         -forward tab
 TABSTOP N       -Set tab stops every N.  does not effect text load
 TITLE (title)   -set window title manually
 TLATE [+/-]N    -translate character by +N or -N, or set character
          to exactly N if no + or -. (e.g. TLATE +65 TLATE 3)
 TMPHEIGHT N     -set window height for next window only, pixels
 TMPWIDTH  N     -set window width for next window only,  pixels
 TOGGLE N        -flip toggle array entry N (0..255)  (See IF)
 TOMOUSE     -moves cursor to mouse position
 TOP         -Move to Top of File
 TOPEDGE N       -set topedge in the screen in PIXELS for any new window
 TPEN pen        -set pen for title bar rendering
 UNBLOCK     -clear the block markers for the current window
 UNDELINE        -insert most recently deleted line (only last line saved)
 UNDO        -undo current line (must be mapped to a key to work)
 UNJUSTIFY       -removes extra spaces in a line
 UNMAP key       -unmap a key
 UP          -cursor up
 UNSET var       -delete an internal variable
 UNSETENV var    -delete an enviroment variable
 WHILE cnd act   -(see below)
 WIDTH N     -set width in PIXELS for any new window
 WLEFT       -move to beginning of previous word.  If in the
          middle of a word, move to beginning of current word.
 WORDWRAP on/off/toggle
         -Word Wrap mode (related to MARGIN)
 WRIGHT      -move to beginning of next word


 -------------------------------------------------------------
 -------------    More Info on Complicated Commands  -----------------
 -------------------------------------------------------------

 MENUOFF/ON      -This command will enable/disable menus.  Users
          who have a whole bunch of MENUADD commands in
          their .EDRC should note that disabling menus at
          the beginning will speed up the MENUADD commands.
          Then reenable menus at the end.  These calls are
          stackable in that if you call MENUOFF, say, twice,
          it will take two MENUON commands to restore
          menus.  The reverse is not true.

 CTAGS   (c-[)   -(1.30B and beyond) Compatible with Aztec's CTAGS
          program.  This command searches for the subroutine
          name under the cursor in the associated tags file
          (&quot;tags&quot; in the directory holding the file currently
          being edited).  Also, the file &quot;tags&quot; in directories
          specified by the special DME path (see ADDPATH and
          REMPATH) will be searched.

          If the tag is found, it loads the file the subroutine
          resides in if neccesary, then WindowToFront()'s the
          window, ActivateWindow()s it, and GOTO's the line
          where the subroutine starts.  The search within the
          source file is anchored to the left column.  If the
          file is already loaded, it is not reloaded.

          This enables a programmer to quickly trace subroutines
          over an arbitrary number of files.

          The tags file contains one or more lines of the following
          format:

          subroutine-name file-name /^search-pattern
          (that's a slash and a carrot, then the pattern)

          -- EXAMPLE of 'TAGS' file:
          setpen cmd1.c /^setpen(
          do_up cmd1.c /^do_up(
          --

         SPECIAL NOTE:  CTAGS will work even if you are not in
         the directory containing the file.  You can thus place
         a tags file in the directory containing the files it
         references, and the filenames WITHIN the tags file need
         not be a full path.

 REF     (c-])   -(1.28d and beyond).  This is a very powerful new
          command that allows you to bring up a reference to
          a keyword with a single keystroke.  This is useful for
          programmers who have on-line documentation or fully
          commented include files.  DME opens a window just big
          enough to fit the reference.

          NOTE:  The new CTAGS command may be more suited to
          your application.

          The reference keyword is the alpha-numeric string
          currently under the cursor.  REF will search the
          file DME.REFS in the directories listed by the
          special DME path (see ADDPATH and REMPATH).  The
          file must be built by the user and each line has the
          following format:

          (keyword) (nolines/endstring) (file) (searchstr/##seekpos)

          Surrounding the keywords with `' or () is optional if
          the keyword does not contain spaces.

         keyword     -keyword under cursor
         nolines/ends-either a number (the number of lines
                  in the reference) or a string denoting
                  the end of the reference when found.
         file        -the file containing the reference
                  material
         searchstr/##-search string in file that indicates
                  the beginning of the reference, or
                  two hashes (##) and the seek position
                  in decimal (like ##2343).  The latter
                  method is used mainly for reference-
                  generator programs.

          Upon finding a successful keyword match the specified
          file is openned and the seach string searched for.  If
          a seek position was specified no search is made and a
          seek is made to the beginning of the reference.  If
          found, the indicated number of lines (if a number
          is specified for &#060;nolines/ends&#062;) or until a match with
          the endstring (if a string was specified) will be
          placed in a temporary file and a new DME window
          brought up. The temporary file is then deleted.

          When looking for matches, the compare is anchored at
          the beginning of each line in the file.  Thus, any
          spaces in front of the string in the file must be
          duplicated.

          T: must be assigned to a temporary directory, usually
          RAM:   See the included example DME.REFS file.  The
          most common things referenced are the autodocs and
          commented include files.

          Some modification of the included DME.REFS.* files may
          be required due to differences in include file and
          autodoc format.

 SCANF ctlstr    -This is equivalent to the C scanf() function with the
          restriction that only one conversion is allowed, that
          conversion being a string.  Thus:

          scanf %s       will place the string under the
                 cursor in the variable $scanf

          scanf %4s      The first four chars of the string.

          scanf %[0123456789]
                 will scan the string while it contains
                 specified chars (e.g. scan a number)

          scanf %[~,]    will scan the string until it finds
                 a ','.

         The variable $scanf may be used as an argument in any
         command.  Example:  (insfile $scanf).

         NOTE:  If using $scanf in a macro, you probably want
         to precede it with a  to prevent it from being
         evaluated at macro-creation time.


 REPEAT N arg    -Repeat (arg) N times.  Apart from being a number, N
          can also be one of:

         line    Current line # (lines begin at 1)
         lbot    #lines to the bottom, including current line
         cleft   column # (cols begin at 0)
         cright  #chars to eol, including current char under cursor
         tr  #char positions to next tab
         tl  #char positions to next back tab

         Certain commands can abort a REPEAT loop.
         Specifically, any FIND[R], NEXT[R], or PREV[R] in which
         the search string is NOT found will abort a REPEAT.
         Most operations which can go out of bounds, such as
         UP, LEFT, RIGHT, DOWN, also abort a repeat.

         Specifying -1 as N causes REPEAT to go on forever
         (well, actually, 0xFFFFFFFF times) or until an abort.

 IF [!]condition arg
 WHILE [!]condition arg
 IFELSE [!]condition arg else arg

  If the specified condition is true, execute the argument.  For
  WHILE, the argument is executed until the condition is false
  (be careful!).
   
  the optional '!' inverts the logic.
   
  Conditions:
   
   
  #       if toggle entry # is SET.  there are 256 toggles (0..255)
  t       if On line 1
  b       if On last line
  l       if At column 0
  r       if At end of line (spaces below and beyond)
  m       if Text has been modified
  i       if in insert mode
  x[&#060;=&#062;]# if column position (starts at 1) is (any OR combo of
      &#060;, =, or &#062;) than some number.  Example:   x&#060;=20
  y[&#060;=&#062;]# if Line number (starts at 1) is (same as for x)
  cl      character under cursor is lower case alpha
  cu      character under cursor is upper case alpha
  ca      character under cursor is alpha-numeric
  cn      character under cursor is numeric
  c[&#060;=&#062;]# character under cursor is ascii code # (# in decimal)
          optional conditionals as in 'x' and 'y'.
  cb      cursor within a block
   
 Example: simulating an insert mode toggle: ALT-i (not CTL-i)
   
 map a-i (ifelse 0 (toggle 0 insertmode OFF) (toggle 0 insertmode ON))
   
 Example: while lower case, map to upper case and move right.
   
 map c-U (while cl (tlate -32 right))
   
 Example: Search/Replace all of text.
   
 map c-R (escimm (findstr ) escimm (repstr ) repeat -1 nextr)
   
 if c&#060;32 ((char under cursor is smaller than 32))
 if c&#060;&#062;32 ((char under cursor is not equal to 32))
 while !b down
   
</pre>
</body>
</html>
