<html>
<head>
  <title>dc1 Commands</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="das.html">PREV</a> | <a href="dcc.html">NEXT</a>
<hr>
<pre>

 FUNCTION
 DICE Compiler

 SYNOPSIS
 DC1 cppd_src_file [-o outfile] options

 DESCRIPTION
 DC1 is the compiler itself.  As input it requires a file preprocessed
 by dcpp, and as output it provides assembly code ready for the das
 assembler.  Normally one uses either dcc or VMake as a front end,
 never directly invoking dc1.

 The compiler generates absolute-data references and absolute code
 references by default.  Do not confuse this with DCC's default, which
 is small-data and small-code.

 The compiler will put argument and auto variables into registers
 according to register availability and usage.  It will use
 A0-A1/D0-D1 for register variables whenever possible.  Consequently,
 the most heavily used variables will be in registers even for very
 large subroutines.

 You should get into the habit of declaring automatic variables within
 sub blocks rather than declaring all your autos at the top of the
 procedure. Apart from making the code more modular, this will enable
 the compiler to make better decisions when allocating register
 variables.

 DCC does not do any major contents tracking and redundant
 instructions will be generated.  DAS will handle properly optimizing
 branches and DAS has a peephole optimizer built in it to handle other
 obvious redundancies. The compiler does some optimizations itself,
 such as using bit instructions to handle special cases of &amp;, |, and
 ^, include using BTST.

 || NOTE: volatile forces a data item NOT to be placed in a register.
 || register is treated as a hint only by the compiler.  const is
 || ignored by default but will force objects into the code section
 || given the -ms or -mS options (see below). Other type and storage
 || qualifiers are described in chapter .

 -S
-S0  Set alternate section names &quot;libdata&quot; and &quot;libbss&quot;.

-Sd name  Set section name for data sections

-Sb name  Set section name for bss sections

-Sc name  Set section name for code sections

-SD name  Set section name for __far data sections

-SB name  Set section name for __far bss sections

     The -S option allows you to modify the default section naming
     conventions.  DICE uses data, text, and bss as defaults for the
     data, code, and bss sections.

     The DICE c.lib is compiled with -S and the startup code (c.o)
     references these first to force c.lib's data to come before
     program data.  The data ordering is then as follows:

 1) Library Initialized Data

 2) Program Initialized Data

 3) Library BSS Space

 4) Program BSS Space

 As long as the program does not declare more than 64KBytes of
 initialized data it can be linked with the small-data model c.lib.
 Thus, large-data-model programs that declare more than 64KBytes of
 BSS space will still link with the small-data-model c.lib

 This may be of no consequence because any __far declared data will be
 placed in a different data segment entirely.  Simply declare your
 large arrays as __far and the rest may remain small-data

  -d[#]  Set debug mode.  This isn't pretty, it is primarily used for
     diagnosing potential compiler problems.

 -E file  specify stderr file, any errors are appended to the file instead
     of to stdout. Useful for batch compiles

 -R  Tells the compile to remove (delete) the input file when it no
     longer needs it.  The input file is usually a temporary
     preprocessor file and DCC will use this option to get DC1 to
     delete it as soon as possible.

 -proto  The main compiler will generate errors for any unprototyped
     function call.

 -r  Resident option.  The main compiler will generate special
     autoinit code to initialize data-data relocations.  This
     simplifies the work that DLink and the startup module must do to
     support residentable programs.

 -v  Verbose

 -o outfile
     Specify assembly output file name

    -mc  Small-code model (DCC default)

    -mC  Large-code model (DC1 default)

    -md  Small-data model (DCC default)

    -mD  Large-data model (DC1 default)

    -mw  Absolute-word addressing (overrides -md/-mD)

    -ma  Absolute addressing (no effect on DC1 operation)

     These options specify the memory model.  The small-code model
     uses PC-relative addressing and the small-data model uses
     A4-relative addressing

     -mw is used when making ROMable code and specifies that the
     ABSOLUTE WORD addressing mode be used instead of either absolute
     long or A4-relative.  Absolute word addresses are resolved at
     link time.

     || NOTE: This option should not be used when generating
     || executables meant to run on the Amiga.

   -ms0  (default) const is ignored

    -ms  string constants and const objs placed in code section

    -mS  string constants and const objs placed in code section

     These options control how const data items are handled, including
     string constants such as char *ptr = &quot;abcd&quot;; The default is to
     ignore the const type qualifier.

     If -ms is specified string constants and const data items are
     placed in the code section.  Local references to const data items
     use PC-RELATIVE addressing.  Remote references (from other
     modules) to const data items use ABSOLUTE LONG addressing.

     -mS works the same as -ms but remote references are forced to use
     PC-RELATIVE addressing.

     || NOTE: This can be dangerous and the final CODE size MUST BE
     || LESS THAN 32KBYTES!

     Usually it is safe to use -ms and, in fact, can save a lot of
     memory when combined with -r residentable programs because the
     string constants will not be duplicated for each running instance
     of the program.

 SEE ALSO
 dcc, dcpp, dlink

</pre>
</body>
</html>
