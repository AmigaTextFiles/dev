<html>
<head>
  <title>qsort command</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="system.html">PREV</a> | <a href="rand.html">NEXT</a>
<hr>
<pre>

 <b>qsort</b>

 NAME
  qsort  - sort an array of objects

 SYNOPSIS
  #include &#060;stdio.h&#062;
  #include &#060;stdlib.h&#062;

  (void) qsort(array, numElem, elemSize, compare_func)
  void *array;
  size_t numElem;
  size_t elemSize;
  int (*compare_func)(const void *arg1, const void *arg2);

 FUNCTION
  qsort sorts numElem elements in an array based at 'array'.  Each
  element is elemSize bytes long.  When a comparison is required,
  qsort calls the passed compare_func function pointer with a
  pointer to the two elements being sorted.

  DICE currently implements qsort with a simple merge sort algorithm,
  using relatively slow movmem()s to avoid having to allocate much
  additional storage.  Very little stack is used.  Traditional
  qsort uses a stack based quick-sort algorithm that might use a
  massive amount of stack.

 EXAMPLE
  #include &#060;stdio.h&#062;
  #include &#060;stdlib.h&#062;

  char *StrList[6] = {
      &quot;fubar&quot;,
      &quot;able&quot;,
      &quot;yum&quot;,
      &quot;quack&quot;,
      &quot;rigger&quot;,
      &quot;battle&quot;
  };

  my_comp(s1, s2)
  char **s1;
  char **s2;
  {
      return(strcmp(*s1, *s2));
  }

  main()
  {
      short i;

      qsort(StrList, 6, sizeof(char *), my_comp);
      for (i = 0; i &#060; 6; ++i)
      printf(&quot;%d %sn&quot;, i, StrList[i]);
      return(0);
  }

 INPUTS
  void *array;        pointer to base of array of objects

  size_t numElem;     number of elements in the array

  size_t elemSize;    Size, in bytes, of each element

  int (*compare_func)()   function pointer to compare function given
              pointers to two of the elements

 RESULTS
  None



</pre>
</body>
</html>
