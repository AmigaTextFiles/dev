<html>
<head>
  <title>all printf varient (and lets face it there are loads) commands</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="fopen.html">PREV</a> | <a href="fgetc.html">NEXT</a>
<hr>
<pre>

 printf
 fprintf
 sprintf
 vprintf
 vfprintf
 vsprintf

 NAME
  printf - formatted output to stdout, file pointer, or buffer

 SYNOPSIS
  #include &#060;stdio.h&#062;
  #include &#060;stdarg.h&#062; /*  v[f/s]printf() only */

  int n = printf(fmt, ...);
  int n = fprintf(fp, fmt, ...);
  int n = sprintf(buf, fmt, ...);
  int n = vprintf(fmt, argvect);
  int n = vfprintf(fp, fmt, argvect);
  int n = vsprintf(buf, fmt, argvect);

  FILE *fp;
  char *fmt;
  char *buf;
  va_list argvect;

 FUNCTION
  These various connotations offer formatted printing.  printf and
  vprintf output to stdout; fprintf and vfprintf output to a
  file pointer (fp); sprintf and vsprintf output to a character
  buffer.

  All routines return the number of characters written if successful,
  a negative number if not.  Only sprintf and vsprintf is limited
  in terms of output size (it cannot exceed the buffer you give it).

  The common argument to all routines is the format specifier.  The
  format specifier is scanned to determine how to handle the arguments
  to the call (or the arglist for v*printf connotations).  Characters
  are copied to the output until a % is encountered.  %% indicates a
  literal '%' character.  Otherwise, the % is followed by a control
  sequence that tells printf how to output an argument quantity.  The
  quantity is output and the scan continues until the end of the
  format string.

  The % format is as follows:

      %[flags][#[.#]][modifier]&#060;conversion-specifier&#062;

  Items in brackets are option.  After the % zero or more flags may
  be specified.  Then, an optional integer which represents the
  minimum field width for the object.  If an integer is specified
  it may be followed by a period and another integer that represents
  that precision with which a number is printed.  Zero or more
  modifiers may then be specified followed by a mandatory conversion
  specifier.

  Either or both integers (#[.#]) may be specified as a '*', as in
  &quot;%*d&quot;, specifying that the minimum field width and/or precision
  is specified as an integer in the argument that occurs before
  the conversion object.  For example, printf(&quot;x%*dxn&quot;, 10, 23);
  would print the number 23 right justified in a field 10 characters
  wide.

  FLAGS:
  -     left justify text within its field, otherwise output is right
        justified

  +     precede a signed number with a plus sign if it is positive
        (negative numbers are always preceeded with a minus sign)

    &#060;space&#062; precede a positive signed number with a space so the number's
        width matches that of itself if it were negative.

  #     forces numeric data items to be formatted such that their type
        is known.  The following effects occur given a conversion
        specifier:

          e, E, f, F      always retains decimal point

          g, G     always retains decimal point and trailing zeros are kept

          x, X        prints '0x' and '0X' respectively before the number

        (current not implemented by DICE)

  0     pad with zeros instead of spaces.  Ignored if a precision
        is specified or if the '-' flag is specified.

        (currently partially implemented by DICE)

  MODIFIERS

  h     Indicates the corresponding integer argument is a short or
        an unsigned short.

        under DICE, this has no effect since integers are 32 bits

  l     Indicates the corresponding integer argument is a long or
        unsigned long.  Indicates floating point argument is a
        double (else is a float)

        under DICE, for integers, this is superfluous, but for
        portability reasons you want to specify it when an argument
        is explicitly a long.

  L     Indicates the corresponding floating point argument is a
        long double (16 byte quantity)  (currently not implemented
        by DICE)

  CONVRSION SPECIFIER

  c     Output the character represented by the integer quantity

  d     Output a signed integer

  e     Output a double quantity in exponential form, the format:
        The precision specifies the number of digits beyond the
        decimal point to print

          [-]d.dddddde+/-dd

  E     e conversion but use upper case E in exponent:  E+/-dd

  f     Output a double quantity in the form:  The precision specifies
        the number of digits beyond the decimal point to print

          [-]d.dddddd

  g     Output a double quantity using either the 'e' or 'f' form,
        depending on the exponent.

  G     Output a double quantity using either the 'E' or 'f' form,
        depending on the exponent.

  i     same as 'd'

  n     The argument is a pointer to an integer which is used to
        set the integer to the bytes written out so far.  This is
        especially useful with sprintf to determine where a particular
        part of the format begins in the output buffer.

  o     The unsigned integer quantity is converted to ascii-octal

  p     The pointer is printed (basically the address is printed)

  s     The string represented by the character pointer is printed

  u     The unsigned integer quantity is converted to ascii-decimal

  x     The unsigned integer quantity is converted to ascii-hex using
        '0'-'9', 'a'-'f'.

  X     The unsigned integer quantity is converted to ascii-hex using
        upper case A-F instead of lower case.

 EXAMPLE
  /*
   *  Example use of most conversion specifiers.  Compile -lm to
   *  get the math pfmt.
   */

  #include &#060;stdio.h&#062;
  #include &#060;stdarg.h&#062;

  void gagprint();

  main()
  {
      char buf[256];
      int i;
      int n;

      n = printf(&quot;ab%c %03d %le %lf %2.2lf %n%o %p %sXX %u %x %X %08lxn&quot;,
      'c',                /*  %c      -&#062; 'c'      */
      43,         /*  %03d    -&#062; '043'    */
      1.23E-2,
      1.23E-2,
      1.257,          /*  %2.2lf  -&#062; 1.26     */
      &amp;i,
      11,         /*  %o  -&#062; '13'     */
      buf,            /*  %p  -&#062; &#060;hex-ptr-addr&#062;   */
      &quot;FuBar&quot;,
      32094,          /*  %u  -&#062; 32094    */
      4095,           /*  %x          */
      4095,           /*  %X          */
      4095            /*  %08lx           */
      );
      printf(&quot;%d chars writtenn&quot;, n);

      n = printf(&quot;%*s%sn&quot;, i, &quot;&quot;, &quot;^Octal Number&quot;);
      printf(&quot;%d chars writtenn&quot;, n);

      n = sprintf(buf, &quot;FuBar%s&quot;, &quot;Bletch&quot;);
      puts(buf);
      printf(&quot;%d chars writtenn&quot;, n);

      n = fprintf(stdout, &quot;This is an fprintfn&quot;);
      printf(&quot;%d chars writtenn&quot;, n);

      gagprint(&quot;%d %d %dn&quot;, 1, 2, 3);
      return(0);
  }

  void
  gagprint(ctl, ...)
  char *ctl;
  {
      va_list va;
      int n;

      va_start(va, ctl);
      n = vprintf(ctl, va);
      printf(&quot;%d chars writtenn&quot;, n);
      va_end(va);
  }

 INPUTS
  FILE *fp;       file pointer (fprintf, vfprintf)
  char *fmt;      format string, e.g. &quot;Answer is %dn&quot;
  char *buf;      buffer (sprintf, vsprintf)
  va_list argvect;    arg list (vprintf, vfprintf, vsprintf)

 RESULTS
  int n;          number of characters written if successful,
              a negative number if not.  for sprintf and
              vsprintf the nul character at the end of the
              string is NOT included in the count.

 SEE ALSO
  puts, fputs, fwrite


</pre>
</body>
</html>
