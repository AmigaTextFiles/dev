<html>
<head>
  <title>The DICE 3.xx Clib Documentation</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="dice_index/main.html">INDEX</a> | <a href="dice.guide/clib.html">PREV</a> | <a href="dice.guide/clib.html">NEXT</a>
<hr>
<pre>


    <b>CLIB/Amiga Documentaion</b>

    <b>Signaling Documents</b>
    c.lib/signal/signal
    c.lib/signal/<a href="raise.html">raise</a>


 <b>signal</b>

 NAME
 signal  - set a signal vector for a signal

 SYNOPSIS
 typedef void (*__sigfunc)(int);

 __sigfunc oldfunc = signal(signo, newfunc)
 int signo;
 __sigfunc newfunc;

 FUNCTION
 signal() sets a signal vector function for a given signal number as
 defined in &#060;signal.h&#062; and returns the previously set function.

 currently only SIGINT causes any semi-asynchronous action to occur.
 You may pass newfunc as your own signal function or one of:

 SIG_ERR     error (exit program)
 SIG_DFL     default (for break, normal operation)
 SIG_IGN     ignore signal (for break, ^C is now ignored)

 when a signal occurs, the signal is set back to its default
 condition before the handler is called.  Thus, if you are allowing
 multiple signals to occur you MUST restore the signal vector
 with signal() from your signal handler before it returns.

 NOTE
 signal()s on the Amiga are not truely asynchronous.  Currently
 ^C is detected during stdio calls only.  No other signal is
 implemented though you *can* modify any signal vector 0 to 31
 and raise it with the raise() call.

 Early versions of DICE, including quite possibly this version,
 do not understand complex type declarations containing
 procedural types.  Thus, you may have to get around the problem
 by building up a complex procedural type with typedefs.

 Unlike onbreak(), a signal function returns no value.

   EXAMPLE
    #include &#060;signal.h&#062;

    void brkfunc(int);

    main()
    {
        short i;

        puts(&quot;The following is unbreakable&quot;);
        sleep(1);
        signal(SIGINT, SIG_IGN);
        for (i = 0; i &#060; 100; ++i)
        printf(&quot;1 %dn&quot;, i);

        puts(&quot;The following may be broken out of&quot;);
        puts(&quot;with a cute message&quot;);
        sleep(1);
        signal(SIGINT, brkfunc);
        for (i = 0; i &#060; 100; ++i)
        printf(&quot;2 %dn&quot;, i);

        puts(&quot;The following may be broken out of&quot;);
        sleep(1);
        signal(SIGINT, SIG_DFL);
        for (i = 0; i &#060; 100; ++i)
        printf(&quot;3 %dn&quot;, i);
        puts(&quot;Hey! You never hit ^C!  What kind of test is this!&quot;);
        return(0);
    }

    void
    brkfunc(int signo)
    {
        printf(&quot;signo %d occured, exitingn&quot;, signo);
        exit(1);
    }

 INPUTS
  int   signo;    signal to modify, usually SIGINT
  __sigfunc newfunc;  signal function or SIG_ERR, SIG_DFL, SIG_IGN

 RESULTS
 __sigfunc oldfunc;  previous signal function




 <b>raise</b>

 NAME
 raise  - raise a signal (cause an 'interrupt' synchronously)

 SYNOPSIS
 int r = raise(signo);
 int signo;

 FUNCTION
 raise() causes a signal to occur and the appropriate action to be
 taken.  raise() returns 0 on success, -1 if the signo is invalid
 (outside the range of allowed signals).

 when you raise a signal, the signal is set back to its default
 vector before the handler is called.  Thus, if you are allowing
 multiple signals to occur you MUST restore the signal vector with
 signal() from your signal handler before it returns.

 EXAMPLE
    /*
     *  prints the numbers 0 to 99, except only gets to 50 because
     *  we 'cause' a ^C.
     */

    #include &#060;signal.h&#062;

    main()
    {
        short i;

        for (i = 0; i &#060; 100; ++i) {
        printf(&quot;i = %dn&quot;, i);
        if (i == 50)
            raise(SIGINT);
        }
        return(0);
    }

   INPUTS
    int   signo;    signal to cause

   RESULTS
    int   r;        0 on success, -1 if signo is out of range.

   SEE ALSO
    <a href="signal.html">signal</a>

</pre>
<hr>
<address>Converted using <tt>GuideML</tt> V1.6, a converter written by Richard K&ouml;rber &#060;<a href="mailto:shred@chessy.aworld.de">shred@chessy.aworld.de</a>&#062;</address>
</body>
</html>
