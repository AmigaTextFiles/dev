<html>
<head>
  <title>DICE 3.xx ANSI Compatability</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="comments.html">PREV</a> | <a href="first_prog.html">NEXT</a>
<hr>
<pre>

                       <b>COMPATIBILITY COMMENTS</b>

<b>ANSI C</b>

With structural returns and auto-aggregate is implemented, DICE is now
95% ANSI compliant.  Known differences are described in the KNOWNBUGS
document.

I spent a great deal of time ensuring that STDIO routines run
relatively fast.  I decided to write nearly all of the support library
in C instead of falling back to optimized assembly to keep the system
uniform and portable.  One does not notice much of a difference between
the C strcpy() and an assembly strcpy() relative to the run time of
their program.

<b>AMIGA</b>

As said in feature (7), if you wish your program to be runnable from
the workbench you must supply a wbmain() entry point.  If you do not
then running the program from the workbench will result in its
immediate termination (e.g. nothing happens).  On return from wbmain()
or exit() the workbench message is automatically ReplyMsg()d by the
exit code.

DICE separates workbench startup and puts it in the hands of the user
to simplify the user's code.  Since there are two entry points,
main() for CLI run programs and wbmain() for WORKBENCH-run programs,
the programmer can more easily modularize his code.

The Registered release of DICE supports the __near, __far, and __chip
keywords.

<b>UNBUFFERED CONSOLE IO</b>

You may set a console to RAW mode using the setbuf() and setvbuf() calls.
You may set a console back to COOKED mode using the same calls.

</pre>
</body>
</html>
