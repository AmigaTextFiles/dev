<html>
<head>
  <title>Errors C1:000 - C1:120</title>
  <meta name="Generator" content="GuideML V1.6">
  <meta http-equiv="Content-Type" content="text/html">
</head>
<body>
<a href="main.html">CONTENTS</a> | <a href="dice_index/main.html">INDEX</a> | <a href="main.html">PREV</a> | <a href="cp.html">NEXT</a>
<hr>
<pre>

 C1:001,C1:002,C1:003,C1:004,C1:006

 __autoinit, __autoexit, __geta4, __chip, floating point
 -------------------------------------------------------
 These error messages should only occur if you are using the freeware
 release, and attempt to use features not supported in that limited
 version.

 C1:009

 Unexpected EOF
 --------------
 The source or header file ended abruptly, for example ending in the
 middle of a quoted string or macro.

 C1:010

 Char Const Too Large!
 ---------------------
 Only 4 characters are allowed within a character constant, more than
 four, such as 'abcde' will generate this error.

 C1:011

 NewLine in string constant
 --------------------------
 A newline occurs within a string constant, such as the next two
 lines:

 &quot;abcd
 efgh&quot;

 This is not legal under ANSI C. Instead, you can create a single
 large string using &quot;string1&quot; &quot;string2&quot; ... two sets of quoted strings
 with no delimiter, putting them side by side or on separate lines as
 you like.

 C1:012

 Illegal character '%c' $%02x
 ----------------------------
 Certain characters are illegal. One example is '#', when not part of
 a preprocessor directive:  int x= 43#.

 C1:013

 Unexpected Token '%s' expected '%s'
 -----------------------------------
 The expected token wasn't the one we got! The error message tells you
 what the character was and what was expected.  This is normally
 indicative of mismatched parenthesis or a semi-colon inside a
 subroutine call that expected commas or a close parenthesis.  Most
 full featured prograzmmer's editors can match braces (ie. find a
 matching } for every {) to help track these errors down.

 C1:014

 __geta4 keyword does NOT work with residentable executables!
 ------------------------------------------------------------
 __geta4 requires the base of the data to be at a known absolute
 relocatable location. You cannot use __geta4 in conjunction with -r
 because residentable code allocates its data segment at run time.
 Keep in mind that in the most common situation where you might get
 such an error -- writing shared libraries and devices, making the
 program resident would not buy you anything anyway.  The other common
 situation where you would need to use __geta4 -- Amiga shared library
 callbacks, currently requires you to not make such executables
 residentable.

 C1:015

 More than 32K of auto variables!
 --------------------------------
 DICE accesses all stack variables using word-register-relative, thus
 no more than 32KBytes worth of stack variables may be declared.

 C1:016

 Unsupported return type
 -----------------------
 You attempted to return a type that is currently unsupported.  Since
 all return types including structural returns are now supported, you
 should not get this error message.  Getting this error message would
 most likely be due to a bug in DICE.

 C1:017

 constant does not fit storage: %d
 ---------------------------------
 DICE will, in some cases, catch the use of constants that are out of
 range in a particular situation. For example, specifying the constant
 '128' in relation to a signed character (-128 to 127).

 DICE checks constant-fit only in hazzardous situations such as in a
 switch().

 C1:018

 size mismatch: %d, %d
 ---------------------
 This is a code generation error which can occur when you compare or
 run operations on incompatible types.  This error occurs when high
 level routines in the compiler fail to detect a problem with your
 source.

 C1:019

 repeated case: %d (0x%08lx)
 ---------------------------
 The specified case, given in both decimal and hex, occurs more than
 once within a switch statement.

 C1:020,C1:021

 block operation error in source, block operation error in dest
 --------------------------------------------------------------
 Generally means that either the source or the destination of a
 block-op, such as a structure assignment, are incompatible. For
 example:

 foo = bar;

 where foo has a different structure type than bar. Generally this
 error is preceeded by an &quot;illegal assignment&quot; error.

 C1:022

 dest not lvalue
 ---------------
 Generally occurs if the object of an assignment is not assignable
 (&quot;lvalue means modifiable value). However, note that DICE is notably
 weak in this area. It will cheerfully allow you to do things like (a
 + b) = c + d;, obviously illegal.

 C1:023

 syntax error in expression
 --------------------------
 A General syntax error in an expression occured. Usually occurs due
 to an illegally constructed expression, such as:

 a ] b;

 can also occur due to too few parenthesis.

 C1:024

 expected expression
 -------------------
 An expression was expected when, instead, either nothing or a
 statement was found. This can also occur due to a syntax error in the
 expression.

 C1:025

 expected '}'
 ------------
 A close brace was expected, for example, a global declaration such
 as:

 int a[] = { 1, 2, 3;

 C1:026

 expected %d close parens
 ------------------------
 Expected one or more close parenthesis in an expression.

 C1:027

 expected close bracket
 ----------------------
 Expected a close bracket ']', generally caused by an incomplete array
 index such as a[i = 4;

 C1:028

 expected identifer after . or -&#062;
 --------------------------------
 A structure indirection via '.' or '-&#062;' requires a structure member
 to be specified. i.e. a field MAJOR HEADING.

 C1:029

 expected ',' or ')' in function call
 ------------------------------------
 Expected a delimiter in a function call. Either comma if another
 argument is to be given, or a close parenthesis to end the function
 call.

 C1:030

 undefined symbol: %s
 --------------------
 The given symbol is not defined. For example, referencing a variable
 that was not defined or extern'd.

 C1:031

 expected integer constant
 -------------------------
 An integer constant was expected, generally occurs when you declare
 an array. For example, the following is illegal: int i[j];

 C1:032

 not an lvalue
 -------------
 Occurs when an lvalue was expected, usually in an assignment. An
 lvalue is an expression which exists in real storage, for example:

 *ptr = 4;

 the expression '*ptr' points to real storage where as the expression
 (a + b) in;

 (a + b) = 4;

 does NOT.  Note that DICE is not very good at catching lvalues errors
 yet.

 C1:033

 goto label not found: %.*s
 --------------------------
 The label that was given as a target for a goto statement was not
 found anywhere in the procedure.

 C1:034

 constant div/mod by 0
 ---------------------
 You attempted to use the '/' or '%' operator with the constant value
 0 on the right hand side. Division/Modulus by 0 is illegal.

 C1:035

 ptr-ptr mismatch: type %s
 -------------------------
 Generally occurs in a pointer comparison or assignment. The two
 pointers do not point to the same type. Example,

 char *a; long *b; if (a &#060; b);

 The error message indicates the type of the pointer that you are
 attempting to use.  This is typically followed by an error C1:115
 which contains the type that was expected.

 C1:036

 unexpected void type
 --------------------
 Occurs due to an illegally constructed expression where the result
 storage is void.

 C1:037

 result not used
 ---------------
 This warning occurs in some cases where an expression has been
 calculated but the result ends up not being used.  For example:

 a &#060;= 4;

 C1:039

 &amp; of bitfield illegal
 ---------------------
 It is not legal to take the address of a bitfield element in a
 structure since no pointer representation is possible.

 C1:040

 indirection through non-ptr
 ---------------------------
 Example: int a; *a = 4; ... i.e. where 'a' wasn't a pointer. Will
 also occur if you attempt to index a variable which is not an array
 or pointer, i.e. a[4] = 4; where 'a' is an integer instead of an
 array/pointer.

 C1:041

 must #include &#060;alloca.h&#062; for alloca
 -----------------------------------
 DICE requires a special alloca. To obtain it any modules that use
 alloca() must #include &#060;alloca.h&#062; which redefines it properly.

 C1:042

 left hand side of assignment is not a procedure
 -----------------------------------------------
 You attempted to make a procedure call, such as foo(23); where foo is
 not a procedure. Example:

 int foo;
 ...
 foo(23);

 This can occur if you accidently declare a variable whos MAJOR
 HEADING is the same as a procedure you attempt to call.

 C1:043

 unprototyped call
 -----------------
 When the -proto option to DCC is used, any procedure call which is
 not prototyped will generate this error.

 C1:044, C1:045

 too few parameters in call, too many parameters in call
 -------------------------------------------------------
 For prototyped procedures, the number of arguments is generally
 known. DICE will print these warnings if you make a procedure call
 with too few or too many arguments.

 C1:046

 not structure or union type
 ---------------------------
 An attempt was made to indirect through a structure or union where
 the left hand side was not a structure or union type.

 C1:047

 maximum auto storage for temporaries exceeded
 ---------------------------------------------
 DICE tracks stack temporaries, mainly for floating point. If DICE's
 maximum number of temporaries is exceeded due to an overly complex
 expression, this error will be given.  You should try breaking up the
 code into smaller chunks.

 C1:048

 register not allocated: %d
 --------------------------
 This is generally an indication of a software error within DC1 if not
 preceeded by other error messages.

 C1:049

 expected integer type
 ---------------------
 An integer type was expected but instead a non-integer type was
 found. For example, trying to use a float to index an array.

 C1:050

 illegal ptr arithmatic
 ----------------------
 This error generally occurs when you do something illegal with a
 pointer. For example, while 'ptr - i' is valid, 'i - ptr' is not.
 While you can subtract two pointers 'p1 - p2', you cannot add two
 pointers 'p1 + p2'.

 C1:051,C1:052

 illegal ptr conversion, illegal structure conversion
 ----------------------------------------------------
 These errors generally occurs when you attempt to cast a structure to
 a pointer or vise versa.

 C1:053

 illegal cast
 ------------
 A catch all for casts that DICE does not understand, such as
 converting integers into arrays.

 C1:054

 ptr-int conversion
 ------------------
 Generally occurs when DICE is forced to convert a pointer to an
 integer, for example when making a procedure call and passing a
 pointer when the procedure expected an integer.

 C1:055

 illegal int conversion
 ----------------------
 It is illegal to convert an integer to a structure or vice-versa,
 generally the error occurs through an explicit cast.

 C1:056

 int-ptr conversion
 ------------------
 Generally occurs when DICE is forced to convert an integer to a
 pointer, for example when making a procedure call and passing an
 integer when the procedure expected a pointer.  The most common
 problem related to this is not having #include'd the appropriate
 prototypes for various Amiga library calls or for your own routines.

 C1:057

 int/ptr mismatch
 ----------------
 Generally occurs when you compare two unlike types (an integer and a
 pointer).

 C1:058

 illegal or incompatible structure operation
 -------------------------------------------
 When you assign structures to each other they must be of the same
 type and size. May also occur if you accidently assign a structure to
 a non-structure or vice-versa.

 C1:059

 illegal assignment
 ------------------
 The assignment is illegal. Usually occurs if you attempt to assign a
 field in a structure in the structure definition, like:

 struct foo {
     int x = 4; /* huh ?? */
 };

 C1:060

 illegal ptr-int or int-ptr conversion, int-size != ptr-size
 -----------------------------------------------------------
 This is catch-all for programs that convert between pointers and
 integers and vice-versa. You can only convert an int or long to a
 pointer and back in DICE. Converting to or from a short is illegal.

 C1:061

 illegal bit-field operation
 ---------------------------
 The bitfield operation is not legal. Generally occurs when you
 attempt to declare a bitfield not part of a structure or union.

 C1:062

 illegal compare
 ---------------
 Generally occurs when you attempt to compare two structures. You can
 only use == and != when comparing structures.

 C1:063

 undefined structure tag: %s
 ---------------------------
 Generally occurs when you attempt to reference a field in a structure
 which has yet to be defined.  Note that it is perfectly legal to
 declare pointers to undefined structures as long as you do not
 attempt to reference a field in the structure.

 The error message indicates the structure tag that was not found.

 C1:064

 undefined struct/union field: %s
 --------------------------------
 The specified field does not exist in the structure definition.

 C1:065

 ran out of memory
 -----------------
 DICE ran out of memory. The README file outlines possible steps to
 take ranging from making fewer things resident to specifying a
 temporary directory on your HD instead of in T: (usually assigned to
 RAM:). The best work around is to split up large source files into
 smaller ones.

 C1:066

 fp constant string too long!
 ----------------------------
 A floating point constant is too long (&#062; 128 digits). DICE can only
 handle so much.

 C1:067

 fp constant too large to convert to int
 ---------------------------------------
 The fp constant is less than -0x80000000 or larger than 0x7FFFFFFF
 and thus cannot be converted to an integer.

 C1:068

 expected semicolon
 ------------------
 A semicolon was expected. For example:

 int a&#060;--- oops
 int b;

 Generally occurs when something unexpected happens, a semicolon is
 not always the correct solution. For example, can occur if you have
 too many close braces.

 C1:069

 illegal type/storage qualifier for variable
 -------------------------------------------
 The type or storage qualifier is illegal for this variable
 declaration.

 C1:070

 illegal typedef
 ---------------
 The typedef is illegal.

 C1:071

 multiply defined procedure
 --------------------------
 You have defined a procedure (definition means procedure declaration
 with { ... code ... }) more than once in the same source file.

 C1:072

 type too complex
 ----------------
 Occurs if a type is too complex for DICE to handle. For example, DICE
 cannot deal with an array with 32 dimensions.

 C1:073

 syntax error in declaration
 ---------------------------
 This is a very general error that indicates that DICE no longer
 understood what you were trying to compile.  If there are any other
 previous errors, they could have cascaded to the point of confusion.
 Otherwise, the problem should be at the error position or immediately
 before it.  Note that sometimes an error in a #include file sometimes
 does not show up until immediately after the end of the file.

 C1:074

 enum identifier overides variable/type
 --------------------------------------
 Occurs if you create an enum identifier that overides an existing
 typedef or variable.  While enum's are supposed to be in a separate
 domain, this is one of the areas in which DICE is not totally ANSI.

 C1:075

 id missing in procedure declaration
 -----------------------------------
 You have made a procedure definition, probably using the ANSI
 procedure definition style, but forgotten to specify an identifier
 for one of the arguments.  Only procedure REFERENCES may leave off
 the identifier.

 void fubar(int) {...} /* not ok in definition    */

 void fubar(int);      /*  ok in prototype */

 C1:076

 procedure id decl not in id list
 --------------------------------
 This occurs if you declare a procedure with arguments old style and
 mistakenly declare a variable that wasn't specified in the identifier
 list.

 int fubar(a,b,c)
 int a, b, c, d;
 {
 }

 Note that the variable 'd' did not exist in the id list.

 C1:077

 statement's condition must be an expression
 -------------------------------------------
 RETURN, IF, DO and WHILE require an expression or nothing. The middle
 argument for FOR() requires an expression. Whatever you gave the
 compiler, it wasn't an expression.

 C1:078

 duplicate default: in switch
 ----------------------------
 You have more than one default: statement in a switch.

 C1:080

 expected '{' or '}' for procedure def
 -------------------------------------
 Just a more specific error message to the general syntax error. There
 is something wrong with your procedure definition, DICE expected an
 open brace and then the procedure but didn't see an open brace.

 C1:081

 case/default outside switch
 ---------------------------
 with DICE, the case and default statements must be on the same
 semantic level as the switch() { ... } even though ANSI says they can
 be in lower levels. At least for now. The other common cause is if
 you really do have a case or default statement outside of the switch
 statement.

 C1:082

 else without if
 ---------------
 You have an ELSE statement not associated with any IF statement. The
 most common mistake is when you accidently put two statements in
 between an IF and an ELSE without using braces, like this:

 if (i == 0)
     i = 1; j = 2; /* wrong, need braces if */
           /* more than one stmt    */
 else
 i = 3;

 Which more commonly occurs if you use #define macros heavily.

 C1:083

 too many initializers
 ---------------------
 This error will occur if you specify more initializers in a structure
 assignment then the structure has fields.  For example:

 struct { int a, b; } Fu = { 1, 2, 3 };
 /* where's the 3 go? */

 C1:084

 array cannot hold string
 ------------------------
 This error will occur if you declare an array and initialize it to a
 string that is larger then the array.  Note that the special case
 where the string's nil terminator is just outside the array is
 allowed (the nil terminator is ignored).

 char Fu[3] = { &quot;abcd&quot; };

 C1:085

 illegal register specification
 ------------------------------
 This error occurs if you specify more then one register for a
 procedure argument.  E.G.  void fubar(__D0 __D1 int a) { ... }

 C1:086

 Variable not used: %*.*s
 ------------------------
 This warning informs you of variables which you have declared but not
 referenced.

 C1:087

 Illegal return type
 -------------------
 This error indicates that you have attempted to return a type which
 is incompatible with the return type of the procedure.  For example,
 returning an integer from a procedure which is supposed to return
 void.

 C1:088

 Warning, SAS/C __qualifier placement
 ------------------------------------
 DICE attempts to be somewhat SAS/C compatible in terms of type
 qualifier placement but, frankly, SAS/C is too wierd in some
 respects.  With DICE, extensions normally occur BEFORE the type MAJOR
 HEADING while in SAS/C they normally occur AFTER the type MAJOR
 HEADING.  DICE will accept SAS/C qualifier placement and issue this
 warning, but note that in this particular case multiple declarators
 separated by commas will not work using SAS/C qualifier placement:

 int __chip a, b; /*DOESN'T WORK, ONLY A in CHIP*/

 __chip int a, b; /*OK,  BOTH A &amp; B ARE IN CHIP  */

 You should also note that DICE accepts __asm, simply ignoring it, and
 also ignores the register qualifier with explicit register
 specifications.  That is:

 long fubar(__D0 int a) ...   /* DICE METHOD  */

 long fubar(a)            /* DICE METHOD  */ __D0 int a;
 {
 ...
 long __asm fubar(register __d0 int a)
 ... /* SAS/C */

 DICE will accept the SAS/C registered args procedure format in the
 MAJOR HEADING of portability but it's unreadable.

 C1:089

 BREAK outside of loop/switch
 ----------------------------
 The BREAK statement normally breaks out of the nearest switch, do,
 for, or while statement.  If you are not within any of those
 constructs there is nowhere to BREAK to and this error message will
 occur.

 C1:090

 CONTINUE outside of loop
 ------------------------
 The CONTINUE statement normally continue's to the nearest do, for, or
 while statement (note that switch() statements are skipped).  If you
 are not within a loop statement then CONTINUE has nowhere to go and
 this error message occurs.

 C1:091

 Cannot take the address of a constant
 -------------------------------------
 You cannot take the address of a constant.  E.G. int *a = &amp;4;  ...
 what is that supposed to mean?  If you code structures to constant
 addresses remember to cast the constant addresses as pointers.

 C1:092

 Cannot passed unaligned structs by value
 ----------------------------------------
 The __unaligned storage qualifier is meant for certain very rare
 situations where you do not want structures to be word aligned.
 Unfortunately, DICE is not able to perform all possible operations on
 such structures and passing them by value is one of those operations.
 You can pass a pointer to the structure just fine, just not by value.

 C1:093

 Prototype required for inline call
 ----------------------------------
 Inline library calls are generally implemented by #include'ing the
 appropriate prototype file.  The DICE method is to #include the
 appropriate file in clib/, e.g. &#060;clib/exec_protos.h&#062;.  DICE will find
 &quot;dinclude:clib/exec_protos.h&quot; first which then declares the #pragma's
 and finally includes the commodore protos,
 &quot;dinclude:amiga20/clib/exec_protos.h&quot;.  This error occurs if a
 #pragma has been found for a routine but no ANSI prototype.  DICE
 requires an ANSI prototype as well as a #pragma to be able to make an
 inline library call.

 C1:094

 Input must be a seekable file
 -----------------------------
 DICE must be able to seek around the input file.  This error occurs
 if, for example, you specify a pipe as the input file instead of a
 disk file.

 C1:095

 Can't open %s
 -------------
 DICE is unable to open the specified file

 C1:096

 Read failed
 -----------
 DICE is able to open the file but Read() failed unexpectedly.

 C1:097

 Can't open output %s
 --------------------
 DICE is unable to create either a temporary output file or your
 specified output file, depending on what it is doing.  For example,
 if you compile a source file into an object DICE can give this error
 while attempting to create the temporary assembly (.a) file before
 assembling it into your object.

 C1:098

 Incorrect type for indirection
 ------------------------------
 You can only indirect (the unary '*' operator) through a pointer.

 C1:099

 Base variable (%.*s) for pragma is undefined
 --------------------------------------------
 DICE has found a subroutine call for which a #pragma statement is
 present, but the library base for the #pragma statement is missing.
 Typically this will occur when you #include the pragma file directly
 without including the prototypes or library definition as in:

 #include &#060;pragmas/exec_pragmas.h&#062;
 ...
 Disable();

 To solve the problem, you should #include the corresponding clib file
 like:

 #include &#060;clib/exec_protos.h&#062;

 C1:100

 sizeof(type) is 0
 -----------------
 The size of the type passed to sizeof is zero bytes long.  Typically
 this occurs when you take the size of an undefined structure tag or
 the sizeof a void.

 C1:101

 Duplicate variable/symbol in same {} block: %.*s
 ------------------------------------------------
 This occurs when you have two variables in the same block which have
 the exact same MAJOR HEADING (usually as the result of a cut/paste
 operation).  Simply reMAJOR HEADING one of the variables (or delete
 the duplicated line).

 C1:102

 Variable declared but not used: %.*s
 ------------------------------------
 This warning identifies a variable which is not referenced within the
 scope of a subroutine.  Often this is the result of code that has
 been #ifdefed out.  DICE will continue to compile the code.

 C1:103

 Variable overides procedure argument: %.*s
 ------------------------------------------
 You have declared a local variable which is the same MAJOR HEADING as
 one of the parameters to the current procedure as in:

 void foo(int i)
 {
    int i;
 ...

 Since there would be no way to access the parameter, DICE issues the
 error.  You need to reMAJOR HEADING either the parameter or the local
 variable.  This is often the result of a cut/paste operation within
 the editor.

 C1:104

 Pragma argument count conflict with prototype: %.*s
 ---------------------------------------------------
 This error indicates that there is a difference of opinion as to the
 number of parameters that an inline function takes.  The #pragma
 statement for the function codes the number of parameters while the
 prototype explicitely lists them.  If you encounter this error, you
 will have to examine the two in order to determine which is right.

 C1:105

 Only D0 supported as a return register for pragmas: %.*s
 --------------------------------------------------------
 The #pragma statement had a value other than 0 in the next to the
 last character of the register specification.  Since all Amiga
 functions return the result in D0, you need to correct the prototype.

 C1:106

 Attempt to indirect through void pointer
 ----------------------------------------
 DICE detected an attempt to use a void pointer to reference memory.
 Since a void pointer can not point to anything real, you must cast
 the pointer to the correct type before using it.

 void *vp;
 char c;
 ...
 c = *vp;  /* Not allowed */
 c = *(char *)vp;  /* This eliminates the error */

 C1:107

 Structure/Union %s has no members
 ---------------------------------
 After parsing the structure, there turned out to be no members in it.
 You need to correct the declaration of the structure.  Often this is
 the result of a macro expansion.

 C1:108

 Missing comma in initialization expression
 ------------------------------------------
 When initializing an array, DICE did not find a comma between two
 elements in the array.  Often DICE is correct about assuming you
 needed the comma, but you should check it to be certain.

 char foo[10] = { 1, 2, 3 /* oops */ 4, 5 };

 C1:109

 Return type for procedures do not match from: %s
 ------------------------------------------------
 The procedure that you are declaring OR assigning (in the case of a
 function pointer) returns a different type than what it is being
 matched to.  This will be followed by an C1:115 error message which
 indicates the type that was expected.  To correct this, you will need
 to either insert a cast (only as a last resort) or correct the
 declarations.

 C1:110

 Number of args mismatch with prototype
 --------------------------------------
 The procedure being declared does not have the same number of
 arguments as a prototype previously encountered for this procedure.
 You will need to correct one or the other.

 C1:111

 Prototype into Non-Prototype
 ----------------------------
 A function that was previously declared as a prototype style function
 is now being redeclared as a non-prototype style function in a manner
 which causes the types to be incompatible.  You need to correct one
 or the other.

 C1:112

 Incompatible procedure Argument #%d type: %s
 --------------------------------------------
 This can occur in one of two places:  During the declaration of a
 function or during the assignment of a function pointer.  In both
 cases, one of the parameters of the two types (the original prototype
 or the left hand side of the assignment) doesn't match.  This will be
 followed by a C1:115 error message which indicates the type that was
 expected.  To correct this, you will need to fix the declarations.

 C1:113

 Argument #%d is in a different register
 ---------------------------------------
 This is usually the result of matching __STKARGS function with a
 __REGARGS function.  In rare cases it can be seen when you actually
 declare the parameters to be in specific registers.  You will need to
 correct the declarations to make them match.

 C1:114

 Structure Types do not match: %s
 --------------------------------
 Two Structure/Union/Bitfield types are not equivalent.  You will need
 to either insert a cast or correct the declarations.  This will be
 followed by a C1:115 error message to indicate the type that was
 expected.

 C1:115

 Does not match original declaration type: %s
 --------------------------------------------
 This is always paired up with another error message (C1:035, C1:109,
 C1:112, or C1:114) to provide more information about a type that was
 mismatched.  This message simply tells you what was expected.  You
 will never see this message by itself and any corrective action will
 be based on the immediately previous error message.

 C1:116

 Subroutine too complex to generate code for
 -------------------------------------------
 In rare cases, DICE will run out of registers (or get itself into an
 impossible situation).  Instead of generating bad code, DICE issues
 this error message and aborts.  You can report the problem to us
 (with the sample code of course), but in the meantime you can
 continue to compile your code by breaking it up into smaller
 subroutines.

 C1:117

 Internal Compiler error %d: %s
 ------------------------------
 In an even rarer caes where the compiler has detected some impossible
 state, it will issue this error message.  Unfortunately there is no
 cookbook way to get around this, but as a first stab, you should
 clean up all other error messages which you have gotten in your code.
 In order for us to fix this, we would need a complete compilable
 sample.

 C1:118

 Can not read locale library file: %s
 ------------------------------------
 When attemping to build a locale based program, the compiler was
 unable to open up the file that was specified on the command line.
 Please check the options to the compiler and run it again.
 Additional problems could be related to the version of locale, but
 this would be a rare case.

 C1:119

 unrelocatable data reference in const storage
 ---------------------------------------------
 This occurs when you attempt to put a relocatable pointer into const
 storage. Since by definition const is position independent, you will
 need to change the declarations which are causing the problem or
 compile with a different option.

 C1:120

 Can not open needed math library: %s
 ------------------------------------
 When attempting to compile a code which uses floating point math,
 DICE needs to open up the Amiga supplied math libraries.  You will
 either need to compile with a different math option or locate the
 appropriate libraries on your system disks.

</pre>
</body>
</html>
