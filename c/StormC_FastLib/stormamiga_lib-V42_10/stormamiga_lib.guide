@database   stormamiga_lib.guide
@author     "Matthias Henze"
@$VER:      2.5ß (20.03.1997)

@index guideIndex

@node Main "Informationen"
@toc Inhalt

	       @{B}@{FG SHINE}stormamiga.lib Version 42.10ß ( 20.03.1997 )

		  © Kopierrecht 1996/97 bei COMPIUTECK

		     geschrieben von Matthias Henze@{FG TEXT}@{UB}


			@{B} B E T A V E R S I O N@{UB}


Bei dieser Version der "stormamiga.lib" handelt es sich um eine Betaversion.
Sie ist also noch nicht fertiggestellt und es können noch einige Fehler
auftreten. Über alle bekannten Fehler können Sie sich bei @{"Bekannte Fehler" link "Bekannte Fehler"}
informieren.

Für Fehlerberichte und Verbesserungsvorschläge bin ich jederzeit dankbar.
Es wäre auch sehr schön, wenn Sie @{" mir " link "Autor"} Ihre Meinung zur "stormamiga.lib"
mitteilen würden.

@{B}@{U}An alle Anwender, die für ein "Dankeschön" arbeiten@{UB}@{UU}

Ich suche dringend einige Anwender, die diese Anleitung und den Installer-
script in andere Sprachen (Englisch, Italienisch, Französisch und andere)
übersetzen.
Außerdem suche ich noch einige Betatester.
Wenn Sie Interesse haben, können Sie mir schreiben oder mich anrufen.

Für Ihre Mühe danke ich im Voraus.

@endnode

@node Inhalt "Inhalt"

	       @{B}@{FG SHINE}stormamiga.lib Version 42.10ß ( 20.03.1997 )

		  © Kopierrecht 1996/97 bei COMPIUTECK

		     geschrieben von Matthias Henze@{FG TEXT}@{UB}


			   @{B} F R E E W A R E@{UB}



  @{" Einleitung          " link "Einleitung"}    Informationen über die stormamiga.lib.

  @{" Besonderheiten      " link "Besonderheiten"}    Was ist an der stormamiga.lib so besonders?

  @{" Registrierung       " link "Registrierung"}    Weshalb man sich registriert.

  @{" Systemanforderungen " link "Systemanforderungen"}    Was braucht man für die stormamiga.lib?

  @{" Installation        " link "Installation"}    Wie installiere ich die stormamiga.lib?

  @{" Funktionsübersicht  " link "Funktionsübersicht"}    Auflistung aller vorhandenen Funktionen.

  @{" Funktionen          " link "Funktionen"}    Beschreibung der einzelnen Funktionen.

  @{" Anwendungshinweise  " link "Anwendungshinweise"}    Tips und Tricks zur Anwendung.

  @{" Beispiele           " link "Beispiele"}    Beschreibung der Beispielprogramme.

  @{" Bekannte Fehler     " link "Bekannte Fehler"}    Wo gibt es Probleme?

  @{" Updates             " link "Updates"}    Wo gibt es neue Versionen?

  @{" Kopierrecht         " link "Kopierrecht"}    Das Rechtliche.

  @{" Geschichte          " link "Geschichte"}    Was hat sich bisher getan?

  @{" In Zukunft          " link "Zukunft"}    Was wird sich noch ändern?

  @{" Danksagungen        " link "Danksagungen"}    Danksagungen an ... .

  @{" Autor               " link "Autor"}    Wie erreicht man den Autor?

  @{" Index               " link "guideIndex"}    Das Stichwortverzeichnis.

@endnode

@node Einleitung

@{B}@{FG SHINE}Einleitung:
~~~~~~~~~~~@{FG TEXT}@{UB}

Da die Funktionen der "storm.lib" in C geschrieben sind,
werden die damit gelinkten Programme sehr groß und langsam.
Die Funktionen der "amiga.lib" sind auch nicht gerade klein
und schnell.
Aus diesem Grund habe ich mich am 18.03.1996 entschlossen
die "stormamiga.lib" zu schreiben.

Die "stormamiga.lib" ist komplett in Assembler geschrieben.
Dadurch werden die damit gelinkten Programme auch sehr klein
und schnell.
Mein Ziel ist es, alle Funktionen der "amiga.lib", die nicht
in den Pragmadateien enthalten sind, und alle Funktionen der
"storm.lib" durch kurze und schnelle Assemblerroutinen zu
ersetzen. Außerdem will ich einige Spezialbefehle von anderen
Compilern (zur Zeit nur vom GCC) und einige Routinen, die das
Programmieren erleichtern, in die "stormamiga.lib" integrieren.


@{B}@{I}@{U}Wichtig@{UB}@{UI}@{UU}

In der jetzigen Version der "stormamiga.lib" sind noch nicht
alle Funktionen der "storm.lib" und der "amiga.lib" enthalten.

Die "stormamiga.lib" sollte auch mit C++ funktionieren. Allerdings
wurde das noch nicht genügend getestet.

@endnode

@node Besonderheiten

@{B}@{FG SHINE}Ein paar Besonderheiten der "stormamiga.lib":
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

- komplett in Assembler geschrieben; dadurch werden die mit der
  "stormamiga.lib" gelinkten Programme sehr klein und schnell

- spezielle Versionen des Startupcodes für das große und kleine Codemodell
  in "ANSI C"; dadurch werden die Programme noch etwas kürzer; siehe
  @{" Der Startupcode " link "Startupcode"}

- spezielle Versionen des Startupcodes für das große und kleine Codemodell
  in "C++"; dadurch werden die Programme noch etwas kürzer; siehe
  @{" Der Startupcode " link "Startupcode"}

- spezielle Versionen der "stormamiga.lib" für MC68EC020+, MC68881+, MC68040+
  und MC68060; die "stormamiga_040.lib" ist bis zu 22 mal so schnell wie die
  "math040.lib"

- Unterstützung des kleinen Codemodelles; damit können Sie auch das
  letzte Byte aus Ihrem Programm herausholen

- Unterstützung von Umlauten (z.B.: "islower_d", "toupper_d" usw.) und
  Ausgabe von deutschen Texten (z.B.: "strftime_d", "asctime_d" usw.);
  siehe @{" Deutsche Funktionen " link "Deutsche Funktionen"}

- die "stormamiga.lib" enthält einige Spezialfunktionen (z.B.: "button",
  "max_Width" usw.); dadurch wird z.B. die Verwendung einer Mausabfrage,
  oder das Ermitteln der sichtbaren Fensterbreite auch für Anfänger, extrem
  einfach; siehe @{" Funktionen " link "Funktionen"}

- die "stormamiga.lib" enthält einige Registerfunktionen (z.B.: "mulu_r",
  "divs64_r" usw.); dadurch werden die Programme noch etwas kürzer und
  schneller; siehe @{" Registerfunktionen " link "Registerfunktionen"}

- die "stormamiga.lib" enthält einige Funktionen (z.B.: "srnicmp", "isnan"
  usw.) anderer Compiler; dadurch wird der Umstieg von anderen Compilern
  wesentlich erleichtert; siehe @{" Funktionen " link "Funktionen"}

- durch Definition von "STORMAMIGA_INLINE" können für viele Funktionen
  (z.B.: "putc", "GetAPen" usw.) sehr kurze und schnelle Inlinefunktionen
  verwendet werden; siehe @{" Inlinefunktionen " link "Inlinefunktionen"}

- die "stormamiga.lib" enthält einige Funktionsreduzierte (ohne mathematische
  Unterstützung) Funktionen (z.B.: "printf_", "scanf_" usw.); dadurch werden
  die Programme wesentlich kürzer und etwas schneller; siehe @{" Funktionen " link "Funktionen"}

- die "stormamiga.lib" ist FREEWARE; sie kostet sie also keinen Pfennig


@endnode

@node Registrierung

@{B}@{FG SHINE}Registrierung:
~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Obwohl die "stormamiga.lib" Freeware ist, was auch so bleiben
wird, können Sie sich bei @{" mir " link "Autor"} registrieren lassen. Ich möchte
vor allem wissen, ob sich die Weiterentwicklung überhaupt lohnt.

Sie können mir natürlich auch Geschenke, die Sie für angemessen
halten, zuschicken. Es währe auch sehr schön, wenn Sie mir Ihr
Programm, bei dem Sie die "stormamiga.lib" verwendet haben,
zuschicken würden. Außerdem würde ich gerne Ihre Meinung zur
"stormamiga.lib" erfahren.

Für Fehlerberichte (möglichst mit dem entsprechenden Quelltext
und einer genauen Beschreibung) und Verbesserungsvorschläge bin
ich jederzeit dankbar.
Wenn Sie Fragen zur "stormamiga.lib" haben, können Sie mich gerne
anrufen oder mir schreiben. Ich werde die Antworten zu Ihren Fragen
sofort am Telefon beantworten oder in der Anleitung der nächsten
Version veröffentlichen. Wenn ich Ihnen die Antworten zu Ihren
Fragen persönlich zuschicken soll, dann müssen Sie mir natürlich
einen frankierten Briefumschlag mitschicken. Wenn ich Ihnen die
neuste Version der "stormamiga.lib" zuschicken soll, dann müssen Sie
neben dem frankierten Briefumschlag auch eine Diskette (HD oder DD)
mitschicken.

@endnode

@node Systemanforderungen

@{B}@{FG SHINE}Systemanforderungen:
~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

- Ein Amiga
- AmigaOS 2.0 oder höher
- MC68EC020 oder höher
- StormC Version 2.0 oder höher

@endnode

@node Installation

@{B}@{FG SHINE}Installation:
~~~~~~~~~~~~~@{FG TEXT}@{UB}

Starten Sie das Installationsprogramm "HD-Install_deutsch" oder
"HD-Install_english" und führen Sie die Installation nach Ihren
Wünschen und Anforderungen durch.

Obwohl es von der "stormamiga.lib" mehrere Versionen, mit unter-
schiedlichen Namen ("stormamiga.lib", "stormamiga_nc.lib" usw.)
gibt, verwende ich meistens den allgemeinen Namen "stormamiga.lib".
Für die Startupcodes "stormamiga_startups.o", "stormamiga_nc_start-
ups.o", "stormamiga_C++_startups.o", "stormamiga_nc_C++_startups.o"
verwende ich meistens den allgemeinen Namen "stormamiga_startups.o".

Fügen Sie die "stormamiga.lib" an erster Stelle in das Projekt ein.
Wenn Sie die "stormamiga_881.lib", die "stormamiga_040.lib" oder die
"stormamiga_060.lib" nutzen wollen, müssen Sie diese noch vor der
"stormamiga.lib" in das Projekt einfügen. Da in dieser Version noch
nicht alle Funktionen enthalten sind, kann es vorkommen, daß Sie
noch die "storm.lib" in das Projekt einfügen müssen.
Wenn Sie die Spezialfunktionen der "stormamiga.lib" nutzen wollen,
müssen Sie noch die Includedatei "stormamiga.h", mit "#include
<stormamiga.h>", in Ihren Quelltext einbinden. Die Includedatei
"stormamiga.h" müssen Sie als letzte einbinden. Um auch den neuen
Startupcode "stormamiga_startups.o" zu nutzen, müssen Sie, bei den
Linkeroptionen (Linker 1) des Menüs Einstellungen, die Option
"Eigener Startup-Code" einschalten und den gewünschten Startupcode
auswählen.

@endnode

@node Funktionsübersicht

@{B}@{FG SHINE}Auflistung aller vorhandenen Funktionen:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

@{FG SHINE}Funktionen der Startupcodes
@{" stdlib Funktionen    " link "stdlibFunktionen_Startup"}

Funktionen der "stormamiga.lib" und der "stormamiga_nc.lib"
@{" Alpha Funktionen     " link "Alpha Funktionen"}@{" Amiga Funktionen     " link "Amiga Funktionen"}@{" amiga.lib Funktionen " link "amiga.lib Funktionen"}
@{" assert Funktionen    " link "assert Funktionen"}@{" ctype Funktionen     " link "ctype Funktionen"}@{" interne Funktionen   " link "interne Funktionen"}
@{" math Funktionen      " link "math Funktionen"}@{" new Funktionen       " link "new Funktionen"}@{" setjmp Funktionen    " link "setjmp Funktionen"}
@{" signal Funktionen    " link "signal Funktionen"}@{" spezial Funktionen   " link "spezial Funktionen"}@{" stdio Funktionen     " link "stdio Funktionen"}
@{" stdlib Funktionen    " link "stdlib Funktionen"}@{" string Funktionen    " link "string Funktionen"}@{" time Funktionen      " link "time Funktionen"}

Funktionen der "stormamiga_881.lib" und der "stormamiga_nc_881.lib"
@{" interne Funktionen   " link "interneFunktionen_881"}@{" math Funktionen      " link "mathFunktionen_881"}@{" stdio Funktionen     " link "stdioFunktionen_881"}
@{" stdlib Funktionen    " link "stdlibFunktionen_881"}@{" time Funktionen      " link "timeFunktionen_881"}

Funktionen der "stormamiga_040.lib" und der "stormamiga_nc_040.lib"
@{" interne Funktionen   " link "interneFunktionen_040"}@{" math Funktionen      " link "mathFunktionen_040"}@{" stdio Funktionen     " link "stdioFunktionen_040"}
@{" stdlib Funktionen    " link "stdlibFunktionen_040"}@{" time Funktionen      " link "timeFunktionen_040"}

Funktionen der "stormamiga_060.lib" und der "stormamiga_nc_060.lib"@{FG TEXT}
@{" interne Funktionen   " link "interneFunktionen_060"}@{" math Funktionen      " link "mathFunktionen_060"}@{" stdio Funktionen     " link "stdioFunktionen_060"}
@{" stdlib Funktionen    " link "stdlibFunktionen_060"}@{" time Funktionen      " link "timeFunktionen_060"}

@endnode

@node stdlibFunktionen_Startup "stdlib Funktionen der Startupcodes"
@{FG SHINE}stdlib Funktionen@{FG TEXT}

abort()     abort__STANDARD()    exit()

@endnode

@node "Alpha Funktionen"
@{FG SHINE}Alpha Funktionen@{FG TEXT}

SetAPen()       SetAPen_r()     SetBPen()       SetBPen_r()

@endnode

@node "Amiga Funktionen"
@{FG SHINE}Amiga Funktionen@{FG TEXT}

GetAPen()       GetAPen_r()     GetBPen()       GetBPen_r()
Move()          Move_r()

@endnode

@node "amiga.lib Funktionen"
@{FG SHINE}amiga.lib Funktionen@{FG TEXT}

AddTOF()         ArgArrayDone()   ArgArrayInit()   ArgInt()
ArgString()      BeginIO()        CallHook()       CallHookA()
CoerceMethod()   CoerceMethodA()  CreatePort()     CreateTask()
CreateExtIO()    CreateStdIO()    DeleteExtIO()    DeletePort()
DeleteStdIO()    DeleteTask()     DoMethod()       DoMethodA()
DoSuperMethod()  DoSuperMethodA() FastRand()       FreeIEvents()
HookEntry()      HotKey()         LibAllocPooled() LibCreatePool()
LibDeletePool()  LibFreePooled()  NewList()        RangeRand()
RemTOF()         SetSuperAttrs()  SPRINTF()        TimeDelay()
VSPRINTF()       waitbeam()

@endnode

@node "assert Funktionen"
@{FG SHINE}assert Funktionen@{FG TEXT}

assert()        assert_()       do_assert()     do_assert_()

@endnode

@node "ctype Funktionen"
@{FG SHINE}ctype Funktionen@{FG TEXT}

isalnum()       isalnum_d()     isalpha()       isalpha_d()
iscntrl()       isdigit()       isgraph()       islower()
islower_d()     isprint()       isprint_d()     ispunct()
ispunct_d()     isspace()       isupper()       isupper_d()
isxdigit()      tolower()       tolower_d()     toupper()
toupper_d()     which_xdigit()

@endnode

@node "interne Funktionen"
@{FG SHINE}interne Funktionen@{FG TEXT}

Add64()                         blocksize_a2_d2()
Cmp64()                         geta4
GetBaseReg                      INIT_O_InitUserbreak()
intmult()                       intdiv()
LibClose()                      LibExpunge()
LibInit()                       LibNull()
LibOpen()                       lib_64bit_shl
lib_64bit_shr                   lib_catch()
lib_catchclass()                lib_destruct()
lib_destruct_a0()               lib_div_int()
lib_div_uint()                  lib_rethrow()
lib_throw()                     main()
main__()                        main__iPc()
main__iPPc()                    Neg64()
SDiv64()                        SDivMod32()
SDivMod64()                     set_terminate__PFvp()
set_unexpected__PFvp()          SMod64()
SMult64()                       Sub64()
terminate()                     UDiv64()
UDivMod32()                     UDivMod64()
uintmult()                      uintdiv()
UMod64()                        UMult64()
unexpected()                    userbreak()
wbmain()                        wbmain__P09WBStartup()

@{B}Autolib Funktionen@{UB}
EXIT_3_AmigaGuideBase()         EXIT_2_AslBase()
EXIT_3_BulletBase()             EXIT_3_ColorWheelBase()
EXIT_2_CxBase()                 EXIT_3_DataTypesBase()
EXIT_2_DiskfontBase()           EXIT_1_DOSBase()
EXIT_2_ExpansionBase()          EXIT_2_GadToolsBase()
EXIT_3_GradientSliderBase()     EXIT_2_GfxBase()
EXIT_2_IconBase()               EXIT_2_IFFParseBase()
EXIT_2_IntuitionBase()          EXIT_2_KeymapBase()
EXIT_2_LayersBase()             EXIT_3_LocaleBase()
EXIT_3_LowLevelBase()           EXIT_2_MathBase()
EXIT_2_MathIeeeDoubBasBase()    EXIT_2_MathIeeeDoubTransBase()
EXIT_2_MathIeeeSingBasBase()    EXIT_2_MathIeeeSingTransBase()
EXIT_2_MathTransBase()          EXIT_2_MUIMasterBase()
EXIT_3_NVBase()                 EXIT_3_RealTimeBase()
EXIT_2_ReqToolsBase()           EXIT_2_RexxSysBase()
EXIT_3_TranslatorBase()         EXIT_1_UtilityBase()
EXIT_2_VersionBase()            EXIT_2_WizardBase()
EXIT_2_WorkbenchBase()          INIT_3_AmigaGuideBase()
INIT_2_AslBase()                INIT_3_BulletBase()
INIT_3_ColorWheelBase()         INIT_2_CxBase()
INIT_3_DataTypesBase()          INIT_2_DiskfontBase()
INIT_1_DOSBase()                INIT_2_ExpansionBase()
INIT_2_GadToolsBase()           INIT_3_GradientSliderBase()
INIT_2_GfxBase()                INIT_2_IconBase()
INIT_2_IFFParseBase()           INIT_2_IntuitionBase()
INIT_2_KeymapBase()             INIT_2_LayersBase()
INIT_3_LocaleBase()             INIT_3_LowLevelBase()
INIT_2_MathBase()               INIT_2_MathIeeeDoubBasBase()
INIT_2_MathIeeeDoubTransBase()  INIT_2_MathIeeeSingBasBase()
INIT_2_MathIeeeSingTransBase()  INIT_2_MathTransBase()
INIT_2_MUIMasterBase()          INIT_3_NVBase()
INIT_3_RealTimeBase()           INIT_2_ReqToolsBase()
INIT_2_RexxSysBase()            INIT_3_TranslatorBase()
INIT_1_UtilityBase()            INIT_2_VersionBase()
INIT_2_WizardBase()             INIT_2_WorkbenchBase()

@{B}IO Funktionen@{UB}
amigaclose()                    amigaeof()
amigaflush()                    amigagetc()
amigagetcunget()                amigaopen()
amigaputc()                     amigaread()
amigareadunget()                amigaseek()
amigaungetc()                   amigawrite()
char_in()                       char_out()
double_in()                     double_out()
EXIT_5_InitFiles()              EXIT_5_InitStdIOFiles()
INIT_0_NEAR_CODE_StdioFiles()   INIT_0_InitFiles()
INIT_5_InitStdIOFiles()         intern__form_in()
intern__form_in_()              int_in()
signed_out()                    string_in()
string_out()                    udiv_64()
unsigned_out()

@{B}math Funktionen@{UB}
expo10()                        Expo10()
floattostr()                    fpwr10()
lib_double2float()              lib_double2int()
lib_float2double()              lib_float2int()
lib_float_add()                 lib_float_cmp()
lib_float_div()                 lib_float_mult()
lib_float_neg()                 lib_float_sub()
lib_float_tst()                 lib_int2double()
lib_int2float()                 pwr10()
Pwr10()

@{B}interne Daten@{UB}
AmigaGuideBase                  AslBase
BulletBase                      ColorWheelBase
CxBase                          DataTypesBase
DiskfontBase                    DOSBase
errno                           ExpansionBase
fileList                        flagc
GadToolsBase                    GradientSliderBase
GfxBase                         IconBase
IFFParseBase                    IntuitionBase
KeymapBase                      LayersBase
LocaleBase                      lowertabel
LowLevelBase                    MathBase
MathIeeeDoubBasBase             MathIeeeDoubTransBase
MathIeeeSingBasBase             MathIeeeSingTransBase
MathTransBase                   MUIMasterBase
NVBase                          RealTimeBase
ReqToolsBase                    RexxSysBase
signal_dat                      std__err
std__in                         std__out
time_dat                        tmpnamList
tmpnamNext                      TranslatorBase
uppertabel                      userbreak_flagpos
UtilityBase                     VersionBase
WizardBase                      WorkbenchBase
__ctypetable

@endnode

@node "math Funktionen"
@{FG SHINE}math Funktionen@{FG TEXT}

acos()          asin()          atan()          atan2()
ceil()          cos()           cosh()          exp()
fabs()          floor()         fmod()          frexp()
isinf()         isnan()         ldexp()         log()
log10()         modf()          pow()           sin()
sinh()          sqrt()          tan()           tanh()

@endnode

@node "new Funktionen"
@{FG SHINE}new Funktionen@{FG TEXT}
set_new_handler()

@endnode

@node "setjmp Funktionen"
@{FG SHINE}setjmp Funktionen@{FG TEXT}

longjmp()       setjmp()

@endnode

@node "signal Funktionen"
@{FG SHINE}signal Funktionen@{FG TEXT}

raise()         signal()

@endnode

@node "spezial Funktionen"
@{FG SHINE}spezial Funktionen@{FG TEXT}

button()        button_al()     button_ar()     button_bl()
button_br()     button_r()      divs64()        divs64_r()
divsl_r()       divu64()        divu64_r()      divul_r()
max_Height()    max_Height_r()  max_Width()     max_Width_r()
muls()          muls64()        muls64_r()      muls_r()
mulu()          mulu64()        mulu64_r()      mulu_r()
waitbutton()    waitbutton_al() waitbutton_ar() waitbutton_bl()
waitbutton_br() waitbutton_r()

@endnode

@node "stdio Funktionen"
@{FG SHINE}stdio Funktionen@{FG TEXT}

clearerr()      fclose()        feof()          ferror()
fflush()        fgetc()         fgetpos()       fgets()
fopen()         fprintf()       fprintf_()      fputc()
fputs()         fputstr()       fread()         freopen()
fscanf()        fscanf_()       fseek()         fsetpos()
ftell()         fwrite()        getc()          getchar()
gets()          perror()        printf()        printf_()
putc()          putchar()       puts()          remove()
rename()        rewind()        scanf()         scanf_()
setbuf()        setbuffer()     setlinebuf()    setvbuf()
sprintf()       sprintf_()      sscanf()        sscanf_()
tmpfile()       tmpnam()        ungetc()        vfprintf()
vfprintf_()     vfscanf()       vfscanf_()      vprintf()
vprintf_()      vscanf()        vscanf_()       vsprintf()
vsprintf_()     vsscanf()       vsscanf_()

@endnode

@node "stdlib Funktionen"
@{FG SHINE}stdlib Funktionen@{FG TEXT}

abort()         abs()           atexit()        atof()
atoi()          atol()          atoll()         bsearch()
calloc()        delete()        div()           free()
getenv()        inttostr()      labs()          ldiv()
llabs()         llongtostr()    malloc()        new()
qsort()         rand()          realloc()       srand()
strtod()        strtol()        strtoll()       strtoul()
strtoull()      system()        uinttostr()     ullongtostr()

@endnode

@node "string Funktionen"
@{FG SHINE}string Funktionen@{FG TEXT}

bcmp()          bcopy()         ffs()           index()
memccpy()       memchr()        memcmp()        memcpy()
memmove()       memset()        rindex()        strcasecmp()
strcasecmp_d()  strcat()        strchr()        strcmp()
strcpy()        strcspn()       strdup()        strerror()
stricmp()       stricmp_d()     strlen()        strlower()
strlower_d()    strlwr()        strlwr_d()      strncasecmp()
strncasecmp_d() strncat()       strncmp()       strncpy()
strnicmp()      strnicmp_d()    strpbrk()       strrchr()
strsep()        strspn()        strstr()        strtok()
strupper()      strupper_d()    strupr()        strupr_d()
strxfrm()       swab()          

@endnode

@node "time Funktionen"
@{FG SHINE}time Funktionen@{FG TEXT}

asctime()       asctime_d()     clock()         ctime()
ctime_d()       difftime()      gmtime()        mktime()
strftime()      strftime_d()    time()          

@endnode

@node interneFunktionen_881 "interne Funktionen für den MC68881+"
@{FG SHINE}interne Funktionen@{FG TEXT}

(noch) keine

@endnode

@node mathFunktionen_881 "math Funktionen für den MC68881+"
@{FG SHINE}math Funktionen@{FG TEXT}

acos()          asin()          atan()          atan2()
ceil()          cos()           cosh()          exp()
fabs()          floor()         fmod()          frexp()
ldexp()         log()           log10()         modf()
pow()           sin()           sinh()          sqrt()
tan()           tanh()

@endnode

@node stdioFunktionen_881 "stdio Funktionen für den MC68881+"
@{FG SHINE}stdio Funktionen@{FG TEXT}

(noch) keine

@endnode

@node stdlibFunktionen_881 "stdlib Funktionen für den MC68881+"
@{FG SHINE}stdlib Funktionen@{FG TEXT}

atof()          strtod()

@endnode

@node timeFunktionen_881 "time Funktionen für den MC68881+"
@{FG SHINE}time Funktionen@{FG TEXT}

difftime()

@endnode

@node interneFunktionen_040 "interne Funktionen für den MC68040+"
@{FG SHINE}interne Funktionen@{FG TEXT}

(noch) keine

@endnode

@node mathFunktionen_040 "math Funktionen für den MC68040+"
@{FG SHINE}math Funktionen@{FG TEXT}

atan2()         ceil()          cos()           fabs()
floor()         fmod()          frexp()         ldexp()
modf()          sqrt()

@endnode

@node stdioFunktionen_040 "stdio Funktionen für den MC68040+"
@{FG SHINE}stdio Funktionen@{FG TEXT}

(noch) keine

@endnode

@node stdlibFunktionen_040 "stdlib Funktionen für den MC68040+"
@{FG SHINE}stdlib Funktionen@{FG TEXT}

atof()          strtod()

@endnode

@node timeFunktionen_040 "time Funktionen für den MC68040+"
@{FG SHINE}time Funktionen@{FG TEXT}

difftime()

@endnode

@node interneFunktionen_060 "interne Funktionen für den MC68060"
@{FG SHINE}interne Funktionen@{FG TEXT}

(noch) keine

@endnode

@node mathFunktionen_060 "math Funktionen für den MC68060"
@{FG SHINE}math Funktionen@{FG TEXT}

atan2()         ceil()          cos()           fabs()
floor()         fmod()          frexp()         ldexp()
modf()          sqrt()

@endnode

@node stdioFunktionen_060 "stdio Funktionen für den MC68060"
@{FG SHINE}stdio Funktionen@{FG TEXT}

(noch) keine

@endnode

@node stdlibFunktionen_060 "stdlib Funktionen für den MC68060"
@{FG SHINE}stdlib Funktionen@{FG TEXT}

atof()          strtod()

@endnode

@node timeFunktionen_060 "time Funktionen für den MC68060"
@{FG SHINE}time Funktionen@{FG TEXT}

difftime()

@endnode


@node Funktionen

@{B}@{FG SHINE}Die Funktionen der "stormamiga.lib":
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Da die normalen Ansi-C und C++ Funktionen bereits bei StormC
beschrieben werden, erkläre ich nur die Spezialfunktionen.


@{" Der Startupcode " link "Startupcode"}

@{FG SHINE}AmigaDOS stdio Funktionen
@{" SPRINTF       " link "SPRINTF"}@{" VSPRINTF      " link "VSPRINTF"}

stdio Funktionen
@{" printf_       " link "printf_"}@{" fprintf_      " link "fprintf_"}@{" sprintf_      " link "sprintf_"}@{" vprintf_      " link "vprintf_"}
@{" vfprintf_     " link "vfprintf_"}@{" vsprintf_     " link "vsprintf_"}@{" scanf_        " link "scanf_"}@{" fscanf_       " link "fscanf_"}
@{" sscanf_       " link "sscanf_"}@{" vscanf        " link "vscanf"}@{" vscanf_       " link "vscanf_"}@{" vfscanf       " link "vfscanf"}
@{" vfscanf_      " link "vfscanf_"}@{" vsscanf       " link "vsscanf"}@{" vsscanf_      " link "vsscanf_"}@{" setbuffer     " link "setbuffer"}
@{" setlinebuf    " link "setlinebuf"}

string Funktionen
@{" strcoll       " link "strcoll"}@{" strxfrm       " link "strxfrm"}@{" bcmp          " link "bcmp"}@{" bcopy         " link "bcopy"}
@{" bzero         " link "bzero"}@{" ffs           " link "ffs"}@{" index         " link "index"}@{" rindex        " link "rindex"}
@{" memccpy       " link "memccpy"}@{" strsep        " link "strsep"}@{" swab          " link "swab"}@{" stricmp_d     " link "stricmp_d"}
@{" strnicmp      " link "strnicmp"}@{" strnicmp_d    " link "strnicmp_d"}@{" strcasecmp    " link "strcasecmp"}@{" strcasecmp_d  " link "strcasecmp_d"}
@{" strncasecmp   " link "strncasecmp"}@{" strncasecmp_d " link "strncasecmp_d"}@{" strlower      " link "strlower"}@{" strlower_d    " link "strlower_d"}
@{" strupper      " link "strupper"}@{" strupper_d    " link "strupper_d"}@{" strlwr_d      " link "strlwr_d"}@{" strupr_d      " link "strupr_d"}
@{" strdup        " link "strdup"}

ctype Funktionen
@{" isalnum_d     " link "isalnum_d"}@{" isalpha_d     " link "isalpha_d"}@{" islower_d     " link "islower_d"}@{" isprint_d     " link "isprint_d"}
@{" ispunct_d     " link "ispunct_d"}@{" isupper_d     " link "isupper_d"}@{" tolower_d     " link "tolower_d"}@{" toupper_d     " link "toupper_d"}

assert Funktionen
@{" assert_       " link "assert_"}

time Funktionen
@{" strftime      " link "strftime"}@{" strftime_d    " link "strftime_d"}@{" asctime_d     " link "asctime_d"}@{" ctime_d       " link "ctime_d"}

math Funktionen
@{" isinf         " link "isinf"}@{" isnan         " link "isnan"}

Spezial Funktionen@{FG TEXT}
@{" muls          " link "muls"}@{" muls_r        " link "muls_r"}@{" mulu          " link "mulu"}@{" mulu_r        " link "mulu_r"}
@{" divsl         " link "divsl"}@{" divsl_r       " link "divsl_r"}@{" divul         " link "divul"}@{" divul_r       " link "divul_r"}
@{" muls64        " link "muls64"}@{" muls64_r      " link "muls64_r"}@{" mulu64        " link "mulu64"}@{" mulu64_r      " link "mulu64_r"}
@{" divs64        " link "divs64"}@{" divs64_r      " link "divs64_r"}@{" divu64        " link "divu64"}@{" divu64_r      " link "divu64_r"}
@{" button_al     " link "button_al"}@{" button_ar     " link "button_ar"}@{" button_bl     " link "button_bl"}@{" button_br     " link "button_br"}
@{" button        " link "button"}@{" button_r      " link "button_r"}@{" waitbutton_al " link "waitbutton_al"}@{" waitbutton_ar " link "waitbutton_ar"}
@{" waitbutton_bl " link "waitbutton_bl"}@{" waitbutton_br " link "waitbutton_br"}@{" waitbutton    " link "waitbutton"}@{" waitbutton_r  " link "waitbutton_r"}
@{" max_Height    " link "max_Height"}@{" max_Height_r  " link "max_Height_r"}@{" max_Width     " link "max_Width"}@{" max_Width_r   " link "max_Width_r"}

@endnode

@node Startupcode "Der Startupcode"

@{FG SHINE}Der Startupcode "stormamiga_startups.o"@{FG TEXT}
Die Startupcodes "stormamiga_startups.o" und "stormamiga_nc_
startups.o" sind speziell für Ansi-C geschrieben. Der Startup-
code "stormamiga_startups.o" unterstützt das große Codemodell
in Verbindung mit den Datenmodellen "FAR", "NEAR A4" und "NEAR
A6". Der Startupcode "stormamiga_nc_startups.o" unterstützt das
kleine Codemodell in Verbindung mit den Datenmodellen "FAR",
"NEAR A4" und "NEAR A6".
Der größte Unterschied, zum Startupcode "startup.o" von StormC,
ist der Aufruf der Funktionen "main" und "wbmain".

Bei einem Start aus dem CLI wird die Funktion "_main__", das
entspricht der Funktion @{" main__() " link "main__()"} in Ansi-C, aufgerufen. Wenn
es diese Funktion, in Ihrem Programm, nicht gibt, wird sie aus
der "stormamiga.lib" dazugelinkt. Die Funktion "_main__" ruft
die Funktion "_main", das entspricht der Funktion "main()" in
Ansi-C, auf. Wenn es diese Funktion nicht gibt, meldet der
Linker einen Fehler.

Bei einem Start von der Workbench wird die Funktion "_wbmain",
das entspricht der Funktion "wbmain()" in Ansi-C, aufgerufen.
Wenn es diese Funktion nicht gibt, wird sie aus der "storm-
amiga.lib" dazugelinkt.


Die Startupcodes "stormamiga_C++_startups.o" und "stormamiga_nc_
C++_startups.o" sind für C++ und Ansi-C geschrieben. Der Startup-
code "stormamiga_C++_startups.o" unterstützt das große Codemodell
in Verbindung mit den Datenmodellen "FAR", "NEAR A4" und "NEAR A6".
Der Startupcode "stormamiga_nc_C++_startups.o" unterstützt das
kleine Codemodell in Verbindung mit den Datenmodellen "FAR",
"NEAR A4" und "NEAR A6".
Die Funktion entspricht dem Startupcode "startup.o" von StormC.


@endnode

@node main__()

@{B}Die Funktion "main__()"@{UB}

Wenn Sie für Ihr Programm keine Auswertung von Argumenten
benötigen oder diese Routine selber schreiben, können Sie die
Funktion "main()" in "main__()" umbenennen. Dadurch wird Ihr
Programm etwas kleiner.

@{B}@{I}@{U}Wichtig@{UB}@{UI}@{UU}

Da der Compiler die Funktion "main__()" nicht als normale
main-Funktion erkennt, setzt er auch nicht den Returncode
auf 0. Deshalb müssen Sie den Returncode, mit "return 0",
selber auf 0 setzen.
Die Funktion "main__()" benötigt den Startupcode "stormamiga
_startups.o" oder "stormamiga_nc_startups.o" und funktioniert
nur in Ansi-C.

@endnode

@node SPRINTF

@{FG SHINE}SPRINTF@{FG TEXT}
Formatierte Ausgabe in den Stringpuffer "s".

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = SPRINTF (s, format, ...);

long r;
char *s;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in den @{" Stringpuffer " link "Stringpuffer"} "s". Der Formatstring
"format" beschreibt das Ausgabeformat. Danach folgen zusätzlich
angegebene Parameter.

"SPRINTF" verwendet den Befehl @{" RawDoFmt " link "StormC:StormSYS/Help/exec/RawDoFmt()"} der "exec.library"
und ist dadurch auch sehr klein.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen.

@endnode

@node VSPRINTF

@{FG SHINE}VSPRINTF@{FG TEXT}
Formatierte Ausgabe in den Stringpuffer "s".

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = VSPRINTF (s, format, vl);

long r;
char *s;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in den @{" Stringpuffer " link "Stringpuffer"} "s". Der Formatstring
"format" beschreibt das Ausgabeformat. Danach folgt eine
@{" Parameterliste " link "Parameterliste"} "vl".

"VSPRINTF" verwendet den Befehl @{" RawDoFmt " link "StormC:StormSYS/Help/exec/RawDoFmt()"} der "exec.library"
und ist dadurch auch sehr klein.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen.

@endnode

@node printf_

@{FG SHINE}printf_@{FG TEXT}
Formatierte Ausgabe in die Standardausgabe "stdout".
@{I}Funktionsreduzierte Version von "printf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = printf_ (format, ...);

int r;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in die Standardausgabe "stdout". Der
@{" Ausgabeformatstring_ " link "Ausgabeformatstring_"} "format" beschreibt das Ausgabe-
format. Danach folgen zusätzlich angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node fprintf_

@{FG SHINE}fprintf_@{FG TEXT}
Formatierte Ausgabe in die Datei "f".
@{I}Funktionsreduzierte Version von "fprintf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = fprintf_ (f, format, ...);

int r;
FILE *f;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in die Datei "f". Der @{" Ausgabeformatstring_ " link "Ausgabeformatstring_"}
"format" beschreibt das Ausgabeformat. Danach folgen zusätzlich
angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node sprintf_

@{FG SHINE}sprintf_@{FG TEXT}
Formatierte Ausgabe in den Stringpuffer "s".
@{I}Funktionsreduzierte Version von "sprintf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = sprintf_ (s, format, ...);

int r;
char *s;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in den @{" Stringpuffer " link "Stringpuffer"} "s". Der
@{" Ausgabeformatstring_ " link "Ausgabeformatstring_"} "format" beschreibt das Ausgabe-
format. Danach folgen zusätzlich angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node vprintf_

@{FG SHINE}vprintf_@{FG TEXT}
Formatierte Ausgabe in die Standardausgabe "stdout".
@{I}Funktionsreduzierte Version von "vprintf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vprintf_ (format, vl);

int r;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in die Standardausgabe "stdout". Der
@{" Ausgabeformatstring_ " link "Ausgabeformatstring_"} "format" beschreibt das Ausgabe-
format. Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

Der Befehl "vprintf_" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node vfprintf_

@{FG SHINE}vfprintf_@{FG TEXT}
Formatierte Ausgabe in die Datei "f".
@{I}Funktionsreduzierte Version von "vfprintf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vfprintf_ (f, format, vl);

int r;
FILE *f;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in die Datei "f". Der
@{" Ausgabeformatstring_ " link "Ausgabeformatstring_"} "format" beschreibt
das Ausgabeformat. Danach folgt eine
@{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node vsprintf_

@{FG SHINE}vsprintf_@{FG TEXT}
Formatierte Ausgabe in den Stringpuffer "s".
@{I}Funktionsreduzierte Version von "vsprintf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vsprintf_ (s, format, vl);

int r;
char *s;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe in den @{" Stringpuffer " link "Stringpuffer"} "s". Der
@{" Ausgabeformatstring_ " link "Ausgabeformatstring_"} "format" beschreibt das
Ausgabeformat. Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen oder im Fehlerfall
eine negative Zahl.

@endnode

@node scanf_

@{FG SHINE}scanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".
@{I}Funktionsreduzierte Version von "scanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = scanf_ (format, ...);

int r;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".
Der @{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgen zusätzlich angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node fscanf_

@{FG SHINE}fscanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Datei "f".
@{I}Funktionsreduzierte Version von "fscanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = fscanf_ (f, format, ...);

int r;
FILE *f;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Datei "f". Der
@{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgen zusätzlich angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node sscanf_

@{FG SHINE}sscanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s".
@{I}Funktionsreduzierte Version von "sscanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = sscanf_ (s, format, ...);

int r;
char *s;
const char *format;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s". Der
@{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgen zusätzlich angegebene Parameter.

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vscanf

@{FG SHINE}vscanf@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vscanf (format, vl);

int r;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".
Der @{" Eingabeformatstring " link "Eingabeformatstring"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

Der Befehl "vscanf" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vscanf_

@{FG SHINE}vscanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".
@{I}Funktionsreduzierte Version von "scanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vscanf_ (format, vl);

int r;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Standardeingabe "stdin".
Der @{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

Der Befehl "vscanf_" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vfscanf

@{FG SHINE}vfscanf@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Datei "f".

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vfscanf (f, format, vl);

int r;
FILE *f;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Datei "f". Der
@{" Eingabeformatstring " link "Eingabeformatstring"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vfscanf_

@{FG SHINE}vfscanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus der Datei "f".
@{I}Funktionsreduzierte Version von "vfscanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vfscanf_ (f, format, vl);

int r;
FILE *f;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus der Datei "f". Der
@{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vsscanf

@{FG SHINE}vsscanf@{FG TEXT}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s".

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vsscanf (s, format, vl);

int r;
char *s;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s". Der
@{" Eingabeformatstring " link "Eingabeformatstring"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node vsscanf_

@{FG SHINE}vsscanf_@{FG TEXT}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s".
@{I}Funktionsreduzierte Version von "vsscanf".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = vsscanf_ (s, format, vl);

int r;
char *s;
const char *format;
va_list vl;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Einlesen einer formatierten Eingabe aus dem Stringpuffer "s". Der
@{" Eingabeformatstring_ " link "Eingabeformatstring_"} "format" beschreibt das Eingabeformat.
Danach folgt eine @{" Parameterliste " link "Parameterliste"} "vl".

@{B}Rückgabe@{UB}
Die Anzahl der eingelesenen Zeichen oder im Fehlerfall einen Rück-
gabewert der kleiner als die Anzahl der eingelesenen Zeichen ist.

@endnode

@node setbuffer

@{FG SHINE}setbuffer@{FG TEXT}
setzen eines Dateipuffers

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = setbuffer (f, buf, size);

void r;
FILE *f;
char *buf;
int size;

@{B}Standard@{UB}
(noch) keiner (4.3BSD)

@{B}Erklärung@{UB}
Setzt für die Datei "f" den Dateipuffer "buf" der Länge "size".

Der Befehl "setbuffer" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
keine

@endnode

@node setlinebuf

@{FG SHINE}setlinebuf@{FG TEXT}
setzen eines Zeilenpuffers

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = setlinebuf (f);

int r;
FILE *f;

@{B}Standard@{UB}
(noch) keiner (4.3BSD)

@{B}Erklärung@{UB}
Setzt für die Datei "f" einen Zeilenpuffer.

Der Befehl "setlinebuf" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Es wird immer 0 zurückgegeben.

@endnode

@node strcoll

@{FG SHINE}strcoll@{FG TEXT}
vergleichen zweier Strings unter Beachtung der aktuellen Sprache

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strcoll (s1, s2);

int r;
const char *s1;
const char *s2;

@{B}Standard@{UB}
ANSI C3.159-1989 ("ANSI C")

@{B}Erklärung@{UB}
Vergleicht die Strings "s1" und "s2" Zeichen für Zeichen.
Da die "stormamiga.lib" die ANSI-Lokalisierung nicht unterstützt,
wird die aktuelle Sprache nicht berücksichtigt.
Die Funktion "strcoll" ist nur aus Gründen der Kompatibilität zu
anderen Compilern (z.B.: GCC) vorhanden.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strxfrm

@{FG SHINE}strxfrm@{FG TEXT}
kopieren eines Strings unter Beachtung der aktuellen Sprache

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strxfrm (dest, source, n);

int r;
char *dest;
const char *source;
size_t n;

@{B}Standard@{UB}
ANSI C3.159-1989 ("ANSI C")

@{B}Erklärung@{UB}
Kopiert maximal "n" Bytes vom String "source" nach "dest".
Da die "stormamiga.lib" die ANSI-Lokalisierung nicht unterstützt,
wird die aktuelle Sprache nicht berücksichtigt.
Die Funktion "strxfrm" ist nur aus Gründen der Kompatibilität zu
anderen Compilern (z.B.: GCC) vorhanden.

@{B}Rückgabe@{UB}
Die Länge des kopierten Strings "source" ohne Nullzeichen.

@endnode

@node bcmp

@{FG SHINE}bcmp@{FG TEXT}
vergleichen zweier Speicherbereiche mit Beachtung einer Maximallänge

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = bcmp (b1, b2, n);

int r;
const void *b1;
const void *b2;
size_t n;

@{B}Standard@{UB}
(noch) keiner (4.2BSD)

@{B}Erklärung@{UB}
Vergleicht die Speicherbereiche "b1" und "b2" Byte für Byte auf
maximal "n" Bytes Länge. Die Speicherbereiche dürfen sich über-
schneiden.

@{B}Rückgabe@{UB}
< 0 wenn b1 < b2
= 0 wenn b1 = b2
> 0 wenn b1 > b2

@endnode

@node bcopy

@{FG SHINE}bcopy@{FG TEXT}
Speicher kopieren

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = bcopy (source, dest, n);

void r;
const void *source;
void *dest;
size_t n;

@{B}Standard@{UB}
(noch) keiner (4.2BSD)

@{B}Erklärung@{UB}
Kopiert "n" Bytes vom Speicherbereich "source" nach "dest". Die
Speicherbereiche dürfen sich überschneiden. Wenn "n" 0 ist, wird
nichts kopiert.

@{B}Rückgabe@{UB}
keine

@endnode

@node bzero

@{FG SHINE}bzero@{FG TEXT}
schreibt NULL-Bytes in einen Speicherbereich

@{B}Übersicht@{UB}
#include <string.h>

r = bzero (b, n);

void r;
void b;
size_t n;

@{B}Standard@{UB}
(noch) keiner (4.3BSD)

@{B}Erklärung@{UB}
Schreibt "n" NULL-Bytes in den Speicherbereich "b".

@{B}Rückgabe@{UB}
keine

@endnode

@node ffs

@{FG SHINE}ffs@{FG TEXT}
findet das erste gesetzte Bit in einem Bit-String

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = ffs (value);

int r;
int value;

@{B}Standard@{UB}
(noch) keiner (4.3BSD)

@{B}Erklärung@{UB}
Findet das erste gesetzte Bit in dem Bit-String "value" und gibt
den Index davon zurück.

@{B}Rückgabe@{UB}
Index des Bit-String "value"

@endnode

@node index

@{FG SHINE}index@{FG TEXT}
sucht das erste Vorkommen eines Zeichens in einem String

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = index (s, c);

char *r;
const char *s;
int c;

@{B}Standard@{UB}
(noch) keiner (Version 6 AT&T UNIX)

@{B}Erklärung@{UB}
Sucht das erste Vorkommen des Zeichens "c" in dem String "s"
und gibt einen Zeiger auf das erste gefundene Zeichen "c"
zurück. Wenn das Zeichen "c" nicht gefunden wird, wird 0
zurückgegeben.

@{B}Rückgabe@{UB}
Ein Zeiger auf das erste gefundene Zeichen "c" oder 0.

@endnode

@node rindex

@{FG SHINE}rindex@{FG TEXT}
sucht das letzte Vorkommen eines Zeichens in einem String

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = rindex (s, c);

char *r;
const char *s;
int c;

@{B}Standard@{UB}
(noch) keiner (Version 6 AT&T UNIX)

@{B}Erklärung@{UB}
Sucht das letzte Vorkommen des Zeichens "c" in dem String "s"
und gibt einen Zeiger auf das letzte gefundene Zeichen "c"
zurück. Wenn das Zeichen "c" nicht gefunden wird, wird 0
zurückgegeben.

@{B}Rückgabe@{UB}
Ein Zeiger auf das letzte gefundene Zeichen "c" oder 0.

@endnode

@node memccpy

@{FG SHINE}memccpy@{FG TEXT}
Speicher kopieren

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = memccpy (dest, source, c, n);

void *r;
void *dest;
const void *source;
int c;
size_t n;

@{B}Standard@{UB}
(noch) keiner (4.3BSD)

@{B}Erklärung@{UB}
Die Funktion kopiert den Speicherbereich "source" in den Speicher-
bereich "dest". Wenn das Zeichen "c" im Speicherbereich "source"
vorkommt, wird der Kopiervorgang an dieser Stelle gestoppt und ein
Zeiger auf das Byte hinter der Kopie des Zeichens "c" im Speicher-
bereich "dest" zurückgegeben. Ansonsten werden "n" Bytes kopiert
und 0 zurückgegeben.

@{B}Rückgabe@{UB}
Ein Zeiger auf das Byte hinter der Kopie des Zeichens "c" im
Speicherbereich "dest" oder 0.

@endnode

@node strsep

@{FG SHINE}strsep@{FG TEXT}
trennt Strings

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strsep (s1, s2);

char *r;
char **s1;
char *s2;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
Die Funktion findet im String "*s1" (mit abschließendem Nullzeichen)
das erste Vorkommen eines Zeichens aus dem String "s2", ersetzt dieses
durch ein Nullzeichen und verzeichnet die Stelle des nächsten Zeichens
im String "*s1". Es wird der Originalwert des Strings "*s1" zurückgege-
ben. Wenn kein Zeichens aus dem String "s2" gefunden wird, wird 0 zurück-
gegeben.

@{B}Rückgabe@{UB}
Der Originalwert des Strings "*s1" oder 0.

@endnode

@node swab

@{FG SHINE}swab@{FG TEXT}
vertauschen angrenzender Bytes

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = swab (source, dest, n);

void r;
const void *source;
void *dest;
size_t n;

@{B}Standard@{UB}
(noch) keiner (Version 7 AT&T UNIX)

@{B}Erklärung@{UB}
Kopiert "n" Bytes von "source" nach "dest" und vertauscht die
angrenzenden Bytes. "n" muß eine gerade Zahl sein.

@{B}Rückgabe@{UB}
keine

@endnode

@node strnicmp

@{FG SHINE}strnicmp@{FG TEXT}
vergleichen zweier Strings mit Beachtung einer Maximallänge

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strnicmp (s1, s2, n);

int r;
const char *s1;
const char *s2;
size_t n;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2", bis maximal zum Zeichen
mit Index "n", Zeichen für Zeichen, ohne die Groß- oder Kleinschreibung
der Buchstaben zu beachten.
Aus Portabilitätsgründen werden keine Umlaute unterstützt.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strcasecmp

@{FG SHINE}strcasecmp@{FG TEXT}
vergleichen zweier Strings

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strcasecmp (s1, s2);

int r;
const char *s1;
const char *s2;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2" Zeichen für Zeichen,
ohne die Groß- oder Kleinschreibung der Buchstaben zu beachten.
Aus Portabilitätsgründen werden keine Umlaute unterstützt.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strncasecmp

@{FG SHINE}strncasecmp@{FG TEXT}
vergleichen zweier Strings mit Beachtung einer Maximallänge

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strncasecmp (s1, s2, n);

int r;
const char *s1;
const char *s2;
size_t n;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2", bis maximal zum Zeichen
mit Index "n", Zeichen für Zeichen, ohne die Groß- oder Kleinschreibung
der Buchstaben zu beachten.
Aus Portabilitätsgründen werden keine Umlaute unterstützt.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strlower

@{FG SHINE}strlower@{FG TEXT}
wandelt die Großbuchstaben eines Strings in Kleinbuchstaben um

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strlower (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Großbuchstabe sind,
werden sie in Kleinbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Aus Portabilitätsgründen werden keine Umlaute unterstützt.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node strupper

@{FG SHINE}strupper@{FG TEXT}
wandelt die Kleinbuchstaben eines Strings in Großbuchstaben um

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strupper (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Kleinbuchstaben sind,
werden sie in Großbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Aus Portabilitätsgründen werden keine Umlaute unterstützt.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node stricmp_d

@{FG SHINE}stricmp_d@{FG TEXT}
vergleichen zweier Strings
@{I}deutsche Version von "stricmp"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = stricmp_d (s1, s2);

int r;
const char *s1;
const char *s2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2" Zeichen für Zeichen,
ohne die Groß- oder Kleinschreibung der Buchstaben zu beachten.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strnicmp_d

@{FG SHINE}strnicmp_d@{FG TEXT}
vergleichen zweier Strings mit Beachtung einer Maximallänge
@{I}deutsche Version von "strnicmp"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strnicmp_d (s1, s2, n);

int r;
const char *s1;
const char *s2;
size_t n;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2", bis maximal zum Zeichen
mit Index "n", Zeichen für Zeichen, ohne die Groß- oder Kleinschreibung
der Buchstaben zu beachten.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt. Da es "ß"
nicht als Großbuchstabe gibt, muß dieser nicht extra unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strcasecmp_d

@{FG SHINE}strcasecmp_d@{FG TEXT}
vergleichen zweier Strings
@{I}deutsche Version von "strcasecmp"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strcasecmp_d (s1, s2);

int r;
const char *s1;
const char *s2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2" Zeichen für Zeichen,
ohne die Groß- oder Kleinschreibung der Buchstaben zu beachten.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strncasecmp_d

@{FG SHINE}strncasecmp_d@{FG TEXT}
vergleichen zweier Strings mit Beachtung einer Maximallänge
@{I}deutsche Version von "strncasecmp"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strncasecmp_d (s1, s2, n);

int r;
const char *s1;
const char *s2;
size_t n;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Vergleicht die beiden Strings "s1" und "s2", bis maximal zum Zeichen
mit Index "n", Zeichen für Zeichen, ohne die Groß- oder Kleinschreibung
der Buchstaben zu beachten.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt. Da es "ß"
nicht als Großbuchstabe gibt, muß dieser nicht extra unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
< 0 wenn s1 < s2
= 0 wenn s1 = s2
> 0 wenn s1 > s2

@endnode

@node strlower_d

@{FG SHINE}strlower_d@{FG TEXT}
wandelt die Großbuchstaben eines Strings in Kleinbuchstaben um
@{I}deutsche Version von "strlower"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strlower_d (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Großbuchstabe sind,
werden sie in Kleinbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node strupper_d

@{FG SHINE}strupper_d@{FG TEXT}
wandelt die Kleinbuchstaben eines Strings in Großbuchstaben um
@{I}deutsche Version von "strupper"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strupper_d (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Kleinbuchstaben sind,
werden sie in Großbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node strlwr_d

@{FG SHINE}strlwr_d@{FG TEXT}
wandelt die Großbuchstaben eines Strings in Kleinbuchstaben um
@{I}deutsche Version von "strlwr"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strlwr_d (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Großbuchstabe sind,
werden sie in Kleinbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node strupr_d

@{FG SHINE}strupr_d@{FG TEXT}
wandelt die Kleinbuchstaben eines Strings in Großbuchstaben um
@{I}deutsche Version von "strupr"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strupr_d (s);

char *r;
char *s;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls ein oder mehrere Zeichen des Strings "s" Kleinbuchstaben sind,
werden sie in Großbuchstaben umgewandelt, ansonsten bleiben sie
unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Der umgewandelte String "s".

@endnode

@node strdup

@{FG SHINE}strdup@{FG TEXT}
speichert die Kopie eines Strings

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strdup (s);

char *r;
const char *s;

@{B}Standard@{UB}
(noch) keiner (BSD)

@{B}Erklärung@{UB}
"strdup" reserviert ausreichend Speicher für eine Kopie des Strings "s",
kopiert diesen, und gibt einen Zeiger auf die Kopie zurück. Dieser
Zeiger kann später als Argument für die Funktion @{" free " link "StormC:StormSYS/Help/StormReference.guide/free"} verwendet werden.

@{B}Rückgabe@{UB}
Einen Zeiger auf die Kopie des Strings "s".

@endnode

@node isalnum_d

@{FG SHINE}isalnum_d@{FG TEXT}
testet, ob es sich um ein Buchstabe oder eine Ziffer handelt
@{I}deutsche Version von "isalnum"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isalnum_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein Buchstabe oder
eine Ziffer ist.
Die Umlaute "ä", "ö", "ü", "ß", "Ä", "Ö" und "Ü" werden unterstützt.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein Buchstabe und keine Ziffer ist, sonst ein
Wert ungleich 0

@endnode

@node isalpha_d

@{FG SHINE}isalpha_d@{FG TEXT}
testet, ob es sich um ein Buchstabe handelt
@{I}deutsche Version von "isalpha"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isalpha_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein Buchstabe ist.
Die Umlaute "ä", "ö", "ü", "ß", "Ä", "Ö" und "Ü" werden unterstützt.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein Buchstabe ist, sonst ein Wert ungleich 0

@endnode

@node islower_d

@{FG SHINE}islower_d@{FG TEXT}
testet, ob es sich um ein Kleinbuchstabe handelt
@{I}deutsche Version von "islower"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = islower_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein Kleinbuchstabe ist.
Die Umlaute "ä", "ö", "ü", "ß", "Ä", "Ö" und "Ü" werden unterstützt.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein Kleinbuchstabe ist, sonst ein Wert ungleich 0

@endnode

@node isprint_d

@{FG SHINE}isprint_d@{FG TEXT}
testet, ob es sich um ein druckbares Zeichen handelt
@{I}deutsche Version von "isprint"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isprint_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein druckbares Zeichen ist.
Die Umlaute "ä", "ö", "ü", "ß", "Ä", "Ö" und "Ü" werden unterstützt.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein druckbares Zeichen ist, sonst ein Wert ungleich 0

@endnode

@node ispunct_d

@{FG SHINE}ispunct_d@{FG TEXT}
testet, ob es sich um ein Sonderzeichen handelt
@{I}deutsche Version von "ispunct"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = ispunct_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein Sonderzeichen ist.
Die Umlaute "ä", "ö", "ü", "ß", "Ä", "Ö" und "Ü" werden nicht zu den
Sonderzeichen gezählt.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein Sonderzeichen ist, sonst ein Wert ungleich 0

@endnode

@node isupper_d

@{FG SHINE}isupper_d@{FG TEXT}
testet, ob es sich um ein Großbuchstabe handelt
@{I}deutsche Version von "isupper"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isupper_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Diese Funktion testet, ob das übergebene Zeichen ein Großbuchstabe ist.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt. Da es "ß"
nicht als Großbuchstabe gibt, muß dieser nicht extra unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
0 wenn das Zeichen kein Großbuchstabe ist, sonst ein Wert ungleich 0

@endnode

@node tolower_d

@{FG SHINE}tolower_d@{FG TEXT}
wandelt Großbuchstaben in Kleinbuchstaben um
@{I}deutsche Version von "tolower"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = tolower_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls das Zeichen "ch" ein Großbuchstabe ist, wird es in einen
Kleinbuchstaben umgewandelt, ansonsten bleibt es unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
das umgewandelte Zeichen

@endnode

@node toupper_d

@{FG SHINE}toupper_d@{FG TEXT}
wandelt Kleinbuchstaben in Großbuchstaben um
@{I}deutsche Version von "toupper"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = toupper_d (ch);

int r;
int ch;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Falls das Zeichen "ch" ein Kleinbuchstabe ist, wird es in einen
Großbuchstaben umgewandelt, ansonsten bleibt es unverändert.
Die Umlaute "ä", "ö", "ü", "Ä", "Ö" und "Ü" werden unterstützt.
Da es "ß" nicht als Großbuchstabe gibt, muß dieser nicht extra
unterstützt werden.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
das umgewandelte Zeichen

@endnode

@node assert_

@{FG SHINE}assert@{FG TEXT}
testet eine Bedingung und unterbricht den Programmlauf

@{B}Übersicht@{UB}
#include <stormamiga.h>

assert_ (x);

int x;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Siehe @{" assert " link "StormC:StormSYS/Help/StormReference.guide/assert"}.
Der einzige Unterschied zu "assert" besteht darin, daß zur Ausgabe
der Fehlermeldung "printf_" und nicht "printf" verwendet wird.

@endnode

@node strftime

@{FG SHINE}strftime@{FG TEXT}
Formatierte Ausgabe von Datum und Zeit in den Stringpuffer "s".
@{I}Erweiterte Version von "strftime" der "storm.lib".@{UI}

@{B}Übersicht@{UB}
#include <time.h>

r = strftime (s, size, format, tp);

size_t r;
char *s;
size_t size;
const char *format;
const struct tm *tp;

@{B}Standard@{UB}
ANSI C3.159-1989 ("ANSI C")

@{B}Erklärung@{UB}
Formatierte Ausgabe von Datum und Zeit in den @{" Stringpuffer " link "Stringpuffer"} "s".
Der @{" Zeitformatstring " link "Zeitformatstring"} "format" beschreibt das Ausgabeformat.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen.

@endnode

@node strftime_d

@{FG SHINE}strftime_d@{FG TEXT}
Formatierte Ausgabe von Datum und Zeit in den Stringpuffer "s".
@{I}Erweiterte deutsche Version von "strftime" der "storm.lib".@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = strftime_d (s, size, format, tp);

size_t r;
char *s;
size_t size;
const char *format;
const struct tm *tp;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Formatierte Ausgabe von Datum und Zeit in den @{" Stringpuffer " link "Stringpuffer"} "s".
Der @{" Zeitformatstring " link "Zeitformatstring"} "format" beschreibt das Ausgabeformat.
Die Namen der Monate und Wochentage werden in deutsch ausgegeben.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Die Anzahl der ausgegebenen Zeichen.

@endnode

@node asctime_d

@{FG SHINE}asctime_d@{FG TEXT}
Erzeugt eine Zeichenkette aus Datum und Zeit
@{I}deutsche Version von "asctime"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

tp = asctime_d (t);

char *tp;
const struct tm *t;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
"asctime_d" wandelt die Zeit aus "*t" in eine Zeichenkette der Form
"Mit Okt 07 01:03:42 1992" um. Diese Zeichenkette wird in einem
internen Puffer abgelegt und ein Zeiger darauf zurückgegeben.
Die Namen der Monate und Wochentage werden in deutsch ausgegeben.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

@{B}Rückgabe@{UB}
Die Funktion liefert einen ASCII-Text mit der exakten Länge von 26 Zeichen.
Das Format des Textes ist:
	"DDD MMM dd hh:mm:ss YYYY\n\0"

DDD ist der Wochentag, MMM ist der Monat, dd ist der Tag im Monat,
hh:mm:ss sind Stunde:Minute:Sekunde und YYYY ist das Jahr. Zum Beispiel:
	"Mit Okt 25 12:05:43 1995\n\0"

@endnode

@node ctime_d

@{FG SHINE}ctime_d@{FG TEXT}
Konvertiert einen Zeit-Wert in einen ASCII-Text
@{I}deutsche Version von "ctime"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

s = ctime_d (t);

char *s;
const time_t *t;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
"ctime_d" ist identisch mit "asctime_d (localtime (t))", wandelt also einen
"time_t"-Wert in eine Stringdarstellung um.
Die Namen der Monate und Wochentage werden in deutsch ausgegeben.

Siehe auch bei @{" Deutsche Funktionen " link "Deutsche Funktionen"}.

Der Befehl "ctime_d" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die Funktion liefert einen ASCII-Text mit der exakten Länge von 26 Zeichen.
Das Format des Textes ist:
	"DDD MMM dd hh:mm:ss YYYY\n\0"
DDD ist der Wochentag, MMM ist der Monat, dd ist der Tag im Monat,
hh:mm:ss sind Stunde:Minute:Sekunde und YYYY ist das Jahr. Zum Beispiel:
	"Mit Okt 25 12:05:43 1995\n\0"

@endnode

@node isinf

@{FG SHINE}isinf@{FG TEXT}
testet, ob es sich um eine unendliche Zahl handelt

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isinf (x);

int r;
double x;

@{B}Standard@{UB}
IEEE Standard for Binary Floating-Point Arithmetic, Std 754-1985, ANSI

@{B}Erklärung@{UB}
Die Funktion "isinf" (is infinite) testet, ob "x" eine unendliche Zahl ist.

@{B}Rückgabe@{UB}
1 wenn "x" eine unendliche Zahl ist, sonst 0.

@endnode

@node isnan

@{FG SHINE}isnan@{FG TEXT}
testet, ob es sich um eine ungültige Zahl handelt

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = isnan (x);

int r;
double x;

@{B}Standard@{UB}
IEEE Standard for Binary Floating-Point Arithmetic, Std 754-1985, ANSI

@{B}Erklärung@{UB}
Die Funktion "isnan" (is not a number) testet, ob "x" eine ungültige
Zahl (Division durch 0, Wurzel einer negativen Zahl) ist.

@{B}Rückgabe@{UB}
1 wenn "x" eine ungültige Zahl ist, sonst 0.

@endnode

@node muls

@{FG SHINE}muls@{FG TEXT}
signed 32 Bit mal 32 Bit Multiplikation mit 32 Bit Ergebnis

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = muls (arg1, arg2);

long r;
long arg1;
long arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "muls" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "muls" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SMult32 " link "StormC:StormSYS/Help/utility/SMult32()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "SMult32"
einfach durch "muls" ersetzt werden.

Der Befehl "muls" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
signed 32 Bit Ergebnis "r"

@endnode

@node mulu

@{FG SHINE}mulu@{FG TEXT}
unsigned 32 Bit mal 32 Bit Multiplikation mit 32 Bit Ergebnis

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = mulu (arg1, arg2);

ulong r;
ulong arg1;
ulong arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "mulu" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "mulu" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UMult32 " link "StormC:StormSYS/Help/utility/UMult32()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "UMult32"
einfach durch "mulu" ersetzt werden.

Der Befehl "mulu" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
unsigned 32 Bit Ergebnis "r"

@endnode

@node divsl

@{FG SHINE}divsl@{FG TEXT}
signed 32 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divsl (dividend, divisor);

long quotient;
long remainder
long dividend;
long divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divsl" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".
Der Befehl "divsl" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SDivMod32 " link "StormC:StormSYS/Help/utility/SDivMod32()"} der "utility.library".
Da die Funktion und der Aufruf beider Befehle identisch ist, kann
"SDivMod32" einfach durch "divsl" ersetzt werden.

@{B}Rückgabe@{UB}
signed 32 Bit Quotient "quotient"
signed 32 Bit Rest "remainder"

@endnode

@node divul

@{FG SHINE}divul@{FG TEXT}
unsigned 32 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divul (dividend, divisor);

ulong quotient;
ulong remainder
ulong dividend;
ulong divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divul" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".
Der Befehl "divul" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UDivMod32 " link "StormC:StormSYS/Help/utility/UDivMod32()"} der "utility.library".
Da die Funktion und der Aufruf beider Befehle identisch ist, kann
"UDivMod32" einfach durch "divul" ersetzt werden.

@{B}Rückgabe@{UB}
unsigned 32 Bit Quotient "quotient"
unsigned 32 Bit Rest "remainder"

@endnode

@node muls64

@{FG SHINE}muls64@{FG TEXT}
signed 32 Bit mal 32 Bit Multiplikation mit 64 Bit Ergebnis

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = muls64 (arg1, arg2);

long r;
long arg1;
long arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "muls64" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "muls64" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SMult64 " link "StormC:StormSYS/Help/utility/SMult64()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "SMult64"
einfach durch "muls64" ersetzt werden.
Im Gegensatz zu "SMult64", benötigt "muls64" nicht AmigaOS 3.x,
sondern ist bereits ab AmigaOS 2.x lauffähig.

@{B}Rückgabe@{UB}
signed 64 Bit Ergebnis "r"

@endnode

@node mulu64

@{FG SHINE}mulu64@{FG TEXT}
unsigned 32 Bit mal 32 Bit Multiplikation mit 64 Bit Ergebnis

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = mulu64 (arg1, arg2);

ulong r;
ulong arg1;
ulong arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "mulu64" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "mulu64" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UMult64 " link "StormC:StormSYS/Help/utility/UMult64()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "UMult64"
einfach durch "mulu64" ersetzt werden.
Im Gegensatz zu "UMult64", benötigt "mulu64" nicht AmigaOS 3.x,
sondern ist bereits ab AmigaOS 2.x lauffähig.

@{B}Rückgabe@{UB}
unsigned 64 Bit Ergebnis "r"

@endnode

@node divs64

@{FG SHINE}divs64@{FG TEXT}
signed 64 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divs64 (dividend, divisor);

long quotient;
long remainder
long dividend;
long divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divs64" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".

@{B}Rückgabe@{UB}
signed 32 Bit Quotient "quotient"
signed 32 Bit Rest "remainder"

@endnode

@node divu64

@{FG SHINE}divu64@{FG TEXT}
unsigned 64 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divu64 (dividend, divisor);

ulong quotient;
ulong remainder
ulong dividend;
ulong divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divu64" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".

@{B}Rückgabe@{UB}
unsigned 32 Bit Quotient "quotient"
unsigned 32 Bit Rest "remainder"

@endnode

@node muls_r

@{FG SHINE}muls_r@{FG TEXT}
signed 32 Bit mal 32 Bit Multiplikation mit 32 Bit Ergebnis
@{I}Registerversion von "muls"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = muls_r (register __d0 arg1, register __d1 arg2);

long r;
long arg1;
long arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "muls_r" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "muls_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SMult32 " link "StormC:StormSYS/Help/utility/SMult32()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "SMult32"
einfach durch "muls_r" ersetzt werden.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
signed 32 Bit Ergebnis "r"

@endnode

@node mulu_r

@{FG SHINE}mulu_r@{FG TEXT}
unsigned 32 Bit mal 32 Bit Multiplikation mit 32 Bit Ergebnis
@{I}Registerversion von "mulu"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = mulu_r (register __d0 arg1, register __d1 arg2);

ulong r;
ulong arg1;
ulong arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "mulu_r" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "mulu_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UMult32 " link "StormC:StormSYS/Help/utility/UMult32()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "UMult32"
einfach durch "mulu_r" ersetzt werden.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
unsigned 32 Bit Ergebnis "r"

@endnode

@node divsl_r

@{FG SHINE}divsl_r@{FG TEXT}
signed 32 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest
@{I}Registerversion von "divsl"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divsl_r (register __d0 dividend, register __d1 divisor);

long quotient;
long remainder
long dividend;
long divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divsl_r" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".
Der Befehl "divsl_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SDivMod32 " link "StormC:StormSYS/Help/utility/SDivMod32()"} der "utility.library".
Da die Funktion und der Aufruf beider Befehle identisch ist, kann
"SDivMod32" einfach durch "divsl_r" ersetzt werden.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
signed 32 Bit Quotient "quotient"
signed 32 Bit Rest "remainder"

@endnode

@node divul_r

@{FG SHINE}divul_r@{FG TEXT}
unsigned 32 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest
@{I}Registerversion von "divul"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divul_r (register __d0 dividend, register __d1 divisor);

ulong quotient;
ulong remainder
ulong dividend;
ulong divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divul_r" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".
Der Befehl "divul_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UDivMod32 " link "StormC:StormSYS/Help/utility/UDivMod32()"} der "utility.library".
Da die Funktion und der Aufruf beider Befehle identisch ist, kann
"UDivMod32" einfach durch "divul_r" ersetzt werden.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
unsigned 32 Bit Quotient "quotient"
unsigned 32 Bit Rest "remainder"

@endnode

@node muls64_r

@{FG SHINE}muls64_r@{FG TEXT}
signed 32 Bit mal 32 Bit Multiplikation mit 64 Bit Ergebnis
@{I}Registerversion von "muls64"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = muls64_r (register __d0 arg1, register __d1 arg2);

long r;
long arg1;
long arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "muls64_r" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "muls64_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" SMult64 " link "StormC:StormSYS/Help/utility/SMult64()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "SMult64"
einfach durch "muls64_r" ersetzt werden.
Im Gegensatz zu "SMult64", benötigt "muls64_r" nicht AmigaOS 3.x,
sondern ist bereits ab AmigaOS 2.x lauffähig.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
signed 64 Bit Ergebnis "r"

@endnode

@node mulu64_r

@{FG SHINE}mulu64_r@{FG TEXT}
unsigned 32 Bit mal 32 Bit Multiplikation mit 64 Bit Ergebnis
@{I}Registerversion von "mulu64"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = mulu64_r (register __d0 arg1, register __d1 arg2);

ulong r;
ulong arg1;
ulong arg2;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "mulu64_r" multipliziert "arg1" mit "arg2" und ermittelt
das Ergebnis "r".
Der Befehl "mulu64_r" ist ein sehr schneller und sehr kleiner Ersatz
für den Befehl @{" UMult64 " link "StormC:StormSYS/Help/utility/UMult64()"} der "utility.library". Da die Funktion
und der Aufruf beider Befehle identisch ist, kann "UMult64"
einfach durch "mulu64_r" ersetzt werden.
Im Gegensatz zu "UMult64", benötigt "mulu64_r" nicht AmigaOS 3.x,
sondern ist bereits ab AmigaOS 2.x lauffähig.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
unsigned 64 Bit Ergebnis "r"

@endnode

@node divs64_r

@{FG SHINE}divs64_r@{FG TEXT}
signed 64 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest
@{I}Registerversion von "divs64"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divs64_r (register __d0 dividend, register __d1 divisor);

long quotient;
long remainder
long dividend;
long divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divs64_r" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
signed 32 Bit Quotient "quotient"
signed 32 Bit Rest "remainder"

@endnode

@node divu64_r

@{FG SHINE}divu64_r@{FG TEXT}
unsigned 64 Bit durch 32 Bit Division mit 32 Bit Quotient und Rest
@{I}Registerversion von "divu64"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

quotient : remainder = divu64_r (register __d0 dividend, register __d1 divisor);

ulong quotient;
ulong remainder
ulong dividend;
ulong divisor;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "divu64_r" teilt den Dividenden "dividend" durch den
Divisor "divisor" und ermittelt den Quotient "quotient" und den
Rest "remainder".

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
unsigned 32 Bit Quotient "quotient"
unsigned 32 Bit Rest "remainder"

@endnode

@node button_al

@{FG SHINE}button_al@{FG TEXT}
Abfrage der linken Maus- oder Joysticktaste an Port A

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button_al ();

int r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button_al" ist zur Abfrage der linken Maus- oder
Joysticktaste an Port A. Wenn zum Zeitpunkt der Abfrage die
entsprechende Taste betätigt ist, wird 1 zurückgegeben, sonst 0.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
start:
    if (!button_al ())
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node button_ar

@{FG SHINE}button_ar@{FG TEXT}
Abfrage der rechten Maustaste an Port A

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button_ar ();

int r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button_ar" ist zur Abfrage der rechten Maustaste an Port A.
Wenn zum Zeitpunkt der Abfrage die entsprechende Taste betätigt ist,
wird 1 zurückgegeben, sonst 0.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
start:
    if (!button_ar ())
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node button_bl

@{FG SHINE}button_bl@{FG TEXT}
Abfrage der linken Maus- oder Joysticktaste an Port B

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button_bl ();

int r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button_bl" ist zur Abfrage der linken Maus- oder
Joysticktaste an Port B. Wenn zum Zeitpunkt der Abfrage die
entsprechende Taste betätigt ist, wird 1 zurückgegeben, sonst 0.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
start:
    if (!button_bl ())
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node button_br

@{FG SHINE}button_br@{FG TEXT}
Abfrage der rechten Maustaste an Port B

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button_br ();

int r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button_br" ist zur Abfrage der rechten Maustaste an Port B.
Wenn zum Zeitpunkt der Abfrage die entsprechende Taste betätigt ist,
wird 1 zurückgegeben, sonst 0.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
start:
    if (!button_br ())
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node button

@{FG SHINE}button@{FG TEXT}
Abfrage der Maus- und Joysticktasten

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button (port, button);

int r;
int port;
int button;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button" ist zur Abfrage der Maus- und Joysticktasten.
Für "port" kann 0, für Port A, oder 1, für Port B, angegeben werden.
Für "button" kann 0, für die linke Maustaste oder die Feuertaste am
Joystick, oder 1, für die rechte Maustaste, angegeben werden.
Wenn zum Zeitpunkt der Abfrage die entsprechende Taste betätigt ist,
wird 1 zurückgegeben, sonst 0.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
 int p = 0; // Port A
 int b = 0; // linke Maustaste oder Feuertaste

start:
    if (!button (p, b))
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node button_r

@{FG SHINE}button_r@{FG TEXT}
Abfrage der Maus- und Joysticktasten
@{I}Registerversion von "button"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = button_r (register __d0 port, register __d1 button);

int r;
int port;
int button;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "button_r" ist zur Abfrage der Maus- und Joysticktasten.
Für "port" kann 0, für Port A, oder 1, für Port B, angegeben werden.
Für "button" kann 0, für die linke Maustaste oder die Feuertaste am
Joystick, oder 1, für die rechte Maustaste, angegeben werden.
Wenn zum Zeitpunkt der Abfrage die entsprechende Taste betätigt ist,
wird 1 zurückgegeben, sonst 0.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
1 wenn die entsprechende Taste betätigt ist, sonst 0

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
 int p = 0; // Port A
 int b = 0; // linke Maustaste oder Feuertaste

start:
    if (!button_r (p, b))
	goto start;
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton_al

@{FG SHINE}waitbutton_al@{FG TEXT}
Abfrage der linken Maus- oder Joysticktaste an Port A

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton_al ();

void r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton_al" ist zur Abfrage der linken Maus- oder
Joysticktaste an Port A. Das Programm wartet solange, bis die
richtige Taste betätigt wird.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
    waitbutton_al ();
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton_ar

@{FG SHINE}waitbutton_ar@{FG TEXT}
Abfrage der rechten Maustaste an Port A

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton_ar ();

void r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton_ar" ist zur Abfrage der rechten Maustaste an Port A.
Das Programm wartet solange, bis die richtige Taste betätigt wird.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
    waitbutton_ar ();
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton_bl

@{FG SHINE}waitbutton_bl@{FG TEXT}
Abfrage der linken Maus- oder Joysticktaste an Port B

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton_bl ();

void r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton_bl" ist zur Abfrage der linken Maus- oder
Joysticktaste an Port B. Das Programm wartet solange, bis die
richtige Taste betätigt wird.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
    waitbutton_bl ();
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton_br

@{FG SHINE}waitbutton_br@{FG TEXT}
Abfrage der rechten Maustaste an Port B

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton_br ();

void r;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton_br" ist zur Abfrage der rechten Maustaste an Port B.
Das Programm wartet solange, bis die richtige Taste betätigt wird.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
    waitbutton_br ();
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton

@{FG SHINE}waitbutton@{FG TEXT}
Abfrage der Maus- und Joysticktasten

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton (port, button);

void r;
int port;
int button;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton" ist zur Abfrage der Maus- und Joysticktasten.
Für "port" kann 0, für Port A, oder 1, für Port B, angegeben werden.
Für "button" kann 0, für die linke Maustaste oder die Feuertaste am
Joystick, oder 1, für die rechte Maustaste, angegeben werden.
Das Programm wartet solange, bis die richtige Taste betätigt wird.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
 int p = 0; // Port A
 int b = 0; // linke Maustaste oder Feuertaste

    waitbutton (p, b);
    printf ("Hello World!\\n");
}

@endnode

@node waitbutton_r

@{FG SHINE}waitbutton_r@{FG TEXT}
Abfrage der Maus- und Joysticktasten
@{I}Registerversion von "waitbutton"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r = waitbutton_r (register __d0 port, register __d1 button);

void r;
int port;
int button;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "waitbutton_r" ist zur Abfrage der Maus- und Joysticktasten.
Für "port" kann 0, für Port A, oder 1, für Port B, angegeben werden.
Für "button" kann 0, für die linke Maustaste oder die Feuertaste am
Joystick, oder 1, für die rechte Maustaste, angegeben werden.
Das Programm wartet solange, bis die richtige Taste betätigt wird.

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
keine

@{B}Beispiel@{UB}
#include <stormamiga.h>

main()
{
 int p = 0; // Port A
 int b = 0; // linke Maustaste oder Feuertaste

    waitbutton_r (p, b);
    printf ("Hello World!\\n");
}

@endnode

@node max_Height

@{FG SHINE}max_Height@{FG TEXT}
Ermitteln der sichtbaren Fensterhöhe

@{B}Übersicht@{UB}
#include <stormamiga.h>

r =  max_Height (window);

int r;
struct  Window  *window;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "max_Height" ermittelt die sichtbare Höhe des Fensters
"window".

Der Befehl "max_Height" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die sichtbare Höhe des Fensters "window".

@endnode

@node max_Height_r

@{FG SHINE}max_Height_r@{FG TEXT}
Ermitteln der sichtbaren Fensterhöhe
@{I}Registerversion von "max_Height"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r =  max_Height_r (register __a0 window);

int r;
struct  Window  *window;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "max_Height_r" ermittelt die sichtbare Höhe des Fensters
"window".

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
Die sichtbare Höhe des Fensters "window".

@endnode

@node max_Width

@{FG SHINE}max_Width@{FG TEXT}
Ermitteln der sichtbaren Fensterbreite

@{B}Übersicht@{UB}
#include <stormamiga.h>

r =  max_Width (window);

int r;
struct  Window  *window;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "max_Width" ermittelt die sichtbare Breite des Fensters
"window".

Der Befehl "max_Width" ist auch als @{" Inlinefunktion " link "Inlinefunktionen"} verfügbar.

@{B}Rückgabe@{UB}
Die sichtbare Breite des Fensters "window".

@endnode

@node max_Width_r

@{FG SHINE}max_Width_r@{FG TEXT}
Ermitteln der sichtbaren Fensterbreite
@{I}Registerversion von "max_Width"@{UI}

@{B}Übersicht@{UB}
#include <stormamiga.h>

r =  max_Width_r (register __a0 window);

int r;
struct  Window  *window;

@{B}Standard@{UB}
(noch) keiner (Eigenentwicklung)

@{B}Erklärung@{UB}
Der Befehl "max_Width_r" ermittelt die sichtbare Breite des Fensters
"window".

Siehe auch bei @{" Registerfunktionen " link "Registerfunktionen"}.

@{B}Rückgabe@{UB}
Die sichtbare Breite des Fensters "window".

@endnode

@node Stringpuffer

@{FG SHINE}Der Stringpuffer "s"@{FG TEXT}

Der Stringpuffer "s" muß mindestens so groß sein, daß die
Ausgabe mit abschließenden Nullzeichen hineinpaßt.
Die Funktion kann nicht feststellen ob der Stringpuffer groß
genug ist.

@endnode

@node Parameterliste

@{FG SHINE}Die Parameterliste "vl"@{FG TEXT}

Die Parameterliste "vl" muß vor dem Aufruf mit va_start initialisiert
werden und nach dem Aufruf mit va_end abgeschlossen werden.

@endnode

@node Ausgabeformatstring_

@{FG SHINE}Der Ausgabeformatstring_ "format" zur formatierten Ausgabe@{FG TEXT}
Der Formatstring "format" zur formatierten Ausgabe besteht aus
Formatkommandos und Ausgabezeichen. Die Formatkommandos bestimmen
den Typ der Parameter der Ausgabefunktion und die Art der Konver-
tierung und Ausgabe. Alle Zeichen, die kein Formatkommando sind,
also nicht mit dem Zeichen "%" beginnen sind Ausgabezeichen und
werden unverändert ausgegeben.

Der Aufbau eines Formatkommandos:

% [flags] [width [.limit] ] [size] type

Die Angaben in den eckigen Klammern können optional angegeben werden.

@{B}flags@{UB}
"-" zur Linksjustierung;
"+" zur Ausgabe auch eines positiven Vorzeichens bei Zahlen;
"0" zur Ausgabe führender Nullen bei Zahlen;
"#" zur Ausgabe von "0x" bei hexadezimalen Zahlen und "0" bei
    oktalen Zahlen

@{B}width@{UB}
Feldbreite als dezimale Ziffernfolge oder "*", in diesem Fall wird
die Feldbreite als nächstes Argument des Typs int übergeben. Die
Feldbreite ist immer ein minimaler Wert, zu lange Ausgaben werden
nicht beschnitten.

@{B}limit@{UB}
Die Genauigkeit als dezimale Ziffernfolge oder "*", in diesem Fall
wird die Genauigkeit als nächstes Argument des Typs int übergeben.
Der Wert beschreibt die maximale Anzahl von Zeichen bei Ausgabe
einer Zeichenkette oder die minimale Anzahl von Ziffern einer ganz-
zahligen Ausgabe.

@{B}size@{UB}
Längenangabe des Arguments:
"h" für ein Argument des Typs short int oder unsigned short int;
"l" für ein Argument des Typs long int oder unsigned long int;
"L" für ein Argument des Typs long long int oder unsigned long long int;

@{B}type@{UB}
Typangabe des Arguments:

"d"
"i" zur Ausgabe einer vorzeichenbehafteten Dezimalzahl, das zuge-
    hörige Argument ist vom Typ int

"o" zur Ausgabe einer vorzeichenlosen Oktalzahl, das zugehörige
    Argument ist vom Typ int oder unsigned int

"x" zur Ausgabe einer vorzeichenlosen Hexadezimalzahl mit Kleinbuch-
    staben, das zugehörige Argument ist vom Typ int oder unsigned int

"X" zur Ausgabe einer vorzeichenlosen Hexadezimalzahl mit Großbuch-
    staben, das zugehörige Argument ist vom Typ int oder unsigned int

"u" zur Ausgabe einer vorzeichenlosen Dezimalzahl, das zugehörige
    Argument ist vom Typ unsigned int

"c" zur Ausgabe eines Zeichens, das zugehörige Argument ist vom Typ
    int und wird in unsigned char konvertiert

"s" zur Ausgabe einer Zeichenkette, die mit einem Nullzeichen abge-
    schlossen ist, das zugehörige Argument ist vom Typ char *

"p" zur Ausgabe einer hexadezimalen Speicheradresse, das zugehörige
    Argument ist vom Typ void *;

"n" zur Speicherung der Anzahl der bisher von diesem Funktionsaufruf
    ausgegebenen Zeichen in der Variablen, auf die das Argument vom
    Typ int * zeigt, es erfolgt keine Ausgabe

"%" zur Ausgabe eines Prozentzeichens

Alle anderen Typangaben führen zu undefinierten Ausgaben.

@endnode


@node Eingabeformatstring

@{FG SHINE}Der Eingabeformatstring "format" zur formatierten Eingabe@{FG TEXT}
Der Formatstring "format" zur formatierten Eingabe besteht aus den
Formatkommandos und Eingabezeichen. Die Formatkommandos bestimmen
den Typ der Parameter der Eingabefunktion und die Art der Konver-
tierung und Eingabe. Alle Zeichen, die kein Formatkommando sind,
also nicht mit dem Zeichen "%" beginnen und keine Trennzeichen (Leer-
zeichen, Tabulatoren und Zeilenvorschübe) sind, sind Eingabezeichen
und werden unverändert in der Eingabe erwartet.

Der Aufbau eines Formatkommandos:

% [width] [size] type

Die Angaben in den eckigen Klammern können optional angegeben werden.

@{B}width@{UB}
Die Anzahl der zu lesenden Zeichen als dezimale Ziffernfolge oder "*",
in diesem Fall werden die Zeichen zwar gelesen, aber nicht in das
nächste Argument übertragen.

@{B}size@{UB}
Längenangabe des Arguments:
"h" für ein Argument des Typs short int oder unsigned short int
"l" für ein Argument des Typs long int oder unsigned long int
"L" für ein Argument des Typs long long int oder unsigned long long int;

@{B}type@{UB}
Typangabe des Arguments:

"d" zur Eingabe einer vorzeichenbehafteten dezimalen Ganzzahl, das zuge-
    hörige Argument ist vom Typ int *

"i" zur Eingabe einer vorzeichenbehafteten Dezimalzahl, Oktalzahl (bei
    führender '0') oder Hexadezimalzahl (bei führendem '0x' oder '0X'),
    das zugehörige Argument ist vom Typ int *

"o" zur Eingabe einer Oktalzahl, das zugehörige Argument ist vom Typ int *

"x" zur Eingabe einer Hexadezimalzahl mit oder ohne '0x', das zugehörige
    Argument ist vom Typ int oder unsigned int

"c" zur Eingabe von "width" Zeichen, wobei Leerzeichen und Zeilentrenner
    nicht überlesen werden und kein Nullzeichen angehängt wird, das zuge-
    hörige Argument ist vom Typ char *

"s" zur Eingabe einer Zeichenkette, wobei führende Leerzeichen und Zeilen-
    trenner überlesen werden und ein Nullzeichen angehängt wird, das zuge-
    hörigen Argument ist vom Typ char *

"e"
"f"
"g" zur Eingabe einer Fließkommazahl in beliebiger Darstellung, das zuge-
    hörige Argument ist vom Typ float *

"p" zur Eingabe einer hexadezimalen Speicheradresse, das zugehörige Argument
    ist vom Typ int *

"n" zur Speicherung der Anzahl der bisher von diesem Funktionsaufruf gele-
    senen Zeichen in der Variablen, auf die das Argument vom Typ int * zeigt,
    es wird kein Zeichen gelesen.

"[...]"  zur Eingabe einer Zeichenkette, die nur aus den in den eckigen
	 Klammern angegebenen Zeichen besteht, wobei ein Nullzeichen ange-
	 hängt wird, das zugehörigen Argument ist vom Typ char *

"[^...]" zur Eingabe einer Zeichenkette, die nur aus Zeichen besteht, die
	 nicht in den eckigen Klammern angegebenen sind, wobei ein Null-
	 zeichen angehängt wird; das zugehörigen Argument ist vom Typ char *

"%%"     zur Eingabe eines Prozentzeichens

Alle anderen Typangaben führen zu undefinierten Eingaben.

@endnode

@node Eingabeformatstring_

@{FG SHINE}Der Eingabeformatstring_ "format" zur formatierten Eingabe@{FG TEXT}
Der Formatstring "format" zur formatierten Eingabe besteht aus den
Formatkommandos und Eingabezeichen. Die Formatkommandos bestimmen
den Typ der Parameter der Eingabefunktion und die Art der Konver-
tierung und Eingabe. Alle Zeichen, die kein Formatkommando sind,
also nicht mit dem Zeichen "%" beginnen und keine Trennzeichen (Leer-
zeichen, Tabulatoren und Zeilenvorschübe) sind, sind Eingabezeichen
und werden unverändert in der Eingabe erwartet.

Der Aufbau eines Formatkommandos:

% [width] [size] type

Die Angaben in den eckigen Klammern können optional angegeben werden.

@{B}width@{UB}
Die Anzahl der zu lesenden Zeichen als dezimale Ziffernfolge oder "*",
in diesem Fall werden die Zeichen zwar gelesen, aber nicht in das
nächste Argument übertragen.

@{B}size@{UB}
Längenangabe des Arguments:
"h" für ein Argument des Typs short int oder unsigned short int
"l" für ein Argument des Typs long int oder unsigned long int
"L" für ein Argument des Typs long long int oder unsigned long long int;

@{B}type@{UB}
Typangabe des Arguments:

"d" zur Eingabe einer vorzeichenbehafteten dezimalen Ganzzahl, das zuge-
    hörige Argument ist vom Typ int *

"i" zur Eingabe einer vorzeichenbehafteten Dezimalzahl, Oktalzahl (bei
    führender '0') oder Hexadezimalzahl (bei führendem '0x' oder '0X'),
    das zugehörige Argument ist vom Typ int *

"o" zur Eingabe einer Oktalzahl, das zugehörige Argument ist vom Typ int *

"x" zur Eingabe einer Hexadezimalzahl mit oder ohne '0x', das zugehörige
    Argument ist vom Typ int oder unsigned int

"c" zur Eingabe von "width" Zeichen, wobei Leerzeichen und Zeilentrenner
    nicht überlesen werden und kein Nullzeichen angehängt wird, das zuge-
    hörige Argument ist vom Typ char *

"s" zur Eingabe einer Zeichenkette, wobei führende Leerzeichen und Zeilen-
    trenner überlesen werden und ein Nullzeichen angehängt wird, das zuge-
    hörigen Argument ist vom Typ char *

"p" zur Eingabe einer hexadezimalen Speicheradresse, das zugehörige Argument
    ist vom Typ int *

"n" zur Speicherung der Anzahl der bisher von diesem Funktionsaufruf gele-
    senen Zeichen in der Variablen, auf die das Argument vom Typ int * zeigt,
    es wird kein Zeichen gelesen.

"[...]"  zur Eingabe einer Zeichenkette, die nur aus den in den eckigen
	 Klammern angegebenen Zeichen besteht, wobei ein Nullzeichen ange-
	 hängt wird, das zugehörigen Argument ist vom Typ char *

"[^...]" zur Eingabe einer Zeichenkette, die nur aus Zeichen besteht, die
	 nicht in den eckigen Klammern angegebenen sind, wobei ein Null-
	 zeichen angehängt wird; das zugehörigen Argument ist vom Typ char *

"%%"     zur Eingabe eines Prozentzeichens

Alle anderen Typangaben führen zu undefinierten Eingaben.

@endnode

@node Zeitformatstring

@{FG SHINE}Zeitformatstring zur Konvertierung einer Zeitangabe.@{FG TEXT}
Der Zeitformatstring "format" zur formatierten Ausgabe von Datum und Zeit besteht
aus den Formatkommandos und Eingabezeichen. Die Formatkommandos bestimmen den
Typ der Parameter der Ausgabefunktion und die Art der Konvertierung und Ausgabe.
Alle Zeichen, die kein Formatkommando sind, also nicht mit dem Zeichen "%" beginnen
sind Ausgabezeichen und werden unverändert ausgegeben.

Der Aufbau eines Formatkommandos:

%type

@{B}type@{UB}
Typangabe des Arguments:

"a" für den abgekürzten Namen des Wochentages (Mon, Tue, ...)

"A" für den vollständigen Namen des Wochentages

"b"
"h" für den abgekürzten Namen des Monats (Jan, Feb, ...)

"B" für den vollständigen Namen des Monats

"c" für die Kurzdarstellung von Datum und Uhrzeit ("%m/%d/%y %I:%M:%S")

"C" für die Darstellung im Format "%a %b %e %I:%M:%S %Y"

"d" für die Nummer des Tages des Monats (01 bis 31)

"e" für die Nummer des Tages des Monats ( 1 bis 31)

"H" für die amerikanische Stundendarstellung (01 bis 12)

"I" für die europäische Stundendarstellung (00 bis 23)

"j" für die Nummer des Tages im Jahr (001 bis 366)

"k" für die europäische Stundendarstellung ( 0 bis 23)

"l" für die amerikanische Stundendarstellung ( 1 bis 12)

"m" für die Nummer des Monats (01 bis 12)

"M" für die Anzahl der Minuten (00 bis 59)

"n" für eine neue Zeile

"p" für die Tageshälfte ("AM" oder "PM")

"r" für die Darstellung im Format "%H:%M:%S %p"

"R" für die Darstellung im Format "%I:%M"

"S" für die Anzahl von Sekunden (00 bis 60)

"t" für einen Tabulator

"u" für die Nummer des Wochentages (1 bis 7); Montag ist erster Wochentag

"U" für die Nummer der Woche im Jahr (00 bis 53); Sonntag ist erster Wochentag

"V" für die Nummer der Woche im Jahr (01 bis 53); Montag ist erster Wochentag

"w" für die Nummer des Wochentages (0 bis 6); Sonntag ist erster Wochentag

"W" für die Nummer der Woche im Jahr (00 bis 53); Montag ist erster Wochentag

"x"
"D" für die Kurzdarstellung des Datums ("%m/%d/%y")

"X"
"T" für die Kurzdarstellung der Uhrzeit ("%I:%M:%S")

"y" für die Jahreszahl ohne Jahrhundert

"Y" für die vollständige Jahreszahl mit Jahrhundert

"Z" für den Namen der Zeitzone

"%" für ein Prozentzeichen

Alle anderen Typangaben führen zu undefinierten Ausgaben.

@endnode


@node Anwendungshinweise

@{B}@{FG SHINE}Anwendungshinweise:
~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Obwohl die Anwendung der "stormamiga.lib" sehr einfach ist, möchte
ich in diesem Abschnitt einige Hinweise geben.


 @{" Allgemeine Hinweise " link "Allgemeine Hinweise"}    Nützliche Hinweise zur Anwendung.

 @{" Inlinefunktionen    " link "Inlinefunktionen"}    Beschreibung der Inlinefunktionen.

 @{" Registerfunktionen  " link "Registerfunktionen"}    Beschreibung der Registerfunktionen.

 @{" Deutsche Funktionen " link "Deutsche Funktionen"}    Beschreibung der deutschen Funktionen.

 @{" Amiga - Funktionen  " link "Amiga-Funktionen"}    Beschreibung der Amiga - Funktionen.

 @{" Alpha - Funktionen  " link "Alpha-Funktionen"}    Beschreibung der Alpha - Funktionen.

@endnode

@node "Allgemeine Hinweise"

@{B}@{FG SHINE}Allgemeine Hinweise:
~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Die "stormamiga.lib" ist die Basisbibliothek für den MC68EC020
oder höher. Sie enthält die Funktionen für das große Codemodell
in Verbindung mit dem großen Datenmodell und dem kleinen Daten-
modell A4.

Die "stormamiga_nc.lib" ist die Basisbibliothek für den MC68EC020
oder höher. Sie enthält die Funktionen für das kleine Codemodell
in Verbindung mit dem großen Datenmodell und dem kleinen Daten-
modell A4.

Die "stormamiga_881.lib" ist die Erweiterungsbibliothek für den
MC68881 oder höher. Sie enthält die mathematischen Funktionen für
das große Codemodell in Verbindung mit dem großen Datenmodell und
dem kleinen Datenmodell A4.

Die "stormamiga_nc_881.lib" ist die Erweiterungsbibliothek für den
MC68881 oder höher. Sie enthält die mathematischen Funktionen für
das kleine Codemodell in Verbindung mit dem großen Datenmodell und
dem kleinen Datenmodell A4.

Die "stormamiga_040.lib" ist die Erweiterungsbibliothek für den
MC68040 oder höher. Sie enthält die mathematischen Funktionen für
das große Codemodell in Verbindung mit dem großen Datenmodell und
dem kleinen Datenmodell A4.

Die "stormamiga_nc_040.lib" ist die Erweiterungsbibliothek für den
MC68040 oder höher. Sie enthält die mathematischen Funktionen für
das kleine Codemodell in Verbindung mit dem großen Datenmodell und
dem kleinen Datenmodell A4.

Die "stormamiga_060.lib" ist die Erweiterungsbibliothek für den
MC68060. Sie enthält die mathematischen Funktionen für das große
Codemodell in Verbindung mit dem großen Datenmodell und dem kleinen
Datenmodell A4.

Die "stormamiga_nc_060.lib" ist die Erweiterungsbibliothek für den
MC68060. Sie enthält die mathematischen Funktionen für das kleine
Codemodell in Verbindung mit dem großen Datenmodell und dem kleinen
Datenmodell A4.

Die Includedatei "stormamiga.h" enthält die Deklaration für alle
Spezialfunktionen.
Um nicht ständig unendliche Verse wie "unsigned long long int"
schreiben zu müssen, habe ich kurze Worte wie "ullint" definiert.

@{B}Definitionen@{UB}

uchar  für unsigned char
ushort für unsigned short
lint   für long int
llint  für long long int
uint   für unsigned int
ulint  für unsigned long int
ullint für unsigned long long int
llong  für long long
ulong  für unsigned long
ullong für unsigned long long

Die Includedatei "stormamigainline.h" enthält alle verfügbaren
@{" Inlinefunktionen " link "Inlinefunktionen"}.

Wenn Sie Fragen zum Startupcode haben, dann sehen Sie bitte bei
@{" Der Startupcode " link "Startupcode"} nach.

Alle Funktionen mit dem Namen "..._r" (z.B.: "mulu_r") sind
@{" Registerfunktionen " link "Registerfunktionen"}.

Alle Funktionen mit dem Namen "..._d" (z.B.: "ctime_d") sind
@{" Deutsche Funktionen " link "Deutsche Funktionen"}.


Wenn Ihre Quelltexte auch mit anderen Compilern problemlos
funktionieren sollen, dann sollten Sie Ihre Quelltexte wie
dieses Beispiel gestalten.

@{B}Beispiel@{UB}

#ifdef __STORM__
  #define STORMAMIGA_INLINE
  #define STORMAMIGA_DEUTSCH
  #include <stormamiga.h>
  #define printf printf_
  #define main main__
#endif

#include <stdio.h>
#include <time.h>

int main (void)
{
  struct tm *tp;
  time_t t;

  time (&t);
  tp = localtime (&t);
  printf ("Die aktuelle Zeit ist %s", asctime (tp));
  return 0;
}

@endnode

@node Inlinefunktionen

@{B}@{FG SHINE}Die Inlinefunktionen:
~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Die Inlinefunktionen werden, wie der Name schon sagt, an die Stelle
(in die Zeile oder Linie) des Funktionsaufrufes eingefügt. Dadurch
werden die Programme meistens etwas kürzer und schneller. Bei keiner
oder geringer Optimierung kann es sein, daß die Programme wesentlich
größer und langsamer werden.

Wenn Sie die Inlinefunktionen nutzen wollen, müssen Sie die Zeile
"#define STORMAMIGA_INLINE", vor dem Aufruf der Includedatei
"stormamiga.h", in Ihr Programm einbinden. Sie können "#define
STORMAMIGA_INLINE" aber auch bei den Compileroptionen (Preprozessor)
des Menüs Einstellungen eintragen.

@{B}Hinweis:@{UB}
Wenn die Definitionen "STORMAMIGA_REGISTER" und "STORMAMIGA_INLINE"
gleichzeitig verwendet werden, dann werden die Inlinefunktionen, weil
sie kürzer und schneller sind, vorrangig eingesetzt.

@{U}@{B}Alle verfügbaren Funktionen:@{UU}@{UB}

@{B}stdio Funktionen@{UB}
fgetc()         getc()          getchar()       ungetc()
fputc()         putc()          putchar()       feof()
ferror()        clearerr()      perror()        remove()
rename()        setbuf()        setbuffer()     setlinebuf()
vprintf()       vprintf_()      vscanf()        vscanf_()

@{B}string Funktionen@{UB}
memcpy()        memmove()       memset()        memchr()
memcmp()

@{B}stdlib Funktionen@{UB}
atoi()          atol()          atoll()         atof()
abort()

@{B}time Funktionen@{UB}
localtime()     ctime()         difftime()      ctime_d()

@{B}Spezial Funktionen@{UB}
muls()          mulu()          max_Height()    max_Width()

@{B}amiga.lib Funktionen@{UB}
CreateExtIO()   CreateStdIO()   DeleteExtIO()   DeleteStdIO()
DeleteTask()    NewList()       RemTOF()        waitbeam()

@{B}Amiga Funktionen@{UB}
Move()          GetAPen()       GetBPen()

@{B}Alpha Funktionen@{UB}
SetAPen()       SetBPen()

@endnode

@node Registerfunktionen

@{B}@{FG SHINE}Die Registerfunktionen:
~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Bei den Registerfunktionen werden die Daten und Parameter nicht über
den Stackpointer, sondern über festgelegte Register übergeben. Dadurch
werden die Programme manchmal etwas kürzer und schneller.

Wenn Sie alle Registerfunktionen nutzen wollen, müssen Sie die Zeile
"#define STORMAMIGA_REGISTER", vor dem Aufruf der Includedatei
"stormamiga.h", in Ihr Programm einbinden. Sie können "#define
STORMAMIGA_REGISTER" aber auch bei den Compileroptionen (Preprozessor)
des Menüs Einstellungen eintragen.
Wenn Sie nur einige Registerfunktionen verwenden wollen, müssen Sie an
die Namen der entsprechenden Funktionen "_r" anhängen (aus "button" wird
also "button_r").

@{B}Hinweis:@{UB}
Wenn die Definitionen "STORMAMIGA_REGISTER" und "STORMAMIGA_INLINE"
gleichzeitig verwendet werden, dann werden die Inlinefunktionen, weil
sie kürzer und schneller sind, vorrangig eingesetzt.

@{U}@{B}Alle verfügbaren Funktionen:@{UU}@{UB}

@{B}Spezial Funktionen@{UB}
muls_r()        mulu_r()        divsl_r()       divul_r()
muls64_r()      mulu64_r()      divs64_r()      divu64_r()
button_r()      waitbutton_r()  max_Height_r()  max_Width_r()

@{B}Amiga Funktionen@{UB}
Move_r()        GetAPen_r()     GetBPen_r()

@{B}Alpha Funktionen@{UB}
SetAPen_r()     SetBPen_r()

@endnode

@node "Deutsche Funktionen"

@{B}@{FG SHINE}Die deutschen Funktionen:
~~~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Da in "ANSI C" und "C++" keine Umlaute unterstützt werden und alle
Texte auf englisch ausgegeben werden, habe ich einige deutsche Funktionen
geschrieben, die alle Texte auf deutsch ausgeben und alle Umlaute
unterstützen.
Wenn Sie alle deutschen Funktionen verwenden wollen, müssen Sie die Zeile
"#define STORMAMIGA_DEUTSCH", vor dem Aufruf der Includedatei
"stormamiga.h", in Ihr Programm einbinden. Sie können "#define
STORMAMIGA_DEUTSCH" aber auch bei den Compileroptionen (Preprozessor)
des Menüs Einstellungen eintragen.
Wenn Sie nur einige deutsche Funktionen verwenden wollen, müssen Sie an
die Namen der entsprechenden Funktionen "_d" anhängen (aus "ctime" wird
also "ctime_d").

@{U}@{B}Alle verfügbaren Funktionen:@{UU}@{UB}

@{B}string Funktionen@{UB}
stricmp_d()     strnicmp_d()    strcasecmp_d()  strncasecmp_d()
strlwr_d()      strupr_d()      strlower_d()    strupper_d()

@{B}ctype Funktionen@{UB}
isalnum_d()     isalpha_d()     islower_d()     isprint_d()
ispunct_d()     isupper_d()     tolower_d()     toupper_d()

@{B}time Funktionen@{UB}
strftime_d()    asctime_d()     ctime_d()

@endnode

@node Amiga-Funktionen

@{B}@{FG SHINE}Die Amiga - Funktionen:
~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Bei den Amiga - Funktionen handelt es sich um Funktionen, die bereits
im AmigaOS enthalten sind. Da die AmigaOS - Funktionen aber oft sehr
groß und langsam sind, habe ich mich entschlossen einige dieser
Funktionen in die "stormamiga.lib" zu integrieren.
Die Amiga - Funktionen sind als @{" Inlinefunktionen " link "Inlinefunktionen"} und als
@{" Registerfunktionen " link "Registerfunktionen"} verfügbar.

@endnode

@node Alpha-Funktionen

@{B}@{FG SHINE}Die Alpha - Funktionen:
~~~~~~~~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

Bei den Alpha - Funktionen handelt es sich um Funktionen, die noch
nicht fertiggestellt sind, oder noch einige Fehler aufweisen.
Wenn Sie alle Alpha - Funktionen verwenden wollen, müssen Sie die
Zeile "#define STORMAMIGA_ALPHA", vor dem Aufruf der Includedatei
"stormamiga.h", in Ihr Programm einbinden. Sie können "#define
STORMAMIGA_ALPHA" aber auch bei den Compileroptionen (Preprozessor)
des Menüs Einstellungen eintragen.
Die Alpha - Funktionen sind als @{" Inlinefunktionen " link "Inlinefunktionen"} und als
@{" Registerfunktionen " link "Registerfunktionen"} verfügbar.

@endnode

@node Beispiele

@{B}@{FG SHINE}Beispiele:
~~~~~~~~~~@{FG TEXT}@{UB}

Um die Vorteile und Anwendungsmöglichkeiten der "stormamiga.lib"
etwas zu verdeutlichen, habe ich die Programme "Hello World", "Pi",
"Dhrystone", "SpeedTest" und "TaskDemo" als Beispiele beigelegt.

Die Beispiele mit dem Namen "...-storm" werden mit der "storm.lib"
und dem Startupcode "startup.o" gelinkt.

Die Beispiele mit dem Namen "...-stormamiga" werden mit der
"stormamiga.lib" und dem Startupcode "stormamiga_startups.o" gelinkt.

Die Beispiele mit dem Namen "...-stormamiga-2" werden mit der
"stormamiga.lib" und dem Startupcode "stormamiga_startups.o" gelinkt.
Außerdem wurde der Quelltext für die "stormamiga.lib" optimiert.


@{B}Hinweise zum Programm "SpeedTest":@{UB}

Bei "SpeedTest" handelt es sich um ein einfaches Testprogramm, daß die
Geschwindigkeit und Genauigkeit der mathematischen Funktionen und der
Ausgaberoutinen testet.
Die Anzahl der Testdurchläufe sollte für einen MC68060 etwa 1000000,
für einen MC68040+ etwa 500000 bis 1000000, für einen MC68881+ etwa
100000 bis 500000 und ohne Koprozessor etwa 10000 bis 50000 betragen.

Auf einem A1200 mit OS 3.0 gibt die Funktion "sqrt" der "mathieeedoubbas.
library" merkwürdigerweise eine unendliche Zahl (inf) anstatt einer
ungültigen Zahl (NaN) aus.

@endnode

@node "Bekannte Fehler"

@{B}@{FG SHINE}Bekannte Fehler:
~~~~~~~~~~~~~~~~@{FG TEXT}@{UB}

- In C++ wird bei allen Funktionen, die zur Ausgabe die Funktion "double_out"
  benutzen, falsch gerundet.
  Da diese Fehler bereits seit dem 20.05.1996 vorhanden sein müssen (Die
  Funktionen wurden seit dem 20.05.1996 nicht wesentlich geändert.), und
  sich niemand dazu gemeldet hat, ist die Korrektur dieser Fehler sicher
  nicht so wichtig.

@endnode

@node Updates

@{B}@{FG SHINE}Updates:
~~~~~~~~@{FG TEXT}@{UB}

Sie können die neuste Version natürlich immer direkt von @{" mir " link "Autor"} bekommen.
Wenn ich Ihnen die neuste Version per Post zuschicken soll, dann müssen
Sie mir einen frankierten Briefumschlag und eine Diskette (HD oder DD)
zuschicken.

Wenn Sie Zugang zum Internet haben, dann können Sie die Updates auf der
HomePage "http://home.pages.de/~haage" der Haage & Partner Computer GmbH
bekommen.
Wer ein CD-Laufwerk besitzt, kann die Updates auf den CDs der "AMIGA plus"
finden.

@endnode

@node Kopierrecht

@{B}@{FG SHINE}Kopierrecht:
~~~~~~~~~~~~@{FG TEXT}@{UB}

Die "stormamiga.lib" ist FREEWARE. Sie darf frei kopiert werden, solange
sie in KEINSTER Weise verändert wird und solange ALLE dazugehörigen
Dateien UNVERÄNDERT mitkopiert werden.

Die "stormamiga.lib" darf auch im Zusammenhang mit anderen Programmen
verwendet und vertrieben werden, solange KLARGESTELLT ist, daß es sich um
FREEWARE handelt UND solange ALLE Dateien UNVERÄNDERT mitkopiert werden.
Mit der Weitergabe der "stormamiga.lib" darf kein Gewinn erzielt werden.
Der Verkaufspreis einer Diskette, die die "stormamiga.lib" enthält, darf
nicht mehr als 5,- DM betragen. Ausgenommen davon sind Disketten, die es
zu Zeitschriften gibt.

Eine Reassemblierung der "stormamiga.lib" ist selbstverständlich NICHT
gestattet.


@{B}@{I}@{U}AM WICHTIGSTEN:@{UB}@{UI}@{UU}

Die Benutzung der "stormamiga.lib" erfolgt AUSSCHLIEßLICH auf eigenes Risiko.

Der Autor kann auf KEINEN FALL für einen Schaden oder Datenverlust der direkt
oder indirekt mit dem Gebrauch der "stormamiga.lib" entstehen sollte verant-
wortlich gemacht werden.

Alle Rechte vorbehalten. Für Fehlermitteilungen oder Verbesserungsvorschläge
bin ich jederzeit dankbar.

@endnode

@node Geschichte

@{B}@{FG SHINE}Geschichte:
~~~~~~~~~~~@{FG TEXT}@{UB}

@{" V41.000 alpha - V41.031 beta " link "V41.000-V41.031"}  18.03.1996 - 15.06.1996

@{" V41.032 beta  - V41.035      " link "V41.032-V41.035"}  16.06.1996 - 17.08.1996

@{" V42.00        - V42.05       " link "V42.00-V42.05"}  14.06.1996 - 27.12.1996


@{B}stormamiga.lib V42.10 (13.12.1996 - 20.03.1997):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die new-Funktion "set_new_handler" geschrieben
- die ctype-Funktionen "isprint_d" und "ispunct_d" geschrieben
- die ctype-Funktionen "iscntrl", "isprint" und "ispunct" neu geschrieben;
  Diese Funktionen sind jetzt schneller und wesentlich kürzer.
- die stdlib-Funktionen "atof" und "strtod" neu geschrieben; Diese
  Funktionen sind jetzt kürzer, schneller und kompatibeler zu StormC.
- die stdlib-Funktionen "strtol", "strtoul", "strtoll", "strtoull",
  "system", "uinttostr", "ullongtostr", "malloc" und "free" optimiert;
  Diese Funktionen sind jetzt schneller und wesentlich kürzer.
- die string-Funktionen "stricmp", "strnicmp", "strcasecmp", "strncasecmp",
  "stricmp_d", "strnicmp_d", "strcasecmp_d", "strncasecmp_d", "strcmp",
  "strncmp", "memcmp", "memccpy", "memmove", "strpbrk", "strcspn", "strsep",
  "strspn" und "strstr" optimiert; Diese Funktionen sind jetzt kürzer und
  schneller.
- die stdio-Funktionen "vsprintf_" und "vsprintf" neu geschrieben; Die
  Fehler, die bei den Typen "o", "e", "E", "f", "g" und "G" auftraten,
  sind damit beseitigt. Außerdem wird jetzt die Größe "L", die für long
  long int oder unsigned long long int steht, unterstützt.
- die stdio-Funktionen "scanf", "scanf_", "vscanf", "vscanf_", "getchar"
  und "gets" an die Version 2 der "storm.lib" angepaßt und optimiert; Es
  ist nicht mehr notwendig, vor einer Eingabe mit "scanf", "gets" usw.
  den Befehl "fflush (stdout)" auszuführen.
- die stdio-Funktionen "freopen", "perror", "remove", "rename", "puts",
  "fputs", "fgets", "vfprintf" und "vfprintf_" optimiert; Diese Funktionen
  sind jetzt kürzer und schneller.
- die time-Funktionen "clock" und "difftime" optimiert; Diese Funktionen
  sind jetzt kürzer und schneller.
- die math-Funktionen "ceil", "floor", "fabs", "sqrt", "fmod", "exp",
  "log", "log10", "pow", "acos", "cos", "cosh", "asin", "sin", "sinh",
  "atan", "tan" und "tanh" optimiert; Diese Funktionen sind jetzt kürzer
  und schneller.
- die signal-Funktionen "raise" und "signal" optimiert; Diese Funktionen
  sind jetzt schneller.
- die amiga.lib-Funktionen "CreateStdIO", "CreateExtIO", "DeleteStdIO",
  "DeleteExtIO", "CreatePort" und "DeletePort" neu geschrieben; Es werden
  jetzt die Funktionen von OS 2.x benutzt, wodurch diese Funktionen wesentlich
  kürzer sind.
- die amiga.lib-Funktionen "LibAllocPooled", "LibCreatePool", "LibDeletePool",
  "LibFreePooled" und "TimeDelay" optimiert; Diese Funktionen sind jetzt kürzer
  und schneller.
- die internen Funktionen "lib_64bit_shl" und "lib_64bit_shr" der "storm.lib"
  integriert
- die interne Funktion "udiv_64" geschrieben
- die internen Funktionen "main__" und "main__iPc" neu geschrieben; Bei den
  alten main-Funktionen gab es öfters "Speicherleichen".
- die internen Funktionen "UDiv64", "EXIT_5_InitFiles", "EXIT_5_InitStdIOFiles",
  "INIT_O_InitUserbreak", "userbreak", "EXIT_4_free", "intern__form_in",
  "intern__form_in_", "int_in", "double_in" und "amigareadunget" optimiert;
  Diese Funktionen sind jetzt kürzer und schneller.
- die Inline-Funktionen "memcpy", "memmove", "memset", "memchr", "memcmp",
  "CreateExtIO", "DeleteStdIO" und "DeleteExtIO" geschrieben
- Fehlerkorrektur der stdio-Funktionen "vfprintf", "vfprintf_" (Die Größe
  "L", die für long long int oder unsigned long long int steht, wurde nicht
  unterstützt. Bei Type p wurde immer "0x" vor der Adresse ausgegeben. Wenn
  nach den Typen "e", "E", "f", "g" und "G" noch ein anderer Type verwendet
  wurde, dann kam es zu fehlerhaften Ausgaben.), "fclose" (Die Anwendung
  dieser Funktion führte zum Systemabsturz und nicht zum Schließen einer
  Datei.) und "fflush"
- Fehlerkorrektur der internen Funktionen "amigaseek", "amigaread", "amigaopen"
  (wird z.B.: von "fopen" verwendet) und "amigaclose" (wird z.B.: von "fclose"
  verwendet); Die Anwendung von "amigaopen" und  "amigaclose" führte zum
  Systemabsturz und nicht zum Öffnen oder Schließen einer Datei.
- Fehlerkorrektur der stdlib-Funktion "srand"; Die Anwendung dieser Funktion
  hatte keinerlei Wirkung.
- Fehlerkorrektur der ctype-Funktionen "isspace" (Es wurde kein Leerzeichen
  unterstützt.), "islower" ("z" wurde nicht als Kleinbuchstabe erkannt.) und
  "isupper" ("Z" wurde nicht als Großbuchstabe erkannt.)
- Fehlerkorrektur des Beispielprogrammes "SpeedTest"; Die Anzahl der Testdurch-
  läufe mußte mindestens 2 sein, sonst wurde nichts berechnet.
- Beispielprogramme an die aktuellen Versionen der "storm.lib" und der
  "stormamiga.lib" angepaßt und einige Schönheitsfehler beseitigt
- Includedateien "stormamiga.h" und "stormamigainline.h" überarbeitet und
  erweitert
- Installerskript überarbeitet und von Thomas Blätte ins Englische übersetzt
- Anleitung überarbeitet und erweitert; Beschreibung der neuen Funktionen
  hinzugefügt und Funktionsübersicht erweitert.


@{B}stormamiga_881.lib V42.10 (13.12.1996 - 20.03.1997):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die stdlib-Funktionen "atof" und "strtod" neu geschrieben (Diese
  Funktionen sind jetzt kürzer, schneller und kompatibeler zu StormC.)


@{B}stormamiga_040.lib V42.10 (13.12.1996 - 20.03.1997):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die stdlib-Funktionen "atof" und "strtod" neu geschrieben (Diese
  Funktionen sind jetzt kürzer, schneller und kompatibeler zu StormC.)


@{B}stormamiga_060.lib V42.10 (13.12.1996 - 20.03.1997):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die stdlib-Funktionen "atof" und "strtod" neu geschrieben (Diese
  Funktionen sind jetzt kürzer, schneller und kompatibeler zu StormC.)


@endnode


@node V41.000-V41.031 "Geschichte"

@{B}V41.000 alpha - V41.002 alpha (18.03. - 21.03.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
  interne Entwicklungsphase

- Funktionen der "amiga.lib" für MC68000 oder höher geschrieben


@{B}V41.003 alpha - V41.021 alpha (22.03. - 16.05.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
  interne Entwicklungsphase

- Funktionen der "amiga.lib" für MC68EC020 oder höher umgeschrieben (ab
  V41.003 alpha wird ein MC68EC020 oder höher benötigt)
- Ein- und Ausgaberoutinen geschrieben (GCC-kompatibel)
- Funktionen zum automatischen Öffnen und Schließen der Libraries ge-
  schrieben
- die meisten ctype-Funktionen geschrieben
- einige stdio-, string- und stdlib-Funktionen geschrieben
- Startupcode für die "stormamiga.lib" optimiert
- einige andere Funktionen geschrieben
- einige Optimierungen und Fehlerkorrekturen
- Includedatei "stormamiga.h" geschrieben


@{B}V41.022 alpha - V41.029 alpha (20.05. - 11.06.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
  interne Entwicklungsphase

- Ein- und Ausgaberoutinen komplett neu geschrieben (StormC-kompatibel)
- einige stdio-Funktionen geschrieben
- 64Bit Befehle der "storm.lib" für MC68EC020+ optimiert
- einige andere Funktionen geschrieben
- einige Optimierungen und Fehlerkorrekturen
- Includedatei "stormamiga.h" erweitert
- Anleitung geschrieben


@{B}Hinweis:@{UB}

Durch ein Versehen wurde die Version 41.028 alpha, einige uralte Beispiel-
programme und Teile der Anleitung, mit der Version 1.1 von StormC, veröffent-
licht. Diese Version hat aber noch einige größere Fehler und funktioniert
nicht mit den alten Beispielprogrammen.
Die erste, zur Veröffentlichung gedachte Version, ist die Version 41.032 beta.


@{B}V41.030 beta - V41.031 beta (13.06. - 15.06.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
  interne Entwicklungs- und Testphase

- Optimierung der Ein- und Ausgaberoutinen
- Fehlerkorrekturen
- Anleitung überarbeitet

@endnode

@node V41.032-V41.035 "Geschichte"

@{B}V41.032 beta (16.06.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
  Erste öffentliche Version


@{B}V41.033 beta (17.06. - 15.07.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- umfangreiches Betatesting
- Fehlerkorrektur der string-Funktion "memcpy" (Die Benutzung von "memcpy"
  führte zu einem Fehler oder zum Systemabsturz. Die Ursache war ein Tipp-
  fehler. Ich hatte "a2" statt "a1" geschrieben.)
- die mathematischen Funktionen "acos", "asin", "atan", "ceil", "cos",
  "cosh", "exp", "fabs", "floor", "log", "log10", "pow", "sin", "sinh",
  "sqrt", "tan" und "tanh" geschrieben
- die string-Funktionen "memccpy", "strcoll", "strlwr", "strsep", "strupr",
  "strxfrm" und "swab" geschrieben
- die stdlib-Funktionen "abs", "labs", "atoi" und "atol" geschrieben
- die stdlib-Funktion "rand" optimiert
- die string-Funktionen "memchr", "memmove", "memset", "strcspn", "strpbrk",
  "strspn" und "strtok" optimiert
- Includedatei "stormamiga.h" überarbeitet und erweitert


@{B}V41.034 (16.07. - 31.07.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- Fehlerkorrektur der internen Funktion "amigawrite" (Der auszugebende Text
  wurde erst nach einigen Sekunden angezeigt. Bei dem Programm "GadTools"
  wurde der Text erst ausgegeben, wenn 5 Schalter gedrückt wurden.)
- die string-Funktionen "strerror" und "stricmp" geschrieben
- die string-Funktionen "memcmp", "strcat", "strcmp", "strcpy", "strncat",
  "strncmp", "strncpy" und "strstr" optimiert
- die stdlib-Funktionen "malloc" und "free" optimiert
- die stdio-Funktionen "vfprintf", "vfprintf_", "vfprintf__", "vfscanf",
  "vfscanf_", "vfscanf__", "fflush" und "setvbuf" optimiert
- die internen Funktionen "amigaread", "amigareadunget", "amigawrite", "amiga-
  eof", "amigaseek", "amigagetc", "amigagetcunget", "amigaungetc", "amigaputc",
  "amigaflush", "amigaclose", "SMult64", "UMult64", "SDiv64", "INIT_0_InitFiles",
  "EXIT_5_InitFiles", "INIT_5_InitStdIOFiles", "EXIT_5_InitStdIOFiles" und
  "EXIT_4_free" optimiert
- "aufräumen" der "stormamiga.lib" (dadurch wird das Linken beschleunigt,
  die Programme etwas schneller und die Map-Datei übersichtlicher)
- Anleitung überarbeitet


@{B}V41.035 (02.08. - 17.08.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die string-Funktionen "strcmp", "strcoll" und "strxfrm" neu geschrieben
- die stdlib-Funktionen "llabs",  "atoll", "strtol", "strtoll", "strtoul",
  "strtoull", "inttostr", "llongtostr", "uinttostr" und "ullongtostr"
  geschrieben
- die stdio-Funktion "puts" geschrieben
- die Spezial-Funktionen "muls64" und "mulu64" geschrieben
- Includedatei "stormamiga.h" erweitert
- Benutzer-Lexikon mit allen Sonder-Funktionen der "stormamiga.lib" geschrieben
- Installerskript geschrieben
- Anleitung überarbeitet (Beschreibung der Funktionen neu geschrieben, Index
  hinzugefügt und an AmigaOS 3.0 angepaßt); Anleitung als ASCII-Text beigelegt

@endnode

@node V42.00-V42.05

@{B}stormamiga.lib V42.00 (14.06. - 27.10.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die ctype-Funktionen "which_xdigit" "isalnum_d", "isalpha_d",
  "islower_d", "isupper_d", "tolower_d" und "toupper_d"  geschrieben
- die ctype-Funktionen "isalnum", "isalpha", "iscntrl", "isdigit",
  "isgraph", "islower", "isprint", "ispunct", isspace", "isupper",
  "isxdigit", "tolower" und "toupper" neu geschrieben
- die string-Funktionen "strnicmp", "strcasecmp", "strncasecmp",
  "stricmp_d", "strnicmp_d", "strcasecmp_d", "strncasecmp_d",
  "strlower", "strupper", "strlower_d", "strupper_d", "strlwr_d",
  "strupr_d" und "strdup" geschrieben
- die string-Funktionen "strcoll", "strxfrm", "memcpy", "strcpy",
  "strcmp", "strncmp" und "stricmp" neu geschrieben
- die stdlib-Funktionen "abort", "atexit", "getenv", "system", "atof"
  und "strtod" geschrieben
- die stdlib-Funktionen "bsearch" und "qsort" der "storm.lib" für den
  MC68EC020+ optimiert
- die stdio-Funktionen "setbuf", "setbuffer", "setlinebuf", "perror",
  "remove", "rename", "fopen", "freopen", "fclose", "tmpnam" und
  "tmpfile" geschrieben
- die stdio-Funktionen "vfprintf" und "vfprintf_" (mit den Routinen
  zur formatierten Ausgabe) neu geschrieben
- die stdio-Funktionen "setvbuf", "vprintf", "vprintf_", "vscanf",
  "vscanf_", "vsscanf" und  "vsscanf_" optimiert
- die time-Funktionen "ctime", "asctime", "localtime", "gmtime",
  "strftime", "ctime_d", "asctime_d", "strftime_d", "difftime" und
  "mktime" geschrieben
- die time-Funktionen "clock" und "time" neu geschrieben
- die signal-Funktionen "raise" und "signal" geschrieben
- die setjmp-Funktionen "longjmp" und "setjmp" der "storm.lib"
  integriert
- die math-Funktionen "atan2", "fmod", "frexp", "ldexp" und "modf"
  geschrieben
- die amiga.lib-Funktionen "ArgArrayInit", "ArgArrayDone", "ArgInt" und
  "ArgString" geschrieben
- die Spezial-Funktionen "divs64", "divu64", "button", "button_al",
  "button_ar", "button_bl", "button_br", "waitbutton", "waitbutton_al",
  "waitbutton_ar", "waitbutton_bl", "waitbutton_br", "muls_r", "mulu_r",
  "divsl_r", "divul_r", "muls64_r", "mulu64_r", "divs64_r", "divu64_r",
  "button_r" und "waitbutton_r" geschrieben
- die internen Funktionen "INIT_0_NEAR_CODE_StdioFiles", "intern__time_",
  "userbreak", "intern__signal_", "__ctypetable", "do_assert" und
  "do_assert_" geschrieben
- die internen Funktionen "intern__ctype_", "intern__form_in" und
  "intern__form_in_" neu geschrieben
- die internen Funktionen "UMult64", "INIT_5_InitStdIOFiles", "EXIT_5_Init-
  StdIOFiles", "amigaread", "amigawrite", "amigaputc", "amigaflush",
  "amigaclose", "amigaseek", "char_in", "string_in", "int_in" und "double_in"
  optimiert
- die interne Funktion "floattostr" der "storm.lib" für den MC68EC020+
  optimiert
- die internen Funktionen "blocksize_a2_d2", "lib_destruct", "lib_throw",
  "lib_destruct_a0", "lib_rethrow", "lib_catch", "set_unexpected__PFvp",
  "terminate_", "set_terminate__PFvp", "unexpected_", "lib_catchclass",
  "LibInit", "LibOpen", "LibClose", "LibExpunge", "LibNull", "fpwr10" und
  alle internen mathe-Funktionen der "storm.lib" integriert
- Funktionen zum automatischen Öffnen und Schließen der "realtime.library",
  "reqtools.library" und "muimaster.library" geschrieben
- Fehlerkorrektur der stdlib-Funktion "free"
- Unterstützung des kleinen Datenmodelles a4 und des kleinen Codemodelles
  integriert
- Startupcodes für Ansi-C und C++ (für das kleine und große Codemodell
  geschrieben
- Inline-Funktionen geschrieben
- Includedatei "stormamiga.h" erweitert
- Benutzer-Lexikon erweitert
- Installerskript überarbeitet und erweitert
- Anleitung überarbeitet und erweitert (Beschreibung der neuen Funktionen
  hinzugefügt)


@{B}stormamiga.lib V42.01 (29.10. - 01.11.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- Fehlerkorrektur der stdlib-Funktionen "malloc" und "free" (Im großen Daten-
  modell fehlte die Kennung "FAR". Dadurch wurden diese Funktionen auch
  für das kleine Datenmodell verwendet, was zu Fehlern führte.)
- Fehlerkorrektur der stdio-Funktionen "vfprintf" und "vfprintf_" (Fehler bei
  type p)
- Fehlerkorrektur der internen Funktion "amigawrite"


@{B}stormamiga.lib V42.02 (02.11. - 04.11.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die math-Funktionen "frexp" und "modf" optimiert
- die interne Funktion "dsscanf" optimiert


@{B}stormamiga.lib V42.03 (05.11. - 17.11.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die math-Funktionen "isinf" und "isnan" geschrieben
- die math-Funktionenen "frexp", "ldexp", "modf" "fmod", "floor" und "ceil"
  neu geschrieben (Die Funktionen "modf", "fmod", "ceil" und "floor" sind jetzt
  etwa 4 mal so schnell wie die Funktionen der "math020.lib". Die Funktion "ldexp"
  ist etwa 14 mal so schnell.)
- die math-Funktion "atan2" optimiert
- Fehlerkorrektur der stdio-Funktionen "fgets" (Im kleinen Datenmodell wurden keine
  Eingaben angenommen.) und "vfprintf_" (Der Linker konnte diese Funktion nicht
  finden, weil der "_" fehlte.)
- Includedateien "stormamiga.h" und "stormamigainline.h" überarbeitet und
  erweitert
- Benutzer-Lexikon erweitert
- Installerskript überarbeitet und erweitert
- Anleitung überarbeitet und erweitert


@{B}stormamiga_881.lib V42.00 (02.11. - 17.11.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die time-Funktion "difftime" geschrieben
- die stdlib-Funktionen "atof" und "strtod" geschrieben
- die stdio-Funktion "dsscanf" geschrieben
- die math-Funktionen "ceil", "floor", "fabs", "sqrt", "frexp", "ldexp",
  "modf", "fmod", "exp", "log", "log10", "pow", "acos", "cos", "cosh",
  "asin", "sin", "sinh", "atan", "tan", "tanh" und "atan2" geschrieben (Die
  Funktionen "modf", "fmod", "ceil", "floor" und "ldexp" sind wesentlich
  schneller als die Funktionen der "math881.lib". Die genaue Geschwindigkeit
  dieser Funktionen kann ich leider nicht testen, da ich keinen MC68881 oder
  MC68882 besitze.)


@{B}stormamiga_040.lib V42.00 (17.07. - 17.11.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die time-Funktion "difftime" geschrieben
- die stdlib-Funktionen "atof" und "strtod" geschrieben
- die stdio-Funktion "dsscanf" geschrieben
- die math-Funktionen "ceil", "floor", "fabs", "sqrt", "frexp", "ldexp",
  "modf", "fmod", "atan2" und "cos" geschrieben (Die Funktion "modf" ist etwa
  14 mal so schnell, "ceil" und "floor" sind etwa 17 mal so schnell und "ldexp"
  ist etwa 22 mal so schnell wie die Funktionen der "math040.lib".
  Da die  Funktion "fmod" der "math040.lib" fehlerhaft arbeitet, ist kein
  Geschwindigkeitsvergleich möglich.)


@{B}Hinweis:@{UB}

Eigentlich sollten die "stormamiga.lib", die "stormamiga_881.lib" und die
"stormamiga_040.lib" zur COMPUTER 96 alle Funktionen von "ANSI C" und "C++"
enthalten. Das ich dieses Ziel nicht ereicht habe ist hauptsächlich der
Firma "eagle computer products" zu verdanken. Diese Firma hat durch die
mangelhafte Qualität Ihrer Produkte und durch Ihren extrem schlechten
Kundenservice (eigentlich kann man gar nicht von Service sprechen) die
Weiterentwicklung der "stormamiga.lib" erfolgreich gebremst (es ist recht
schwierig an einem Computer zu arbeiten, dessen Netzteil und Shuttle Board
monatelang zum UMTAUSCH bei dieser Firma liegen).


@{B}stormamiga.lib V42.04 (18.11. - 12.12.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die time-Funktion "gmtime", "strftime" und "strftime_d" optimiert
- die stdlib-Funktionen "malloc" und "free" optimiert
- die math-Funktionen "fmod", "modf", "ceil" und "floor" optimiert
- die amiga.lib-Funktion "CreateExtIO" optimiert
- die internen Funktionen "string_in", "char_in", "double_in",
  "intern__form_in", "intern__form_in_", "amigaread", "amigawrite",
  "EXIT_4_free", "expo10" und "pwr10" optimiert
- die Spezial-Funktionen "max_Width", "max_Height", "max_Width_r" und
  "max_Height" geschrieben
- die Amiga-Funktionen "Move", "Move_r", "GetAPen", "GetAPen_r", "GetBPen"
  und "GetBPen_r" geschrieben
- die Alpha-Funktionen "SetAPen", "SetAPen_r", "SetBPen" und "SetBPen_r"
  geschrieben
- Fehlerkorrektur der amiga.lib-Funktionen "DeletePort", "DeleteTask" und
  "NewList" (Die Benutzung dieser Funktionen führte oft zum Systemabsturz.)
- Fehlerkorrektur der internen Funktionen "intern__form_in" und
  "intern__form_in_" (Fehler bei type c)
- Fehlerkorrektur des Beispielprogrammes "SpeedTest" (Die Gesamtzeit wurde
  falsch ausgegeben.)
- Includedateien "stormamiga.h" und "stormamigainline.h" überarbeitet und
  erweitert
- Benutzer-Lexikon erweitert
- Installerskript überarbeitet und erweitert
- Anleitung überarbeitet und erweitert (Funktionsübersicht und Beschreibung
  der neuen Funktionen hinzugefügt)


@{B}stormamiga_881.lib V42.01 (29.11. - 12.12.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die math-Funktionen "ceil" und "floor" neu geschrieben (Diese Funktionen
  sind langsamer als die der "math881.lib" gewesen.)
- die math-Funktionen "modf" und "fmod" optimiert


@{B}stormamiga_040.lib V42.01 (29.11. - 12.12.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die math-Funktionen "modf" und "fmod" optimiert


@{B}stormamiga_060.lib V42.00 (02.12. - 12.12.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- die time-Funktion "difftime" geschrieben
- die stdlib-Funktionen "atof" und "strtod" geschrieben
- die stdio-Funktion "dsscanf" geschrieben
- die math-Funktionen "ceil", "floor", "fabs", "sqrt", "frexp", "ldexp",
  "modf", "fmod", "atan2" und "cos" geschrieben


@{B}stormamiga.lib V42.05 (Patch vom 27.12.1996):
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯@{UB}
- Fehlerkorrektur der stdlib-Funktionen "malloc" und "free" (Der Speicher
  wurde nicht richtig angefordert und nicht oder nur teilweise wieder
  freigegeben.)
- Fehlerkorrektur der internen Funktion "EXIT_4_free" (Der Speicher
  wurde nicht oder nur teilweise wieder freigegeben.)

@endnode

@node Zukunft "In Zukunft"

@{B}@{FG SHINE}In Zukunft:
~~~~~~~~~~~@{FG TEXT}@{UB}

Die folgenden Punkte habe ich mir für die nächsten Versionen der
"stormamiga.lib" vorgenommen.

- alle, noch fehlenden, Funktionen der "storm.lib" und der "amiga.lib"
  in die "stormamiga.lib", "stormamiga_881.lib", "stormamiga_040.lib"
  und "stormamiga_060.lib" integrieren
- einige Amiga Funktionen und neue Funktionen schreiben
- Ihre Vorschläge

@endnode

@node Danksagungen

@{B}@{FG SHINE}Danksagungen:
~~~~~~~~~~~~~@{FG TEXT}@{UB}

@{B}Als erstes möchte ich mich bei der Haage & Partner Computer GmbH
bedanken, weil sie mir ihre Entwicklerunterlagen und Quelltexte
kostenlos überlassen haben. Ohne diese Unterlagen währe ich wahr-
scheinlich an den Ein- und Ausgaberoutinen für die Befehle printf
und scanf verzweifelt.
Besonderen Dank an Jochen Becher, der auch an Sonntagen zu später
Stunde Zeit für meine Probleme hatte und an Jürgen Haage, der auch
so manche Stunde für meine Probleme geopfert hat.

Ohne die Unterstützung der Haage & Partner Computer GmbH würde
es die "stormamiga.lib", in dieser Form, nicht geben.@{UB}


Außerdem möchte ich mich bei folgenden Leuten bedanken:
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
- Uwe Schienbein, für Betatesting, Bugreports, neue Ideen, die
  Unterstützung bei der Entwicklung der Funktion "cos" für den
  MC68040+ und MC68060 und für das Beispielprogramm "TaskDemo"

- Thomas Blätte, für die englische Übersetzung des Installerskripts,
  die Piktogramme für den Installer, Betatesting, Bugreports und
  neue Ideen

- Carsten Bornholz, für Betatesting und Bugreports

- Jens Schildknecht, für Betatesting und Bugreports

- Joachim Schneider, für Betatesting

- Onur Pekdimir, für seine Unterstützung bei der Veröffentlichung
  der "stormamiga.lib"

- Dietmar Heidrich, für seinen "OMA"

- Frank Wille, für seinen "PhxAss"


@{B}@{FG SHINE}
Ganz besonders möchte ich mich bei der Firma "eagle computer products"
bedanken. Diese Firma hat durch die mangelhafte Qualität Ihrer Produkte
und durch Ihren extrem schlechten Kundenservice (eigentlich kann man gar
nicht von Service sprechen) die Weiterentwicklung der "stormamiga.lib"
erfolgreich gebremst (es ist recht schwierig an einem Computer zu arbeiten,
dessen Netzteil und Shuttle Board monatelang zum UMTAUSCH bei dieser Firma
liegen).@{FG TEXT}@{UB}
@endnode

@node Autor

@{B}@{FG SHINE}Autor:
~~~~~~@{FG TEXT}@{UB}

			   Matthias Henze
			  Gorkistraße  119
			   04347 Leipzig
			    Deutschland

			Telefon: 0341/2326414

	     EMail: COMPIUTECK_Matthias_Henze@T-Online.de


Für Fehlerberichte und Verbesserungsvorschläge bin ich jederzeit dankbar.
Es wäre auch sehr schön, wenn Sie mir Ihre Meinung zur "stormamiga.lib"
mitteilen würden.

@{B}@{U}An alle Anwender, die für ein "Dankeschön" arbeiten@{UB}@{UU}

Ich suche dringend einige Anwender, die diese Anleitung und den Installer-
script in andere Sprachen (Englisch, Italienisch, Französisch und andere)
übersetzen.
Außerdem suche ich noch einige Betatester.
Wenn Sie Interesse haben, können Sie mir schreiben oder mich anrufen.

Für Ihre Mühe danke ich im Voraus.

@endnode

@node guideIndex "Index"

@{B}@{FG SHINE}Index:
~~~~~~@{FG TEXT}@{UB}

@{B} A@{UB}

 @{" Allgemeine Hinweise    " link "Allgemeine Hinweise"}
 @{" Alpha - Funktionen     " link "Alpha-Funktionen"}
 @{" Amiga - Funktionen     " link "Amiga-Funktionen"}
 @{" Anwendungshinweise     " link "Anwendungshinweise"}
 @{" asctime_d              " link "asctime_d"}
 @{" assert_                " link "assert_"}
 @{" Ausgabeformatstring_   " link "Ausgabeformatstring_"}
 @{" Autor                  " link "Autor"}

@{B} B@{UB}

 @{" Besonderheiten         " link "Besonderheiten"}
 @{" bcmp                   " link "bcmp"}
 @{" bcopy                  " link "bcopy"}
 @{" Beispiele              " link "Beispiele"}
 @{" Bekannte Fehler        " link "Bekannte_Fehler"}
 @{" button                 " link "button"}
 @{" button_r               " link "button_r"}
 @{" button_al              " link "button_al"}
 @{" button_ar              " link "button_ar"}
 @{" button_bl              " link "button_bl"}
 @{" button_br              " link "button_br"}
 @{" bzero                  " link "bzero"}

@{B} C@{UB}

 @{" ctime_d                " link "ctime_d"}

@{B} D@{UB}

 @{" Danksagungen           " link "Danksagungen"}
 @{" Der Startupcode        " link "Startupcode"}
 @{" Deutsche Funktionen    " link "Deutsche Funktionen"}
 @{" divs64                 " link "divs64"}
 @{" divs64_r               " link "divs64_r"}
 @{" divsl                  " link "divsl"}
 @{" divsl_r                " link "divsl_r"}
 @{" divu64                 " link "divu64"}
 @{" divu64_r               " link "divu64_r"}
 @{" divul                  " link "divul"}
 @{" divul_r                " link "divul_r"}

@{B} E@{UB}

 @{" Eingabeformatstring    " link "Eingabeformatstring"}
 @{" Eingabeformatstring_   " link "Eingabeformatstring_"}
 @{" Einleitung             " link "Einleitung"}

@{B} F@{UB}

 @{" ffs                    " link "ffs"}
 @{" fprintf_               " link "fprintf_"}
 @{" fscanf_                " link "fscanf_"}
 @{" Funktionen             " link "Funktionen"}
 @{" Funktionsübersicht     " link "Funktionsübersicht"}

@{B} G@{UB}

 @{" Geschichte             " link "Geschichte"}

@{B} I@{UB}

 @{" In Zukunft             " link "Zukunft"}
 @{" index                  " link "index"}
 @{" Inlinefunktionen       " link "Inlinefunktionen"}
 @{" Installation           " link "Installation"}
 @{" isalnum_d              " link "isalnum_d"}
 @{" isalpha_d              " link "isalpha_d"}
 @{" isinf                  " link "isinf"}
 @{" islower_d              " link "islower_d"}
 @{" isnan                  " link "isnan"}
 @{" isprint_d              " link "isprint_d"}
 @{" ispunct_d              " link "ispunct_d"}
 @{" isupper_d              " link "isupper_d"}

@{B} K@{UB}

 @{" Kopierrecht            " link "Kopierrecht"}

@{B} M@{UB}

 @{" main__()               " link "main__()"}
 @{" max_Height             " link "max_Height"}
 @{" max_Height_r           " link "max_Height_r"}
 @{" max_Width              " link "max_Width"}
 @{" max_Width_r            " link "max_Width_r"}
 @{" memccpy                " link "memccpy"}
 @{" muls                   " link "muls"}
 @{" muls_r                 " link "muls_r"}
 @{" muls64                 " link "muls64"}
 @{" muls64_r               " link "muls64_r"}
 @{" mulu                   " link "mulu"}
 @{" mulu_r                 " link "mulu_r"}
 @{" mulu64                 " link "mulu64"}
 @{" mulu64_r               " link "mulu64_r"}

@{B} P@{UB}

 @{" Parameterliste         " link "Parameterliste"}
 @{" printf_                " link "printf_"}

@{B} R@{UB}

 @{" Registerfunktionen     " link "Registerfunktionen"}
 @{" Registrierung          " link "Registrierung"}
 @{" rindex                 " link "rindex"}

@{B} S@{UB}

 @{" scanf_                 " link "scanf_"}
 @{" setbuffer              " link "setbuffer"}
 @{" setlinebuf             " link "setlinebuf"}
 @{" SPRINTF                " link "SPRINTF"}
 @{" sprintf_               " link "sprintf_"}
 @{" sscanf_                " link "sscanf_"}
 @{" strcasecmp             " link "strcasecmp"}
 @{" strcasecmp_d           " link "strcasecmp_d"}
 @{" strcoll                " link "strcoll"}
 @{" strdup                 " link "strdup"}
 @{" strftime               " link "strftime"}
 @{" strftime_d             " link "strftime_d"}
 @{" stricmp_d              " link "stricmp_d"}
 @{" Stringpuffer           " link "Stringpuffer"}
 @{" strlower               " link "strlower"}
 @{" strlower_d             " link "strlower_d"}
 @{" strlwr_d               " link "strlwr_d"}
 @{" strncasecmp            " link "strncasecmp"}
 @{" strncasecmp_d          " link "strncasecmp_d"}
 @{" strnicmp               " link "strnicmp"}
 @{" strnicmp_d             " link "strnicmp_d"}
 @{" strsep                 " link "strsep"}
 @{" strupper               " link "strupper"}
 @{" strupper_d             " link "strupper_d"}
 @{" strupr_d               " link "strupr_d"}
 @{" strxfrm                " link "strxfrm"}
 @{" swab                   " link "swab"}
 @{" Systemanforderungen    " link "Systemanforderungen"}

@{B} T@{UB}

 @{" tolower_d              " link "tolower_d"}
 @{" toupper_d              " link "toupper_d"}

@{B} U@{UB}

 @{" Updates                " link "Updates"}

@{B} V@{UB}

 @{" vfprintf_              " link "vfprintf_"}
 @{" vfscanf                " link "vfscanf"}
 @{" vfscanf_               " link "vfscanf_"}
 @{" vprintf_               " link "vprintf_"}
 @{" vscanf                 " link "vscanf"}
 @{" vscanf_                " link "vscanf_"}
 @{" VSPRINTF               " link "VSPRINTF"}
 @{" vsprintf_              " link "vsprintf_"}
 @{" vsscanf                " link "vsscanf"}
 @{" vsscanf_               " link "vsscanf_"}

@{B} W@{UB}

 @{" waitbutton             " link "waitbutton"}
 @{" waitbutton_r           " link "waitbutton_r"}
 @{" waitbutton_al          " link "waitbutton_al"}
 @{" waitbutton_ar          " link "waitbutton_ar"}
 @{" waitbutton_bl          " link "waitbutton_bl"}
 @{" waitbutton_br          " link "waitbutton_br"}

@{B} Z@{UB}

 @{" Zeitformatstring       " link "Zeitformatstring"}

@endnode
