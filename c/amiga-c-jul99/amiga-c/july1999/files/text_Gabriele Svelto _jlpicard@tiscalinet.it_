Hello Christian

> From: Christian Hattemer <Chris@heaven.riednet.wh.tu-darmstadt.de>
> 
> Hi,
> 
> I want to build an array of structure pointers dynamically. The main
> problem is that the layout of the struct to be put in the array should
> also be described dynamically.
> 
> I want to use this for a function which reads some data from a file and
> then puts it into the array. The array is ment to be used mit
> MUIM_List_Insert.
> 
> I want to have to struct dynamic to be able to use the function to read
> several types of data (i. e. several different structs) without changing
> the code.
> 
> I thought of passing in another array like this, describing the structure
> to be built:
> 
> struct ReadConfig
> {
>   ULONG Type;
>   TEXT  Item[20];
>   TEXT  StrDef[100];
>   ULONG StrLen;
>   ULONG NumDef;
> };
> 
> struct ReadConfig[] =
> {
>   {TYPE_TEXT, "Data1", "Value1", 50, 0},
>   {TYPE_NUM , "Data2", ""      ,  0, 5}
> };
> 
> Type defines whether the element is a string or a number.
> Item is a string which identifies the data in the file
> StrDef is a default string which is copied into the structure if the data
> wasn't in the file
> StrLen is a lenght limit for the string in the struct
> NumDef is the numerical default, simmilar to StrDef
> 
> StrDef and StrLen are only used if it's TYPE_TEXT, NumDef only if it's
> TYPE_NUM.
> 
> In this example the created struct should look like this:
> 
> struct Data
> {
>   TEXT String[50];
>   ULONG Num;
> };

If I have understood your problem you need to create an array of Data
structures which can be different (for example TEXT String could be of
another size etc...). You could then create the Data structure only using
pointers like that:

sruct Data
{
    TEXT *String; (is TEXT a #define of char?)
    ULONG Num;
}

Then you could create an array of Data structures:

struct Data Data_ptr = (struct Data *) malloc(n * sizeof(struct Data));

where n is the number of Data structures and then you could use an array of
ReadConfig for allocating memory for each string, take a look at the
example prog below:

struct Data
{
  TEXT *String;
  ULONG Num;
}

/* ... your code ...  */

struct ReadConfig *config;
struct Data *dataptr;
long n; /* /*/* Number of elements in config and dataptr arrays */
long temp;

config = (struct ReadConfig *) malloc(n* ** sizeof(struct ReadConfig));

/* Initialize your ReadConfig array for your needs... */

dataptr = (struct Data *) malloc(sizeof(struct Data));

/* Now allocate memory for the different elements of the Data array */

for (temp = 0; temp < n; temp++)
{
    if ( (config + temp)->StrLen != 0 )
    {
        /* Allocate memory */
        (dataptr + temp)->String = malloc((config + temp)->StrLen);
        /* Copy the default string */
        (void) strcpy((dataptr + temp)->String, (config + temp)->StrDef));
    }
    (...)    
    /* Initialise the rest of the array like that */
}

etc...

> The big Question is now: How do I find out how much memory needs to be
> allocated to hold the array, and how do I find out the offsets to fill in
> the data?

That's not a problem, you don't need to calculate any offsets at all if
you're using pointers, the compiler will do the work for you: for example,
for printing the string contained in the fourth structure of the Data array
you could simply write:

puts((dataptr + 3)->String);

 Hope this could help you

 Gabriele