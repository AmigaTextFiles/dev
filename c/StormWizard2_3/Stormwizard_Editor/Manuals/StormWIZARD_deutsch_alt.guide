@database StormWIZARD.guide

@wordwrap

@Master manuals

@width 72

@index Main

This is the AmigaGuide® file StormWIZARD.guide

This file documents StormWIZARD, a GUI-EDITOR system for AmigaOS V2.04
or newer.


@node "Main" "StormW.guide"
@next "Main"
@prev "Main"
@title "Erste Seite"


@{b}StormWIZARD 2.3@{ub}

Software und Dokumentation                         
© 1996/1997 by HAAGE & PARTNER Computer GmbH

Dank an HAAGE & PARTNER Computer GmbH , dass Bernd Roesch die Erlaubniss bekommen hat, Storm Wizard kostenlos
zu releasen und weiterzuentwickeln.

Bitte daher keine Bug Reports an HAAGE & PARTNER Computer GmbH schicken, sondern an diese Mail
Adresse: nospamname@web.de oder im Amiforce Forum www.amiforce.de mailen.

 @{b}Inhaltsverzeichnis@{ub}

 @{" Lizenzbedingungen " link "ST_Lizenz"}

 @{" Kapitel  1 " link "ST_Welcome"}	Willkommen
 @{" Kapitel  2 " link "ST_Philo"}	Philosophisches
 @{" Kapitel  3 " link "ST_Maschine"}	Anforderungen
 @{" Kapitel  4 " link "ST_Install"}	Installation
 @{" Kapitel  5 " link "ST_Tutorial"}	Tutorial
 @{" Kapitel  6 " link "ST_Start"}	Programmstart und 1. Übung
 @{" Kapitel  7 " link "ST_Ubung2"}	2. Übung
 @{" Kapitel  8 " link "ST_Ubung3"}	Paging und Notify
 @{" Kapitel  9 " link "ST_Layout"}	Layouttechniken
 @{" Kapitel 10 " link "ST_Klassenspezial"}	Layoutverhalten
 @{" Kapitel 11 " link "ST_Notify"}	Die Notifyobjekte
 @{" Kapitel 12 " link "ST_Proging"}	Programmierung

 @{" Copyrights " link "ST_CRIGHT"}

 @{" Bestellformular " link "ST_ORDER"}

@endnode

@node "ST_Order" "StormWIZARD.guide/ST_Order"
@toc "Main"

All is free now,

@endnode

@node "ST_CRIGHT" "StormWIZARD.guide/ST_CRIGHT"
@next "ST_Lizenz"
@prev "ST_ORDER"
@toc "Main"


Copyrights und Warenzeichen:
Amiga ist ein eingetragene Warenzeichen von Amiga inc.
SAS und SAS/C sind eingetragene Warenzeichen des SAS-Instituts.
Amiga, AmigaDOS, Kickstart und Workbench sind Warenzeichen von Amiga Inc.
Die Nennung von Produkten, die nicht von der HAAGE & PARTNER Computer 
GmbH sind, dient ausschließlich Informationszwecken und stellt keinen 
Warenzeichenmißbrauch dar.

@endnode

@node "ST_Lizenz" "StormWIZARD.guide/ST_Lizenz"
@next "ST_ORDER"
@prev "ST_CRIGHT"
@toc "Main"

@{b}Lizenzvereinbarungen@{ub}

@{i}1 Allgemeines@{ui}
(1)	Gegenstand dieses Vertrages ist das Benutzungsrecht für Computer-
	programme der HAAGE & PARTNER Computer GmbH, für die Benutzungs-
	anleitung sowie für sonstiges zugehöriges, schriftliches Material, 
	nachfolgend zusammenfassend als Produkt bezeichnet.
(2)	Die HAAGE & PARTNER Computer GmbH und/oder die in dem Produkt 
	angegebenen Lizenzgeber sind Inhaber sämtlicher Rechte an den 
	Produkten und Warenzeichen.

@{i}2 Nutzungsrechte@{ui}
(1)	Der Anwender erhält ein nicht übertragbares, nicht ausschließliches
	Recht, das erworbene Produkt auf einem Computer bzw. an einem 
	Arbeitsplatz zu nutzen.
(2)	Darüber hinaus kann der Anwender eine einzige Kopie zu Sicherungs-
	zwecken anfertigen.
(3)	Der Anwender ist nicht berechtigt, das erworbene Produkt zu
	vertreiben, zu vermieten, Dritten Unterlizenzen anzubieten oder 
	diese in anderer Weise Dritten zur Verfügung zu stellen.
(4)	Es ist verboten, das Produkt zu ändern, zu modifizieren oder 
	anzupassen oder in jeglicher Form rückzuentschlüsseln. Dieses 
	Verbot gilt auch für das Übersetzen, Abwandeln, Rückentschlüsseln 
	und Weiterverwenden von Teilen.


@{i}4 Sonstiges@{ui}
(1)	In diesem Vertrag sind sämtliche Rechte und Pflichten der 
	Vertragsparteien geregelt. Sonstige Vereinbarungen bestehen nicht. 
	Änderungen sind nur in Schriftform und bei Bezugnahme auf diesen 
	Vertrag wirksam und beiderseitig zu unterzeichnen.
(2)	Der Gerichtsstand für alle Streitigkeiten aus diesem Vertrag 
	ist, soweit vereinbar, das zuständige Gericht am Firmensitz der 
	HAAGE & PARTNER Computer GmbH.
(3)	Sollten einzelne Bestimmungen dieser Bedingungen nicht rechts-
	wirksam sein oder ihre Rechtswirksamkeit durch einen späteren 
	Umstand verlieren, oder sollte sich in diesen Bedingungen eine 
	Lücke herausstellen, so wird hierdurch die Rechtswirksamkeit der 
	übrigen Bestimmungen nicht berührt. Anstelle der unwirksamen 
	Vertragsbestimmungen oder zur Ausfüllung der Lücke soll eine 
	angemessene Regelung gelten, die, soweit rechtlich möglich, 
	dem am nächsten kommt, was die Vertragsparteien gewollt haben, 
	soweit sie von der Unwirksamkeit der Bestimmung Kenntnis 
	gehabt hätten.
(4)	Jede Verletzung vorstehender Lizenzbestimmungen oder von 
	Urheber- und Warenzeichenrechten wird straf- und zivilrechtlich 
	verfolgt.
(5)	Durch Installation der Software werden diese Lizenz-
	vereinbarungen anerkannt.

@{i}3 Gewährleistung@{ui}
(1)	Die HAAGE & PARTNER Computer GmbH und Weiterentwickler übernimmt keine Haftung dafür,
	daß das Produkt für die vom Kunden vorgesehene Aufgabe geeignet
	ist. Für eventuell auftretende Folgeschäden übernimmt die
	HAAGE & PARTNER Computer GmbH und Weiterentwickler keine Haftung.
(2)	Der Anwender weiß, daß nach dem heutigen Stand der Technik die
	Erstellung völlig fehlerfreier Software nicht möglich ist.

Stand:  2009

@endnode

@node "ST_Welcome" "StormWIZARD.guide/ST_Welcome"
@toc "Main"

@{b}Willkommen zu einer neuen Ära der Amiga-Oberflächengenerierung.@{ub}

Mit der beiliegenden Version unseres brandneuen GUI-Editors 
lernen Sie die Fähigkeiten eines fortschrittlichen Oberflächeneditors 
und einer Boopsi-Bibliothek kennen.

Mittlerweile existieren unzählige Bibliotheken auf dem Amiga, die alle,
zumindest nach der Meinung ihrer Programmierer, die Superleistung
bieten, die zum Programmieren gebraucht wird.

Viele davon sind eine Sammlung mächtiger Funktionen mit überladenen 
Konfigurationsmöglichkeiten. Dinge, die den Anwender nur überfordern.

Alle haben jedoch, trotz meist hervoragender Qualität, ein gemeinsames 
Problem: Die Bibliotheken sind entweder Free-Ware, PD oder Share-Ware.
Für den Einsatz in kommerziell vermarkteter Software kommen daher die 
wenigsten in Frage. Nur unsicher kann die Frage nach der Weiterentwik-
klung beantwortet werden.

Eine weitere Frage stellt sich spätestens bei der Einführung des Power-PC
Amiga. Kann die Library problemlos umgesetzt werden? Ist Sie vielleicht
in Assembler oder einer exotischen Programmiersprache erzeugt, die es
bestimmt nicht in einer speziellen PPC-Version geben wird?

Wenn Sie nicht umgesetzt werden kann, bedeutet das für Sie, daß Sie durch
den Einsatz einer "unsicheren" Bibliothek die PPC-Weiterentwicklung Ihres 
Projektes auf's Spiel setzten.

Beim Einsatz von StormWizard haben Sie eine Gewißheit, daß die Bibliothek
auch als PPC-Nativ-Version verfügbar sein wird. Schließlich entwickeln
wir das Power-PC-Entwicklungssystem für den Amiga, das selbst auf die 
Wizard.Library angewiesen ist.

Desweiteren gibt es für die wenigsten Free-, Share-Ware oder PD-
Bibliotheken einen grafischen Editor, der es Ihnen erlaubt Ihre Ober-
flächen direkt am Bildschirm grafisch aufzubauen.


Mit StormC und StormWizard haben wir unser Entwicklungssystem weiter
komplettiert. StormWizard integriert sich, genau wie alle anderen 
Programmteile zu StormC, harmonisch in die Projektverwaltung.

Bereits in der Version 1.1 von StormC wurde dazu unsere Porjektverwaltung
und der Linker erweitert. Die Projektverwaltung bietet eine eigene
Sektion für ".wizard"-Dateien. Und der Linker ist in der Lage, die 
".wizard"-Ressourcen als Binärdateien an Ihre Programme anzubinden.

Eine Möglichkeit, die kein anderes Entwicklungssystem bietet!

Der Vorteil sind enorm kurze Turnaround-Zeiten und ein extremer 
Effizienzgewinn beim Programmieren.

@endnode

@node "ST_Philo" "StormWIZARD.guide/ST_Philo"
@toc "Main"

@{b}Philosophisches@{ub}

Einen sehr großen Teil der Zeit, bei der Programmierarbeit, wird für das 
Entwerfen und für die Pflege von Programmoberfläche benötigt.

Gerade die Pflege ist doch sehr schwierig und fehlerträchtig, da mit
komplexen Strukturen umgegangen werden muß und allzuleicht Fehler
gemacht werden, die nur schwer zu finden sind.

Beim Arbeiten mit StormWizard werden Sie daher nicht mit den Quellcodes
Ihrer Oberfläche konfrontiert. Statt dessen erzeugt StormWizard eine
Ressource-Datei, die alle Informationen enthält.

Der erste große Vorteil dieser Methode ist die damit gewonnene 
Unabhängigkeit von der Programmiersprache. Wenn Sie mit StormWizard
arbeiten sind Sie nicht gezwungen in ANSI/C, C++ oder Assembler zu
programmieren. Die von StormWizard erzeugte Ressource-Datei können 
Sie in jeder Programmiersprache verwenden. Ein großer Vorteil, der
ein Standard-Tool bieten muß.

Der zweite und unschätzbare Vorteil von StormWizard ist, daß Änderungen
an der Oberfläche nicht in Ihrem Programm sondern mit StormWizard an
Ihrer Ressource-Datei gemacht werden. Die Oberfläche ist also strikt
gekapselt und für Sie leicht zu verändern. Es muß kein Compiler- oder
Assemblerlauf gestartet werden um sich die Veränderungen anzusehen.
Mit StormWizard sehen Sie sofort alle Veränderungen die Sie vornehmen.

Konzentrieren Sie sich ganz auf die Programmierarbeit und überlassen die 
Oberfläche StormWIZARD!

@endnode

@node "ST_Maschine" "StormWIZARD.guide/ST_Maschine"
@toc "Main"

@{b}Anforderungen@{ub}

In der folgenden Liste finden Sie die Minimal-Konfiguration zum Betrieb 
von StormWIZARD:
@{b}@{i}
-	Amiga mit Festplattenlaufwerk
-	Kickstart/Workbench 3.0 (v39)
-	2 MB Hauptspeicher
-	2 MB Festplattenspeicher
@{ub}@{ui}
@endnode

@node "ST_Install" "StormWIZARD.guide/ST_Install"
@toc "Main"

@{b}Installation@{ub}

Zur Installation auf Ihre Festplatte wird der Commodore Installer 
eingesetzt. Dieses Installationstool hat sich mittlerweile als 
Standard-Installierer durchgesetzt und sollte Ihnen in der Bedienung 
bekannt sein.

Zum besseren Verständnis finden Sie hier die Übersetzung 
der wichtigsten Tasten:

@{b}Proceed@{ub}
  @{i}OK und weiter@{ui}
  Die abgefragte Aktion wird ausgeführt.

@{b}Abort Installation@{ub}
  @{i}Installation beenden@{ui}
  Die Installation wird nicht fortgeführt.

@{b}Parent Drawer@{ub}
  @{i}Mutterverzeichnis@{ui}
  Den Inhalt des nächst höheren Verzeichnisses anzeigen.

@{b}Show Drives@{ub}
  @{i}Laufwerke@{ui}
  Alle Laufwerke anzeigen.

@{b}Make New Drawer@{ub}
  @{i}Erzeuge neues Verzeichnis@{ui}
  Legt einen neuen Ordner im angegebenen Pfad an.

@{b}Help@{ub}
  Das sollten Sie auch ohne Übersetzung wissen!

@{b}Cancel@{ub}
  @{i}Aktion abbrechen@{ui}

Entpacken Sie das StormWIZARD-Archiv in eine Schublade auf Ihrer
Festplatte. Zum Entpacken wird der LHA-Entpacker benötigt.

Doppelklicken Sie jetzt auf das Ikon "Install StormWIZARD-HD".
Bitte haben Sie einen Augenblick Geduld, bis das Installations-
programm und das -Script geladen sind.

Bitte folgen Sie den Anweisungen des Installationsprogrammes. 
Sollten Sie einmal nicht weiter wissen, klicken Sie einfach auf 
den "Help"-Knopf und lesen Sie nach, was zu tun ist.

Das Skript kopiert die Datei Wizard.Library in die LIBS:-Schublade
und nimmt eine Eintragung in Ihrer User-Startup vor.

Nach erfolgreicher Installation erhalten Sie eine entsprechende 
Meldung vom Installationsprogramm. 

Sollte die Installation nicht positiv verlaufen sein, wiederholen 
Sie bitte den Vorgang mit eingeschalteter "Log-Datei"-Generierung. 
Die Option @{i}"Log all actions to: Log File"@{ui} kann in dem 
Optionen-Fenster eingestellt werden, das nach dem Begrüßungs-Fenster 
angezeigt wird. Nach der erfolglosen Installation können Sie dann im 
Installationsprotokoll nachlesen, was nicht funktioniert hat. 

Beheben Sie bitte das Problem und installieren Sie erneut.

Bei Fragen wenden Sie sich an:

HAAGE & PARTNER Computer GmbH
Mainzer Straße 10A

61191 Rosbach v.d.H.

Tel: 06007/930051
Fax: 06007/7543

Internet: haage_partner@compuserve.com
Web-page: http://ourworld.compuserve.com/homepages/haage_partner

@endnode

@node "ST_Tutorial" "StormWIZARD.guide/ST_Tutorial"
@toc "Main"

@{b}Tutorial@{ub}

Im Tutorialteil des Handbuchs erfahren Sie alles über den Umgang mit 
dem Programm. Anhand einiger Übungen wird Ihnen die Funktions-
weise des GUI-Editors beigebracht. Sie lernen den Umgang mit dem 
Fenster-Editor, wie man Gadgets positioniert und schließlich, wie man 
schnell und einfach Menüs erzeugt. 

Sie erhalten durch das Tutorial einen umfassenden Eindruck des 
Gestaltungssystems. 

@endnode

@node "ST_Start" "StormWIZARD.guide/ST_Start"
@toc "Main"

@{b}Programmstart@{ub}

Im den folgenden Übungen lernen Sie, wie Sie Fenster erstellen, Gadgets
hinzufügen, deren Dimension und Postition verändern

Starten Sie bitte StormWIZARD durch Doppelklick auf das Programm-Piktogramm. 

Nach dem Start wird der Fenster-Editor angezeigt, in dem alle Bestandteile 
Ihres Projektes (Fenster, Gadgets und Menüs) in einer Liste angezeigt
werden.

Zu Beginn ist die Liste leer, da Sie ja noch kein Fester angelegt haben.

@{b}Erste Übung@{ub}

Legen Sie ein neues Fenster mit Klick auf @{b}"Fenster hinzufügen"@{ub} an.
Geben Sie nun ein @{b}Objektnamen@{ub} für das Fenster ein bestätigen mit
@{b}OK@{ub}. Der erste Eintrag erscheint in der Liste des Fenster-Editors.

Klicken Sie nun mit der Maus auf das @{b}"+"@{ub}-Zeichen des ersten
Eintrags. Alternativ können Sie auch @{i}<Leertaste>@{ui} betätigen.
Unterhalb des Eintrags erscheinen nun zwei weitere Einträge, über
die man per Doppelklick zum Gadget- und zum Menü-Editor gelangt.

Mit den Cursortasten @{i}<Auf>@{ui} und @{i}<Ab>@{ui} können Sie ebenfalls die Einträge
selektieren und mit @{i}<Return>@{ui} in den jeweiligen Editor wechseln.

Ein Doppelklick auf Eintrag @{b}"Gadgets"@{ub} bringt uns zum Gadget-Editor.

Klicken Sie mit der linken Maustaste ( HALTEN SIE DIE MAUSTASTE GEDRÜCKT !)
auf das Gadget mit der Aufschrift @{b}"Objekt hinzufügen"@{ub}. Jetzt erscheint ein 
Popup-Menü aus dem Sie bitte den Eintrag @{b}"Date"@{ub} auswählen.

Daraufhin erscheint der Datum Attribut-Einsteller, dessen Einstell-
möglichkeiten wir zunächst ignorieren. Klicken Sie bitte auf @{b}"Ok"@{ub} oder
drücken Sie die Taste @{i}<O>@{ui}.

Im Gadget-Editor wählen Sie jetzt @{b}"Neu zeichnen"@{ub} und erhalten ihr
erstes Wizard-Fenster. Dies ist schon sehr beeindruckend, aber noch
lange nicht alles, was StormWizard kann.

Fügen Sie jetzt noch ein Objekt mit der Bezeichnung @{b}HGroup@{ub} aus dem
Popup-Menü @{b}"Objekt hinzufügen"@{ub} hinzu. Auch hier bestätigen wir
vorerst mit @{b}"Ok"@{ub}.

Ein erneuter Klick auf @{b}"Neu zeichnen"@{ub} läßt das 
Fenster kaum verändert erscheinen.

Wenn Sie jetzt jedoch die Fenstergöße verändern, stellen Sie fest,
daß das Datums-Gadget in der oberen Ecke "klebt".
Die Ursache liegt an dem Gruppen-Gadget, das mit einer höheren 
Prioritätseinstellung das Datums-Gadget verdrängt.

Die Verteilung der Dimensionen durch Gruppen-Gadgets ist sehr stark
an die Priorität gebunden. Unser unsichtbares Gruppen-Gadget ist
in diesem Fall das Root-Gadget, welches jedes Fenster vom Editor mit-
bekommt und automatisch zu den vertikalen Gruppen zählt.

Wählen Sie jetzt das Datums-Gadget in der Liste des Gadgets-Editors
an (nur selektieren) und klicken auf das rechts befindliche Gadget
@{b}"Abwärts"@{ub}. 

Nun befindet sich das Datums-Gadget unterhalb unseres Gruppen-Gadgets.
Es erscheint in das HGroup-Gadget eingerückt und ist ab sofort ein 
Mitglied dieser Gruppe.

In unserer Root-Gruppe gibt es jetzt nur noch ein einziges Objekt, 
nämlich unser HGroup-Gadget. Dieses besitzt aber selbst ein Datums-
Gadget als Mitglied.

Klicken Sie Doppelt auf das HGroup-Gadget in der Gadget-Editor Liste. 
In dem daraufhin erscheinenden Attributeinsteller klicken Sie auf 
den Karteikartenreiter @{b}"Attribute"@{ub}. Dadurch wird eine andere Seite 
innerhalb des Attributeinstellers aufgeschlagen.

Suchen Sie das Integer-Gadget mit der Beschriftung @{b}"HBorder"@{ub} und 
geben Sie dort den Wert 10 ein. Bestätigen Sie mit @{i}<Ok>@{ui}, so daß das
Fenster wieder verschwindet und klicken erneut auf das Gadget @{b}"Neu 
zeichnen"@{ub}. Die vorgenommene Änderung wird angezeigt.

Ziehen Sie das Fenster auf die minimale Größe und sehen Sie sich
die verbleibenden Ränder links und rechts von unserem Datums-Gadget an.
Dort sind jeweils 10 Pixel frei. Das ist unser @{b}"HBorder"@{ub}.

Klicken Sie nun wieder doppelt auf das HGroup-Gadget in der Liste
des Gadget-Editors und suchen Sie auf der Seite für die Attribute den 
Eintrag @{b}"VBorder"@{ub}. Er befindet sich in der rechten
Spalte. Dort geben Sie eine 6 ein. Bestätigen Sie und lassen Sie das 
Vorschaufenster mit Klick auf @{b}"Neu zeichnen"@{ub} neu anzeigen.
Jetzt haben wir auch noch oben und unten einen 6 Pixel großen freien 
Raum.


@endnode

@node "ST_Ubung2" "StormWIZARD.guide/ST_Project"
@toc "Main"

@{b}2. Übung@{ub}

Soll das Gruppen-Gadget um seine Mitglieder einen Rahmen zeichnen,
dann müssen Sie mit einem Doppelklick auf das HGroup-Gadget auf 
der Seite für die Attribute den Rahmentyp einstellen.

Wählen Sie aus dem Popup-Menü dem Eintrag @{b}"SButton"@{ub} aus und
lassen Sie sich das Vorschau-Fenster mit Klick auf @{b}"Neu zeichnen"@{ub}
anzeigen.

Ziehen Sie bitte das Fenster auf seine minimalen Dimensionen.

Wir haben jetzt einen schönen Rahmen um unser Datums-Gadget.
Doch leider wird der Rahmen in den Inhalt des Gruppen-Gadgets, also
in unser Datums-Gadget hineingezeichnet.

Damit dies nicht der Fall bleibt, stellen wir das Gruppen-Gadget-
Attribut @{b}"BHOffset"@{ub} auf 5. Bestätigen Sie den Einsteller
und lassen das Vorschau-Fenter neu anzeigen.

Wie wir leicht feststellen konnten, ist jetzt der Rahmen breiter
geworden, denn er beginnt jetzt an der linken Seite 5 Pixel früher 
und endet rechts 5 Pixel später.

Der Rahmen wird also jetzt in den durch den @{b}"HBorder"@{ub} freigehaltenen
Raum gezeichnet.

Leider ist aber unser Datums-Gadget noch oben und unten 
unschön überzeichnet.
Um dies zu ändern, wird der Parameter @{b}"BVOffset"@{ub} auf 4 
gesetzt. Jetzt liegt der Rahmen schön um unser Datums-Gadget 
herum.

@endnode

@node "ST_Ubung3" "StormWIZARD.guide/ST_Project"
@toc "Main"

@{b}Ein Beispiel Mit Paging und Notify@{ub}

Für diese Übung sollten Sie den Menüpunkt @{i}"Neu"@{ui} im Fenster-Editor
anwählen, damit wir die Grundeinstellung besitzen.

Klicken Sie auf das Gadget @{b}"Fenster hinzufügen"@{ub} und im erscheinenden 
Fenster Attribut-Einsteller geben Sie dem Fenster einen Namen. 
Schließen Sie den Attribut-Dialog mit Klick auf @{b}"Ok"@{ub}.

Klicken Sie nun mit der Maus auf das @{b}"+"@{ub}-Zeichen des ersten
Eintrags. Alternativ können Sie auch @{i}<Leertaste>@{ui} betätigen.
Unterhalb des Eintrags erscheinen nun zwei weitere Einträge, über
die man per Doppelklick zum Gadget- und zum Menü-Editor gelangt.

Mit den Cursortasten @{i}<Auf>@{ui} und @{i}<Ab>@{ui} können Sie ebenfalls die
Einträge selektieren und mit @{i}<Return>@{ui} in den jeweiligen Editor wechseln.

Rufen Sie bitte den Gadget-Editor auf. Klicken Sie mit der Maus auf das 
Popup-Menü @{b}"Objekt hinzufügen"@{ub} und wählen Sie den Eintrag @{b}"HGroup"@{ub}.
Der angezeigte Attribut-Einsteller bestätigen Sie einfach nur mit @{b}"Ok"@{ub}. 

Erzeugen Sie ein neues Cycle-Objekt, in dem Sie, aus dem Popup-Menü @{b}"Objekt
hinzufügen"@{ub} den Eintrag @{i}"Cycle"@{ui} wählen. Im angezeigten Fenster 
wechseln Sie bitte auf die Seite @{b}"Labels"@{ub} und erzeugen zwei
"Cycle-Einträge":

     Seite 1
     Seite 2

Bestätigen Sie bitte das Fenster mit @{i}<OK>@{ui}.

Das neue Cycle-Gadget ist automatisch mit der zuvor erzeugten horizontalen
Gruppe verbunden.

Erzeugen Sie jetzt ein neues HGroup-Gadget und klicken in dem erscheinenden 
Attribut-Einsteller auf den Karteikartenreiter @{b}"Attribute"@{ub}.
Damit haben wir eine neue Seite des Attribut-Einstellers sichtbar gemacht.

Rechts unten finden Sie das Textfeld @{b}"Max. Seiten:"@{ub}.
Geben Sie bitte eine @{i}1@{ui} ein. Schließen Sie das Fenster mit @{b}"Ok"@{ub}.

Die neue angefügte horizontale Gruppe soll aber an Root-Gadget angefügt werden, 
weshalb vor dem nächsten Schritt @{b}"Abwärts"@{ub} betätigt werden muß.

Das HGroup-Gadget ist nun nicht mehr mit dem ersten HGroup-Objekt verbunden.

Fügen Sie ein Button-Objekt hinzu und geben in das Feld  @{b}"Name"@{ub} den
Text "Auf Seite 1" ein. Schließen Sie das Fenster mit @{b}"Ok"@{ub}.

Erzeugen Sie erneut ein Button-Objekt und geben im Namensfeld den  Text 
"Auf Seite 2" ein. Ändern Sie bitte den Wert für @{b}"Seite:"@{ub} in 1.

Klicken Sie jetzt auf @{b}"Neu zeichnen"@{ub}, damit das Resultat Ihrer
Arbeit angezeigt wird.

Wenn Sie im Preview-Fenster das Cycle-Gadgte betätigen hat es leider
keinerlei Auswirkung.

Sie müssen zuerst die Verbindungen zwischen dem Cycle-Gadget und dem 
Gruppen-Gadget herstellen.

Selektieren Sie dazu im Gadget-Editor das Cycle-Gadget und klicken Sie auf 
das Feld @{b}"Notify Editor"@{ub}.

Klicken Sie bitte auf das Popup-Feld rechts oben und wählen den Eintrag
"3, HGroup". Jetzt haben Sie ein Verbindungsobjekt angelegt.

Dieses Objekt besitzt bereits die korrekten Einstellungen, denn StormWizard
schlägt ihnen diese vor. Schließen Sie den Notify-Editor mit @{b}"Ok"@{ub} und 
lassen Sie sich das neue Fenster mit Klick auf @{b}"Neu zeichnen"@{ub} anzeigen.

Grafisch hat sich nichts verändert, dafür funktioniert aber jetzt das
@{b}"Paging"@{ub} mittels Cycle-Gadget.

Wir wollen aber noch weitere Verbindungen herstellen um Ihnen die 
Funktionsweise noch deutlicher zu machen.

Selektieren Sie den Eintrag "3, HGroup" im Gadget-Editor. Mit dem Notify-
Editor erzeugen Sie ein Verbindungsobjekt zum Cycle-Gadget.

Übernehmen Sie die Einstellungen mit @{b}"Ok"@{ub}. Wenn Sie jetzt 
@{b}"Neu zeichnen"@{ub} betätigen, hat sich nichts verändert, denn das 
HGroup-Objekt kann das Paging noch nicht von sich aus übernehmen. 

Klicken Sie dazu doppelt auf den Gaget-Editor Eintrag "3, HGroup".
Fügen Sie zwei neue Labels hinzu und geben für das erste den ersten 
Text "Seite 1" und für das zweite "Seite 2" ein.

Wechseln Sie mit Klick auf den Karteikartenreiter auf die Seite @{b}"Attribute"@{ub}.

Ändern Sie hier den Wert für @{b}"HBorder"@{ub} auf 10. Setzen Sie nun den
Wert für @{b}"VBorder"@{ub} auf 6, @{b}"BHOffset"@{ub} auf 6 und @{b}"BVOffset"@{ub} 
auf 4.

Den Wert in @{b}"Max. Seiten"@{ub} setzen Sie bitte auf 0, denn er besitzt 
jetzt keine Bedeutung (Labels bestimmt jetzt die Anzahl der Seiten).

Wenn Sie jetzt das Fenster mit @{b}"Neu zeichnen"@{ub} anzeigen lassen, 
sehen wir unser fertiges Fenster.

@endnode

@node "ST_Layout" "StormWIZARD.guide/ST_Project"
@toc "Main"

@{b}Layouttechniken@{ub}

Um die Position von Objekten innerhalb eines Fenster automatisch bestimmen
zu lassen, werden diese in Gruppen-Gadgets untergebracht. Wir unterscheiden
horizontale und vertikale Gruppen. 

@{i}1. Merksatz:@{ui}
-----------
Ein horizontales Gruppen-Ggadget ordnet seine Mitglieder nebeneinandern an,
während das vertikale Gruppen-Gadget die Mitglieder untereinander anordnet.

@{i}2. Merksatz:@{ui}
-----------
Freiräume werden immer zwischen den Mitgliedern dargestellt und je nach
Gruppen-Gadgettype auch berechnet. D.h. ein horizontals Gruppen-Gadget wird
einen Freiraum zwischen den nebeneinander liegenden beiden Objekten
erzeugen. Die Anzahl der Objekte um eins verringert ergibt die Anzahl der
Freiräume. Bei nur einem Mitglied kann kein Freiraum erzeugt werden.

@{i}3. Merksatz:@{ui}
-----------
Die Mindestbreite einer horizontalen Gruppe für die übergeordnete Gruppe
setzt sich aus der Summe aller minimalen Mitgliederbreiten und den freien
Plätzen zwischen diesen zusammen. Außerdem muß der Wert für @{b}"HBorder"@{ub} doppelt
addiert werden. Die Mindesthöhe ergibt sich aus dem doppelten Wert für
@{b}VBorder@{ub} und der größten Mindesthöhe eines Mitglieds.

@{i}4. Merksatz:@{ui}
-----------
Die Mindestbreite einer vertikalen Gruppe für die übergeordnete Gruppe
errechnet sich aus dem doppelten Wert für @{b}"HBorder"@{ub} und der größten 
Mindestbreite eines Mitglieds. Dagegen muß für die Mindesthöhe einer Gruppe 
die Summe aller Einzelmindesthöhen der Mitglieder mit den dazwischen-
liegenden Freiräumen addiert werden. Der Wert für @{b}"VBorder"@{ub} wird wieder 
doppelt hinzugerechnet.

@{i}5. Merksatz:@{ui}
-----------
Innerhalb einer horizontalen Gruppe bekommt ein Mitglied immer die volle
Höhe des Grauppengadgets zugeteilt. Dabei wird natürlich @{b}"VBorder"@{ub} oben
und unten freigelassen. Ein vertikales Gruppengadget übergibt allen Migliedern
die selbe Breite, unter Berücksichtigung von @{b}"HBorder"@{ub} an der linken und
rechten Seite.

@{i}6. Merksatz:@{ui}
-----------
Ein horizontale Gruppen-Gadget errechnet die Breite eines Mitgliedes anhand
dessen Priorität und seiner minimalen Breite. Dabei beachtet es auch die 
minimalen Breiten aller anderen Miglieder. Der @{b}"HBorder"@{ub}-Wert wird 
dabei links und rechts freigelassen. Umgekehrt gilt für vertikale Gruppen 
das der @{b}"VBorder"@{ub}-wert oben und unten freigelassen wird und mit 
dem verbleibenden Wert wird die Höhe für jedes Mitglied errechnet. Dabei 
beachtet dieses die minimale Höhe und Priorität des Einzelobjektes wie auch 
die Gesamtsumme aller Mitglieder. Den entscheidenden Einfluß auf die 
Verteilung des Patzes unter den Mitgliedern einer Gruppe, übt also die 
Priorität der Mitglieder untereinander aus!

@{i}7. Merksatz:@{ui}
-----------
Besitzt ein Mitglied einer Gruppe eine Priorität von Null, dann bedeutet
es, das innerhalb einer horizontalen Gruppe seine Breite immer auf den
minimalen Betrag gesetzt wird! Bei einer vertikalen Gruppe trifft dies dann
auf die Höhe des Mitglieds zu.

@{i}8. Merksatz:@{ui}
-----------
Besitzt ein horizontales Gruppen-Gadget das Flag @{b}"Equalsize"@{ub}, dann 
bedeutet es, das alle Mitglieder die selbe Mindestbreite verordnet bekommen.
Dabei fragt das Gruppengadget alle Mitglieder nach der Mindestbreite und 
rechnet mit der größten Mindestbreite für alle Mitglieder weiter.
Das vertikale Gruppen-Gadget funktioniert entsprechend für die Mindesthöhe.

@{i}9. Merksatz:@{ui}
-----------
Beträgt die Gesamtpriorität aller Mitglieder einer Gruppe gleich Null,
darf der Wert für @{b}"Var. Leerraum"@{ub} nur mit 0 oder 100 Prozent
initialisiert werden. Geben Sie hier trotzdem einen davon abweichenden 
Wert ein, müssen Sie mit einer nicht definierten Positionsbestimmung
rechnen.

In zukünftigen Versionen der Library kann sich hier etwas ändern!

@{i}10. Merksatz:@{ui}
----------
Ein Objekt ordnet sich immer seiner übergeordneten Gruppen ein. Dies
geschieht unter Berücksichtigung der beim Mitglied festgelegten Seite.
Wurde bei einem Objekt die Seitennummer 1 eingegeben, dann ist es nur
sichtbar, wenn die Seite 1 beim Gruppengadget die aktuelle Seite ist.

@{i}11. Merksatz:@{ui}
----------
Der @{b}"Dockmodus"@{ub} eines Gruppen-Gadgets berücksichtigt nur die minimale
Breite und Höhe eines Mitglieds. @{b}"Leerraum"@{ub} und @{b}"Var. Leerraum"@{ub}
werden ebenfalls nicht berücksichtigt. Für diesen Modus muß das Gruppengadget 
mit einem Link zu einem Proportional-Gadget versehen werden, welches rechts
oder unter dem Gruppengadget angeordnet ist!

@endnode

@node "ST_Klassenspezial" "StormWIZARD.guide/ST_Project"
@toc "Main"

@{b}Klassenspezifisches Layoutverhalten:@{ub}

Jede Klasse nimmt den ihr dargebotenen Raum verschieden an. Dabei kann
man Sie in 2 Gruppen einteilen.

* Klassen welche den Ihnen angebotenen Raum voll annehmen, sind:

- Gruppen-Klassen
- Scroller-Klassen
- Slider-Klassen
- ListView-Klassen
- Arrow-Klasse
- Line-Klasse
- Colorfield-Klasse
- VectorButton-Klasse
- Space-Klasse
- Image-Klasse
- ImageButton-Klasse
- ImageToggle-Klasse
- ImagePopup-Klasse
- Palette-Klasse
- VectorPopup-Klasse
- Hierarchy-Klasse

* Klassen die eine feste Höhe besitzen und sich deshalb vertikal zentrieren
  sind:

- Button-Klasse
- String-Klasse
- Label-Klasse
- CheckBox-Klasse
- MutualExclusion-Klasse
- Integer-Klasse
- Toogle-Klasse
- Args-Klasse
- Gauge-Klasse
- Date-Klasse
- Cycle-Klasse
- TextPopup-Klasse
  
  Diese Klassen dürfen in einer vertikalen Gruppen immer nur eine Null
  als Priorität besitzen. Um Kompatibilität zu waren, sollten Sie sich
  daran halten.
  
@endnode

@node "ST_Notify" "StormWIZARD.guide/ST_Project"
@toc "Main"

@{b}Die Notifyobjekte@{ub}

Da jede Klasse ihre besonderen Eigenschaften hat und es sinnvoll ist,
diese zu kombinieren, können Objekte miteinander kommunizieren.
Dies geschieht ohne Zutun des Programmierers. Man kann zum Beispiel
einen Slidergadget mit einem Integergadget zusammenarbeiten lassen.

Dazu muß jedoch ein Verbindungs-Objekt angelegt werden. Für solche 
Arbeiten wurde der Notify-Editor entworfen. Dieses Verbindungs-Objekt 
kann, wenn eine Nachricht vom Source-Objekt abgeschickt wird, 
"mappen".

Dieses Mappen bedeutet, das eine Informationskennung geändert wird.
So lässt sich zum Beispiel die Informationskennung @{b}WSLIDERA_Level@{ub},
mit welcher der Stand eines Sliders gekennzeichnet wird, in die
Informationskennung @{b}WINTEGERA_Long@{ub} "mappen".

Diese neue Informationskennung wird von unserem Zielobjekt, einem 
Integer-Gadget, verstanden. Es lassen sich prinzipziell fast alle 
Klassen miteinander verbinden.

Ändert der Benutzer aber nicht den Sliderstand, sondern den Wert des
Integergadgets, wird ersterer nicht benachrichtigt. Zu diesem Zweck
sollten Sie ebenfalls ein Verbindungsobjekt erzeugen, welches die
Informationskennung von @{b}WINTEGERA_Long@{ub} nach @{b}WSLIDERA_Level@{ub}
konvertiert.

Damit sind beide Objekte in beiden Richtungen miteinandern verknüpft.
Es läßt aber nicht nur die Informationskennung ändern, sondern auch
die Information selbst.

@endnode

@node "ST_Proging" "StormWIZARD.guide/ST_Project"
@next "ST_Order"
@toc "Main"

@{" Grundlagen    " link "ST_Proging_Grundlagen"} Nutzung der Wizarddateien in Programmen
@{" Bubble-Help   " link "ST_Proging_BubbleHelp"} Bubble-Help benutzen

@endnode

@node "ST_Proging_Grundlagen" "StormWIZARD.guide/Grundlagen"
@next "ST_Proging_BubbleHelp"
@toc "ST_Proging"

@{b}Nutzung der Wizardateien und Programmierung der Oberflächen!@{ub}

Dies dürfte wohl das interessanteste Kapitel sein, deshalb finden Sie hier
auch Beispiele wie Funktionen in der Sprache ANSI-C angesprochen werden.

Um auch die Funktionen der Library nutzen zu können, muß diese natürlich
auch geöffnet werden, dies geschieht wie auf dem Amiga üblich:

   struct Library *WizardBase; // Basisaddressse definieren
		.
		.
		.
   if( (WizardBase = OpenLibrary("wizard.library",0L)))
		{
      // Library geöffnet
		}
	else
		// Fehlerabfang!

Am Ende eines Programmes sollten Sie die Library wieder freigeben, damit
der Speicher der dafür belegt wurde, freigegeben werden kann.
Das könnte wie folgt aussehen:

		.
		.
		.
	if( WizardBase)
	   CloseLibrary( WizardBase);
      // ab hier keine Funktion mehr nutzbar!!!

Um jetzt eine Oberflächenbeschreibung verfügbar machen zu können, sollten
Sie die Funktion WZ_OpenSurface() benutzen. Ein Beispiel: 

	APTR MySurface;
		.
		.
		.
   if( (MySurface = WZ_OpenSurface("manager.wizard",0L,TAG_DONE)))
		{
		// Datei erfolgreich geladen
		}
	else
		// Fehlerabfang!

Zurückgegeben wird die Speicheradresse, an die die Wizard-Datei geladen
wurde. Im Fehlerfall erhalten Sie eine Null als Ergebnis.

Wenn Sie die Lokalisierungseigenschaften von StromWizard nutzen möchten,
muß die Adresse des entsprechenden Lokale-Catalogs beim Öffnen der 
Oberflächendatei mitangegeben werden.

Zuvor muß der Catalog allerding mit den Funktionen der Locale.Library
ebenfalls geladen werden.

Beachten Sie, daß Sie hierbei auch die locale.library geöffnet haben
müssen.

Beispiel:

 APTR MySurface;

 struct Catalog *MyCatalog;

 if (( MyCatalog = OpenCatalog(NULL,"program.catalog",TAG_DONE)))
   {
   if ((MySurface=WZ_OpenSurface("program.wizard",NULL,
                                 SFH_Catalog, MyCatalog,
                                 TAG_DONE)))
      {
      .
      .
      WZ_CloseSurface(MySurface);
      }
   
   CloseCatalog(MyCatalog);
   }

Die Abfrage,ob der Katalog geladen werden konnte ist nicht unbedingt
erfoderlich! Sie können also stur programmieren.

Der im obigen Beispiel übergeben Null-Parameter ist ein Zeiger auf eine
Adresse innerhalb des Speichers. Falls nämlich die ".wizard"-Datei bereits
im Speicher ist (durch Binärinclude), dann sollten Sie diese Addresse
angeben und den Namensstring auf Null setzen.

Beispiel:
	MySurface=WZ_OpenSurface(0L,SurfaceAddress,TAG_DONE);

Nun wollen wir aber ein Fenster erzeugen und dazu müssen wir erst einmal
ein sogenanntes WindowHandle beantragen. Dazu machen wir einen Funktions-
aufruf wie im Fogenden beschrieben:

 struct WizardWindowHandle *MyWinHandle;

 MyWinHandle=WZ_AllocWindowHandle(MyScreen,
                                  sizeof(MyWinExtension),
                                  MySurface,
                                  TAG_DONE);

MyScreen ist ein Zeiger auf den zu verwendenden Screen, auf dem unser
Fenster später erscheinen soll.

Gleichzeitig können Sie die Größe einer automatisch bereitzustellenden
privaten Struktur angeben. Dies ist nützlich, da man häufig eigene Daten
zu einem Fenster verwalten muß. Die Adresse dieser bereitgestellten
Struktur finden Sie in der WizardWindowHandle-Struktur eingetragen. 

Möchten Sie von dieser Möglichkeit keinen Gebrauch machen, geben Sie 
hier eine Null an.

@{b}MySurface@{ub} ist der vom vorhergehenden @{b}WZ_OpenSurface@{ub} 
zurückgegebene Handle.

Zu guter Letzt können noch Tags übergeben werden. Im Moment sind für
kann nur das Tag WWH_StackSize angegeben werden. Dieses Tag bschreibt
die Stackgröße des Fensterspezifischen Stacks, welcher beim Layoutvorgang
benutzt werden soll. Dieser wird gleichzeitig beim Funktionsaufruf
allokiert.

Wenn Sie den @{b}WindowHandle@{ub} nicht mehr benötigen sollten Sie ihn
wieder freigeben, dabei werden alle Objekte, die in dem @{b}WindowHandle@{ub}
eingetragen sind automatisch wieder freigegeben. Dies betrifft auch ein
eventuell geöffnete Fenster!

	WZ_FreeWindowHandle( MyWinHandle);

Ein @{b}WindowHandle@{ub} alleine ist nicht sinnvoll, deshalb gibt es eine
Funktion zum Erzeugen aller zu einem Fenster gehörenden Objekte. Dies 
betrifft Gadgets, Menüs, Notify-Verbindungsobjekte und anderes.

Beispiel:

 #define MY_WINDOW_ID		1
 #define MY_WINDOW_GADGETS	80

 struct NewWindow *MyNewWindow;
 struct Gadget *MyGadgets[MY_WINDOW_GADGETS];

 MyNewWindow=WZ_CreateWindowObj( MyWinHandle,
                                 MY_WINDOW_ID,
                                 WWH_GadgetArray, MyGadgets,
                                 WWH_GadgetArraySize, sizeof( MyGadgets),
                                 TAG_DONE);

Der Parameter @{b}MyWinHandle@{ub} benötigt keine Erklärung mehr, dafür
aber @{b}MY_WINDOW_ID@{ub}. Hierbei handelt es sich um die Identifizierungs-
nummer, welche von StormWizard beim Speichern vergeben wird.
In der automtisch mitgespeicherten Include-Datei finden Sie diese ID unter
dem im StormWizard im Fensterattribut-Einsteller eingegeben ObjektNamen.

Die folgendende Tagliste sollte mindestens das Tag @{b}WWH_GadgetArray@{ub} 
enthalten, mit dem Sie die Adresse ihrer Gadget-Liste übergeben. Denn Sie
wollen schließlich auch auf die erzeugten Gadgets zugreifen können.

Dabei sollte das Array alle Gadgets aufnehmen können. Um also sicher zu
stellen, das das GadgetArray nur akzeptiert wird, wenn es groß genug ist,
sollten Sie außerdem die Größe in Bytes beim Tag @{b}WWH_GadgetArraySize@{ub}
angeben.

Konnten alle Objekte richtig zurückgegeben werden, dann erhalten Sie die
Adresse einer bereits initialisierten NewWindow-Struktur zurück.

Diese Struktur dürfen Sie selbst ändern und brauchen Sie auch für den 
Aufruf in der folgenden Funktion:

	struct Window *MyWindow;
	
	MyWindow=WZ_OpenWindow( MyWinHandle,
	                        MyNewWindow,
	                        WA_AutoAdjust ,TRUE,
	                        TAG_DONE);

Die Parameter @{b}MyWinHandle@{ub} und @{b}MyNewWindow@{ub} kennen Sie bereits von den
vorhergehenden Funktionen. Hinzu kommt dann eine Tagliste, die alle Tags
zuläßt, welche bei der Funktion @{b}"OpenWindowTagList()"@{ub} zulässig sind.

Es empfiehlt sich dabei, das Tag @{b}WA_AutoAdjust@{ub} auf @{b}TRUE@{ub} zu setzen, um das
Fenster notfalls anpassen zu lassen.

Um das Fenster zu schließen existiert analog die Funktion:

	WZ_CloseWindow( MyWinhandle);
	

Dabei können Sie ein Fenster beliebig oft öffnen und wieder schließen!

Da ein Fenster nur Sinn macht, wenn man auch Nachrichten empfängt, sollten
Sie mittels @{b}Wait()@{ub} oder @{b}WaitPort()@{ub} auch auf Nachrichten warten.
Holen Sie die Nachricht wie gewohnt mittels @{b}GetMsg()@{ub} vom Userport des
Fensters ab. Möchten Sie nun die Tastaturunterstützung für Wizard-Klassen
nutzen, schauen Sie sich folgenden Auszug an.

   switch(msg->Class)
   {
      case IDCMP_VANILLAKEY:

         WZ_GadgetKey( MyWinHandle, msg->Code, msg->Qualifier,TAG_DONE);
      
         break;
      .
      .
      .
   }

Die Besonderheit ist die, daß, falls ein Gadget für diesen Tastendruck
zuständig war, dieses veranlasst wird, selbst eine Nachricht vom Type
@{b}IDCMP_IDCMPUPDATE@{ub} abzuschicken. Dabei werden die Notify-Objekte
ebenfallse berücksichtigt.

Handelte es sich um ein Integer- oder String-Gadget, dann wird dieses 
aktiviert und es sendet keine Nachricht aus. Die Funktion gibt außerdem
zurück, ob überhaupt ein Gadget zuständig gewesen ist.
In unserem Beispiel haben wir das aber nicht berücksichtigt.

Ab der Betriebssystemversion V39 kann der Amiga @{b}IDCMP_GADGETHELP@{ub} `s
an den Programmierer senden. Häufig nutzt man das, um einen Hilfe-Text
für den Anwender darzustellen. Dazu können Sie mit einer Funktion einen
Hilfe-Text für jedes Objekt im StormWizard eingeben. Anfordern können
Sie ihn bei einem Gadget wie folgt.

	STRPTR Help;
	
	Help=WZ_GadgetHelp(MyWinHandle,msg->IAddress);

Unter Umständen können Sie auch eine Nulladdresse bekommen, beachten Sie
dies, in dem Sie das Ergebnis abfragen. Auch für Menüs gibt es eine solche
Funktion, falls @{b}IDCMP_MENUHELP@{ub} - Nachrichten ankommen.

	STRPTR Help;
	
	Help=WZ_MenuHelp(MyWinHandle,msg->Code);
	
Leider kann erst ab Version 39 das Betriebssystem eine solche Funktion
übernehmen. Häufig soll die Entwicklung aber schon ab V37 (OS 2.0/2.1)
laufen, deshalb besitzt die Library auch eine Funktion, mit der die
Gadget-Help Nachricht simuliert werden kann. Dazu müssen Sie die
Mausbewegung beobachten.

	
	STRPTR Help;
	
	APTR HelpIAddress;
	
	struct WizardWindowHandle *HelpWinHandle;
	.
	.
	.
	case IDCMP_MOUSEMOVE:
	   
	   if (WZ_GadgetHelp( MyWinHandle, &HelpWinHandle, &HelpIAddress,
	   			msg->MouseX, msg->MouseY, 0))
	   {
	      Help=WZ_GadgetHelp( HelpWinHandle, HelpIAddress);
	   }
	   break;
	.
	.
	.

@{b}MyWinHandle@{ub} ist das Fenster, bei dem die Nachricht einer Mausbewegung
angekommen ist.
@{b}HelpWinHandle@{ub} enthält den Zeiger auf ein @{b}WizardWindowHandle@{ub},
wenn eine Gadget-Help Nachricht vorliegt.

Die Variable @{b}HelpIAddress@{ub} enthält dabei den Wert, wie er bei 
@{b}IntuiMessage->IAddress@{ub} zu finden ist.

Die Mausposition wird natürlich auch benötigt und noch Flags, welche
das Verhalten der Funktion bestimmen.

Wird das Flag @{b}WGHF_IgnoreOS@{ub} gesetzt, wird auch ab OS V39 und höher
eine GadgetHelpfunktion simuliert, sonst nur unter V37 (OS 2.0/2.1). 

Dagegen besitzt das Flag @{b}WGHF_FullContol@{ub} noch keine Bedeutung.

Häufig ist es erforderlich ein geöffnetes Fenster gegen Eingaben von Seiten
des Benutzers zu sperren, auch dafür besitzt die Library eine Funktion, der
Sie das WizardWindowHandle übergeben müssen. Sie dürfen diese Funktion
mehrnals hintereinander aufrufen:

	WZ_LockWindow( MyWinHandle); // Fenster ist jetzt gesperrt


Um es wieder für Eingaben zuzulassen, existiert auch eine Funktion, welche
den selben Parameter verlangt.

	WZ_UnlockWindow(MyWinHandle); // Fenster wieder bereit für Eingaben

Dabei wird das Fenster nur wieder für Eingaben zulässig, wenn diese
Funktion genauso oft aufgerufen wird, wie die Funktion @{b}WZ_LockWindow()@{ub}
für dieses Fenster.

Wenn man mit mehreren geöffneten Fenstern arbeitet, dann können Sie
schlagartig mit einer Funktion alle geöffneten Fenster gegen Eingaben
sperren.

Als Parameter dient die von WZ_OpenSurface() gelieferte Adresse.
Achten Sie auf das angefügte "s" !

	WZ_LockWindows( MySurface);

Das Gegenteil bewirkt die Funktion:

	WZ_UnlockWindows( MySurace);

@endnode

@node "ST_Proging_BubbleHelp" "StormWIZARD.guide/BubbleHelp"
@toc "ST_Proging"

@{b}Bubble-Help@{ub}

Ab Version 41 unterstützt die wizard.library Bubble-Help. Damit die Bubble-Help
geöffnet werden kann müssen verschiedene Bedingungen erfüllt sein:

1. Jedes Gadget, für das eine Bubble-Help angezeigt werden soll, muß das Flag
"GadgetHelp" gesetzt haben und einen passenden Hilfetext eingetragen haben. Diese
Bedingung muß für jede Gadget-Hilfe erfüllt sein.

2. Das Fenster muß mit der Funktion HelpControl() und Setzen des entsprechenden IDCMP
Flags IDCMP_GADGETHELP für GadgetHelp Nachrichten freigeschaltet sein. Auch diese
Bedingung muß für jede Gadget-Hilfe erfüllt sein.

3. Neben dem Flag IDCMP_GADGETHELP müssen noch weitere Flags gesetzt sein: IDCMP_INTUITICKS
und IDCMP_INACTIVEWINDOW sind Pflicht, damit die Bubble-Help mit der notwendigen 
Verzögerung geöffnet und in jedem Fall auch wieder geschlossen wird.

4. Jede IntuiMessage, die das Programm empfängt muß zuerst mit WZ_HandleIMessage()
bearbeitet werden. Diese Funktion führt die Bubble-Help durch, d.h. sie öffnet das
Fenster mit der Bubble-Help und schließt es auch wieder.

Soll ein Fenster explizit keine Bubble-Help unterstützten, obwohl das Fenster Gadgets
mit gesetztem GadgetHelp-Flag enthält, so kann beim Aufruf der Funktion 
WZ_CreateWindowObj() die Bubble-Help für das Fenster durch die Angabe des Tags
WWH_BubbleHelp mit dem Wert FALSE unterdrückt werden.

Im Gegensatz zur normalen Gadet-Help wird die Bubble-Help nur für OS Versionen ab V39
unterstützt, es erfolgt keine Simulation der Nachricht IDCMP_GADGETHELP durch 
Mausbewegungen.


@{b}Style Guide@{ub}

Jedes Programm mit Bubble-Help sollte diese auch abschaltbar machen. Dazu wird der HotKey
Shift-Help empfohlen. Die BubbleHelp word mit WZ_ControlBubbleHelpA() an- bzw.
ausgeschaltet.

Die Bubble-Help kann und sollte mehrzeilig gestaltet werden. Dazu ist die Eingabe
des Hilfetextes im StormWIZARD für die Fenster und Gadgets mehrzeilig möglich.

@endnode
