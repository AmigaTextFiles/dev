
                               [1mparse()[0m
                           [4mversion 1.00[0m

                      [3mby Jean-Pierre Rivière[0m

          (Lecteur francophone, veuille bien lire parse.doc)


    ABSTRACT : command line parser, easy to use and fully System V
               compliant (for the options rules).
               copyright (c) 1992 by Jean-Pierre Rivière.
               Freely redistriubtable and free (that's freeware)
               Any use of this program is free and costless as long
               as the source of the program thereof, if it is
               distributed, includes the present software package
               or at least gives its reference and the mean to fetch it.
               Any use of the package thereof is done at the sole risks
               of the user, the author declining any responsability in
               advance.
               Enough talk, let's see the thing!

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

      Cares for the scrupulous respect of Unix System V v4 convnetions
   for options parsing rules on command lines. To this end, uses a format
   strings where all the options are included in no particular order,
   but with a space after each option without arguments and with a
   semicolon after each option with an argument.

      If everything has been all right, the return value is positive or
   null, equal to the number of options recognized in the command line.

      Else it is negative to indicate a syntax error ir that the dynamic
   memory allocation failed. In any case, there is nothing corresponding
   to what might have been seen and hence you must not try to see that!

      If everything was OK, you shall disallocate manually by calling
   parse_cleanup() to free what parse() had allocated.

      Let's remember that all the options shall be set before any arguments
   if nay, that their order is clueless but that they shan't be repeated,
   even if it would not be in contradiction.

      parse() and parse_cleanup() are two functions which I wrote as a
   C module to ease the management of multiple options on command lines.
   My goal was might and comfort and I think I reach that.

      Might because of the strict following of the norms edicted by the
   Open Software Foundation. Might because easy to set into motion and
   to get evoluate. The whole is then ergonomic both for the programmer
   and the end user (unifomization of the shell interface is more easy
   so more extended).

      The main tool for these two functions is a dumb strings which is
   a sequence of options and option types : with or withour argument.

      For instance if your program is to be used so :

      fubar [-h] [-i] [-f <file>] [-o <dest>] [-v] [-R] <mode> [<type>]

   then the automatic treatment of the options is realized with the
   following C string :

      "h i f;o;v R "

   or still, because the order is unimportant in that string :

      "R f;h i o;v "

      The characters in odd positions are the letters of the options. A
   semicolon after a letter indicates that the option takes an argument,
   a space that it doesn't. Beware : the charactcter after the letter of
   option is fully mandatory.

      Attention also to the fact that the option are case-sensitive and that
   you normally should use only letters (this last point is not checked but
   it's up to the programmer to decide what he does there).

      By respect to the conventions thereof, the following command lines
   are accepted (and correctly processed ;-) (if, of course, fubar finds
   good the number of arguments he gets) :


      fubar -i -hR -f thanks my lad

      fubar it_was_a pleasure

      fubar -o hara -hRi -f you said so

      fubar -h -  ---> here - means standard input and is not an option.

      fubar -h -o brien -- -i     --> -- indicates the end of the options
                                      -i is the first argument.

      fubar -hi -o -i owa    --> the argument of an option with argument
                                 is totally free. Here -i is the argument
                                 of the option o.

   But the latter are not :

      fubar -hRo hara kiri  ---> the option wiharguments have to be lonesome

      fubar -hRi -hv virus  ---> never repeat an option

      fubar -ohara sant     ---> don't tie the argument to its option

      fubar -h - -i trema   ---> the - is considered as an option whose
                                 letter lacks. Tthis might be out of the
                                 norms (I have no more these at hand) but
                                 I thought that if - is followed by a
                                 group beginning by - then the first -
                                 would very certainly be a typo (this is
                                 true anyway when you encounter - --). This
                                 was not a thing which simplified my code,
                                 so I wait for your reactions...

      Well, here's a formal grammar for the description string :
                  descriptor ::= descriptor | option
                  option ::= (letter type)
                  letter ::= { a...z A...Z }
                  type ::= ( <space> ; )

      And to use all this ? See the the source code. If you define TEST
   on the compilation line, you'll get an executable which will show you
   I am not a liar. As the main() function suggests it, the idea is to do :

      if (parse(...) < 0) {
         /* syntax errors treatment */
         exit(1);
      }
      /* program own logic errors treatment */
      ...
      /* endd of the program */
      parse_cleanup();
      exit(0);

      For a greater ease, I defined a structure holding all the data, which
   allows to easily point out what happens, and if it goes wrong.

      I let you have a look at the code (I won't duplicate it). Then pay
   attention to the following things :
      - a call to parse_cleanup() without a prior call to parse() is
         illegal and return an error code. Yet harmless.
      - a call to parse_clenup() after a call to parse() which failed is
         illegal beacause parse() had cleansed everything already, and an
         error code is returned. Yet harmless.
      - two consecutive call to the same function parse() or parse_cleanup()
         are forbidden and the second return an error code. Yet harmless.
      - a call to parse_cleanup() is to free the memory allocated by a
         successful call to parse(). Don't forget then to call it, even if
         for instance the options set do not respect the logic of your
         program. See the main() given as example.

      To use these two functions, compile them apart then link them
   with your program. Thsi will warrant the processes involved.

      I defined several flags for the compilation of the module parse.o :

      NO_PARSE_ERR_MESS : if it is defined, the error messages won't exist.
         You will then only have the error codes.
      ENGLISH : it it is defined and if there are errors messages, those
         will be in English (default id French :^)
      ERR_MESS_WITHOUT_LETTER : if it is defined and if there are errors
         messqages, those will be simple strings ready for printing. By
         default, these string holds a %s in the right place to put the
         option letter which went wrong, and hence need to be use with
         a function like printf.

      When you edit your source; the only flag that might be defined
   (and then before including parse?h) is NO_PARSE_ERR_MESS.

      parse() and parse_cleanup() are not public domain (because I don't
   want a guy depossess me of them) but are freely redistributable and
   freeware. Their use is wished anytime an Unix-like syntax is wanted
   (I have never been able to cope with getopt() because it does not
   very well when you modify your syntax (or I don't know how to use it
   but then my solution is both more simple and more powerful)). You are
   not entitled to distribute them without the documentation or for a fee
   exceeding that of the support, the reference of that being the floppy
   disks AmigaLibDisk distributed by Fred Fish.

      Well, good C programmation. If it's another language, feel free to
   do it. Then please send me your adaptation, that would be smart of you!

   My address :

      Jean-Pierre Rivière
      13, rue Maison Dieu
      75014 PARIS
      FRANCE

