@database TWiMUI.guide

@Master Doku.tex

@Width 72


This is the AmigaGuide® file TWiMUI.guide, produced by Makeinfo-1.49 from 
the input file Doku.tex.


@Node Main "TWiMUI.guide"
@Next "Vorwort"

TWiMUI
******

   TWiMUI ist eine C++-Klassenbibliothek für MUI.


 @{" Vorwort " Link "Vorwort"}             Dies ist das Vorwort
 @{" Anforderungen " Link "Anforderungen"}       Was wird benötigt
 @{" Klassen " Link "Klassen"}             Beschreibung der Klassen
 @{" Interface " Link "Interface"}           Interface für public Custom Classes
 @{" Danksagungen " Link "Danksagungen"}        Wem muß ich danken
 @{" Author " Link "Author"}              Wer bin ich und wie kann man mich erreichen
 @{" MUI " Link "MUI"}                 MUI
 @{" Registrierung " Link "Registrierung"}       Formular für die Registrierung
 @{" Einschränkung " Link "Einschränkung"}       Einschränkungen in der unregistrierten Version
 @{" Haftungsausschluß " Link "Haftungsausschluß"}   Ich hafte für gar nichts
 @{" Index " Link "Index"}               Index


@EndNode

@Node "Vorwort" "TWiMUI.guide/Vorwort"
@Next "Anforderungen"
@Prev "Main"
@Toc "Main"

Vorwort
*******

   Diese Klassenbibliothek definiert C++-Klassen für MUI (See @{"MUI" Link "MUI"}.).
Für jede öffentliche MUI-Klasse existiert eine C++Klasse mit einigen
Konstruktoren und natürlich allen Attributen und Methoden, die in der
entsprechenden Klasse definiert sind.

   Die Vererbungshierarchie leitet sich aus der Hierarchie der
MUI-Klassen ab.

   Es sind auch einige weitere Klassen definiert, die es in dieser Form
in MUI nicht gibt. Dies sind Klassen, die originäre MUI-Klassen
ergänzen.


@EndNode

@Node "Anforderungen" "TWiMUI.guide/Anforderungen"
@Next "Klassen"
@Prev "Vorwort"
@Toc "Main"

Anforderungen
*************

   Um diese Klassenbibliothek einsetzen zu können, sollten Sie schon
mit der herkömmlichen MUI-Programmierung vertraut sein.

   Ansonsten benötigen Sie einen C++-Compiler, der auch Templates und
Exceptions beherrscht und  MUI 3.8. natürlich müssen auch deren
Anforderungen erfüllt sein.

   Seit der Version 1.1 von TWiMUI können alle Data-Modelle verwendet
werden.


@EndNode

@Node "Klassen" "TWiMUI.guide/Klassen"
@Next "Interface"
@Prev "Anforderungen"
@Toc "Main"

Klassen
*******

   Folgend nun die Beschreibungen der einzelnen Klassen. Dieses Kapitel
ist aufgegliedert in drei Teile. Zuerst kommen verschiedene
Hilfsklassen, die für ein komfortables Programmieren einer
Klassenbibiothek notwendig sind. Danach kommen die MUI-Basisklassen.
Das sind Klassen, von denen keine eigene Instanz gebildet werden kann
bzw sollte, da die eigentlichen MUI-Klassen von diesen Klassen erben.
Die eigentlichen MUI-Klasen werden dann im dritten Teil beschrieben. Im
vierten Teil sind noch ein paar definierte inline-Funktionen
aufgeführt.

   Diese Klassenbibliothek verwendet die registrierte Tag-Base *0x06af*.
Ich bitte Euch also diese Base *NICHT* in eigenen Programmen zu
verwenden.


 @{" Hilfsklassen " Link "Hilfsklassen"}       verschiedene Hilfsklassen
 @{" MUI-Basisklassen " Link "MUI-Basisklassen"}   Basisklassen für MUI-Klassen
 @{" MUI-Klassen " Link "MUI-Klassen"}        Das sind die eigentlichen Klassen
 @{" inline-Funktionen " Link "inline-Funktionen"}  einige per inline definierte Funktionen


@EndNode

@Node "Hilfsklassen" "TWiMUI.guide/Hilfsklassen"
@Next "MUI-Basisklassen"
@Toc "Klassen"

MUI-Basisklassen
================

   Hier werden jetzt alle Hilfsklassen beschrieben, die sozusagen ein
Abfallprodukt bei der Entwicklung der vorliegenden Klassenbibliothek
waren.


 @{" TWiArray " Link "TWiArray"}            Klasse für Arrays beliebiger Elemente
 @{" TWiArrayCursor " Link "TWiArrayCursor"}      Klasse, um die Array-Klasse per Cursor zu durchlaufen
 @{" TWiBuffer " Link "TWiBuffer"}           Klasse, um einen Datenpuffer zu verwalten
 @{" TWiFormat " Link "TWiFormat"}           Klasse, um RawDoFmt komfortabel zu benutzen
 @{" TWiMemX " Link "TWiMemX"}             Exception-Klasse für fehlerhafte Speicher-Anforderung
 @{" TWiShare " Link "TWiShare"}            Klasse, um dynamische Elemente zu schützen
 @{" TWiShareManual " Link "TWiShareManual"}      Klasse, um dynamische Elemente zu schützen mit manueller Referenzierung
 @{" TWiStr " Link "TWiStr"}              Klasse, um einen String zu verwalten
 @{" TWiTag " Link "TWiTag"}              Klasse, um TagItem-Strukturen zu verwalten
 @{" TWiTagCursor " Link "TWiTagCursor"}        Klasse, um die Tag-Klasse per Cursor zu durchlaufen


@EndNode

@Node "TWiArray" "TWiMUI.guide/TWiArray"
@Next "TWiArrayCursor"
@Toc "Hilfsklassen"

TWiArray
--------

     template <class T> class TWiArray
         {
         public:
             TWiArray(const ULONG);
             ~TWiArray();
             TWiArray<T> &operator= (const T &);
             T &operator[] (ULONG);
             operator APTR() const;
             ULONG size();
             ULONG length() const;
             T &addTail();
             T &insert(const ULONG);
             VOID remove(const ULONG);
             VOID remTail();
             VOID clear();
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Datastructures/Array.h

   Diese Klasse realisiert ein Array für beliebige Elemente.

TWiArray(const ULONG)
     Der Konstruktor dieser Klasse initialisiert das Array und bekommt
     die Anfangs-Anzahl der Elemente übergeben. Sollte das Anlegen des
     Array fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen. Der Default ist 16.

operator APTR
     Diese Methode liefert die Anfangs-Adresse des Array.

operator=(const T &)
     Diese Methode weist der Instanz die Elemente der Parameter-Instanz
     zu. Bei einem Array das aus Pointern besteht ist dabei natürlich
     große Vorsicht geboten.

operator[](ULONG)
     Diese Methode liefert eine Referenz des Elementes, dessen Index
     übergeben wird.

size()
     Diese Methode liefert die Anzahl der angelegten Elemente.

length()
     Diese Methode liefert die Anzahl der wirklich vorhandenen Elemente.

addTail()
     Diese Methode liefert eine Referenz des Elementes, das hinter dem
     letzten Element liegt. Diese Methode wird dazu verwendet, ein
     Element hinter dem letzten, vorhandenen Element einzufügen.
     Sollte dort kein Platz für ein neues Element vorhanden sein, so
     wird versucht das Array zu vergrößern. Schlägt dies fehl, so
     wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen. Das
     einzufügende Element muß an das Ergebnis der Methode zugewiesen
     werden.

insert(ULONG)
     Diese Methode liefert eine Referenz des Elementes, dessen Index
     übergeben wird. Alle dahinter liegenden Elemente werden um eins
     nach rechts verschoben. Diese Methode wird dazu verwendet, ein
     Element in das Array einzufügen. Sollte kein Platz für ein neues
     Element vorhanden sein, so wird versucht das Array zu
     vergrößern. Schlägt dies fehl, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen. Das einzufügende Element muß an das
     Ergebnis der Methode zugewiesen werden.

remove(ULONG)
     Diese Methode entfernt das Element, dessen Index übergeben wird.
     Alle dahinter liegenden Elemente werden um eins nach links
     verschoben.

remTail()
     Diese Methode entfernt das letzte Element.

clear()
     Diese Methode entfernt alle Elemente.

   *Beispiel:*
         .
         .
         .
         TWiArray<ULONG> arr(5);
         ULONG i;
         i = 256;
         arr.addTail() = i;
         .
         .
         .


@EndNode

@Node "TWiArrayCursor" "TWiMUI.guide/TWiArrayCursor"
@Next "TWiBuffer"
@Prev "TWiArray"
@Toc "Hilfsklassen"

TWiArrayCursor
--------------

     template <class T> class TWiArrayCursor
         {
         public:
             TWiArrayCursor(TWiArray<T>);
             ~TWiArrayCursor();
             BOOL operator! ();
             VOID first();
             VOID last();
             VOID next();
             VOID prev();
             LONG index() const;
             T &item();
             BOOL isDone();
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Datastructures/Array.h

   Diese Klasse realisiert einen Cursor, um damit komfortabel Schleifen
über Instanzen der Klasse *TWiArray* (See @{"TWiArray" Link "TWiArray"}.) definieren zu
können.

TWiArrayCursor(TWiArray<T>)
     Der Konstruktor dieser Klasse initialisiert den Cursor für das
     Array für das eine Referenz übergeben wird.

operator! ()
     Diese Methode liefert FALSE, wenn der Cursor auf ein gültiges
     Element zeigt und TRUE, wenn der Cursor aus den Bounds geraten ist.

first()
     Diese Methode setzt den Cursor auf das erste Element.

last()
     Diese Methode setzt den Cursor auf das letzte Element.

next()
     Diese Methode setzt den Cursor auf das nächste Element.

prev()
     Diese Methode setzt den Cursor auf das vorherige Element.

index()
     Diese Methode liefert den aktuellen Index mit dem in den Array
     indiziert wird.

item()
     Diese Methode liefert eine Referenz auf das aktuelle Element, auf
     das der Cursor gerade zeigt.

isDone()
     Diese Methode liefert FALSE, wenn der Cursor auf ein gültiges
     Element zeigt und TRUE, wenn der Cursor aus den Bounds geraten ist.

   *Beispiel:*
         .
         .
         TWiArray<ULONG> arr(5);
         TWiArrayCursor<ULONG> arc(arr);
         ULONG i;
         for (arc.first()  ;  !arc.isDone()  ;  arc.next())
             {
             i = arc.item();
             .
             .
             }
         .
         .


@EndNode

@Node "TWiBuffer" "TWiMUI.guide/TWiBuffer"
@Next "TWiFormat"
@Prev "TWiArrayCursor"
@Toc "Hilfsklassen"

TWiBuffer
---------

     class TWiBuffer
         {
         public:
             TWiBuffer(const ULONG);
             TWiBuffer(const TWiBuffer &);
             ~TWiBuffer();
             TWiBuffer &operator= (const TWiBuffer &);
             operator APTR() const;
             APTR buffer() const;
             ULONG size() const;
             VOID doubleBuffer(const BOOL);
             VOID setSize(const ULONG, const BOOL);
             VOID setMinSize(const ULONG, const BOOL);
             VOID extendBuffer(const ULONG, const BOOL);
             VOID eraseBuffer();
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Datastructures/Buffer.h

   Diese Klasse stellt einen einfachen Daten-Buffer zur Verfügung.

TWiBuffer(const ULONG)
     Dieser Konstruktor definiert einen Buffer in der angegebenen
     Größe. Sollte das Anlegen des Buffers fehlschlagen, so wird die
     Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen. Der Default ist
     256.

TWiBuffer(const TWiBuffer &)
     Dieser Konstruktor übernimmt die Elemente aus der angegebenen
     Klasse, legt einen eigenen Buffer der entsprechenden Größe an
     und kopiert den Buffer der Parameter-Klasse in seinen eigenen.
     Sollte das Anlegen des Buffers fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const TWiBuffer &)
     Dieser Operator übernimmt die Elemente aus der angegebenen Klasse,
     legt einen eigenen Buffer der entsprechenden Größe an und kopiert
     den Buffer der Parameter-Klasse in seinen eigenen. Sollte das
     Anlegen des Buffers fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator APTR()
     Diese Methode liefert die Anfangs-Adresse des Buffers.

buffer()
     Diese Methode liefert die Anfangs-Adresse des Buffers.

size()
     Diese Methode liefert die Größe des Buffers.

doubleBuffer(const BOOL)
     Diese Methode verdoppelt den Buffer. Wird als Parameter TRUE
     (Default) angegeben, so wird der Inhalt kopiert. Bei FALSE nicht.
     Sollte das Vergrößern des Buffers fehlschlagen, so wird die
     Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

setSize(const ULONG, const BOOL)
     Diese Methode setzt die Buffer-Größe auf den angegebenen Wert.
     Wird als zweiter Parameter TRUE (Default) angegeben, so wird der
     Inhalt kopiert. Bei FALSE nicht. Sollte die neue Größe kleiner
     als die Alte sein, wird der Inhalt abgeschnitten. Sollte das
     Anlegen des Buffers fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

setMinSize(const ULONG, const BOOL)
     Diese Methode überprüft ob der Buffer mindestens die angegebene
     Größe hat. hat er sie, so passiert nichts. Ist der Buffer aber
     kleiner, so wird ein neuer Buffer in der angegebenen
     Mindestgröße angelegt. Wird als zweiter Parameter TRUE (Default)
     angegeben, so wird der Inhalt kopiert. Bei FALSE nicht. Sollte die
     neue Größe kleiner als die Alte sein, wird der Inhalt
     abgeschnitten. Sollte das Anlegen des Buffers fehlschlagen, so
     wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

extendBuffer(const ULONG, const BOOL)
     Diese Methode vergrößert den Buffer um den als ersten Parameter
     angegebenen Wert. Wird als zweiter Parameter TRUE (Default)
     angegeben, so wird der Inhalt kopiert. Bei FALSE nicht. Sollte die
     neue Größe kleiner als die Alte sein, wird der Inhalt
     abgeschnitten. Sollte das Anlegen des Buffers fehlschlagen, so
     wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

eraseBuffer()
     Diese Methode löscht den Buffer.

   *Beispiel:*
         .
         .
         .
         STRPTR aaa = "Das ist nur ein Test";
         TWiBuffer buf(strlen(aaa)+1);
         memcpy(buf.buffer(),aaa,buf.size());
         .
         .
         .


@EndNode

@Node "TWiFormat" "TWiMUI.guide/TWiFormat"
@Next "TWiMemX"
@Prev "TWiBuffer"
@Toc "Hilfsklassen"

TWiFormat
---------

     class TWiFormat
         {
         public:
             TWiFormat(const STRPTR);
             TWiFormat(const STRPTR, const ULONG);
             TWiFormat(const ULONG);
             TWiFormat(const TWiFormat &);
             ~TWiFormat();
             TWiFormat &operator=(const TWiFormat &);
             VOID Format(const STRPTR);
             const TWiStr &Format() const;
             const TWiStr &Ergebnis() const;
             operator const STRPTR() const;
             TWiStr &format(const ULONG, ...);
             TWiStr &format(const APTR);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Datastructures/Format.h

   Diese Klasse stellt Methoden zur Verfügung um komfortabel die
Amiga-Exec-Funktion RawDoFmt() aufzurufen.

TWiFormat(const STRPTR)
     Dieser Konstruktor setzt das printf-Syle Format, mit welchem dann
     formatiert wird, auf den angegebenen Parameter. Die Größe des
     Ziel-Buffers wird in diesem Konstruktor auf 0 gesetzt.

TWiFormat(const STRPTR, const ULONG)
     Dieser Konstruktor setzt das printf-Syle Format mit welchem dann
     formatiert wird auf den String des ersten Parameters. Die Größe
     des Ziel-Buffers wird auf den Wert des zweiten Parameters gesetzt.
     Sollte das Anlegen des Buffers fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiFormat(const ULONG)
     Dieser Konstruktor setzt die Größe des Ziel-Buffers auf den Wert
     des zweiten Parameters. Sollte das Anlegen des Buffers
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen. Das printf-Style-Format wird in diesem Konstruktor
     nicht gesetzt und muß deshalb später mit der Methode
     FormatStr(const STRPTR) nachträglich gesetzt werden. Sollte das
     anlegen des Buffers fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const TWiFormat &)
     Dieser Operator übernimmt das Format und den Buffer aus der
     angegebenen Klasse, legt eigene Bereiche der entsprechenden
     Größe an und kopiert die Elemente der Parameter-Klasse in seine
     eigenen. Sollte das Anlegen eines der Elemente fehlschlagen, so
     wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

Format(const STRPTR)
     Diese Methode setzt das printf-Style-Format.

Format()
     Diese Methode liefert eine Referenz auf das printf-Style-Format.

Ergebnis()
     Diese Methode liefert eine Referenz auf das Ergebnis der
     Formatierung.

operator const STRPTR()
     Diese Methode liefert eine Referenz auf das Ergebnis der
     Formatierung.

format(ULONG, ...)
     Diese Methode ruft die Amiga-Exec Funktion RawDoFmt() auf. Die
     Argumente für die Formatierung werden als Parameterliste
     mitgegeben. Als Ergebnis liefert die Funktion eine Referenz des
     Ergebnis-Strings.

format(APTR)
     Diese Methode ruft die Amiga-Exec Funktion RawDoFmt() auf. Die
     Argumente für die Formatierung als Array-Adresse mitgegeben. Als
     Ergebnis liefert die Funktion eine Referenz des Ergebnis-Strings.

   *Beispiel:*
         .
         .
         .
         TWiFormat form("Formatiert wird die zahl: %ld",50);
         cout << form.format(28) << endl;
         .
         .
         .


@EndNode

@Node "TWiMemX" "TWiMUI.guide/TWiMemX"
@Next "TWiShare"
@Prev "TWiFormat"
@Toc "Hilfsklassen"

TWiMemX
-------

     class TWiMemX
         {
         public:
             TWiMemX(const ULONG, const ULONG);
             ULONG size() const;
             ULONG flags() const;
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Exceptions/Exceptions.h

   Diese Klasse ist zum Auswerfen einer Exception gedacht, nachdem eine
Speicheranforderung nicht geklappt hat.

TWiMemX(const ULONG, const ULONG)
     Der Konstruktor bekommt als ersten Parameter die Größe des
     angeforderten Speicherbereiches übergeben. Als zweiten Parameter
     werden die Flags des angeforderten Speicherbereiches angegeben.
     Dieser zweite Parameter kann auch weggelassen werden. Der
     Default-Wert ist dann MEMF_ANY.

size()
     Diese Methode liefert die Größe des angeforderten
     Speicherbereiches. Damit hier ein sinnvoller Wert geliefert werden
     kann, muß natürlich dem Konstruktor auch ein solcher übergeben
     werden.

flags()
     Diese Methode liefert die Flags des angeforderten
     Speicherbereiches. Damit hier ein sinnvoller Wert geliefert werden
     kann muß natürlich dem Konstruktor auch ein solcher übergeben
     werden.

   *Beispiel:*
         .
         .
         VOID Klasse::Methode()
             {
             .
             .
             APTR mem = AllocMem(1024,MEMF_CLEAR);
             if (!mem)
                 throw TWiMemX(1024,MEMF_CLEAR);
             .
             .
             }
     
         VOID main()
             {
             try
                 {
                 Klasse xx();
                 xx.Methode();
                 }
             catch(TWiMemX(memx))
                 {
                 cout << "Exception TWiMemX! Größe: " << memx.size() << endl;
                 cout << "                   Flags: " << memx.flags() << endl;
                 }
             }


@EndNode

@Node "TWiShare" "TWiMUI.guide/TWiShare"
@Next "TWiShareManual"
@Prev "TWiMemX"
@Toc "Hilfsklassen"

TWiShare
--------

     class TWiShare
         {
         public:
             TWiShare();
             TWiShare(const TWiShare &);
             ~TWiShare();
             TWiShare &operator=(const TWiShare &);
             BOOL only() const;
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Exec/Share.h

   Diese Klasse dient zum einfacheren Verwalten von dynamischen
Objekten. Wenn in einer Klasse ein dynamisches Objekt vorkommt (z.B.
ein mit 'new' allokiertes Element) muß dieses dann im Destruktor
ordungsgemäß gelöscht werden. Wenn nun aber durch den
Copy-Konstruktor oder den operator= der Pointer das dynamische Objekt
einer anderen Klasse zugeordnet wurde, so darf das Löschen nur im
Destruktor der letzten Instanz erfolgen. Dieses kann mit diser Klasse
sichergestellt werden indem sie als Basisklasse verwendet wird und im
Destruktor die Methode only() abgeprüft wird.

TWiShare()
     Der Konstruktor initialisiert diese Klasse. Sollte das
     Initialisieren fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiShare(const TWiShare &)
     Dieser Konstruktor merkt sich das von dieser Instanz eine Kopie
     angelegt wurde.

only()
     Diese Methode liefert TRUE zurück wenn diese Instanz die letzte
     ist, die dieses Objekt benutzt. Ansonsten FALSE.

   *Beispiel:*
         .
         .
         class Klasse : protected TWiShare
             {
             private:
                 STRPTR ptr;
             public:
                 Klasse(const STRPTR);
                 Klasse(const Klasse &);
                 ~Klasse();
                 Klasse &operator=(const Klasse &);
             };
     
         Klasse::Klasse(const STRPTR p)
             :   TWiShare(),
                 ptr(new UBYTE(strlen(p)+1))
             {
             if (ptr != NULL)
                 memcpy(ptr,p,strlen(p)+1);
             else
                 throw TWiMemX(strlen(p)+1);
             }
     
         Klasse::Klasse(const Klasse &k)
             :   TWiShare(k),
                 ptr(k.ptr)
             {
             }
     
         Klasse::~Klasse()
             {
             if (only())
                 delete []ptr;
             else
                 ;
             }
     
         Klasse &Klasse::operator=(const Klasse &k)
             {
             if (this != &k)
                 {
                 ptr = k.ptr;
                 TWiShare::operator=(k);
                 }
             else
                 ;
             return(*this);
             }


@EndNode

@Node "TWiShareManual" "TWiMUI.guide/TWiShareManual"
@Next "TWiStr"
@Prev "TWiShare"
@Toc "Hilfsklassen"

TWiShareManual
--------------

     class TWiShareManual
         {
         public:
             TWiShareManual();
             TWiShareManual(const TWiShareManual &);
             ~TWiShareManual();
             TWiShareManual &operator=(const TWiShareManual &);
             VOID reference();
             VOID dereference();
             BOOL only() const;
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Exec/Share.h

   Diese Klasse ist der Klasse *TWiShare* (See @{"TWiShare" Link "TWiShare"}.) sehr
ähnlich. Der Unterschied liegt darin, daß Referenzierungen und
Dereferenzierungen manuell getan werden müßen. Die Verwendung kann
dann sinnvoll sein, wenn die verwaltete Ressource nicht direkt zur
Klasse gehört.

TWiShareManual()
     Der Konstruktor initialisiert diese Klasse. Sollte das
     Initialisieren fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiShareManual(const TWiShareManual &)
     Dieser Konstruktor merkt sich das von dieser Instanz eine Kopie
     angelegt wurde.

reference()
     Diese Methode erhöht den Referenzierungs-Zähler.

dereference()
     Diese Methode verringert den Referenzierungs-Zähler.

only()
     Diese Methode liefert TRUE zurück wenn diese Instanz die letzte
     ist, die dieses Objekt benutzt. Ansonsten FALSE.

   *Beispiel:* See @{"TWiShare" Link "TWiShare"}.


@EndNode

@Node "TWiStr" "TWiMUI.guide/TWiStr"
@Next "TWiTag"
@Prev "TWiShareManual"
@Toc "Hilfsklassen"

TWiStr
------

     class TWiStr
         {
         public:
             TWiStr(const STRPTR);
             TWiStr(const STRPTR, const ULONG);
             TWiStr(const UBYTE);
             TWiStr(const TWiStr &);
             ~TWiStr();
             operator STRPTR() const;
             TWiStr &operator= (const TWiStr &);
             TWiStr &operator= (const STRPTR);
             TWiStr &operator= (const UBYTE);
             TWiStr &operator= (const ULONG);
             TWiStr &operator= (const LONG);
             UBYTE &operator[] (ULONG);
             TWiStr &operator+= (const TWiStr &);
             TWiStr &operator+= (const STRPTR);
             TWiStr &operator+= (UBYTE);
             TWiStr &operator+= (ULONG);
             TWiStr &operator+= (LONG);
             ULONG size() const;
             ULONG length() const;
             TWiStr left(const ULONG) const;
             TWiStr mid(const ULONG, const ULONG) const;
             TWiStr right(const ULONG) const;
             LONG pos(const STRPTR, const ULONG) const;
             VOID cut(const ULONG);
             VOID shrinkBuffer();
             VOID doubleBuffer();
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Datastructures/String.h

   Diese Klasse stellt ein komfortables String-Handling zur Verfügung.

TWiStr(const STRPTR)
     Dieser Konstruktor legt einen Speicherbereich in der Länge des
     angegebenen Strings an und kopiert den angegebenen String hinein.
     Sollte das Anlegen des Bereichs fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen. Der Default ist ein leerer
     String in einem 64 Byte langen Bereich.

TWiStr(const STRPTR, const ULONG)
     Dieser Konstruktor legt einen Speicher in der Länge des zweiten
     Parameters an und kopiert den Inhalt des ersten Parameters hinein.
     In das letzte Byte des Buffer wird ein Null-byte geschrieben damit
     auf jeden fall ein gültiger String entsteht. Sollte das Anlegen
     des Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiStr(const UBYTE)
     Dieser Konstruktor erstellt einen einstelligen String plus
     abschließendes Nullbyte aus dem angegeben UBYTE. Sollte das
     Anlegen des Bereichs fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiStr(const TWiStr &)
     Dieser Konstruktor erstellt eine Kopie der angegebenen Instanz.
     Sollte das Anlegen des Bereichs fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator STRPTR()
     Dieser Operator liefert die Anfangs-Adresse des Strings.

operator=(const TWiStr &)
     Dieser Operator übernimmt den String aus der angegebenen Klasse,
     legt einen eigenen Bereich der entsprechenden Größe an und
     kopiert den String der Parameter-Klasse in seinen eigenen. Sollte
     das Anlegen des Buffers fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const STRPTR)
     Dieser Operator übernimmt den übergebenen String legt einen
     Bereich der entsprechenden Größe an und kopiert den String in
     seinen eigenen. Sollte das Anlegen des Buffers fehlschlagen, so
     wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const UBYTE)
     Dieser Operator übernimmt das übergebene Byte, legt einen
     Bereich der Größe 2 an und kopiert das Byte mit einem
     abschließenden Null-Byte hinein. Sollte das Anlegen des Buffers
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

operator=(const ULONG)
     Dieser Operator übernimmt die übergebene Zahl, wandelt sie um in
     einen String, legt einen speicherbereich der entsprechenden
     Größe an und kopiert den String dort hinein. Sollte das Anlegen
     des Buffers fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const LONG)
     Dieser Operator übernimmt die übergebene Zahl, wandelt sie um in
     einen String, legt einen Speicherbereich der entsprechenden
     Größe an und kopiert den String dort hinein. Sollte das Anlegen
     des Buffers fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator[](ULONG)
     Dieser Operator gibt eine Referenz auf das durch den Parameter
     indizierte Byte zurück. Sollte der Index zu groß sein, so wird
     der Buffer vergrößert. Sollte das Anlegen des Buffers
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

operator+=(const TWiStr &)
     Dieser Operator nimmt den String aus der angegebenen Klasse, und
     hängt diesen an seinen eigenen an. Falls der eigene Bereich zu
     klein ist, wird er vergrößert. Sollte das vergrößern des
     Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator+=(const STRPTR)
     Dieser Operator nimmt den angegebenen String und hängt diesen an
     seinen eigenen an. Falls der eigene Bereich zu klein ist, wird er
     vergrößert. Sollte das Vergrößern des Bereichs fehlschlagen,
     so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator+=(const UBYTE)
     Dieser Operator nimmt das angegebene Byte und hängt dieses an
     seinen eigenen String an. Falls der eigene Bereich zu klein ist,
     wird er vergrößert. Sollte das Vergrößern des Bereichs
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

operator+=(const ULONG)
     Dieser Operator nimmt die angegebene Zahl, wandelt diese um in
     einen String und hängt diesen an seinen eigenen an. Falls der
     eigene Bereich zu klein ist, wird er vergrößert. Sollte das
     Vergrößern des Bereichs fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator+=(const LONG)
     Dieser Operator nimmt die angegebene Zahl, wandelt diese um in
     einen String und hängt diesen an seinen eigenen an. Falls der
     eigene Bereich zu klein ist, wird er vergrößert. Sollte das
     Vergrößern des Bereichs fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

size()
     Diese Methode liefert die Größe des Buffer.

length()
     Diese Methode liefert die Länge des Strings.

left(ULONG)
     Diese Methode liefert eine Instanz der Klasse TWiStr welche den
     linken Teil des Strings enthält. Die Anzahl der gewünschten
     Stellen werden als Parameter übergeben. Sollte das Anlegen des
     Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

mid(ULONG, ULONG)
     Diese Methode liefert eine Instanz der Klasse TWiStr, welche den
     mittleren Teil des Strings enthält. Die Anzahl der gewünschten
     Stellen und der Index der ersten gewünschten Stelle werden als
     Parameter übergeben. Der erste Parameter bezeichnet den Anfang des
     Strings und der Zweite bezeichnet die Länge. Sollte das Anlegen
     des Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

right(ULONG)
     Diese Methode liefert eine Instanz der Klasse TWiStr, welche den
     rechten Teil des Strings enthält. Die Anzahl der gewünschten
     Stellen werden als Parameter übergeben. Sollte das Anlegen des
     Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

pos(const STRPTR, const ULONG)
     Diese Methode liefert den Anfang des Teil-Strings der als erster
     Parameter übergeben wird zurück. Sollte er nicht vorhanden sein,
     so wird -1 zurückgegeben. Die Suche startet an der Position die
     als zweiter Parameter angegeben wird. Der Default ist hier 0.

cut(const ULONG)
     Diese Methode schneidet den String an der angegebenen Stelle ab.
     Die Größe des Buffer wird dadurch nicht verändert. Ist der
     Parameter größer als die String-Länge passiert nichts.

shrinkBuffer()
     Diese Methode setzt die Größe des Bereichs auf die Länge des
     Strings plus das Nullbyte. Sollte das Anlegen des Bereichs
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

doubleBuffer()
     Diese Methode verdoppelt den Bereich. Sollte das Vergößern des
     Bereichs fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

   *Beispiel:*
         .
         .
         TWiStr str1("Das ist ein Test");
         TWiStr str2 = str1.mid(3,4);
         .
         .


@EndNode

@Node "TWiTag" "TWiMUI.guide/TWiTag"
@Next "TWiTagCursor"
@Prev "TWiStr"
@Toc "Hilfsklassen"

TWiTag
------

     class TWiTag
         {
         public:
             TWiTag();
             TWiTag(const Tag, ...);
             TWiTag(const struct TagItem *);
             TWiTag(const TWiTag &);
             ~TWiTag();
             TWiTag &operator= (const TWiTag &);
             struct TagItem *tags() const;
             VOID append(const TWiTag &);
             VOID append(const Tag, ...);
             VOID append(const struct TagItem *);
             VOID set(const TWiTag &tags);
             VOID set(const Tag tag1Type, ...);
             VOID set(const struct TagItem *tags);
             struct TagItem *find(const Tag tagType) const;
             ULONG getData(const Tag tagType, const ULONG defaultData) const;
             ULONG filter(const LONG logic, const Tag tagTypes[]);
             ULONG filter(const LONG logic, const Tag tag1, ... );
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Utility/Tag.h

   Diese Klasse verwaltet ein Array von TagItem-Strukturen.

TWiTag()
     Dieser Konstruktor legt ein leeres Array an.

TWiTag(const Tag, ...)
     Dieser Konstruktor legt ein Array von TagItem-Strukturen an und
     kopiert die angegebene Parameter-Liste dort hinein. Das letzte
     Element der Liste muß TAG_DONE sein. Sollte das Anlegen des
     Arrays fehlschlagen, so wird die Exception *TWiMemX* (See
     @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiTag(const struct TagItem *)
     Dieser Konstruktor legt ein Array von TagItem-Strukturen an und
     kopiert die angegebene TagItem-Liste dort hinein. Sollte das
     Anlegen des Arrays fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

TWiTag(const TWiTag &)
     Dieser Konstruktor erstellt eine Kopie der angegebenen Instanz.
     Sollte das Anlegen des Arrays fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

operator=(const TWiTag &)
     Dieser Konstruktor gibt sein eigenes Array frei und erstellt eine
     Kopie der angegebenen Instanz. Sollte das Anlegen des Arrays
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

tags()
     Diese Methode liefert die Adresse des Array.

append(const struct TagItem *)
     Diese Methode hängt die angegebene Liste an das eigene Array an.
     Sollte das Vergrößern des Arrays fehlschlagen, so wird die
     Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

append(const Tag, ...)
     Diese Methode hängt die angegebene Parameter-Liste an das eigene
     Array an. Das letzte Element der Liste muß TAG_DONE sein. Sollte
     das Vergrößern des Arrays fehlschlagen, so wird die Exception
     *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

append(const TWiTag &)
     Diese Methode hängt die angegebene Instanz an das eigene Array an.
     Sollte das Vergrößern des Arrays fehlschlagen, so wird die
     Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

set(const struct TagItem *)
     Diese Methode mischt die übergebene Tag-Liste in die eigene
     Tag-Liste ein. Wenn in der Parameter-Liste ein Tag-Wert steht, der
     auch in der eigenen Liste vorhanden ist, so wird der Data-Wert
     dieses Tags überschrieben. Tags, die in der eigenen Liste nicht
     vorhanden sind, werden angehängt. Sollte das Anhängen des Arrays
     fehlschlagen, so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.)
     ausgeworfen.

set(const Tag, ...)
     Diese Methode mischt die übergebene Tag-Liste in die eigene
     Tag-Liste ein. Wenn in der Parameter-Liste ein Tag-Wert steht, der
     auch in der eigenen Liste vorhanden ist, so wird der Data-Wert
     dieses Tags überschrieben. Tags, die in der eigenen Liste nicht
     vorhanden sind, werden angehängt. Das letzte Element der Liste
     muß TAG_DONE sein. Sollte das Anhängen des Arrays fehlschlagen,
     so wird die Exception *TWiMemX* (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

set(const TWiTag &)
     Diese Methode mischt die Tag-Liste der übergebenen Instanz in die
     eigene Tag-Liste ein. Wenn in der Parameter-Instanz ein Tag-Wert
     steht, der auch in der eigenen Liste vorhanden ist, so wird der
     Data-Wert dieses Tags überschrieben. Tags, die in der eigenen
     Liste nicht vorhanden sind, werden angehängt. Sollte das
     Anhängen des Arrays fehlschlagen, so wird die Exception *TWiMemX*
     (See @{"TWiMemX" Link "TWiMemX"}.) ausgeworfen.

find(const Tag)
     Diese Methode ruft die Amiga-Utility-Funktion FindTagItem() mit dem
     angegebenen Parameter auf und gibt deren Wert zurück.

getData(const Tag, const ULONG)
     Diese Methode ruft die Amiga-Utility-Funktion GetTagData() mit den
     angegebenen Parametern auf und gibt deren Wert zurück.

filter(const LONG, const Tag)
     Diese Methode ruft die Amiga-Utility-Funktion FilterTagItems() mit
     den angegebenen Parametern auf und gibt deren Wert zurück.

   *Beispiel:*
         .
         .
         .
         TWiTag tag(MUIA_Window_Activate, TRUE, TAG_DONE);
         tag.append(MUIA_WINDOW_Open, TRUE, TAG_DONE);
         .
         .
         .


@EndNode

@Node "TWiTagCursor" "TWiMUI.guide/TWiTagCursor"
@Prev "TWiTag"
@Toc "Hilfsklassen"

TWiTagCursor
------------

     class TWiTagCursor
         {
         public:
             TWiTagCursor(const TWiTag &);
             TWiTagCursor(const struct TagItem *);
             ~TWiTagCursor();
             BOOL isDone();
             VOID first();
             VOID next();
             struct TagItem *item() const;
             Tag itemTag() const;
             ULONG itemData() const;
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/Utility/Tag.h

   Diese Klasse realisiert einen Cursor, um damit komfortabel Schleifen
über Instanzen der Klasse *TWiTag* (See @{"TWiTag" Link "TWiTag"}.) oder auch über
herkömmlich erstellte TagItem-Listen definieren zu können.

TWiTagCursor(const TWiTag &)
     Dieser Konstruktor initialisiert den Cursor für das Array für
     das eine Referenz übergeben wird.

TWiTagCursor(const struct TagItem *)
     Dieser Konstruktor initialisiert den Cursor für die TagItem-Liste,
     deren Adresse übergeben wird.

isDone()
     Diese Methode liefert FALSE, wenn der Cursor auf ein gültiges
     Element zeigt und TRUE, wenn der Cursor aus den Bounds geraten ist.

first()
     Diese Methode setzt den Cursor auf das erste Element.

next()
     Diese Methode setzt den Cursor auf das nächste Element.

item()
     Diese Methode liefert die Adresse des aktuellen Elements, auf das
     der Cursor gerade zeigt.

itemTag()
     Diese Methode liefert die ti_Tag-Wert des aktuellen Elements, auf
     das der Cursor gerade zeigt.

itemData()
     Diese Methode liefert die ti_Data-Wert des aktuellen Elements, auf
     das der Cursor gerade zeigt.

   *Beispiel:*
         .
         .
         .
         TWiTag tag(MUIA_Window_Activate, TRUE, TAG_DONE);
         tag.append(MUIA_WINDOW_Open, TRUE, TAG_DONE);
         TWiTagcursor tc(tag);
         for (tc.first()  ;  !tc.isDone()  ;  tc.next())
             {
             if (tc.itemTag() = MUIA_Window_Open)
             .
             .
             .
             }
         .
         .
         .


@EndNode

@Node "MUI-Basisklassen" "TWiMUI.guide/MUI-Basisklassen"
@Next "MUI-Klassen"
@Prev "Hilfsklassen"
@Toc "Klassen"

MUI-Basisklassen
================

   Hier werden jetzt alle MUI-Basisklassen beschrieben. Diese Klassen
werden zur eigenen Programm-Entwicklung normalerweise nicht benötigt.
Sie werden hier deshalb beschrieben, da einzelne Methoden eventuell
überladen werden sollten.


 @{" MUIApplicationBrokerHook " Link "MUIApplicationBrokerHook"}  Hilfe für BrokerHook in einer Application
 @{" MUIApplicationRexxHook " Link "MUIApplicationRexxHook"}    Hilfe für RexxHook in einer Application
 @{" MUIDirlistFilterHook " Link "MUIDirlistFilterHook"}      Hilfe für FilterHook in einer Dirlist
 @{" MUIGroupLayoutHook " Link "MUIGroupLayoutHook"}        Hilfe für LayoutHook in einer Group
 @{" MUIListCompareHook " Link "MUIListCompareHook"}        Hilfe für CompareHook in einer List
 @{" MUIListConstructHook " Link "MUIListConstructHook"}      Hilfe für ConstructHook in einer List
 @{" MUIListDestructHook " Link "MUIListDestructHook"}       Hilfe für DestructHook in einer List
 @{" MUIListDisplayHook " Link "MUIListDisplayHook"}        Hilfe für DisplayHook in einer List
 @{" MUIListMultiTestHook " Link "MUIListMultiTestHook"}      Hilfe für MultiTestHook in einer List
 @{" MUIPopaslStartHook " Link "MUIPopaslStartHook"}        Hilfe für StartHook in einem Popasl
 @{" MUIPopaslStopHook " Link "MUIPopaslStopHook"}         Hilfe für StopHook in einem Popasl
 @{" MUIPopobjectObjStrHook " Link "MUIPopobjectObjStrHook"}    Hilfe für ObjStrHook in einem Popobject
 @{" MUIPopobjectStrObjHook " Link "MUIPopobjectStrObjHook"}    Hilfe für StrObjHook in einem Popobject
 @{" MUIPopobjectWindowHook " Link "MUIPopobjectWindowHook"}    Hilfe für WindowHook in einem Popobject
 @{" MUIPopstringCloseHook " Link "MUIPopstringCloseHook"}     Hilfe für CloseHook in einem Popstring
 @{" MUIPopstringOpenHook " Link "MUIPopstringOpenHook"}      Hilfe für OpenHook in einem Popstring
 @{" MUIStringEditHook " Link "MUIStringEditHook"}         Hilfe für EditHook in einem String

 @{" MUILabelHelp " Link "MUILabelHelp"}              Hilfe für Label mit Control-Character

 @{" MUIErrorX " Link "MUIErrorX"}                 Exception-Klasse


@EndNode

@Node "MUIApplicationBrokerHook" "TWiMUI.guide/MUIApplicationBrokerHook"
@Next "MUIApplicationRexxHook"
@Toc "MUI-Basisklassen"

MUIApplicationBrokerHook
------------------------

     class MUIApplicationBrokerHook
         {
         private:
             struct Hook brokerhook;
             static VOID BrokerHookEntry(register __a0 struct Hook *,
                                         register __a2 Object *,
                                         register __a1 CxMsg *);
             virtual VOID BrokerHookFunc(struct Hook *,
                                         Object *,
                                         CxMsg *);
         protected:
             MUIApplicationBrokerHook();
             MUIApplicationBrokerHook(const MUIApplicationBrokerHook &);
             ~MUIApplicationBrokerHook();
             MUIApplicationBrokerHook &operator=
                 (const MUIApplicationBrokerHook &);
         public:
             struct Hook *broker();
         };

abgeleitete Klassen:
     MUIApplication (See @{"MUIApplication" Link "MUIApplication"}.)

Include-File:
     classes/TWiMUI/Application.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen BrokerHook in einer Application zu definieren. Dazu
gibt man in dem Tag *MUIA_Application_BrokerHook* einfach den
Return-Wert der Methode *broker()* an und überlädt die Methode
*BrokerHookFunc()*.

   *Beispiel:*
     class App : public MUIApplication
         {
         private:
             virtual VOID BrokerHookFunc(struct Hook *,
                                         Object *,
                                         CxMsg *);
         public:
             App(MUIA_Application_Title, "???",
                 MUIA_Application_Version, "$VER: ????",
                 MUIA_Application_BrokerHook, broker(),
                 TAG_DONE);
                 { };
             ~App() { };
         };
     
     VOID App::BrokerHookFunc(struct Hook *h,
                              Object *o,
                              CxMsg *m)
         {
         eigener Code.
         };


@EndNode

@Node "MUIApplicationRexxHook" "TWiMUI.guide/MUIApplicationRexxHook"
@Next "MUIDirlistFilterHook"
@Prev "MUIApplicationBrokerHook"
@Toc "MUI-Basisklassen"

MUIApplicationRexxHook
----------------------

     class MUIApplicationRexxHook
         {
         private:
             struct Hook rexxhook;
             static ULONG RexxHookEntry(register __a0 struct Hook *,
                                        register __a2 Object *,
                                        register __a1 struct RexxMsg *);
             virtual ULONG RexxHookFunc(struct Hook *,
                                        Object *,
                                        struct RexxMsg *);
         protected:
             MUIApplicationRexxHook();
             MUIApplicationRexxHook(const MUIApplicationRexxHook &);
             ~MUIApplicationRexxHook();
             MUIApplicationRexxHook &operator= (const MUIApplicationRexxHook &);
         public:
             struct Hook *rexx();
         };

abgeleitete Klassen:
     MUIApplication (See @{"MUIApplication" Link "MUIApplication"}.)

Include-File:
     classes/TWiMUI/Application.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen RexxHook in einer Application zu definieren. Dazu
gibt man in dem Tag *MUIA_Application_RexxHook* einfach den Return-Wert
der Methode *rexx()* an und überlädt die Methode *RexxHookFunc()*.

   *Beispiel:*
     class App : public MUIApplication
         {
         private:
             virtual ULONG RexxHookFunc(struct Hook *,
                                        Object *,
                                        struct RexxMsg *);
         public:
             App(MUIA_Application_Title, "???",
                 MUIA_Application_Version, "$VER: ????",
                 MUIA_Application_RexxHook, rexx(),
                 TAG_DONE);
                 { };
             ~App() { };
         };
     
     ULONG App::RexxHookFunc(struct Hook *h,
                             Object *o,
                             struct RexxMsg *m)
         {
         eigener Code.
         };


@EndNode

@Node "MUIDirlistFilterHook" "TWiMUI.guide/MUIDirlistFilterHook"
@Next "MUIGroupLayoutHook"
@Prev "MUIApplicationRexxHook"
@Toc "MUI-Basisklassen"

MUIDirlistFilterHook
--------------------

     class MUIDirlistFilterHook
         {
         private:
             struct Hook filterhook;
             static ULONG FilterHookEntry(register __a0 struct Hook *,
                                          register __a2 Object *,
                                          register __a1 struct ExAllData *);
             virtual ULONG FilterHookFunc(struct Hook *,
                                          Object *,
                                          struct ExAllData *);
         protected:
             MUIDirlistFilterHook();
             MUIDirlistFilterHook(const MUIDirlistFilterHook &);
             ~MUIDirlistFilterHook();
             MUIDirlistFilterHook &operator= (const MUIDirlistFilterHook &);
         public:
             struct Hook *filter();
         };

abgeleitete Klassen:
     MUIDirlist (See @{"MUIDirlist" Link "MUIDirlist"}.)

Include-File:
     classes/TWiMUI/Dirlist.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen FilterHook in einer Dirlist zu definieren. Dazu
gibt man in dem Tag *MUIA_Dirlist_FilterHook* einfach den Return-Wert
der Methode *filter()* an und überlädt die Methode *FilterHookFunc()*.

   *Beispiel:*
     class Dir : public MUIDirlist
         {
         private:
             virtual ULONG FilterHookFunc(struct Hook *,
                                          Object *,
                                          struct ExAllData *);
         public:
             Dir(MUIA_Dirlist_Directory, "RAM:",
                 MUIA_Dirlist_FilterHook, filter(),
                 TAG_DONE);
                 { };
             ~Dir() { };
         };
     
     ULONG Dir::FilterHookFunc(struct Hook *h,
                               Object *o,
                               struct ExAllData *d)
         {
         eigener Code.
         };


@EndNode

@Node "MUIGroupLayoutHook" "TWiMUI.guide/MUIGroupLayoutHook"
@Next "MUIListCompareHook"
@Prev "MUIDirlistFilterHook"
@Toc "MUI-Basisklassen"

MUIGroupLayoutHook
------------------

     class MUIGroupLayoutHook
         {
         private:
             struct Hook layouthook;
             static ULONG LayoutHookEntry(register __a0 struct Hook *,
                                          register __a2 Object *,
                                          register __a1 struct MUI_LayoutMsg *);
             virtual ULONG LayoutHookFunc(struct Hook *,
                                          Object *,
                                          struct MUI_LayoutMsg *);
         protected:
             MUIGroupLayoutHook();
             MUIGroupLayoutHook(const MUIGroupLayoutHook &);
             ~MUIGroupLayoutHook();
             MUIGroupLayoutHook &operator= (const MUIGroupLayoutHook &);
         public:
             struct Hook *layout();
         };

abgeleitete Klassen:
     MUIGroup (See @{"MUIGroup" Link "MUIGroup"}.)

Include-File:
     classes/TWiMUI/Group.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen LayoutHook in einer Group zu definieren. Dazu gibt
man in dem Tag *MUIA_Group_LayoutHook* einfach den Return-Wert der
Methode *layout()* an und überlädt die Methode *LayoutHookFunc()*.

   *Beispiel:*
     class Grp : public MUIGroup
         {
         private:
             virtual ULONG LayoutHookFunc(struct Hook *,
                                          Object *,
                                          struct MUI_LayoutMsg *);
         public:
             Grp(MUIA_Group_Horiz, TRUE,
                 MUIA_Group_LayoutHook, layout(),
                 TAG_DONE);
                 { };
             ~Grp() { };
         };
     
     ULONG Grp::LayoutHookFunc(struct Hook *h,
                               Object *o,
                               struct MUI_LayoutMsg *m)
         {
         eigener Code.
         };


@EndNode

@Node "MUIListCompareHook" "TWiMUI.guide/MUIListCompareHook"
@Next "MUIListConstructHook"
@Prev "MUIGroupLayoutHook"
@Toc "MUI-Basisklassen"

MUIListCompareHook
------------------

     class MUIListCompareHook
         {
         private:
             struct Hook comparehook;
             static LONG CompareHookEntry(register __a0 struct Hook *,
                                          register __a2 APTR,
                                          register __a1 APTR);
             virtual LONG CompareHookFunc(struct Hook *,
                                          APTR,
                                          APTR);
         protected:
             MUIListCompareHook();
             MUIListCompareHook(const MUIListCompareHook &);
             ~MUIListCompareHook();
             MUIListCompareHook &operator= (const MUIListCompareHook &);
         public:
             struct Hook *compare();
         };

abgeleitete Klassen:
     MUIList (See @{"MUIList" Link "MUIList"}.)

Include-File:
     classes/TWiMUI/List.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen CompareHook in einer List zu definieren. Dazu gibt
man in dem Tag *MUIA_List_CompareHook* einfach den Return-Wert der
Methode *compare()* an und überlädt die Methode *CompareHookFunc()*.

   *Beispiel:*
     class Lst : public MUIList
         {
         private:
             virtual LONG CompareHookFunc(struct Hook *,
                                          APTR,
                                          APTR);
         public:
             Lst(ReadListFrame,
                 MUIA_List_CompareHook, compare(),
                 TAG_DONE);
                 { };
             ~Lst() { };
         };
     
     LONG Lst::CompareHookFunc(struct Hook *h,
                               APTR e1,
                               APTR e2)
         {
         eigener Code.
         };


@EndNode

@Node "MUIListConstructHook" "TWiMUI.guide/MUIListConstructHook"
@Next "MUIListDestructHook"
@Prev "MUIListCompareHook"
@Toc "MUI-Basisklassen"

MUIListConstructHook
--------------------

     class MUIListConstructHook
         {
         private:
             struct Hook constructhook;
             static APTR ConstructHookEntry(register __a0 struct Hook *,
                                            register __a2 APTR,
                                            register __a1 APTR);
             virtual APTR ConstructHookFunc(struct Hook *,
                                            APTR,
                                            APTR);
         protected:
             MUIListConstructHook();
             MUIListConstructHook(const MUIListConstructHook &);
             ~MUIListConstructHook();
             MUIListConstructHook &operator= (const MUIListConstructHook &);
         public:
             struct Hook *construct();
         };

abgeleitete Klassen:
     MUIList (See @{"MUIList" Link "MUIList"}.)

Include-File:
     classes/TWiMUI/List.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen ConstructHook in einer List zu definieren. Dazu
gibt man in dem Tag *MUIA_List_ConstructHook* einfach den Return-Wert
der Methode *construct()* an und überlädt die Methode
*ConstructHookFunc()*.

   *Beispiel:*
     class Lst : public MUIList
         {
         private:
             virtual APTR ConstructHookFunc(struct Hook *,
                                            APTR,
                                            APTR);
         public:
             Lst(ReadListFrame,
                 MUIA_List_ConstructHook, construct(),
                 TAG_DONE);
                 { };
             ~Lst() { };
         };
     
     APTR Lst::ConstructHookFunc(struct Hook *h,
                                 APTR p,
                                 APTR e)
         {
         eigener Code.
         };


@EndNode

@Node "MUIListDestructHook" "TWiMUI.guide/MUIListDestructHook"
@Next "MUIListDisplayHook"
@Prev "MUIListConstructHook"
@Toc "MUI-Basisklassen"

MUIListDestructHook
-------------------

     class MUIListDestructHook
         {
         private:
             struct Hook destructhook;
             static VOID DestructHookEntry(register __a0 struct Hook *,
                                           register __a2 APTR,
                                           register __a1 APTR);
             virtual VOID DestructHookFunc(struct Hook *,
                                           APTR,
                                           APTR);
         protected:
             MUIListDestructHook();
             MUIListDestructHook(const MUIListDestructHook &);
             ~MUIListDestructHook();
             MUIListDetructHook &operator= (const MUIListDestructHook &);
         public:
             struct Hook *destruct();
         };

abgeleitete Klassen:
     MUIList (See @{"MUIList" Link "MUIList"}.)

Include-File:
     classes/TWiMUI/List.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen DestructHook in einer List zu definieren. Dazu gibt
man in dem Tag *MUIA_List_DestructHook* einfach den Return-Wert der
Methode *destruct()* an und überlädt die Methode *DestructHookFunc()*.

   *Beispiel:*
     class Lst : public MUIList
         {
         private:
             virtual VOID DestructHookFunc(struct Hook *,
                                           APTR,
                                           APTR);
         public:
             Lst(ReadListFrame,
                 MUIA_List_DestructHook, destruct(),
                 TAG_DONE);
                 { };
             ~Lst() { };
         };
     
     VOID Lst::DestructHookFunc(struct Hook *h,
                                APTR p,
                                APTR e)
         {
         eigener Code.
         };


@EndNode

@Node "MUIListDisplayHook" "TWiMUI.guide/MUIListDisplayHook"
@Next "MUIListMultiTestHook"
@Prev "MUIListDestructHook"
@Toc "MUI-Basisklassen"

MUIListDisplayHook
------------------

     class MUIListDisplayHook
         {
         private:
             struct Hook displayhook;
             static VOID DisplayHookEntry(register __a0 struct Hook *,
                                          register __a2 STRPTR *,
                                          register __a1 APTR);
             virtual VOID DisplayHookFunc(struct Hook *,
                                          STRPTR *,
                                          APTR);
         protected:
             MUIListDisplayHook();
             MUIListDisplayHook(const MUIListDisplayHook &);
             ~MUIListDisplayHook();
             MUIListDisplayHook &operator= (const MUIListDisplayHook &);
         public:
             struct Hook *display();
         };

abgeleitete Klassen:
     MUIList (See @{"MUIList" Link "MUIList"}.)

Include-File:
     classes/TWiMUI/List.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen DisplayHook in einer List zu definieren. Dazu gibt
man in dem Tag *MUIA_List_DisplayHook* einfach den Return-Wert der
Methode *display()* an und überlädt die Methode *DisplayHookFunc()*.

   *Beispiel:*
     class Lst : public MUIList
         {
         private:
             virtual VOID DisplayHookFunc(struct Hook *,
                                          STRPTR *,
                                          APTR);
         public:
             Lst(ReadListFrame,
                 MUIA_List_DisplayHook, display(),
                 TAG_DONE);
                 { };
             ~Lst() { };
         };
     
     VOID Lst::DisplayHookFunc(struct Hook *h,
                               STRPTR *a,
                               APTR e)
         {
         eigener Code.
         };


@EndNode

@Node "MUIListMultiTestHook" "TWiMUI.guide/MUIListMultiTestHook"
@Next "MUIPopaslStartHook"
@Prev "MUIListDisplayHook"
@Toc "MUI-Basisklassen"

MUIListMultiTestHook
--------------------

     class MUIListMultiTestHook
         {
         private:
             struct Hook multitesthook;
             static BOOL MultiTestHookEntry(register __a0 struct Hook *,
                                            register __a1 APTR);
             virtual BOOL MultitestHookFunc(struct Hook *,
                                            APTR);
         protected:
             MUIListMultiTestHook();
             MUIListMultiTestHook(const MUIListMultiTestHook &);
             ~MUIListMultiTestHook();
             MUIListMultiTestHook &operator= (const MUIListMultiTestHook &);
         public:
             struct Hook *multitest();
         };

abgeleitete Klassen:
     MUIList (See @{"MUIList" Link "MUIList"}.)

Include-File:
     classes/TWiMUI/List.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen MultiTestHook in einer List zu definieren. Dazu
gibt man in dem Tag *MUIA_List_MultiTestHook* einfach den Return-Wert
der Methode *multitest()* an und überlädt die Methode
*MultiTestHookFunc()*.

   *Beispiel:*
     class Lst : public MUIList
         {
         private:
             virtual BOOL MultiTestHookFunc(struct Hook *,
                                            APTR);
         public:
             Lst(ReadListFrame,
                 MUIA_List_MultiTestHook, multitest(),
                 TAG_DONE);
                 { };
             ~Lst() { };
         };
     
     BOOL Lst::MultiTestHookFunc(struct Hook *h,
                                 APTR e)
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopaslStartHook" "TWiMUI.guide/MUIPopaslStartHook"
@Next "MUIPopaslStopHook"
@Prev "MUIListMultiTestHook"
@Toc "MUI-Basisklassen"

MUIPopaslStartHook
------------------

     class MUIPopaslStartHook
         {
         private:
             struct Hook starthook;
             static BOOL StartHookEntry(register __a0 struct Hook *,
                                        register __a2 Object *,
                                        register __a1 struct TagItem *);
             virtual BOOL StartHookFunc(struct Hook *,
                                        Object *,
                                        struct TagItem *);
         protected:
             MUIPopaslStartHook();
             MUIPopaslStartHook(const MUIPopaslStartHook &);
             ~MUIPopaslStartHook();
             MUIPopaslStartHook &operator= (const MUIPopaslStartHook &);
         public:
             struct Hook *start();
         };

abgeleitete Klassen:
     MUIPopasl (See @{"MUIPopasl" Link "MUIPopasl"}.)

Include-File:
     classes/TWiMUI/Popasl.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen StartHook in einem Popasl zu definieren. Dazu gibt
man in dem Tag *MUIA_Popasl_StartHook* einfach den Return-Wert der
Methode *start()* an und überlädt die Methode *StartHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopasl
         {
         private:
             virtual BOOL StartHookFunc(struct Hook *,
                                        Object *,
                                        struct TagItem *);
         public:
             Pop(MUIA_Popasl_Type, ASL_FileRequest,
                 MUIA_Popasl_StartHook, start(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     BOOL Pop::StartHookFunc(struct Hook *h,
                             Object *o,
                             struct TagItem *t);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopaslStopHook" "TWiMUI.guide/MUIPopaslStopHook"
@Next "MUIPopobjectObjStrHook"
@Prev "MUIPopaslStartHook"
@Toc "MUI-Basisklassen"

MUIPopaslStopHook
-----------------

     class MUIPopaslStopHook
         {
         private:
             struct Hook stophookFile;
             struct Hook stophookFont;
             struct Hook stophookScreenMode;
             static VOID StopHookEntryFile(register __a0 struct Hook *,
                                           register __a2 Object *,
                                           register __a1 struct FileRequester *);
             static VOID StopHookEntryFont(register __a0 struct Hook *,
                                           register __a2 Object *,
                                           register __a1 struct FontRequester *);
             static VOID StopHookEntryScreenMode(register __a0 struct Hook *,
                                     register __a2 Object *,
                                     register __a1 struct ScreenModeRequester *);
             virtual VOID StopHookFuncFile(struct Hook *,
                                           Object *,
                                           struct FileRequester *);
             virtual VOID StopHookFuncFont(struct Hook *,
                                           Object *,
                                           struct FontRequester *);
             virtual VOID StopHookFuncScreenMode(struct Hook *,
                                                 Object *,
                                                 struct ScreenModeRequester *);
         protected:
             MUIPopaslStopHook();
             MUIPopaslStopHook(const MUIPopaslStopHook &);
             ~MUIPopaslStopHook();
             MUIPopaslStopHook &operator= (const MUIPopaslStopHook &);
         public:
             struct Hook *stopFile();
             struct Hook *stopFont();
             struct Hook *stopScreenMode();
         };

abgeleitete Klassen:
     MUIPopasl (See @{"MUIPopasl" Link "MUIPopasl"}.)

Include-File:
     classes/TWiMUI/Popasl.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen StopHook in einem Popasl zu definieren. Dazu gibt
man in dem Tag *MUIA_Popasl_StopHook* einfach den Return-Wert einer der
Methoden *stopFile()*, *stopFont()* oder *stopScreenMode()* an und
überlädt die Methode *StopHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopasl
         {
         private:
             virtual VOID StopHookFunc(struct Hook *,
                                       Object *,
                                       struct FileRequester *);
         public:
             Pop(MUIA_Popasl_Type, ASL_FileRequest,
                 MUIA_Popasl_StopHook, stopFile(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     VOID Pop::StopHookFunc(struct Hook *h,
                             Object *o,
                             struct FileRequester *f);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopobjectObjStrHook" "TWiMUI.guide/MUIPopobjectObjStrHook"
@Next "MUIPopobjectStrObjHook"
@Prev "MUIPopaslStopHook"
@Toc "MUI-Basisklassen"

MUIPopobjectObjStrHook
----------------------

     class MUIPopobjectObjStrHook
         {
         private:
             struct Hook objstrhook;
             static VOID ObjStrHookEntry(register __a0 struct Hook *,
                                         register __a2 Object *,
                                         register __a1 Object *);
             virtual VOID ObjStrHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         protected:
             MUIPopobjectObjStrHook();
             MUIPopobjectObjStrHook(const MUIPopobjectObjStrHook &);
             ~MUIPopobjectObjStrHook();
             MUIPopobjectObjStrHook &operator= (const MUIPopobjectObjStrHook &);
         public:
             struct Hook *objstr();
         };

abgeleitete Klassen:
     MUIPopobject (See @{"MUIPopobject" Link "MUIPopobject"}.)

Include-File:
     classes/TWiMUI/Popobject.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen ObjStrHook in einem Popobject zu definieren. Dazu
gibt man in dem Tag *MUIA_Popobject_ObjStrHook* einfach den Return-Wert
der Methode *ObjStr()* an und überlädt die Methode *ObjStrHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopobject
         {
         private:
             virtual VOID ObjStrHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         public:
             Pop(MUIA_Popobject_Object, obj,
                 MUIA_Popobject_ObjStrHook, objstr(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     VOID Pop::ObjStrHookFunc(struct Hook *h,
                              Object *o,
                              Object *str);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopobjectStrObjHook" "TWiMUI.guide/MUIPopobjectStrObjHook"
@Next "MUIPopobjectWindowHook"
@Prev "MUIPopobjectObjStrHook"
@Toc "MUI-Basisklassen"

MUIPopobjectStrObjHook
----------------------

     class MUIPopobjectStrObjHook
         {
         private:
             struct Hook strobjhook;
             static BOOL StrObjHookEntry(register __a0 struct Hook *,
                                         register __a2 Object *,
                                         register __a1 Object *);
             virtual BOOL StrObjHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         protected:
             MUIPopobjectStrObjHook();
             MUIPopobjectStrObjHook(const MUIPopobjectStrObjHook &);
             ~MUIPopobjectStrObjHook();
             MUIPopobjectStrObjHook &operator= (const MUIPopobjectStrObjHook &);
         public:
             struct Hook *strobj();
         };

abgeleitete Klassen:
     MUIPopobject (See @{"MUIPopobject" Link "MUIPopobject"}.)

Include-File:
     classes/TWiMUI/Popobject.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen StrObjHook in einem Popobject zu definieren. Dazu
gibt man in dem Tag *MUIA_Popobject_StrObjHook* einfach den Return-Wert
der Methode *strobj()* an und überlädt die Methode *StrObjHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopobject
         {
         private:
             virtual BOOL StrObjHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         public:
             Pop(MUIA_Popobject_Object, obj,
                 MUIA_Popobject_StrObjHook, strobj(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     BOOL Pop::StrObjHookFunc(struct Hook *h,
                              Object *o,
                              Object *str);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopobjectWindowHook" "TWiMUI.guide/MUIPopobjectWindowHook"
@Next "MUIPopstringCloseHook"
@Prev "MUIPopobjectStrObjHook"
@Toc "MUI-Basisklassen"

MUIPopobjectWindowHook
----------------------

     class MUIPopobjectWindowHook
         {
         private:
             struct Hook windowhook;
             static VOID WindowHookEntry(register __a0 struct Hook *,
                                         register __a2 Object *,
                                         register __a1 Object *);
             virtual VOID WindowHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         protected:
             MUIPopobjectWindowHook();
             MUIPopobjectWindowHook(const MUIPopobjectWindowHook &);
             ~MUIPopobjectWindowHook();
             MUIPopobjectWindowHook &operator= (const MUIPopobjectWindowHook &);
         public:
             struct Hook *window();
         };

abgeleitete Klassen:
     MUIPopobject (See @{"MUIPopobject" Link "MUIPopobject"}.)

Include-File:
     classes/TWiMUI/Popobject.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen WindowHook in einem Popobject zu definieren. Dazu
gibt man in dem Tag *MUIA_Popobject_WindowHook* einfach den Return-Wert
der Methode *window()* an und überlädt die Methode *WindowHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopobject
         {
         private:
             virtual VOID WindowHookFunc(struct Hook *,
                                         Object *,
                                         Object *);
         public:
             Pop(MUIA_Popobject_Object, obj,
                 MUIA_Popobject_WindowHook, window(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     VOID Pop::WindowHookFunc(struct Hook *h,
                              Object *o,
                              Object *win);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopstringCloseHook" "TWiMUI.guide/MUIPopstringCloseHook"
@Next "MUIPopstringOpenHook"
@Prev "MUIPopobjectWindowHook"
@Toc "MUI-Basisklassen"

MUIPopstringCloseHook
---------------------

     class MUIPopstringCloseHook
         {
         private:
             struct MUI_Popstring_CloseHook { Object *str; LONG success; };
             struct Hook closehook;
             static VOID CloseHookEntry(register __a0 struct Hook *,
                            register __a2 Object *,
                            register __a1 struct MUI_Popstring_CloseHook *);
             virtual VOID CloseHookFunc(struct Hook *,
                                        Object *,
                                        struct MUI_Popstring_CloseHook *);
         protected:
             MUIPopstringCloseHook();
             MUIPopstringCloseHook(const MUIPopstringCloseHook &);
             ~MUIPopstringCloseHook();
             MUIPopstringCloseHook &operator= (const MUIPopstringCloseHook &);
         public:
             struct Hook *close();
         };

abgeleitete Klassen:
     MUIPopstring (See @{"MUIPopstring" Link "MUIPopstring"}.)

Include-File:
     classes/TWiMUI/Popstring.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen CloseHook in einem Popstring zu definieren. Dazu
gibt man in dem Tag *MUIA_Popstring_CloseHook* einfach den Return-Wert
der Methode *close()* an und überlädt die Methode *CloseHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopstring
         {
         private:
             virtual VOID CloseHookFunc(struct Hook *,
                                         Object *,
                                         struct MUI_Popstring_CloseHook *);
         public:
             Pop(MUIA_Popstring_String, strobj,
                 MUIA_Popstring_Button, butobj,
                 MUIA_Popstring_CloseHook, close(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     VOID Pop::CloseHookFunc(struct Hook *h,
                             Object *o,
                             struct MUI_Popstring_CloseHook *c);
         {
         eigener Code.
         };


@EndNode

@Node "MUIPopstringOpenHook" "TWiMUI.guide/MUIPopstringOpenHook"
@Next "MUIStringEditHook"
@Prev "MUIPopstringCloseHook"
@Toc "MUI-Basisklassen"

MUIPopstringOpenHook
--------------------

     class MUIPopstringOpenHook
         {
         private:
             struct Hook openhook;
             static BOOL OpenHookEntry(register __a0 struct Hook *,
                                       register __a2 Object *,
                                       register __a1 Object **);
             virtual BOOL OpenHookFunc(struct Hook *,
                                       Object *,
                                       Object **);
         protected:
             MUIPopstringOpenHook();
             MUIPopstringOpenHook(const MUIPopstringOpenHook &);
             ~MUIPopstringOpenHook();
             MUIPopstringOpenHook &operator= (const MUIPopstringOpenHook &);
         public:
             struct Hook *open();
         };

abgeleitete Klassen:
     MUIPopstring (See @{"MUIPopstring" Link "MUIPopstring"}.)

Include-File:
     classes/TWiMUI/Popstring.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen OpenHook in einem Popstring zu definieren. Dazu
gibt man in dem Tag *MUIA_Popstring_OpenHook* einfach den Return-Wert
der Methode *open()* an und überlädt die Methode *OpenHookFunc()*.

   *Beispiel:*
     class Pop : public MUIPopstring
         {
         private:
             virtual BOOL OpenHookFunc(struct Hook *,
                                       Object *,
                                       Object **);
         public:
             Pop(MUIA_Popstring_String, strobj,
                 MUIA_Popstring_Button, butobj,
                 MUIA_Popstring_OpenHook, open(),
                 TAG_DONE);
                 { };
             ~Pop() { };
         };
     
     BOOL Pop::OpenHookFunc(struct Hook *h,
                            Object *o,
                            Object **str);
         {
         eigener Code.
         };


@EndNode

@Node "MUIStringEditHook" "TWiMUI.guide/MUIStringEditHook"
@Next "MUILabelHelp"
@Prev "MUIPopstringOpenHook"
@Toc "MUI-Basisklassen"

MUIStringEditHook
-----------------

     class MUIStringEditHook
         {
         private:
             struct Hook edithook;
             static VOID EditHookEntry(register __a0 struct Hook *,
                                       register __a2 struct SGWork *,
                                       register __a1 Msg);
             virtual VOID EditHookFunc(struct Hook *,
                                       struct SGWork *,
                                       Msg);
         protected:
             MUIStringEditHook();
             MUIStringEditHook(const MUIStringEditHook &);
             ~MUIStringEditHook();
             MUIStringEditHook &operator= (const MUIStringEditHook &);
         public:
             struct Hook *edit();
         };

abgeleitete Klassen:
     MUIString (See @{"MUIString" Link "MUIString"}.)

Include-File:
     classes/TWiMUI/String.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, auf einfache
Art und Weise einen EditHook in einem String zu definieren. Dazu gibt
man in dem Tag *MUIA_String_EditHook* einfach den Return-Wert der
Methode *edit()* an und überlädt die Methode *EditHookFunc()*.

   *Beispiel:*
     class Str : public MUIString
         {
         private:
             virtual VOID EditHookFunc(struct Hook *,
                                       struct SGWork *,
                                       Msg);
         public:
             Str(MUIA_String_Contents, "String-Contents",
                 MUIA_String_MaxLen, 64,
                 MUIA_String_EditHook, edit(),
                 TAG_DONE);
                 { };
             ~Str() { };
         };
     
     VOID Str::EditHookFunc(struct Hook *h,
                            struct SGWork *s,
                            Msg m);
         {
         eigener Code.
         };


@EndNode

@Node "MUILabelHelp" "TWiMUI.guide/MUILabelHelp"
@Next "MUIErrorX"
@Prev "MUIStringEditHook"
@Toc "MUI-Basisklassen"

MUILabelHelp
------------

     class MUILabelHelp
         {
         private:
             StringC labstr;
             UBYTE cc;
         protected:
             MUILabelHelp(const STRPTR);
             MUILabelHelp(const MUILabelHelp &);
             virtual ~MUILabelHelp();
             MUILabelHelp &operator=(const MUILabelHelp &);
             StringC &gLab();
             UBYTE gCC();
         };

abgeleitete Klassen:
     MUILabButton        (See @{"MUILabButton" Link "MUILabButton"}.)
     MUILabCheckmark     (See @{"MUILabCheckmark" Link "MUILabCheckmark"}.)
     MUILabCycle         (See @{"MUILabCycle" Link "MUILabCycle"}.)
     MUILabNumericbutton (See @{"MUILabNumericbutton" Link "MUILabNumericbutton"}.)
     MUILabRadio         (See @{"MUILabRadio" Link "MUILabRadio"}.)
     MUILabSlider        (See @{"MUILabSlider" Link "MUILabSlider"}.)
     MUILabString        (See @{"MUILabString" Link "MUILabString"}.)
Include-File:
     classes/TWiMUI/Notify.h

   Diese Klasse hat keinen öffentlichen Konstruktor, da auch keine
Instanzen davon gebildet werden sollten. Sie dient dazu, ein Object mit
einem Label zu versehen und gleichzeitig ein Control-Character für die
Tastatur-Bedienung zu definieren. Um dieses zu tun, muß der
abgeleiteten Klasse für das Label ein String übergeben werden, in
welchem dem Control-Character ein Unterstrich ("_") vorangestellt ist.
Dieser Unterstrich wird aus dem String entfernt und das
Control-Character wird unterstrichen.

   *Beispiel:*
     VOID main()
         {
         MUILabString Str("_String:","Contents",32);
         .
         .
         };


@EndNode

@Node "MUIErrorX" "TWiMUI.guide/MUIErrorX"
@Prev "MUILabelHelp"
@Toc "MUI-Basisklassen"

MUIErrorX
---------

     class MUIErrorX
         {
         public:
             MUIErrorX(const TWiStr &, const ULONG);
             MUIErrorX(const MUIErrorX &);
             ~MUIErrorX();
             const TWiStr &name() const;
             ULONG typ() const;
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Notify.h

   Diese Klasse wird ausgeworfen, falls bei einer MUI-Funktion ein
Fehler auftrat. Wird diese Exception dann aufgefangen, so kann mit der
Methode *name* der Name der fehlerhaften Klasse ermittelt werden und
mit der Methode *typ* eine dazugehörige Nummer. Diese Nummern sind
folgendermaßen vordefiniert:

     const ULONG MUIV_TWiMUI_MUIErrorX_Notify        = 1;
     const ULONG MUIV_TWiMUI_MUIErrorX_Family        = 2;
     const ULONG MUIV_TWiMUI_MUIErrorX_Menustrip     = 3;
     const ULONG MUIV_TWiMUI_MUIErrorX_Menu          = 4;
     const ULONG MUIV_TWiMUI_MUIErrorX_Menuitem      = 5;
     const ULONG MUIV_TWiMUI_MUIErrorX_Application   = 6;
     const ULONG MUIV_TWiMUI_MUIErrorX_Window        = 7;
     const ULONG MUIV_TWiMUI_MUIErrorX_Aboutmui      = 8;
     const ULONG MUIV_TWiMUI_MUIErrorX_Area          = 9;
     const ULONG MUIV_TWiMUI_MUIErrorX_Rectangle     = 10;
     const ULONG MUIV_TWiMUI_MUIErrorX_Balance       = 11;
     const ULONG MUIV_TWiMUI_MUIErrorX_Image         = 12;
     const ULONG MUIV_TWiMUI_MUIErrorX_Bitmap        = 13;
     const ULONG MUIV_TWiMUI_MUIErrorX_Bodychunk     = 14;
     const ULONG MUIV_TWiMUI_MUIErrorX_Text          = 15;
     const ULONG MUIV_TWiMUI_MUIErrorX_Gadget        = 16;
     const ULONG MUIV_TWiMUI_MUIErrorX_String        = 17;
     const ULONG MUIV_TWiMUI_MUIErrorX_Boopsi        = 18;
     const ULONG MUIV_TWiMUI_MUIErrorX_Prop          = 19;
     const ULONG MUIV_TWiMUI_MUIErrorX_Gauge         = 20;
     const ULONG MUIV_TWiMUI_MUIErrorX_Scale         = 21;
     const ULONG MUIV_TWiMUI_MUIErrorX_Colorfield    = 22;
     const ULONG MUIV_TWiMUI_MUIErrorX_List          = 23;
     const ULONG MUIV_TWiMUI_MUIErrorX_Floattext     = 24;
     const ULONG MUIV_TWiMUI_MUIErrorX_Volumelist    = 25;
     const ULONG MUIV_TWiMUI_MUIErrorX_Dirlist       = 26;
     const ULONG MUIV_TWiMUI_MUIErrorX_Numeric       = 27;
     const ULONG MUIV_TWiMUI_MUIErrorX_Knob          = 28;
     const ULONG MUIV_TWiMUI_MUIErrorX_Levelmeter    = 29;
     const ULONG MUIV_TWiMUI_MUIErrorX_Numericbutton = 30;
     const ULONG MUIV_TWiMUI_MUIErrorX_Slider        = 31;
     const ULONG MUIV_TWiMUI_MUIErrorX_Pendisplay    = 32;
     const ULONG MUIV_TWiMUI_MUIErrorX_Poppen        = 33;
     const ULONG MUIV_TWiMUI_MUIErrorX_Group         = 34;
     const ULONG MUIV_TWiMUI_MUIErrorX_Register      = 35;
     const ULONG MUIV_TWiMUI_MUIErrorX_Penadjust     = 36;
     const ULONG MUIV_TWiMUI_MUIErrorX_Virtgroup     = 37;
     const ULONG MUIV_TWiMUI_MUIErrorX_Scrollgroup   = 38;
     const ULONG MUIV_TWiMUI_MUIErrorX_Scrollbar     = 39;
     const ULONG MUIV_TWiMUI_MUIErrorX_Listview      = 40;
     const ULONG MUIV_TWiMUI_MUIErrorX_Radio         = 41;
     const ULONG MUIV_TWiMUI_MUIErrorX_Cycle         = 42;
     const ULONG MUIV_TWiMUI_MUIErrorX_Coloradjust   = 43;
     const ULONG MUIV_TWiMUI_MUIErrorX_Palette       = 44;
     const ULONG MUIV_TWiMUI_MUIErrorX_Popstring     = 45;
     const ULONG MUIV_TWiMUI_MUIErrorX_Popobject     = 46;
     const ULONG MUIV_TWiMUI_MUIErrorX_Poplist       = 47;
     const ULONG MUIV_TWiMUI_MUIErrorX_Popasl        = 48;
     const ULONG MUIV_TWiMUI_MUIErrorX_Semaphore     = 49;
     const ULONG MUIV_TWiMUI_MUIErrorX_Dataspace     = 50;
     const ULONG MUIV_TWiMUI_MUIErrorX_CreateClass   = 100;

   *Beispiel:*
     VOID main()
         {
         try
             {
             MUIWindow(......);
             MUIApplication(......);
             }
         catch(MUIErrorX(m))
             {
             cout << "MUI-Fehler:  " << m.typ() << endl;
             cout << "  Classname: " << m.name() << endl;
             }
         catch(...)
             {
             cout << "unbekannte Exception!" << endl;
             }
         };


@EndNode

@Node "MUI-Klassen" "TWiMUI.guide/MUI-Klassen"
@Next "inline-Funktionen"
@Prev "MUI-Basisklassen"
@Toc "Klassen"

MUI-Klassen
===========


 @{" UserDispatch " Link "UserDispatch"}         Wie definiere ich einen eigenen Dispatcher
 @{" MUIAboutmui " Link "MUIAboutmui"}          Die Klasse Aboutmui
 @{" MUIApplication " Link "MUIApplication"}       Die Klasse Application
 @{" MUIArea " Link "MUIArea"}              Die Klasse Area
 @{" MUIBalance " Link "MUIBalance"}           Die Klasse Balance
 @{" MUIBitmap " Link "MUIBitmap"}            Die Klasse Bitmap
 @{" MUIBodychunk " Link "MUIBodychunk"}         Die Klasse Bodychunk
 @{" MUIBoopsi " Link "MUIBoopsi"}            Die Klasse Boopsi
 @{" MUIButton " Link "MUIButton"}            Die Klasse Button
 @{" MUILabButton " Link "MUILabButton"}         Die Klasse Button mit Label-Unterstützung
 @{" MUICheckmark " Link "MUICheckmark"}         Die Klasse Checkmark
 @{" MUILabCheckmark " Link "MUILabCheckmark"}      Die Klasse Checkmark mit Label-Unterstützung
 @{" MUIColoradjust " Link "MUIColoradjust"}       Die Klasse Coloradjust
 @{" MUIColorfield " Link "MUIColorfield"}        Die Klasse Colorfield
 @{" MUICycle " Link "MUICycle"}             Die Klasse Cycle
 @{" MUILabCycle " Link "MUILabCycle"}          Die Klasse Cycle mit Label-Unterstützung
 @{" MUIDataspace " Link "MUIDataspace"}         Die Klasse Dataspace
 @{" MUIDirlist " Link "MUIDirlist"}           Die Klasse Dirlist
 @{" MUIFamily " Link "MUIFamily"}            Die Klasse Family
 @{" MUIFloattext " Link "MUIFloattext"}         Die Klasse Floattext
 @{" MUIGadget " Link "MUIGadget"}            Die Klasse Gadget
 @{" MUIGauge " Link "MUIGauge"}             Die Klasse Gauge
 @{" MUIGroup " Link "MUIGroup"}             Die Klasse Group
 @{" MUIGroupH " Link "MUIGroupH"}            Die Klasse Group mit horizontaler Ausrichtung
 @{" MUIGroupV " Link "MUIGroupV"}            Die Klasse Group mit vertikaler Ausrichtung
 @{" MUIGroupCol " Link "MUIGroupCol"}          Die Klasse Group mit Spalten-Anzahl
 @{" MUIGroupRow " Link "MUIGroupRow"}          Die Klasse Group mit Zeilen-Anzahl
 @{" MUIImage " Link "MUIImage"}             Die Klasse Image
 @{" MUIKnob " Link "MUIKnob"}              Die Klasse Knob
 @{" MUILabel " Link "MUILabel"}             Die Klasse Label
 @{" MUILevelmeter " Link "MUILevelmeter"}        Die Klasse Levelmeter
 @{" MUIList " Link "MUIList"}              Die Klasse List
 @{" MUIListview " Link "MUIListview"}          Die Klasse Listview
 @{" MUIMenu " Link "MUIMenu"}              Die Klasse Menu
 @{" MUIMenuitem " Link "MUIMenuitem"}          Die Klasse Menuitem
 @{" MUIMenusep " Link "MUIMenusep"}           Die Klasse Menusep
 @{" MUIMenustrip " Link "MUIMenustrip"}         Die Klasse Menustrip
 @{" MUINotify " Link "MUINotify"}            Die Klasse Notify
 @{" MUINumeric " Link "MUINumeric"}           Die Klasse Numeric
 @{" MUINumericbutton " Link "MUINumericbutton"}     Die Klasse Numericbutton
 @{" MUILabNumericbutton " Link "MUILabNumericbutton"}  Die Klasse Numericbutton mit Label-Unterstützung
 @{" MUIPalette " Link "MUIPalette"}           Die Klasse Palette
 @{" MUIPendisplay " Link "MUIPendisplay"}        Die Klasse Pendisplay
 @{" MUIPopasl " Link "MUIPopasl"}            Die Klasse Popasl
 @{" MUIPopbutton " Link "MUIPopbutton"}         Die Klasse Popbutton
 @{" MUIPoplist " Link "MUIPoplist"}           Die Klasse Poplist
 @{" MUIPopobject " Link "MUIPopobject"}         Die Klasse Popobject
 @{" MUIPoppen " Link "MUIPoppen"}            Die Klasse Poppen
 @{" MUIPopstring " Link "MUIPopstring"}         Die Klasse Popstring
 @{" MUIProp " Link "MUIProp"}              Die Klasse Prop
 @{" MUIRadio " Link "MUIRadio"}             Die Klasse Radio
 @{" MUILabRadio " Link "MUILabRadio"}          Die Klasse Radio mit Label-Unterstützung
 @{" MUIRectangle " Link "MUIRectangle"}         Die Klasse Rectangle
 @{" MUIHBar " Link "MUIHBar"}              Die Klasse Rectangle als HBar
 @{" MUIVBar " Link "MUIVBar"}              Die Klasse Rectangle als VBar
 @{" MUIRegister " Link "MUIRegister"}          Die Klasse Register
 @{" MUIRequest " Link "MUIRequest"}           Die Klasse Request
 @{" MUIScale " Link "MUIScale"}             Die Klasse Scale
 @{" MUIScrollbar " Link "MUIScrollbar"}         Die Klasse Scrollbar
 @{" MUIScrollgroup " Link "MUIScrollgroup"}       Die Klasse Scrollgroup
 @{" MUISemaphore " Link "MUISemaphore"}         Die Klasse Semaphore
 @{" MUISlider " Link "MUISlider"}            Die Klasse Slider
 @{" MUILabSlider " Link "MUILabSlider"}         Die Klasse Slider mit Label-Unterstützung
 @{" MUIString " Link "MUIString"}            Die Klasse String
 @{" MUILabString " Link "MUILabString"}         Die Klasse String mit Label-Unterstützung
 @{" MUIText " Link "MUIText"}              Die Klasse Text
 @{" MUIVirtgroup " Link "MUIVirtgroup"}         Die Klasse Virtgroup
 @{" MUIVolumelist " Link "MUIVolumelist"}        Die Klasse Volumelist
 @{" MUIWindow " Link "MUIWindow"}            Die Klasse Window

   Hier werden jetzt die C++-Klassen beschrieben, die sich direkt aus
den einzelnen MUI-Klassen abgeleitet haben. Zusätzlich werden auch
einige weitere Klassen beschrieben, die aus diesen Klassen abgleitet
werden und dem Programmierer weitere Unterstützung bieten.

   Zu jedem MUI-Attribut, welches gelesen oder gesetzt werden kann,
existiert eine entsprechende Methode mit gleichen Namen, um dieses
Attribut zu setzen bzw. zu lesen. Die Methoden mit den entsprechenden
Parameter dienen zum Setzen der Attribute und die Methode mit den
Return-Werten zum Lesen.

   Auch für die Methoden der Klassen gibt es entsprechende Methoden
mit gleichen Namen.

   Sollte es für die Attribute oder Methoden Standard-Parameter geben,
wie zum Beispiel bei *MUIM_Application_Load* die Möglichkeiten
*MUIV_Application_Load_ENV* oder auch *...ENVARC*, so gibt es auch
dafür schon fertige Methoden, denen dann kein Parameter mehr übergeben
werden muß. (In diesen Fällen also *LoadENV* und *LoadENVARC*.


@EndNode

@Node "UserDispatch" "TWiMUI.guide/UserDispatch"
@Next "MUIAboutmui"
@Toc "MUI-Klassen"

UserDispatch
------------

   Da diese Klassen-Bibliothek auf den Custom-Classes von MUI basiert,
wird es notwendig sein, eigene Disaptcher für die MUI-Klassen zu
benutzen. Deshalb gibt es für jede Klasse eine virtuelle Funktion *
ULONG UserDispatch(struct IClass *, Object *, Msg)*, die überladen
werden kann. In dieser Funktion können dann eigene Methoden definiert
werden. Es darf natürlich nicht vergessen werden, daß alle
unbekannten Methoden direkt an die vererbende Klasse mit DoSuperMethod()
weitergeleitet werden.


@EndNode

@Node "MUIAboutmui" "TWiMUI.guide/MUIAboutmui"
@Next "MUIApplication"
@Prev "UserDispatch"
@Toc "MUI-Klassen"

MUIAboutmui
-----------

     class MUIAboutmui : public MUIWindow
         {
         public:
             MUIAboutmui(const struct TagItem *);
             MUIAboutmui(const Tag, ...);
             MUIAboutmui();
             MUIAboutmui(MUIAboutmui &);
             virtual ~MUIAboutmui();
             MUIAboutmui &operator= (const MUIAboutmui &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Aboutmui.h

   Dies ist die C++-Klasse für die MUI-Klasse Aboutmui. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Aboutmui-Fenster zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden, um das Aboutmui-Fenster zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIAboutmui About(
             MUIA_Window_RefWindow, win,
             MUIA_Aboutmui_Application, app,
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIApplication" "TWiMUI.guide/MUIApplication"
@Next "MUIArea"
@Prev "MUIAboutmui"
@Toc "MUI-Klassen"

MUIApplication
--------------

     class MUIApplication
         :   public MUINotify,
             public MUIApplicationBrokerHook,
             public MUIApplicationRexxHook
         {
         private:
             virtual ULONG Dispatch(struct IClass *, Object *, Msg);
         public:
             MUIApplication(const struct TagItem *);
             MUIApplication(const Tag, ...);
             MUIApplication();
             MUIApplication(MUIApplication &);
             virtual ~MUIApplication();
             MUIApplication &operator= (const MUIApplication &);
             VOID Loop();
             VOID Add(MUIWindow &);
             VOID Rem(MUIWindow &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Application.h

   Dies ist die C++-Klasse für die MUI-Klasse Application. Den
Konstruktoren werden die Tags übergeben, die notwendig sind, um eine
Application zu erstellen. Dabei können die Tags als variable Parameter
oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden, um die Application zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Für diese Klasse gibt es noch drei zusätzliche Methoden:
Loop
     Diese Methode wird dafür verwendet, um MUI in den Wait()-Loop zu
     schicken und die einzelnen Signale zu empfangen und auszuwerten.
     Da diese Klassen-Bibliothek auf Custom-Classes aufbaut, können
     eigene Methoden leicht über eigene Dispatcher (See @{"UserDispatch" Link "UserDispatch"}.)
     implementiert werden und es ist nicht notwendig,
     MUIA-Application_ReturnID zu verwenden, mit Ausnahme von
     MUIV_Application_ReturnID_Quit, mit dem die Methode Loop() beendet
     wird..

Add
     Diese Methode wird dazu verwendet, um einer Application ein Window
     dynamisch anzuhängen.

Rem
     Diese Methode wird dazu verwendet, um ein Window aus einer
     Application wieder zu entfernen.

   *Beispiel:*
     VOID main()
         {
         MUIApplication App(
             MUIA_Application_Title, "???",
             MUIA_Application_Version, "$VER: ????",
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIArea" "TWiMUI.guide/MUIArea"
@Next "MUIBalance"
@Prev "MUIApplication"
@Toc "MUI-Klassen"

MUIArea
=======

     class MUIArea : public MUINotify
         {
         protected:
             MUIArea(const STRPTR);
         public:
             MUIArea(const struct TagItem *);
             MUIArea(const Tag, ...);
             MUIArea();
             MUIArea(MUIArea &);
             virtual ~MUIArea();
             MUIArea &operator= (const MUIArea &);
             MUIWindow *WinClass() const;
         };

abgeleitete Klassen:
     MUIRectangle  (See @{"MUIRectangle" Link "MUIRectangle"}.)
     MUIBalance    (See @{"MUIBalance" Link "MUIBalance"}.)
     MUIImage      (See @{"MUIImage" Link "MUIImage"}.)
     MUIBitmap     (See @{"MUIBitmap" Link "MUIBitmap"}.)
     MUIText       (See @{"MUIText" Link "MUIText"}.)
     MUIGadget     (See @{"MUIGadget" Link "MUIGadget"}.)
     MUIGauge      (See @{"MUIGauge" Link "MUIGauge"}.)
     MUIScale      (See @{"MUIScale" Link "MUIScale"}.)
     MUIColorfield (See @{"MUIColorfield" Link "MUIColorfield"}.)
     MUIList       (See @{"MUIList" Link "MUIList"}.)
     MUINumeric    (See @{"MUINumeric" Link "MUINumeric"}.)
     MUIPendisplay (See @{"MUIPendisplay" Link "MUIPendisplay"}.)
     MUIGroup      (See @{"MUIGroup" Link "MUIGroup"}.)
Include-File:
     classes/TWiMUI/Area.h

   Dies ist die C++-Klasse für die MUI-Klasse Area. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um eine Area zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden, um die Area zu erstellen. Dieser Methode können auch variable
Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Im Normalfall wird allerdings von dieser Klasse keine Instanz
gebildet, da sie für fast alle MUI-Objekte Basisklasse ist.

   Für diese Klasse gibt es noch eine zusätzliche Methode:
WinClass
     Diese Methode gibt einen Zeiger auf eine Instanz der Klasse
     MUIWindow, der dieses Objekt zugeordnet ist zurück.

   *Beispiel:*
     VOID main()
         {
         MUIArea Area(
             MUIA_ObjectID, 1,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIBalance" "TWiMUI.guide/MUIBalance"
@Next "MUIBitmap"
@Prev "MUIArea"
@Toc "MUI-Klassen"

MUIBalance
==========

     class MUIBalance : public MUIArea
         {
         public:
             MUIBalance(const struct TagItem *);
             MUIBalance(const Tag, ...);
             MUIBalance();
             MUIBalance(MUIBalance &);
             virtual ~MUIBalance();
             MUIBalance &operator= (const MUIBalance &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Balance.h

   Dies ist die C++-Klasse für die MUI-Klasse Balance. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Balance-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Balance-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIBalance Bal(
             MUIA_ObjectID, 1,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIBitmap" "TWiMUI.guide/MUIBitmap"
@Next "MUIBodychunk"
@Prev "MUIBalance"
@Toc "MUI-Klassen"

MUIBitmap
=========

     class MUIBitmap : public MUIArea
         {
         public:
             MUIBitmap(const struct TagItem *);
             MUIBitmap(const Tag, ...);
             MUIBitmap();
             MUIBitmap(MUIBitmap &);
             virtual ~MUIBitmap();
             MUIBitmap &operator= (const MUIBitmap &);
         };

abgeleitete Klassen:
     MUIBodychunk  (See @{"MUIBodychunk" Link "MUIBodychunk"}.)
Include-File:
     classes/TWiMUI/Bitmap.h

   Dies ist die C++-Klasse für die MUI-Klasse Bitmap. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Bitmap-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Bitmap-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIBitmap BitMap(
             MUIA_Bitmap_UseFriend, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIBodychunk" "TWiMUI.guide/MUIBodychunk"
@Next "MUIBoopsi"
@Prev "MUIBitmap"
@Toc "MUI-Klassen"

MUIBodychunk
============

     class MUIBodychunk : public MUIArea
         {
         public:
             MUIBodychunk(const struct TagItem *);
             MUIBodychunk(const Tag, ...);
             MUIBodychunk();
             MUIBodychunk(MUIBodychunk &);
             virtual ~MUIBodychunk();
             MUIBodychunk &operator= (const MUIBodychunk &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Bodychunk.h

   Dies ist die C++-Klasse für die MUI-Klasse Bodychunk. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Bodychunk-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Bodychunk-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIBodychunk bc(
             MUIA_Bodychunk_Depth, 8,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIBoopsi" "TWiMUI.guide/MUIBoopsi"
@Next "MUIButton"
@Prev "MUIBodychunk"
@Toc "MUI-Klassen"

MUIBoopsi
=========

     class MUIBoopsi : public MUIGadget
         {
         public:
             MUIBoopsi(const struct TagItem *);
             MUIBoopsi(const Tag, ...);
             MUIBoopsi();
             MUIBoopsi(MUIBoopsi &);
             virtual ~MUIBoopsi();
             MUIBoopsi &operator= (const MUIBoopsi &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Boopsi.h

   Dies ist die C++-Klasse für die MUI-Klasse Boopsi. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Boopsi-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Boopsi-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIBoopsi bc(
             MUIA_Boopsi_ClassID, "colorwheel.gadget",
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIButton" "TWiMUI.guide/MUIButton"
@Next "MUILabButton"
@Prev "MUIBoopsi"
@Toc "MUI-Klassen"

MUIButton
=========

     class MUIButton : public MUIText
         {
         public:
             MUIButton(const STRPTR);
             MUIButton(const STRPTR, const UBYTE);
             MUIButton(MUIButton &);
             virtual ~MUIButton();
             MUIButton &operator= (const MUIButton &);
         };

abgeleitete Klassen:
     MUILabButton  (See @{"MUILabButton" Link "MUILabButton"}.)
Include-File:
     classes/TWiMUI/Button.h

   Dies ist die C++-Klasse um aus der MUI-Klasse Text einen Button zu
erstellen. Den Konstruktoren wird ein Pointer auf den Inhalt des
Buttons übergeben. Wenn gewünscht, kann danach noch ein zweiter
Parameter, ein UBYTE, übergeben werden. Dieses Zeichen wird dann im
Button-Inhalt unterstrichen dargestellt und wird das Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         MUIButton but("Button-Inhalt",'b');
         .
         .
         .
         };


@EndNode

@Node "MUILabButton" "TWiMUI.guide/MUILabButton"
@Next "MUICheckmark"
@Prev "MUIButton"
@Toc "MUI-Klassen"

MUILabButton
============

     class MUILabButton
         :   public MUILabelHelp,
             public MUIButton
         {
         public:
             MUILabButton(const STRPTR);
             virtual ~MUILabButton();
             MUILabButton &operator= (const MUILabButton &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Button.h

   Diese Klasse ist eine weitere Unterstützung bei der Erstellung
eines Buttons. Dem Konstruktor wird ein Pointer auf einen String
übergeben. Dieser String wird der Inhalt des Buttons. Ausserdem wird
dieser String nach einem Underscore ("_") untersucht und das darauf
folgende Zeichen wird in dem String unterstrichen dargestellt.
Ausserdem wird dieses Zeichen das Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         MUILabButton but("_Save:");
         .
         .
         .
         };


@EndNode

@Node "MUICheckmark" "TWiMUI.guide/MUICheckmark"
@Next "MUILabCheckmark"
@Prev "MUILabButton"
@Toc "MUI-Klassen"

MUICheckmark
============

     class MUICheckmark : public MUIImage
         {
         public:
             MUICheckmark(const UBYTE);
             MUICheckmark(const STRPTR);
             MUICheckmark(MUICheckmark &);
             virtual ~MUICheckmark();
             MUICheckmark &operator= (const MUICheckmark &);
         };

abgeleitete Klassen:
     MUILabCheckmark  (See @{"MUILabCheckmark" Link "MUILabCheckmark"}.)
Include-File:
     classes/TWiMUI/Checkmark.h

   Dies ist die C++-Klasse um aus der MUI-Klasse Image ein Checkmark zu
erstellen. Dem Konstruktor wird entweder ein Zeichen oder ein Pointer
auf ein Zeichen übergeben. Dieses Zeichen wird dann das
Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         MUICheckmark chk('c');
         .
         .
         .
         };


@EndNode

@Node "MUILabCheckmark" "TWiMUI.guide/MUILabCheckmark"
@Next "MUIColoradjust"
@Prev "MUICheckmark"
@Toc "MUI-Klassen"

MUILabCheckmark
===============

     class MUILabCheckmark : public MUILabelHelp, public MUICheckmark
         {
         public:
             MUILabCheckmark(const STRPTR);
             virtual ~MUILabCheckmark();
             MUILabCheckmark &operator= (const MUILabCheckmark &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Checkmark.h

   Diese Klasse ist eine weitere Unterstützung bei der Erstellung
eines Buttons. Dem Konstruktor wird ein Pointer auf einen String
übergeben. Dieser String wird der Inhalt des Checkmarks. Ausserdem wird
dieser String nach einem Underscore ("_") untersucht und das darauf
folgende Zeichen wird in dem String unterstrichen dargestellt.
Ausserdem wird dieses Zeichen das Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         MUILabCheckmark but("_Save:");
         .
         .
         .
         };


@EndNode

@Node "MUIColoradjust" "TWiMUI.guide/MUIColoradjust"
@Next "MUIColorfield"
@Prev "MUILabCheckmark"
@Toc "MUI-Klassen"

MUIColoradjust
==============

     class MUIColoradjust : public MUIGroup
         {
         public:
             MUIColoradjust(const struct TagItem *);
             MUIColoradjust(const Tag, ...);
             MUIColoradjust();
             MUIColoradjust(MUIColoradjust &);
             virtual ~MUIColoradjust();
             MUIColoradjust &operator= (const MUIColoradjust &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Coloradjust.h

   Dies ist die C++-Klasse für die MUI-Klasse Coloradjust. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Coloradjust-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Coloradjust-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIColoradjust ca(
             MUIA_Coloradjust_Blue, 0,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIColorfield" "TWiMUI.guide/MUIColorfield"
@Next "MUICycle"
@Prev "MUIColoradjust"
@Toc "MUI-Klassen"

MUIColorfield
=============

     class MUIColorfield : public MUIGroup
         {
         public:
             MUIColorfield(const struct TagItem *);
             MUIColorfield(const Tag, ...);
             MUIColorfield();
             MUIColorfield(MUIColorfield &);
             virtual ~MUIColorfield();
             MUIColorfield &operator= (const MUIColorfield &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Colorfield.h

   Dies ist die C++-Klasse für die MUI-Klasse Colorfield. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Colorfield-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Colorfield-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIColorfield cf(
             MUIA_Colorfield_Blue, 0,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUICycle" "TWiMUI.guide/MUICycle"
@Next "MUILabCycle"
@Prev "MUIColorfield"
@Toc "MUI-Klassen"

MUICycle
========

     class MUICycle : public MUIGroup
         {
         public:
             MUICycle(const struct TagItem *);
             MUICycle(const Tag, ...);
             MUICycle(const STRPTR *);
             MUICycle(const STRPTR *, const UBYTE);
             MUICycle();
             MUICycle(MUICycle &);
             virtual ~MUICycle();
             MUICycle &operator= (const MUICycle &);
         };

abgeleitete Klassen:
     MUILabCycle  (See @{"MUILabCycle" Link "MUILabCycle"}.)
Include-File:
     classes/TWiMUI/Cycle.h

   Dies ist die C++-Klasse für die MUI-Klasse Cycle. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Cycle-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Cycle-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Bei dieser Klasse sind weitere Möglichkeiten zur Konstruktion einer
Instanz gegeben. Es kann ein Pointer auf ein mit NULL abgeschlossenes
Array von String-Pointern übergeben werden. Diese Strings bilden dann
den Inhalt des Cycle-Gadgets. Wenn gewünscht, kann danach noch ein
zweiter Parameter, ein UBYTE, übergeben werden. Dieses Zeichen wird
dann das Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         static const STRPTR ent[] =
             {
             "Entry 1",
             "Entry 2",
             "Entry 3",
             NULL
             };
         MUICycle cyc(ent);
         .
         .
         .
         };


@EndNode

@Node "MUILabCycle" "TWiMUI.guide/MUILabCycle"
@Next "MUIDataspace"
@Prev "MUICycle"
@Toc "MUI-Klassen"

MUILabCycle
===========

     class MUILabCycle : public MUILabelHelp, public MUICycle
         {
         public:
             MUILabCycle(const STRPTR, const STRPTR *);
             virtual ~MUILabCycle();
             MUILabCycle &operator= (const MUILabCycle &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Cycle.h

   Diese Klasse ist eine weitere Unterstützung bei der Erstellung
eines Cycle-Objekts. Dem Konstruktor wird ein Pointer auf einen String
übergeben. Dieser String wird dem Cycle-Objekt als Label
vorangestellt. Ausserdem wird dieser String nach einem Underscore ("_")
untersucht und das darauf folgende Zeichen wird in dem Label
unterstrichen dargestellt. Ausserdem wird dieses Zeichen das
Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         static const STRPTR ent[] =
             {
             "Entry 1",
             "Entry 2",
             "Entry 3",
             NULL
             };
         MUILabCycle cyc("_Cycle:",ent);
         .
         .
         .
         };


@EndNode

@Node "MUIDataspace" "TWiMUI.guide/MUIDataspace"
@Next "MUIDirlist"
@Prev "MUILabCycle"
@Toc "MUI-Klassen"

MUIDataspace
============

     class MUIDataspace : public MUISemaphore
         {
         public:
             MUIDataspace(const struct TagItem *);
             MUIDataspace(const Tag, ...);
             MUIDataspace();
             MUIDataspace(MUIDataspace &);
             virtual ~MUIDataspace();
             MUIDataspace &operator= (const MUIDataspace &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Dataspace.h

   Dies ist die C++-Klasse für die MUI-Klasse Dataspace. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Dataspace-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Dataspace-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         APTR pool = CreatePool(...);
         MUIDataspace ds(MUIA_Dataspace_Pool, pool, TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIDirlist" "TWiMUI.guide/MUIDirlist"
@Next "MUIFamily"
@Prev "MUIDataspace"
@Toc "MUI-Klassen"

MUIDirlist
==========

     class MUIDirlist : public MUIList
         {
         public:
             MUIDirlist(const struct TagItem *);
             MUIDirlist(const Tag, ...);
             MUIDirlist();
             MUIDirlist(MUIDirlist &);
             virtual ~MUIDirlist();
             MUIDirlist &operator= (const MUIDirlist &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Dirlist.h

   Dies ist die C++-Klasse für die MUI-Klasse Dirlist. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Dirlist-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Dirlist-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIDirlist dl(
             MUIA_Dirlist_DrawersOnly, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIFamily" "TWiMUI.guide/MUIFamily"
@Next "MUIFloattext"
@Prev "MUIDirlist"
@Toc "MUI-Klassen"

MUIFamily
=========

abgeleitete Klassen:
     MUIMenustrip  (See @{"MUIMenustrip" Link "MUIMenustrip"}.)
     MUIMenu       (See @{"MUIMenu" Link "MUIMenu"}.)
     MUIMenuitem   (See @{"MUIMenuitem" Link "MUIMenuitem"}.)
Include-File:
     classes/TWiMUI/Family.h

   Dies ist die C++-Klasse für die MUI-Klasse Family. Von dieser
Klasse kann keine Instanz genildet werden, da sie als Basisklasse für
andere MUI-Klassen verwendet wird.


@EndNode

@Node "MUIFloattext" "TWiMUI.guide/MUIFloattext"
@Next "MUIGadget"
@Prev "MUIFamily"
@Toc "MUI-Klassen"

MUIFloattext
============

     class MUIFloattext : public MUIList
         {
         public:
             MUIFloattext(const struct TagItem *);
             MUIFloattext(const Tag, ...);
             MUIFloattext();
             MUIFloattext(MUIFloattext &);
             virtual ~MUIFloattext();
             MUIFloattext &operator= (const MUIFloattext &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Floattext.h

   Dies ist die C++-Klasse für die MUI-Klasse Floattext. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Floattext-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Floattext-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIFloattext ft(
             MUIA_Floattext_Justify, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIGadget" "TWiMUI.guide/MUIGadget"
@Next "MUIGauge"
@Prev "MUIFloattext"
@Toc "MUI-Klassen"

MUIGadget
=========

     class MUIGadget : public MUIArea
         {
         public:
             MUIGadget(const struct TagItem *);
             MUIGadget(const Tag, ...);
             MUIGadget();
             MUIGadget(MUIGadget &);
             virtual ~MUIGadget();
             MUIGadget &operator= (const MUIGadget &);
         };

abgeleitete Klassen:
     MUIString  (See @{"MUIString" Link "MUIString"}.)
     MUIBoopsi  (See @{"MUIBoopsi" Link "MUIBoopsi"}.)
     MUIProp    (See @{"MUIProp" Link "MUIProp"}.)
Include-File:
     classes/TWiMUI/Gadget.h

   Dies ist die C++-Klasse für die MUI-Klasse Gadget. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Gadget-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Gadget-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIGadget gad(TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIGauge" "TWiMUI.guide/MUIGauge"
@Next "MUIGroup"
@Prev "MUIGadget"
@Toc "MUI-Klassen"

MUIGauge
========

     class MUIGauge : public MUIArea
         {
         public:
             MUIGauge(const struct TagItem *);
             MUIGauge(const Tag, ...);
             MUIGauge();
             MUIGauge(MUIGauge &);
             virtual ~MUIGauge();
             MUIGauge &operator= (const MUIGauge &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Gauge.h

   Dies ist die C++-Klasse für die MUI-Klasse Gauge. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Gauge-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Gauge-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIGauge dl(
             MUIA_Gauge_Horiz, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIGroup" "TWiMUI.guide/MUIGroup"
@Next "MUIGroupH"
@Prev "MUIGauge"
@Toc "MUI-Klassen"

MUIGroup
========

     class MUIGroup : public MUIArea
         {
         public:
             MUIGroup(const struct TagItem *);
             MUIGroup(const Tag, ...);
             MUIGroup();
             MUIGroup(MUIGroup &);
             virtual ~MUIGroup();
             MUIGroup &operator= (const MUIGroup &);
         };

abgeleitete Klassen:
     MUIColoradjust  (See @{"MUIColoradjust" Link "MUIColoradjust"}.)
     MUICycle        (See @{"MUICycle" Link "MUICycle"}.)
     MUIGroupCol     (See @{"MUIGroupCol" Link "MUIGroupCol"}.)
     MUIGroupH       (See @{"MUIGroupH" Link "MUIGroupH"}.)
     MUIGroupRow     (See @{"MUIGroupRow" Link "MUIGroupRow"}.)
     MUIGroupV       (See @{"MUIGroupV" Link "MUIGroupV"}.)
     MUIListview     (See @{"MUIListview" Link "MUIListview"}.)
     MUIPalette      (See @{"MUIPalette" Link "MUIPalette"}.)
     MUIPopstring    (See @{"MUIPopstring" Link "MUIPopstring"}.)
     MUIRadio        (See @{"MUIRadio" Link "MUIRadio"}.)
     MUIRegister     (See @{"MUIRegister" Link "MUIRegister"}.)
     MUIScrollbar    (See @{"MUIScrollbar" Link "MUIScrollbar"}.)
     MUIScrollgroup  (See @{"MUIScrollgroup" Link "MUIScrollgroup"}.)
     MUIVirtgroup    (See @{"MUIVirtgroup" Link "MUIVirtgroup"}.)
Include-File:
     classes/TWiMUI/Group.h

   Dies ist die C++-Klasse für die MUI-Klasse Group. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Group-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Group-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIGroup grp(
             MUIA_Group_PageMode, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIGroupH" "TWiMUI.guide/MUIGroupH"
@Next "MUIGroupV"
@Prev "MUIGroup"
@Toc "MUI-Klassen"

MUIGroupH
=========

   Diese Gruppe ist identisch mit der Gruppe MUIGroup (See @{"MUIGroupH" Link "MUIGroupH"}.)
mit der Ausnahme, daß sie automatisch eine horizontale Gruppe ist.


@EndNode

@Node "MUIGroupV" "TWiMUI.guide/MUIGroupV"
@Next "MUIGroupCol"
@Prev "MUIGroupH"
@Toc "MUI-Klassen"

MUIGroupV
=========

   Diese Gruppe ist identisch mit der Gruppe MUIGroup (See @{"MUIGroupH" Link "MUIGroupH"}.)
mit der Ausnahme, daß sie automatisch eine vertikale Gruppe ist.


@EndNode

@Node "MUIGroupCol" "TWiMUI.guide/MUIGroupCol"
@Next "MUIGroupRow"
@Prev "MUIGroupV"
@Toc "MUI-Klassen"

MUIGroupCol
===========

   Diese Gruppe ist identisch mit der Gruppe MUIGroup (See @{"MUIGroupH" Link "MUIGroupH"}.)
mit der Ausnahme, daß als erster Parameter ein LONG-Wert übergeben
wird, der die Anzahl der Spalten definiert.


@EndNode

@Node "MUIGroupRow" "TWiMUI.guide/MUIGroupRow"
@Next "MUIImage"
@Prev "MUIGroupCol"
@Toc "MUI-Klassen"

MUIGroupRow
===========

   Diese Gruppe ist identisch mit der Gruppe MUIGroup (See @{"MUIGroupH" Link "MUIGroupH"}.)
mit der Ausnahme, daß als erster Parameter ein LONG-Wert übergeben
wird, der die Anzahl der Zeilen definiert.


@EndNode

@Node "MUIImage" "TWiMUI.guide/MUIImage"
@Next "MUIKnob"
@Prev "MUIGroupRow"
@Toc "MUI-Klassen"

MUIImage
========

     class MUIImage : public MUIArea
         {
         public:
             MUIImage(const struct TagItem *);
             MUIImage(const Tag, ...);
             MUIImage();
             MUIImage(MUIImage &);
             virtual ~MUIImage();
             MUIImage &operator= (const MUIImage &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Image.h

   Dies ist die C++-Klasse für die MUI-Klasse Image. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Image-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Image-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIImage img(
             MUIA_Image_FontMatch, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIKnob" "TWiMUI.guide/MUIKnob"
@Next "MUILabel"
@Prev "MUIImage"
@Toc "MUI-Klassen"

MUIKnob
=======

     class MUIKnob : public MUINumeric
         {
         public:
             MUIKnob(const struct TagItem *);
             MUIKnob(const Tag, ...);
             MUIKnob();
             MUIKnob(MUIKnob &);
             virtual ~MUIKnob();
             MUIKnob &operator= (const MUIKnob &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Knob.h

   Dies ist die C++-Klasse für die MUI-Klasse Knob. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Knob-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Knob-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIKnob knob(TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUILabel" "TWiMUI.guide/MUILabel"
@Next "MUILevelmeter"
@Prev "MUIKnob"
@Toc "MUI-Klassen"

MUILabel
========

     class MUILabel : public MUIText
         {
         public:
             MUILabel(const struct TagItem *);
             MUILabel(const Tag, ...);
             MUILabel();
             MUILabel(MUILabel &);
             virtual ~MUILabel();
             MUILabel &operator= (const MUILabel &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Label.h

   Dies ist die C++-Klasse um aus der Klasse MUIText (See @{"MUIText" Link "MUIText"}.) ein
Label zu kreieren. Für alle in der MUI-Header-Datei definierten Label
gibt es eine korrespondierende MUILabel-Klasse. Den Konstruktoren
dieser Klassen werden ein Pointer auf einen String übergeben, welcher
dann das Label darstellt. Den Key-Labeln wird als zweiter Parameter
noch ein UBYTE übergeben. Dieses Zeichen wird dann in dem Label
unterstrichen dargestellt.

   *Beispiel:*
     VOID main()
         {
         MUILabel2 lab1("Label1: ");
         MUIKeyLabel2 lab2("Label2: ",'l');
         .
         .
         .
         };


@EndNode

@Node "MUILevelmeter" "TWiMUI.guide/MUILevelmeter"
@Next "MUIList"
@Prev "MUILabel"
@Toc "MUI-Klassen"

MUILevelmeter
=============

     class MUILevelmeter : public MUINumeric
         {
         public:
             MUILevelmeter(const struct TagItem *);
             MUILevelmeter(const Tag, ...);
             MUILevelmeter();
             MUILevelmeter(MUILevelmeter &);
             virtual ~MUILevelmeter();
             MUILevelmeter &operator= (const MUILevelmeter &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Levelmeter.h

   Dies ist die C++-Klasse für die MUI-Klasse Levelmeter. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Levelmeter-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Levelmeter-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUILevelmeter lm(MUIA_Levelmeter_Label, "Label", TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIList" "TWiMUI.guide/MUIList"
@Next "MUIListview"
@Prev "MUILevelmeter"
@Toc "MUI-Klassen"

MUIList
=======

     class MUIList
         :   public MUIArea,
             public MUIListCompareHook,
             public MUIListConstructHook,
             public MUIListDestructHook,
             public MUIListDisplayHook,
             public MUIListMultiTestHook
         {
         public:
             MUIList(const struct TagItem *);
             MUIList(const Tag, ...);
             MUIList();
             MUIList(MUIList &);
             virtual ~MUIList();
             MUIList &operator= (const MUIList &);
         };

abgeleitete Klassen:
     MUIDirlist      (See @{"MUIDirlist" Link "MUIDirlist"}.)
     MUIFloattext    (See @{"MUIFloattext" Link "MUIFloattext"}.)
     MUIVolumelist   (See @{"MUIVolumelist" Link "MUIVolumelist"}.)
Include-File:
     classes/TWiMUI/List.h

   Dies ist die C++-Klasse für die MUI-Klasse List. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein List-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das List-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIList lst(
             MUIA_List_Active, MUIV_List_Active_Top,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIListview" "TWiMUI.guide/MUIListview"
@Next "MUIMenu"
@Prev "MUIList"
@Toc "MUI-Klassen"

MUIListview
===========

     class MUIListview : public MUIGroup
         {
         public:
             MUIListview(const struct TagItem *);
             MUIListview(const Tag, ...);
             MUIListview();
             MUIListview(MUIListview &);
             virtual ~MUIListview();
             MUIListview &operator= (const MUIListview &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Listview.h

   Dies ist die C++-Klasse für die MUI-Klasse Listview. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Listview-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Listview-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIListview lv(
             MUIA_Listview_Input, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIMenu" "TWiMUI.guide/MUIMenu"
@Next "MUIMenuitem"
@Prev "MUIListview"
@Toc "MUI-Klassen"

MUIMenu
=======

     class MUIMenu : public MUIFamily
         {
         public:
             MUIMenu(const struct TagItem *);
             MUIMenu(const Tag, ...);
             MUIMenu();
             MUIMenu(MUIMenu &);
             MUIMenu(const STRPTR, const Object *, ...);
             MUIMenu(const STRPTR, const MUIMenuitem *, ...);
             virtual ~MUIMenu();
             MUIMenu &operator= (const MUIMenu &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Menu.h

   Dies ist die C++-Klasse für die MUI-Klasse Menu. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Menu-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Menu-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Für diese Klasse sind noch zwei weitere Konstruktoren
implementiert. Beiden wird als erster Parameter ein Pointer auf einen
String übergeben. Dieser String wird der Titel des Menüs. Danach
können dann entweder eine Liste von Pointern auf Menuitem-Objekte oder
eine Liste von Pointern auf Instanzen der MUIMenuitem-Klasse übergeben
werden. Beide Listen werden mit NULL terminiert.

   *Beispiel:*
     VOID main()
         {
         MUIMenu men(
             MUIA_Menu_Title, "Titel",
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIMenuitem" "TWiMUI.guide/MUIMenuitem"
@Next "MUIMenusep"
@Prev "MUIMenu"
@Toc "MUI-Klassen"

MUIMenuitem
===========

     class MUIMenuitem : public MUIFamily
         {
         public:
             MUIMenuitem(const struct TagItem *);
             MUIMenuitem(const Tag, ...);
             MUIMenuitem();
             MUIMenuitem(MUIMenuitem &);
             MUIMenuitem(const STRPTR, const Object *, ...);
             MUIMenuitem(const STRPTR, const MUIMenuitem *, ...);
             virtual ~MUIMenuitem();
             MUIMenuitem &operator= (const MUIMenuitem &);
         };

abgeleitete Klassen:
     MUIMenusep   (See @{"MUIMenusep" Link "MUIMenusep"}.)
Include-File:
     classes/TWiMUI/Menu.h

   Dies ist die C++-Klasse für die MUI-Klasse Menuitem. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Menuitem-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Menuitem-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Für diese Klasse sind noch zwei weitere Konstruktoren
implementiert. Beiden wird als erster Parameter ein Pointer auf einen
String übergeben. Dieser String wird der Titel des Menüitems. Danach
können dann entweder eine Liste von Pointern auf Menuitem-Objekte oder
eine Liste von Pointern auf Instanzen der MUIMenuitem-Klasse übergeben
werden. Beide Listen werden mit NULL terminiert.

   *Beispiel:*
     VOID main()
         {
         MUIMenuitem men(
             MUIA_Menuitem_Title, "Titel",
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIMenusep" "TWiMUI.guide/MUIMenusep"
@Next "MUIMenustrip"
@Prev "MUIMenuitem"
@Toc "MUI-Klassen"

MUIMenusep
==========

     class MUIMenusep : public MUIMenuitem
         {
         public:
             MUIMenusep();
             MUIMenusep(MUIMenusep &);
             virtual ~MUIMenusep();
             MUIMenusep &operator= (const MUIMenusep &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Menu.h

   Diese Klasse ist eine Hilfsklasse um einen Separator-Balken in einem
Menü einfach erstellen zu können.

   *Beispiel:*
     VOID main()
         {
         MUIMenusep sep();
         .
         .
         .
         };


@EndNode

@Node "MUIMenustrip" "TWiMUI.guide/MUIMenustrip"
@Next "MUINotify"
@Prev "MUIMenusep"
@Toc "MUI-Klassen"

MUIMenustrip
============

     class MUIMenustrip : public MUIFamily
         {
         public:
             MUIMenustrip(const struct TagItem *);
             MUIMenustrip(const Tag, ...);
             MUIMenustrip();
             MUIMenustrip(MUIMenustrip &);
             MUIMenustrip(const STRPTR, const Object *, ...);
             MUIMenustrip(const STRPTR, const MUIMenu *, ...);
             virtual ~MUIMenustrip();
             MUIMenustrip &operator= (const MUIMenustrip &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Menu.h

   Dies ist die C++-Klasse für die MUI-Klasse Menustrip. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Menustrip-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Menustrip-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   Für diese Klasse sind noch zwei weitere Konstruktoren
implementiert. Es wird entweder eine Liste von Pointern auf
Menu-Objekte oder eine Liste von Pointern auf Instanzen der
MUIMenu-Klasse übergeben. Beide Listen werden mit NULL terminiert.

   *Beispiel:*
     VOID main()
         {
         MUIMenustrip men(
             MUIA_Menustrip_Enabled, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUINotify" "TWiMUI.guide/MUINotify"
@Next "MUINumeric"
@Prev "MUIMenustrip"
@Toc "MUI-Klassen"

MUINotify
=========

abgeleitete Klassen:
     MUIApplication  (See @{"MUIApplication" Link "MUIApplication"}.)
     MUIArea         (See @{"MUIArea" Link "MUIArea"}.)
     MUIFamily       (See @{"MUIFamily" Link "MUIFamily"}.)
     MUIWindow       (See @{"MUIWindow" Link "MUIWindow"}.)
Include-File:
     classes/TWiMUI/Notify.h

   Dies ist die C++-Klasse für die MUI-Klasse Notify. Von dieser
Klasse kann keine Instanz gebildet werden, da sie als Basisklasse für
andere MUI-Klassen verwendet wird.

   Allgemein verfügbar ist die Methode *Create()*. Diese Methode dient
zum nachträglichen kreieren eines MUI-Objektes, wenn der entsprechende
Konstruktor ohne Parameter aufgerufen wurde. Dieser Methode werden die
Tags übergeben, die notwendig sind um das entsprechende MUI-Objekt zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Für diese Klasse gibt es noch zwei zusätzliche Methoden:
AppClass
     Diese Methode liefert einen Pointer auf eine Instanz der Klasse
     MUIApplication, der dieses Objekt zugeordnet ist.

OwnMethod
     Diese Methode dient dazu um mit C++-Syntax selbstdefinierte
     Methoden auf Instanzen eigener Klassen auszuführen. Dieser
     Methode wird als erster Parameter die eigentlich auszuführenden
     Methode übergeben. Der zweite Parameter gibt die Anzahl der
     darauf folgenden Parameter an. Darauf folgend kommen alle an die
     Methode zu übergebenden Parameter. Die Anzahl kann natürlich
     auch 0 sein. Diese Methode ist z.B. dann nützlich, wenn man einen
     Pointer auf eine Instanz der Klasse MUIWindow über *WinClass()*
     (See @{"MUIArea" Link "MUIArea"}.) bekommen hat diese Klasse aber nur eine Basisklasse
     eines eigenen Windows ist. Dann kann man eine eigene Methode
     folgendermaßen aufrufen:
              WinClass()->OwnMethod(id,2,parm1,parm2);


@EndNode

@Node "MUINumeric" "TWiMUI.guide/MUINumeric"
@Next "MUINumericbutton"
@Prev "MUINotify"
@Toc "MUI-Klassen"

MUINumeric
==========

     class MUINumeric : public MUIArea
         {
         public:
             MUINumeric(const struct TagItem *);
             MUINumeric(const Tag, ...);
             MUINumeric();
             MUINumeric(MUINumeric &);
             virtual ~MUINumeric();
             MUINumeric &operator= (const MUINumeric &);
         };

abgeleitete Klassen:
     MUIKnob           (See @{"MUIKnob" Link "MUIKnob"}.)
     MUILevelmeter     (See @{"MUILevelmeter" Link "MUILevelmeter"}.)
     MUINumericbutton  (See @{"MUINumericbutton" Link "MUINumericbutton"}.)
     MUISlider         (See @{"MUISlider" Link "MUISlider"}.)
Include-File:
     classes/TWiMUI/Numeric.h

   Dies ist die C++-Klasse für die MUI-Klasse Numeric. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Numeric-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine List übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Numeric-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUINumeric num(
             MUIA_Numeric_Min, 0,
             MUIA_Numeric_Max, 20,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUINumericbutton" "TWiMUI.guide/MUINumericbutton"
@Next "MUILabNumericbutton"
@Prev "MUINumeric"
@Toc "MUI-Klassen"

MUINumericbutton
================

     class MUINumericbutton : public MUINumeric
         {
         public:
             MUINumericbutton(const struct TagItem *);
             MUINumericbutton(const Tag, ...);
             MUINumericbutton(const STRPTR, const ULONG, const ULONG);
             MUINumericbutton(const STRPTR, const ULONG, const ULONG, const UBYTE);
             MUINumericbutton();
             MUINumericbutton(MUINumericbutton &);
             virtual ~MUINumericbutton();
             MUINumericbutton &operator= (const MUINumericbutton &);
         };

abgeleitete Klassen:
     MUILabNumericbutton  (See @{"MUILabNumericbutton" Link "MUILabNumericbutton"}.)
Include-File:
     classes/TWiMUI/Numericbutton.h

   Dies ist die C++-Klasse für die MUI-Klasse Numericbutton. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Numericbutton-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Numericbutton-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   Zusätzlich dazu sind noch zwei weitere Konstruktoren implementiert,
die das erstellen von Numericbutton-Objekten vereinfachen. Beiden
werden am Anfang ein Pointer auf einen String übergeben. Dieser String
bezeichnet das printf-Style-Format in welcher Form der Inhalt des
Objektes dargestellt werden soll. Der zweite und dritte Parameter
bezeichnen das Minimum und das Maximum, das dieses Objekt annehmen
darf. Wenn gewünscht, kann dann noch ein UBYTE übergeben werden,
welches dann das Control-Zeichen wird.

   *Beispiel:*
     VOID main()
         {
         MUINumericbutton nb("%ld",0,20);
         .
         .
         .
         };


@EndNode

@Node "MUILabNumericbutton" "TWiMUI.guide/MUILabNumericbutton"
@Next "MUIPalette"
@Prev "MUINumericbutton"
@Toc "MUI-Klassen"

MUILabNumericbutton
===================

     class MUILabNumericbutton
         :   public MUILabelhelp,
             public MUINumericbutton
         {
         public:
             MUILabNumericbutton(const STRPTR, const STRPTR,
                                 const ULONG, const ULONG);
             MUILabNumericbutton();
             MUILabNumericbutton(MUILabNumericbutton &);
             virtual ~MUILabNumericbutton();
             MUILabNumericbutton &operator= (const MUILabNumericbutton &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Numericbutton.h

   Diese Klasse unterstützt noch etwas mehr bei der Erstellung eines
Numericbutton-Objektes. Dem Konstruktor wird als erster Parameter ein
Pointer auf einen String übergeben. Dieser String kann dem Objekt als
Label vorangestellt werden. Ausserdem wird dieser String nach einem
Underscore ("_") untersucht und das darauf folgende Zeichen wird in dem
String unterstrichen dargestellt. Ausserdem wird dieses Zeichen das
Control-Zeichen. Der zweite Parameter ist noch ein Pointer auf einen
String. Dieser String bezeichnet das printf-Style-Format, in welcher
Form der Inhalt des Objektes dargestellt werden soll. Der dritte und
vierte Parameter bezeichnen das Minimum und das Maximum, das dieses
Objekt annehmen darf.

   *Beispiel:*
     VOID main()
         {
         MUILabNumericbutton nb("_Label: ","%ld",0,20);
         .
         .
         .
         };


@EndNode

@Node "MUIPalette" "TWiMUI.guide/MUIPalette"
@Next "MUIPendisplay"
@Prev "MUILabNumericbutton"
@Toc "MUI-Klassen"

MUIPalette
==========

     class MUIPalette : public MUIGroup
         {
         public:
             MUIPalette(const struct TagItem *);
             MUIPalette(const Tag, ...);
             MUIPalette();
             MUIPalette(MUIPalette &);
             virtual ~MUIPalette();
             MUIPalette &operator= (const MUIPalette &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Palette.h

   Dies ist die C++-Klasse für die MUI-Klasse Palette. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Palette-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Palette-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIPalette lv(
             MUIA_Palette_Groupable, TRUE,
                .
                .
                .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIPendisplay" "TWiMUI.guide/MUIPendisplay"
@Next "MUIPopasl"
@Prev "MUIPalette"
@Toc "MUI-Klassen"

MUIPendisplay
=============

     class MUIPendisplay : public MUIArea
         {
         public:
             MUIPendisplay(const struct TagItem *);
             MUIPendisplay(const Tag, ...);
             MUIPendisplay();
             MUIPendisplay(MUIPendisplay &);
             virtual ~MUIPendisplay();
             MUIPendisplay &operator= (const MUIPendisplay &);
         };

abgeleitete Klassen:
     MUIPoppen  (See @{"MUIPoppen" Link "MUIPoppen"}.)
Include-File:
     classes/TWiMUI/Pendisplay.h

   Dies ist die C++-Klasse für die MUI-Klasse Pendisplay. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Pendisplay-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Pendisplay-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   Diese Klasse wird hauptsächlich als Basisklasse für die Klasse
MUIPoppen verwendet.


@EndNode

@Node "MUIPopasl" "TWiMUI.guide/MUIPopasl"
@Next "MUIPopbutton"
@Prev "MUIPendisplay"
@Toc "MUI-Klassen"

MUIPopasl
=========

     class MUIPopasl
         :   public MUIPopstring,
             public MUIPopaslStartHook,
             public MUIPopaslStopHook
         {
         public:
             MUIPopasl(const struct TagItem *);
             MUIPopasl(const Tag, ...);
             MUIPopasl();
             MUIPopasl(MUIPopasl &);
             virtual ~MUIPopasl();
             MUIPopasl &operator= (const MUIPopasl &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Popasl.h

   Dies ist die C++-Klasse für die MUI-Klasse Popasl. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Popasl-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Popasl-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIPopasl pa(
             MUIA_Popasl_Type, ASL_FileRequest,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIPopbutton" "TWiMUI.guide/MUIPopbutton"
@Next "MUIPoplist"
@Prev "MUIPopasl"
@Toc "MUI-Klassen"

MUIPopbutton
============

     class MUIPopbutton : public MUIImage
         {
         public:
             MUIPopbutton(const ULONG);
             MUIPopbutton(MUIPopbutton &);
             virtual ~MUIPopbutton();
             MUIPopbutton &operator= (const MUIPopbutton &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Popbutton.h

   Diese Klasse unterstützt die Erstellung eines Buttons zur
Verwendung in den Pop-Klassen. Dem Konstruktor wird die Nummer eines
vordefinierten Button-Image übergeben.

   *Beispiel:*
     VOID main()
         {
         MUIPopbutton(MUII_PopFile);
         .
         .
         .
         };


@EndNode

@Node "MUIPoplist" "TWiMUI.guide/MUIPoplist"
@Next "MUIPopobject"
@Prev "MUIPopbutton"
@Toc "MUI-Klassen"

MUIPoplist
==========

     class MUIPoplist : public MUIPopobject
         {
         public:
             MUIPoplist(const struct TagItem *);
             MUIPoplist(const Tag, ...);
             MUIPoplist();
             MUIPoplist(MUIPoplist &);
             virtual ~MUIPoplist();
             MUIPoplist &operator= (const MUIPoplist &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Poplist.h

   Dies ist die C++-Klasse für die MUI-Klasse Poplist. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Poplist-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Poplist-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.


@EndNode

@Node "MUIPopobject" "TWiMUI.guide/MUIPopobject"
@Next "MUIPoppen"
@Prev "MUIPoplist"
@Toc "MUI-Klassen"

MUIPopobject
============

     class MUIPopobject
         :   public MUIPopstring,
             public MUIPopobjectObjStrHook,
             public MUIPopobjectStrObjHook,
             public MUIPopobjectStopHook
         {
         public:
             MUIPopobject(const struct TagItem *);
             MUIPopobject(const Tag, ...);
             MUIPopobject();
             MUIPopobject(MUIPopobject &);
             virtual ~MUIPopobject();
             MUIPopobject &operator= (const MUIPopobject &);
         };

abgeleitete Klassen:
     MUIPoplist    (See @{"MUIPoplist" Link "MUIPoplist"}.)
Include-File:
     classes/TWiMUI/Popobject.h

   Dies ist die C++-Klasse für die MUI-Klasse Popobject. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Popobject-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Popobject-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIPopobject po(
             MUIA_Popobject_Follow, TRUE,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIPoppen" "TWiMUI.guide/MUIPoppen"
@Next "MUIPopstring"
@Prev "MUIPopobject"
@Toc "MUI-Klassen"

MUIPoppen
=========

     class MUIPoppen : public MUIPendisplay
         {
         public:
             MUIPoppen(const struct TagItem *);
             MUIPoppen(const Tag, ...);
             MUIPoppen();
             MUIPoppen(MUIPoppen &);
             virtual ~MUIPoppen();
             MUIPoppen &operator= (const MUIPoppen &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Poppen.h

   Dies ist die C++-Klasse für die MUI-Klasse Poppen. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Poppen-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Poppen-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIPoppen pp(
             MUIA_CycleChain  , 1,
             MUIA_Window_Title, "Followed Links Color",
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIPopstring" "TWiMUI.guide/MUIPopstring"
@Next "MUIProp"
@Prev "MUIPoppen"
@Toc "MUI-Klassen"

MUIPopstring
============

     class MUIPopstring
         :   public MUIGroup,
             public MUIPopstringCloseHook,
             public MUIPopstringOpenHook
         {
         public:
             MUIPopstring(const struct TagItem *);
             MUIPopstring(const Tag, ...);
             MUIPopstring();
             MUIPopstring(MUIPopstring &);
             virtual ~MUIPopstring();
             MUIPopstring &operator= (const MUIPopstring &);
         };

abgeleitete Klassen:
     MUIPopasl     (See @{"MUIPopasl" Link "MUIPopasl"}.)
     MUIPopobject  (See @{"MUIPopobject" Link "MUIPopobject"}.)
Include-File:
     classes/TWiMUI/Popstring.h

   Dies ist die C++-Klasse für die MUI-Klasse Popstring. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Popstring-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Popstring-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIPopbutton pb(MUII_PopUp);
         MUIPopstring ps(
             MUIA_Popstring_Button, pb.object(),
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIProp" "TWiMUI.guide/MUIProp"
@Next "MUIRadio"
@Prev "MUIPopstring"
@Toc "MUI-Klassen"

MUIProp
=======

     class MUIProp : public MUIGadget
         {
         public:
             MUIProp(const struct TagItem *);
             MUIProp(const Tag, ...);
             MUIProp();
             MUIProp(MUIProp &);
             virtual ~MUIProp();
             MUIProp &operator= (const MUIProp &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Prop.h

   Dies ist die C++-Klasse für die MUI-Klasse Prop. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Prop-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Prop-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIProp prop(
             MUIA_Prop_Horiz, TRUE,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIRadio" "TWiMUI.guide/MUIRadio"
@Next "MUILabRadio"
@Prev "MUIProp"
@Toc "MUI-Klassen"

MUIRadio
========

     class MUIRadio : public MUIArea
         {
         public:
             MUIRadio(const struct TagItem *);
             MUIRadio(const Tag, ...);
             MUIRadio(const STRPTR);
             MUIRadio(const STRPTR, const UBYTE);
             MUIRadio();
             MUIRadio(MUIRadio &);
             virtual ~MUIRadio();
             MUIRadio &operator= (const MUIRadio &);
         };

abgeleitete Klassen:
     MUILabRadio  (See @{"MUILabRadio" Link "MUILabRadio"}.)
Include-File:
     classes/TWiMUI/Radio.h

   Dies ist die C++-Klasse für die MUI-Klasse Radio. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Radio-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Radio-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Zusätzlich dazu sind noch zwei weitere Konstruktoren implementiert
die das erstellen von Radio-Objekten vereinfachen. Beiden wird ein
Pointer auf ein Array aus String-Pointern übergeben. Diese Strings
definieren sowohl die Anzahl der Radio-Buttons als auch die Bezeichnung
der Buttons. Das Array muß mit NULL terminiert werden. Wenn gewünscht
kann dann noch ein UBYTE übergeben werden, welches dann das
Control-Zeichen wird.

   *Beispiel:*
     VOID main()
         {
         STRPTR array[] =
             {
             "Entry 1",
             "Entry 2",
             "Entry 3",
             NULL
             };
         MUIRadio rad(array);
         .
         .
         .
         };


@EndNode

@Node "MUILabRadio" "TWiMUI.guide/MUILabRadio"
@Next "MUIRectangle"
@Prev "MUIRadio"
@Toc "MUI-Klassen"

MUILabRadio
===========

     class MUILabRadio
         :   public MUILabelhelp,
             public MUIRadio
         {
         public:
             MUILabRadio(const STRPTR, const STRPTR, const ULONG, const ULONG);
             MUILabRadio();
             MUILabRadio(MUILabRadio &);
             virtual ~MUILabRadio();
             MUILabRadio &operator= (const MUILabRadio &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Radio.h

   Diese Klasse unterstützt noch etwas mehr bei der Erstellung eines
Radio-Objektes. Dem Konstruktor wird als erster Parameter ein Pointer
auf einen String übergeben. Dieser String kann dem Objekt als Label
vorangestellt werden. Ausserdem wird dieser String nach einem
Underscore ("_") untersucht und das darauf folgende Zeichen wird in dem
String unterstrichen dargestellt. Ausserdem wird dieses Zeichen das
Control-Zeichen. Der zweite Parameter ist ein Pointer auf ein Array aus
String-Pointern. Diese Strings definieren sowohl die Anzahl der
Radio-Buttons als auch die Bezeichnung der Buttons. Das Array muß mit
NULL terminiert werden.

   *Beispiel:*
     VOID main()
         {
         STRPTR array[] =
             {
             "Entry 1",
             "Entry 2",
             "Entry 3",
             NULL
             };
         MUILabRadio nb("_Label: ",array);
         .
         .
         .
         };


@EndNode

@Node "MUIRectangle" "TWiMUI.guide/MUIRectangle"
@Next "MUIHBar"
@Prev "MUILabRadio"
@Toc "MUI-Klassen"

MUIRectangle
============

     class MUIRectangle : public MUIArea
         {
         public:
             MUIRectangle(const struct TagItem *);
             MUIRectangle(const Tag, ...);
             MUIRectangle();
             MUIRectangle(MUIRectangle &);
             virtual ~MUIRectangle();
             MUIRectangle &operator= (const MUIRectangle &);
         };

abgeleitete Klassen:
     MUIHBar  (See @{"MUIHBar" Link "MUIHBar"}.)
     MUIVBar  (See @{"MUIVBar" Link "MUIVBar"}.)
Include-File:
     classes/TWiMUI/Rectangle.h

   Dies ist die C++-Klasse für die MUI-Klasse Rectangle. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Rectangle-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Rectangle-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIRectangle rec(
             MUIA_Rectangle_BarTitle, "Titel des Rectangles",
             MUIA_Rectangle_HBar,     TRUE,
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIHBar" "TWiMUI.guide/MUIHBar"
@Next "MUIVBar"
@Prev "MUIRectangle"
@Toc "MUI-Klassen"

MUIHBar
=======

     class MUIHBar : public MUIRectangle
         {
         public:
             MUIHBar(const ULONG);
             MUIHBar(MUIHBar &);
             virtual ~MUIHBar();
             MUIHBar &operator= (const MUIHBar &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Rectangle.h

   Diese Klasse ist eine weitere Unterstützung, um horizontalen
Leerraum zu erstellen. Dem Konstruktor wird die Größe des Platzes
übergeben.

   *Beispiel:*
     VOID main()
         {
         MUIHBar hb(50);
         .
         .
         .
         };


@EndNode

@Node "MUIVBar" "TWiMUI.guide/MUIVBar"
@Next "MUIRegister"
@Prev "MUIHBar"
@Toc "MUI-Klassen"

MUIVBar
=======

     class MUIVBar : public MUIRectangle
         {
         public:
             MUIVBar(const ULONG);
             MUIVBar(MUIVBar &);
             virtual ~MUIVBar();
             MUIVBar &operator= (const MUIVBar &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Rectangle.h

   Diese Klasse ist eine weitere Unterstützung, um vertikalen Leerraum
zu erstellen. Dem Konstruktor wird die Größe des Platzes übergeben.

   *Beispiel:*
     VOID main()
         {
         MUIVBar vb(50);
         .
         .
         .
         };


@EndNode

@Node "MUIRegister" "TWiMUI.guide/MUIRegister"
@Next "MUIRequest"
@Prev "MUIVBar"
@Toc "MUI-Klassen"

MUIRegister
===========

     class MUIRegister : public MUIGroup
         {
         public:
             MUIRegister(const struct TagItem *);
             MUIRegister(const Tag, ...);
             MUIRegister();
             MUIRegister(MUIRegister &);
             virtual ~MUIRegister();
             MUIRegister &operator= (const MUIRegister &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Register.h

   Dies ist die C++-Klasse für die MUI-Klasse Register. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Register-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Register-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIRegister reg(
             MUIA_Register_Framed, TRUE,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIRequest" "TWiMUI.guide/MUIRequest"
@Next "MUIScale"
@Prev "MUIRegister"
@Toc "MUI-Klassen"

MUIRequest
==========

     class MUIRequest
         {
         public:
             MUIRequest(const MUIApplication &,
                 const MUIWindow &,
                 const LONGBITS,
                 const STRPTR,
                 const STRPTR,
                 const STRPTR,
                 const ULONG,
                 const ULONG *);
             MUIRequest(const MUIWindow &,
                 const LONGBITS,
                 const STRPTR,
                 const STRPTR,
                 const STRPTR,
                 const ULONG,
                 const ULONG *);
             MUIRequest(const MUIApplication &,
                 const LONGBITS,
                 const STRPTR,
                 const STRPTR,
                 const STRPTR,
                 const ULONG,
                 const ULONG *);
             MUIRequest(const LONGBITS,
                 const STRPTR,
                 const STRPTR,
                 const STRPTR,
                 const ULONG,
                 const ULONG *);
             MUIRequest();
             MUIRequest(MUIRequest &);
             virtual ~MUIRequest();
             MUIRequest &operator= (const MUIRequest &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Request.h

   Dies ist eine Klasse um MUI-Requester leicht erstellen zu können.
Den Konstruktoren können die Parameter wie bei einem MUIRequest-Call
mitgegeben werden. Diese Parameter können, solange der Requester nicht
offen ist, auch mit der entsprechenden set...-Methode noch geändert
werden.

   Geöffnet wird der Requester mit der methode show(). Dieser Methode
kann auch noch eine MUIApplication, ein MUIWindow, beides oder auch
keines der beiden mitgegeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIRequest reg(0L,"Titel","_Ok","Der Wert ist: %ld",wert);
         reg.show(app,win);
         .
         .
         .
         };


@EndNode

@Node "MUIScale" "TWiMUI.guide/MUIScale"
@Next "MUIScrollbar"
@Prev "MUIRequest"
@Toc "MUI-Klassen"

MUIScale
========

     class MUIScale : public MUIArea
         {
         public:
             MUIScale(const struct TagItem *);
             MUIScale(const Tag, ...);
             MUIScale();
             MUIScale(MUIScale &);
             virtual ~MUIScale();
             MUIScale &operator= (const MUIScale &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Scale.h

   Dies ist die C++-Klasse für die MUI-Klasse Scale. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Scale-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Scale-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIScale sc(MUIA_Scale_Horiz, TRUE, TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIScrollbar" "TWiMUI.guide/MUIScrollbar"
@Next "MUIScrollgroup"
@Prev "MUIScale"
@Toc "MUI-Klassen"

MUIScrollbar
============

     class MUIScrollbar : public MUIGroup
         {
         public:
             MUIScrollbar(const struct TagItem *);
             MUIScrollbar(const Tag, ...);
             MUIScrollbar();
             MUIScrollbar(MUIScrollbar &);
             virtual ~MUIScrollbar();
             MUIScrollbar &operator= (const MUIScrollbar &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Scrollbar.h

   Dies ist die C++-Klasse für die MUI-Klasse Scrollbar. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Scrollbar-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Scrollbar-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIScrollbar sb(
             MUIA_Scrollbar_Type, MUIV_Scrollbar_Type_Default,
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIScrollgroup" "TWiMUI.guide/MUIScrollgroup"
@Next "MUISemaphore"
@Prev "MUIScrollbar"
@Toc "MUI-Klassen"

MUIScrollgroup
==============

     class MUIScrollgroup : public MUIGroup
         {
         public:
             MUIScrollgroup(const struct TagItem *);
             MUIScrollgroup(const Tag, ...);
             MUIScrollgroup();
             MUIScrollgroup(MUIScrollgroup &);
             virtual ~MUIScrollgroup();
             MUIScrollgroup &operator= (const MUIScrollgroup &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Scrollgroup.h

   Dies ist die C++-Klasse für die MUI-Klasse Scrollgroup. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Scrollgroup-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Scrollgroup-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIScrollgroup sg(
             MUIA_Scrollgroup_FreeHoriz, TRUE,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUISemaphore" "TWiMUI.guide/MUISemaphore"
@Next "MUISlider"
@Prev "MUIScrollgroup"
@Toc "MUI-Klassen"

MUISemaphore
============

     class MUISemaphore : public MUIArea
         {
         public:
             MUISemaphore(const struct TagItem *);
             MUISemaphore(const Tag, ...);
             MUISemaphore();
             MUISemaphore(MUISemaphore &);
             virtual ~MUISemaphore();
             MUISemaphore &operator= (const MUISemaphore &);
         };

abgeleitete Klassen:
     MUIDataspace  (See @{"MUIDataspace" Link "MUIDataspace"}.)
Include-File:
     classes/TWiMUI/Semaphore.h

   Dies ist die C++-Klasse für die MUI-Klasse Semaphore. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Semaphore-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Semaphore-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUISemaphore se(TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUISlider" "TWiMUI.guide/MUISlider"
@Next "MUILabSlider"
@Prev "MUISemaphore"
@Toc "MUI-Klassen"

MUISlider
=========

     class MUISlider : public MUINumeric
         {
         public:
             MUISlider(const struct TagItem *);
             MUISlider(const Tag, ...);
             MUISlider(const ULONG, const ULONG);
             MUISlider(const ULONG, const ULONG, const UBYTE);
             MUISlider();
             MUISlider(MUISlider &);
             virtual ~MUISlider();
             MUISlider &operator= (const MUISlider &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Slider.h

   Dies ist die C++-Klasse für die MUI-Klasse Slider. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Slider-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Slider-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Zusätzlich dazu sind noch zwei weitere Konstruktoren implementiert,
die das erstellen von Slider-Objekten vereinfachen. Die ersten beiden
Parameter bezeichnen das Minimum und das Maximum, das dieses Objekt
annehmen darf. Wenn gewünscht kann dann noch ein UBYTE übergeben
werden, welches dann das Control-Zeichen wird.

   *Beispiel:*
     VOID main()
         {
         MUISlider sl(0,20);
         .
         .
         .
         };


@EndNode

@Node "MUILabSlider" "TWiMUI.guide/MUILabSlider"
@Next "MUIString"
@Prev "MUISlider"
@Toc "MUI-Klassen"

MUILabSlider
============

     class MUILabSlider
         :   public MUILabelhelp,
             public MUISlider
         {
         public:
             MUILabSlider(const STRPTR, const ULONG, const ULONG);
             MUILabSlider();
             MUILabSlider(MUILabSlider &);
             virtual ~MUILabSlider();
             MUILabSlider &operator= (const MUILabSlider &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Slider.h

   Diese Klasse unterstützt noch etwas mehr bei der Erstellung eines
Slider-Objektes. Dem Konstruktor wird als erster Parameter ein Pointer
auf einen String übergeben. Dieser String kann dem Objekt als Label
vorangestellt werden. Ausserdem wird dieser String nach einem
Underscore ("_") untersucht und das darauf folgende Zeichen wird in dem
String unterstrichen dargestellt. Ausserdem wird dieses Zeichen das
Control-Zeichen. Der zweite und dritte Parameter bezeichnen das Minimum
und das Maximum das dieses Objekt annehmen darf.

   *Beispiel:*
     VOID main()
         {
         MUILabSlider nb("_Label: ","%ld",0,20);
         .
         .
         .
         };


@EndNode

@Node "MUIString" "TWiMUI.guide/MUIString"
@Next "MUILabString"
@Prev "MUILabSlider"
@Toc "MUI-Klassen"

MUIString
=========

     class MUIString
         :   public MUIGadget,
             public MUIStringEditHook
         {
         public:
             MUIString(const struct TagItem *);
             MUIString(const Tag, ...);
             MUIString(const STRPTR, const ULONG);
             MUIString(const STRPTR, const ULONG, const UBYTE);
             MUIString(const ULONG, const ULONG);
             MUIString(const ULONG, const ULONG, const UBYTE);
             MUIString(const ULONG);
             MUIString(const ULONG, const UBYTE);
             MUIString();
             MUIString(MUIString &);
             virtual ~MUIString();
             MUIString &operator= (const MUIString &);
         };

abgeleitete Klassen:
     MUILabString  (See @{"MUILabString" Link "MUILabString"}.)
Include-File:
     classes/TWiMUI/String.h

   Dies ist die C++-Klasse für die MUI-Klasse String. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein String-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das String-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   Zusätzlich dazu sind noch sechs weitere Konstruktoren implementiert
die das erstellen von String- oder Integer-Objekten vereinfachen.

   Die ersten beiden Konstruktoren sind dazu da, um einfache
String-Objekte zu erstellen. Beiden wird als erster Parameter ein
Pointer auf einen String übergeben, welcher dann der Anfangs-Inhalt
des Objektes wird. Der zweite Parameter bezeichnet die maximale Länge
des String-Objektes. Wenn gewünscht, kann dann noch ein UBYTE
angegeben werden. Dieses Zeichen wird dann das Control-Zeichen.

   Die anderen Konstruktoren sind zum Erstellen eines Integer-Objektes
gedacht. Wenn die zwei ersten Parameter beide ULONG-Werte sind, dann
bezeichnet der erste davon den Inhalt des Integer-Objektes und wird in
einen String umgewandelt, damit der Inhalt auch dargestellt werden
kann. Der zweite Parameter bezeichnet dann die maximale Länge des
Objektes. Wird aber nur ein ULONG-Parameter angegeben, so gibt es
keinen Anfangs-Inhalt des Objektes und der angegebene Parameter
bezeichnet die maximale Länge des Objektes. Allen dieser Objekte kann
noch ein UBYTE-Parameter übergeben werden. Dieses Zeichen wird dann
das Control-Zeichen.

   *Beispiel:*
     VOID main()
         {
         MUIString str1("Inhalt 1",20);
         MUIString str2("Inhalt 2",20,'a');
         MUIString int1(5,20);
         .
         .
         .
         };


@EndNode

@Node "MUILabString" "TWiMUI.guide/MUILabString"
@Next "MUIText"
@Prev "MUIString"
@Toc "MUI-Klassen"

MUILabString
============

     class MUILabString
         :   public MUILabelhelp,
             public MUIString
         {
         public:
             MUILabString(const STRPTR, const STRPTR, const ULONG);
             MUILabString(const STRPTR, const ULONG, const ULONG);
             MUILabString();
             MUILabString(MUILabString &);
             virtual ~MUILabString();
             MUILabString &operator= (const MUILabString &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/String.h

   Diese Klasse unterstützt noch etwas mehr bei der Erstellung eines
String-Objektes. Dem Konstruktor wird als erster Parameter ein Pointer
auf einen String übergeben. Dieser String kann dem Objekt als Label
vorangestellt werden. Ausserdem wird dieser String nach einem
Underscore ("_") untersucht und das darauf folgende Zeichen wird in dem
String unterstrichen dargestellt. Ausserdem wird dieses Zeichen das
Control-Zeichen. Der zweite Parameter ist dann entweder wieder ein
Pointer auf einen String oder aber ein ULONG. Ist dieser Parameter ein
Pointer auf einen String, so wird dieser String der Inhalt des
String-Objektes. Ist es ein ULONG-Wert, so wird dieser umgewandelt in
einen String und dieser dann der Inhalt des Objektes. Ausserdem wird
das Objekt ein Integer-Objekt. Der dritte Parameter ist ein ULONG-Wert,
welcher die maximale Länge des Objektes angibt.

   *Beispiel:*
     VOID main()
         {
         MUILabString str1("_Label: ","Inhalt",20);
         MUILabString int1("_Label: ",5,20);
         .
         .
         .
         };


@EndNode

@Node "MUIText" "TWiMUI.guide/MUIText"
@Next "MUIVirtgroup"
@Prev "MUILabString"
@Toc "MUI-Klassen"

MUIText
=======

     class MUIText : public MUIArea
         {
         public:
             MUIText(const struct TagItem *);
             MUIText(const Tag, ...);
             MUIText();
             MUIText(MUIText &);
             virtual ~MUIText();
             MUIText &operator= (const MUIText &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Text.h

   Dies ist die C++-Klasse für die MUI-Klasse Text. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Text-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Text-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIText tct(
             MUIA_Text_Contents, "Inhalt des Textes",
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIVirtgroup" "TWiMUI.guide/MUIVirtgroup"
@Next "MUIVolumelist"
@Prev "MUIText"
@Toc "MUI-Klassen"

MUIVirtgroup
============

     class MUIVirtgroup : public MUIGroup
         {
         public:
             MUIVirtgroup(const struct TagItem *);
             MUIVirtgroup(const Tag, ...);
             MUIVirtgroup();
             MUIVirtgroup(MUIVirtgroup &);
             virtual ~MUIVirtgroup();
             MUIVirtgroup &operator= (const MUIVirtgroup &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Virtgroup.h

   Dies ist die C++-Klasse für die MUI-Klasse Virtgroup. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Virtgroup-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Virtgroup-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIVirtgroup vg(
             MUIA_Virtgroup_Input, FALSE,
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIVolumelist" "TWiMUI.guide/MUIVolumelist"
@Next "MUIWindow"
@Prev "MUIVirtgroup"
@Toc "MUI-Klassen"

MUIVolumelist
=============

     class MUIVolumelist : public MUIList
         {
         public:
             MUIVolumelist(const struct TagItem *);
             MUIVolumelist(const Tag, ...);
             MUIVolumelist();
             MUIVolumelist(MUIVolumelist &);
             virtual ~MUIVolumelist();
             MUIVolumelist &operator= (const MUIVolumelist &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Volumelist.h

   Dies ist die C++-Klasse für die MUI-Klasse Volumelist. Den
Konstruktoren werden die Tags übergeben, die notwendig sind um ein
Volumelist-Object zu erstellen. Dabei können die Tags als variable
Parameter oder auch als Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Volumelist-Object zu erstellen. Dieser Methode können
auch variable Taglisten oder ein Pointer auf eine Tagliste übergeben
werden.

   *Beispiel:*
     VOID main()
         {
         MUIVolumelist vl(TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "MUIWindow" "TWiMUI.guide/MUIWindow"
@Prev "MUIVolumelist"
@Toc "MUI-Klassen"

MUIWindow
=========

     class MUIWindow : public MUINotify
         {
         public:
             MUIWindow(const struct TagItem *);
             MUIWindow(const Tag, ...);
             MUIWindow();
             MUIWindow(MUIWindow &);
             virtual ~MUIWindow();
             MUIWindow &operator= (const MUIWindow &);
         };

abgeleitete Klassen:
     keine

Include-File:
     classes/TWiMUI/Window.h

   Dies ist die C++-Klasse für die MUI-Klasse Window. Den Konstruktoren
werden die Tags übergeben, die notwendig sind um ein Window-Object zu
erstellen. Dabei können die Tags als variable Parameter oder auch als
Pointer auf eine Liste übergeben werden.

   Alternativ kann auch der Konstruktor ohne Parameter benutzt werden.
In diesem Fall muß die Methode *Create()* (See @{"MUINotify" Link "MUINotify"}.) benutzt
werden um das Window-Object zu erstellen. Dieser Methode können auch
variable Taglisten oder ein Pointer auf eine Tagliste übergeben werden.

   *Beispiel:*
     VOID main()
         {
         MUIWindow win(
             MUIA_Window_Title, "Window-Titel",
             .
             .
             .
             TAG_DONE);
         .
         .
         .
         };


@EndNode

@Node "inline-Funktionen" "TWiMUI.guide/inline-Funktionen"
@Prev "MUI-Klassen"
@Toc "Klassen"

inline-Funkionen
================

   Hier sind einige Funktionen aufgeführt, die per inline definiert
wurden. Es handelt sich dabei um einige der Aufrufe der
MUI_MakeObject()-Funktion. Diese Aufrufe wurden hier neu definiert,
damit eine effektive Typprüfung stattfinden kann. Es muß beachtet
werden, daß mit diesen Funktionen erstellte Objekte nicht automatisch
wieder destruiert werden, da es keinen Destruktor dafür gibt. Sie
sollten deshalb nur in einer Parameter-Liste bei der Erstellung eines
anderen Objektes aufgerufen werden. Diese Funktionen sind deshalb auch
nur für Objekte definiert, die normalerweise keine Methoden benutzen
oder keine weiteren Attribute haben.

   Für die genaue Bedeutung dieser Objekte lesen Sie bitte die
MUI-Dokumentation.

     inline Object *MakeLabel(const STRPTR lab)
     inline Object *MakeLabel1(const STRPTR lab)
     inline Object *MakeLabel2(const STRPTR lab)
     inline Object *MakeLLabel(const STRPTR lab)
     inline Object *MakeLLabel1(const STRPTR lab)
     inline Object *MakeLLabel2(const STRPTR lab)
     inline Object *MakeCLabel(const STRPTR lab)
     inline Object *MakeCLabel1(const STRPTR lab)
     inline Object *MakeCLabel2(const STRPTR lab)
     inline Object *MakeFreeLabel(const STRPTR lab)
     inline Object *MakeFreeLabel1(const STRPTR lab)
     inline Object *MakeFreeLabel2(const STRPTR lab)
     inline Object *MakeFreeLLabel(const STRPTR lab)
     inline Object *MakeFreeLLabel1(const STRPTR lab)
     inline Object *MakeFreeLLabel2(const STRPTR lab)
     inline Object *MakeFreeCLabel(const STRPTR lab)
     inline Object *MakeFreeCLabel1(const STRPTR lab)
     inline Object *MakeFreeCLabel2(const STRPTR lab)
     inline Object *MakeKeyLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyLLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyLLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyLLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyCLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyCLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeKeyCLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyLLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyCLabel(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyCLabel1(const STRPTR lab, const UBYTE key)
     inline Object *MakeFreeKeyCLabel2(const STRPTR lab, const UBYTE key)
     inline Object *MakeHBar(const ULONG size)
     inline Object *MakeVBar(const ULONG size)
     inline Object *MakeHSpace(const ULONG size)
     inline Object *MakeVSpace(const ULONG size)

   Zusätzlich zu diesen Funktionen gibt es noch eine Funktion die es
ermöglicht relativ einfach eine Id (z.B. MUIA_Window_ID) zu erstellen.

     inline ULONG MakeId(const UBYTE a, const UBYTE b,
                         const UBYTE c, const UBYTE d)


@EndNode

@Node "Interface" "TWiMUI.guide/Interface"
@Next "Danksagungen"
@Prev "Klassen"
@Toc "Main"

Interface
*********

   Hier versuche ich jetzt zu beschreiben wie eigene Klassen für
*public custom classes* geschrieben werden können. Das werde ich
anhand eines Beispiels tun. Und zwar anhand einer Klasse für
*Busy.mcc*.

   Deshalb hier zuerst einmal das dazugehörige Header-File:
     class MUIBusy : public MUIArea
         {
         protected:
             virtual const ULONG ClassNum() const;
         public:
             MUIBusy(const struct TagItem *t) : MUIArea(MUIC_Busy) { init(t); };
             MUIBusy(const Tag t, ...);
             MUIBusy() : MUIArea(MUIC_Busy) { };
             MUIBusy(const MUIBusy &);
             virtual ~MUIBusy();
             MUIBusy &operator= (const MUIBusy &);
             VOID Speed(const LONG p) { set(MUIA_Busy_Speed,(ULONG)p); };
             VOID SpeedOff() { set(MUIA_Busy_Speed,MUIV_Busy_Speed_Off); };
             VOID SpeedUser() { set(MUIA_Busy_Speed,MUIV_Busy_Speed_User); };
             LONG Speed() const { return((LONG)get(MUIA_Busy_Speed,0L)); };
             VOID Move() { dom(MUIM_Busy_Move); };
         };

   Kommen wir nun zu Erklärung der Basisklasse und der einzelnen
Methoden (wenn etwas unklar ist, seht bitte im mitgelieferten Source
nach, oder setzt Euch mit mir (See @{"Author" Link "Author"}.) in Verbindung):

MUIArea
     Dies ist die Basisklasse für *MUIBusy*. Da Busy.mcc als
     Basisklasse Area.mcc hat ist das nur logisch.

ClassNum()
     Damit im Fehlerfalle beim Werfen der Exception *MUIErrorX* die
     korrekte Konstante *MUIV_TWiMUI_MUIErrorX_xxxx* benutzt wird ist
     diese Methode definiert. *xxxx* bedeutet dabei die Klasse welche
     die Exception ausgelöst hat. Für selbstdefinierte Klassen
     schlage ich vor, daß nur Zahlen ab 1025 und aufwärts verwendet
     werden. Das sollte ausreichen um keine Probleme mit künftigen
     MUI-Standardklassen zu bekommen.

MUIBusy(const struct TagItem *t) : MUIArea(MUIC_Busy) { init(t); };
     Dieser Konstruktor initialisiert zuerst die Klasse MUIArea und
     übergibt ihr seinen Namen damit die MUI-SubClass von der korrekten
     Klasse erstellt wird. Danach wird die Adresse der TagItem-Struktur
     an die Methode *init()* übergeben, die dann ein Object mit den
     angegebenen Parametern erstellt. Tritt dabei ein Fehler auf wird
     die Exception *MUIErrorX* (See @{"MUIErrorX" Link "MUIErrorX"}.) ausgeworfen.

MUIBusy(const Tag t, ...);
     Dieser Konstruktor initialisiert zuerst die Klasse MUIArea und
     übergibt ihr seinen Namen damit die MUI-SubClass von der korrekten
     Klasse erstellt wird. Danach werden die angegebenen Parameter
     unter Zuhilfenahme der Standardmakros zusammengesammelt und damit
     eine Instanz der Klasse *TWiTag* (See @{"TWiTag" Link "TWiTag"}.) gebildet. Die
     Adresse der dadurch erstellten TagItem-Struktur wird an die
     Methode *init()* übergeben, die dann ein Object mit den
     angegebenen Parametern erstellt. Tritt dabei ein Fehler auf wird
     die Exception *MUIErrorX* (See @{"MUIErrorX" Link "MUIErrorX"}.) ausgeworfen.

MUIBusy() : MUIArea(MUIC_Busy) { };
     Dieser Konstruktor initialisiert zuerst die Klasse MUIArea und
     übergibt ihr seinen Namen damit die MUI-SubClass von der korrekten
     Klasse erstellt wird. Tritt dabei ein Fehler auf wird die
     Exception *MUIErrorX* (See @{"MUIErrorX" Link "MUIErrorX"}.) ausgeworfen. Ein Objekt
     dieser Klasse wird mit diesem Konstruktor nicht erstellt. Das muß
     später mit der Methode *Create()* der Klasse *MUINotify* (See
     @{"MUINotify" Link "MUINotify"}.) nachgehohlt werden.

MUIBusy(const MUIBusy &);
     Der Copy-Konstruktor initialisiert zuerst die Klasse MUIArea und
     übergibt ihr seinen Namen damit die MUI-SubClass von der korrekten
     Klasse erstellt wird. Danach wird die Instanz der Klasse TWiTag
     der Parameter-Instanz kopiert und die Methode init() aufgerufen um
     ein Objekt zu erstellen. Tritt dabei ein Fehler auf wird die
     Exception *MUIErrorX* (See @{"MUIErrorX" Link "MUIErrorX"}.) ausgeworfen.

~MUIBusy();
     Der Destruktor hat standardmäßig keine besonderen Funktionen zu
     erfüllen.

MUIBusy &operator= (const MUIBusy &);
     Dieser operator prüft zuerst ob die Zuweisung auf sich selbst
     erfolgt. Ist dies der Fall wird nichts gemacht. Muß etwas getan
     werden, so wird zuerst der operator= der Basisklasse MUIArea
     aufgerufen. Danach wird die TWiTag-Instanz der Parameter-Instanz
     kopiert um dann die Methode init() aufzurufen damit das Objekt
     erstellt wird.

VOID Speed(const LONG p) { set(MUIA_Busy_Speed,(ULONG)p); };
     Diese Methode setzt das Attribut MUIA_Busy_Speed mit dem
     angegebenen Parameter. Dafür wird die Methode *set()* der Klasse
     *MUINotify* (See @{"MUINotify" Link "MUINotify"}.) verwendet. Diese ruft die
     Intuition-Funktion SetAttrs mit dem Object-Pointer dieser Klasse,
     MUIA_Busy_Speed als Attribut und dem angegebenen Parameter als
     Wert auf. Ist der Pointer NULL so wird nichts gemacht.

VOID SpeedOff() { set(MUIA_Busy_Speed,MUIV_Busy_Speed_Off); };
     Diese Methode ist fast die gleiche wie die Methode *Speed* nur das
     als Parameter der Methode *set* fest der vordefinierte Wert
     MUIV_Busy_Speed_Off übergeben wird.

VOID SpeedUser() { set(MUIA_Busy_Speed,MUIV_Busy_Speed_User); };
     Diese Methode ist fast die gleiche wie die Methode *Speed* nur das
     als Parameter der Methode *set* fest der vordefinierte Wert
     MUIV_Busy_Speed_User übergeben wird.

LONG Speed() { return((LONG)get(MUIA_Busy_Speed,0L); };
     Diese Methode liest das Attribut MUIA_Busy_Speed. Dafür wird die
     Methode *get()* der Klasse *MUINotify* (See @{"MUINotify" Link "MUINotify"}.) verwendet.
     Diese ruft die Intuition-Funktion GetAttr mit dem Object-Pointer
     dieser Klasse und MUIA_Busy_Speed als Attribut auf. Der Wert von
     GetAttr() wird zurückgegeben. Ist der Pointer NULL so wird der
     zweite Parameter als Default-Parameter zurückgegeben.

VOID Move() { dom(MUIM_Busy_Move); };
     Diese Methode führt die Methode MUIM_Busy_Move aus. Dafür wird
     die Methode *dom()* der Klasse *MUINotify* (See @{"MUINotify" Link "MUINotify"}.)
     verwendet. Diese ruft die Intuition-Funktion DoMethodA mit dem
     Object-Pointer dieser Klasse und MUIM_Busy_Move als MethodID auf.
     Der Wert von DoMethodA() wird zurückgegeben. Ist der Pointer NULL
     so wird 0UL zurückgegeben. Die Methode *dom()* ist in der Klasse
     *MUINotify* (See @{"MUINotify" Link "MUINotify"}.) mit der Parameter-Anzahl von 0 bis 7
     definiert. Zum Beispiel benötigt die Methode *Exchange* der
     Klasse *MUIList* (See @{"MUIList" Link "MUIList"}.) 2 Parameter. Also ist sie
     folgendermaßen definiert:
          VOID Exchange(LONG p1, LONG p2) { dom(MUIM_List_Exchange,p1,p2); };


@EndNode

@Node "Danksagungen" "TWiMUI.guide/Danksagungen"
@Next "Author"
@Prev "Interface"
@Toc "Main"

Danksagungen
************

   Als erstes muß ich natürlich meiner Frau danken, die mich teilweise
gar nicht mehr gesehen hat.

   Als nächstes den Entwicklern von StormC, die es ermöglichen ein
C++-Programm mit allen Sprachelementen auf dem AMIGA zu erstellen.

   Und natürlich allen Anderen die mit Kritik und Anregungen zum
Erstellen der Bibliothek beigetragen haben.


@EndNode

@Node "Author" "TWiMUI.guide/Author"
@Next "MUI"
@Prev "Danksagungen"
@Toc "Main"

Author
******

   Für Anregungen, konstruktive Kritik und eventuelle Fragen bin ich
auf folgenden Wegen zu erreichen:

Brief-Post
     Thomas Wilhelmi
     Taunusstraße 14
     D - 61138 Niederdorfelden
Fax
     06101/531061

E-mail
     willi@twi.rhein-main.de

   Bei Fragen, Kritik oder Anregungen braucht niemand Hemmungen zu haben
und kann sich gerne jederzeit an mich wenden. Bevorzugt behandelt
werden natürlich E-Mail-Anfragen.

   Ich bin auch Teilnehmer an der MUI Mailingliste.


@EndNode

@Node "MUI" "TWiMUI.guide/MUI"
@Next "Registrierung"
@Prev "Author"
@Toc "Main"

MUI
***

   MUI ist ein System zum einfacheren Programmieren und sehr
komfortablen Konfigurieren einer GUI.

   MUI ist Shareware. Eine unregistrierte Version laesst sich vom
AmiNet oder auch aus diversen Mailboxen beziehen.

   MUI ist (C) 1993/94 Stefan Stuntz.

   Bei ihm kann man sich auch mit der Übersendung von 30,-- DM als
Benutzer registrieren lassen:

                             Stefan Stuntz

                       Eduard-Spranger-Straße 7

                            D-80935 München


@EndNode

@Node "Registrierung" "TWiMUI.guide/Registrierung"
@Next "Einschränkung"
@Prev "MUI"
@Toc "Main"

Registrierung
*************

   Bitte füllen Sie das beiliegende Formular aus und senden Sie es per
E-Mail, Fax oder Brief an mich (See @{"Author" Link "Author"}.).

   Wenn sich jemand bereit erklären würde, diese Dokumentation zu
übersetzen, braucht derjenige natürlich keine Registrierungs-Gebühr
zu bezahlen. Aber ich bitte um vorherige Kontaktaufnahme.

      Registrierung
     
     
      Hiermit möchte ich mich für TWiMUI registrieren lassen.
     
      Vorname:_____________________________________________________
     
      Name:________________________________________________________
     
      Straße:______________________________________________________
     
      PLZ:__________ Ort:__________________________________________
     
      Telefon:_____________________________________________________
     
      EMail:_______________________________________________________
     
     
      Gewünschte Zahlungsweise bitte ankreuzen:
     
      *       per Nachnahme (DM 40,-, nicht ins Ausland)
     
      *       per beiliegendem Vorauskasse-Scheck mit Brief-Versand
              einer Diskette (DM 30,- in Deutschland, DM 35,- in Europa,
              DM 40,- Rest der Welt)
     
      *       per Überweisung mit Brief-Versand einer Diskette (DM 30,-
              in Deutschland, DM 35,- in Europa, DM 40,- Rest der Welt)
     
      *       per beiliegendem Vorauskasse-Scheck mit E-Mail-Versand
              (DM 30,-)
     
      *       per Überweisung mit E-Mail-Versand (DM 30,-)
     
      *       Diese Dokumentation in gedruckter Form beim Briefversand
              beilegen (zzgl. DM 10,-)
     
      Meine Bankverbindung:
      Postgiroamt Ffm
      Kontonummer 3973 35-603
      BLZ 500 100 60


@EndNode

@Node "Einschränkung" "TWiMUI.guide/Einschränkung"
@Next "Haftungsausschluß"
@Prev "Registrierung"
@Toc "Main"

Einschränkung
*************

   In der unregistrierten Version befindet sich eine Einschränkung im
Vergleich zur registrierten Vollversion. Und zwar ist es nur möglich,
40 Objekte in einem Programm zu kreieren. Wenn versucht wird, mehr
Objekte zu kreieren, so wird die Exception MUIErrorX mit dem Typ 999
geworfen.

   Ansonsten gibt es keine weiteren Einschränkungen.


@EndNode

@Node "Haftungsausschluß" "TWiMUI.guide/Haftungsausschluß"
@Next "Index"
@Prev "Einschränkung"
@Toc "Main"

Haftungsausschluß
*****************

   Durch die Verwendung dieses Programms akzeptiert der Benutzer die
volle Verantwortung für alle Schäden, die durch seine Benutzung oder
das Unvermögen seiner Benutzung auftreten können. Der Entwickler
dieser Software kann nicht verantwortlich gemacht werden.


@EndNode

@Node "Index" "TWiMUI.guide/Index"
@Prev "Haftungsausschluß"
@Toc "Main"

Index
*****



 @{" Aboutmui " Link "MUIAboutmui"}                             MUIAboutmui
 @{" Anforderungen " Link "Anforderungen"}                        Anforderungen
 @{" Application " Link "MUIApplication"}                          MUIApplication
 @{" ApplicationBrokerHook " Link "MUIApplicationBrokerHook"}                MUIApplicationBrokerHook
 @{" ApplicationRexxHook " Link "MUIApplicationRexxHook"}                  MUIApplicationRexxHook
 @{" Area " Link "MUIArea"}                                 MUIArea
 @{" Array " Link "TWiArray"}                                TWiArray
 @{" ArrayCursor " Link "TWiArrayCursor"}                          TWiArrayCursor
 @{" Attribut " Link "MUI-Klassen"}                             MUI-Klassen
 @{" Balance " Link "MUIBalance"}                              MUIBalance
 @{" Basisklassen " Link "MUI-Basisklassen"}                         MUI-Basisklassen
 @{" Basisklassen " Link "Hilfsklassen"}                         Hilfsklassen
 @{" Bitmap " Link "MUIBitmap"}                               MUIBitmap
 @{" Bodychunk " Link "MUIBodychunk"}                            MUIBodychunk
 @{" Boopsi " Link "MUIBoopsi"}                               MUIBoopsi
 @{" BrokerHook " Link "MUIApplicationBrokerHook"}                           MUIApplicationBrokerHook
 @{" Buffer " Link "TWiBuffer"}                               TWiBuffer
 @{" Button " Link "MUIButton"}                               MUIButton
 @{" Checkmark " Link "MUICheckmark"}                            MUICheckmark
 @{" CloseHook " Link "MUIPopstringCloseHook"}                            MUIPopstringCloseHook
 @{" Coloradjust " Link "MUIColoradjust"}                          MUIColoradjust
 @{" Colorfield " Link "MUIColorfield"}                           MUIColorfield
 @{" CompareHook " Link "MUIListCompareHook"}                          MUIListCompareHook
 @{" ConstructHook " Link "MUIListConstructHook"}                        MUIListConstructHook
 @{" Cycle " Link "MUICycle"}                                MUICycle
 @{" Danksagungen " Link "Danksagungen"}                         Danksagungen
 @{" Dataspace " Link "MUIDataspace"}                            MUIDataspace
 @{" DestructHook " Link "MUIListDestructHook"}                         MUIListDestructHook
 @{" Dirlist " Link "MUIDirlist"}                              MUIDirlist
 @{" DirlistFilterHook " Link "MUIDirlistFilterHook"}                    MUIDirlistFilterHook
 @{" Dispatcher " Link "UserDispatch"}                           UserDispatch
 @{" DisplayHook " Link "MUIListDisplayHook"}                          MUIListDisplayHook
 @{" EditHook " Link "MUIStringEditHook"}                             MUIStringEditHook
 @{" Einschränkung " Link "Einschränkung"}                      Einschränkung
 @{" Exception-Klasse " Link "MUIErrorX"}                     MUIErrorX
 @{" Family " Link "MUIFamily"}                               MUIFamily
 @{" FilterHook " Link "MUIDirlistFilterHook"}                           MUIDirlistFilterHook
 @{" Floattext " Link "MUIFloattext"}                            MUIFloattext
 @{" Format " Link "TWiFormat"}                               TWiFormat
 @{" Gadget " Link "MUIGadget"}                               MUIGadget
 @{" Gauge " Link "MUIGauge"}                                MUIGauge
 @{" Group " Link "MUIGroup"}                                MUIGroup
 @{" GroupCol " Link "MUIGroupCol"}                             MUIGroupCol
 @{" GroupH " Link "MUIGroupH"}                               MUIGroupH
 @{" GroupLayoutHook " Link "MUIGroupLayoutHook"}                      MUIGroupLayoutHook
 @{" GroupRow " Link "MUIGroupRow"}                             MUIGroupRow
 @{" GroupV " Link "MUIGroupV"}                               MUIGroupV
 @{" Haftungsausschluß " Link "Haftungsausschluß"}                  Haftungsausschluß
 @{" HBar " Link "MUIHBar"}                                 MUIHBar
 @{" Image " Link "MUIImage"}                                MUIImage
 @{" inline-Funktionen " Link "inline-Funktionen"}                    inline-Funktionen
 @{" Interface " Link "Interface"}                            Interface
 @{" Klassen " Link "Klassen"}                              Klassen
 @{" Knob " Link "MUIKnob"}                                 MUIKnob
 @{" LabButton " Link "MUILabButton"}                            MUILabButton
 @{" LabCheckmark " Link "MUILabCheckmark"}                         MUILabCheckmark
 @{" LabCycle " Link "MUILabCycle"}                             MUILabCycle
 @{" Label " Link "MUILabel"}                                MUILabel
 @{" LabelHelp " Link "MUILabelHelp"}                            MUILabelHelp
 @{" LabNumericbutton " Link "MUILabNumericbutton"}                     MUILabNumericbutton
 @{" LabRadio " Link "MUILabRadio"}                             MUILabRadio
 @{" LabSlider " Link "MUILabSlider"}                            MUILabSlider
 @{" LabString " Link "MUILabString"}                            MUILabString
 @{" LayoutHook " Link "MUIGroupLayoutHook"}                           MUIGroupLayoutHook
 @{" Levelmeter " Link "MUILevelmeter"}                           MUILevelmeter
 @{" List " Link "MUIList"}                                 MUIList
 @{" ListCompareHook " Link "MUIListCompareHook"}                      MUIListCompareHook
 @{" ListConstructHook " Link "MUIListConstructHook"}                    MUIListConstructHook
 @{" ListDestructHook " Link "MUIListDestructHook"}                     MUIListDestructHook
 @{" ListDisplayHook " Link "MUIListDisplayHook"}                      MUIListDisplayHook
 @{" ListMultiTestHook " Link "MUIListMultiTestHook"}                    MUIListMultiTestHook
 @{" Listview " Link "MUIListview"}                             MUIListview
 @{" MemX " Link "TWiMemX"}                                 TWiMemX
 @{" Menu " Link "MUIMenu"}                                 MUIMenu
 @{" Menuitem " Link "MUIMenuitem"}                             MUIMenuitem
 @{" Menusep " Link "MUIMenusep"}                              MUIMenusep
 @{" Menustrip " Link "MUIMenustrip"}                            MUIMenustrip
 @{" Methode " Link "MUI-Klassen"}                              MUI-Klassen
 @{" MUI " Link "MUI"}                                  MUI
 @{" MUI-Attribut " Link "MUI-Klassen"}                         MUI-Klassen
 @{" MUI-Basisklassen " Link "MUI-Basisklassen"}                     MUI-Basisklassen
 @{" MUI-Basisklassen " Link "Hilfsklassen"}                     Hilfsklassen
 @{" MUI-Klassen " Link "MUI-Klassen"}                          MUI-Klassen
 @{" MUI-Methode " Link "MUI-Klassen"}                          MUI-Klassen
 @{" MUIAboutmui " Link "MUIAboutmui"}                          MUIAboutmui
 @{" MUIApplication " Link "MUIApplication"}                       MUIApplication
 @{" MUIApplicationBrokerHook " Link "MUIApplicationBrokerHook"}             MUIApplicationBrokerHook
 @{" MUIApplicationRexxHook " Link "MUIApplicationRexxHook"}               MUIApplicationRexxHook
 @{" MUIArea " Link "MUIArea"}                              MUIArea
 @{" MUIBalance " Link "MUIBalance"}                           MUIBalance
 @{" MUIBitmap " Link "MUIBitmap"}                            MUIBitmap
 @{" MUIBodychunk " Link "MUIBodychunk"}                         MUIBodychunk
 @{" MUIBoopsi " Link "MUIBoopsi"}                            MUIBoopsi
 @{" MUIButton " Link "MUIButton"}                            MUIButton
 @{" MUICheckmark " Link "MUICheckmark"}                         MUICheckmark
 @{" MUIColoradjust " Link "MUIColoradjust"}                       MUIColoradjust
 @{" MUIColorfield " Link "MUIColorfield"}                        MUIColorfield
 @{" MUICycle " Link "MUICycle"}                             MUICycle
 @{" MUIDataspace " Link "MUIDataspace"}                         MUIDataspace
 @{" MUIDirlist " Link "MUIDirlist"}                           MUIDirlist
 @{" MUIDirlistFilterHook " Link "MUIDirlistFilterHook"}                 MUIDirlistFilterHook
 @{" MUIErrorX " Link "MUIErrorX"}                            MUIErrorX
 @{" MUIFamily " Link "MUIFamily"}                            MUIFamily
 @{" MUIFloattext " Link "MUIFloattext"}                         MUIFloattext
 @{" MUIGadget " Link "MUIGadget"}                            MUIGadget
 @{" MUIGauge " Link "MUIGauge"}                             MUIGauge
 @{" MUIGroup " Link "MUIGroup"}                             MUIGroup
 @{" MUIGroupCol " Link "MUIGroupCol"}                          MUIGroupCol
 @{" MUIGroupH " Link "MUIGroupH"}                            MUIGroupH
 @{" MUIGroupLayoutHook " Link "MUIGroupLayoutHook"}                   MUIGroupLayoutHook
 @{" MUIGroupRow " Link "MUIGroupRow"}                          MUIGroupRow
 @{" MUIGroupV " Link "MUIGroupV"}                            MUIGroupV
 @{" MUIHBar " Link "MUIHBar"}                              MUIHBar
 @{" MUIImage " Link "MUIImage"}                             MUIImage
 @{" MUIKnob " Link "MUIKnob"}                              MUIKnob
 @{" MUILabButton " Link "MUILabButton"}                         MUILabButton
 @{" MUILabCheckmark " Link "MUILabCheckmark"}                      MUILabCheckmark
 @{" MUILabCycle " Link "MUILabCycle"}                          MUILabCycle
 @{" MUILabel " Link "MUILabel"}                             MUILabel
 @{" MUILabelHelp " Link "MUILabelHelp"}                         MUILabelHelp
 @{" MUILabNumericbutton " Link "MUILabNumericbutton"}                  MUILabNumericbutton
 @{" MUILabRadio " Link "MUILabRadio"}                          MUILabRadio
 @{" MUILabSlider " Link "MUILabSlider"}                         MUILabSlider
 @{" MUILabString " Link "MUILabString"}                         MUILabString
 @{" MUILevelmeter " Link "MUILevelmeter"}                        MUILevelmeter
 @{" MUIList " Link "MUIList"}                              MUIList
 @{" MUIListCompareHook " Link "MUIListCompareHook"}                   MUIListCompareHook
 @{" MUIListConstructHook " Link "MUIListConstructHook"}                 MUIListConstructHook
 @{" MUIListDestructHook " Link "MUIListDestructHook"}                  MUIListDestructHook
 @{" MUIListDisplayHook " Link "MUIListDisplayHook"}                   MUIListDisplayHook
 @{" MUIListMultiTestHook " Link "MUIListMultiTestHook"}                 MUIListMultiTestHook
 @{" MUIListview " Link "MUIListview"}                          MUIListview
 @{" MUIMenu " Link "MUIMenu"}                              MUIMenu
 @{" MUIMenuitem " Link "MUIMenuitem"}                          MUIMenuitem
 @{" MUIMenusep " Link "MUIMenusep"}                           MUIMenusep
 @{" MUIMenustrip " Link "MUIMenustrip"}                         MUIMenustrip
 @{" MUINotify " Link "MUINotify"}                            MUINotify
 @{" MUINumeric " Link "MUINumeric"}                           MUINumeric
 @{" MUINumericbutton " Link "MUINumericbutton"}                     MUINumericbutton
 @{" MUIPalette " Link "MUIPalette"}                           MUIPalette
 @{" MUIPendisplay " Link "MUIPendisplay"}                        MUIPendisplay
 @{" MUIPopasl " Link "MUIPopasl"}                            MUIPopasl
 @{" MUIPopaslStartHook " Link "MUIPopaslStartHook"}                   MUIPopaslStartHook
 @{" MUIPopaslStopHook " Link "MUIPopaslStopHook"}                    MUIPopaslStopHook
 @{" MUIPopbutton " Link "MUIPopbutton"}                         MUIPopbutton
 @{" MUIPoplist " Link "MUIPoplist"}                           MUIPoplist
 @{" MUIPopobject " Link "MUIPopobject"}                         MUIPopobject
 @{" MUIPopobjectObjStrHook " Link "MUIPopobjectObjStrHook"}               MUIPopobjectObjStrHook
 @{" MUIPopobjectStrObjHook " Link "MUIPopobjectStrObjHook"}               MUIPopobjectStrObjHook
 @{" MUIPopobjectWindowHook " Link "MUIPopobjectWindowHook"}               MUIPopobjectWindowHook
 @{" MUIPoppen " Link "MUIPoppen"}                            MUIPoppen
 @{" MUIPopstring " Link "MUIPopstring"}                         MUIPopstring
 @{" MUIPopstringCloseHook " Link "MUIPopstringCloseHook"}                MUIPopstringCloseHook
 @{" MUIPopstringOpenHook " Link "MUIPopstringOpenHook"}                 MUIPopstringOpenHook
 @{" MUIProp " Link "MUIProp"}                              MUIProp
 @{" MUIRadio " Link "MUIRadio"}                             MUIRadio
 @{" MUIRectangle " Link "MUIRectangle"}                         MUIRectangle
 @{" MUIRegister " Link "MUIRegister"}                          MUIRegister
 @{" MUIRequest " Link "MUIRequest"}                           MUIRequest
 @{" MUIScale " Link "MUIScale"}                             MUIScale
 @{" MUIScrollbar " Link "MUIScrollbar"}                         MUIScrollbar
 @{" MUIScrollgroup " Link "MUIScrollgroup"}                       MUIScrollgroup
 @{" MUISemaphore " Link "MUISemaphore"}                         MUISemaphore
 @{" MUISlider " Link "MUISlider"}                            MUISlider
 @{" MUIString " Link "MUIString"}                            MUIString
 @{" MUIStringEditHook " Link "MUIStringEditHook"}                    MUIStringEditHook
 @{" MUIText " Link "MUIText"}                              MUIText
 @{" MUIVBar " Link "MUIVBar"}                              MUIVBar
 @{" MUIVirtgroup " Link "MUIVirtgroup"}                         MUIVirtgroup
 @{" MUIVolumelist " Link "MUIVolumelist"}                        MUIVolumelist
 @{" MUIWindow " Link "MUIWindow"}                            MUIWindow
 @{" MultiTestHook " Link "MUIListMultiTestHook"}                        MUIListMultiTestHook
 @{" Notify " Link "MUINotify"}                               MUINotify
 @{" Numeric " Link "MUINumeric"}                              MUINumeric
 @{" Numericbutton " Link "MUINumericbutton"}                        MUINumericbutton
 @{" ObjStrHook " Link "MUIPopobjectObjStrHook"}                           MUIPopobjectObjStrHook
 @{" OpenHook " Link "MUIPopstringOpenHook"}                             MUIPopstringOpenHook
 @{" Palette " Link "MUIPalette"}                              MUIPalette
 @{" Pendisplay " Link "MUIPendisplay"}                           MUIPendisplay
 @{" Popasl " Link "MUIPopasl"}                               MUIPopasl
 @{" PopaslStartHook " Link "MUIPopaslStartHook"}                      MUIPopaslStartHook
 @{" PopaslStopHook " Link "MUIPopaslStopHook"}                       MUIPopaslStopHook
 @{" Popbutton " Link "MUIPopbutton"}                            MUIPopbutton
 @{" Poplist " Link "MUIPoplist"}                              MUIPoplist
 @{" Popobject " Link "MUIPopobject"}                            MUIPopobject
 @{" PopobjectObjStrHook " Link "MUIPopobjectObjStrHook"}                  MUIPopobjectObjStrHook
 @{" PopobjectStrObjHook " Link "MUIPopobjectStrObjHook"}                  MUIPopobjectStrObjHook
 @{" PopobjectWindowHook " Link "MUIPopobjectWindowHook"}                  MUIPopobjectWindowHook
 @{" Poppen " Link "MUIPoppen"}                               MUIPoppen
 @{" Popstring " Link "MUIPopstring"}                            MUIPopstring
 @{" PopstringCloseHook " Link "MUIPopstringCloseHook"}                   MUIPopstringCloseHook
 @{" PopstringOpenHook " Link "MUIPopstringOpenHook"}                    MUIPopstringOpenHook
 @{" Prop " Link "MUIProp"}                                 MUIProp
 @{" Public Custom Classes " Link "Interface"}                Interface
 @{" Radio " Link "MUIRadio"}                                MUIRadio
 @{" Rectangle " Link "MUIRectangle"}                            MUIRectangle
 @{" Register " Link "MUIRegister"}                             MUIRegister
 @{" Registrierung " Link "Registrierung"}                        Registrierung
 @{" Request " Link "MUIRequest"}                              MUIRequest
 @{" RexxHook " Link "MUIApplicationRexxHook"}                             MUIApplicationRexxHook
 @{" Scale " Link "MUIScale"}                                MUIScale
 @{" Scrollbar " Link "MUIScrollbar"}                            MUIScrollbar
 @{" Scrollgroup " Link "MUIScrollgroup"}                          MUIScrollgroup
 @{" Semaphore " Link "MUISemaphore"}                            MUISemaphore
 @{" Share " Link "TWiShare"}                                TWiShare
 @{" ShareManual " Link "TWiShareManual"}                          TWiShareManual
 @{" Slider " Link "MUISlider"}                               MUISlider
 @{" StartHook " Link "MUIPopaslStartHook"}                            MUIPopaslStartHook
 @{" StopHook " Link "MUIPopaslStopHook"}                             MUIPopaslStopHook
 @{" Str " Link "TWiStr"}                                  TWiStr
 @{" String " Link "MUIString"}                               MUIString
 @{" StringEditHook " Link "MUIStringEditHook"}                       MUIStringEditHook
 @{" StrObjHook " Link "MUIPopobjectStrObjHook"}                           MUIPopobjectStrObjHook
 @{" Tag " Link "TWiTag"}                                  TWiTag
 @{" TagCursor " Link "TWiTagCursor"}                            TWiTagCursor
 @{" Text " Link "MUIText"}                                 MUIText
 @{" TWiArray " Link "TWiArray"}                             TWiArray
 @{" TWiArrayCursor " Link "TWiArrayCursor"}                       TWiArrayCursor
 @{" TWiBuffer " Link "TWiBuffer"}                            TWiBuffer
 @{" TWiFormat " Link "TWiFormat"}                            TWiFormat
 @{" TWiMemX " Link "TWiMemX"}                              TWiMemX
 @{" TWiShare " Link "TWiShare"}                             TWiShare
 @{" TWiShareManual " Link "TWiShareManual"}                       TWiShareManual
 @{" TWiStr " Link "TWiStr"}                               TWiStr
 @{" TWiTag " Link "TWiTag"}                               TWiTag
 @{" TWiTagCursor " Link "TWiTagCursor"}                         TWiTagCursor
 @{" VBar " Link "MUIVBar"}                                 MUIVBar
 @{" Vererbungshierarchie " Link "Vorwort"}                 Vorwort
 @{" Virtgroup " Link "MUIVirtgroup"}                            MUIVirtgroup
 @{" Volumelist " Link "MUIVolumelist"}                           MUIVolumelist
 @{" Vorwort " Link "Vorwort"}                              Vorwort
 @{" Window " Link "MUIWindow"}                               MUIWindow
 @{" WindowHook " Link "MUIPopobjectWindowHook"}                           MUIPopobjectWindowHook

@EndNode

