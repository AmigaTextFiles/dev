@database 07a27f28-0
@master linklist.guide
@$VER: 1.1
@author "John Brooks"
@(c) "© 1995"

@node "Main" "Linked List Library"
                        @{b}@{fg shine}Linked List Library v1.1@{ub}@{fg text}

      @{"  INTRODUCTION " link "_introduction" 0}           --- what this is all about
      @{"  LEGAL STUFF  " link "_legal" 0}           --- permissions and copyright info

      @{"  LINKLIST.H   " link "_header" 0}           --- the header file
      @{"  LINKLIST.LIB " link "_library" 0}           --- the library file

      @{"  HISTORY      " link "_history" 0}           --- what was I thinking??
@endnode

@node "_introduction" "  INTRODUCTION "
@next "_legal"
@prev "Main"
Well, I finally got tired of re-writing code for linked lists.  It
would usually take me a couple of hours cause I had to figure out how to do it
all over again.  I took about a week, only a couple of hours a day, and came
up with this library.

A few facts about this thing.  There is code written for three basic types
of linked lists, single link, double link, and circular link.  There are
several duplicate functions between the types.  None of the functions are
dependant upon other functions in the library.  Yes, this results in some
duplicate code but the size is about 5k so who really cares.  I stayed away
from recursion. This seems to make it just a bit faster.

The library was developed on an Amiga 3000 with the SAS C compiler version 6.3.
The code was compiled and tested with the Memlib libray to ensure there were no
memory errors or leaks from it.

To help out a bit, there are examples of how to use the library calls in
this document.  Enjoy.  I hope you like it.

@{fg shine}If you have any comments, questions, suggestions, or wish to send gifts
or donations I can be reached at

                                   @{b} John Brooks                        
                                    461 3rd St
                                    Satellite Bch, FL 32937@{ub}@{fg text}






SAS/C® Copyright ©1992 by SAS Institute Inc., Cary, NC, USA
Memlib was written and copyrighted ©1988-1992 by Doug Walker

@endnode

@node "_legal" "  LEGAL STUFF  "
@prev "_introduction"
Permission is granted to develop and release software products both public
and commercial with this library.  There are no restrictions on the use of
it.

@{u}@{fg shine}Permission is not granted to dissasemble or modify the library
or documentation without permission from the author.@{uu}@{fg text}

@endnode

@node "_header" "  LINKLIST.H   "
@next "__structure_list"
@prev "Main"
 @{b}@{fg shine}LINKLIST.H@{ub}@{fg text}   The library header file.

This file allows access into the linklist library.  When looking at this file
it is not that easy to tell what is going on.  Hopefully this will help.

       @{" STRUCTURES " link "__structure_list" 0}      --- the pre-defined C structures that are used
                             with the library 

       @{" FUNCTIONS  " link "__function_list" 0}      --- a listing of all the functions in the library.

@endnode

@node "__structure_list" " STRUCTURES"
@next "__function_list"
@prev "_header"
@{b}@{fg shine}Linked List Library Structures@{ub}@{fg text}

@{fg shine}Single Link List@{fg text}

        typedef struct _single {
          struct _single        *next;
          void                  *data;
        } Single;

@{fg shine}Double Link List@{fg text}

        typedef struct _double {
          struct _double        *next;
          struct _double        *prev;
          void                  *data;
        } Double;

@{fg shine}Circle Link List@{fg text}

        typedef struct _circle {
          struct _circle        *next;
          void                  *data;
        } Circle;

@endnode

@node "__function_list" " FUNCTIONS"
@prev "__function_list"


@{b}@{fg shine}FUNCTIONS@{ub}@{fg text}

@{fg shine}standard list functions@{fg text}

void    *stdGetNewLink (int)

@{fg shine}single list functions@{fg text}

Single  *singleGetNewLink (void)
Single  *singleAttachBegin (Single *, Single *)
Single  *singleAttachEnd (Single *, Single *)
Single  *singleInsertLink (Single *, Single *)
Single  *singleDeleteLink (Single *, Single *)
Single  *singleSearch (void *, Single *)
Single  *singleFindEnd (Single *)
void     singleDestroyList (Single *)

@{fg shine}double list functions@{fg text}

Double  *doubleGetNewLink (void)
Double  *doubleAttachBegin (Double *, Double *)
Double  *doubleAttachEnd (Double *, Double *)
Double  *doubleInsertLink (Double *, Double *)
Double  *doubleDeleteLink (Double *, Double *)
Double  *doubleFindBegin (Double *)
Double  *doubleFindEnd (Double *)
Double  *doubleSearch (void *, Double *)
void     doubleDestroyList (Double *)

@{fg shine}circular list functions@{fg text}

Circle  *circleGetNewLink (void)
Circle  *circleStartList (Circle *)
Circle  *circleAttachEnd (Circle *, Circle *)
Circle  *circleInsertLink (Circle *, Circle *)
Circle  *circleDeleteLink (Circle *, Circle *)
Circle  *circleSearch (void *, Circle *)
void     circleDestroyList (Circle *)

@endnode

@node "_library" "  LINKLIST.LIB "
@next "__standard_functions"
@prev "Main"
@{fg shine}Library Functions@{fg text}

This section will explain in detail each of the functions contained  in the
library.  There will be an example of how to use the code as  part of the
description.

        @{"Standard List Functions" link "__standard_functions" 0}
        @{"Single List Functions  " link "__single_functions" 0}
        @{"Double List Functions  " link "__double_functions" 0}
        @{"Circular List Functions" link "__circle_functions" 0}

@endnode

@node "__standard_functions" " STANDARD FUNCTIONS"
@prev "_library"
@{fg shine}@{b}Standard Functions@{ub}@{fg text}

These functions can be used with any linked list.  Since they are pretty
generic, typedef'ing will more than likely be used to keep the compiler
quiet.

        @{"stdGetNewLink" link "___stdGetNewLink" 0}

@endnode

@node "___stdGetNewLink" " stdGetNewLink ()"
@{b}@{fg shine}stdGetNewLink@{ub}@{fg text}

void *stdGetNewLink (size) int        size;

This function returns a pointer to the amount of memory allocated  in the
argument size.  The pointer will probably have to be typedef'ed  into a useful
type.  This function's primary use is to get memory for  any user created
structures.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
  Single  *link;
  link = (Single *)stdGetNewLink (sizeof (Single));
  ...
}

@{b}error: returns NULL if the memory could not be allocated.@{ub}

@endnode

@node "__single_functions" "Single List Functions"
@prev "__standard_functions"
@{b}@{fg shine}Single List Functions@{ub}@{fg text}

The following functions are used with the single linked list.  If a different
structure is used with these functions, problems can occur with the memory
bounds of pointers.  To ensure this doesn't happen the structures used with
the single functions should be the same size as the defined single
structure.

        @{"singleGetNewLink " link "___singleGetNewLink" 0}
        @{"singleAttachBegin" link "___singleAttachBegin" 0}
        @{"singleAttachEnd  " link "___singleAttachEnd" 0}
        @{"singleInsertLink " link "___singleInsertLink" 0}
        @{"singleDeleteLink " link "___singleDeleteLink" 0}
        @{"singleSearch     " link "___singleSearch" 0}
        @{"singleFindEnd    " link "___singleFindEnd" 0}
        @{"singleDestroyList" link "___singleDestroyList" 0}

@endnode

@node "___singleGetNewLink" " singleGetNewLink ()"
@{b}@{fg shine}singleGetNewLink@{ub}@{fg text}

Single *singleGetNewLink (void)

This function returns a pointer of type single to the allocated memory.
Typedef the function if a different pointer type is being used.

@{fg shine}example:@{fg text}

#include "linklist.h"

main () {

   Single *link;
   link = singleGetNewLink ();
   ...
}

@{b}error: returns a NULL if the memory could not be allocated.@{ub}

@endnode

@node "___singleAttachBegin" " singleAttachBegin ()"
@{b}@{fg shine}singleAttachBegin@{ub}@{fg text}

Single *singleAttachBegin (list, link)
Single *list;
Single *link;

Attaches the new link to the start of the list and returns the pointer to
the start of the new list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{

  Single    *list, link;
  ...

  link = singleGetNewLink ();
  list = singleAttachBegin (list, link);
  ...
}

@{b}NOTE:@{ub} The first argument to this function must be the start of the
list or a serious leak can and will occur.

@{b}error: returns a NULL if either of the arguments is an invalid pointer.@{ub}

@endnode

@node "___singleAttachEnd" " singleAttachEnd ()"
@{b}@{fg shine}singleAttachEnd@{ub}@{fg text}

Single *singleAttachEnd (list, link)
Single *list;
Single *link;

The function returns the pointer to the same list that was passed in as the
first argument. The pointer to the link will be attached to  the end of the
list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main () {

  Single *list, *link;
  ...

  link = singleGetNewLink ();
  list = singleAttachEnd (list, link);
  ...
}

The list variable and argument doesn't have to be the start of the list.   It
is a little quicker if the list argument is somewhere deeper into  the list.
The big problem is when a pointer to the start of the list is not maintained
a memory leak occurs and also loss of data.

@{b}error: returns NULL if either of the arguments is an invalid pointer @{ub}

@endnode

@node "___singleInsertLink" " singleInsertLink ()"
@{b}@{fg shine}singleInsertLink@{ub}@{fg text}

Single *singleInsertLink (before, new)
Single *before;
Single *new;

This function is used when a link needs to be inserted somewhere inside  the
list.  To speed up the operation it takes the link that is before the
new link as the first argument so the whole link doesn't have to be
parsed.  This function can be used to attach a link to the end of the
list. The pointer to the first argument is returned.

@{fg shine}example:@{fg text}

#include "linklist.h"

main() {
  Single *list, *new_link;
  ...

  list = singleInsertLink (list, new_link);
  ...
}

@{b}error: returns NULL if either of the pointers are invalid.@{ub}

@endnode

@node "___singleDeleteLink" " singleDeleteLink ()"
@{b}@{fg shine}singleDeleteLink@{ub}@{fg text}

Single *singleDeleteLink (list, link)
Single *list;
Single *link;

This function is used to remove a link from the list.  Since it is technically
a memory bug to free memory that is not allocated (Memlib complains) the
function makes sure the link is in the list  before freeing and setting the
pointers of the other links.  If the  link is not part of the list it must be
freed by the programmer or attached to the link before it can be freed with
this call.  The arguments are the pointer to the list and the link being
removed.  The pointer to the new list is returned.

@{fg shine}example:@{fg text}

#include "linklist.h"

main () {
  Single *list, *link;
  ...

  list = singleDeleteLink (list, link);
  ...
}

As with @{fg shine}@{i}singleAttachEnd @{ui}@{fg text}the argument list doesn't have to be the start  of the
list to help speed things up, but the same memory leak and data loss
potential is there.

@{b}error: returns a NULL if either of the arguments is an invalid pointer.@{ub}

@endnode

@node "___singleSearch" " singleSearch ()"
@{b}@{fg shine}singleSearch@{ub}@{fg text}

Single *singleSearch (data, list)
void   *data;
Single *list;

This function may be a little tricky and rarely used.  It requires some
pointer that will be compared to the @{b}Single->data@{ub} part of the structure.  The
other argument is the list to be searched.  It returns the link if found or
NULL if not.

@{fg shine}example:@{fg text}

#include "linklist.h"

main() {
  Single *list, *link;
  char   *data = "data";
  ...

  link->data = data;
  ...

  if ( !(singleSearch (data, list)))
    printf ("Data not found\n");

  ...
}

@{b}error: returns a NULL if the second argument is an invalid pointer.@{ub}

@endnode

@node "___singleFindEnd" " singleFindEnd ()"
@{b}@{fg shine}singleFindEnd@{ub}@{fg text}

Single *singleFindEnd (list)
Single *list;

This function is pretty much self explanatory.  Its only argument is the list
and it returns a pointer to the last link of that list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main () {
  Single *list;
  ...

  /* remove the last link of the list */
  list = singleDeleteLink (list, singleFindEnd (list));
  ...
}

@{b}error: NULL is returned if the argument is invalid.@{ub}

@endnode

@node "___singleDestroyList" " singleDestroyList ()"
@{b}@{fg shine}singleDestroyList@{ub}@{fg text}

void singleDestroyList (list)
Single *list;

The use of this function is pretty much straight forward - destroy the whole
list.  The function parses through the list to find the end and  then one by
one frees the memory to each link.

NOTE: This function does not free the memory pointed to by the @{b}Single->data@{ub}
pointer.  It would be simple to do this but if it was a pointer to another
structure that had memory pointer in it, there would be serious memory leaks.
Any memory that has been allocated inside this pointer must be freed before
calling this function.

@{fg shine}example:@{fg text}

#include "linklist.h"

main()

{
  Single *list;
  ...

  singleDestroyList (list);
  exit (0);
}

@{b}error: no error condition is returned.  If the pointer is invalid the function
returns without releasing the memory.@{ub}

@endnode

@node "__double_functions" " DOUBLE LIST FUNCTIONS"
@prev "__single_functions"
@{fg shine}@{b}Double List Functions@{ub}@{fg text}

These following functions are for double linked lists.  Again, the predefined
structures don't have to be used but make sure that any user defined strucures
have the same basic format to prevent any weird memory and/or pointer problems.

        @{"doubleGetNewLink " link "___doubleGetNewLink" 0}
        @{"doubleAttachBegin" link "___doubleAttachBegin" 0}
        @{"doubleAttachEnd  " link "___doubleAttachEnd" 0}
        @{"doubleInsertLink " link "___doubleInsertLink" 0}
        @{"doubleDeleteLink " link "___doubleDeleteLink" 0}
        @{"doubleFindBegin  " link "___doubleFindBegin" 0}
        @{"doubleFindEnd    " link "___doubleFindEnd" 0}
        @{"doubleSearch     " link "___doubleSearch" 0}
        @{"doubleDestroyList" link "___doubleDestroyList" 0}

@endnode

@node "___doubleGetNewLink" " doubleGetNewLink ()"
@{b}@{fg shine}doubleGetNewLink@{ub}@{fg text}

Double *doubleGetNewLink (void)

Returns a pointer to the new link of type Double.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *link;
        link = doubleGetNewLink ();
} 

@{b}error: returns a NULL if the memory could no be allocated.@{ub}

@endnode

@node "___doubleAttachBegin" " doubleAttachEnd ()"
@{b}@{fg shine}doubleAttachBegin@{fg text}@{ub}

Double *doubleAttachBegin (list, link)
Double *list;
Double *link;

This function parses through the list and attaches the link to the start.  The pointer
to the new list is returned, not necessarily the start of the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list;
        ...

        list = doubleAttachBegin (list, doubleGetNewLink());
        ...
}

As with the attach function with the single lists, the first argument
can be any link on the list.  The only difference here is that a pointer to the
head doesn't have to be kept since the start can be found.

@{b}error: returns a NULL if either of the pointers are invalid.@{ub}

@endnode

@node "___doubleAttachEnd" " doubleAttachEnd ()"
@{b}@{fg shine}doubleAttachEnd@{fg text}@{ub}

Double *doubleAttachEnd (list, link)
Double *list;
Double *link;

This function is identical to @{b}doubleAttachBegin@{ub} except that it puts the link at the
end of the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main()
{
        Double *list;
        ...

        list = doubleAttachEnd (list, doubleGetNewLink());
        ...
} 

@{b}error: if either of the pointers are invalid a NULL is returned.@{ub}

@endnode

@node "___doubleInsertLink" " doubleInsertLink ()"
@{b}@{fg shine}doubleInsertLink@{fg text}@{ub}

Double *doubleInsertLink (before, new)
Double *before;
Double *new;

This function is almost identical to @{b}singleInsertLink@{ub}.  It is used to insert a link
somewhere in the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list, *link2;
        ...

        list = doubleAttachEnd (list, doubleGetNewLink());
        ...

        link2 = doubleGetNewLink();
        list = doubleInsertLink (list, link2);
        ...
} 

@{b}error: returns a NULL if either of the arguments are invalid pointers.@{ub}

@endnode

@node "___doubleDeleteLink" " doubleDeleteLink ()"
@{b}@{fg shine}doubleDeleteLink@{fg text}@{ub}

Double *doubleDeleteLink (list, link)
Double *list;
Double *link;

This function is used to remove a link from the list.  The function will not
free any memory allocated by the @{b}Double->data@{ub} pointer.  This memory,
and any memory further in, must be freed before the link is destroyed in
order to prevent memory leaks. The pointer to the new list is returned.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list, *link;
        ...

        list = doubleDeleteLink (list, link);
        ...
} 

@{b}error: if the pointers are invalid, a NULL is returned.@{ub}

@endnode

@node "___doubleFindBegin" " doubleFindBegin ()"
@{b}@{fg shine}doubleFindBegin@{fg text}@{ub}

Double *doubleFindBegin (list)
Double *list;

This function accepts the list as its only argumnt and then parses back through
it returning the pointer to the first link in the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list, *link;
        ...

        list = doubleAttachBegin (list, link);
        /* make sure that list is pointing to the head */
        list = doubleFindBegin (list);
        ...
} 

@{b}error: a NULL is returned if the pointer is invalid.@{ub}

@endnode

@node "___doubleFindEnd" " doubleFindEnd ()"
@{b}@{fg shine}doubleFindEnd@{fg text}@{ub}

Double *doubleFindEnd (list)
Double *list;

This function is identical to the @{b}doubleFindBegin@{ub} except that it finds the end of
the list instead of the start.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list;
        ...

        /* remove the last link in the list */
        list = doubleDeleteLink (list, doubleFindEnd (list));
        ...
} 

@{b}error: if the argument is an invalid pointer, NULL is returned.@{ub}

@endnode

@node "___doubleSearch" " doubleSearch ()"
@{b}@[fg shine}doubleSearch@{fg text}@{ub}

Double *doubleSearch (data, list)
void   *data;
Double *list;

The first argument to this function is a pointer to the data that will be
searched for.  The function parses through the list, the second argument,
comparing the pointer to the @{b}Double->data@{ub} pointer in the structure.  If
found the pointer to the link is returned otherwise NULL is.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list, *link;
        char   *data = "data";
        ...

        link->data = data;
        ...

        if ( !(doubleSearch (data, list)))
                printf ("Data not found\n");
        ...
} 

@{b}error: a NULL is returned if the second argument is an invalid pointer.@{ub}

@endnode

@node "___doubleDestroyList" " doubleDestroyList ()"
@{b}@{fg shine}doubleDestroyList@{fg text}@{ub}

void doubleDestroyList (list)
Double *list;

The use of this function is pretty much straight forward - destroy the whole
list.  The function parses through the list to find the end and then one by
one frees the memory to each link.

NOTE: This function does not free the memory pointed to by the @{b}Double->data@{ub}
pointer.  It would be simple to do this but if it was a pointer to another
structure that had memory pointer in it, there would be serious memory leaks.
Any memory that has been allocated inside this pointer must be freed before
calling this function.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Double *list;
        ...

        doubleDestroyList (list);
        exit (0);
} 

@{b}error: if the pointer passed to the function is invalid it will not execute.
No error condition is returned.@{ub}

@endnode

@node "__circle_functions" "CIRCULAR LIST FUNCTIONS"
@prev "__double_functions"
@{b}@{fg shine}Circular List Functions@{fg text}@{ub}

The following functions are to be used with circular linked lists.  These
functions use links that only point in one direction (the next link) and
end up connecting back at the start.  Because of the sometimes unique
behavior of circular links, some of the functions here may not behave in
the expected way, ie. a pointer to a link other than expected.  These may
appear as bugs but there should be no great concern as the functions return
the most reliable pointers and since the list is circular there is no
loss of data through these functions.

        @{"circleGetNewLink " link "___circleGetNewLink" 0}
        @{"circleStartList  " link "___circleStartList" 0}
        @{"circleAttachEnd  " link "___circleAttachEnd" 0}
        @{"circleInsertLink " link "___circleInsertLink" 0}
        @{"circleDeleteLink " link "___circleDeleteLink" 0}
        @{"circleSearch     " link "___circleSearch" 0}
        @{"circleDestroyList" link "___circleDestroyList" 0}

@endnode

@node "___circleGetNewLink" " circleGetNewLink ()"
@{b}@{fg shine}circleGetNewLink@{fg text}@{ub}

Circle *circleGetNewLink (void)

The function returns a pointer to the new link.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *link;
        link = circleGetNewLink ();
}
 
@{b}error: a NULL is returned if the memory couldn't be allocated.@{ub}

@endnode

@node "___circleStartList" " circleStartList ()"
@{b}@{fg shine}circleStartList@{fg text}@{ub}

Circle *circleStartList (list)
Circle *list;

This is a very important function.  This function starts the circular
pointer.  It returns the pointer to the start of the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list;

        list = circleGetNewLink ();
        list = circleStartList (list);
        ...
} 

@{b}error: if the pointer is invalid, a NULL is returned.@{ub}

@endnode

@node "___circleAttachEnd" " circleAttachEnd ()"
@{b}@{fg shine}circleAttachEnd@{fg text}@{ub}

Circle *circleAttachEnd (list, link)
Circle *list;
Circle *link;

This function attaches the link to the 'end' of the list.  There really is
no end in a circular list.  The function pareses through the list until it
finds the start and then it attaches the link just before the start and
points the link to the start completing the circle again.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list;
        ...

        list = circleAttachEnd (list, circleGetNewLink());
        ...
} 

@{b}error: if either of the pointers are invalid, a NULL is returned.@{ub}

@endnode

@node "___circleInsertLink" " circleInsertLink ()"
@{b}@{fg shine}circleInsertLink@{fg text}@{ub}

Circle *circleInsertLink (before, new)
Circle *before;
Circle *new;

This function is used to insert a link somewhere in the list.  To speed up
the process the first argument is the link that will be before
the new link.  This function can be used to attach links to the
preverbial end of the list.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list, *link;

        list = circleStartList (circleGetNewLink());
        link = circleGetNewLink ();
        /* attach link to the end of the list */
        list = circleInsertList (list, link);
        /* now there are two links in the list */
        ...
} 

@{b}error: if the arguements are invalid pointers, a NULL is returned.@{ub}

@endnode

@node "___circleDeleteLink" " circleDeleteLink ()" 
@{b}@{fg shine}circleDeleteLink@{fg text}@{ub}

Circle *circleDeleteLink (list, link)
Circle *list;
Circle *link;

This is one of the functions that may not return the expected pointer into
the list.  If the pointer being passed in as the list is the one destroyed
then the pointer becomes unstable.  To avoid loss of data the link that
points to this link is the one that is passed back.  This function does not
free any memory that is allocated deeper in the @{b}Circle->data@{ub} pointer
This memory must be freed before the link is destroyed.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list, *link;
        ...

        list = circleDeleteLink (list, link);
        ...
}

@{b}error: a NULL is returned if either of the pointers are invalid.@{ub}

@endnode

@node "___circleSearch" " circleSearch"
@{b}@{fg shine}circleSearch@{fg text}@{ub}

Circle *circleSearch (data, list)
void   *data;
Circle *list;

As with the other search functions this one also parses through the list
looking at the @{b}Circle->data@{ub} pointer.  If a match is found it returns
the pointer to the link and return NULL if one is not.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list, *link;
        char   *data = "data";
        ...

        link->data = data;
        ...

        if ( (circleSearch (data, list)))
                printf ("Found %s\n", data);
        ...
} 

@{b}error: if the second pointer is invalid, a NULL is returned.@{ub}

@endnode

@node "___circleDestroyList" " circleDestroyList ()"
@{b}@{fg shine}circleDestroyList@{fg text}@{ub}

void circleDestroyList (list)
Circle *list;

The use of this function is pretty much straight forward - destroy the whole
list.  The function parses through the list to find the end and then one
by one frees the memory to each link.

NOTE: This function does not free the memory pointed to by the @{b}Circle->data@{ub}
pointer.  It would be simple to do this but if it was a pointer to another
structure that had memory pointer in it, there would be serious memory leaks.
Any memory that has been allocated inside this pointer must be freed before
calling this function.

@{fg shine}example:@{fg text}

#include "linklist.h"

main ()
{
        Circle *list;
        ...

        circleDestroyList (list);
        exit (0);
}   

@{b}error: if the pointer is not valid, the function will return without
releasing the memory.  No error condition is returned.@{ub}

@endnode

@node "_history" "  HISTORY      "


@{fg shine}Version 1.0@{fg text}
        The initial release of the library.

@{fg shine}Version 1.1@{fg text}

Added a new function singleAttachBegin() to the library.

Changed the functions singleInsertLink(), doubleInsertLink(), and 
circleInsertLink().

singleInsertLink (before, after, link);	                /*v 1.0*/
singleInsertLink (before, link);			/*v 1.1*/

doubleInsertLink (before, after, link);	                /*v 1.0*/
doubleInsertLink (before, link);			/*v 1.1*/

circleInsertLink (before, after, link);	                /*v 1.0*/
circleInsertLink (before, link);			/*v 1.1*/

The function circleStartList(), which creates a one link circular link to 
initialize the list, is no longer needed.  Now circleGetNewLink() 
correctly initializes the new list by doing this function. It is still 
left in the library for compatability to version 1.0 and to initialize 
any user created list structures.

All of the functions that take link pointers as arguments now have 
error checking in them.  If an invalid pointer is passed into the 
function a NULL pointer is returned.  This keeps the library from 
crashing any programs due to SEGV errors.

@endnode

