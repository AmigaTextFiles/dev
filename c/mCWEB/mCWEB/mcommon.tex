\input mcwebmac
% This file is part of mCWEB.
% This program by Markus Öllinger is based on
% CWEB 3.4 by Silvio Levy and Donald E. Knuth which in turn
% is based on a program by Knuth.
% It is distributed WITHOUT ANY WARRANTY, express or implied.
% Version 1.1 --- October 1998

% Copyright (C) 1996-1998 Markus Öllinger

% Permission is granted to make and distribute verbatim copies of this
% document provided that the copyright notice and this permission notice
% are preserved on all copies.

% Permission is granted to copy and distribute modified versions of this
% document under the conditions for verbatim copying, provided that the
% entire resulting derived work is given a different name and distributed
% under the terms of a permission notice identical to this one.

\def\v{\char'174} % vertical (|) in typewriter font

\def\title{Common code for mCTANGLE and mCWEAVE (Version 1.1)}
\def\topofcontents{\null\vfill
  \centerline{\titlefont Common code for {\ttitlefont mCTANGLE} and
    {\ttitlefont mCWEAVE}}
  \vskip 15pt
  \centerline{(Version 1.1)}
  \vfill}
\def\botofcontents{\vfill\titlefalse}
\def\contentspagenumber{53}
%\def\title{APPENDIX D: COMMON}
%\let\K=\leftarrow
\pageno=\contentspagenumber \advance\pageno by 1
\let\maybe=\iftrue


\N{0}{1}Introduction.  This file contains code common
to both \.{CTANGLE} and \.{CWEAVE}, which roughly concerns the following
problems: character uniformity, input routines, error handling and
parsing of command line.  We have tried to concentrate in this file
all the system dependencies, so as to maximize portability.

In the texts below we will
sometimes use \.{CWEB} to refer to either of the two component
programs, if no confusion can arise.

Since \.{mCWEB} contains \.{CWEB}, we will continue using the terms
\.{CTANGLE}, \.{CWEAVE} and \.{CWEB} when we talk about features
common to both, the old \.{CWEB} and the new \.{mCWEB} system.
Only when we will be talking about additional features that are
only available in \.{mCWEB} we will use the prefix \.{m}.

The file begins with a few basic definitions.

\Y\B\X7:Include files\X\6
\ATH\6
\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X\6
\X3:Other definitions\X\6
\X5:Predeclaration of procedures\X\par
\fi

\M{2}In certain cases \.{CTANGLE} and \.{CWEAVE} should do almost, but not
quite, the same thing.  In these cases we've written common code for
both, differentiating between the two by means of the global variable
\PB{\\{program}}.

\Y\B\4\D$\\{ctangle}$ \5
\T{0}\par
\B\4\D$\\{cweave}$ \5
\T{1}\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\E{}$\6
\&{typedef} \&{short} \&{boolean};\6
\&{boolean} \\{program};\C{ \.{CWEAVE} or \.{CTANGLE}? }\par
\As9, 12, 22, 29, 32, 34, 37, 61, 63, 73, 81\ETs85.
\U1.\fi

\M{3}\.{CWEAVE} operates in three phases: first it inputs the source
file and stores cross-reference data, then it inputs the source once again and
produces the \TEX/ output file, and finally it sorts and outputs the index.
Similarly, \.{CTANGLE} operates in two phases.
The global variable \PB{\\{phase}} tells which phase we are in.

\Y\B\4\X3:Other definitions\X${}\E{}$\6
\&{int} \\{phase};\C{ which phase are we in? }\par
\A13.
\U1.\fi

\M{4}There's an initialization procedure that gets both \.{CTANGLE} and
\.{CWEAVE} off to a good start. We will fill in the details of this
procedure later.

\Y\B\&{void} \\{common\_init}(\,)\1\1\2\2\6
${}\{{}$\1\6
\\{init\_common\_ptrs}(\,);\6
\X74:Set the default options common to \.{CTANGLE} and \.{CWEAVE}\X;\6
\X86:Scan arguments and open output files\X;\6
\4${}\}{}$\2\par
\fi

\M{5}
\Y\B\4\X5:Predeclaration of procedures\X${}\E{}$\6
\&{void} \\{init\_common\_ptrs}(\,);\par
\As38, 43, 51, 58, 62, 66, 69, 75\ETs89.
\U1.\fi

\M{6}We will store all names in a symbol table. The following function will
reset these pointers thus clearing the symbol table.
\Y\B\&{void} \\{init\_common\_ptrs}(\,)\1\1\2\2\6
${}\{{}$\1\6
\X35:Initialize pointers\X;\6
\4${}\}{}$\2\par
\fi

\N{2}{7}The character set.
\.{CWEB} uses the conventions of \CEE/ programs found in the standard
\.{ctype.h} header file.

\Y\B\4\X7:Include files\X${}\E{}$\6
\8\#\&{include} \.{<ctype.h>}\par
\As10\ET24.
\U1.\fi

\M{8}A few character pairs are encoded internally as single characters,
using the definitions below. These definitions are consistent with
an extension of ASCII code originally developed at MIT and explained in
Appendix~C of {\sl The \TEX/book\/}; thus, users who have such a
character set can type things like \.{\char'32} and \.{\char'4} instead
of \.{!=} and \.{\&\&}. (However, their files will not be too portable
until more people adopt the extended code.)

If the character set is not ASCII, the definitions given here may conflict
with existing characters; in such cases, other arbitrary codes should be
substituted. The indexes to \.{CTANGLE} and \.{CWEAVE} mention every
case where similar codes may have to be changed in order to
avoid character conflicts. Look for the entry ``ASCII code dependencies''
in those indexes.


\Y\B\4\D$\\{and\_and}$ \5
\T{\~4}\C{ `\.{\&\&}'\,; corresponds to MIT's {\tentex\char'4} }\par
\B\4\D$\\{lt\_lt}$ \5
\T{\~20}\C{ `\.{<<}'\,;  corresponds to MIT's {\tentex\char'20} }\par
\B\4\D$\\{gt\_gt}$ \5
\T{\~21}\C{ `\.{>>}'\,;  corresponds to MIT's {\tentex\char'21} }\par
\B\4\D$\\{plus\_plus}$ \5
\T{\~13}\C{ `\.{++}'\,;  corresponds to MIT's {\tentex\char'13} }\par
\B\4\D$\\{minus\_minus}$ \5
\T{\~1}\C{ `\.{--}'\,;  corresponds to MIT's {\tentex\char'1} }\par
\B\4\D$\\{minus\_gt}$ \5
\T{\~31}\C{ `\.{->}'\,;  corresponds to MIT's {\tentex\char'31} }\par
\B\4\D$\\{not\_eq}$ \5
\T{\~32}\C{ `\.{!=}'\,;  corresponds to MIT's {\tentex\char'32} }\par
\B\4\D$\\{lt\_eq}$ \5
\T{\~34}\C{ `\.{<=}'\,;  corresponds to MIT's {\tentex\char'34} }\par
\B\4\D$\\{gt\_eq}$ \5
\T{\~35}\C{ `\.{>=}'\,;  corresponds to MIT's {\tentex\char'35} }\par
\B\4\D$\\{eq\_eq}$ \5
\T{\~36}\C{ `\.{==}'\,;  corresponds to MIT's {\tentex\char'36} }\par
\B\4\D$\\{or\_or}$ \5
\T{\~37}\C{ `\.{\v\v}'\,;  corresponds to MIT's {\tentex\char'37} }\par
\B\4\D$\\{dot\_dot\_dot}$ \5
\T{\~16}\C{ `\.{...}'\,;  corresponds to MIT's {\tentex\char'16} }\par
\B\4\D$\\{colon\_colon}$ \5
\T{\~6}\C{ `\.{::}'\,;  corresponds to MIT's {\tentex\char'6} }\par
\B\4\D$\\{period\_ast}$ \5
\T{\~26}\C{ `\.{.*}'\,;  corresponds to MIT's {\tentex\char'26} }\par
\B\4\D$\\{minus\_gt\_ast}$ \5
\T{\~27}\C{ `\.{->*}'\,;  corresponds to MIT's {\tentex\char'27} }\par
\fi

\N{0}{9}Input routines.  The lowest level of input to the \.{CWEB} programs
is performed by \PB{\\{input\_ln}}, which must be told which file to read from.
The return value of \PB{\\{input\_ln}} is 1 if the read is successful and 0 if
not (generally this means the file has ended). The conventions
of \TEX/ are followed; i.e., the characters of the next line of the file
are copied into the \PB{\\{buffer}} array,
and the global variable \PB{\\{limit}} is set to the first unoccupied position.
Trailing blanks are ignored. The value of \PB{\\{limit}} must be strictly less
than \PB{\\{buf\_size}}, so that \PB{$\\{buffer}[\\{buf\_size}-\T{1}]$} is
never filled.

Since \PB{\\{buf\_size}} is strictly less than \PB{\\{long\_buf\_size}},
some of \.{CWEB}'s routines use the fact that it is safe to refer to
\PB{${*}(\\{limit}+\T{2})$} without overstepping the bounds of the array.

\Y\B\4\D$\\{buf\_size}$ \5
\T{256}\C{ for \.{CWEAVE} and \.{CTANGLE} }\par
\B\4\D$\\{longest\_name}$ \5
\T{1000}\par
\B\4\D$\\{long\_buf\_size}$ \5
$(\\{buf\_size}+\\{longest\_name}{}$)\C{ for \.{CWEAVE} }\par
\B\4\D$\\{xisspace}(\|c)$ \5
$(\\{isspace}(\|c)\W{}$((\&{unsigned} \&{char}) \|c${}<\T{\~200}){}$)\par
\B\4\D$\\{xisupper}(\|c)$ \5
$(\\{isupper}(\|c)\W{}$((\&{unsigned} \&{char}) \|c${}<\T{\~200}){}$)\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{char} \\{buffer}[\\{long\_buf\_size}];\C{ where each line of input goes }\6
\&{char} ${}{*}\\{buffer\_end}\K\\{buffer}+\\{buf\_size}-\T{2}{}$;\C{ end of %
\PB{\\{buffer}} }\6
\&{char} ${}{*}\\{limit}\K\\{buffer}{}$;\C{ points to the last character in the
buffer }\6
\&{char} ${}{*}\\{loc}\K\\{buffer}{}$;\C{ points to the next character to be
read from the buffer }\par
\fi

\M{10}\B\X7:Include files\X${}\mathrel+\E{}$\6
\8\#\&{include} \.{<stdio.h>}\par
\fi

\M{11}In the unlikely event that your standard I/O library does not
support \PB{\\{feof}}, \PB{\\{getc}} and \PB{\\{ungetc}} you may have to change
things here.

\Y\B\&{int} \\{input\_ln}(\\{fp})\C{ copies a line into \PB{\\{buffer}} or
returns 0 }\1\1\6
\&{FILE} ${}{*}\\{fp}{}$;\C{ what file to read from }\2\2\6
${}\{{}$\1\6
\&{register} \&{int} \|c${}\K\.{EOF}{}$;\C{ character read; initialized so some
compilers won't complain }\6
\&{register} \&{char} ${}{*}\|k{}$;\C{ where next character goes }\7
\&{if} (\\{feof}(\\{fp}))\1\5
\&{return} (\T{0});\C{ we have hit end-of-file }\2\6
${}\\{limit}\K\|k\K\\{buffer}{}$;\C{ beginning of buffer }\6
\&{while} ${}(\|k\Z\\{buffer\_end}\W(\|c\K\\{getc}(\\{fp}))\I\.{EOF}\W\|c\I\.{'%
\\n'}){}$\1\6
\&{if} ${}(({*}(\|k\PP)\K\|c)\I\.{'\ '}){}$\1\5
${}\\{limit}\K\|k;{}$\2\2\6
\&{if} ${}(\|k>\\{buffer\_end}){}$\1\6
\&{if} ${}((\|c\K\\{getc}(\\{fp}))\I\.{EOF}\W\|c\I\.{'\\n'}){}$\5
${}\{{}$\1\6
${}\\{ungetc}(\|c,\39\\{fp});{}$\6
${}\\{loc}\K\\{buffer};{}$\6
\\{err\_print}(\.{"!\ Input\ line\ too\ lo}\)\.{ng"});\6
\4${}\}{}$\2\2\6
\&{if} ${}(\|c\E\.{EOF}\W\\{limit}\E\\{buffer}){}$\1\5
\&{return} (\T{0});\C{ there was nothing after     the last newline }\2\6
\&{return} (\T{1});\6
\4${}\}{}$\2\par
\fi

\M{12}Now comes the problem of deciding which file to read from next.
Recall that the actual text that \.{CWEB} should process comes from two
streams: a \PB{\\{web\_file}}, which can contain possibly nested include
commands \.{@i}, and a \PB{\\{change\_file}}, which might also contain
includes.  The \PB{\\{web\_file}} together with the currently open include
files form a stack \PB{\\{file}}, whose names are stored in a parallel stack
\PB{\\{file\_name}}.  The boolean \PB{\\{changing}} tells whether or not we're
reading
from the \PB{\\{change\_file}}.

The line number of each open file is also kept for error reporting and
for the benefit of \.{CTANGLE}.

\Y\B\F\\{line} \5
\|x\C{ make \PB{\\{line}} an unreserved word }\par
\B\4\D$\\{max\_include\_depth}$ \5
\T{10}\C{ maximum number of source files open   simultaneously, not counting
the change file }\par
\B\4\D$\\{max\_file\_name\_length}$ \5
\T{128}\par
\B\4\D$\\{cur\_file}$ \5
\\{file}[\\{include\_depth}]\C{ current file }\par
\B\4\D$\\{cur\_file\_name}$ \5
\\{file\_name}[\\{include\_depth}]\C{ current file name }\par
\B\4\D$\\{cur\_line}$ \5
\\{line}[\\{include\_depth}]\C{ number of current line in current file }\par
\B\4\D$\\{web\_file}$ \5
\\{file}[\T{0}]\C{ main source file }\par
\B\4\D$\\{web\_file\_name}$ \5
\\{file\_name}[\T{0}]\C{ main source file name }\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{int} \\{include\_depth};\C{ current level of nesting }\6
\&{FILE} ${}{*}\\{file}[\\{max\_include\_depth}]{}$;\C{ stack of non-change
files }\6
\&{FILE} ${}{*}\\{change\_file}{}$;\C{ change file }\6
\&{char} \\{file\_name}[\\{max\_include\_depth}][\\{max\_file\_name\_length}];%
\C{ stack of non-change file names }\6
\&{char} \\{change\_file\_name}[\\{max\_file\_name\_length}];\C{ name of change
file }\6
\&{char} \\{alt\_web\_file\_name}[\\{max\_file\_name\_length}];\C{ alternate
name to try }\6
\&{int} \\{line}[\\{max\_include\_depth}];\C{ number of current line in the
stacked files }\6
\&{int} \\{change\_line};\C{ number of current line in change file }\6
\&{int} \\{change\_depth};\C{ where \.{@y} originated during a change }\6
\&{boolean} \\{input\_has\_ended};\C{ if there is no more input }\6
\&{boolean} \\{changing};\C{ if the current line is from \PB{\\{change\_file}}
}\6
\&{boolean} \\{web\_file\_open}${}\K\T{0}{}$;\C{ if the web file is being read
}\6
\&{FILE} ${}{*}\\{rep\_file}{}$;\par
\fi

\M{13}When \PB{$\\{changing}\E\T{0}$}, the next line of \PB{\\{change\_file}}
is kept in
\PB{\\{change\_buffer}}, for purposes of comparison with the next
line of \PB{\\{cur\_file}}. After the change file has been completely input, we
set \PB{$\\{change\_limit}\K\\{change\_buffer}$},
so that no further matches will be made.

Here's a shorthand expression for inequality between the two lines:

\Y\B\4\D$\\{lines\_dont\_match}$ \5
$(\\{change\_limit}-\\{change\_buffer}\I\\{limit}-\\{buffer}\V\\{strncmp}(%
\\{buffer},\39\\{change\_buffer},\39\\{limit}-\\{buffer}){}$)\par
\Y\B\4\X3:Other definitions\X${}\mathrel+\E{}$\6
\&{char} \\{change\_buffer}[\\{buf\_size}];\C{ next line of \PB{\\{change%
\_file}} }\6
\&{char} ${}{*}\\{change\_limit}{}$;\C{ points to the last character in \PB{%
\\{change\_buffer}} }\par
\fi

\M{14}Procedure \PB{\\{prime\_the\_change\_buffer}}
sets \PB{\\{change\_buffer}} in preparation for the next matching operation.
Since blank lines in the change file are not used for matching, we have
\PB{$(\\{change\_limit}\E\\{change\_buffer}\W\R\\{changing})$} if and only if
the change file is exhausted. This procedure is called only when
\PB{\\{changing}} is 1; hence error messages will be reported correctly.

\Y\B\&{void} \\{prime\_the\_change\_buffer}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{change\_limit}\K\\{change\_buffer}{}$;\C{ this value is used if the
change file ends }\6
\X15:Skip over comment lines in the change file; \PB{\&{return}} if end of file%
\X;\6
\X16:Skip to the next nonblank line; \PB{\&{return}} if end of file\X;\6
\X17:Move \PB{\\{buffer}} and \PB{\\{limit}} to \PB{\\{change\_buffer}} and %
\PB{\\{change\_limit}}\X;\6
\4${}\}{}$\2\par
\fi

\M{15}While looking for a line that begins with \.{@x} in the change file, we
allow lines that begin with \.{@}, as long as they don't begin with \.{@y},
\.{@z} or \.{@i} (which would probably mean that the change file is fouled up).

\Y\B\4\X15:Skip over comment lines in the change file; \PB{\&{return}} if end
of file\X${}\E{}$\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\\{change\_line}\PP;{}$\6
\&{if} ${}(\R\\{input\_ln}(\\{change\_file})){}$\1\5
\&{return};\2\6
\&{if} ${}(\\{limit}<\\{buffer}+\T{2}){}$\1\5
\&{continue};\2\6
\&{if} ${}(\\{buffer}[\T{0}]\I\.{'@'}){}$\1\5
\&{continue};\2\6
\&{if} (\\{xisupper}(\\{buffer}[\T{1}]))\1\5
${}\\{buffer}[\T{1}]\K\\{tolower}(\\{buffer}[\T{1}]);{}$\2\6
\&{if} ${}(\\{buffer}[\T{1}]\E\.{'x'}){}$\1\5
\&{break};\2\6
\&{if} ${}(\\{buffer}[\T{1}]\E\.{'y'}\V\\{buffer}[\T{1}]\E\.{'z'}\V\\{buffer}[%
\T{1}]\E\.{'i'}){}$\5
${}\{{}$\1\6
${}\\{loc}\K\\{buffer}+\T{2};{}$\6
\\{err\_print}(\.{"!\ Missing\ @x\ in\ cha}\)\.{nge\ file"});\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U14.\fi

\M{16}Here we are looking at lines following the \.{@x}.

\Y\B\4\X16:Skip to the next nonblank line; \PB{\&{return}} if end of file\X${}%
\E{}$\6
\&{do}\5
${}\{{}$\1\6
${}\\{change\_line}\PP;{}$\6
\&{if} ${}(\R\\{input\_ln}(\\{change\_file})){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ Change\ file\ ended}\)\.{\ after\ @x"});\6
\&{return};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\5
\&{while} ${}(\\{limit}\E\\{buffer}){}$;\par
\U14.\fi

\M{17}\B\X17:Move \PB{\\{buffer}} and \PB{\\{limit}} to \PB{\\{change\_buffer}}
and \PB{\\{change\_limit}}\X${}\E{}$\6
${}\{{}$\1\6
${}\\{change\_limit}\K\\{change\_buffer}-\\{buffer}+\\{limit};{}$\6
${}\\{strncpy}(\\{change\_buffer},\39\\{buffer},\39\\{limit}-\\{buffer}+%
\T{1});{}$\6
\4${}\}{}$\2\par
\Us14\ET18.\fi

\M{18}The following procedure is used to see if the next change entry should
go into effect; it is called only when \PB{\\{changing}} is 0.
The idea is to test whether or not the current
contents of \PB{\\{buffer}} matches the current contents of \PB{\\{change%
\_buffer}}.
If not, there's nothing more to do; but if so, a change is called for:
All of the text down to the \.{@y} is supposed to match. An error
message is issued if any discrepancy is found. Then the procedure
prepares to read the next line from \PB{\\{change\_file}}.

When a match is found, the current section is marked as changed unless
the first line after the \.{@x} and after the \.{@y} both start with
either \PB{\.{'@*'}} or \PB{\.{'@\ '}} (possibly preceded by whitespace).

This procedure is called only when \PB{$\\{buffer}<\\{limit}$}, i.e., when the
current line is nonempty.

\Y\B\4\D$\\{if\_section\_start\_make\_pending}(\|b)$ \6
${}\{{}$\5
\1${}{*}\\{limit}\K\.{'!'};{}$\6
\&{for} ${}(\\{loc}\K\\{buffer};{}$ ${}\\{xisspace}({*}\\{loc});{}$ ${}\\{loc}%
\PP){}$\1\5
;\2\6
${}{*}\\{limit}\K\.{'\ '};{}$\6
\&{if} ${}({*}\\{loc}\E\.{'@'}\W(\\{xisspace}({*}(\\{loc}+\T{1}))\V{*}(\\{loc}+%
\T{1})\E\.{'*'})){}$\1\5
${}\\{change\_pending}\K\|b;{}$\2\6
\4${}\}{}$\2\par
\Y\B\&{void} \\{check\_change}(\,)\C{ switches to \PB{\\{change\_file}} if the
buffers match }\6
${}\{{}$\1\6
\&{int} \|n${}\K\T{0}{}$;\C{ the number of discrepancies found }\7
\&{if} (\\{lines\_dont\_match})\1\5
\&{return};\2\6
${}\\{change\_pending}\K\T{0};{}$\6
\&{if} ${}(\R\\{changed\_section}[\\{section\_count}]){}$\5
${}\{{}$\1\6
\\{if\_section\_start\_make\_pending}(\T{1});\6
\&{if} ${}(\R\\{change\_pending}){}$\1\5
${}\\{changed\_section}[\\{section\_count}]\K\T{1};{}$\2\6
\4${}\}{}$\2\6
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\\{changing}\K\T{1};{}$\6
${}\\{print\_where}\K\T{1};{}$\6
${}\\{change\_line}\PP;{}$\6
\&{if} ${}(\R\\{input\_ln}(\\{change\_file})){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ Change\ file\ ended}\)\.{\ before\ @y"});\6
${}\\{change\_limit}\K\\{change\_buffer};{}$\6
${}\\{changing}\K\T{0};{}$\6
\&{return};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{limit}>\\{buffer}+\T{1}\W\\{buffer}[\T{0}]\E\.{'@'}){}$\5
${}\{{}$\1\6
\&{if} (\\{xisupper}(\\{buffer}[\T{1}]))\1\5
${}\\{buffer}[\T{1}]\K\\{tolower}(\\{buffer}[\T{1}]);{}$\2\6
\X19:If the current line starts with \.{@y}, report any discrepancies and \PB{%
\&{return}}\X;\6
\4${}\}{}$\2\6
\X17:Move \PB{\\{buffer}} and \PB{\\{limit}} to \PB{\\{change\_buffer}} and %
\PB{\\{change\_limit}}\X;\6
${}\\{changing}\K\T{0};{}$\6
${}\\{cur\_line}\PP;{}$\6
\&{while} ${}(\R\\{input\_ln}(\\{cur\_file})){}$\5
${}\{{}$\C{ pop the stack or quit }\1\6
\&{if} ${}(\\{include\_depth}\E\T{0}){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ CWEB\ file\ ended\ d}\)\.{uring\ a\ change"});\6
${}\\{input\_has\_ended}\K\T{1};{}$\6
\&{return};\6
\4${}\}{}$\2\6
${}\\{include\_depth}\MM;{}$\6
${}\\{cur\_line}\PP;{}$\6
\4${}\}{}$\2\6
\&{if} (\\{lines\_dont\_match})\1\5
${}\|n\PP;{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{19}\B\X19:If the current line starts with \.{@y}, report any discrepancies
and \PB{\&{return}}\X${}\E{}$\6
\&{if} ${}(\\{buffer}[\T{1}]\E\.{'x'}\V\\{buffer}[\T{1}]\E\.{'z'}){}$\5
${}\{{}$\1\6
${}\\{loc}\K\\{buffer}+\T{2};{}$\6
\\{err\_print}(\.{"!\ Where\ is\ the\ matc}\)\.{hing\ @y?"});\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{buffer}[\T{1}]\E\.{'y'}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|n>\T{0}){}$\5
${}\{{}$\1\6
${}\\{loc}\K\\{buffer}+\T{2};{}$\6
${}\\{printf}(\.{"\\n!\ Hmm...\ \%d\ "},\39\|n);{}$\6
\\{err\_print}(\.{"of\ the\ preceding\ li}\)\.{nes\ failed\ to\ match"});\6
\4${}\}{}$\2\6
${}\\{change\_depth}\K\\{include\_depth};{}$\6
\&{return};\6
\4${}\}{}$\2\par
\U18.\fi

\M{20}The \PB{\\{reset\_input}} procedure, which gets \.{CWEB} ready to read
the
user's \.{CWEB} input, is used at the beginning of phase one of \.{CTANGLE},
phases one and two of \.{CWEAVE}.

\Y\B\&{void} \\{reset\_input}(\,)\1\1\2\2\6
${}\{{}$\1\6
${}\\{limit}\K\\{buffer};{}$\6
${}\\{loc}\K\\{buffer}+\T{1};{}$\6
${}\\{buffer}[\T{0}]\K\.{'\ '};{}$\6
\X21:Open input files\X;\6
${}\\{include\_depth}\K\T{0};{}$\6
${}\\{cur\_line}\K\T{0};{}$\6
${}\\{change\_line}\K\T{0};{}$\6
${}\\{change\_depth}\K\\{include\_depth};{}$\6
${}\\{changing}\K\T{1};{}$\6
\\{prime\_the\_change\_buffer}(\,);\6
${}\\{changing}\K\R\\{changing};{}$\6
${}\\{limit}\K\\{buffer};{}$\6
${}\\{loc}\K\\{buffer}+\T{1};{}$\6
${}\\{buffer}[\T{0}]\K\.{'\ '};{}$\6
${}\\{input\_has\_ended}\K\T{0};{}$\6
\4${}\}{}$\2\par
\fi

\M{21}The following code opens the input files.

\Y\B\4\X21:Open input files\X${}\E{}$\6
\&{if} ${}((\\{web\_file}\K\\{fopen}(\\{web\_file\_name},\39\.{"r"}))\E%
\NULL){}$\5
${}\{{}$\1\6
${}\\{strcpy}(\\{web\_file\_name},\39\\{alt\_web\_file\_name});{}$\6
\&{if} ${}((\\{web\_file}\K\\{fopen}(\\{web\_file\_name},\39\.{"r"}))\E%
\NULL){}$\1\5
${}\\{fatal}(\.{"!\ Cannot\ open\ input}\)\.{\ file\ "},\39\\{web\_file%
\_name});{}$\2\6
\4${}\}{}$\2\6
${}\\{web\_file\_open}\K\T{1};{}$\6
\&{if} ${}((\\{change\_file}\K\\{fopen}(\\{change\_file\_name},\39\.{"r"}))\E%
\NULL){}$\1\5
${}\\{fatal}(\.{"!\ Cannot\ open\ chang}\)\.{e\ file\ "},\39\\{change\_file%
\_name}){}$;\2\par
\U20.\fi

\M{22}The \PB{\\{get\_line}} procedure is called when \PB{$\\{loc}>\\{limit}$};
it puts the next
line of merged input into the buffer and updates the other variables
appropriately. A space is placed at the right end of the line.
This procedure returns \PB{$\R\\{input\_has\_ended}$} because we often want to
check the value of that variable after calling the procedure.

If we've just changed from the \PB{\\{cur\_file}} to the \PB{\\{change\_file}},
or if
the \PB{\\{cur\_file}} has changed, we tell \.{CTANGLE} to print this
information in the \CEE/ file by means of the \PB{\\{print\_where}} flag.

\Y\B\4\D$\\{max\_sections}$ \5
\T{2000}\C{ number of identifiers, strings, section names;   must be less than
10240 }\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{typedef} \&{unsigned} \&{short} \&{sixteen\_bits};\6
\&{sixteen\_bits} \\{section\_count};\C{ the current section number }\6
\&{boolean} \\{changed\_section}[\\{max\_sections}];\C{ is the section changed?
}\6
\&{boolean} \\{change\_pending};\C{ if the current change is not yet recorded
in   \PB{\\{changed\_section}[\\{section\_count}]} }\6
\&{boolean} \\{print\_where}${}\K\T{0}{}$;\C{ should \.{CTANGLE} print line and
file info? }\par
\fi

\M{23}\B\&{int} \\{get\_line}(\,)\C{ inputs the next line }\6
${}\{{}$\1\6
\4\\{restart}:\5
\X31:Handle reading from copy buffer\X;\6
\&{if} ${}(\\{changing}\W\\{include\_depth}\E\\{change\_depth}){}$\1\5
\X27:Read from \PB{\\{change\_file}} and maybe turn off \PB{\\{changing}}\X;\2\6
\&{if} ${}(\R\\{changing}\V\\{include\_depth}>\\{change\_depth}){}$\5
${}\{{}$\1\6
\X26:Read from \PB{\\{cur\_file}} and maybe turn on \PB{\\{changing}}\X;\6
\&{if} ${}(\\{changing}\W\\{include\_depth}\E\\{change\_depth}){}$\1\5
\&{goto} \\{restart};\2\6
\4${}\}{}$\2\6
\4\\{got\_new\_buffer}:\5
${}\\{loc}\K\\{buffer};{}$\6
${}{*}\\{limit}\K\.{'\ '};{}$\6
\&{if} ${}({*}\\{buffer}\E\.{'@'}\W({*}(\\{buffer}+\T{1})\E\.{'i'}\V{*}(%
\\{buffer}+\T{1})\E\.{'I'})){}$\5
${}\{{}$\1\6
${}\\{loc}\K\\{buffer}+\T{2};{}$\6
\&{while} ${}(\\{loc}\Z\\{limit}\W({*}\\{loc}\E\.{'\ '}\V{*}\\{loc}\E\.{'\\t'}%
\V{*}\\{loc}\E\.{'"'})){}$\1\5
${}\\{loc}\PP;{}$\2\6
\&{if} ${}(\\{loc}\G\\{limit}){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ Include\ file\ name}\)\.{\ not\ given"});\6
\&{goto} \\{restart};\6
\4${}\}{}$\2\6
\&{if} ${}(\\{include\_depth}\G\\{max\_include\_depth}-\T{1}){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ Too\ many\ nested\ i}\)\.{ncludes"});\6
\&{goto} \\{restart};\6
\4${}\}{}$\2\6
${}\\{include\_depth}\PP{}$;\C{ push input stack }\6
\X25:Try to open include file, abort push if unsuccessful, go to \PB{%
\\{restart}}\X;\6
\4${}\}{}$\2\6
\X30:Handle writing to copy buffer\X;\6
\&{return} ${}(\R\\{input\_has\_ended});{}$\6
\4${}\}{}$\2\par
\fi

\M{24}When an \.{@i} line is found in the \PB{\\{cur\_file}}, we must
temporarily
stop reading it and start reading from the named include file.  The
\.{@i} line should give a complete file name with or without
double quotes.
If the environment variable \.{CWEBINPUTS} is set, or if the compiler flag
of the same name was defined at compile time,
\.{CWEB} will look for include files in the directory thus named, if
it cannot find them in the current directory.
(Colon-separated paths are not supported.)
The remainder of the \.{@i} line after the file name is ignored.

\Y\B\4\D$\\{too\_long}()$ \6
${}\{{}$\1\6
${}\\{include\_depth}\MM;{}$\6
\\{err\_print}(\.{"!\ Include\ file\ name}\)\.{\ too\ long"});\6
\&{goto} \\{restart};\6
\4${}\}{}$\2\par
\Y\B\4\X7:Include files\X${}\mathrel+\E{}$\6
\8\#\&{include} \.{<stdlib.h>}\C{ declaration of \PB{\\{getenv}} and \PB{%
\\{exit}} }\par
\fi

\M{25}\B\X25:Try to open include file, abort push if unsuccessful, go to \PB{%
\\{restart}}\X${}\E{}$\6
${}\{{}$\1\6
\&{char} \\{temp\_file\_name}[\\{max\_file\_name\_length}];\6
\&{char} ${}{*}\\{cur\_file\_name\_end}\K\\{cur\_file\_name}+\\{max\_file\_name%
\_length}-\T{1};{}$\6
\&{char} ${}{*}\|k\K\\{cur\_file\_name},{}$ ${}{*}\\{kk};{}$\6
\&{int} \|l;\C{ length of file name }\7
\&{while} ${}({*}\\{loc}\I\.{'\ '}\W{*}\\{loc}\I\.{'\\t'}\W{*}\\{loc}\I\.{'"'}%
\W\|k\Z\\{cur\_file\_name\_end}){}$\1\5
${}{*}\|k\PP\K{*}\\{loc}\PP;{}$\2\6
\&{if} ${}(\|k>\\{cur\_file\_name\_end}){}$\1\5
\\{too\_long}(\,);\2\6
${}{*}\|k\K\.{'\\0'};{}$\6
\&{if} ${}((\\{cur\_file}\K\\{fopen}(\\{cur\_file\_name},\39\.{"r"}))\I%
\NULL){}$\5
${}\{{}$\1\6
\&{if} (\\{rep\_file})\1\5
${}\\{fprintf}(\\{rep\_file},\39\.{"\%s\\n"},\39\\{cur\_file\_name});{}$\2\6
${}\\{cur\_line}\K\T{0};{}$\6
${}\\{print\_where}\K\T{1};{}$\6
\&{goto} \\{restart};\C{ success }\6
\4${}\}{}$\2\6
${}\\{kk}\K\\{getenv}(\.{"CWEBINPUTS"});{}$\6
\&{if} ${}(\\{kk}\I\NULL){}$\5
${}\{{}$\1\6
\&{if} ${}((\|l\K\\{strlen}(\\{kk}))>\\{max\_file\_name\_length}-\T{2}){}$\1\5
\\{too\_long}(\,);\2\6
${}\\{strcpy}(\\{temp\_file\_name},\39\\{kk});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\6
\8\#\&{ifdef} \.{CWEBINPUTS}\1\6
\&{if} ${}((\|l\K\\{strlen}(\.{CWEBINPUTS}))>\\{max\_file\_name\_length}-%
\T{2}){}$\1\5
\\{too\_long}(\,);\2\6
${}\\{strcpy}(\\{temp\_file\_name},\39\.{CWEBINPUTS});{}$\6
\8\#\&{else}\6
${}\|l\K\T{0};{}$\6
\8\#\&{endif}\C{ \PB{\.{CWEBINPUTS}} }\6
\4${}\}{}$\2\6
\&{if} ${}(\|l>\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(\|k+\|l+\T{2}\G\\{cur\_file\_name\_end}){}$\1\5
\\{too\_long}(\,);\2\6
\&{for} ( ; ${}\|k\G\\{cur\_file\_name};{}$ ${}\|k\MM){}$\1\5
${}{*}(\|k+\|l+\T{1})\K{*}\|k;{}$\2\6
${}\\{strcpy}(\\{cur\_file\_name},\39\\{temp\_file\_name});{}$\6
${}\\{cur\_file\_name}[\|l]\K\.{'/'}{}$;\C{ \UNIX/ pathname separator }\6
\&{if} ${}((\\{cur\_file}\K\\{fopen}(\\{cur\_file\_name},\39\.{"r"}))\I%
\NULL){}$\5
${}\{{}$\1\6
\&{if} (\\{rep\_file})\1\5
${}\\{fprintf}(\\{rep\_file},\39\.{"\%s\\n"},\39\\{cur\_file\_name});{}$\2\6
${}\\{cur\_line}\K\T{0};{}$\6
${}\\{print\_where}\K\T{1};{}$\6
\&{goto} \\{restart};\C{ success }\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}\\{include\_depth}\MM;{}$\6
\\{err\_print}(\.{"!\ Cannot\ open\ inclu}\)\.{de\ file"});\6
\&{goto} \\{restart};\6
\4${}\}{}$\2\par
\U23.\fi

\M{26}\B\X26:Read from \PB{\\{cur\_file}} and maybe turn on \PB{\\{changing}}%
\X${}\E{}$\6
${}\{{}$\1\6
${}\\{cur\_line}\PP;{}$\6
\&{while} ${}(\R\\{input\_ln}(\\{cur\_file})){}$\5
${}\{{}$\C{ pop the stack or quit }\1\6
${}\\{print\_where}\K\T{1};{}$\6
\&{if} ${}(\\{include\_depth}\E\T{0}){}$\5
${}\{{}$\1\6
${}\\{input\_has\_ended}\K\T{1};{}$\6
\&{break};\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\\{fclose}(\\{cur\_file});\6
${}\\{include\_depth}\MM;{}$\6
\&{if} ${}(\\{changing}\W\\{include\_depth}\E\\{change\_depth}){}$\1\5
\&{break};\2\6
${}\\{cur\_line}\PP;{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{changing}\W\R\\{input\_has\_ended}){}$\1\6
\&{if} ${}(\\{limit}-\\{buffer}\E\\{change\_limit}-\\{change\_buffer}){}$\1\6
\&{if} ${}(\\{buffer}[\T{0}]\E\\{change\_buffer}[\T{0}]){}$\1\6
\&{if} ${}(\\{change\_limit}>\\{change\_buffer}){}$\1\5
\\{check\_change}(\,);\2\2\2\2\6
\4${}\}{}$\2\par
\U23.\fi

\M{27}\B\X27:Read from \PB{\\{change\_file}} and maybe turn off \PB{%
\\{changing}}\X${}\E{}$\6
${}\{{}$\1\6
${}\\{change\_line}\PP;{}$\6
\&{if} ${}(\R\\{input\_ln}(\\{change\_file})){}$\5
${}\{{}$\1\6
\\{err\_print}(\.{"!\ Change\ file\ ended}\)\.{\ without\ @z"});\6
${}\\{buffer}[\T{0}]\K\.{'@'};{}$\6
${}\\{buffer}[\T{1}]\K\.{'z'};{}$\6
${}\\{limit}\K\\{buffer}+\T{2};{}$\6
\4${}\}{}$\2\6
\&{if} ${}(\\{limit}>\\{buffer}){}$\5
${}\{{}$\C{ check if the change has ended }\1\6
\&{if} (\\{change\_pending})\5
${}\{{}$\1\6
\\{if\_section\_start\_make\_pending}(\T{0});\6
\&{if} (\\{change\_pending})\5
${}\{{}$\1\6
${}\\{changed\_section}[\\{section\_count}]\K\T{1};{}$\6
${}\\{change\_pending}\K\T{0};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
${}{*}\\{limit}\K\.{'\ '};{}$\6
\&{if} ${}(\\{buffer}[\T{0}]\E\.{'@'}){}$\5
${}\{{}$\1\6
\&{if} (\\{xisupper}(\\{buffer}[\T{1}]))\1\5
${}\\{buffer}[\T{1}]\K\\{tolower}(\\{buffer}[\T{1}]);{}$\2\6
\&{if} ${}(\\{buffer}[\T{1}]\E\.{'x'}\V\\{buffer}[\T{1}]\E\.{'y'}){}$\5
${}\{{}$\1\6
${}\\{loc}\K\\{buffer}+\T{2};{}$\6
\\{err\_print}(\.{"!\ Where\ is\ the\ matc}\)\.{hing\ @z?"});\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{buffer}[\T{1}]\E\.{'z'}){}$\5
${}\{{}$\1\6
\\{prime\_the\_change\_buffer}(\,);\6
${}\\{changing}\K\R\\{changing};{}$\6
${}\\{print\_where}\K\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U23.\fi

\M{28}At the end of the program, we will tell the user if the change file
had a line that didn't match any relevant line in \PB{\\{web\_file}}.

\Y\B\&{void} \\{check\_complete}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{if} ${}(\\{change\_limit}\I\\{change\_buffer}){}$\5
${}\{{}$\C{ \PB{\\{changing}} is 0 }\1\6
${}\\{strncpy}(\\{buffer},\39\\{change\_buffer},\39\\{change\_limit}-\\{change%
\_buffer}+\T{1});{}$\6
${}\\{limit}\K\\{buffer}+{}$(\&{int}) ${}(\\{change\_limit}-\\{change%
\_buffer});{}$\6
${}\\{changing}\K\T{1};{}$\6
${}\\{change\_depth}\K\\{include\_depth};{}$\6
${}\\{loc}\K\\{buffer};{}$\6
\\{err\_print}(\.{"!\ Change\ file\ entry}\)\.{\ did\ not\ match"});\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\N{1}{29}Copy buffers.
In order to support \.{mCWEAVE}'s \&{mark}, \&{copy} and \&{paste} commands,
\.{mcommon.w} offers copy buffers.
\PB{\\{get\_line}}, which is responsible for fetching the next line of input to
\PB{\\{buffer}} now can write the input buffer to a copy buffer if \PB{$\\{copy%
\_to\_buffer}\I\T{0}$}
or read from a copy buffer if \PB{$\\{copy\_from\_buffer}\I\T{0}$}.
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{char} ${}{*}\\{copy\_ptr}{}$;\C{ next character to read/write }\6
\&{char} ${}{*}\\{copy\_end}{}$;\C{ end of copy buffer }\6
\&{boolean} \\{copy\_from\_buffer}${},{}$ \\{copy\_to\_buffer};\6
\&{char} ${}{*}\\{rest\_after\_paste}{}$;\C{ rest of input buffer after %
\&{paste} command }\par
\fi

\M{30}We must write all lines we read in \PB{\\{get\_line}} to the copy buffer,
if \PB{$\\{copy\_to\_buffer}\I\T{0}$}.
The location in the copy buffer to write to is \PB{\\{copy\_ptr}}.
\PB{\\{copy\_ptr}} may never grow beyond \PB{\\{copy\_end}}.
\Y\B\4\X30:Handle writing to copy buffer\X${}\E{}$\6
${}\{{}$\1\6
\&{if} (\\{copy\_to\_buffer})\5
${}\{{}$\1\6
\&{int} \\{len}${}\K\\{limit}-\\{buffer};{}$\7
\&{if} ${}(\\{copy\_ptr}+\\{len}+\T{1}\G\\{copy\_end}){}$\1\5
\\{overflow}(\.{"copy\ buffer"});\2\6
${}\\{memcpy}(\\{copy\_ptr},\39\\{buffer},\39\\{len});{}$\6
${}\\{copy\_ptr}[\\{len}\PP]\K\T{0};{}$\6
${}\\{copy\_ptr}\MRL{+{\K}}\\{len};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U23.\fi

\M{31}On the other hand, if \PB{$\\{copy\_from\_buffer}\I\T{0}$}, we read from
the copy buffer
instead of the input file. Again, \PB{\\{copy\_ptr}} points to the current
location
in the copy buffer. The buffer ends at \PB{\\{copy\_end}}. If we reach the end
of the copy buffer, we switch back to the input file (\PB{$\\{copy\_from%
\_buffer}\K\T{0}$})
and append the rest of the line after the \&{paste} command to the current
input buffer. This was saved in \PB{\\{rest\_after\_paste}} by whatever routine
switched
\PB{\\{copy\_from\_buffer}} on.
\Y\B\4\X31:Handle reading from copy buffer\X${}\E{}$\6
${}\{{}$\1\6
\&{if} (\\{copy\_from\_buffer})\5
${}\{{}$\1\6
\&{if} ${}(\\{copy\_ptr}\G\\{copy\_end}){}$\1\5
${}\\{copy\_from\_buffer}\K\T{0};{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{int} \\{len}${}\K\\{strlen}(\\{copy\_ptr});{}$\7
${}\\{strcpy}(\\{buffer},\39\\{copy\_ptr});{}$\6
${}\\{copy\_ptr}\MRL{+{\K}}\\{len}+\T{1};{}$\6
${}\\{limit}\K\\{buffer}+\\{len};{}$\6
\&{if} ${}(\\{copy\_ptr}\G\\{copy\_end}){}$\5
${}\{{}$\C{ end of buffer reached }\1\6
\&{if} (\\{rest\_after\_paste})\5
${}\{{}$\1\6
${}\\{strcpy}(\\{limit},\39\\{rest\_after\_paste});{}$\6
${}\\{limit}\MRL{+{\K}}\\{strlen}(\\{rest\_after\_paste});{}$\6
${}\\{rest\_after\_paste}\K\NULL;{}$\6
\4${}\}{}$\2\6
${}\\{copy\_from\_buffer}\K\T{0};{}$\6
\4${}\}{}$\2\6
\&{goto} \\{got\_new\_buffer};\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U23.\fi

\N{0}{32}Storage of names and strings.
Both \.{CWEAVE} and \.{CTANGLE} store identifiers, section names and
other strings in a large array of \PB{\&{char}}s, called \PB{\\{byte\_mem}}.
Information about the names is kept in the array \PB{\\{name\_dir}}, whose
elements are structures of type \PB{\\{name\_info}}, containing a pointer into
the \PB{\\{byte\_mem}} array (the address where the name begins) and other
data.
A \PB{\&{name\_pointer}} variable is a pointer into \PB{\\{name\_dir}}.

\Y\B\4\D$\\{max\_bytes}$ \5
\T{90000}\C{ the number of bytes in identifiers,   index entries, and section
names; must be less than $2^{24}$ }\par
\B\4\D$\\{max\_names}$ \5
\T{10000}\C{ number of identifiers, strings, section names;   must be less than
10240 }\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{typedef} \&{struct} \\{name\_info} ${}\{{}$\1\6
\&{char} ${}{*}\\{byte\_start}{}$;\C{ beginning of the name in \PB{\\{byte%
\_mem}} }\7
\X36:More elements of \PB{\&{name\_info}} structure\X\2\6
${}\}{}$ \&{name\_info};\C{ contains information about an identifier or section
name }\6
\&{typedef} \&{name\_info} ${}{*}\&{name\_pointer}{}$;\C{ pointer into array of
\PB{\\{name\_info}}s }\6
\&{char} \\{byte\_mem}[\\{max\_bytes}];\C{ characters of names }\6
\&{char} ${}{*}\\{byte\_mem\_end}\K\\{byte\_mem}+\\{max\_bytes}-\T{1}{}$;\C{
end of \PB{\\{byte\_mem}} }\6
\&{name\_info} \\{name\_dir}[\\{max\_names}];\C{ information about names }\6
\&{name\_pointer} \\{name\_dir\_end}${}\K\\{name\_dir}+\\{max\_names}-\T{1}{}$;%
\C{ end of \PB{\\{name\_dir}} }\par
\fi

\M{33}The actual sequence of characters in the name pointed to by a \PB{\&{name%
\_pointer} \|p} appears in positions \PB{$\|p\MG\\{byte\_start}$} to \PB{$(\|p+%
\T{1})\MG\\{byte\_start}-\T{1}$}, inclusive.
The \PB{\\{print\_id}} macro prints this text on the user's terminal.

\Y\B\4\D$\\{length}(\|c)$ \5
$(\|c+\T{1})\MG\\{byte\_start}-(\|c)\MG{}$\\{byte\_start}\C{ the length of a
name }\par
\B\4\D$\\{print\_id}(\|c)$ \5
$\\{term\_write}((\|c)\MG\\{byte\_start},\39\\{length}((\|c)){}$)\C{ print
identifier }\par
\fi

\M{34}The first unused position in \PB{\\{byte\_mem}} and \PB{\\{name\_dir}} is
kept in \PB{\\{byte\_ptr}} and \PB{\\{name\_ptr}}, respectively.  Thus we
usually have \PB{$\\{name\_ptr}\MG\\{byte\_start}\E\\{byte\_ptr}$}, and
certainly
we want to keep \PB{$\\{name\_ptr}\Z\\{name\_dir\_end}$} and \PB{$\\{byte\_ptr}%
\Z\\{byte\_mem\_end}$}.

\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{name\_pointer} \\{name\_ptr};\C{ first unused position in \PB{\\{byte%
\_start}} }\6
\&{char} ${}{*}\\{byte\_ptr}{}$;\C{ first unused position in \PB{\\{byte\_mem}}
}\par
\fi

\M{35}\B\X35:Initialize pointers\X${}\E{}$\6
$\\{name\_dir}\MG\\{byte\_start}\K\\{byte\_ptr}\K\\{byte\_mem}{}$;\C{ position
zero in both arrays }\6
${}\\{name\_ptr}\K\\{name\_dir}+\T{1}{}$;\C{ \PB{\\{name\_dir}[\T{0}]} will be
used only for error recovery }\6
${}\\{name\_ptr}\MG\\{byte\_start}\K\\{byte\_mem}{}$;\C{ this makes name 0 of
length zero }\par
\As39\ET46.
\U6.\fi

\M{36}The names of identifiers are found by computing a hash address \PB{\|h}
and
then looking at strings of bytes signified by the \PB{\&{name\_pointer}}s
\PB{\\{hash}[\|h]}, \PB{$\\{hash}[\|h]\MG\\{link}$}, \PB{$\\{hash}[\|h]\MG%
\\{link}\MG\\{link}$}, \dots,
until either finding the desired name or encountering the null pointer.

\Y\B\4\X36:More elements of \PB{\&{name\_info}} structure\X${}\E{}$\6
\&{struct} \&{name\_info} ${}{*}\\{link}{}$;\par
\As45\ET60.
\U32.\fi

\M{37}The hash table itself
consists of \PB{\\{hash\_size}} entries of type \PB{\&{name\_pointer}}, and is
updated by the \PB{\\{id\_lookup}} procedure, which finds a given identifier
and returns the appropriate \PB{\&{name\_pointer}}. The matching is done by the
function \PB{\\{names\_match}}, which is slightly different in
\.{CWEAVE} and \.{CTANGLE}.  If there is no match for the identifier,
it is inserted into the table.

\Y\B\4\D$\\{hash\_size}$ \5
\T{353}\C{ should be prime }\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{typedef} \&{name\_pointer} ${}{*}\&{hash\_pointer};{}$\6
\&{name\_pointer} \\{hash}[\\{hash\_size}];\C{ heads of hash lists }\6
\&{hash\_pointer} \\{hash\_end}${}\K\\{hash}+\\{hash\_size}-\T{1}{}$;\C{ end of
\PB{\\{hash}} }\6
\&{hash\_pointer} \|h;\C{ index into hash-head array }\par
\fi

\M{38}\B\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{extern} \&{int} \\{names\_match}(\,);\par
\fi

\M{39}Initially all the hash lists are empty.

\Y\B\4\X35:Initialize pointers\X${}\mathrel+\E{}$\6
\&{for} ${}(\|h\K\\{hash};{}$ ${}\|h\Z\\{hash\_end};{}$ ${}{*}\|h\PP\K\NULL){}$%
\1\5
;\2\par
\fi

\M{40}Here is the main procedure for finding identifiers:

\Y\B\&{name\_pointer} ${}\\{id\_lookup}(\\{first},\39\\{last},\39\|t{}$)\C{
looks up a string in the identifier table }\1\1\6
\&{char} ${}{*}\\{first}{}$;\C{ first character of string }\6
\&{char} ${}{*}\\{last}{}$;\C{ last character of string plus one }\6
\&{char} \|t;\C{ the \PB{\\{ilk}}; used by \.{CWEAVE} only }\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\|i\K\\{first}{}$;\C{ position in \PB{\\{buffer}} }\6
\&{int} \|h;\C{ hash code }\6
\&{int} \|l;\C{ length of the given identifier }\6
\&{name\_pointer} \|p;\C{ where the identifier is being sought }\7
\&{if} ${}(\\{last}\E\NULL){}$\1\6
\&{for} ${}(\\{last}\K\\{first};{}$ ${}{*}\\{last}\I\.{'\\0'};{}$ ${}\\{last}%
\PP){}$\1\5
;\2\2\6
${}\|l\K\\{last}-\\{first}{}$;\C{ compute the length }\6
\X41:Compute the hash code \PB{\|h}\X;\6
\X42:Compute the name location \PB{\|p}\X;\6
\&{if} ${}(\|p\E\\{name\_ptr}){}$\1\5
\X44:Enter a new name into the table at position \PB{\|p}\X;\2\6
\&{return} (\|p);\6
\4${}\}{}$\2\par
\fi

\M{41}A simple hash code is used: If the sequence of
character codes is $c_1c_2\ldots c_n$, its hash value will be
$$(2^{n-1}c_1+2^{n-2}c_2+\cdots+c_n)\,\bmod\,\PB{\\{hash\_size}}.$$

\Y\B\4\X41:Compute the hash code \PB{\|h}\X${}\E{}$\6
$\|h\K{}$(\&{unsigned} \&{char}) ${}{*}\|i;{}$\6
\&{while} ${}(\PP\|i<\\{last}){}$\1\5
${}\|h\K(\|h+\|h+{}$(\&{int}) ((\&{unsigned} \&{char}) ${}{*}\|i))\MOD\\{hash%
\_size}{}$;\2\par
\U40.\fi

\M{42}If the identifier is new, it will be placed in position \PB{$\|p\K\\{name%
\_ptr}$},
otherwise \PB{\|p} will point to its existing location.

\Y\B\4\X42:Compute the name location \PB{\|p}\X${}\E{}$\6
$\|p\K\\{hash}[\|h];{}$\6
\&{while} ${}(\|p\W\R\\{names\_match}(\|p,\39\\{first},\39\|l,\39\|t)){}$\1\5
${}\|p\K\|p\MG\\{link};{}$\2\6
\&{if} ${}(\|p\E\NULL){}$\5
${}\{{}$\1\6
${}\|p\K\\{name\_ptr}{}$;\C{ the current identifier is new }\6
${}\|p\MG\\{link}\K\\{hash}[\|h];{}$\6
${}\\{hash}[\|h]\K\|p{}$;\C{ insert \PB{\|p} at beginning of hash list }\6
\4${}\}{}$\2\par
\U40.\fi

\M{43}The information associated with a new identifier must be initialized
in a slightly different way in \.{CWEAVE} than in \.{CTANGLE}; hence the
\PB{\\{init\_p}} procedure.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{void} \\{init\_p}(\,);\par
\fi

\M{44}\B\X44:Enter a new name into the table at position \PB{\|p}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{byte\_ptr}+\|l>\\{byte\_mem\_end}){}$\1\5
\\{overflow}(\.{"byte\ memory"});\2\6
\&{if} ${}(\\{name\_ptr}\G\\{name\_dir\_end}){}$\1\5
\\{overflow}(\.{"name"});\2\6
${}\\{strncpy}(\\{byte\_ptr},\39\\{first},\39\|l);{}$\6
${}(\PP\\{name\_ptr})\MG\\{byte\_start}\K\\{byte\_ptr}\MRL{+{\K}}\|l;{}$\6
\&{if} ${}(\\{program}\E\\{cweave}){}$\5
${}\{{}$\1\6
${}\\{init\_p}(\|p,\39\|t);{}$\6
${}\\{init\_p}(\\{name\_ptr},\39\T{0});{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U40.\fi

\M{45}The names of sections are stored in \PB{\\{byte\_mem}} together
with the identifier names, but a hash table is not used for them because
\.{CTANGLE} needs to be able to recognize a section name when given a prefix of
that name. A conventional binary search tree is used to retrieve section names,
with fields called \PB{\\{llink}} and \PB{\\{rlink}} (where \PB{\\{llink}}
takes the place
of \PB{\\{link}}).  The root of this tree is stored in \PB{$\\{name\_dir}\MG%
\\{rlink}$};
this will be the only information in \PB{\\{name\_dir}[\T{0}]}.

Since the space used by \PB{\\{rlink}} has a different function for
identifiers than for section names, we declare it as a \PB{\&{union}}.

\Y\B\4\D$\\{llink}$ \5
\\{link}\C{ left link in binary search tree for section names }\par
\B\4\D$\\{rlink}$ \5
$\\{dummy}.{}$\\{Rlink}\C{ right link in binary search tree for section names }%
\par
\B\4\D$\\{root}$ \5
$\\{name\_dir}\MG{}$\\{rlink}\C{ the root of the binary search tree   for
section names }\par
\Y\B\4\X36:More elements of \PB{\&{name\_info}} structure\X${}\mathrel+\E{}$\6
\&{union} ${}\{{}$\1\6
\&{struct} \&{name\_info} ${}{*}\\{Rlink}{}$;\C{ right link in binary search
tree for section     names }\6
\&{char} \\{Ilk};\C{ used by identifiers in \.{CWEAVE} only }\2\6
${}\}{}$ \\{dummy};\par
\fi

\M{46}\B\X35:Initialize pointers\X${}\mathrel+\E{}$\6
$\\{root}\K\NULL{}$;\C{ the binary search tree starts out with nothing in it }%
\par
\fi

\M{47}If \PB{\|p} is a \PB{\&{name\_pointer}} variable, as we have seen,
\PB{$\|p\MG\\{byte\_start}$} is the beginning of the area where the name
corresponding to \PB{\|p} is stored.  However, if \PB{\|p} refers to a section
name, the name may need to be stored in chunks, because it may
``grow'': a prefix of the section name may be encountered before
the full name.  Furthermore we need to know the length of the shortest
prefix of the name that was ever encountered.

We solve this problem by inserting two extra bytes at \PB{$\|p\MG\\{byte%
\_start}$},
representing the length of the shortest prefix, when \PB{\|p} is a
section name. Furthermore, the last byte of the name will be a blank
space if \PB{\|p} is a prefix. In the latter case, the name pointer
\PB{$\|p+\T{1}$} will allow us to access additional chunks of the name:
The second chunk will begin at the name pointer \PB{$(\|p+\T{1})\MG\\{link}$},
and if it too is a prefix (ending with blank) its \PB{\\{link}} will point
to additional chunks in the same way. Null links are represented by
\PB{\\{name\_dir}}.

\Y\B\4\D$\\{first\_chunk}(\|p)$ \5
$((\|p)\MG\\{byte\_start}+\T{2}{}$)\par
\B\4\D$\\{prefix\_length}(\|p)$ \5
(\&{int}) ((\&{unsigned} \&{char}) ${}{*}((\|p)\MG\\{byte\_start})*\T{256}+{}$(%
\&{unsigned} \&{char}) ${}{*}((\|p)\MG\\{byte\_start}+\T{1}){}$)\par
\B\4\D$\\{set\_prefix\_length}(\|p,\|m)$ \5
$({*}((\|p)\MG\\{byte\_start})\K(\|m)/\T{256},\39{*}((\|p)\MG\\{byte\_start}+%
\T{1})\K(\|m)\MOD\T{256}{}$)\par
\Y\B\&{void} \\{print\_section\_name}(\|p)\1\1\6
\&{name\_pointer} \|p;\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{ss},{}$ ${}{*}\|s\K\\{first\_chunk}(\|p);{}$\6
\&{name\_pointer} \|q${}\K\|p+\T{1};{}$\7
\&{while} ${}(\|p\I\\{name\_dir}){}$\5
${}\{{}$\1\6
${}\\{ss}\K(\|p+\T{1})\MG\\{byte\_start}-\T{1};{}$\6
\&{if} ${}({*}\\{ss}\E\.{'\ '}\W\\{ss}\G\|s){}$\5
${}\{{}$\1\6
${}\\{term\_write}(\|s,\39\\{ss}-\|s);{}$\6
${}\|p\K\|q\MG\\{link};{}$\6
${}\|q\K\|p;{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{term\_write}(\|s,\39\\{ss}+\T{1}-\|s);{}$\6
${}\|p\K\\{name\_dir};{}$\6
${}\|q\K\NULL;{}$\6
\4${}\}{}$\2\6
${}\|s\K\|p\MG\\{byte\_start};{}$\6
\4${}\}{}$\2\6
\&{if} (\|q)\1\5
${}\\{term\_write}(\.{"..."},\39\T{3}){}$;\C{ complete name not yet known }\2\6
\4${}\}{}$\2\par
\fi

\M{48}\B\&{void} ${}\\{sprint\_section\_name}(\\{dest},\39\|p){}$\1\1\6
\&{char} ${}{*}\\{dest};{}$\6
\&{name\_pointer} \|p;\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{ss},{}$ ${}{*}\|s\K\\{first\_chunk}(\|p);{}$\6
\&{name\_pointer} \|q${}\K\|p+\T{1};{}$\7
\&{while} ${}(\|p\I\\{name\_dir}){}$\5
${}\{{}$\1\6
${}\\{ss}\K(\|p+\T{1})\MG\\{byte\_start}-\T{1};{}$\6
\&{if} ${}({*}\\{ss}\E\.{'\ '}\W\\{ss}\G\|s){}$\5
${}\{{}$\1\6
${}\|p\K\|q\MG\\{link};{}$\6
${}\|q\K\|p;{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{ss}\PP;{}$\6
${}\|p\K\\{name\_dir};{}$\6
\4${}\}{}$\2\6
${}\\{strncpy}(\\{dest},\39\|s,\39\\{ss}-\|s),\39\\{dest}\MRL{+{\K}}\\{ss}-%
\|s;{}$\6
${}\|s\K\|p\MG\\{byte\_start};{}$\6
\4${}\}{}$\2\6
${}{*}\\{dest}\K\.{'\\0'};{}$\6
\4${}\}{}$\2\par
\fi

\M{49}\B\&{void} \\{print\_prefix\_name}(\|p)\1\1\6
\&{name\_pointer} \|p;\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\|s\K\\{first\_chunk}(\|p);{}$\6
\&{int} \|l${}\K\\{prefix\_length}(\|p);{}$\7
${}\\{term\_write}(\|s,\39\|l);{}$\6
\&{if} ${}(\|s+\|l<(\|p+\T{1})\MG\\{byte\_start}){}$\1\5
${}\\{term\_write}(\.{"..."},\39\T{3});{}$\2\6
\4${}\}{}$\2\par
\fi

\M{50}When we compare two section names, we'll need a function analogous to
\PB{\\{strcmp}}. But we do not assume the strings
are null-terminated, and we keep an eye open for prefixes and extensions.

\Y\B\4\D$\\{less}$ \5
\T{0}\C{ the first name is lexicographically less than the second }\par
\B\4\D$\\{equal}$ \5
\T{1}\C{ the first name is equal to the second }\par
\B\4\D$\\{greater}$ \5
\T{2}\C{ the first name is lexicographically greater than the second }\par
\B\4\D$\\{prefix}$ \5
\T{3}\C{ the first name is a proper prefix of the second }\par
\B\4\D$\\{extension}$ \5
\T{4}\C{ the first name is a proper extension of the second }\par
\Y\B\&{int} ${}\\{web\_strcmp}(\|j,\39\\{j\_len},\39\|k,\39\\{k\_len}{}$)\C{
fuller comparison than \PB{\\{strcmp}} }\1\1\6
\&{char} ${}{*}\|j,{}$ ${}{*}\|k{}$;\C{ beginning of first and second strings }%
\6
\&{int} \\{j\_len}${},{}$ \\{k\_len};\C{ length of strings }\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{j1}\K\|j+\\{j\_len},{}$ ${}{*}\\{k1}\K\|k+\\{k\_len};{}$\7
\&{while} ${}(\|k<\\{k1}\W\|j<\\{j1}\W{*}\|j\E{*}\|k){}$\1\5
${}\|k\PP,\39\|j\PP;{}$\2\6
\&{if} ${}(\|k\E\\{k1}){}$\1\6
\&{if} ${}(\|j\E\\{j1}){}$\1\5
\&{return} \\{equal};\2\6
\&{else}\1\5
\&{return} \\{extension};\2\2\6
\&{else} \&{if} ${}(\|j\E\\{j1}){}$\1\5
\&{return} \\{prefix};\2\6
\&{else} \&{if} ${}({*}\|j<{*}\|k){}$\1\5
\&{return} \\{less};\2\6
\&{else}\1\5
\&{return} \\{greater};\2\6
\4${}\}{}$\2\par
\fi

\M{51}Adding a section name to the tree is straightforward if we know its
parent and whether it's the \PB{\\{rlink}} or \PB{\\{llink}} of the parent.  As
a
special case, when the name is the first section being added, we set the
``parent'' to \PB{$\NULL$}.  When a section name is created, it has only one
chunk, which however may be just a prefix: the full name will
hopefully be unveiled later.  Obviously, \PB{\\{prefix\_length}} starts
out as the length of the first chunk, though it may decrease later.

The information associated with a new node must be initialized
differently in \.{CWEAVE} and \.{CTANGLE}; hence the
\PB{\\{init\_node}} procedure, which is defined differently in \.{mcweave.w}
and \.{mctangle.w}.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{extern} \&{void} \\{init\_node}(\,);\par
\fi

\M{52}\B\&{name\_pointer} ${}\\{add\_section\_name}(\\{par},\39\|c,\39%
\\{first},\39\\{last},\39\\{ispref}{}$)\C{ install a new node in the tree }\1\1%
\6
\&{name\_pointer} \\{par};\C{ parent of new node }\6
\&{int} \|c;\C{ right or left? }\6
\&{char} ${}{*}\\{first}{}$;\C{ first character of section name }\6
\&{char} ${}{*}\\{last}{}$;\C{ last character of section name, plus one }\6
\&{int} \\{ispref};\C{ are we adding a prefix or a full name? }\2\2\6
${}\{{}$\1\6
\&{name\_pointer} \|p${}\K\\{name\_ptr}{}$;\C{ new node }\6
\&{char} ${}{*}\|s\K\\{first\_chunk}(\|p);{}$\6
\&{int} \\{name\_len}${}\K\\{last}-\\{first}+\\{ispref}{}$;\C{ length of
section name }\7
\&{if} ${}(\|s+\\{name\_len}>\\{byte\_mem\_end}){}$\1\5
\\{overflow}(\.{"byte\ memory"});\2\6
\&{if} ${}(\\{name\_ptr}+\T{1}\G\\{name\_dir\_end}){}$\1\5
\\{overflow}(\.{"name"});\2\6
${}(\PP\\{name\_ptr})\MG\\{byte\_start}\K\\{byte\_ptr}\K\|s+\\{name\_len};{}$\6
\&{if} ${}(\\{program}\E\\{cweave}){}$\1\5
${}\\{init\_p}(\\{name\_ptr},\39\T{0});{}$\2\6
\&{if} (\\{ispref})\5
${}\{{}$\1\6
${}{*}(\\{byte\_ptr}-\T{1})\K\.{'\ '};{}$\6
${}\\{name\_len}\MM;{}$\6
${}\\{name\_ptr}\MG\\{link}\K\\{name\_dir};{}$\6
${}(\PP\\{name\_ptr})\MG\\{byte\_start}\K\\{byte\_ptr};{}$\6
\&{if} ${}(\\{program}\E\\{cweave}){}$\1\5
${}\\{init\_p}(\\{name\_ptr},\39\T{0});{}$\2\6
\4${}\}{}$\2\6
${}\\{set\_prefix\_length}(\|p,\39\\{name\_len});{}$\6
${}\\{strncpy}(\|s,\39\\{first},\39\\{name\_len});{}$\6
${}\|p\MG\\{llink}\K\NULL;{}$\6
${}\|p\MG\\{rlink}\K\NULL;{}$\6
\\{init\_node}(\|p);\6
\&{return} ${}\\{par}\E\NULL\?(\\{root}\K\|p):\|c\E\\{less}\?(\\{par}\MG%
\\{llink}\K\|p):(\\{par}\MG\\{rlink}\K\|p);{}$\6
\4${}\}{}$\2\par
\fi

\M{53}\B\&{void} ${}\\{extend\_section\_name}(\|p,\39\\{first},\39\\{last},\39%
\\{ispref}){}$\1\1\6
\&{name\_pointer} \|p;\C{ name to be extended }\6
\&{char} ${}{*}\\{first}{}$;\C{ beginning of extension text }\6
\&{char} ${}{*}\\{last}{}$;\C{ one beyond end of extension text }\6
\&{int} \\{ispref};\C{ are we adding a prefix or a full name? }\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\|s;{}$\6
\&{name\_pointer} \|q${}\K\|p+\T{1};{}$\6
\&{int} \\{name\_len}${}\K\\{last}-\\{first}+\\{ispref};{}$\7
\&{if} ${}(\\{name\_ptr}\G\\{name\_dir\_end}){}$\1\5
\\{overflow}(\.{"name"});\2\6
\&{while} ${}(\|q\MG\\{link}\I\\{name\_dir}){}$\1\5
${}\|q\K\|q\MG\\{link};{}$\2\6
${}\|q\MG\\{link}\K\\{name\_ptr};{}$\6
${}\|s\K\\{name\_ptr}\MG\\{byte\_start};{}$\6
${}\\{name\_ptr}\MG\\{link}\K\\{name\_dir};{}$\6
\&{if} ${}(\|s+\\{name\_len}>\\{byte\_mem\_end}){}$\1\5
\\{overflow}(\.{"byte\ memory"});\2\6
${}(\PP\\{name\_ptr})\MG\\{byte\_start}\K\\{byte\_ptr}\K\|s+\\{name\_len};{}$\6
\&{if} ${}(\\{program}\E\\{cweave}){}$\1\5
${}\\{init\_p}(\\{name\_ptr},\39\T{0});{}$\2\6
${}\\{strncpy}(\|s,\39\\{first},\39\\{name\_len});{}$\6
\&{if} (\\{ispref})\1\5
${}{*}(\\{byte\_ptr}-\T{1})\K\.{'\ '};{}$\2\6
\4${}\}{}$\2\par
\fi

\M{54}The \PB{\\{section\_lookup}} procedure is supposed to find a
section name that matches a new name, installing the new name if
it doesn't match an existing one. The new name is the string
between \PB{\\{first}} and \PB{\\{last}}; a ``match'' means that the new name
exactly equals or is a prefix or extension of a name in the tree.

\Y\B\&{name\_pointer} ${}\\{section\_lookup}(\\{first},\39\\{last},\39%
\\{ispref}{}$)\C{ find or install section name in tree }\1\1\6
\&{char} ${}{*}\\{first},{}$ ${}{*}\\{last}{}$;\C{ first and last characters of
new name }\6
\&{int} \\{ispref};\C{ is the new name a prefix or a full name? }\2\2\6
${}\{{}$\1\6
\&{int} \|c${}\K\T{0}{}$;\C{ comparison between two names; initialized so some
compilers won't complain }\6
\&{name\_pointer} \|p${}\K\\{root}{}$;\C{ current node of the search tree }\6
\&{name\_pointer} \|q${}\K\NULL{}$;\C{ another place to look in the tree }\6
\&{name\_pointer} \|r${}\K\NULL{}$;\C{ where a match has been found }\6
\&{name\_pointer} \\{par}${}\K\NULL{}$;\C{ parent of \PB{\|p}, if \PB{\|r} is %
\PB{$\NULL$};             otherwise parent of \PB{\|r} }\6
\&{int} \\{name\_len}${}\K\\{last}-\\{first}+\T{1};{}$\7
\X55:Look for matches for new name among shortest prefixes, complaining if more
than one is found\X;\6
\X56:If no match found, add new name to tree\X;\6
\X57:If one match found, check for compatibility and return match\X;\6
\4${}\}{}$\2\par
\fi

\M{55}A legal new name matches an existing section name if and only if it
matches the shortest prefix of that section name.  Therefore we can
limit our search for matches to shortest prefixes, which eliminates
the need for chunk-chasing at this stage.

\Y\B\4\X55:Look for matches for new name among shortest prefixes, complaining
if more than one is found\X${}\E{}$\6
\&{while} (\|p)\5
${}\{{}$\C{ compare shortest prefix of \PB{\|p} with new name }\1\6
${}\|c\K\\{web\_strcmp}(\\{first},\39\\{name\_len},\39\\{first\_chunk}(\|p),\39%
\\{prefix\_length}(\|p));{}$\6
\&{if} ${}(\|c\E\\{less}\V\|c\E\\{greater}){}$\5
${}\{{}$\C{ new name does not match \PB{\|p} }\1\6
\&{if} ${}(\|r\E\NULL{}$)\C{ no previous matches have been found }\1\6
${}\\{par}\K\|p;{}$\2\6
${}\|p\K(\|c\E\\{less}\?\|p\MG\\{llink}:\|p\MG\\{rlink});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\C{ new name matches \PB{\|p} }\1\6
\&{if} ${}(\|r\I\NULL){}$\5
${}\{{}$\C{ and also \PB{\|r}: illegal }\1\6
\\{printf}(\.{"\\n!\ Ambiguous\ prefi}\)\.{x:\ matches\ <"});\6
\\{print\_prefix\_name}(\|p);\6
\\{printf}(\.{">\\n\ and\ <"});\6
\\{print\_prefix\_name}(\|r);\6
\\{err\_print}(\.{">"});\6
\&{return} \\{name\_dir};\C{ the unsection }\6
\4${}\}{}$\2\6
${}\|r\K\|p{}$;\C{ remember match }\6
${}\|p\K\|p\MG\\{llink}{}$;\C{ try another }\6
${}\|q\K\|r\MG\\{rlink}{}$;\C{ we'll get back here if the new \PB{\|p} doesn't
match }\6
\4${}\}{}$\2\6
\&{if} ${}(\|p\E\NULL){}$\1\5
${}\|p\K\|q,\39\|q\K\NULL{}$;\C{ \PB{\|q} held the other branch of \PB{\|r} }\2%
\6
\4${}\}{}$\2\par
\U54.\fi

\M{56}\B\X56:If no match found, add new name to tree\X${}\E{}$\6
\&{if} ${}(\|r\E\NULL{}$)\C{ no matches were found }\1\6
\&{return} ${}\\{add\_section\_name}(\\{par},\39\|c,\39\\{first},\39\\{last}+%
\T{1},\39\\{ispref}){}$;\2\par
\U54.\fi

\M{57}Although error messages are given in anomalous cases, we do return the
unique best match when a discrepancy is found, because users often
change a title in one place while forgetting to change it elsewhere.

\Y\B\4\X57:If one match found, check for compatibility and return match\X${}%
\E{}$\6
\&{switch} ${}(\\{section\_name\_cmp}({\AND}\\{first},\39\\{name\_len},\39%
\|r)){}$\5
${}\{{}$\C{ compare all of \PB{\|r} with new name }\1\6
\4\&{case} \\{prefix}:\6
\&{if} ${}(\R\\{ispref}){}$\5
${}\{{}$\1\6
\\{printf}(\.{"\\n!\ New\ name\ is\ a\ p}\)\.{refix\ of\ <"});\6
\\{print\_section\_name}(\|r);\6
\\{err\_print}(\.{">"});\6
\4${}\}{}$\2\6
\&{else} \&{if} ${}(\\{name\_len}<\\{prefix\_length}(\|r)){}$\1\5
${}\\{set\_prefix\_length}(\|r,\39\\{name\_len}){}$;\C{ fall through }\2\6
\4\&{case} \\{equal}:\5
\&{return} \|r;\6
\4\&{case} \\{extension}:\6
\&{if} ${}(\R\\{ispref}\V\\{first}\Z\\{last}){}$\1\5
${}\\{extend\_section\_name}(\|r,\39\\{first},\39\\{last}+\T{1},\39%
\\{ispref});{}$\2\6
\&{return} \|r;\6
\4\&{case} \\{bad\_extension}:\5
\\{printf}(\.{"\\n!\ New\ name\ extend}\)\.{s\ <"});\6
\\{print\_section\_name}(\|r);\6
\\{err\_print}(\.{">"});\6
\&{return} \|r;\6
\4\&{default}:\C{ no match: illegal }\6
\\{printf}(\.{"\\n!\ Section\ name\ in}\)\.{compatible\ with\ <"});\6
\\{print\_prefix\_name}(\|r);\6
\\{printf}(\.{">,\\n\ which\ abbrevia}\)\.{tes\ <"});\6
\\{print\_section\_name}(\|r);\6
\\{err\_print}(\.{">"});\6
\&{return} \|r;\6
\4${}\}{}$\2\par
\U54.\fi

\M{58}The return codes of \PB{\\{section\_name\_cmp}}, which compares a string
with
the full name of a section, are those of \PB{\\{web\_strcmp}} plus
\PB{\\{bad\_extension}}, used when the string is an extension of a
supposedly already complete section name.  This function has a side
effect when the comparison string is an extension: it advances the
address of the first character of the string by an amount equal to
the length of the known part of the section name.

The name \.{@<foo...@>} should be an acceptable ``abbreviation''
for \.{@<foo@>}. If such an abbreviation comes after the complete
name, there's no trouble recognizing it. If it comes before the
complete name, we simply append a null chunk. This logic requires
us to regard \.{@<foo...@>} as an ``extension'' of itself.

\Y\B\4\D$\\{bad\_extension}$ \5
\T{5}\par
\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{int} \\{section\_name\_cmp}(\,);\par
\fi

\M{59}\B\&{int} ${}\\{section\_name\_cmp}(\\{pfirst},\39\\{len},\39\|r){}$\1\1\6
\&{char} ${}{*}{*}\\{pfirst}{}$;\C{ pointer to beginning of comparison string }%
\6
\&{int} \\{len};\C{ length of string }\6
\&{name\_pointer} \|r;\C{ section name being compared }\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{first}\K{*}\\{pfirst}{}$;\C{ beginning of comparison string }%
\6
\&{name\_pointer} \|q${}\K\|r+\T{1}{}$;\C{ access to subsequent chunks }\6
\&{char} ${}{*}\\{ss},{}$ ${}{*}\|s\K\\{first\_chunk}(\|r);{}$\6
\&{int} \|c;\C{ comparison }\6
\&{int} \\{ispref};\C{ is chunk \PB{\|r} a prefix? }\7
\&{while} (\T{1})\5
${}\{{}$\1\6
${}\\{ss}\K(\|r+\T{1})\MG\\{byte\_start}-\T{1};{}$\6
\&{if} ${}({*}\\{ss}\E\.{'\ '}\W\\{ss}\G\|r\MG\\{byte\_start}){}$\1\5
${}\\{ispref}\K\T{1},\39\|q\K\|q\MG\\{link};{}$\2\6
\&{else}\1\5
${}\\{ispref}\K\T{0},\39\\{ss}\PP,\39\|q\K\\{name\_dir};{}$\2\6
\&{switch} ${}(\|c\K\\{web\_strcmp}(\\{first},\39\\{len},\39\|s,\39\\{ss}-%
\|s)){}$\5
${}\{{}$\1\6
\4\&{case} \\{equal}:\6
\&{if} ${}(\|q\E\\{name\_dir}){}$\1\6
\&{if} (\\{ispref})\5
${}\{{}$\1\6
${}{*}\\{pfirst}\K\\{first}+(\\{ss}-\|s);{}$\6
\&{return} \\{extension};\C{ null extension }\6
\4${}\}{}$\2\6
\&{else}\1\5
\&{return} \\{equal};\2\2\6
\&{else}\1\5
\&{return} ${}(\|q\MG\\{byte\_start}\E(\|q+\T{1})\MG\\{byte\_start})\?%
\\{equal}:\\{prefix};{}$\2\6
\4\&{case} \\{extension}:\6
\&{if} ${}(\R\\{ispref}){}$\1\5
\&{return} \\{bad\_extension};\2\6
${}\\{first}\MRL{+{\K}}\\{ss}-\|s;{}$\6
\&{if} ${}(\|q\I\\{name\_dir}){}$\5
${}\{{}$\1\6
${}\\{len}\MRL{-{\K}}\\{ss}-\|s;{}$\6
${}\|s\K\|q\MG\\{byte\_start};{}$\6
${}\|r\K\|q;{}$\6
\&{continue};\6
\4${}\}{}$\2\6
${}{*}\\{pfirst}\K\\{first};{}$\6
\&{return} \\{extension};\6
\4\&{default}:\5
\&{return} \|c;\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\fi

\M{60}The last component of \PB{\&{name\_info}} is different for \.{CTANGLE}
and
\.{CWEAVE}.  In \.{CTANGLE}, if \PB{\|p} is a pointer to a section name,
\PB{$\|p\MG\\{equiv}$} is a pointer to its replacement text, an element of the
array \PB{\\{text\_info}}.  In \.{CWEAVE}, on the other hand, if
\PB{\|p} points to an identifier, \PB{$\|p\MG\\{xref}$} is a pointer to its
list of cross-references, an element of the array \PB{\\{xmem}}.  The make-up
of \PB{\\{text\_info}} and \PB{\\{xmem}} is discussed in the \.{CTANGLE} and %
\.{CWEAVE}
source files, respectively; here we just declare a common field
\PB{\\{equiv\_or\_xref}} as a pointer to a \PB{\&{char}}.

\Y\B\4\X36:More elements of \PB{\&{name\_info}} structure\X${}\mathrel+\E{}$\6
\&{char} ${}{*}\\{equiv\_or\_xref}{}$;\C{ info corresponding to names }\par
\fi

\N{0}{61}Reporting errors to the user.
A global variable called \PB{\\{history}} will contain one of four values
at the end of every run: \PB{\\{spotless}} means that no unusual messages were
printed; \PB{\\{harmless\_message}} means that a message of possible interest
was printed but no serious errors were detected; \PB{\\{error\_message}} means
that
at least one error was found; \PB{\\{fatal\_message}} means that the program
terminated abnormally. The value of \PB{\\{history}} does not influence the
behavior of the program; it is simply computed for the convenience
of systems that might want to use such information.

\Y\B\4\D$\\{spotless}$ \5
\T{0}\C{ \PB{\\{history}} value for normal jobs }\par
\B\4\D$\\{harmless\_message}$ \5
\T{1}\C{ \PB{\\{history}} value when non-serious info was printed }\par
\B\4\D$\\{error\_message}$ \5
\T{2}\C{ \PB{\\{history}} value when an error was noted }\par
\B\4\D$\\{fatal\_message}$ \5
\T{3}\C{ \PB{\\{history}} value when we had to stop prematurely }\par
\B\4\D$\\{mark\_harmless}$ \6
${}\{{}$\1\6
\&{if} ${}(\\{history}\E\\{spotless}){}$\1\5
${}\\{history}\K\\{harmless\_message};{}$\2\6
\4${}\}{}$\2\par
\B\4\D$\\{mark\_error}$ \5
$\\{history}\K{}$\\{error\_message}\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{int} \\{history}${}\K\\{spotless}{}$;\C{ indicates how bad this run was }\par
\fi

\M{62}The command `\PB{\\{err\_print}(\.{"!\ Error\ message"})}' will report a
syntax error to
the user, by printing the error message at the beginning of a new line and
then giving an indication of where the error was spotted in the source file.
Note that no period follows the error message, since the error routine
will automatically supply a period. A newline is automatically supplied
if the string begins with \PB{\.{"!"}}.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{void} \\{err\_print}(\,);\par
\fi

\M{63}
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{boolean} \\{parsing\_exp\_file};\C{ are we parsing an exported file (export
or shared file)? }\par
\fi

\M{64}\B\&{void} \\{err\_print}(\|s)\C{ prints `\..' and location of error
message }\1\1\6
\&{char} ${}{*}\|s;\2\2{}$\6
${}\{{}$\1\6
\&{char} ${}{*}\|k,{}$ ${}{*}\|l{}$;\C{ pointers into \PB{\\{buffer}} }\7
${}\\{printf}({*}\|s\E\.{'!'}\?\.{"\\n\%s"}:\.{"\%s"},\39\|s);{}$\6
\&{if} (\\{web\_file\_open})\1\5
\X65:Print error location based on input buffer\X;\2\6
\\{update\_terminal};\6
\\{mark\_error};\6
\4${}\}{}$\2\par
\fi

\M{65}The error locations can be indicated by using the global variables
\PB{\\{loc}}, \PB{\\{cur\_line}}, \PB{\\{cur\_file\_name}} and \PB{%
\\{changing}},
which tell respectively the first
unlooked-at position in \PB{\\{buffer}}, the current line number, the current
file, and whether the current line is from \PB{\\{change\_file}} or \PB{\\{cur%
\_file}}.
This routine should be modified on systems whose standard text editor
has special line-numbering conventions.

\Y\B\4\X65:Print error location based on input buffer\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{changing}\W\\{include\_depth}\E\\{change\_depth}){}$\1\5
${}\\{printf}(\.{".\ (l.\ \%d\ of\ change\ }\)\.{file)\\n"},\39\\{change%
\_line});{}$\2\6
\&{else} \&{if} ${}(\\{include\_depth}\E\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(\R\\{parsing\_exp\_file}){}$\1\5
${}\\{printf}(\.{".\ (l.\ \%d)\\n"},\39\\{cur\_line});{}$\2\6
\4${}\}{}$\2\6
\&{else}\1\5
${}\\{printf}(\.{".\ (l.\ \%d\ of\ include}\)\.{\ file\ \%s)\\n"},\39\\{cur%
\_line},\39\\{cur\_file\_name});{}$\2\6
${}\|l\K(\\{loc}\G\\{limit}\?\\{limit}:\\{loc});{}$\6
\&{if} ${}(\|l>\\{buffer}){}$\5
${}\{{}$\1\6
\&{for} ${}(\|k\K\\{buffer};{}$ ${}\|k<\|l;{}$ ${}\|k\PP){}$\1\6
\&{if} ${}({*}\|k\E\.{'\\t'}){}$\1\5
\\{putchar}(\.{'\ '});\2\6
\&{else}\1\5
${}\\{putchar}({*}\|k){}$;\C{ print the characters already read }\2\2\6
\\{putchar}(\.{'\\n'});\6
\&{for} ${}(\|k\K\\{buffer};{}$ ${}\|k<\|l;{}$ ${}\|k\PP){}$\1\5
\\{putchar}(\.{'\ '});\C{ space out the next line }\2\6
\4${}\}{}$\2\6
\&{for} ${}(\|k\K\|l;{}$ ${}\|k<\\{limit};{}$ ${}\|k\PP){}$\1\5
${}\\{putchar}({*}\|k){}$;\C{ print the part not yet read }\2\6
\&{if} ${}({*}\\{limit}\E\.{'|'}){}$\1\5
\\{putchar}(\.{'|'});\C{ end of \CEE/ text in section names }\2\6
\\{putchar}(\.{'\ '});\C{ to separate the message from future asterisks }\6
\4${}\}{}$\2\par
\U64.\fi

\M{66}When no recovery from some error has been provided, we have to wrap
up and quit as graciously as possible.  This is done by calling the
function \PB{\\{wrap\_up}} at the end of the code.

\.{CTANGLE} and \.{CWEAVE} have their own notions about how to
print the job statistics.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{int} \\{wrap\_up}(\,);\6
\&{extern} \&{void} \\{print\_stats}(\,);\par
\fi

\M{67}Some implementations may wish to pass the \PB{\\{history}} value to the
operating system so that it can be used to govern whether or not other
programs are started. Here, for instance, we pass the operating system
a status of 0 if and only if only harmless messages were printed.

\Y\B\&{int} \\{wrap\_up}(\,)\1\1\2\2\6
${}\{{}$\1\6
\\{putchar}(\.{'\\n'});\6
\&{if} (\\{show\_stats})\1\5
\\{print\_stats}(\,);\C{ print statistics about memory usage }\2\6
\X68:Print the job \PB{\\{history}}\X;\6
\&{if} ${}(\\{history}>\\{harmless\_message}){}$\1\5
\&{return} (\T{1});\2\6
\&{else}\1\5
\&{return} (\T{0});\2\6
\4${}\}{}$\2\par
\fi

\M{68}\B\X68:Print the job \PB{\\{history}}\X${}\E{}$\6
\&{switch} (\\{history})\5
${}\{{}$\1\6
\4\&{case} \\{spotless}:\6
\&{if} (\\{show\_happiness})\1\5
\\{printf}(\.{"(No\ errors\ were\ fou}\)\.{nd.)\\n"});\2\6
\&{break};\6
\4\&{case} \\{harmless\_message}:\5
\\{printf}(\.{"(Did\ you\ see\ the\ wa}\)\.{rning\ message\ above?}\)\.{)%
\\n"});\6
\&{break};\6
\4\&{case} \\{error\_message}:\5
\\{printf}(\.{"(Pardon\ me,\ but\ I\ t}\)\.{hink\ I\ spotted\ somet}\)\.{hing\
wrong.)\\n"});\6
\&{break};\6
\4\&{case} \\{fatal\_message}:\5
\\{printf}(\.{"(That\ was\ a\ fatal\ e}\)\.{rror,\ my\ friend.)\\n"});\6
\4${}\}{}$\C{ there are no other cases }\2\par
\U67.\fi

\M{69}When there is no way to recover from an error, the \PB{\\{fatal}}
subroutine is
invoked. This happens most often when \PB{\\{overflow}} occurs.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{void} \\{fatal}(\,)${},{}$ \\{overflow}(\,);\par
\fi

\M{70}The two parameters to \PB{\\{fatal}} are strings that are essentially
concatenated to print the final error message.

\Y\B\&{void} ${}\\{fatal}(\|s,\39\|t){}$\1\1\6
\&{char} ${}{*}\|s,{}$ ${}{*}\|t;\2\2{}$\6
${}\{{}$\1\6
\&{if} ${}({*}\|s){}$\1\5
\\{printf}(\|s);\2\6
\\{err\_print}(\|t);\6
${}\\{history}\K\\{fatal\_message};{}$\6
\\{exit}(\\{wrap\_up}(\,));\6
\4${}\}{}$\2\par
\fi

\M{71}An overflow stop occurs if \.{CWEB}'s tables aren't large enough.

\Y\B\&{void} \\{overflow}(\|t)\1\1\6
\&{char} ${}{*}\|t;\2\2{}$\6
${}\{{}$\1\6
${}\\{printf}(\.{"\\n!\ Sorry,\ \%s\ capac}\)\.{ity\ exceeded"},\39\|t);{}$\6
${}\\{fatal}(\.{""},\39\.{""});{}$\6
\4${}\}{}$\2\par
\fi

\M{72}Sometimes the program's behavior is far different from what it should be,
and \.{CWEB} prints an error message that is really for the \.{CWEB}
maintenance person, not the user. In such cases the program says
\PB{\\{confusion}(\.{"indication\ of\ where}\)\.{\ we\ are"})}.

\Y\B\4\D$\\{confusion}(\|s)$ \5
$\\{fatal}(\.{"!\ This\ can't\ happen}\)\.{:\ "},\39\|s{}$)\par
\fi

\N{0}{73}Command line arguments.
The user calls \.{CWEAVE} and \.{CTANGLE} with arguments on the command line.
These are either file names or flags to be turned off (beginning with \PB{%
\.{"-"}})
or flags to be turned on (beginning with \PB{\.{"+"}}.
The following globals are for communicating the user's desires to the rest
of the program. The various file name variables contain strings with
the names of those files. Most of the 128 flags are undefined but available
for future extensions.

\Y\B\4\D$\\{show\_banner}$ \5
\\{flags}[\.{'b'}]\C{ should the banner line be printed? }\par
\B\4\D$\\{show\_progress}$ \5
\\{flags}[\.{'p'}]\C{ should progress reports be printed? }\par
\B\4\D$\\{show\_stats}$ \5
\\{flags}[\.{'s'}]\C{ should statistics be printed at end of run? }\par
\B\4\D$\\{show\_happiness}$ \5
\\{flags}[\.{'h'}]\C{ should lack of errors be announced? }\par
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{int} \\{argc};\C{ copy of \PB{\\{ac}} parameter to \PB{\\{main}} }\6
\&{char} ${}{*}{*}\\{argv}{}$;\C{ copy of \PB{\\{av}} parameter to \PB{%
\\{main}} }\6
\&{char} \\{C\_file\_name}[\\{max\_file\_name\_length}];\C{ name of \PB{\\{C%
\_file}} }\6
\&{char} \\{tex\_file\_name}[\\{max\_file\_name\_length}];\C{ name of \PB{%
\\{tex\_file}} }\6
\&{char} \\{idx\_file\_name}[\\{max\_file\_name\_length}];\C{ name of \PB{%
\\{idx\_file}} }\6
\&{char} \\{scn\_file\_name}[\\{max\_file\_name\_length}];\C{ name of \PB{%
\\{scn\_file}} }\6
\&{boolean} \\{flags}[\T{128}];\C{ an option for each 7-bit code }\6
\&{char} ${}{*}{*}\\{argv\_web},{}$ ${}{*}{*}\\{argv\_change},{}$ ${}{*}{*}%
\\{argv\_out}{}$;\par
\fi

\M{74}The \PB{\\{flags}} will be initially zero. Some of them are set to~1
before
scanning the arguments; if additional flags are 1 by default they
should be set before calling \PB{\\{common\_init}}.

\Y\B\4\X74:Set the default options common to \.{CTANGLE} and \.{CWEAVE}\X${}%
\E{}$\6
$\\{show\_banner}\K\\{show\_happiness}\K\\{show\_progress}\K\T{1}{}$;\par
\U4.\fi

\M{75}We now must look at the command line arguments and set the file names
accordingly.  At least one file name must be present: the \.{CWEB}
file.  It may have an extension, or it may omit the extension to get \PB{%
\.{".w"}} or
\PB{\.{".web"}} added.  The \TEX/ output file name is formed by replacing the %
\.{CWEB}
file name extension by \PB{\.{".tex"}}, and the \CEE/ file name by replacing
the extension by \PB{\.{".c"}}, after removing the directory name (if any).

If there is a second file name present among the arguments, it is the
change file, again either with an extension or without one to get \PB{%
\.{".ch"}}.
An omitted change file argument means that \PB{\.{"/dev/null"}} should be used,
when no changes are desired.

If there's a third file name, it will be the output file.

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{void} \\{scan\_args}(\,);\par
\fi

\M{76}\B\&{void} \\{scan\_args}(\,)\1\1\2\2\6
${}\{{}$\1\6
\&{char} ${}{*}\\{dot\_pos}{}$;\C{ position of \PB{\.{'.'}} in the argument }\6
\&{char} ${}{*}\\{name\_pos}{}$;\C{ file name beginning, sans directory }\6
\&{register} \&{char} ${}{*}\|s{}$;\C{ register for scanning strings }\6
\&{boolean} \\{found\_web}${}\K\T{0},{}$ \\{found\_change}${}\K\T{0},{}$ %
\\{found\_out}${}\K\T{0}{}$;\C{ have these names have been seen? }\6
\&{boolean} \\{flag\_change}${},{}$ \\{Cxx\_seen}${}\K\T{0};{}$\7
\&{while} ${}(\MM\\{argc}>\T{0}){}$\5
${}\{{}$\1\6
\&{if} ${}(({*}{*}(\PP\\{argv})\E\.{'-'}\V{*}{*}\\{argv}\E\.{'+'})\W{*}({*}%
\\{argv}+\T{1})){}$\1\5
\X80:Handle flag argument\X\2\6
\&{else}\5
${}\{{}$\1\6
${}\|s\K\\{name\_pos}\K{*}\\{argv}{}$;\5
${}\\{dot\_pos}\K\NULL;{}$\6
\&{while} ${}({*}\|s){}$\5
${}\{{}$\1\6
\&{if} ${}({*}\|s\E\.{'.'}){}$\1\5
${}\\{dot\_pos}\K\|s\PP;{}$\2\6
\&{else} \&{if} ${}({*}\|s\E\.{'/'}){}$\1\5
${}\\{dot\_pos}\K\NULL,\39\\{name\_pos}\K\PP\|s;{}$\2\6
\&{else}\1\5
${}\|s\PP;{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{found\_web}){}$\1\5
\X77:Make \PB{\\{web\_file\_name}}, \PB{\\{tex\_file\_name}} and \PB{\\{C\_file%
\_name}}\X\2\6
\&{else} \&{if} ${}(\R\\{found\_change}){}$\1\5
\X78:Make \PB{\\{change\_file\_name}} from \PB{\\{fname}}\X\2\6
\&{else} \&{if} ${}(\R\\{found\_out}){}$\1\5
\X79:Override \PB{\\{tex\_file\_name}} and \PB{\\{C\_file\_name}}\X\2\6
\&{else}\1\5
\X83:Print usage error message and quit\X;\2\6
\4${}\}{}$\2\6
\4${}\}{}$\2\6
\&{if} ${}(\R\\{found\_web}){}$\1\5
\X83:Print usage error message and quit\X;\2\6
\&{if} ${}(\\{found\_change}\Z\T{0}){}$\1\5
${}\\{strcpy}(\\{change\_file\_name},\39\.{"/dev/null"});{}$\2\6
\4${}\}{}$\2\par
\fi

\M{77}We use all of \PB{${*}\\{argv}$} for the \PB{\\{web\_file\_name}} if
there is a \PB{\.{'.'}} in it,
otherwise we add \PB{\.{".w"}}. If this file can't be opened, we prepare an
\PB{\\{alt\_web\_file\_name}} by adding \PB{\.{"web"}} after the dot.
The other file names come from adding other things
after the dot.  We must check that there is enough room in
\PB{\\{web\_file\_name}} and the other arrays for the argument.

\Y\B\4\X77:Make \PB{\\{web\_file\_name}}, \PB{\\{tex\_file\_name}} and \PB{\\{C%
\_file\_name}}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\R\\{argv\_web}){}$\1\5
${}\\{argv\_web}\K\\{argv}{}$;\C{ when first time, remember position of web
file in \PB{\\{argv}} }\2\6
\&{if} ${}(\|s-{*}\\{argv}>\\{max\_file\_name\_length}-\T{5}){}$\1\5
\X84:Complain about argument length\X;\2\6
\&{if} ${}(\\{dot\_pos}\E\NULL){}$\1\5
${}\\{sprintf}(\\{web\_file\_name},\39\.{"\%s.w"},\39{*}\\{argv});{}$\2\6
\&{else}\5
${}\{{}$\C{ \.{.wpp} switches \CPLUSPLUS/ mode on, if not explicitly switched
off }\1\6
\&{if} ${}(\R\\{Cxx\_seen}\W(\R\\{strcmp}(\\{dot\_pos},\39\.{".wpp"})\V\R%
\\{strcmp}(\\{dot\_pos},\39\.{".wxx"}))){}$\1\5
${}\\{flags}[\.{'+'}]\K\T{1}{}$;\C{ these file extensions imply \CPLUSPLUS/ }\2%
\6
${}\\{strcpy}(\\{web\_file\_name},\39{*}\\{argv});{}$\6
${}{*}\\{dot\_pos}\K\T{0}{}$;\C{ string now ends where the dot was }\6
\4${}\}{}$\2\6
${}\\{sprintf}(\\{alt\_web\_file\_name},\39\.{"\%s.web"},\39{*}\\{argv});{}$\6
${}\\{sprintf}(\\{tex\_file\_name},\39\.{"\%s.tex"},\39\\{name\_pos}){}$;\C{
strip off directory name }\6
${}\\{sprintf}(\\{idx\_file\_name},\39\.{"\%s.idx"},\39\\{name\_pos});{}$\6
${}\\{sprintf}(\\{scn\_file\_name},\39\.{"\%s.scn"},\39\\{name\_pos});{}$\6
${}\\{sprintf}(\\{C\_file\_name},\39\.{"\%s.c"},\39\\{name\_pos});{}$\6
\&{if} (\\{dot\_pos})\1\5
${}{*}\\{dot\_pos}\K\.{'.'}{}$;\C{ restore dot for next call of \PB{\\{scan%
\_args}} }\2\6
${}\\{found\_web}\K\T{1};{}$\6
\4${}\}{}$\2\par
\U76.\fi

\M{78}\B\X78:Make \PB{\\{change\_file\_name}} from \PB{\\{fname}}\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\R\\{argv\_web}){}$\1\5
${}\\{argv\_change}\K\\{argv}{}$;\C{ remember position of change file name }\2\6
\&{if} ${}(\\{strcmp}({*}\\{argv},\39\.{"-"})\E\T{0}){}$\1\5
${}\\{found\_change}\K{-}\T{1};{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}(\|s-{*}\\{argv}>\\{max\_file\_name\_length}-\T{4}){}$\1\5
\X84:Complain about argument length\X;\2\6
\&{if} ${}(\\{dot\_pos}\E\NULL){}$\1\5
${}\\{sprintf}(\\{change\_file\_name},\39\.{"\%s.ch"},\39{*}\\{argv});{}$\2\6
\&{else}\1\5
${}\\{strcpy}(\\{change\_file\_name},\39{*}\\{argv});{}$\2\6
${}\\{found\_change}\K\T{1};{}$\6
\4${}\}{}$\2\6
\4${}\}{}$\2\par
\U76.\fi

\M{79}\B\X79:Override \PB{\\{tex\_file\_name}} and \PB{\\{C\_file\_name}}\X${}%
\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\R\\{argv\_web}){}$\1\5
${}\\{argv\_out}\K\\{argv}{}$;\C{ the position of the output file name }\2\6
\&{if} ${}(\|s-{*}\\{argv}>\\{max\_file\_name\_length}-\T{5}){}$\1\5
\X84:Complain about argument length\X;\2\6
\&{if} ${}(\\{dot\_pos}\E\NULL){}$\5
${}\{{}$\1\6
${}\\{sprintf}(\\{tex\_file\_name},\39\.{"\%s.tex"},\39{*}\\{argv});{}$\6
${}\\{sprintf}(\\{idx\_file\_name},\39\.{"\%s.idx"},\39{*}\\{argv});{}$\6
${}\\{sprintf}(\\{scn\_file\_name},\39\.{"\%s.scn"},\39{*}\\{argv});{}$\6
${}\\{sprintf}(\\{C\_file\_name},\39\.{"\%s.c"},\39{*}\\{argv});{}$\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
${}\\{strcpy}(\\{tex\_file\_name},\39{*}\\{argv});{}$\6
\&{if} (\\{flags}[\.{'x'}])\5
${}\{{}$\C{ indexes will be generated }\1\6
\&{if} ${}(\\{program}\E\\{cweave}\W\\{strcmp}({*}\\{argv}+\\{strlen}({*}%
\\{argv})-\T{4},\39\.{".tex"})\I\T{0}){}$\1\5
${}\\{fatal}(\.{"!\ Output\ file\ name\ }\)\.{should\ end\ with\ .tex}\)\.{%
\\n"},\39{*}\\{argv});{}$\2\6
${}\\{strcpy}(\\{idx\_file\_name},\39{*}\\{argv});{}$\6
${}\\{strcpy}(\\{idx\_file\_name}+\\{strlen}({*}\\{argv})-\T{4},\39%
\.{".idx"});{}$\6
${}\\{strcpy}(\\{scn\_file\_name},\39{*}\\{argv});{}$\6
${}\\{strcpy}(\\{scn\_file\_name}+\\{strlen}({*}\\{argv})-\T{4},\39%
\.{".scn"});{}$\6
\4${}\}{}$\2\6
${}\\{strcpy}(\\{C\_file\_name},\39{*}\\{argv});{}$\6
\4${}\}{}$\2\6
${}\\{found\_out}\K\T{1};{}$\6
\4${}\}{}$\2\par
\U76.\fi

\M{80}\B\X80:Handle flag argument\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}({*}{*}\\{argv}\E\.{'-'}){}$\1\5
${}\\{flag\_change}\K\T{0};{}$\2\6
\&{else}\1\5
${}\\{flag\_change}\K\T{1};{}$\2\6
\&{if} ${}(\\{argv}[\T{0}][\T{1}]\E\.{'l'}){}$\1\5
\X82:Store name of localized {\tt mcwebmac}\X\2\6
\&{else}\1\6
\&{for} ${}(\\{dot\_pos}\K{*}\\{argv}+\T{1};{}$ ${}{*}\\{dot\_pos}>\.{'%
\\0'};{}$ ${}\\{dot\_pos}\PP){}$\5
${}\{{}$\1\6
\&{if} ${}({*}\\{dot\_pos}\E\.{'+'}){}$\1\5
${}\\{Cxx\_seen}\K\T{1};{}$\2\6
${}\\{flags}[{*}\\{dot\_pos}]\K\\{flag\_change};{}$\6
\4${}\}{}$\2\2\6
\4${}\}{}$\2\par
\U76.\fi

\M{81}Usually, if no {\tt+l} option is given, the name of the macro file
is {\tt mcwebmac}. However, in order to make localization easier,
a prefix may be given by means of {\tt+l$\langle\hbox{\it prefix}\rangle$}
and will be prepended to {\tt mcwebmac.tex}. For example, the
{\tt+lg} option makes \.{mCWEAVE} include a macro file called
{\tt gmcwebmac.tex}, the german version of \.{mcwebmac}.
\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{char} \\{mcwebmac\_prefix}[\T{10}];\par
\fi

\M{82}
\Y\B\4\X82:Store name of localized {\tt mcwebmac}\X${}\E{}$\6
${}\{{}$\1\6
${}\\{strcpy}(\\{mcwebmac\_prefix},\39\\{argv}[\T{0}]+\T{2});{}$\6
\4${}\}{}$\2\par
\U80.\fi

\M{83}\B\X83:Print usage error message and quit\X${}\E{}$\6
${}\{{}$\1\6
\&{if} ${}(\\{program}\E\\{ctangle}){}$\1\5
${}\\{fatal}(\.{"!\ Usage:\ ctangle\ [o}\)\.{ptions]\ webfile[.w]\ }\)\.{[%
\{changefile[.ch]|-\}}\)\.{\ [outfile[.c]]]\\n"},\39\.{""});{}$\2\6
\&{else}\1\5
${}\\{fatal}(\.{"!\ Usage:\ cweave\ [op}\)\.{tions]\ webfile[.w]\ [}\)\.{%
\{changefile[.ch]|-\}\ }\)\.{[outfile[.tex]]]\\n"},\39\.{""});{}$\2\6
\4${}\}{}$\2\par
\U76.\fi

\M{84}\B\X84:Complain about argument length\X${}\E{}$\6
$\\{fatal}(\.{"!\ Filename\ too\ long}\)\.{\\n"},\39{*}\\{argv}){}$;\par
\Us77, 78\ETs79.\fi

\N{0}{85}Output. Here is the code that opens the output file:

\Y\B\4\X2:Definitions that should agree with \.{CTANGLE} and \.{CWEAVE}\X${}%
\mathrel+\E{}$\6
\&{FILE} ${}{*}\\{C\_file}{}$;\C{ where output of \.{CTANGLE} goes }\6
\&{FILE} ${}{*}\\{tex\_file}{}$;\C{ where output of \.{CWEAVE} goes }\6
\&{FILE} ${}{*}\\{idx\_file}{}$;\C{ where index from \.{CWEAVE} goes }\6
\&{FILE} ${}{*}\\{scn\_file}{}$;\C{ where list of sections from \.{CWEAVE} goes
}\6
\&{FILE} ${}{*}\\{active\_file}{}$;\C{ currently active file for \.{CWEAVE}
output }\par
\fi

\M{86}\B\X86:Scan arguments and open output files\X${}\E{}$\6
\\{scan\_args}(\,);\6
\&{if} ${}(\\{program}\E\\{ctangle}){}$\5
${}\{{}$\1\6
\&{if} ${}((\\{C\_file}\K\\{fopen}(\\{C\_file\_name},\39\.{"w"}))\E\NULL){}$\1\5
${}\\{fatal}(\.{"!\ Cannot\ open\ outpu}\)\.{t\ file\ "},\39\\{C\_file%
\_name});{}$\2\6
\4${}\}{}$\2\6
\&{else}\5
${}\{{}$\1\6
\&{if} ${}((\\{tex\_file}\K\\{fopen}(\\{tex\_file\_name},\39\.{"w"}))\E%
\NULL){}$\1\5
${}\\{fatal}(\.{"!\ Cannot\ open\ outpu}\)\.{t\ file\ "},\39\\{tex\_file%
\_name});{}$\2\6
\4${}\}{}$\2\par
\U4.\fi

\M{87}The \PB{\\{update\_terminal}} procedure is called when we want
to make sure that everything we have output to the terminal so far has
actually left the computer's internal buffers and been sent.

\Y\B\4\D$\\{update\_terminal}$ \5
\\{fflush}(\\{stdout})\C{ empty the terminal output buffer }\par
\fi

\M{88}Terminal output uses \PB{\\{putchar}} and \PB{\\{putc}} when we have to
translate from \.{CWEB}'s code into the external character code,
and \PB{\\{printf}} when we just want to print strings.
Several macros make other kinds of output convenient.
\Y\B\4\D$\\{new\_line}$ \5
\\{putchar}(\.{'\\n'})\par
\B\4\D$\\{putxchar}$ \5
\\{putchar}\par
\B\4\D$\\{term\_write}(\|a,\|b)$ \5
$\\{fflush}(\\{stdout}),\39\\{fwrite}(\|a,\39\&{sizeof}(\&{char}),\39\|b,\39%
\\{stdout}{}$)\par
\B\4\D$\\{C\_printf}(\|c,\|a)$ \5
$\\{fprintf}(\\{C\_file},\39\|c,\39\|a{}$)\par
\B\4\D$\\{C\_putc}(\|c)$ \5
$\\{putc}(\|c,\39\\{C\_file}{}$)\C{ isn't \CEE/ wonderfully consistent? }\par
\fi

\M{89}We predeclare several standard system functions here instead of including
their system header files, because the names of the header files are not as
standard as the names of the functions. (For example, some \CEE/ environments
have \.{<string.h>} where others have \.{<strings.h>}.)

\Y\B\4\X5:Predeclaration of procedures\X${}\mathrel+\E{}$\6
\&{extern} \&{int} \\{strlen}(\,);\C{ length of string }\6
\&{extern} \&{int} \\{strcmp}(\,);\C{ compare strings lexicographically }\6
\&{extern} \&{char} ${}{*}\\{strcpy}(\,){}$;\C{ copy one string to another }\6
\&{extern} \&{int} \\{strncmp}(\,);\C{ compare up to $n$ string characters }\6
\&{extern} \&{char} ${}{*}\\{strncpy}(\,){}$;\C{ copy up to $n$ string
characters }\par
\fi

\N{0}{90}Index.
\fi


\inx
\fin
\con\end
