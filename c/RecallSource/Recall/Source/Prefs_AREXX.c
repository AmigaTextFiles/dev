/*
** Source machine generated by the AREXX Interface Designer for EasyREXX
** which is (c) copyrighted 1995 to Ketil Hunn
** Set TAB=2 for best readability
**
** The source has been modified later to handle the ARexx messages of
** the Designer.
**
** This source calls functions in the AREXX Interface Designer code
** and it will not compile without the FULL source. It is provided
** here as an example on how to make a fully operational AREXX port.
**
** This source also contains functions which show how to load and save
** macro definitions to disk.
**
*/

#ifndef AREXX_INTERFACE_C
#define AREXX_INTERFACE_C

/*** INCLUDES ************************************************************************/
#include "System.h"
#include "System_Prefs.h"
#include "Prefs_AREXX.h"
#include <clib/iffparse_protos.h>
#include <libraries/iffparse.h>
#include "myinclude:MyIFFfunctions.h"

#include "ProjectIO.h"
#include "Asl.h"

/*** DEFINES *************************************************************************/
#define	NOT_ASSIGNED	"	"

#define ID_MACR	MAKE_ID('M','A','C','R')

#define	NOT_AVAILABLE		"<n/a>"

#define AREXX_ACTIVATE				1
#define AREXX_ADD							2
#define AREXX_APPEND					3
#define	AREXX_BUSY						4
#define AREXX_COMMANDSHELL		5
#define AREXX_COPY						6
#define AREXX_CUT							7
#define	AREXX_DESIGNERTOFRONT	8
#define	AREXX_DESIGNERTOBACK	9
#define AREXX_GENERATE				10
#define AREXX_GETATTR					11
#define	AREXX_HELP						12
#define	AREXX_ICONIFY					13
#define AREXX_MOVE						14
#define AREXX_NEW							15
#define AREXX_OPEN						16
#define AREXX_PASTE						17
#define AREXX_QUIT						18
#define	AREXX_RENAME					19
#define	AREXX_REQUEST					20
#define	AREXX_REQUESTFILE			21
#define AREXX_SAVE						22
#define AREXX_SETATTR					23
#define AREXX_SORT						24
#define	AREXX_UNICONIFY				25
#define AREXX_WINDOW					26

/*** GLOBALS *************************************************************************/
struct Library			*EasyRexxBase	=NULL;
struct ARexxContext	*context			=NULL;
ARexxMacro					macro					=NULL;

struct ARexxCommandTable commandTable[]=
{
	AREXX_ACTIVATE,				"ACTIVATE",				"COMMAND/S,ARGUMENT/S,ITEM/N/A",		NULL,
	AREXX_ADD,						"ADD",						"COMMAND/S,ARGUMENT/S,NAME/F",			NULL,
	AREXX_APPEND,					"APPEND",					"PROJECT/S,FILENAME/F",							NULL,
	AREXX_BUSY,						"BUSY",						"ON/S,OFF/S",												NULL,
	AREXX_COMMANDSHELL,		"COMMANDSHELL",		"OPEN/S,CLOSE/S",										NULL,
	AREXX_COPY,						"COPY",						"COMMAND/S,ARGUMENT/S",							NULL,
	AREXX_CUT,						"CUT",						"COMMAND/S,ARGUMENT/S",							NULL,
	AREXX_DESIGNERTOFRONT,"DESIGNERTOFRONT",NULL,																NULL,
	AREXX_DESIGNERTOBACK,	"DESIGNERTOBACK",	NULL,																NULL,
	AREXX_GENERATE,				"GENERATE",				"C/S,E/S,OBERON/S,MODULA2/S,ASM/S,SOURCE/S,FILENAME/F",	NULL,
	AREXX_GETATTR,				"GETATTR",				"ALWAYS/S,ARGUMENT/S,AUTHOR/S,COMMAND/S,COPYRIGHT/S,FINAL/S,AREXXHANDLER/S,HANDLERTYPE/S,KEYWORD/S,MAIN/S,MULTIPLE/S,NUMBER/S,PORTNAME/S,SWITCH/S,TEMPLATES/S,TOGGLE/S,VERSION/S",	NULL,
	AREXX_HELP,						"HELP",						"TOPIC/A/F",												NULL,
	AREXX_ICONIFY,				"ICONIFY",				NULL,																NULL,
	AREXX_MOVE,						"MOVE",						"COMMAND/S,ARGUMENT/S,UP/S,DOWN/S",	NULL,
	AREXX_NEW,						"NEW",						"PROJECT/S,FILENAME,FORCE/S",				NULL,
	AREXX_OPEN,						"OPEN",						"PROJECT/S,MACROS/S,ENVIRONMENT/S,FILENAME,FORCE/S",				NULL,
	AREXX_PASTE,					"PASTE",					"COMMAND/S,ARGUMENT/S",							NULL,
	AREXX_QUIT,						"QUIT",						"FORCE/S",													NULL,
	AREXX_RENAME,					"RENAME",					"COMMAND/S,ARGUMENT/S,NAME/A/F",		NULL,
	AREXX_REQUEST,				"REQUEST",				"TITLE/A,TEXT/A,GADGETS/A",					NULL,
	AREXX_REQUESTFILE,		"REQUESTFILE",		"TITLE/A,FILE/A,SAVE/S,DRAWERS/S,NOICONS/S",	NULL,
	AREXX_SAVE,						"SAVE",						"PROJECT/S,MACROS/S,ENVIRONMENT/S,AS/S,FILENAME/F",	NULL,
	AREXX_SETATTR,				"SETATTR",				"ALWAYS/N,AUTHOR,COPYRIGHT,FINAL/N,AREXXHANDLER/N,HANDLERTYPE/N,KEYWORD/N,MAIN/N,MULTIPLE/N,NUMBER/N,PORTNAME,SWITCH/N,TEMPLATES/N,TOGGLE/N,VERSION,MACRO/N,MACRONAME,", NULL,
	AREXX_SORT,						"SORT",						"COMMANDS/S,ARGUMENTS/S",						NULL,
	AREXX_UNICONIFY,			"UNICONIFY",			NULL,																NULL,
	AREXX_WINDOW,					"WINDOW",					"MAIN/S,CODE/S,ASSIGN/S,ABOUT/S,OPEN/S,CLOSE/S,ACTIVATE/S,ZOOM/S,ZIP/S,TOFRONT/S,TOBACK/S",	NULL,
	TABLE_END,
};

struct Macro	macros[MAXMACROS];
BYTE					record=FALSE;

/*** FUNCTIONS ***********************************************************************/
void myHandleARexx(struct ARexxContext *c)
{
#ifdef MYDEBUG_H
	DebugOut("myHandleARexx");
#endif
	/*	This application just ignores the AREXX stuff if the library	*/
  /*	was not found	or the context could not be allocated.					*/
	if(EasyRexxBase!=NULL & c!=NULL)
	{
		register UBYTE	*resultstring	=NULL;
		register BYTE		oldrecord			=record;
		register LONG		resultlong		=~0;


		/* temporalily turn off macro recording */
		record=FALSE;
		while(GetARexxMsg(c))
		{
//			switch(c->id)
//			{
//			}
			ReplyARexxMsg(c,
										ER_ReturnCode,	RC_OK,
										(resultlong!=~0 ? ER_ResultLong		:TAG_IGNORE),	resultlong,
										(resultstring		?	ER_ResultString	:TAG_IGNORE),	resultstring,
										TAG_DONE);
		}
		record=oldrecord;
	}
}

/*** MACRO FILE IN/OUT **************************************************************/
LONG ReadMacros(struct Macro *macros, UBYTE *file)
{
	struct IFFHandle		*iff;
	struct ContextNode	*cn;
	struct PrefHeader		header;
	LONG								error=IFFERR_EOF;

#ifdef MYDEBUG_H
	DebugOut("ReadMacros");
#endif
	if(iff=AllocIFF())
	{
		if(iff->iff_Stream=Open(file, MODE_OLDFILE))
		{
			InitIFFasDOS (iff);
			if(!(error=OpenIFF(iff, IFFF_READ)))
			{
				ParseIFF(iff, IFFPARSE_RAWSTEP);
				if(cn=CurrentChunk(iff))
				{
					if(cn->cn_ID!=ID_FORM & cn->cn_Type!=ID_PREF)
						error=2;
					else
					{
						ParseIFF(iff, IFFPARSE_RAWSTEP);
						cn=CurrentChunk(iff);
						if(cn->cn_ID!=ID_PRHD)
							error=2;
						else
						{
							register BYTE i=0;

							ReadChunkBytes(iff, (APTR)&header, cn->cn_Size);

							while(i<MAXMACROS)
							{
								error=ParseIFF(iff, IFFPARSE_RAWSTEP);
								if(error==IFFERR_EOC)
									continue;
								else if(error)
									break;

								if(cn=CurrentChunk(iff))
								{
									switch(cn->cn_ID)
									{
										case ID_MACR:
											ReadChunkBytes(iff, (APTR)&macros[i].fullname, cn->cn_Size);
											if(0==stricmp(macros[i].fullname, NOT_ASSIGNED))
												strcpy(macros[i].fullname, egGetString(MSG_NOTASSIGNED));
											strcpy(macros[i].name, FilePart(macros[i].fullname));
											++i;
											break;
									}
								}
							}
						}
					}
				}
				else
					error=2;
				CloseIFF(iff);
			}
			Close(iff->iff_Stream);
		}
		FreeIFF(iff);
	}
	return error;
}

LONG WriteMacros(struct Macro *macros, UBYTE *file)
{
	struct IFFHandle	*iff;
	LONG							error;
	register BYTE			i;

#ifdef MYDEBUG_H
	DebugOut("WriteMacros");
#endif

	if(iff=AllocIFF())
	{
		if(iff->iff_Stream=Open(file, MODE_NEWFILE))
		{
			InitIFFasDOS(iff);
			if(!(error=OpenIFF(iff, IFFF_WRITE)))
			{
				struct PrefHeader PrefHdrChunk={1,0,0};

				PushChunk(iff, ID_PREF, ID_FORM, IFFSIZE_UNKNOWN);

				myWriteChunkStruct(iff, ID_PRHD, (APTR)&PrefHdrChunk, sizeof(struct PrefHeader));

				for(i=0; i<MAXMACROS; i++)
				{
					if(0==stricmp(macros[i].fullname, egGetString(MSG_NOTASSIGNED)))
						myWriteChunkText(iff, ID_MACR, NOT_ASSIGNED);
					else
						myWriteChunkText(iff, ID_MACR, macros[i].fullname);
				}

				PopChunk(iff);
				CloseIFF(iff);
			}
			Close(iff->iff_Stream);
		}
		FreeIFF(iff);
	}
	return error;
}

LONG OpenMacros(struct Macro *macros, UBYTE *file)
{
	LONG	error=IFFERR_EOF;

#ifdef MYDEBUG_H
	DebugOut("OpenMacros");
#endif

	egLockAllTasks(eg);
	if(FileRequest(	mainTask.window,
									MSG_OPENMACROS,
									file,
									NULL,
									NULL,
									MSG_OPEN))
	{
		ReadMacros(macros, file);
		UpdateAssignTask();
		UpdateMainMenu();

		if(record)
			AddARexxMacroCommand(	macro,
														ER_Command,		"OPEN MACROS '%s'",
														ER_Argument, (KeepContents() ? file:NULL),
														TAG_DONE);
	}
	egUnlockAllTasks(eg);
	return error;
}

LONG SaveMacros(struct Macro *macros, UBYTE *file)
{
	LONG error;

#ifdef MYDEBUG_H
	DebugOut("SaveMacros");
#endif

	egLockAllTasks(eg);
	error=WriteMacros(macros, file);
	if(record)
		AddARexxMacroCommand(	macro,
													ER_Command,		"SAVE MACROS",
													TAG_DONE);
	egUnlockAllTasks(eg);

	return error;
}

LONG SaveMacrosAs(struct Macro *macros, UBYTE *file)
{
	LONG error;

#ifdef MYDEBUG_H
	DebugOut("SaveMacrosAs");
#endif

	egLockAllTasks(eg);
	if(FileRequest(	mainTask.window,
									MSG_SAVEMACROS,
									file,
									FRF_DOSAVEMODE,
									NULL,
									MSG_SAVE))
	{
		error=WriteMacros(macros, file);
		if(record)
			AddARexxMacroCommand(	macro,
														ER_Command,		"SAVE MACROS AS '%s'",
														ER_Argument, (KeepContents() ? file:NULL),
														TAG_DONE);
	}
	egUnlockAllTasks(eg);
	return error;
}

/*	Small function which asks the user if he/she wants to store the
**	contents of a requester in the macro.
*/
LONG KeepContents(void)
{
#ifdef MYDEBUG_H
	DebugOut("KeepContents");
#endif
	return egRequest(	mainTask.window,
										egGetString(MSG_MACROGENERATION),
										egGetString(MSG_STORECONTENTS),
										egGetString(MSG_YESNO),
										NULL);
}

void SetAllPointers(void)
{
	register struct egTask *task;

	if(record)
		for(task=eg->tasklist; task; task=task->nexttask)
			if(task->window)
				SetPointer(	task->window,
										ER_RecordPointer,
										ER_RECORDPOINTERHEIGHT,
										ER_RECORDPOINTERWIDTH,
										ER_RECORDPOINTEROFFSET,
										0);
}

void ClearAllPointers(void)
{
	register struct egTask *task;

	for(task=eg->tasklist; task; task=task->nexttask)
		if(task->window)
			ClearPointer(task->window);
}
#endif
