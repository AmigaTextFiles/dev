/*
 *	File:					TASK_About.c
 *	Description:	About requester window.
 *
 *	(C) 1995 Ketil Hunn
 *
 */

#ifndef TASK_ABOUT_C
#define TASK_ABOUT_C

/*** PRIVATE INCLUDES ****************************************************************/
#include "System.h"
#include "AboutLogo.h"
#include "Designer_AREXX.h"
#include "TASK_About.h"

/*** DEFINES *************************************************************************/
#define	GID_ABOUTOK		1

/*** GLOBALS *************************************************************************/
struct egTask	aboutTask;
struct Image	aboutImage;
struct List 	*aboutlist;

struct egGadget *aboutok,
								*aboutlistview;

/*** FUNCTIONS ***********************************************************************/

__asm __saveds ULONG RefreshAboutTask(register __a0 struct Hook *hook,
																			register __a2 APTR	      object,
																			register __a1 APTR	      message)
{
#ifdef MYDEBUG_H
	DebugOut("RefreshAboutTask");
#endif

	geta4();
	DrawImage(aboutTask.window->RPort, &aboutImage,
						LeftMargin,
						(Y1(aboutok)-GadVSpace-ABOUTLOGOHEIGHT)/2);

	return 1L;
}

__asm __saveds ULONG RenderAboutTask(register __a0 struct Hook *hook,
																		register __a2 APTR	      object,
																		register __a1 APTR	      message)
{
	WORD  posarray[1], sizearray[1];
	WORD	tmp;

#ifdef MYDEBUG_H
	DebugOut("RenderAboutTask");
#endif

	geta4();
	egCreateContext(eg, &aboutTask);

	sizearray[0]=(ULONG)egTextWidth(eg, egGetString(MSG__OK))+GadHInside*2;
	egSpreadGadgets(	posarray,
										sizearray,
										LeftMargin,
										LeftMargin+ABOUTLOGOWIDTH, 1, TRUE);

	aboutok=egCreateGadget(eg,
								EG_Window,						aboutTask.window,
								EG_TextAttr,					fontattr,
								EG_GadgetKind,				BUTTON_KIND,
								EG_LeftEdge,					posarray[0],
								EG_DefaultHeight,			TRUE,
								EG_PlaceWindowBottom,	TRUE,
								EG_Width,							sizearray[0],
								EG_GadgetText,				egGetString(MSG__OK),
								EG_GadgetID,					GID_ABOUTOK,
								EG_Flags,							0,
								TAG_END);

	aboutlistview=egCreateGadget(eg,
								EG_GadgetKind,			LISTVIEW_KIND,
								EG_LeftEdge,				tmp=LeftMargin+ABOUTLOGOWIDTH+GadHSpace,
								EG_PlaceWindowTop,	TRUE,
								EG_Width,						aboutTask.window->Width-RightMargin-tmp,
								EG_Height,					Y2(aboutok)-TopMargin,
								EG_GadgetText,			NULL,
//								EG_Arrows,					TRUE,
								EG_GadgetID,				0,
								GTLV_Labels,				aboutlist,
								GTLV_ReadOnly,			TRUE,
								TAG_END);
	return 1L;
}

BYTE TextToList(struct List *list, UBYTE *sourcetext)
{
	register UBYTE *text, *t, *c;
	register BYTE success=FALSE;

#ifdef MYDEBUG_H
	DebugOut("TextToList");
#endif

	if(t=text=strdup(sourcetext))
	{
		while(*text!='\0')
		{
			c=text;
			while(*text!='\n' & *text!='\0')
				text++;

			if(*text!='\0')
				*text++='\0';

			AddNode(list, c);
		}
		free(t);
		success=TRUE;
	}
	return success;
}

__asm __saveds ULONG CloseAboutTask(register __a0 struct Hook *hook,
																		register __a2 APTR	      object,
																		register __a1 APTR	      message)
{
#ifdef MYDEBUG_H
	DebugOut("CloseAboutTask");
#endif

	FreeList(aboutlist);

	if(record)
		AddARexxMacroCommand(	macro,
													ER_Command,	"WINDOW ASSIGN CLOSE",
													TAG_DONE);
	return 1L;
}
__asm __saveds ULONG OpenAboutTask(	register __a0 struct Hook *hook,
																		register __a2 APTR	      object,
																		register __a1 APTR	      message)
{
	WORD minwidth, minheight;

#ifdef MYDEBUG_H
	DebugOut("OpenAboutTask");
#endif

	geta4();
	if(egTaskToFront(&aboutTask))
			return FALSE;

	aboutImage.Width			=ABOUTLOGOWIDTH;
	aboutImage.Height			=ABOUTLOGOHEIGHT;
	aboutImage.Depth			=ABOUTLOGODEPTH;

	aboutImage.ImageData	=AboutLogo;
	aboutImage.PlanePick	=0x3;
	aboutImage.PlaneOnOff	=0x0;
	aboutImage.NextImage	=NULL;

	minwidth=LeftMargin+ABOUTLOGOREALWIDTH*2+GadHSpace+RightMargin;
	minheight=TopMargin+ABOUTLOGOHEIGHT+GadDefHeight+GadVSpace+BottomMargin;

	if(aboutlist=InitList())
	{
		register UBYTE	*text,
										*portname=(context==NULL ? egGetString(MSG_NOAREXXPORT):context->portname);

		if(text=AllocVec((strlen(GetString(&li, MSG_ABOUTTEXT))+strlen(NAME)+strlen(VERS)+strlen(COPYRIGHT)
																													+strlen(DATE)
																													+strlen(TIME))
																													+strlen(portname)
																													+strlen(env.pubname)
																													+1, MEMF_CLEAR))
		{
			sprintf(text, GetString(&li, MSG_ABOUTTEXT), NAME, VERS, COPYRIGHT, DATE, TIME, portname, env.pubname);
			TextToList(aboutlist, text);
			FreeVec(text);
		}		
	}
	if(egOpenTask(&aboutTask,
							WA_Title,					egGetString(MSG_HELPABOUT),
							WA_Width,					MAX(minwidth, aboutTask.coords.Width),
							WA_Height,				MAX(minheight, aboutTask.coords.Height),
							WA_MinWidth,			minwidth,
							WA_MinHeight,			minheight,
							WA_MaxWidth,			~0,
							WA_MaxHeight,			~0,
							WA_AutoAdjust,		TRUE,
							WA_Activate,			TRUE,
							WA_DragBar,				TRUE,
							WA_DepthGadget,		TRUE,
							WA_SizeGadget,		TRUE,
							WA_SizeBBottom,		TRUE,
							WA_CloseGadget,		TRUE,
							WA_RMBTrap,				TRUE,
							WA_PubScreen,			mainTask.screen,
							WA_SimpleRefresh,	env.simplerefresh,
							EG_OpenFunc,			(ULONG)OpenAboutTask,
							EG_RefreshFunc,		(ULONG)RefreshAboutTask,
							EG_CloseFunc,			(ULONG)CloseAboutTask,
							EG_RenderFunc,		(ULONG)RenderAboutTask,
							EG_HandleFunc,		(ULONG)HandleAboutTask,
							EG_IDCMP,					IDCMP_CLOSEWINDOW|
																SCROLLERIDCMP|
																ARROWIDCMP|
																IDCMP_GADGETDOWN|
																IDCMP_GADGETUP,
							EG_HelpNode,			"about",
							EG_InitialCentre,	TRUE,
							EG_IconifyGadget,	TRUE,
							TAG_END))
	{
		if(record)
			SetPointer(	aboutTask.window,
									ER_RecordPointer,
									ER_RECORDPOINTERHEIGHT,
									ER_RECORDPOINTERWIDTH,
									ER_RECORDPOINTEROFFSET,
									0);
		return TRUE;
	}
	return FALSE;
}

__asm __saveds ULONG HandleAboutTask(register __a0 struct Hook *hook,
																		register __a2 APTR	      object,
																		register __a1 APTR	      message)
{
	struct IntuiMessage *msg=eg->msg;

	switch(msg->Class)
	{
		case IDCMP_GADGETUP:
			switch(((struct Gadget *)msg->IAddress)->GadgetID)
			{
				case GID_ABOUTOK:
					egCloseTask(&aboutTask);
					if(record)
						AddARexxMacroCommand(	macro,
																	ER_Command,	"WINDOW ABOUT CLOSE",
																	TAG_DONE);
					break;
			}
		break;
	}
	return 1L;
}

#endif
