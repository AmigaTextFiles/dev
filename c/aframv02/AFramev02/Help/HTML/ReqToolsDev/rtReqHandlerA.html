<HTML>
<HEAD>
<TITLE>rtReqHandlerA</TITLE></HEAD><BODY><H6><A href=main.html>Contents page</A></H6><P>
<H6><A href=Main.html>Index</A></H6><P>
<H1>rtReqHandlerA</H1>
<HR>
reqtools.library/rtReqHandlerA<P>
<PRE>
  NAME  rtReqHandlerA()<P>

    ret = rtReqHandlerA (handlerinfo, sigs, taglist);<P>

    ULONG rtReqHandlerA (struct rtHandlerInfo *, ULONG, struct TagItem *);
    D0                   A1                      D0     A0<P>

    ret = rtReqHandler (handlerinfo, sigs, tag1,...);<P>

    ULONG rtReqHandler (struct rtHandlerInfo *, ULONG, Tag,...);<P>

  DESCRIPTION
    This function should be called if you used the RT_ReqHandler tag with a
    requester function.<P>

    The requester you used the tag with will have returned immediately after
    its initialization and will have initialized a pointer to a rtHandlerInfo
    structure for you.
    You should now do the following:<P>

    Check the DoNotWait field. If it is FALSE you have to wait for the
    signals in the WaitMask field (plus your own signals if you like).
    If any of the signals in WaitMask are received or DoNotWait was not FALSE
    you have to call rtReqHandlerA() and check its return value for one of
    the following values:<P>

      CALL_HANDLER    - Check DoNotWait again, Wait() if you have to
                        and call rtReqHandlerA() again. In other words, loop.
      everything else - normal return value, requester has finished. This
                        return value will be the same as if the requester
                        had run normally.<P>

    You must pass the signals you received to rtReqHandlerA().<P>

    NOTE: if you want to wait for your own signals do not do so if
          DoNotWait is TRUE.  Call rtReqHandlerA() and if you must know
          if one of your signals arrived use SetSignal() to find this out.
          If you are waiting for a message to arrive at a message port you
          can simple call GetMsg() and check if it is non-null.
          DoNotWait will naturally only be TRUE when it absolutely,
          positively has to be.  A multitasking machine as the Amiga should
          use Wait() as much as possible.<P>

    This is an example of a &quot;requester loop&quot;:<P>

    ...
    struct rtHandlerInfo *hinfo;
    ULONG ret, mymask, sigs;<P>

    ...
       /* calculate our mask */
       mymask = 1 &lt;&lt; win-&gt;UserPort-&gt;mp_SigBit;<P>

       /* We use the RT_ReqHandler tag to cause the requester to return
          after initializing.
          Check the return value to see if this setup went ok. */
       if (<A href=rtFontRequestA.html>rtFontRequest</A>(req, &quot;Font&quot;, RT_ReqHandler, &amp;hinfo, TAG_END)
                                                           == CALL_HANDLER) {
          do {
            /* Wait() if we can */
            if (!hinfo-&gt;DoNotWait)
               sigs = Wait(hinfo-&gt;WaitMask | mymask);<P>

            /* check our own message port */
            while (msg = GetMsg(win-&gt;UserPort)) {
               ...
               /* here we handle messages received at our windows IDCMP ...
                  port */
               ...
               }<P>

            /* let the requester do its thing (remember to pass 'sigs') */
            ret = rtReqHandler(hinfo, sigs, TAG_END);<P>

            /* continue this loop as long as the requester is up */
            } while (ret == CALL_HANDLER)<P>

          /* when we get here we know the requester has finished, 'ret'
             is the return code. */
          ...
          }
       else notify(&quot;Error opening requester!&quot;);
    ...<P>

  INPUTS
    handlerinfo - pointer to handler info structure initialized by using
                  the RT_ReqHandler tag when calling a requester function.
    sigs        - the signals received by previous wait, will be ignored if
                  hinfo-&gt;DoNotWait was TRUE.
    taglist     - pointer to a TagItem array.<P>

  TAGS
    RTRH_EndRequest - supplying this tag will end the requester. The return
                      code from rtReqHandlerA() will _not_ be CALL_HANDLER,
                      but the requester return code.  If the tagdata of this
                      tag is REQ_CANCEL the requester will be canceled, if it
                      is REQ_OK the requester will be ok-ed.
                      In case of an <A href=rtEZRequestA.html>EZRequest</A> tagdata should be the return
                      code of the requester (TRUE, FALSE or 2,3,4,...).<P>

  RESULT
    ret - CALL_HANDLER if you have to call rtReqHandlerA() again,
          or the normal return value from the requester.<P>

  BUGS
    none known<P>

  SEE ALSO
    <A href=rtEZRequestA.html>rtEZRequest()</A> (RT_ReqHandler explanation)
<HR>
