<HTML>
<HEAD>
<TITLE>rtLockWindow</TITLE></HEAD><BODY><H6><A href=main.html>Contents page</A></H6><P>
<H6><A href=Main.html>Index</A></H6><P>
<H1>rtLockWindow</H1>
<HR>
reqtools.library/rtLockWindow<P>
<PRE>
  NAME  rtLockWindow() [V38]<P>

    windowlock = rtLockWindow (window);<P>

    APTR rtLockWindow (struct Window *);
    D0                 A0<P>

  DESCRIPTION
    Lock a window so it will no longer accept any user input.  The only
    functions left to the user are depth arrangement and window dragging.
    All gadgets will be un-selectable and the window can not be resized.
    It will also get the standard wait pointer set.  The pointer at the
    time of locking will be restored when the window is unlocked (this
    will *not* happen on Kickstart V39 or higher!).<P>

    You may nest calls to rtLockWindow() and <A href=rtUnlockWindow.html>rtUnlockWindow()</A>.  Make sure
    you unlock the window in the correct (opposite) order.<P>

    See the RT_LockWindow tag for an automatic way of locking your window.<P>

    Use this function (and rtUnlockWindow()) instead of <A href=rtSetWaitPointer.html>rtSetWaitPointer()</A>.<P>

  INPUTS
    window - pointer to the window to be locked.<P>

  RESULT
    windowlock - a pointer to a (private) window lock.  You must pass this
                 to rtUnlockWindow() to unlock the window again.
                 Never mind if this is NULL.  This means there was not enough
                 memory and the window will not be locked.  There is no
                 sense in reporting this, just carry on and pass the NULL
                 window lock to rtUnlockWindow().<P>

  NOTE
    The wait pointer will look exactly like the standard Workbench 2.0
    wait pointer.  In combination with PointerX, ClockTick or LacePointer
    the handle will turn.<P>

  BUGS
    none known<P>

  SEE ALSO
<HR>
