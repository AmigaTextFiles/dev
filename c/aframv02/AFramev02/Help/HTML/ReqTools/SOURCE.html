<HTML>
<HEAD>
<TITLE>Source</TITLE></HEAD><BODY><H6><A href=main.html>Contents page</A></H6><P>
<H6><A href=Main.html>Index</A></H6><P>
<H1>Source</H1>
<HR>
  //////////////////////////////////////////////////////////////////////////////<PRE>
  // ReqTools.cpp - AFrame v1.0 © 1996 Synthetic Input
  //
  // ReqTools C++ Object utilizing reqtools.library version 38.1296
  // by Nico François.  ReqTools is © Nico François
  // 
  //
  // Deryk B Robosson
  // Jeffry A Worth
  // January 20, 1996
  //////////////////////////////////////////////////////////////////////////////<P>

  //////////////////////////////////////////////////////////////////////////////
  // INCLUDES
  #include &quot;AFRAME:include/reqtools.hpp&quot;<P>

  #ifndef __AFREQTOOLS_DEFTAGS__
  #define __AFREQTOOLS_DEFTAGS__<P>

  ULONG def_screentags[] = {</PRE>
RTSC_Flags,SCREQF_DEPTHGAD|SCREQF_SIZEGADS|SCREQF_AUTOSCROLLGAD|SCREQF_OVERSCANGAD,TAG_END } ;<PRE>
  ULONG def_filetags[] = { RTFI_FilterFunc,TAG_END };
  ULONG def_multifiletags[] = { RTFI_FilterFunc,RTFI_Flags,FREQF_MULTISELECT,TAG_END };
  ULONG def_dirtags[] = { RTFI_Flags,FREQF_NOFILES,TAG_END };
  ULONG def_volumetags[] = { RTFI_FilterFunc,RTFI_VolumeRequest,0,TAG_END };
  ULONG def_fonttags[] = { RTFO_FilterFunc,TAG_END };
  ULONG def_palettetags[] = { TAG_END };
  ULONG def_getlong[] = { RTGL_ShowDefault,FALSE,RTGL_Min,0,RTGL_Max,999999,TAG_END };
  //ULONG def_getstring[] = {</PRE>
RTGS_GadFmt,&quot;_Ok|_Cancel&quot;,RTGS_BackFill,FALSE,RTGS_Flags,GSREQF_CENTERTEXT|GSREQF_HIGHLIGHTTEXT,TAG_MORE,RT_Undersco
re,'_',TAG_END };<P>
<PRE>
  #endif //__AFREQTOOLS_DEFTAGS__<P>

  extern struct ExecBase *SysBase;
  extern struct ReqToolsBase *ReqToolsBase;<P>

  //////////////////////////////////////////////////////////////////////////////
  //<P>

  AFReqTools::AFReqTools()
  {
      color=0;
      filename[0]=0;
      m_filelist=NULL;
      m_screenmoderequester=NULL;
      m_filerequester=NULL;
      m_fontrequester=NULL;
  }<P>

  AFReqTools::~AFReqTools()
  {
      DestroyObject();
  }<P>

  void AFReqTools::DestroyObject()
  {
      if(m_filelist)  rtFreeFileList(m_filelist);
      if(m_screenmoderequester) rtFreeRequest(m_screenmoderequester);
      if(m_filerequester) rtFreeRequest(m_filerequester);
      if(m_fontrequester) rtFreeRequest(m_fontrequester);<P>

      color=0;
      filename[0]=0;
      m_filelist=NULL;
      m_screenmoderequester=NULL;
      m_filerequester=NULL;
      m_fontrequester=NULL;
  }<P>

  BOOL AFReqTools::RTCreate()
  {
      if(!ReqToolsBase)
          if(!(ReqToolsBase=(struct ReqToolsBase *)OpenLibrary((UBYTE*)REQTOOLSNAME,(ULONG)REQTOOLSVERSION)))
              return FALSE;
          else return TRUE;
      else return FALSE;
  }<P>

  BOOL AFReqTools::RTEZRequest(char *text, char *gadfmt)
  {
      return ::rtEZRequest(text,gadfmt,NULL,NULL);
  }<P>

  BOOL AFReqTools::RTEZRequestA(char *text, char *gadfmt, struct rtReqInfo *reqinfo, ULONG taglist[])
  {
      return ::rtEZRequest(text,gadfmt,reqinfo,(struct TagItem *)taglist);
  }<P>

  BOOL AFReqTools::RTScreenMode()
  {
      if(SysBase-&gt;LibNode.lib_Version&lt;37) {
          rtEZRequestTags(&quot;ScreenMode requesters require\n Kickstart 2.0 or</PRE>
higher.\n&quot;,&quot;_Ok&quot;,NULL,NULL,RT_Underscore,'_',TAG_END);<PRE>
          return FALSE;
      } else {
          if(m_screenmoderequester=(struct rtScreenModeRequester*)rtAllocRequestA(RT_SCREENMODEREQ,NULL)) {
              if(!rtScreenModeRequest(m_screenmoderequester,(char *)&quot;Select a Screen Mode&quot;,(ULONG)RTSC_Flags,
                                      (ULONG)(SCREQF_DEPTHGAD|SCREQF_SIZEGADS|SCREQF_AUTOSCROLLGAD|SCREQF_OVERSCANGA</PRE>
D),(ULONG)TAG_END))<PRE>
                  return FALSE;
              else return TRUE;
          } else { 
              rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
              return FALSE;
            }
      }
  }<P>

  BOOL AFReqTools::RTScreenModeA(ULONG taglist[])
  {
      if(SysBase-&gt;LibNode.lib_Version&lt;37) {
          rtEZRequestTags(&quot;ScreenMode requesters require\n Kickstart 2.0 or</PRE>
higher.\n&quot;,&quot;_Ok&quot;,NULL,NULL,RT_Underscore,'_',TAG_END);<PRE>
          return FALSE;
      } else {
          if(m_screenmoderequester=(struct rtScreenModeRequester*)rtAllocRequestA(RT_SCREENMODEREQ,NULL)) {
              if(!rtScreenModeRequestA(m_screenmoderequester,(char *)&quot;Select a Screen Mode&quot;,(struct TagItem</PRE>
*)taglist))<PRE>
                  return FALSE;
              else return TRUE;
          } else { 
              rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
              return FALSE;
            }
      }
  }<P>

  BOOL AFReqTools::RTFileRequest()
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          m_filterhook.h_Entry=(ULONG(*)())file_filterfunc;
          if(!rtFileRequest(m_filerequester,filename,&quot;Select a File&quot;,RTFI_FilterFunc,&amp;m_filterhook,TAG_END))
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTFileRequestA(ULONG taglist[])
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          m_filterhook.h_Entry=(ULONG(*)())file_filterfunc;
          if(!rtFileRequestA(m_filerequester,filename,&quot;Select a File&quot;,(struct TagItem *)taglist))
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTFilesRequest()
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          m_filterhook.h_Entry=(ULONG(*)())file_filterfunc;
          m_filelist=(struct rtFileList*)rtFileRequest(m_filerequester,filename,&quot;Select</PRE>
Files&quot;,RTFI_FilterFunc,&amp;m_filterhook,RTFI_Flags,FREQF_MULTISELECT,TAG_END);<PRE>
          if(!m_filelist)
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTFilesRequestA(ULONG taglist[])
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          m_filterhook.h_Entry=(ULONG(*)())file_filterfunc;
          m_filelist=(struct rtFileList*)rtFileRequestA(m_filerequester,filename,&quot;Select Files&quot;,(struct TagItem</PRE>
*)taglist);<PRE>
          if(!m_filelist)
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTDirRequest()
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          if(!rtFileRequest(m_filerequester,filename,&quot;Select a Directory&quot;,RTFI_Flags,FREQF_NOFILES,TAG_END))
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTVolumeRequest()
  {
      if(m_filerequester=(struct rtFileRequester*)rtAllocRequestA(RT_FILEREQ,NULL)) {
          m_volume_filterhook.h_Entry=(ULONG (*)())vol_filterfunc;
          if(!rtFileRequest(m_filerequester,filename,&quot;Select a</PRE>
Volume&quot;,RTFI_FilterFunc,&amp;m_volume_filterhook,RTFI_VolumeRequest,0,TAG_END))<PRE>
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTFontRequest()
  {
      if(m_fontrequester=(struct rtFontRequester*)rtAllocRequestA(RT_FONTREQ,NULL)) {
          m_fontrequester-&gt;Flags=FREQF_STYLE|FREQF_COLORFONTS;
          m_font_filterhook.h_Entry=(ULONG (*)())font_filterfunc;
          if(!rtFontRequest(m_fontrequester,&quot;Select a Font&quot;,RTFO_FilterFunc,&amp;m_font_filterhook,TAG_END))
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTFontRequestA(ULONG taglist[])
  {
      if(m_fontrequester=(struct rtFontRequester*)rtAllocRequestA(RT_FONTREQ,NULL)) {
          m_fontrequester-&gt;Flags=FREQF_STYLE|FREQF_COLORFONTS;
          m_font_filterhook.h_Entry=(ULONG (*)())font_filterfunc;
          if(!rtFontRequestA(m_fontrequester,&quot;Select a Font&quot;,(struct TagItem *)taglist))
              return FALSE;
          else return TRUE;
      } else {
          rtEZRequest((char *)&quot;Out of memory!&quot;,(char *)&quot;Ok!&quot;,NULL,NULL);
          return FALSE;
        }
  }<P>

  BOOL AFReqTools::RTPaletteRequest()
  {
      color=rtPaletteRequest(&quot;Change Palette&quot;,NULL,TAG_END);<P>

      if(color==-1)
          return FALSE;
      else return TRUE;
  }<P>

  BOOL AFReqTools::RTPaletteRequestA(ULONG taglist[])
  {
      color=rtPaletteRequestA(&quot;Change Palette&quot;,m_reqinfo,(struct TagItem *)taglist);<P>

      if(color==-1)
          return FALSE;
      else return TRUE;
  }<P>

  void AFReqTools::RTScreenToFront(struct Screen *screen)
  {
      rtScreenToFrontSafely(screen);
  }<P>

  void AFReqTools::RTSetWaitPointer(struct Window *win)
  {
      rtSetWaitPointer(win);
  }<P>

  BOOL AFReqTools::RTLockWindow(struct Window *win)
  {
      m_windowlock=(APTR)rtLockWindow(win);
      return TRUE;
  }<P>

  void AFReqTools::RTUnlockWindow(struct Window *win, APTR winlock)
  {
      rtUnlockWindow(win,winlock);
  }<P>

  ULONG AFReqTools::RTGetLong(char *title, struct rtReqInfo *reqinfo)
  {
      ULONG ret;
      if(!(ret=rtGetLong((ULONG</PRE>
*)&amp;longvar,title,reqinfo,RTGL_ShowDefault,FALSE,RTGL_Min,0,RTGL_Max,999999,TAG_END)))<PRE>
          return FALSE;
      else return ret;
  }<P>

  ULONG AFReqTools::RTGetLongA(char *title, struct rtReqInfo *reqinfo, ULONG taglist[])
  {
      ULONG ret;
      if(!(ret=rtGetLongA((ULONG *)&amp;longvar,title,reqinfo,(struct TagItem *)taglist)))
          return FALSE;
      else return ret;
  }<P>

  ULONG AFReqTools::RTGetString(UBYTE *buffer, ULONG maxchars, char *title, struct rtReqInfo *reqinfo)
  {
      ULONG ret;<P>

      if(!(ret=rtGetString(buffer, maxchars, title, reqinfo, RTGS_GadFmt,</PRE>
&quot;_Ok|_Cancel&quot;,RTGS_BackFill,FALSE,RTGS_Flags,GSREQF_CENTERTEXT|GSREQF_HIGHLIGHTTEXT,TAG_MORE,RT_Underscore,'_',TAG_E
ND)))<PRE>
          return FALSE;
      else return ret;
  }<P>

  ULONG AFReqTools::RTGetStringA(UBYTE *buffer, ULONG maxchars, char *title, struct rtReqInfo *reqinfo, ULONG</PRE>
taglist[])<PRE>
  {
      ULONG ret;<P>

      if(!(ret=rtGetStringA(buffer, maxchars, title, reqinfo, (struct TagItem *)taglist)))
          return FALSE;
      else return ret;
  }<P>

  ULONG AFReqTools::RTGetVScreenSize(struct Screen *screen, ULONG *widthptr, ULONG *heightptr)
  {
      ULONG spacing;<P>

      if(!(spacing=rtGetVScreenSize(screen,widthptr,heightptr)))
          return FALSE;
      else return spacing;
  }<P>

  BOOL __asm __saveds file_filterfunc (register __a0 struct Hook *filterhook,
         register __a2 struct rtFileRequester *req,
         register __a1 struct FileInfoBlock *fib)
  {
      // examine fib to decide if you want this file in the requester
      return TRUE;
  }<P>

  BOOL __asm __saveds vol_filterfunc (
      REG __a0 struct Hook *hook,
      REG __a2 struct rtFileRequester *filereq,
      REG __a1 struct rtVolumeEntry *volentry
      )
  {
      // examine volentry to decide which volumes you want in this requester
      return TRUE;
  }<P>

  BOOL __asm __saveds font_filterfunc (
      REG __a0 struct Hook *hook,
      REG __a2 struct rtFontRequester *fontreq,
      REG __a1 struct TextAttr *textattr
      )
  {
      // examine textattr to decide which fonts you want in this requester
      return TRUE;
  }
<HR>
