@DATABASE "StateMachine.guide"
@AUTHOR "James T. Steichen"
@(C) StateMachine.guide (c) 2004 by J.T. Steichen, ALL rights reserved.
 
@REMARK $VER: StateMachine.guide 3.0 (06-Dec-2004) by J.T. Steichen

@WORDWRAP

@TOC "Contents"

@NODE "Contents" "Table of Contents"
@{FG SHINE}
              Hey guys, look at all these candies! @{FG TEXT}
	
   @{" Introduction                   " LINK "Main"}
   @{" Requirements                   " LINK "Requirements"} - Other stuff you need (but NOT supplied!)
   @{" Theory of Operation            " LINK "Theory"} - Fine as theories go...
   @{" KeyStrokes                     " LINK "keystrokes"} - Other ways to navigate...
   @{" What's StateMachine good for?? " LINK "WhyUseIt"} - (wasted lots of my time, anyway!)
   @{" Show me how it works           " LINK "IDCMPExample"}
@{FG SHINE}
   Due to popular demand... @{FG TEXT}
   @{" Explanation of the Example...  " LINK "ExampleExplanation"} 
     @{" Lots goin on... " LINK "NextStates"}
       @{" Getting to the finish line " LINK "Almost"}     
         @{" The code what does all of the work " LINK "ActionCode"}

   @{" Disk Configuration             " LINK "Distribution"} - These are all your beautiful files!
   @{" File Formats used              " LINK "FileFormats"} - What the @*&%#(!@!?
   @{" Support Programs               " LINK "SupportPgms"} - (NOT alimony!)
   @{" Bibliography                   " LINK "Bibliography"} - Further Finite State Machine information

   @{" Author Information             " LINK "Author"} - Who's responsible for this outrage??

@ENDNODE

@NODE "Main" "StateMachinePPC Documentation:"
@TOC "Contents"
@{FG SHINE}
   What magic spells were cast to create such a great program? @{FG TEXT}
   
   The StateMachinePPC GUI was created with CanDo V2.0.  I recommend CanDo highly
   since it cuts down on how much C code I have to write in order to make an
   effective Amiga-based program.  Unfortunately, CanDo is no longer supported
   or available, which necessitated re-writing StateMachinePPC in C with the 
   gcc V2.95.3 Compiler running on AmigaOS4.  As far as possible, the source
   code is still compilable with SAS-C & versions of StateMachine can be 
   compiled for 680x0 processors.  (Ya want one, ya gotta pay!)

   StateMachinePPC is intended to allow an Amiga programmer to create finite state
   machines with a graphical user interface, rather than generate the program
   by hand.  StateMachinePPC does NOT generate the action functions associated
   with the finite state machine.  This is up to the user of StateMachinePPC.
   If it could, I would be charging serious money for the program!

   Currently, StateMachinePPC allocates space for 300 items in the 
   @{B}Input Symbols, States, & Actions@{UB} ListView Gadgets, as well as space for 900
   items in the @{B}NextState, Action Pairs:@{UB} ListView Gadget.  These limits are 
   not hard-coded in, but if the program dies because you're making a 
   state machine that's larger than these values, perhaps you should contact
   @{" me " LINK "Author"} for professional support.  Eventually, the @{" ToolTypes " LINK "ToolTypes"} will
   determine the startup sizes for the ListView Gadgets.

@{FG SHINE}   
   By the way, ExamplePPC does NOT work correctly on my AmigaOne; but this an
   example after all -- why don't you send me a working example?? @{FG TEXT}
   
   @{" How Do I Work This? " LINK "Theory"}

   SEE ALSO @{" Table of Contents " LINK "Contents"}

@ENDNODE

@NODE "keystrokes" "KeyStrokes recognized by StateMachinePPC:"
@TOC  "Contents"
@PREV "Main"
@{FG SHINE}
   The following keys are equivalent to clicking on the different Gadgets: @{FG TEXT}

   s or S - Same as putting a carriage return in the @{U}S@{UU}canner String Gadget.
   m or M - Same as putting a carriage return in the @{U}M@{UU}achine String Gadget.
   r or R - Same as putting a carriage return in the @{U}R@{UU}eturn  String Gadget.
   t or T - Same as putting a carriage return in the @{U}T@{UU}ype    String Gadget.

   x or X - Same as clicking on the E@{U}x@{UU}ternal Editor Button Gadget.
   e or E - Same as clicking on the Internal @{U}E@{UU}ditor Button Gadget.
   k or K - Same as clicking on the Hole Chec@{U}k@{UU} Button Gadget.
   
   Both the Left & Right arrow keys cycle through the four ListView Gadgets,
   activating each in turn.
   
   Both the Up & Down arrow keys activate each list item in the currently
   active ListView Gadget & copy the active list item into the corresponding
   String Gadget.
   
   Shift-Clicking on the @{B}States@{UB} or @{B}Actions@{UB} ListView items will copy the item you
   selected to the @{B}NextState, Action Pairs@{UB} ListView Gadget.
@{FG SHINE}
   The following keys are equivalent to selecting Menu Items: @{FG TEXT}

   l or L - Same as selecting the @{B}Load@{UB} menu item under @{B}PROJECT@{UB}.
   s or S - Same as selecting the @{B}Save@{UB} menu item under @{B}PROJECT@{UB}.
   a or A - Same as selecting the @{B}Save As@{UB} menu item under @{B}PROJECT@{UB}.
   g or G - Same as selecting the @{B}Generate Source@{UB} menu item under @{B}PROJECT@{UB}.
   y or Y - Same as selecting the @{B}Edit ToolTypes@{UB} menu item under @{B}PROJECT@{UB}.
   h or H - Same as selecting the @{B}Help@{UB} menu item under @{B}PROJECT@{UB}.
   i or I - Same as selecting the @{B}About..@{UB} menu item under @{B}PROJECT@{UB}.
   q or Q - Same as selecting the @{B}Quit@{UB} menu item under @{B}PROJECT@{UB}.

   The Help key also is equivalent to selecting the @{B}Help@{UB} menu item under @{B}PROJECT@{UB}.
@{FG SHINE}
   NOTE:  The Help key is the Scroll-Lock key on my Logitech Windoze keyboard. @{FG TEXT}
   
@ENDNODE

@NODE "SupportPgms" "Support Programs supplied with StateMachinePPC:"
@{FG SHINE}
              Notice how these programs lifts & separate! @{FG TEXT}

   The Distribution of StateMachinePPC has two support programs included.
   These are:
@{FG SHINE}
      NAME  @{FG TEXT}
         ToolTypesEditorPPC @{FG SHINE}
      SYNOPSIS   @{FG TEXT}
         ToolTypesEditorPPC iconName.info @{FG SHINE}
      DESCRIPTION @{FG TEXT}
         Allow the User to edit/view the ToolTypes contained in the iconName.info file.
	 	 
      and
@{FG SHINE}
      NAME @{FG TEXT}
         FSMGenPPC @{FG SHINE}
      SYNOPSIS @{FG TEXT}
         FSMGenPPC <inputFile.fsm outputSourceFile.c @{FG SHINE}
      DESCRIPTION @{FG TEXT}
         The Finite State Machine generator program.  It actually does the
	 work of translating the .fsm file from StateMachinePPC into a 
	 C-source code file.  It can be placed in any directory you wish as long as 
	 the PATH is set accordingly.  StateMachinePPC will interface with this
	 program for you (but in case you want to know how to use it from a CLI/Shell,
	 this documentation is provided).
@ENDNODE

@NODE "Requirements" "Needed stuff for StateMachinePPC:"
@TOC "Contents"
@{FG SHINE}
              I did NOT supply everything to you! @{FG TEXT}
		
   Other things that you need to use StateMachinePPC:
   
   * A working C-Compiler (gcc recommended).

   * A lexical-analyzer generator (FLeX recommended).

   * An Amiga with a PowerPC processor.
   
   * 4-5 MB of hard disk space
   
   * Programming knowledge in your wet-ware!
         
@ENDNODE

@NODE "FileFormats" "File Formats that StateMachinePPC uses:"
@TOC "Contents"
@{FG SHINE}
                NO Secret decoder ring needed! @{FG TEXT}
	    
   Beyond the ordinary ASCII text files that one uses to keep source
   code in, StateMachinePPC (& FSMGenPPC) use a couple of file formats that
   are documented here:
   
   The .ini file is human-readable ASCII strings, similar to the old
   Windoze .ini files in structure (i.e., a group name followed by 
   group items).  You can therefore edit/create these files by hand,
   if that seems more convenient to you.  If you do so, please follow
   the layout order given (or don't expect StateMachinePPC to work properly!).
   This format is what the @{B}Load & Save@{UB} menu items use in StateMachinePPC under @{B}PROJECT@{UB}.
@{FG SHINE}
   .ini format (Used by StateMachinePPC only): @{FG TEXT}
   
   [ListViewLimits]
   SymbolCount         = 4 @{FG SHINE}- This number must reflect the number of symbol lines present in the file. @{FG TEXT}
   StateCount          = 3 @{FG SHINE}- This number must reflect the number of state lines present in the file. @{FG TEXT}
   ActionCount         = 3 @{FG SHINE}- This number must reflect the number of action lines present in the file. @{FG TEXT}
   NextActionLineCount = 3 @{FG SHINE}- This number must reflect the number of nextState lines present in the file. @{FG TEXT}
   [MachineDefinition]
   SCANNER = yylex
   MACHINE = main
   RETURNS = 0
   TYPE    = int
   [SymbolTable]
   Symbol = empty
   Symbol = white 
   Symbol = eol 
   Symbol = colon
   [StateTable]   
   State = start
   State = st_0
   State = st_1
   [ActionTable]
   Action = sys_0  
   Action = Echo  
   Action = skip
   [NextState_Actions]
   Line = st_0,sys_0,st_0,Echo,st_0,skip,st_0,Echo
   Line = st_1,sys_0,st_1,Echo,st_1,Echo,st_1,skip
   Line = start,sys_0,start,Echo,start,skip,start,Echo
@{I}
   The .fsm format reserves a handful of words as keywords: @{UI}
@{B}
      PREAMBLE
      SCANNER
      MACHINE
      RETURNS
      TYPE
      TRANSITIONS
      CODE
      END @{UB}

   The .fsm format is also human-readable (but tedious to create by hand!).
   This is the primary task of StateMachinePPC -- to create .fsm files from
   your input specifications!
@{FG SHINE}
   .fsm format (Used by both StateMachinePPC & FSMGenPPC) @{FG TEXT}

   #{ @{FG SHINE}(or PREAMBLE) @{FG TEXT}
   /* Place #include files & other global data in here. */
   #}
   SCANNER scannerName; /* Usually 'yylex' */
   MACHINE machineName; /* Usually 'main'  */
   RETURNS 0;           /* or whatever value means the state machine is terminating...*/
   TYPE    int;         /* The return type of each Action function */
   
   TRANSITIONS
   {
      \@Lexeme  \@or          \@Token \@is           \@Another \@Name \@for
      \@Symbols \@Understand? ....   \@SymbolEnd@{FG SHINE} :: @{FG TEXT}
   
   >startState<  next1,action1, next2,action2, next3,action3,
                 ...
   >nextState<   next21,action21, ...
   
   ...
   };
   
   {\@ @{FG SHINE}(or CODE) @{FG TEXT}
   // Place your action functions in this section:
   // Examples: @{FG SHINE}
   void skip( void )   { return; }

   void fault( void )
   {
      printf( "\nIllegal transition to unused state!\n\n" );
   }

   void echo( void )
   {
      int   i = 0;

      while (*(idstr + i) != '\0')  
         {
         (void) putchar( (int) *(idstr + i) );

         i++;
         }

      return;
   } @{FG TEXT}

   \@} @{FG SHINE}(or END) @{FG TEXT}
   
@ENDNODE

@NODE "Theory" "Theory of Operation:"
@TOC "Contents"
@PREV "Main"
@{FG SHINE}
                           How Do I Work This? @{FG TEXT}
    
   A state machine is a program that executes a given function (the action)
   when a given input is supplied (the state), then it moves to another
   state (the next state) & waits for more input.  This input is supplied by
   a user-supplied function that essentially is a lexical analyzer-generator
   (scanner).  A 'scanner' takes an input file & breaks it up into lexemes
   (i.e., keywords, whitespace, punctuation, etc).  Based on the type of lexeme,
   it returns a value to the finite state machine, which in this case, is called
   the State.  The state machine generated uses re-directed I/O for input; 
   therefore, usage of your state machine program will be:
@{FG SHINE}
      your_statemachine <input_definition_file output_source_file @{FG TEXT}
@{B}
      NOTE:  you decide if the output is redirected by how you define
             your output functions!  In other words, you have to figure out how
	     to get yylex() (or whatever scanner you use) to behave correctly.@{UB}
          
   In a way, your computer itself is a large state machine, with instructions
   serving as lexemes, execution of the instructions serving as actions &
   the operating system determining what the next state of the PC is!

   You can also look at ExampleLex.c & examine a very complex state machine-type
   program that FLeX generated from Example.flex.
   
   @{" What's it good for? " LINK "WhyUseIt"}

@ENDNODE

@NODE "WhyUseIt" "What's StateMachinePPC good for??"
@TOC "Contents"
@{FG SHINE}
                   This is NOT my beautiful program... @{FG TEXT}
		    
   So when exactly would a programmer use a finite state machine instead of
   something straight-forward, like a large case statement or a series of
   if-then-else constructs?  For those of you out there that have examined
   a simple (?) Microsoft Windows 3.x program, you will notice that all
   data communications between the operating system & a windows application is
   done via messages, Hundreds of them!  Every WinMain() function has to have
   a large case statement (or call a function that does) in order to cover
   every message that the program will respond to.  Even for simple programs 
   this case statement can be quite large!  

   In general, if you do not know or cannot predict what the next input
   token will be to your program, chances are that a State Machine-type program
   is the best tool for solving your programming conundrum!
    
   Intuition for the Amiga also uses messages, sent to the IDCMPort attached 
   to all open windows.  Fortunately, Intuition has fewer messages to contend 
   with, so it's much easier to use case statements for decoding what the user 
   is doing with the GUI.  Unfortunately, the IDCMP message values are NOT in a 
   linear sequence!  This rules out using finite state machines for the GUI 
   decoding (IDCMP message values are powers of 2.  This means a finite state 
   machine might have a very large (2^32) next-state,action matrix with very 
   few used elements.  This is known as a sparse matrix).

   @{" Show me what you mean " LINK "IDCMPExample"}

@ENDNODE

@NODE "IDCMPExample" "How StateMachinePPC can simplify your life:"
@TOC "Contents"
@{FG SHINE}
                           Shop and compare... @{FG TEXT}
			    
   If IDCMP message values were linear, this is how a IDCMP message decoder
   could be constructed using a finite state machine:
@{FG SHINE}
   FROM TYPICAL IDCMP MESSAGE LOOP: @{FG TEXT}
   
   while (looping == TRUE)
      {
      if (!(imessage = (struct IntuiMessage *) GetMsg( my_window->UserPort )))
         {
         (void) Wait( 1L << my_window->mp_SigBit );

         continue;
         }

      mclass = imessage->Class;
      mcode  = imessage->Code;

      (void) ReplyMsg( imessage );

      switch (mclass)
         {
         case MOUSEBUTTONS:
            DoMouseButtons( mcode );
            break;

         case MENUPICK:
            DecodeMenuSelection( MENUNUM( mcode ), ITEMNUM( mcode ));
            break;

         case GADGETUP:
            DecodeGadgetSelection( mcode );
            break;

         case NEWSIZE:
            UpdateGraphics();
            break;

         case REFRESHWINDOW:
            UpdateGraphics();
            break;

         case CLOSEWINDOW:
            // ClearMenuStrip() if there is one!
            Do_CleanUp();
            looping = FALSE;

         default:
            break;
         }
      }
@{FG SHINE}      
   CHANGED INTO A FINITE STATE MACHINE: @{FG TEXT}
   
   while (looping == TRUE)
      {
      if (!(imessage = (struct IntuiMessage *) GetMsg( my_window->UserPort )))
         {
         (void) Wait( 1L << my_window->mp_SigBit );

         continue;
         }

      State = imessage->Class;

      mcode = imessage->Code;

      (void) ReplyMsg( imessage );

      (*IDCMP_FunctionTable[ mcode ][ State ].action)( );

      looping = IDCMP_FunctionTable[ mcode ][ State ].nextstate;
      }

   As you can see, the code is much simpler, @{B}but much harder to trace & debug!@{UB}
   
   @{" How does the example work? " LINK "ExampleExplanation"}

@ENDNODE

@NODE "ExampleExplanation" "Explanation/Examples:"
@TOC "Contents"
@{FG SHINE}
                    But is it "User-Friendly?" @{FG TEXT}
   
   The places a programmer might find uses for finite state machines are
   file translators, interpreters or compilers.  This means that you could
   create a programming language of your own, for example, a simple interpreted
   language that uses Amiga graphics functions to draw shapes, etc.  This is
   precisely what I have chosen for my example.

   My example recognizes the following instructions:

      HIRES;
      LORES;
      COLOR  Reg#,Red#,Green#,Blue#;
      MOVE   X#,Y#;
      DRAW   X#,Y#;
   
   The first thing a programmer has to figure out is what lexemes the scanner
   must recognize & return to the finite state machine.  For the example, the
   scanner must recognize:

      numbers, commas, semicolons, whitespace, newlines, 'HIRES', 'LORES',
      'COLOR', 'MOVE', 'DRAW' & EOF.

   Next, the programmer must decide what to do when the scanner returns a given
   lexeme.  These are the action functions that will be placed into the action,
   next-state table.  Some actions are always going to be needed, these are:

      error(), ignore(), echo().

   The following actions are added to the example:

      StowNum, DrawFunc, MoveFunc, OpenGraph, ChgColor & Cleanup
      as well as RptErr & Ignore

   Start up the StateMachinePPC program.  @{FG SHINE}Click@{FG TEXT} on an empty item in the Actions
   ListView and it will appear in the String Gadget beneath it (or type these items in the
   String Gadget directly):

      Ignore
      RptErr
      StowNum
      DrawFunc
      MoveFunc
      OpenGraph
      ChgColor
      Cleanup
@{FG SHINE}
   (Or you can select the @{B}Load@{UB} menu-item & load in Example.ini) @{FG TEXT}
   
   Once you are back in the GUI, @{FG SHINE}click@{FG TEXT} on an empty item in the Symbols 
   ListView and it will appear in the String Gadget beneath it (or type these items in the
   String Gadget directly):

      EndFile 
      WhiteSpace
      SemiColon
      HiRes
      LoRes
      Move
      Draw
      Color
      Number
      Comma
      EndLine
@{B}
   NOTE:  These are entered in this order since the generated finite state
          machine expects to see the values in the order the scanner defines them. @{UB}
@{FG SHINE}
          Only the Symbols & NextState,Actions entries are order-dependent. @{FG TEXT}

   Return to the GUI & @{FG SHINE}click@{FG TEXT} on the States ListView (on an empty item)
   and enter the following state names into the ListView (or type these items in the
   String Gadget directly):

      Begin
      DefColor
      DefMove
      DefDraw
      Error
      Done

   @{" But wait!  There's more... " LINK "NextStates"}

@ENDNODE

@NODE "NextStates" "More has to be done (sigh!):"
@TOC "Contents"
@{FG SHINE}
                  Work again?  Grumble, grumble... @{FG TEXT}
  
   Return to the GUI & get ready to do the major task of entering
   in the NextState,Actions name pairs.  This can be done by first @{FG SHINE}Shift-clicking@{FG TEXT} on 
   the State name & then @{FG SHINE}Shift-clicking@{FG TEXT} on the Action name that you want to appear in 
   the list.  StateMachinePPC doesn't care how many newlines are in the 
   NextState,Actions list, so space them so that you can read them.
   Here is the list for our example @{FG SHINE}(note that there are multiple pairs per ListView item): @{FG TEXT}

     Done,Cleanup,    Begin,Ignore,   Begin,Ignore,   Begin,OpenGraph,
     Begin,OpenGraph, DefMove,Ignore, DefDraw,Ignore, DefColor,Ignore,
     Error,RptErr,    Begin,Ignore,   Begin,Ignore,
   
     Error,RptErr,    DefColor,Ignore, Begin,ChgColor, Error,RptErr,
     Error,RptErr,    Error,RptErr,    Error,RptErr,   Error,RptErr,
     DefColor,StowNum,DefColor,Ignore, DefColor,Ignore,

     Error,RptErr,    DefMove,Ignore, Begin,MoveFunc, Error,RptErr,
     Error,RptErr,    Error,RptErr,   Error,RptErr,   Error,RptErr,
     DefMove,StowNum, DefMove,Ignore, Begin,Ignore,

     Error,RptErr,    DefDraw,Ignore, Begin,DrawFunc, Error,RptErr,
     Error,RptErr,    Error,RptErr,   Error,RptErr,   Error,RptErr,
     DefDraw,StowNum, DefDraw,Ignore, Begin,Ignore,
     
     Done,Cleanup,    Begin,Ignore,   Begin,Ignore,   Begin,OpenGraph,
     Begin,OpenGraph, DefMove,Ignore, DefDraw,Ignore, DefColor,Ignore,
     Error,RptErr,    Begin,Ignore,   Begin,Ignore,
     
     Done,Cleanup,    Done,Cleanup,   Done,Cleanup,   Error,RptErr,
     Error,RptErr,    Error,RptErr,   Error,RptErr,   Error,RptErr,
     Done,Cleanup,    Done,Cleanup,   Done,Cleanup
@{FG SHINE}
   NOTICE that the last action is not terminated by a comma! (FSMGenPPC will still work
   correctly even if you forget to edit it out of the final string)@{FG TEXT}
    
   @{" Are we done yet? " LINK "Almost"}

@ENDNODE

@NODE "Almost" "Getting to the finish line:"     
@TOC "Contents"
@{FG SHINE}
                        Will this ever stop?? @{FG TEXT}

   After all NextState,Actions are entered into the list gadget, we are ready to
   enter the prologue & code sections of the Example state machine.  Press the
   @{B}E@{U}x@{UU}ternal Editor@{UB} Gadget & wait for your @{" editor " LINK "ToolTypes"} to start.  Enter the
   following:
@{FG SHINE}
   #include <stdio.h>
   #include <string.h>
   #include <exec/types.h>
   #include <intuition/intuitionbase.h>

   void Ignore( void );  // Your compiler will complain if these are not here!
   void RptErr( void );
   void StowNum( void );
   void DrawFunc( void );
   void MoveFunc( void );
   void OpenGraph( void );
   void ChgColor( void );
   void Cleanup( void ); @{FG TEXT}

   I recommend that you save this part of the code as "yourProgram.preamble"
   so that you can figure out later what file to edit in order to correct
   any typos you might have made.  (All of this is present in Example.preamble).
   
   @{" Now for the last bits... " LINK "ActionCode"}

@ENDNODE

@NODE "ActionCode" "The code what does all of the work:"
@TOC "Contents"
@{FG SHINE}
             At last!  The light at the end of the tunnel... @{FG TEXT}
		
   Finally, we are ready for the Source Code functions.  Press the @{B}E@{U}x@{UU}ternal Editor@{UB} 
   or @{B}Internal @{U}E@{UU}ditor@{UB} button.  
   Enter the following C source code into your editor:
@{FG SHINE}
   extern char *idstr;   // defined in the scanner

   int linecount = 0;    // used for error reporting

   void Ignore( void ) 
   { 
      if (idstr[0] == '\n')
         linecount++;

      return; 
   }

   void RptErr( void )
   {
      fprintf( stderr, "ERROR in input stream!\n" );
      fprintf( stderr, "Found on line %d\n", linecount );

      return;
   }

   struct NewScreen ns = {

      0, 0, 640, 200, 4, 0xFF, 0xFF, HIRES, CUSTOMSCREEN,
      NULL, (UBYTE *) "StateMachine Example:", NULL, NULL
   };

   struct NewWindow nw = {

      0, 0, 640, 200, 0xFF, 0xFF, CLOSEWINDOW,
      WINDOWCLOSE | ACTIVATE | SMART_REFRESH,
      NULL, NULL, (UBYTE *) "StateMachine Example:",
      NULL, NULL, 20, 20, 640, 200, CUSTOMSCREEN
   };

   struct IntuitionBase *IntuitionBase;
   struct GfxBase       *GfxBase;

   struct Window *example_window = NULL;
   struct Screen *example_screen = NULL;

   void OpenGraph( void ) 
   {
      if (strcmp( idstr, "LORES" ) == 0)
         {
         ns.ViewModes = 0;
         ns.Depth     = 5;
         ns.Width     = 320;
         ns.Height    = 200;
         nw.Width     = 320;  // Make window LoRes also!
         nw.Height    = 200;
         nw.MaxWidth  = 320;
         nw.MaxHeight = 200;
         }
  
      if (!(IntuitionBase = (struct IntuitionBase *)
                             OpenLibrary( "intuition.library", 0L )))
         return;

      if (!(GfxBase = (struct GfxBase *)
                       OpenLibrary( "graphics.library", 0L )))
         {
         CloseLibrary( IntuitionBase );
         return;
         }

      if (!(example_screen = (struct Screen *) OpenScreen( &ns )))
         {
         CloseLibrary( GfxBase );
         CloseLibrary( IntuitionBase );
         return;
         }

      nw.Screen = example_screen;

      if (!(example_window = (struct Window *) OpenWindow( &nw )))
         {
         CloseScreen( example_screen );
         CloseLibrary( GfxBase );
         CloseLibrary( IntuitionBase );

         return;
         }

      return;
   }

   int nums[5] = { -1, -1, -1, -1, 0 };

   void StowNum( void )  // store numbers for DrawFunc, MoveFunc & ChgColor
   {
      extern int atoi( char * );

      int index = 0;

      while (nums[index] >= 0)
        index++;

      nums[index] = atoi( idstr );

      return;
   }

   void DrawFunc( void )
   {
      if (example_window) // != NULL)
         Draw( example_window->RPort, nums[0], nums[1] );

      nums[0] = nums[1] = -1;

      return;
   }

   void MoveFunc( void )
   {
      if (example_window) // != NULL)
         Move( example_window->RPort, nums[0], nums[1] );

      nums[0] = nums[1] = -1;

      return;
   }

   void ChgColor( void ) 
   {
      if (example_window) // != NULL)
         {
         SetRGB4( &(example_screen->ViewPort, nums[0], nums[1], nums[2], nums[3] );

         SetAPen( example_window->RPort, nums[0] );
         }

      nums[0] = nums[1] = nums[2] = nums[3] = -1;

      return;
   }

   #ifndef   TRUE
   # define  TRUE  1
   # define  FALSE 0
   #endif

   void Cleanup( void )
   {
      int                 Checking = TRUE;
      ULONG               clazz    = 0;
      struct IntuiMessage *message = NULL;
      char                nil[256], *title = &nil[0];
   
      if (!example_window) // == NULL)
         goto SkipLoop;

      strcpy( title, nw.Title );
      strcat( title, " Click on close window gadget to EXIT!" );

      SetWindowTitles( example_window, title, NULL );
   
      while (Checking == TRUE)
         {
         if (!(message = (struct IntuiMessage *) 
                          GetMsg( example_window->UserPort )))
            {
            (void) Wait( 1L << example_window->UserPort->mp_SigBit );

            continue;
            }

         clazz = message->Class;
         (void) ReplyMsg( message );

         switch( clazz )
            {
            case CLOSEWINDOW:
               Checking = FALSE;
               break;

            default:
               break;
            }
         }
      
   SkipLoop:

      if (example_window)
         CloseWindow( example_window );
      
      if (example_screen)
         CloseScreen( example_screen );
      
      if (GfxBase)
         CloseLibrary( (struct Library *) GfxBase );

      if (IntuitionBase)
         CloseLibrary( (struct Library *) IntuitionBase );

      return;
   } @{FG TEXT}

   I recommend that you call this part of the code "yourProgram.code" in order to keep
   them straight in that head thing of yours! (All of this code is present in Example.code).
   
   Now, return to the GUI after saving your code & exiting your @{" editor " LINK "ToolTypes"}.
   Select @{B}Save As@{UB} from the Project menu and save your new state machine source 
   code.  Finally, select @{B}Generate Source!@{UB} from the Project menu.  This will 
   turn your definition file into C-source code that can be compiled into an
   executable program, once it is linked with the scanner.  That's all there is
   to producing state machines!

@ENDNODE

@NODE "ToolTypes" "StateMachinePPC ToolTypes (in the Icon):"
@TOC "Contents"
@{FG SHINE}
                   Where's those Pliers?? @{FG TEXT}
@{FG SHINE}
   ToolType:             Default Value:
   ~~~~~~~~~             ~~~~~~~~~~~~~~ @{FG TEXT}
   DEFAULTTABSIZE          3 - NOT Currently used
   SYMBOLTABLESIZE       300 - NOT Currently used
   STATETABLESIZE        300 - NOT Currently used
   ACTIONTABLESIZE       300 - NOT Currently used
   NEXTSTATETABLESIZE    900 - NOT Currently used


   TOOLTYPESEDITOR       StateMachine:ToolTypesEditorPPC
   COMMANDPATH           StateMachine:
   HELPPATH              StateMachine:
   HELPPROGRAM           Sys:Utilities/MultiView 
   GENERATORPROGRAM      StateMachine:FSMGenPPC
   EDITOR                C:Ed

   The only ones you might want to change are: @{FG SHINE}
   HelpProgram & Editor. @{FG TEXT}

@ENDNODE

@NODE "Distribution" "The total StateMachinePPC Package:"
@TOC "Contents"
@{FG SHINE} 
              Evenly spread over your hard disk... @{FG TEXT}
@{FG SHINE}
   The files included with StateMachinePPC are as follows: @{FG TEXT}

      StateMachinePPC - The executable program.
      StateMachinePPC.info - The program Icon (See @{" ToolTypes " LINK "ToolTypes"}).

      FSMGenPPC - The Finite State Machine generator program.
                  It can be placed in any directory you wish as long as 
		  the PATH is set accordingly.

      StateMachine.guide - Description of what StateMachinePPC does, along with a tutorial.

      Example.ini      - a tutorial state machine project file.
      Example.preamble - a tutorial state machine preamble file.
      Example.code     - a tutorial state machine code file.
      
      Example.fsm  - a tutorial state machine definition file.

      Example.c    - the output of FSMGenPPC when Example.fsm is supplied.

      Example.flex - a tutorial state machine scanner definition file.

      ExampleLex.c - the output of FLeX when Example.flex is supplied.

      ToolTypesEditor       - An Icon ToolTypes Editor program.   

      ToolTypesEditor.guide - The documentation for ToolTypesEditor program.   

@{FG SHINE}   
   It is interesting to note that FSMGenPPC is itself a finite state machine.  It
   was generated from a more primitive version of itself! @{FG TEXT}

@ENDNODE

@NODE "Bibliography" "Further Finite State Machine information:"
@TOC "Contents"
@{FG SHINE}
                   So... these are the culprits!! @{FG TEXT}
		
   StateMachinePPC was inspired by a couple of articles in the 'C User's Journal'
   entitled: 

      'Building a Finite State Machine' by R. Ward,
       C User's Journal, February 1989, pgs. 94-99.

      'A Finite State Machine Generator' by R. Ward,
       C User's Journal, April 1989, pgs. 101-107.

   Unfortunately, the code in the articles didn't work, and since it was 
   intended to be portable, it certainly didn't make use of the Amiga's
   graphical user interface capabilities.  My rewrite of the code from these
   articles corrects both of these deficiencies.  FSMGenPPC, which is based on 
   these articles, was created from a crude working version of the articles' 
   code and a more complex lexical analyzer (the scanner).
 
   FSMGenPPC uses a unique syntax of its own for the input definition file, which 
   actually generates the C source code, which is subsequently
   compiled by you, the user.  You don't have to remember what this syntax is,
   since StateMachinePPC generates the definition file for you.  The syntax is 
   similar to what LeX & YACC use for their definition files.

   LeX  - Lexical analyzer-generator program, a UNIX programming tool.
          There is a public-domain program called Flex, available on Fred Fish
          disk #407 that works real well (be sure that the source code skeleton
          files don't get mixed up with the skeleton files that have to be 
          included in your lexical analyzer, the file names are similar!).
        
   YACC - Yet Another Compiler Compiler, a UNIX programming tool.
          There is a public-domain program called Bison, available on a Fred 
          Fish disk also, that does the same thing as YACC.

@ENDNODE

@NODE "Author" "Author Information (What a hoopy guy!):"
@TOC "Contents"
@PREV main
@{FG SHINE}
            A Bystander certainly, but far from innocent! @{FG TEXT}
    
  If your conscience is bugging you to contribute some cash for my
  programming efforts, please send $15 or more for the program to:
  
  The Author:
  
  James T. Steichen    @{FG SHINE}(A real cool frood!)@{FG TEXT}
  2217 N. Tamarack Dr. 
  Slayton, Mn. 56172-1155 (USA)

  email: @{FG SHINE} jimbot\@frontiernet.net @{FG TEXT} (best place to send bug reports)

  StateMachinePPC was written originally written as a CanDo deck Program.  I had to
  convert it to C since CanDo is longer available, (worse, it does not run under
  AmigaOS4!).  StateMachinePPC was compiled with gcc V2.95.3 on my AmigaOne,
  running AmigaOS4.0.  It can also compile with the SAS C compiler V6.58.

@ENDNODE
