@database RE2C
@master "RE2C.1"
@remark "manual page source format generated by PolyglotMan v3.2 available at http://polyglotman.sourceforge.net/"
@wordwrap
@tab 8

@node sect0 "Name"
re2c - convert regular expressions to C/C++  
@endnode

@node sect1 "Synopsis"
 [@{b}-bdefghisuvVw1@{ub}] [@{b}-o output@{ub}] file  
@endnode

@node sect2 "Description"
 is a preprocessor that generates C-based recognizers from regular expressions. The input to  consists of C/C++ source interleaved with comments of the form /*!re2c ... */ which contain scanner specifications. In the output these comments are replaced with code that, when executed, will find the next input token and then execute some user-supplied token-specific code.  For example, given the following code   
@{code}char *scan(char *p)
{
/*!re2c
        re2c:define:YYCTYPE  = "unsigned char";
        re2c:define:YYCURSOR = p;
        re2c:yyfill:enable   = 0;
        re2c:yych:conversion = 1;
        re2c:indent:top      = 1;
        [0-9]+          {return p;}
        [ 00-377]     {return (char*)0;}
*/
}
@{body}
   -is will generate   
@{code}/* Generated by re2c on Sat Apr 16 11:40:58 1994 */
char *scan(char *p)
{
    {
        unsigned char yych;
        yych = (unsigned char)*p;
        if(yych &lt;= '/') goto yy4;
        if(yych &gt;= ':') goto yy4;
        ++p;
        yych = (unsigned char)*p;
        goto yy7;
yy3:
        {return p;}
yy4:
        ++p;
        yych = (unsigned char)*p;
        {return char*)0;}
yy6:
        ++p;
        yych = (unsigned char)*p;
yy7:
        if(yych &lt;= '/') goto yy3;
        if(yych &lt;= '9') goto yy6;
        goto yy3;
    }
}
@{body}
  You can place one /*!max:re2c */ comment that will output a "#define  YYMAXFILL <n>" line that holds the maximum number of characters  required to parse the input. That is the maximum value YYFILL(n) will receive. If -1 is in effect then YYMAXFILL can only be triggered once after the last /*!re2c */.  You can also use /*!ignore:re2c */ blocks that allows to document the scanner code and will not be part of the output.  
@endnode

@node sect3 "Options"
 provides the following options: 

 @{b}-?@{ub} @{lindent 3}
@{b}-h@{ub} Invoke a short help. @{lindent 0}

 @{b}-b@{ub} @{lindent 3}
Implies @{b}-s@{ub}.  Use bit vectors as well in the attempt to coax better code out of the compiler.  Most useful for specifications with more than a few keywords (e.g. for most programming languages). @{lindent 0}

 @{b}-d@{ub} @{lindent 3}
Creates a parser that dumps information about the current position and in  which state the parser is while parsing the input. This is useful to debug  parser issues and states. If you use this switch you need to define a macro @{i}YYDEBUG@{ui} that is called like a function with two parameters: @{i}void YYDEBUG(int state, char current)@{ui}. The first parameter receives the  state or -1 and the second parameter receives the input at the current cursor. @{lindent 0}

 @{b}-e@{ub} @{lindent 3}
Cross-compile from an ASCII platform to an EBCDIC one.  @{lindent 0}

 @{b}-f@{ub} @{lindent 3}
Generate a scanner with support for storable state. For details see below at @{b}SCANNER WITH STORABLE STATES@{ub}. @{lindent 0}

 @{b}-g@{ub} @{lindent 3}
Generate a scanner that utilizes GCC's computed goto feature. That is  generates jump tables whenever a decision is of a certain complexity (e.g. a  lot of if conditions are otherwise necessary). This is only useable with GCC  and produces output that cannot be compiled with any other compiler. Note that this implies -b and that the complexity threshold can be configured using the inplace configuration "cgoto:threshold". @{lindent 0}

 @{b}-i@{ub} @{lindent 3}
Do not output #line information. This is usefull when you want use a CMS tool with the  output which you might want if you do not require your users to  have  themselves when building from your source. @{b}-o output@{ub} Specify the output file. @{lindent 0}

 @{b}-s@{ub} @{lindent 3}
Generate nested ifs for some switches.  Many compilers need this assist to generate better code. @{lindent 0}

 @{b}-u@{ub} @{lindent 3}
Generate a parser that supports Unicode chars (UTF-32). This means the  generated code can deal with any valid Unicode character up to 0x10FFFF. When UTF-8 or UTF-16 needs to be supported you need to convert the incoming stream to UTF-32 upon input yourself. @{lindent 0}

 @{b}-v@{ub} @{lindent 3}
Show version information. @{lindent 0}

 @{b}-V@{ub} @{lindent 3}
Show the version as a number XXYYZZ. @{lindent 0}

 @{b}-w@{ub} @{lindent 3}
Create a parser that supports wide chars (UCS-2). This implies @{b}-s@{ub} and  cannot be used together with @{b}-e@{ub} switch. @{lindent 0}

 @{b}-1@{ub} @{lindent 3}
Force single pass generation, this cannot be combined with -f and disables  YYMAXFILL generation prior to last  block. @{lindent 0}

 --no-generation-date @{lindent 3}
Suppress date output in the generated output so that it only shows the re2c version. @{lindent 0}


@endnode

@node sect4 "Interface Code"
Unlike other scanner generators,  does not generate complete scanners: the user must supply some interface code. In particular, the user must define the following macros or use the  corresponding inplace configurations: 

 YYCTYPE @{lindent 3}
Type used to hold an input symbol. Usually char or unsigned char. @{lindent 0}

 YYCURSOR @{lindent 3}
 of type *YYCTYPE that points to the current input symbol. The generated code advances YYCURSOR as symbols are matched. On entry, YYCURSOR is assumed to point to the first character of the current token.  On exit, YYCURSOR will point to the first character of the following token. @{lindent 0}

 YYLIMIT @{lindent 3}
Expression of type *YYCTYPE that marks the end of the buffer (YYLIMIT[-1] is the last character in the buffer). The generated code repeatedly compares YYCURSOR to YYLIMIT to determine when the buffer needs (re)filling. @{lindent 0}

 YYMARKER @{lindent 3}
 of type *YYCTYPE. The generated code saves backtracking information in YYMARKER. Some easy scanners might not use this. @{lindent 0}

 YYCTXMARKER @{lindent 3}
 of type *YYCTYPE. The generated code saves trailing context backtracking information in YYCTXMARKER. The user only needs to define this macro if a scanner specification uses trailing context in one or more of its regular expressions. @{lindent 0}

 YYFILL(@{i}n@{ui}) @{lindent 3}
The generated code "calls" YYFILL(n) when the buffer needs (re)filling:  at least @{i}n@{ui} additional characters should be provided.  YYFILL(n) should adjust YYCURSOR, YYLIMIT, YYMARKER and YYCTXMARKER as needed.  Note that for typical  programming languages @{i}n@{ui} will be the length of the longest keyword plus one. The user can place a comment of the form /*!max:re2c */ once to insert  a YYMAXFILL(n) definition that is set to the maximum length value. If -1  switch is used then YYMAXFILL can be triggered only once after the  last /*!re2c */ block. @{lindent 0}

 YYGETSTATE() @{lindent 3}
The user only needs to define this macro if the @{b}-f@{ub} flag was specified. In that case, the generated code "calls" YYGETSTATE() at the very beginning of the scanner in order to obtain the saved state. YYGETSTATE() must return a signed integer. The value must be either -1, indicating that the scanner is entered for the first time, or a value previously saved by YYSETSTATE(s).  In the second case, the scanner will resume operations right after where the last YYFILL(n) was called. @{lindent 0}

 YYSETSTATE(@{i}s@{ui}) @{lindent 3}
The user only needs to define this macro if the @{b}-f@{ub} flag was specified. In that case, the generated code "calls" YYSETSTATE just before calling YYFILL(n).  The parameter to YYSETSTATE is a signed integer that uniquely identifies the specific instance of YYFILL(n) that is about to be called. Should the user wish to save the state of the scanner and have YYFILL(n) return to the caller, all he has to do is store that unique identifer in a variable. Later, when the scannered is called again, it will call YYGETSTATE() and resume execution right where it left off. The generated code will contain  both YYSETSTATE(s) and YYGETSTATE even if YYFILL(n) is being disabled. @{lindent 0}

 YYDEBUG(@{i}state@{ui},@{i}current)@{ui} @{lindent 3}
This is only needed if the @{b}-d@{ub} flag was specified. It allows to easily debug the generated parser by calling a user defined function for every state. The function should have the following signature: @{i}void YYDEBUG(int state, char current)@{ui}.  The first parameter receives the state or -1 and the second parameter receives the  input at the current cursor. @{lindent 0}

 YYMAXFILL @{lindent 3}
This will be automatically defined by /*!max:re2c */ blocks as explained above.  @{lindent 0}


@endnode

@node sect5 "Scanner with Storable States"
When the @{b}-f@{ub} flag is specified,  generates a scanner that can store its current state, return to the caller, and later resume operations exactly where it left off.  The default operation of  is a "pull" model, where the scanner asks for extra input whenever it needs it. However, this mode of operation assumes that the scanner is the "owner" the parsing loop, and that may not always be convenient.  Typically, if there is a preprocessor ahead of the scanner in the stream, or for that matter any other procedural source of data, the scanner cannot "ask" for more data unless both scanner and source live in a separate threads.  The @{b}-f@{ub} flag is useful for just this situation : it lets users design scanners that work in a "push" model, i.e. where data is fed to the scanner chunk by chunk. When the scanner runs out of data to consume, it just stores its state, and return to the caller. When more input data is fed to the scanner, it resumes operations exactly where it left off.  When using the -f option  does not accept stdin because it has to do the  full generation process twice which means it has to read the input twice. That means  would fail in case it cannot open the input twice or reading the input for the first time influences the second read attempt.  Changes needed compared to the "pull" model.  1. User has to supply macros YYSETSTATE() and YYGETSTATE(state)  2. The @{b}-f@{ub} option inhibits declaration of @{i}yych@{ui} and @{i}yyaccept@{ui}. So the user has to declare these. Also the user has to save and restore these. In the example @{i}examples/push.re@{ui} these are declared as fields of the (C++) class of which the scanner is a method, so they do not need to be saved/restored explicitly. For C they could e.g. be made macros that select fields from a structure passed in as parameter. Alternatively, they could be declared as local variables, saved with YYFILL(n) when it decides to return and restored at entry to the function. Also, it could be more efficient to save the state from YYFILL(n) because YYSETSTATE(state) is called unconditionally. YYFILL(n) however does not get @{i}state@{ui} as parameter, so we would have to store state in a local variable by YYSETSTATE(state).  3. Modify YYFILL(n) to return (from the function calling it) if more input is needed.  4. Modify caller to recognise "more input is needed" and respond appropriately.  5. The generated code will contain a switch block that is used to restores  the last state by jumping behind the corrspoding YYFILL(n) call. This code is automatically generated in the epilog of the first "/*!re2c */" block.  It is possible to trigger generation of the YYGETSTATE() block earlier by  placing a "/*!getstate:re2c */" comment. This is especially useful when the scanner code should be wrapped inside a loop.  Please see examples/push.re for push-model scanner. The generated code can be tweaked using inplace configurations "@{b}state:abort@{ub}" and "@{b}state:nextlabel@{ub}".  
@endnode

@node sect6 "Scanner Specifications"
Each scanner specification consists of a set of @{i}rules@{ui}, @{i}named definitions@{ui} and @{i}configurations@{ui}. @{i}Rules@{ui} consist of a regular expression along with a block of C/C++ code that is to be executed when the associated @{i}regular expression@{ui} is matched. 

@{lindent 3}
@{i}regular expression@{ui} { @{i}C/C++ code@{ui} } @{lindent 0}


Named definitions are of the form: 

@{lindent 3}
@{i}name@{ui} = @{i}regular expression@{ui}; @{lindent 0}


Configurations look like named definitions whose names start  with "@{b}re2c:@{ub}": 

@{lindent 3}
re2c:@{i}name@{ui} = @{i}value@{ui}; @{lindent 0}
@{lindent 3}
re2c:@{i}name@{ui} = @{b}"@{ub}@{i}value@{ui}@{b}"@{ub}; @{lindent 0}
 


@endnode

@node sect7 "Summary of Re2c Regular Expressions"


 "foo" @{lindent 3}
the literal string foo. ANSI-C escape sequences can be used. @{lindent 0}

 'foo' @{lindent 3}
the literal string foo (characters [a-zA-Z] treated case-insensitive). ANSI-C escape sequences can be used. @{lindent 0}

 [xyz] @{lindent 3}
a "character class"; in this case, the  matches either an 'x', a 'y', or a 'z'. @{lindent 0}

 [abj-oZ] @{lindent 3}
a "character class" with a range in it; matches an 'a', a 'b', any letter from 'j' through 'o', or a 'Z'. @{lindent 0}

 [^@{i}class@{ui}] @{lindent 3}
an inverted "character class". @{lindent 0}

 @{i}r@{ui}\@{i}s@{ui} @{lindent 3}
match any @{i}r@{ui} which isn't an @{i}s@{ui}. @{i}r@{ui} and @{i}s@{ui} must be regular expressions which can be expressed as character classes. @{lindent 0}

 @{i}r@{ui}* @{lindent 3}
zero or more @{i}r@{ui}'s, where @{i}r@{ui} is any regular expression @{lindent 0}

 @{i}r@{ui}+ @{lindent 3}
one or more @{i}r@{ui}'s @{lindent 0}

 @{i}r@{ui}? @{lindent 3}
zero or one @{i}r@{ui}'s (that is, "an optional @{i}r@{ui}") @{lindent 0}

 name @{lindent 3}
the expansion of the "named definition" (see above) @{lindent 0}

 (@{i}r@{ui}) @{lindent 3}
an @{i}r@{ui}; parentheses are used to override precedence (see below) @{lindent 0}

 @{i}rs@{ui} @{lindent 3}
an @{i}r@{ui} followed by an @{i}s@{ui} ("concatenation") @{lindent 0}

 @{i}r@{ui}|@{i}s@{ui} @{lindent 3}
either an @{i}r@{ui} or an @{i}s@{ui} @{lindent 0}

 @{i}r@{ui}/@{i}s@{ui} @{lindent 3}
an @{i}r@{ui} but only if it is followed by an @{i}s@{ui}. The @{i}s@{ui} is not part of the matched text. This type of  is called "trailing context". A trailing context can only be the end of a rule and not part of a named definition. @{lindent 0}

 @{i}r@{ui}{@{i}n@{ui}} @{lindent 3}
matches @{i}r@{ui} exactly @{i}n@{ui} times. @{lindent 0}

 @{i}r@{ui}{@{i}n@{ui},} @{lindent 3}
matches @{i}r@{ui} at least @{i}n@{ui} times. @{lindent 0}

 @{i}r@{ui}{@{i}n@{ui},@{i}m@{ui}} @{lindent 3}
matches @{i}r@{ui} at least @{i}n@{ui} but not more than @{i}m@{ui} times. @{lindent 0}

 . @{lindent 3}
match any character except newline (\n). @{lindent 0}

 @{i}def@{ui} @{lindent 3}
matches named definition as specified by @{i}def@{ui}. @{lindent 0}

Character classes and string literals may contain octoal or hexadecimal  character definitions and the following set of escape sequences (@{b}\n@{ub},  @{b}\t@{ub}, @{b}\v@{ub}, @{b}\b@{ub}, @{b}\r@{ub}, @{b}\f@{ub}, @{b}\a@{ub}, @{b}\\@{ub}).
 An octal character is defined by a backslash followed by its three octal digits and a hexadecimal character is defined by backslash, a lower cased '@{b}x@{ub}'  and its two hexadecimal digits or a backslash, an upper cased @{b}X@{ub} and its  four hexadecimal digits. 

 further more supports the c/c++ unicode notation. That is a backslash followed by either a lowercased @{b}u@{ub} and its four hexadecimal digits or an uppercased  @{b}U@{ub} and its eight hexadecimal digits. However only in @{b}-u@{ub} mode the generated code can deal with any valid Unicode character up to 0x10FFFF. 

Since characters greater @{b}\X00FF@{ub} are not allowed in non unicode mode, the  only portable "@{b}any@{ub}" rules are @{b}(.|"\n")@{ub} and @{b}[^]@{ub}. 

The regular expressions listed above are grouped according to precedence, from highest precedence at the top to lowest at the bottom. Those grouped together have equal precedence.  


@endnode

@node sect8 "Inplace Configuration"
It is possible to configure code generation inside  blocks. The following lists the available configurations: 



 @{i}re2c:indent:top@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
Specifies the minimum number of indendation to use. Requires a numeric value  greater than or equal zero. @{lindent 0}

 @{i}re2c:indent:string@{ui} @{b}=@{ub} "\t" @{b};@{ub} @{lindent 3}
Specifies the string to use for indendation. Requires a string that should  contain only whitespace unless you need this for external tools. The easiest  way to specify spaces is to enclude them in single or double quotes. If you do  not want any indendation at all you can simply set this to @{b}""@{ub}. @{lindent 0}

 @{i}re2c:yybm:hex@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
If set to zero then a decimal table is being used else a hexadecimal table  will be generated. @{lindent 0}

 @{i}re2c:yyfill:enable@{ui} @{b}=@{ub} 1 @{b};@{ub} @{lindent 3}
Set this to zero to suppress generation of YYFILL(n). When using this be sure to verify that the generated scanner does not read behind input. Allowing this behavior might introduce sever security issues to you programs. @{lindent 0}

 @{i}re2c:yyfill:parameter@{ui} @{b}=@{ub} 1 @{b};@{ub} @{lindent 3}
Allows to suppress parameter passing to @{b}YYFILL@{ub} calls. If set to zero  then no parameter is passed to @{b}YYFILL@{ub}. If set to a non zero value then @{b}YYFILL@{ub} usage will be followed by the number of requested characters in braces. @{lindent 0}

 @{i}re2c:startlabel@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
If set to a non zero integer then the start label of the next scanner blocks  will be generated even if not used by the scanner itself. Otherwise the normal  @{b}yy0@{ub} like start label is only being generated if needed. If set to a text  value then a label with that text will be generated regardless of whether the  normal start label is being used or not. This setting is being reset to @{b}0@{ub} after a start label has been generated. @{lindent 0}

 @{i}re2c:labelprefix@{ui} @{b}=@{ub} yy @{b};@{ub} @{lindent 3}
Allows to change the prefix of numbered labels. The default is @{b}yy@{ub} and can be set any string that is a valid label. @{lindent 0}

 @{i}re2c:state:abort@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
When not zero and switch -f is active then the YYGETSTATE block will  contain a default case that aborts and a -1 case is used for initialization. @{lindent 0}

 @{i}re2c:state:nextlabel@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
Used when -f is active to control whether the YYGETSTATE block is  followed by a yyNext: label line. Instead of using yyNext you can  usually also use configuration @{i}startlabel@{ui} to force a specific start label or default to yy0 as start label. Instead of using a dedicated label it  is often better to separate the YYGETSTATE code from the actual scanner code by placing a "/*!getstate:re2c */" comment. @{lindent 0}

 @{i}re2c:cgoto:threshold@{ui} @{b}=@{ub} 9 @{b};@{ub} @{lindent 3}
When -g is active this value specifies the complexity threshold that triggers generation of jump tables rather than using nested if's and decision bitfields. The threshold is compared against a calculated estimation of if-s needed where  every used bitmap divides the threshold by 2. @{lindent 0}

 @{i}re2c:yych:conversion@{ui} @{b}=@{ub} 0 @{b};@{ub} @{lindent 3}
When the input uses signed characters and @{b}-s@{ub} or @{b}-b@{ub} switches are  in effect re2c allows to automatically convert to the unsigned character type  that is then necessary for its internal single character. When this setting  is zero or an empty string the conversion is disabled. Using a non zero number the conversion is taken from @{b}YYCTYPE@{ub}. If that is given by an inplace  configuration that value is being used. Otherwise it will be @{b}(YYCTYPE)@{ub}  and changes to that configuration are  no longer possible. When this setting is a string the braces must be specified. Now assuming your input is a @{b}char*@{ub} buffer and you are using above mentioned switches you can set @{b}YYCTYPE@{ub} to @{b}unsigned char@{ub} and this setting to either @{b}1@{ub} or @{b}"(unsigned char)"@{ub}. @{lindent 0}

 @{i}re2c:define:YYCTXMARKER@{ui} @{b}=@{ub} YYCTXMARKER @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYCTXMARKER and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYCTYPE@{ui} @{b}=@{ub} YYCTYPE @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYCTYPE and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYCURSOR@{ui} @{b}=@{ub} YYCURSOR @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYCURSOR and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYDEBUG@{ui} @{b}=@{ub} YYDEBUG @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYDEBUG and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYFILL@{ui} @{b}=@{ub} YYFILL @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYFILL and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYGETSTATE@{ui} @{b}=@{ub} YYGETSTATE @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYGETSTATE and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYLIMIT@{ui} @{b}=@{ub} YYLIMIT @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYLIMIT and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYMARKER@{ui} @{b}=@{ub} YYMARKER @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYMARKER and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:define:YYSETSTATE@{ui} @{b}=@{ub} YYSETSTATE @{b};@{ub} @{lindent 3}
Allows to overwrite the define YYSETSTATE and thus avoiding it by setting the value to the actual code needed. @{lindent 0}

 @{i}re2c:label:yyFillLabel@{ui} @{b}=@{ub} yyFillLabel @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the label yyFillLabel. @{lindent 0}

 @{i}re2c:label:yyNext@{ui} @{b}=@{ub} yyNext @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the label yyNext. @{lindent 0}

 @{i}re2c:variable:yyaccept@{ui} @{b}=@{ub} yyaccept @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the variable yyaccept. @{lindent 0}

 @{i}re2c:variable:yybm@{ui} @{b}=@{ub} yybm @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the variable yybm. @{lindent 0}

 @{i}re2c:variable:yych@{ui} @{b}=@{ub} yych @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the variable yych. @{lindent 0}

 @{i}re2c:variable:yytarget@{ui} @{b}=@{ub} yytarget @{b};@{ub} @{lindent 3}
Allows to overwrite the name of the variable yytarget.  @{lindent 0}


@endnode

@node sect9 "Understanding Re2c"
The subdirectory lessons of the  distribution contains a few step by step lessons to get you started with . All examples in the lessons subdirectory can be compiled and actually work.  


@endnode

@node sect10 "Features"
 does not provide a default action: the generated code assumes that the input will consist of a sequence of tokens. Typically this can be dealt with by adding a rule such as the one for unexpected characters in the example above. 

The user must arrange for a sentinel token to appear at the end of input (and provide a rule for matching it):  does not provide an <<EOF>> expression. If the source is from a null-byte terminated string, a rule matching a null character will suffice.  If the source is from a file then you could pad the input with a newline (or some other character that  cannot appear within another token); upon recognizing such a character check  to see if it is the sentinel and act accordingly. And you can also use YYFILL(n) to end the scanner in case not enough characters are available which is nothing else then e detection of end of data/file. 

 does not provide start conditions:  use a separate scanner specification for each start condition (as illustrated in the above example).  


@endnode

@node sect11 "Bugs"
Difference only works for character sets. 

The  internal algorithms need documentation.  


@endnode

@node sect12 "See Also"
flex(1), lex(1). 

More information on  can be found here:  

@{b}http://re2c.org/@{ub}   


@endnode

@node sect13 "Authors"
 Peter Bumbulis <peter@csg.uwaterloo.ca> 

Brian Young <bayoung@acm.org> 

Dan Nuffer <nuffer@users.sourceforge.net> 

Marcus Boerger <helly@users.sourceforge.net> 

Hartmut Kaiser <hkaiser@users.sourceforge.net> 

Emmanuel Mogenet <mgix@mgix.com> added storable state 

  


@endnode

@node sect14 "Version Information"
This manpage describes , version 0.12.3.  @{body}
@endnode
@node main "RE2C(1)"
@next sect0
@{b}Table of Contents@{ub}

@{"Name" link sect0}
@{"Synopsis" link sect1}
@{"Description" link sect2}
@{"Options" link sect3}
@{"Interface Code" link sect4}
@{"Scanner with Storable States" link sect5}
@{"Scanner Specifications" link sect6}
@{"Summary of Re2c Regular Expressions" link sect7}
@{"Inplace Configuration" link sect8}
@{"Understanding Re2c" link sect9}
@{"Features" link sect10}
@{"Bugs" link sect11}
@{"See Also" link sect12}
@{"Authors" link sect13}
@{"Version Information" link sect14}

@endnode
