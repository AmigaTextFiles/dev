@DATABASE "DBaseManager.guide"
@$VER: DBaseManager 1.0 (01/15/99) (c) by J.T. Steichen

@REMARK CopyRight (c) 1999 by J.T. Steichen

@WIDTH 80
@WORDWRAP
@INDEX Main

@NODE Main "DBaseManager Documentation:"

   This AmigaGuide file represents the documentation for an ARexx interface
   to the DBase III Library of functions written by Lattice (DBC III 
   Library, @{B}no longer supported@{UB}).
   
   General Notes Regarding the ARexx Interface to DBase III Library
   Function Host:

   All functions that return something usually return it to ARexx in the 
   @{I}Result@{UI} variable.  For multi-valued returns, the most meaningful piece
   of data is returned in @{I}Result@{UI} & other functions allow the rest of the
   info to be found.

   The Port name for this program is @{B}DBase_Rexx@{UB}.
   
   There should be a sample ARexx script titled @{I}TextDBase.rexx@{UI} that came
   with your program distribution.  It's not a complete example, but it
   will give you some idea of how to use this program.
   
   @{" Example ARexx Program " LINK "ExampleScript"}
   @{" DataBase Environment  " LINK "DataBaseEnv"}
   @{" Recognized Commands   " LINK "CommandNotes"}

@ENDNODE

@NODE ExampleScript "Example ARexx Usage:"
@{FG SHINE}
   Rough Outline of a DBase ARexx script: @{FG TEXT}

    ADDRESS "DBase_Rexx" /* The DBaseManager port name! */

    recaddr    = GetSpace( recsize )
    memoaddr   = GetSpace( memosize )
    userfaddr  = GetSpace( nfields * 14 ) /* each dBFIELD is 14 bytes */
    r          = c2x( recaddr )
    m          = c2x( memoaddr )
    u          = c2x( userfaddr )

    'ClearMemory '||u||' nfields * 14'
    'ClearMemory '||r||' recsize'
    'ClearMemory '||m||' memosize'
    'SetupField '||u||' name1 type1 width1 decimal1'
    'SetupField '||u||' name2 type2 width2 decimal2'
    'InitEnv myenv '||r||' '||m||' '||u||' nfields recsize memosize'
    'DefineFileName myenv DBFfilename'
    'DefineFileName myenv NDXfilename'
    'DefineFileName myenv DBTfilename'
    'ChooseEnv myenv'
    'CreateDataFile DBFfilename'
    if Results > 0 then say "Result was "||'TranslateErrorNumber '||Results
    'OpenDataFile'
    'GetRecord 123'
    'OutputRecord'   /* the one that GetRecord just loaded into the
                     ** Current Record Buffer! */

    /* Do some modifications, if desired. */
    'PutRecord 123'
    'CloseDataFile'
    'PurgeEnv myenv'
    'QuitDBase'
    FreeSpace( userfaddr, nfields * 14 )
    FreeSpace( memoaddr, memosize )
    FreeSpace( recaddr, recsize )

@ENDNODE

@NODE DataBaseEnv "DataBase Program environmental structure:"
@{FG SHINE}
   The environment that the interface sets up for each group of 
   open database files is: @{FG TEXT}

#define FNAME_LEN   34
#define NUM_FILES   14 // 1 datafile, 10 indexfiles (max) & 3 memofiles

   struct DBenv   {

   char      *CurrentRecordBuff;   /* User must allocate space & set up */
   char      *MemoBuffer;          /* User must allocate space & set up */
   dBFIELD   *UserFields;          /* Supplied by user. */
   int       UserNumFields;        /* Supplied by user. */
   int       USER_RECORD_SIZE;     /* Supplied by user. */
   int       USER_MEMO_SIZE;       /* Supplied by user. */
   char      EnvName[ MAXNAME_LEN ];
   RECNUM    CurrentRecNum;
   char      CurrentStatus;

   /* Those commands that require a file descriptor pointer translate the
   ** filename the user sees into a file descriptor.
   */
   char      FNameBuff[ FNAME_LEN * NUM_FILES ];
   char      *FDescriptor[ NUM_FILES ];   /* NOT visible to user. */
   char      Arguments[ ARG_SIZE * MAX_ARGS ];

   };

@{B}
   The parts that the user supplies means that the user has to have a C
   compiler in order to use this DBase interface.  They must create the
   UserFields *dBFIELD structure & allocate the CurrentRecordBuff & 
   MemoBuff areas, since this interface should be flexible. @{UB}

@ENDNODE

@NODE CommandNotes "Notes on Recognized commands:"

   All of the DBC III Library C functions were translated into code that
   can be used by ARexx as a function host.
   
   When not indicated, a command returns only an error code or zero.

   @{FG SHINE}Commands that interface the environment:@{FG TEXT}

   @{" ClearMemory    " LINK "ClearMemory"}
   @{" SetupField     " LINK "SetupField"}
   @{" InitEnv        " LINK "InitEnv"}
   @{" DefineFileName " LINK "DefineFileName"}
   @{" PurgeEnv       " LINK "PurgeEnv"}
   @{" ChoosEnv       " LINK "ChooseEnv"}
   @{" ReadField      " LINK "ReadField"}
   @{" WriteField     " LINK "WriteField"}
   @{" ReadMemo       " LINK "ReadMemo"}
   @{" WriteMemo      " LINK "WriteMemo"}
   @{" QuitDBase      " LINK "QuitDBase"}
   @{" OutputRecord   " LINK "OutputRecord"}

   @{" TranslateErrorNumber " LINK "TranslateErrorNumber"}

   @{FG SHINE}DataFile DBase commands: @{FG TEXT}

   @{" CreateDataFile  " LINK "CreateDataFile"}
   @{" OpenDataFile    " LINK "OpenDataFile"}           
   @{" CloseDataFile   " LINK "CloseDataFile"}               
   @{" GetRecord       " LINK "GetRecord"}
   @{" PutRecord       " LINK "PutRecord"}
   @{" GetNextRecord   " LINK "GetNextRecord"}
   @{" GetPrevRecord   " LINK "GetPrevRecord"}
   @{" DeleteRecord    " LINK "DeleteRecord"}
   @{" RecallRecord    " LINK "RecallRecord"}
   @{" PurgeRecord     " LINK "PurgeRecord"}
   @{" UpdateRecord    " LINK "UpdateRecord"}
   @{" FlushDataBuffer " LINK "FlushDataBuffer"}
   @{" GetNumOfRecords " LINK "GetNumOfRecords"}

   @{FG SHINE}IndexFile DBase commands: @{FG TEXT}

   @{" CreateIndexFile      " LINK "CreateIndexFile"}
   @{" OpenIndexFile        " LINK "OpenIndexFile"}
   @{" CloseIndexFile       " LINK "CloseIndexFile"}
   @{" ReadCurrentKey       " LINK "ReadCurrentKey"}
   @{" AddKey               " LINK "AddKey"}
   @{" GetKeyedRecord       " LINK "GetKeyedRecord"}
   @{" PutKeyedRecord       " LINK "PutKeyedRecord"}
   @{" AsciiToKey           " LINK "AsciiToKey"}
   @{" KeyToAscii           " LINK "KeyToAscii"}
   @{" GetKeyExpression     " LINK "GetKeyExpression"}
   @{" WindForwardIndexFile " LINK "WindForwardIndexFile"}
   @{" RewindIndexFile      " LINK "RewindIndexFile"}
   @{" ReadNextKey          " LINK "ReadNextKey"}
   @{" ReadPrevKey          " LINK "ReadPrevKey"}
   @{" PurgeKey             " LINK "PurgeKey"}
   @{" TranslateKeyToRecnum " LINK "TranslateKeyToRecnum"}
   @{" FlushIndexBuffer     " LINK "FlushIndexBuffer"}

   @{FG SHINE}MemoFile DBase commands: @{FG TEXT}

   @{" CreateMemoFile " LINK "CreateMemoFile"}
   @{" OpenMemoFile   " LINK "OpenMemoFile"}
   @{" CloseMemoFile  " LINK "CloseMemoFile"}
   @{" GetMemo        " LINK "GetMemo"}
   @{" PutMemo        " LINK "PutMemo"}

   @{FG SHINE}General DBase commands: @{FG TEXT}

   @{" AsciiToField    " LINK "AsciiToField"}
   @{" FieldToAscii    " LINK "FieldToAscii"}
   @{" GetDataFileInfo " LINK "GetDataFileInfo"}
   @{" FormatString    " LINK "FormatString"}

@ENDNODE

@NODE ClearMemory "Clear Memory:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ClearMemory startaddress howmanybytes'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    startaddress - pointer to user-allocated memory that needs to be 
                   cleared.
    howmanybytes - Clear this many bytes of memory.

@ENDNODE

@NODE SetupField "Initialize a record field:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'SetupField userfields name type width decimal'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    userfields - pointer to user-allocated memory that can hold all of
                 the dBFIELD's in a record.
    name       - The name of the field.
    type       - Type of the field (either C, N, L, D, or M).
    width      - Width of the field in bytes (1 to 254).
    decimal    - Number of decimal places.
@ENDNODE

@NODE InitEnv "Initialize an Environment:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'InitEnv envname recordbuff memobuff userfields numfields
             recsize memosize'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    envname    - place supplied info in an environment slot 
                 (MAX_DBASES = 20) & name it 'envname'.
    recordbuff - pointer to user-allocated memory that can hold the
                 largest record in the database.
    memobuff   - pointer to user-allocated memory that represents
                 the maximum size of a memo field 
                 (4096 = DBase III default).
    userfields - pointer to user-defined dBFIELD array.
    numfields  - the number of fields in the user-defined record.
    recsize    - The size of a record in bytes.
    memosize   - The size of a memo in bytes.

@ENDNODE

@NODE DefineFileName "Define a FileName:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'DefineFileName envname filename'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    envname  - select 'envname' environment.
    filename - Add 'filename' to the environment.
@ENDNODE

@NODE PurgeEnv "Purge Environment:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PurgeEnv envname'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    envname - Mark an environment out of service by appending 'PURGED' to
              its name.

@ENDNODE

@NODE ChooseEnv "Set the Current Environment:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ChoosEnv envname'

   @{FG SHINE}PARAMETERS: @{FG TEXT}
   
    envname - Set the Current environment to 'envname'.

@ENDNODE

@NODE TranslateErrorNumber "Translate Error # to Text:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'TranslateErrorNumber errnumber'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    errnumber - Describe the error number.

   @{FG SHINE}RETURNS: @{FG TEXT}
    Return an error description string.

@ENDNODE

@NODE ReadField "Read a Field into the current record:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ReadField fieldname offset size'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    fieldname - which field to read in the current record.
    offset    - where is the start of the field in the current record.
    size      - how large is the field.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A string containing the field.

@ENDNODE

@NODE WriteField "Write a field into current record:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'WriteField name offset size decimal mode contents'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    name     - which field to write to.
    offset   - the start of the field in the current record.
    size     - how large the field is.
    decimal  - where the decimal point in the field is (0 if N/A).
    mode     - L or l for left-adjusted, R or r for right-adjusted.
    contents - what to write into the current record (no spaces!).

@ENDNODE

@NODE Readmemo "Read a Memo from file:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ReadMemo memofile memoname offset'

   @{FG SHINE}PARAMETERS: @{FG TEXT}
   
    memofile - which .DBT file to write to.
    memoname - which field in the file to read.
    offset   - where in the current record to place the results.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the MemoBuffer.

@ENDNODE

@NODE WriteMemo "Write a Memo:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'WriteMemo offset string'

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    offset - where in the MemoBuffer to begin writing.
    string - the string to write into the buffer.

@ENDNODE

@NODE QuitDBase "Exit the DBaseManager program:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'QuitDBase'

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.

@ENDNODE

@NODE OutputRecord "Output a Record"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'OutputRecord'

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the Current Record Buffer.

@ENDNODE

@NODE CreateDataFile "Create a Data file:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CreateDataFile datafilename'

   @{FG SHINE}PARAMETERS: @{FG TEXT}               ==> dBcreat()

    datafilename - Name of the data file to create.     

@ENDNODE

@NODE OpenDataFile "Open a Data file:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'OpenDataFile'           

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.     ==> dBopen()

@ENDNODE

@NODE CloseDataFile "Close the Data file:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CloseDataFile'               

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.     ==> dBclose()

@ENDNODE

@NODE GetRecord "Get a Record (from the file):"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetRecord recnum'

   @{FG SHINE}PARAMETERS: @{FG TEXT}               ==> dBgetr()

    recnum - Number of the record to retrieve (1 to ???) 

@ENDNODE

@NODE PutRecord "Put a Record (into the file):"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PutRecord recnum'
 
   @{FG SHINE}PARAMETERS: @{FG TEXT}               ==> dBputr()

    recnum - Number of the record to write to the file (1 to ???)

@ENDNODE

@NODE GetNextRecord "Get the Next Record:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetNextRecord indexfilename' ==> dBgetnr()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - Name of the index file.
@ENDNODE

@NODE GetPrevRecord "Get Previous Record"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetPrevRecord indexfilename' ==> dBgetpr()

   @{FG SHINE}PARAMETERS: @{FG TEXT}
 
    indexfilename - Name of the index file.
@ENDNODE

@NODE DeleteRecord "DeleteRecord (Mark as deleted):"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'DeleteRecord recnum'         ==> dBdelete()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    recnum - Number of the record to delete (1 to ???)
@ENDNODE

@NODE RecallRecord "RecallRecord (Undelete a record):"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'RecallRecord recnum'         ==> dBrecall()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    recnum - Number of the record to restore to active status (1 to ???)
@ENDNODE

@NODE PurgeRecord "Purge (ERASE!) a Record:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PurgeRecord recnum'          ==> dBrmvr()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    recnum - Number of the record to physically delete (1 to ???).
@ENDNODE

@NODE UpdateRecord "Update Record (in memory)"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'UpdateRecord recnum'         ==> dBupdr()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    recnum - Number of the record to update (now, it's active!).
@ENDNODE

@NODE FlushDataBuffer "FlushDataBuffer "

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'FlushDataBuffer'             ==> dBflush()

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.
@ENDNODE

@NODE GetNumOfRecords "Report the number of records:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetNumOfRecords'         ==> dBsize()

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    The number of records allocated in the .DBF file.
@ENDNODE

@NODE CreateIndexFile "Create an Index file (for sorting):"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CreateIndexFile indexfilename keyexprstring keylen keytype'  

   @{FG SHINE}PARAMETERS: @{FG TEXT}                           ==> dBicreat

    indexfilename - Name of the index file to create.
    keyexprstring - Which field(s) in the records are the keys.
    keylen        - How many characters are in the key (100 max!).
    keytype       - Type of the key (C or N).
@ENDNODE

@NODE OpenIndexFile "Open an Index File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'OpenIndexFile indexfilename'                    ==> dBiopen()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - Which index file to open.
@ENDNODE

@NODE CloseIndexFile "Close an Index File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CloseIndexFile indexfilename'                   ==> dBiclose()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - Which index file to close.
@ENDNODE

@NODE ReadCurrentKey "Read the current key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ReadCurrentKey'                                 ==> dBckey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    A string in the following format:
      "recordnumber, key"

@ENDNODE

@NODE AddKey "Add a Key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'AddKey indexfilename keystring recnum'          ==> dBakey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to add a key to.
    keystring     - The key string to add to the index file.
    recnum        - Which record this added key is associated with.
@ENDNODE

@NODE GetKeyedRecord "Get a record by key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}
 
    'GetKeyedRecord indexfilename keystring'         ==> dBgetrk()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to get the keyed record from.
    keystring     - The key the user is looking for.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    the record status & places the record in the Current Record Buffer.
@ENDNODE

@NODE PutKeyedRecord "Write a record with the key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PutKeyedRecord indexfilename keystring'         ==> dBputrk()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to write the keyed record to.
    keystring     - The key the user is adding to the index file.
@ENDNODE

@NODE AsciiToKey "Convert a string to a key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'AsciiToKey asciistring keystring'               ==> dBatokey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    asciistring - The string to convert to a key.
    keystring   - The resultant key (if initialized as D or d, the key is
                  treated as a DATE type, NUMERIC otherwise). @{FG SHINE}
                  WARNING:  This variable must be at least 8 characters
                  long. @{FG TEXT}

   @{FG SHINE}RETURNS: @{FG TEXT}   
    The resultant key in keystring.

@ENDNODE

@NODE KeyToAscii "Convert a key to text:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'KeyToAscii keystring asciistringptr'  ==> dBkeytoa()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    keystring      - The key to be converted.
    asciistringptr - The first character position is the number of decimal
                     places in a converted ascii string.  Meaningful only
                     if the 2nd character is NOT D or d. @{FG SHINE}
                     WARNING:  Be safe, & allocate 100 characters for
                     this variable. @{FG TEXT}
 
   @{FG SHINE}RETURNS: @{FG TEXT}   
    The resultant asciistring in the asciistringptr.

@ENDNODE

@NODE GetKeyExpression "Return a key expression string:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetKeyExpression indexfilename'       ==> dBkexpr()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to get the key expression from.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    A string in the following format:
    
      "C or N, key expression, key expression length, key length"

@ENDNODE

@NODE WindForwardIndexFile "Move forward in an Index File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'WindForwardIndexFile indexfilename'   ==> dBfwd()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to wind.
@ENDNODE

@NODE RewindIndexFile "Rewind an Index File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'RewindIndexFile indexfilename'        ==> dBrewind()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to rewind.
@ENDNODE

@NODE ReadNextKey "Read the next key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ReadNextKey indexfilename'            ==> dBnkey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to get the key from.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    A string in the following format:
    
      "record number, key"

@ENDNODE

@NODE ReadPrevkey "Read a Previous key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'ReadPrevKey indexfilename'            ==> dBpkey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to get the key from.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    A string in the following format:

      "record number, key"

@ENDNODE

@NODE PurgeKey "Purge a key:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PurgeKey indexfilename keystr recnum' ==> dBrmvkey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to remove the key from.
    keystr        - The user-supplied key.
    recnum        - Record number associated with the key.
@ENDNODE

@NODE TranslateKeyToRecnum "Translate a key to a record number:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'TranslateKeyToRecnum indexfilename keystr'  ==> dBtkey()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file to get the key from.
    keystr        - Which key to translate.

   @{FG SHINE}RETURNS: @{FG TEXT}   
    The record number.

@ENDNODE

@NODE FlushIndexBuffer "Flush Index Buffer:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'FlushIndexBuffer indexfilename'             ==> dBiflsh()
 
   @{FG SHINE}PARAMETERS: @{FG TEXT}

    indexfilename - The index file that needs its I/O buffer flushed.
@ENDNODE

@NODE CreateMemoFile "Create a Memo File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CreateMemoFile memofilename'   ==> dBmcreat()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    memofilename - The memo file to create.
@ENDNODE

@NODE OpenMemoFile "Open a Memo File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'OpenMemoFile memofilename'     ==> dBmopen()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    memofilename - The memo file to open.
@ENDNODE

@NODE CloseMemoFile "Close a Memo File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'CloseMemoFile memofilename'    ==> dBmclose()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    memofilename - The memo file to close.

@ENDNODE

@NODE GetMemo "Get a Memo from File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetMemo memofilename fieldptr'              ==> dBgetm()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    memofilename - Which memo file to read.
    fieldptr     - The character array that represents a memo field.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    The memo in the user-allocated MemoBuff.

@ENDNODE

@NODE PutMemo "Put a Memo into the File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'PutMemo memofilename memobuff' ==> dBputm()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    memofilename - Which memo file to write to.
    memobuff     - The character array that will be written to memo file.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the memo field.

@ENDNODE

@NODE AsciiToField "Convert text into a Field:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'AsciiToField asciistring width decimal'         ==> dBatofld()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    asciistring - Ascii character string to be converted.
    width       - Width of the field. 
    decimal     - Decimal places in the field.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the converted field.

@ENDNODE

@NODE FieldToAscii "Convert a Field to text string:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'FieldToAscii fieldptr width'  ==> dBfldtoa()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    fieldptr - Field that needs to be converted.
    width    - Width of the field. 

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the ascii string.

@ENDNODE

@NODE GetDataFileInfo "Get information on a Data File:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'GetDataFileInfo'                      ==> dBgetf()

   @{FG SHINE}PARAMETERS: @{FG TEXT}      None.

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A string with the following format:
    
      "recordlength, month, day, year, numfields, fieldsptr"

@ENDNODE

@NODE FormatString "Format a String:"

   @{FG SHINE}AREXX USAGE: @{FG TEXT}

    'FormatString adjmode strlen instringptr'     ==> dBstrcpy()

   @{FG SHINE}PARAMETERS: @{FG TEXT}

    adjmode     - L or l => Left-adjusted, R or r => Right-adjusted.
    strlen      - length of formatted string.
    instringptr - String to be formatted..

   @{FG SHINE}RETURNS: @{FG TEXT}  
    A STRPTR to the formatted string.

@ENDNODE
