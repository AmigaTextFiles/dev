; Diese Datei stellt ein Projekt dar. Hier wird auf die
; Programm-Dateien verwiesen, alle Pfade werden hier
; gesetzt. * gilt immer, außer ein Programm übersteuert.
; $1, $2 ... $9 (Variablen für pmm.cfg)
; $$.c=  Pfad für Source, wenn nicht identisch mit PFAD=
;
; Wichtig:
; Hier angegebene Include-Pfade sind nur für den Compiler
; und nicht für den Depend-Scan. Der Scan hat seine Include-
; pfade in der Pmm.UsrIncludes. Aufbau: Pro Zeile ein Include.
; Der Compiler sucht natürlich auch in in den Standard-Compiler-
; includes während der Depend-Scan ALLE Pfade mit den eigenen Dateien
; enthält. Bei Bedarf kommt vielleicht include/libraries mit da rein.
; Aber jedes Compiler-.h-File zu prüfen ist Unsinn. Nach einem Compiler-
; update sollte man ohnehin alles einheitlich neu übersetzen.
; Es ist für den Dependscan nicht nötig programmabhängig zu verwalten.
; Die Config dient mehr dem Ausschluß von Pfaden, nur wäre das wesent-
; lich mehr Arbeit. Der Homepfad der Sourcen ist für Depend immer ent-
; halten. Beim Compilieren wird der Pfad gebraucht, weil er an den
; Preprozessor übergeben werden muß. Pmm könnte das zwar auch alleine
; einsetzen, aber das würde die Möglichkeiten beschränken. Also immer
; -I$I als Include übergeben.
;
; Die Zeilen mit MAKE am Anfang:
; Hier bekommen die Zahlencodes 1%, 2% usw. ihre Zuordnung.
; MAKE=5 bedeutet: Make ohne Zusatz stellt Definition 5 her (ist als
;                  68040 vordefiniert).
; MAKE:xyz=1,2,3   Besagt nichts weiter als das Pmm ... -o xyz die
;                  Definitionen 1, 2 und 3 erstellen soll, so wie
;                  bei Make xyz im Makefile 'xyz:' als Festlegung für
;                  Aufrufparameter steht.
; MAKE:ALL=....    Das ist die Festlegung, welche Definitionen bei
;                  Pmm A, Q, I oder Pmm -o ALL erzeugt werden.
; Diese Einstellungen sind eine Erweiterung zu Pmm.Cfg, aber es geht
; weiter...
;
; Source und sonstige Files:
; $&.c ist source.c     Preprozessor Input  ( .c -> vcpp )
; $&.i ist soirce.i     Preprozessor Output ( .c -> vcpp -> .i )
; $&.a ist source.asm   Compiler Output     ( .i -> vbcc -> .asm )
; $&.s ist source.s     Compiler Output     ( .i -> vbcc -> .s (vsc) -> .asm )
; $&.o ist source.o     Assembler Output    ( .asm -> Assembler -> .o [ -> Linker] )
; $$   ist PROGRAMM     Letzter Output (Programm, Library, Lib etc.)
; vsc ist der Scheduler, siehe Docs für Warp-Version!!!
; Dies alles geschieht automatisch. Für .i, .a, .s und .o werden nur noch die
; Pfade festgelegt. Bei $$ der Name des Programmes INCL. Pfad, wenn gewünscht.
; Falls nicht, wird a.out imaktuellen Verzeichnis benutzt. Siehe $$ unten...
; $L Ergänzung der .Lib/.a-Dateien für den Linker.
;
; Warum dieser Eintrag, ginge doch genauso gut in Pmm.Cfg?
; WEIL Pmm.Cfg nur Dinge enthalten sollte die allgemein gültig sind.
; Diese Projektdatei wird künftig mehrfach angelegt werden können, so
; das Projekte in Sub-Projekte unterteilt werden können, bzw. auch
; mehrere Projekte möglich werden. Dann sollte hier das stehen, was
; für das Projekt vom sonstigen Standard abweicht.
;
:BEGIN *
MAKE=5
MAKE:60=5,6
MAKE:PPC=7,8
MAKE:ALL=1,2,3,4,5,6,7,8
$&.o=obj/$0/
$&.i=T:
$&.a=T:
$&.s=T:
$L=-Bsymbolic Lib:DOSLIB_$0$8 Lib:All$9
7%$L=-Bdynamic Lib:DOSLIB_$0$8 Lib:All$9
:END
;    <- Das END in der vorigen Zeile beendet die Config. AB hier kann
;       wieder ein BEGIN gesetzt werden. $o ist der Name für ein Temp-File
;       das die Lise der Objektfiles für den Linker enthält. Diese wird
;       von Pmm erstellt.
; 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; DEMO-EINTRAG -- KEINE FUNKTION --
; ----------------------------------
; DOSLIB ist ein SPECIAL, der Linker wird übersteuert mit L=PmmLibr!
;        Hier entsteht eine .LIB, gesteuert über den eigenen Libr-Befehl
;        Um Libr wie einen Linker funktionieren zu lassen ist die
;        Steuerung F aufgenommen worden. Diese Version eines Libr könnte
;        auch ohne Probleme z.B. in vc integriert werden. Da hätte nur
;        mal jemand früher drauf kommen müssen (meine erste Version war
;        ein List-Batch wie bei 7% noch zu sehen).
;        Y0 startet einen Stub-Batch der weitere Link-Libs erstellt, wenn
;        dies notwendig ist (siehe Verzeichnis Batch).
;        Bei PPC wird Y1 als Erweiterung von L= eingesetzt, so kommt der
;        Batch zur Ausführung und das .a-File für PPC wird gebildet.

; ACHTUNG! Zur Verdeutlichung einer weiteren Funktion folgt in diesem Teil
;          ein NOMAKE=2,3,8 (keine 68010, 68020 und WarpOS-Versionen
;          herstellen). Sinnvoll immer dann, wenn in Einzelfällen ein Teil
;          im Make unmöglich oder nicht sinnvoll ist. Z.B. ein Utility für
;          PPC-Prozessoren würde die 68k-Aufrufe sinnlos machen.

:BEGIN DOSLIB
PFAD=Proj:DOSLIB
NOMAKE=2,3,8
$5=$6 -I$I
$$=Lib:DOSLIB_$0$8
L=PmmLibr F Lib:DosLib_$0 $o
7%L=List Proj:DOSLIB/obj/ppc/#?.o lformat="ppc-amigaos-ar q Lib:DOSLIB_$0$8 %s%s" >Ram:LibList
5%X5=Execute Pmm:Batch/ManProto.s Proj:DOSLIB Include:DOSLIB_protos.h
Y0=Execute Pmm:Batch/MakeStubAll.s
7%Y1=Execute Ram:LibList
:END
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Als Demo habe ich das zum vbcc-Compiler gehörende Programm vc gewählt
; PFAD=    Wo liegen die Sourcen?
; $9=      Variable, wird in Pmm.Cfg eingefügt, vc muß mit -DAMIGA übersetzt werden
; $$=      Executable (hier gleich 8 unterschiedliche, aufgeteilt in eigene Verzeich-
;          nissse in denen auch die .o-Files gelagert werden). Mag etwas übertrieben
;          aussehen, aber bei 100 .c-Files kämen 800 .o-Files raus. Wer's nicht, oder
;          anders möchte kann sich das ja umstellen.
; $L       Link-Lib, Erweiterung zum Standard, hier auskommentiert, vc braucht meine
;          persönlichen Files nicht. Das muß auch jede Nutzer selber einrichten.
; $o       Obj-Liste für den Linker (Temp-File)
; X0       Aufruf Programmes VOR dem Make z.b. Versionsdumper
; Y0       Copy der 68040-Version ins vbcc-bin-Verzeichnis (zur Sicherheit aber
;          unter anderem Namen). Und, als Demo, 4 der maximal 8 Versionen werden
;          kopiert.
;
:BEGIN vc
PFAD=vbcc://frontend
$9=-DAMIGA
$$=obj/$0/vc
;
;     Die folgenden Zeilen definieren .Lib's für den Linker.
;     Sie sind jetzt auskommentiert, da das eigene Lib's sind und vc
;     braucht sie definitiv nicht.
;
;$L=-Bsymbolic Lib:DOSLIB_$0$8 Lib:All$9
;7%$L=-Bdynamic Lib:DOSLIB_$0$8 Lib:All$9
5%X0=Echo "Ich simuliere einen Versionsdumper, der aber nur bei 68040 anläuft."
Y0=Copy obj/$0/vc vbcc://bin/vc_$0
:END

; :BEGIN xxx ist der Anfang einer Programmdefinition. Diese muß mit :END beendet
; werden. Der Name hinter BEGIN hat keine Bedeutung für's Compilat, er verbindet
; jedoch diese Definition mit den Dateien List_xxx und Work_xxx und ist auch der
; Parameter für Pmm 'Pmm -p xxx'. Der Programmname den der Compiler erzeugt ist
; in $$ festgelegt, ggf. auch mehrmals (siehe oben). BEGIN/END dürfen immer nur
; im Wechsel genau EINMAL benutzt werden. Alle anderen Zeilen können mit #%, also
; 0%, 1% ... 9% CPU-typisch gesetzt werden. An Y0 ist zu erkennen, wie eine
; Funktion nur bei einzelnen CPU's benutzt wird. $L zeigt eine Variante wo es
; einen Standard-Wert gibt, der in Einzelfällen verändert ist. $$ wiederum ist
; für alle CPU's einzeln festgelegt. PFAD ist die letzte Möglichkeit, nur eine
; Definition für alle ($9 und $o dito).
