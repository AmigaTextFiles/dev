
(*##############*)
 MODULE TstShell;      (* 102695 *)
(*##############*)

(*
from AShell.c
*)

FROM   SYSTEM IMPORT ADDRESS, ADR, SHORT;

IMPORT EasyRexx, InOut, LongInOut;
IMPORT Intuition2, Libraries, RexxErrors, Tasks, Utility;

CONST helloworld = "Hello World! :)";
      errormessage = "Error: Because you asked for it ;)";

CONST ArexxCLEAR       = 1;
      ArexxGETVAR      = 2;
      ArexxHELP        = 3;
      ArexxOPEN        = 4;
      ArexxQUIT        = 5;
      ArexxROW         = 6;
      ArexxSAVE        = 7;
      ArexxTEXT        = 8;
      ArexxRX          = 9;
      ArexxCAUSEERROR  = 10;
      ArexxENDTABLE    = 11;

VAR   commandTable   :ARRAY[1..ArexxENDTABLE] OF EasyRexx.ARexxCommandTable;

(*----------------------*)
 PROCEDURE InitCmdTable;
(*----------------------*)

VAR  cmd :INTEGER;

BEGIN

FOR cmd := 1 TO ArexxENDTABLE-1 DO
   WITH commandTable[cmd] DO
      id := cmd;
      userdata := NIL;
      cmdtemplate := ADR("");
   END;
END;
EasyRexx.TableEnd(commandTable[ArexxENDTABLE]);

WITH commandTable[ArexxCLEAR]      DO command := ADR("CLEAR");  cmdtemplate := ADR("FORCE/S");                 END;
WITH commandTable[ArexxGETVAR]     DO command := ADR("GETVAR"); cmdtemplate := ADR("HELLOWORLD/S");            END;
WITH commandTable[ArexxHELP]       DO command := ADR("HELP");   cmdtemplate := ADR("AMIGAGUIDE/S,TOPIC/F");    END;
WITH commandTable[ArexxOPEN]       DO command := ADR("OPEN");   cmdtemplate := ADR("PROJECT/S,TEXT/S,NAME/F"); END;
WITH commandTable[ArexxQUIT]       DO command := ADR("QUIT");                                                  END;
WITH commandTable[ArexxROW]        DO command := ADR("ROW");    cmdtemplate := ADR("NUMBER/A/N");              END;
WITH commandTable[ArexxSAVE]       DO command := ADR("SAVE");   cmdtemplate := ADR("AS/S,NAME/F");             END;
WITH commandTable[ArexxTEXT]       DO command := ADR("TEXT");   cmdtemplate := ADR("TEXT/A/F");                END;
WITH commandTable[ArexxRX]         DO command := ADR("RX");     cmdtemplate := ADR("COMMAND/A/F");             END;
WITH commandTable[ArexxCAUSEERROR] DO command := ADR("CAUSEERROR");                                            END;

END InitCmdTable;

(*-------------------------------------------------------*)
 PROCEDURE myHandleARexx(c:EasyRexx.ARexxContext):BOOLEAN;
(*-------------------------------------------------------*)

TYPE  String0Pointer = POINTER TO ARRAY[0..133] OF CHAR;

VAR  done            :BOOLEAN;
     result1         :LONGINT;
     resultstring,
     error           :EasyRexx.CharPointer;
     sp              :String0Pointer;
     taglist         :ARRAY[0..4] OF Utility.TagItem;
     liRes           :LONGINT;
     pn              :ARRAY[0..81] OF CHAR;


BEGIN

done := FALSE;

resultstring := NIL;
error := NIL;
result1 := RexxErrors.RCOk;

IF CHAR(EasyRexx.GetARexxMsg(c)) # 0C THEN

   InOut.WriteString("Received: ");

   CASE VAL(INTEGER, EasyRexx.Id(c)) OF
      ArexxCLEAR:
         InOut.WriteString("CLEAR");
         IF EasyRexx.Arg(c, 0) # NIL THEN
            InOut.WriteString(" FORCE=on");
         END;
         |
      ArexxGETVAR:
         InOut.WriteString("GETVAR");
         IF EasyRexx.Arg(c, 0) # NIL THEN
            InOut.WriteString(" HELLOWORLD"); InOut.WriteLn;
            InOut.WriteString(" string returned");
            resultstring := ADR(helloworld);
         END;
         |
      ArexxHELP:
         InOut.WriteString("HELP");
         IF EasyRexx.Arg(c, 0) # NIL THEN
            InOut.WriteString(" AMIGAGUIDE");
         END;
         IF EasyRexx.Arg(c, 1) # NIL THEN
            sp := String0Pointer(EasyRexx.ArgString(c,1));
            InOut.WriteString(" TOPIC="); InOut.WriteString(sp^);
         END;
         |
      ArexxOPEN:
         InOut.WriteString("OPEN");
         IF EasyRexx.Arg(c, 1) # NIL THEN
            InOut.WriteString(" TEXT");
         ELSE
            InOut.WriteString(" PROJECT");  (* defaults to PROJECT *)
         END;
         IF EasyRexx.Arg(c, 2) # NIL THEN
            sp := String0Pointer(EasyRexx.ArgString(c,2));
            InOut.WriteString(" '"); InOut.WriteString(sp^); InOut.Write("'");
         END;
         |
      ArexxQUIT:
         InOut.WriteString("QUIT");
         done := TRUE;
         |
      ArexxROW:
         InOut.WriteString("ROW");
         IF EasyRexx.Arg(c, 0) # NIL THEN
            InOut.Write(' '); LongInOut.WriteLongInt(EasyRexx.ArgNumber(c,0), 0);
         END;
         |
      ArexxSAVE:
         InOut.WriteString("SAVE");
         LongInOut.WriteLongInt(LONGINT(EasyRexx.Arg(c, 0)), 10);
         IF EasyRexx.ArgBool(c, 0) THEN
             InOut.WriteString(" AS");
         END;
         IF EasyRexx.Arg(c, 1) # NIL THEN
            sp := String0Pointer(EasyRexx.ArgString(c, 1));
            InOut.WriteString(" '"); InOut.WriteString(sp^); InOut.Write("'");
         END;
         |
      ArexxTEXT:
         InOut.WriteString("TEXT");
         IF EasyRexx.Arg(c, 0) # NIL THEN
            sp := String0Pointer(EasyRexx.ArgString(c,0));
            InOut.WriteString(" '"); InOut.WriteString(sp^); InOut.Write("'");
         END;
         |
      ArexxRX:
         sp := String0Pointer(EasyRexx.ArgString(c,0));
         InOut.WriteString( "RX '"); InOut.WriteString(sp^); InOut.Write("'"); InOut.WriteLn;
         InOut.WriteString(" Sending command asynchronously: '"); InOut.WriteString(sp^);
                         EasyRexx.Portname(c, pn);
                         InOut.WriteString("' to the '"); InOut.WriteString(pn); InOut.WriteString("' port");
                         InOut.WriteLn;

         taglist[0].tiTag := EasyRexx.ERPort;     taglist[0].tiData := ADDRESS(EasyRexx.Port(c));
         taglist[1].tiTag := EasyRexx.ERContext;  taglist[1].tiData := ADDRESS(c);
         taglist[2].tiTag := EasyRexx.ERAsynch;   taglist[2].tiData := ORD(TRUE);
         taglist[3].tiTag := Utility.TagDone;

         liRes := EasyRexx.SendARexxCommandA(EasyRexx.ArgString(c,0), ADR(taglist));
         |
      ArexxCAUSEERROR:
         InOut.WriteString( "CAUSEERROR");
         error := ADR(errormessage);
         result1 := RexxErrors.RCError;
         |

   END;

   taglist[0].tiTag := EasyRexx.ERReturnCode;    taglist[0].tiData := result1;
   taglist[1].tiTag := EasyRexx.ERErrorMessage;  taglist[1].tiData := ADDRESS(error);
   taglist[2].tiTag := EasyRexx.ERResultString;  taglist[2].tiData := ADDRESS(resultstring);
   taglist[3].tiTag := Utility.TagDone;

   IF error = NIL THEN
      taglist[1].tiTag := Utility.TagIgnore;
   END;

   IF resultstring = NIL THEN
      taglist[2].tiTag := Utility.TagIgnore;
   END;

   EasyRexx.ReplyARexxMsgA(c, ADR(taglist));

   InOut.WriteLn;
END;

RETURN done;

END myHandleARexx;

VAR   done    :BOOLEAN;
      context :EasyRexx.ARexxContext;
      taglist :ARRAY[0..13] OF Utility.TagItem;
      signals :Tasks.SignalSet;

(*-----------*)
 BEGIN (*main*)
(*-----------*)

InitCmdTable;

done := FALSE;
context := EasyRexx.NULLARexxContext;

EasyRexx.EasyRexxBase := Libraries.OpenLibrary(ADR(EasyRexx.EasyRexxName), EasyRexx.EasyRexxVersion);

IF (EasyRexx.EasyRexxBase # NIL) THEN

   taglist[0].tiTag := EasyRexx.ERCommandTable;  taglist[0].tiData := ADR(commandTable);
   taglist[1].tiTag := EasyRexx.ERAuthor;        taglist[1].tiData := ADR("Ketil Hunn");
   taglist[2].tiTag := EasyRexx.ERCopyright;     taglist[2].tiData := ADR("© 1995 Ketil Hunn");
   taglist[3].tiTag := EasyRexx.ERVersion;       taglist[3].tiData := ADR("3.0");
   taglist[4].tiTag := EasyRexx.ERPortname;      taglist[4].tiData := ADR("MYAREXX_PORT");
   taglist[5].tiTag := Utility.TagDone;

   context := EasyRexx.AllocARexxContextA(ADR(taglist));

ELSE

   InOut.WriteString("easyrexx.library not found"); InOut.WriteLn;

END;

IF context # EasyRexx.NULLARexxContext THEN

   taglist[0].tiTag  := Intuition2.WATitle;       taglist[0].tiData  := ADR("AREXX Commandline Interface");
   taglist[1].tiTag  := Intuition2.WALeft;        taglist[1].tiData  := 0;
   taglist[2].tiTag  := Intuition2.WAWidth;       taglist[2].tiData  := 320;
   taglist[3].tiTag  := Intuition2.WAHeight;      taglist[3].tiData  := 100;
   taglist[4].tiTag  := Intuition2.WADragBar;     taglist[4].tiData  := ORD(TRUE);
   taglist[5].tiTag  := Intuition2.WADepthGadget; taglist[5].tiData  := ORD(TRUE);
   taglist[6].tiTag  := Intuition2.WASizeGadget;  taglist[6].tiData  := ORD(TRUE);
   taglist[7].tiTag  := Intuition2.WACloseGadget; taglist[7].tiData  := ORD(TRUE);
   taglist[8].tiTag  := Intuition2.WAMinWidth;    taglist[8].tiData  := 50;
   taglist[9].tiTag  := Intuition2.WAMinHeight;   taglist[9].tiData  := 50;
   taglist[10].tiTag := Intuition2.WAMaxWidth;    taglist[10].tiData := -1D;
   taglist[11].tiTag := Intuition2.WAMaxHeight;   taglist[11].tiData := -1D;
   taglist[12].tiTag := Intuition2.WASizeBBottom; taglist[12].tiData := ORD(TRUE);
   taglist[13].tiTag := Utility.TagDone;

   done := CHAR(EasyRexx.ARexxCommandShellA(context, ADR(taglist))) = 0C;

   WHILE NOT done DO
      signals := Tasks.Wait(EasyRexx.ERSignal(context));
      EasyRexx.ERSetSignals(context, signals);

      IF (signals * EasyRexx.ERSignal(context) # Tasks.SignalSet{}) THEN
         done := myHandleARexx(context);
      END;

      (* Needed here because this program only handles an ARexxCommandShell *)
      IF NOT EasyRexx.ERIsShellOpen(context) THEN
         done := TRUE;
      END;

   END;
END;

IF EasyRexx.EasyRexxBase # NIL THEN
   EasyRexx.FreeARexxContext(context);
   Libraries.CloseLibrary(EasyRexx.EasyRexxBase^);
   EasyRexx.EasyRexxBase := NIL;
END;

END TstShell.
