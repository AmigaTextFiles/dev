@DataBase   "LibraryMaker.guide"

@REMARK "$VER: LibraryMaker.guide 1.0 (19-Jan-2004) by James T. Steichen

@REMARK Written by Jim Steichen, Copyright (c) 2004.

@WIDTH 75
@WORDWRAP

@NODE main  "LibraryMaker © 2004 by J.T. Steichen:"

   The purpose of LibraryMaker is to generate the basic source code
   files required to build a Shared (runtime) Library for the Amiga PC.

   Originally this program was written as a CanDo! deck program, but since no
   one is updating CanDo & releasing bug fixes for it, LibraryMaker had to
   be re-written in C.
   
   This .guide file can only describe how the program works, you have
   to know what a Shared Library is & how to use your Compiler/Assembler/Linker
   to create one.  This program is set up to run with SAS-C compiler V6.58. @{FG SHINE}
   This implies that one of the requirements to use the program is to have a
   copy of the SAS-C compiler. @{FG TEXT}
      
   After entering the information that your new shared library requires,
   click on the @{" Make Src Files " LINK Gadgets} button to generate the skeleton
   files of your new shared library.

   You will still have to do some editing of the generated source file & verify 
   that the program generated correct function declarations for you.
   
   The program uses @{" template files " LINK Templates} (located in the Templates/ sub-directory)
   to generate your source code.
   
   More Help:
      
      @{" Menus Available    " LINK Menus}

      @{" Gadgets            " LINK Gadgets}

      @{" KeyStrokes         " LINK KeyStrokes}

      @{" ToolTypes          " LINK ToolTypes}

      @{" Template Files     " LINK Templates}

      @{" Author Information " LINK Author}

      @{" Project file structure " LINK ProjectFiles}
    
      @{" Some notes on SAS-C    " LINK LibraryCreation}
        
      @{" Still to do...         " LINK ToDoStuff}
      
@ENDNODE

@NODE LibraryCreation "Some Additional information:"
@{FG SHINE}
   I do not recall where or when I obtained this information, just
   keep in mind that I DID NOT write it! (JTS) @{FG TEXT}
   
   ===================================================
   How to create an Amiga shared library:
   ===================================================

1) Compile all modules that reference global data with the libcode option.
   Note that global data will be shared between all processes that open 
   the library.

2) Add the __saveds keyword to any function that is callable from outside
   the library.
   
3) Create a .fd describing your library.

4) Link with the following command:

SLink LIBFD <fdfile> [LIBPREFIX <prefix>] [LIBID <idstring>] TO <libname> 
      FROM lib:libent.o lib:libinit.o <modules>

where

LIBFD <fdfile>    specifies the name of the .fd file you created in step (3).

LIBPREFIX         specifies an optional prefix to add to the functions listed
                  in the .fd file.  The default is simply an underscore (_).
                  If for some reason you don't want to use the #pragmas to
                  access the library, you can use the old method of having
                  assembly-language stubs that accept parameters on the stack
                  like a typical C routine, pop them into registers and call
                  the library function for you.  (You must write the stubs
                  yourself in assembler.)  If you do this, the library
                  routines cannot have exactly the same names as the entries
                  in the .fd file, since these names will have been taken
                  by the stub routines.  The LIBPREFIX option specifies a
                  common prefix to be prepended to the function names in the
                  .fd file.  You will be responsible for making sure that the
                  actual function declarations in the library's .c source file
                  match the full name, including any specified prefix.  For
                  example, if your library has a function called 'foo' and
                  you specify a LIBPREFIX of _LIB, you should declare the
                  function in your source code as LIBfoo.  (Remember that
                  SLink always adds an extra underscore to symbol names.)
                  If you always use the automatically-generated #pragma
                  statements to access the library, you can ignore LIBPREFIX.

LIBID <idstring>  specifies an optional library ID string (See _LibID, below).
                  LIBID is purely informational and is never required.

TO <libname>      specifies the resulting library name.

libent.o          contains the RomTag for the library, and MUST BE THE FIRST
                  OBJECT MODULE LISTED.  The source to libent.o (libent.a) is
                  in the SOURCE subdirectory of disk 4 of the compiler 
                  distribution.  You do not need to modify this file for 
                  your library, and probably should not.

libinit.o         contains the system-required library entry points Open,
                  Close and Expunge as well as other initialization routines,
                  and MUST BE THE SECOND OBJECT MODULE LISTED.  The source to
                  libinit.o (libinit.c) is in the SOURCE subdirectory of 
                  disk 4 of the compiler distribution.  You may modify this 
                  file to add custom initialization code if you like, but 
                  you are not required to do so.

modules           are your module names.  They may be in any order as long
                  as they are specified after libent.o and libinit.o.

   ======================================================
   How to call the library:
   ======================================================

   Create pragmas for your library with the FD2PRAGMA program, provided on 
   disk 3 of the compiler distribution.  FD2PRAGMA will output a .h file
   containing #pragma statements for all the externally-callable functions
   in your library.  Code that would like to call your library should 
   #include this .h file before referencing any of the library's functions.
   When one of the library functions is called, the compiler will look at 
   the #pragma for that function and determine which registers the library 
   function wants the parameters in.  It will load the proper registers, load 
   your library base in register A6, and call your function.

   The user code should declare a variable of type 'struct Library *' named 
   after your library base.  For example, if your library is called 
   'mylib.library', and you have chosen to name your library base 'MyLibBase',
   the declaration in the user's code would look like:

      struct Library *MyLibBase;

   The library base can be an automatic or a global variable.  Before calling
   any function in your library, the user must initialize the library base
   by calling the OpenLibrary function:

      MyLibBase = OpenLibrary( "mylib.library", version );  

      where version is less that equal to the number in the version
      field of the struct Library (see libinit.c). A version of 0
      will open any version of the library.
      
   The user should always check to make sure that MyLibBase is not NULL, 
   which would indicate that the library could not be loaded or that the 
   version was not acceptable.

   Once the library base pointer is loaded, the user program can call your
   library functions by name just like any other function.  When the program
   is finished with your library, it should call CloseLibrary:

      CloseLibrary( MyLibBase );


   =======================================================
   How It Works:
   =======================================================

   1) What the compile options do

      Modules compiled with libcode do not use register A6, except when calling 
      other libraries, in which case it is restored immediately upon return. 
      Therefore A6 always has a pointer to the current library base.  Further,
      when __saveds is specified, the compiler generates the instruction  

         LEA   LinkerDB(A6),A4 

      in the function prolog.  LinkerDB is a symbol generated by SLink that
      specifies the offset from the library base at which user global data
      may be stored.  Thus, the above instruction sets A4 to point to the
      library's global data.  Notice that the standard executable startup
      code, c.o, contains a reference to LinkerDB as well.  When SLink is
      linking a library, it knows to interpret LinkerDB differently than
      when linking a normal program.

   2) What the initialization code does

      The job of the LibInit function in a shareable library is to set up 
      the library base.  The LibInit() function defined in libinit.c will
      in addition copy global data from the place where LoadSeg loaded it
      (as defined by the SLink-generated symbol _Libmergeddata) to the end 
      of the library base structure.  Once there, any data relocations are
      patched up. From this point on, global data may be referenced relative
      to A4 since A4 has been set to point at the global data.

   2) What SLink does

      SLink first reads the .fd file and determines the names and number 
      of functions to the library. It creates a jump table of the form:

       +---------------------------------+
       |        __LibOpen                |
       |        __LibClose               |
       |        __LibExpunge             |
       |        ROMTAG - 2               | 
       |        user defined functions.  |
       +---------------------------------+         

      The names of the user-defined functions are created by prepending the
      specified LIBPREFIX to the function names in the .fd file.  The symbol
      _LibFuncTab points to the table, which is placed into the data section.

      SLink also defines the following symbols for libinit.o to use when 
      initializing the library:

         _LibName       name of library, as specified by the TO option to
                        SLINK.

         _LibID         id for library, as specified by the LIBID option to
                        SLINK.  This is a null string if no LIBID option is
                        specified.

         RESLEN         length of data section to be allocated as part of
                        the Library structure.

         NEWDATAL       length of initialized data section.
 
  
   ==================================================
   Library Format:
   ==================================================

  The library that SLink produces looks like this:

  Code Hunk 1:  (comes from libent.o)

      moveq #0,d0           ; This is in case someone tries
      rts                   ; to run the library as a program 

   RomTag
      dc.w RTC_MATCHWORD   ; RomTag information for the library
      dc.l _LibRomTag      ;   as described in the Rom Kernel manual
      dc.l endtag          ; |
      dc.b RTF_AUTOINIT    ; |
      dc.b VERSION         ; |
      dc.b NT_LIBRARY      ; |
      dc.b PRI             ; |
      dc.l _LibName        ; |
      dc.l _LibID          ; v
      dc.l _LibInitTab     ; End of RomTag information

  Code Hunk 2 - n:  (comes from libinit.o and user modules)

   _LibInit
      <code for LibInit>
   _LibOpen
      <code for LibOpen>
   _LibClose
      <code for LibClose>
   _LibExpunge
      <code for LibExpunge>
   user functions

  MERGED DATA

  _Libmergeddata                ; symbol that tells LibInit where the merged
                                ; data is initially loaded.
  _LibInitTab                   ; struct LibInitTab as specified in libinit.c
      length of global data
      pointer to function jump table
      NULL
      pointer to initialization code (_LibInit)

  USER GLOBAL DATA

@ENDNODE

@NODE ToDoStuff "Holes to fill in:"

   The following areas still need to be worked on:
   
   * Handle Function Parameter lists correctly & verify that
     register assignments make sense.
     
@ENDNODE

@NODE ProjectFiles "LibraryMaker Project file Structure:"

   The project file that LibraryMaker generates is structured as
   follows:
   
   [LibraryInformation]
   LibraryName     = thisIsATest
   LibraryBaseName = TestBase
   SourcePrefix    = Test
   FunctionPrefix  = LIB_
   LibraryVersion  = 2
   LibraryRevision = 3
   LibraryAuthor   = J.T. Steichen
   [LibraryFunctions]
   NumberOfFunctions = 5
   LibraryFunction   = int Open( int parm1, char *parm2 ) (d0/a0)
   LibraryFunction   = int Close( void *parm1 ) (a0)
   LibraryFunction   = int Expunge( void *parm1 ) (a0)
   LibraryFunction   = int Reserved( void ) ()
   LibraryFunction   = int longFunctionName( int parm1, char *parm2, UBYTE *junk ) (d0/a0/a1)

   NOTE:  Be sure that each function declaration is less than 236 bytes in length
          or the program will truncate it during read-in.
          
@ENDNODE

@NODE Menus "LibraryMaker Menus:"             
   
   PROJECT
     New
     Open..    A-O
     Save..    A-S
     Save As.. A-A
     ~~~~~~~~~~~~~
     About..   A-I
     Quit      A-Q

   HELP
     View .guide File  A-H                        @{FG SHINE}
     Summary of what to place in ListView Gadget: @{FG TEXT}
     Function Descriptor Help » 
        rtype FuncName( int w, char *s ) (D0/A0)
        int     = D0
        pointer = A0
        long    = D0
        double  = D0/D1 
     @{FG SHINE}
        two double arguments would be passed as (D2/D3,D0/D1) @{FG TEXT}

   OPTIONS
     Add Debug Code          @{FG SHINE}(When checked, various debugging 
                              flags are added to the MakeFile)@{FG TEXT}
     Make Re-entrant library @{FG SHINE}(When checked, use LibInitR.o instead of LibInit.o)@{FG TEXT}

@ENDNODE

@NODE Gadgets "LibraryMaker Gadgets:"             

   Gadget:                        You Enter:
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   A@{U}u@{UU}thor Name:          Your Name (silly!)

   Library @{U}N@{UU}ame:         Library name that OpenLibrary() will use.

   @{U}B@{UU}ase Name:            Library pointer name for CloseLibrary()

   Source @{U}P@{UU}refix:        Name of the Source files.

   @{U}F@{UU}unction Prefix:      Optional prefix for each Library Function 

   @{U}V@{UU}ersion:              Version number of the Shared Library.

   @{U}R@{UU}evision:             Revision number of the Shared Library.

   Library Functions (200 Max.):  @{" Library Function declarations. " LINK "FunctionProtos"}

   @{U}M@{UU}ake Src Files        This will generate the source code files.

   @{U}E@{UU}dit File..           This will invoke the @{" Default Editor. " LINK ToolTypes}

@ENDNODE

@NODE "FunctionProtos" "Function Declarations:"

   Each library function declaration has to have four things:
   
   1. The return type of the function (int, char *, etc).
   2. The name of the function (but of course!).
   3. The parameter list (void, register __d0 int size, struct Window *w, etc).
   4. A list of registers that the parameters are in (d0/a0/a1, etc).

   Examples:
   
   int getFileSize( register __a0 FILE *filePtr ) (a0)
   
   void crashNBurn( void ) ()
   
   double computeMatrix( double factor, register __a0 double *matrix ) (d0/d1/a0)
   
@ENDNODE

@NODE KeyStrokes "LibraryMaker KeyStrokes:"             

   The various Gadgets & Menus in the GUI have keypress equivalents
   to them.  They are as follows:
   
   Key:   Gadget Action:
   ~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
   u/U    Activate the Author   Name   String  Gadget.
   n/N    Activate the Library  Name   String  Gadget.
   b/B    Activate the Base     Name   String  Gadget.
   p/P    Activate the Source   Prefix String  Gadget.
   f/F    Activate the Function Prefix String  Gadget.
   v/V    Activate the Version         Integer Gadget.
   r/R    Activate the Revision        Integer Gadget.

   m/M    Start the file generation process (Make Src Files)
   e/E    Activate the default Editor       (Edit File..)

   Key:   Menu Action:
   ~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   o/O    Open a Project file. (Open..)
   s/S    Save a Project file. (Save..)
   a/A    Save a Project file, but get a filename first (Save As..)
   i/I    Show an program information Requester (About..)
   q/Q    Exit the program (Quit)
   h/H    Use the HelpViewer to view this file (View .guide file)
          (The Help key will also perform this action)
@{FG SHINE}
   NOTE:  Pressing the Up-Arrow key will move the item selector in the
          ListView Gadget up one item, & copy the item into the String
          Gadget below the ListView Gadget.  

          The Down-Arrow key will move the item selector in the
          ListView Gadget down one item, & copy the item into the String
          Gadget below the ListView Gadget.

          The Left-Arrow key does the same as the Up-Arrow, except that
          it also activates the String Gadget below the ListView Gadget.
           
          The Right-Arrow key does the same as the Down-Arrow, except that
          it also activates the String Gadget below the ListView Gadget.
@{FG TEXT}

@ENDNODE

@NODE ToolTypes "LibraryMaker ToolTypes:"             

   LibraryMaker uses the ToolTypes in the program Icon to store
   rarely-changed strings that help generate the source code files.
   
    ToolType:        Default Value:
    ~~~~~~~~~~~~~~   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SAVEPATH       = "Work:Results/"

    CURRENTPROJECT = "myLibrary"

    DEFAULTEDITOR  = "C:Ed" 

    ASMOPTIONS     = "-lmx -iINCLUDE:"

    COPTIONS       = "libcode nostkchk idir=INCLUDE:"

    TESTOPTIONS    = "nostkchk idir=INCLUDE:"

    LINKOPTIONS    = "ADDSYM"

    ASMCOMMAND     = "Asm"             (SAS-C Assembler)

    COMPILECOMMAND = "SC"              (SAS-C Compiler)

    LINKCOMMAND    = "SLink"           (SAS-C Linker)

    LINKLIBRARIES  = "LIB:sc.lib"

    SOURCEPATH     = "Work:"

    HELPVIEWER     = "MultiView"

    TEMPLATEPATH   = "Work:Templates/" @{FG SHINE}(SavePath/Templates)@{FG TEXT}

   The only ToolTypes you might change for your programming environment
   are:
   
      SAVEPATH
      SOURCEPATH
      TEMPLATEPATH
   
   Use the Workbench @{B}Icons/Information@{UB} menu item to view these ToolTypes
   & change them from there.
      
@ENDNODE

@NODE Templates "LibraryMaker Template files:"             

   LibraryMaker uses four template files to generate shared
   library source code.  They are:

      @{" .fd       template " LINK "FDTemplate"}      
      @{" main      template " LINK "FuncTemplate"}
      @{" SMakeFile template " LINK "MakeFileTemplate"}
      @{" test      template " LINK "TestTemplate"} -- For testing the library.

   Each Template file relies on special indicators to tell
   LibraryMaker where to put user-specified information in the
   generated source files.  These special indicators are as follows:
   
   Indicator:     Corresponds to:
   ~~~~~~~~~~     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   $Author        Author Name String Gadget contents.
   $BaseName      Base   name String Gadget contents.
   $Date          Date at the time the Make Src Files Gadget was pressed.
   $FDFuncs       The contents of the Function ListView Gadget.
   $FuncPrefix    Function Prefix String Gadget contents.    
   $Funcs         The contents of the Function ListView Gadget.
   $LibInitObject Either LibInit.o or LibInitR.o
                  (@{" Make Re-entrant library " LINK Menus} state determines which one).
   $Name          Library Name String Gadget contents.   
   $Prefix        Source Prefix String Gadget contents.
   $Rev           Revision Integer Gadget contents.
   $Vers          Version  Integer Gadget contents.

   $ObjFileName   $Prefix with @{B}C.o@{UB} appended.
   $SrcFileName   $Prefix with @{B}C.c@{UB} appended.
   $SrcHeaderName $Prefix with @{B}H.h@{UB} appended.
    
   $AFlags        @{" ASMOPTIONS     ToolType " LINK ToolTypes}
   $CFlags        @{" COPTIONS       ToolType " LINK ToolTypes}
   $CompileCmd    @{" COMPILECOMMAND ToolType " LINK ToolTypes}
   $LFlags        @{" LINKOPTIONS    ToolType " LINK ToolTypes}
   $LinkCmd       @{" LINKCOMMAND    ToolType " LINK ToolTypes}
   $LinkLibs      @{" LINKLIBRARIES  ToolType " LINK ToolTypes}

@ENDNODE

@NODE "FDTemplate" "FD Template File contents:"

   Here is what is inside the fd.template file:
@{FG SHINE}   
****************************************************************
* Function Descriptor file for $Name Shared Library
* Created on $Date by $Author
*
* WARNING:  FD2Pragma chokes on un-necessary whitespace,
*           so this file is usually hard to read!!
****************************************************************
##base _$BaseName
##bias 30
##public
$FDFuncs
@{FG TEXT}
    
@ENDNODE

@NODE "FuncTemplate" "Main Template File contents:"

   Here is what is inside the FunctionsC.template file:
@{FG SHINE}   
/****h* $SrcFileName [$Vers.$Rev] **************************************
* 
* NAME
*    $SrcFileName
*
* DESCRIPTION
*    Contains the User functions for a 
*    shared library generated by Library Maker (c) 2004
*    by J. T. Steichen.  
*
*    The Library was defined by the user as follows:
*
$All
*
* NOTES
*    $VER: $SrcFileName $Vers.$Rev ($Date) by $Author
***************************************************************
*
*/

#include <exec/types.h>

#include <AmigaDOSErrs.h>

#include "$SrcHeaderName"

struct _env {

   struct Library *$BaseName;

   // Place other stuff you need in here!
};

typedef struct _env  ENV, *ENVPTR;

PRIVATE ENV e;


/* --------------- Now, the user functions: ---------------- */

$Funcs
/* --------------- END of $SrcFileName file! ----------------- */
@{FG TEXT}

@ENDNODE

@NODE "MakeFileTemplate" "SMakeFile Template File contents:"

   Here is what is inside the MakeFile.template file:
@{FG SHINE}   
###############################################################
#
#   SMakeFile for "$Name", a shared library.
#
#      Generated by LibraryMaker (c) 2004.
#
#   Created by $Author on $Date
###############################################################
#
TestLibs = LIB:scm.lib,LIB:sc.lib,LIB:Amiga.lib
#
LOpts    = $LFlags
#
SCOpts   = $CFlags
# 
AOpts    = $AFlags
#
TstOpts  = $TFlags
#
dummy:   $Name   $Prefix
   @echo   " "
   @echo   "$Name, $Prefix created."
#
#
#
all: 
   SMake $Name
   SMake Test$Prefix
#
# -------------- Library Target(s): ----------------------------------
#
$Name:   $ObjFileName
      $LinkCmd WITH <<
LIBPREFIX $FuncPrefix
LIBFD     $Prefix.fd
TO        $Name
FROM      LIB:LibEnt.o,$LibInitObject,$ObjFileName
LIB       $LinkLibs
$LFlags
libversion $Vers librevision $Rev
<
     $LinkCmd FROM $Name TO LIBS:$Name ND noicons
#
$ObjFileName   :   $SrcFileName $SrcHeaderName
   $CompileCmd $(SCOpts) $SrcFileName
#
$SrcHeaderName :   $Prefix.fd
   FD2Pragma $Prefix.fd $SrcHeaderName
#
# --------------- Testing code: --------------------------------------
#
$Prefix   :   $Prefix.o
   $LinkCmd LIB:c.o,$Prefix.o TO $Prefix LIB $(TestLibs) $(LOpts)
#
$Prefix.o :   $Prefix.c $SrcHeaderName
   $CompileCmd DEBUG=SYMBOL $(TstOpts) $Prefix.c
#
@{FG TEXT}
    
@ENDNODE

@NODE "TestTemplate" "Test Template File contents:" 

   Here is what is inside the TestSystemLib.template file:
@{FG SHINE}   
/****h* Test$Prefix.c [$Vers.$Rev] ***********************************
*
* NAME
*    Test$Prefix.c
*
* DESCRIPTION
*    This file contains a test driver program for:
*    $Name, a shared library generated by:
*    LibraryMaker (c) 2004, written by J. T. Steichen.
*
* NOTES
*    $Name created by $Author on $Date
***************************************************************
*
*/

#include <stdio.h>

#include <exec/types.h>

#include <AmigaDOSErrs.h>

#include <clib/exec_protos.h>

#include "$SrcHeaderName"

struct Library *$BaseName = NULL;

/*
** This is a list of the functions to be tested:
$FuncProtos   
*/

PUBLIC int main( void )
{
   fputs( "Opening...", stderr );

   $BaseName = OpenLibrary( "$Name", $Vers );

   printf( "\n$BaseName = 0x%08LX\n", $BaseName );

   if ($BaseName == NULL)   
      {
      fprintf( stderr, "Couldn't open $Name !\n" );

      return( ERROR_INVALID_RESIDENT_LIBRARY );
      }

   // Here is where you have to place your test code for the library:

   CloseLibrary( $BaseName );

   return( RETURN_OK );
}

/* ----------------- END of Test$Prefix.c file! ------------------ */
@{FG TEXT}
    
@ENDNODE

@NODE Author "LibraryMaker Author Information (What a hoopy guy!):"
@PREV main

  If your conscience is bugging you to contribute some cash for my
  programming efforts, please send $15 or more for the program to:
  
  The Author:
  
  James T. Steichen    @{FG SHINE}(A real cool frood!)@{FG TEXT}
  2217 N. Tamarack Dr. 
  Slayton, Mn. 56172-1155 (USA)

  email: @{FG SHINE} jimbot@frontiernet.net @{FG TEXT} (best place to send bug reports)

  LibraryMaker was written in C using the SAS C compiler V6.58.

@ENDNODE
