@database
@$VER: DepthMenuAPI_eng.guide V3 (03.12.2002)
@author "Arkadiusz [Yak] Wahlig"
@node main "DepthMenu API"


    @{b}DepthMenu API@{ub}

    Version 3 (03-12-2002)
    Copyright © 2001-2002 Arkadiusz [Yak] Wahlig


    @{"  " LINK docz} What are modules used for?
    @{"  " LINK wyma} What is needed?
    @{b}---@{ub}
    @{"  " LINK stat} Static modules
    @{"  " LINK dyna} Dynamic modules
    @{b}---@{ub}
    @{"  " LINK tagi} Available tags
    @{"  " LINK bibl} depthmenu.library
    @{b}---@{ub}
    @{"  " LINK zale} Advices
    @{"  " LINK kont} Contact

@endnode
@node docz "What are modules used for?"

Modules can:

@{b}1.@{ub} change names of windows/screens in menu,
@{b}2.@{ub} add options and submenus to windows/screens menu,
@{b}3.@{ub} alter the way windows/screens are moved to front.

  It  is  of course possible that future version of DepthMenu will allow to use
more options. API is very flexible and adding new functions won't interact with
existing modules.

  If you think you know how to get advantages of given possibilities, read this
documentation.  API  is  very  easy to code and, if you have some experience in
writing  programs  for  AmigaOS,  you  shouldn't have problems with making your
ideas true. In case you have, @{"contact" link kont} me - I'll help you.

@endnode
@node wyma "What is needed?"

  To  create  your  own module you have to have compiler of C language (as only
includes  for  C  are available at the moment), files from 'include/' directory
(contained  in  this  archive)  and a bit of AmigaOS programming skills (by the
way, it's pure pleasure :)).

I worked with SAS/C 6.50 compiler.

@endnode
@node stat "Static modules"

  Static  modules  are  files  stored  in  "Modules"  directory. They are usual
executable  files  (created  by  compiler)  which  contain properly initialized
@{b}DM_Module@{ub} structure. Location of this structure in file is not really important
as  DepthMenu will search whole file for it. Module should be protected from an
accidental  execution  as a normal program by inserting at the beginning of the
first hunk following assembler code:

moveq #-1,d0
rts


DM_Module structure in static module looks like this:

struct DM_Module
{
 UWORD MatchWord;            /* always DM_MATCHWORD, using  this  one and  next
                                field DepthMenu will find structure in  file */

 struct DM_Module *MatchTag; /* it points the beginning of structure */

 UBYTE APIVersion;           /* version of API required by this module */

 BYTE Priority;              /* module  priority on the  modules  list, higher
                                priority means earlier calling of functions of
                                this module and added options will be placed
                                higher in menu */


 STRPTR IDString;            /* string  which  identifies  module, it  usually
                                contains  name,  version,  compilation date and
                                name of the author */

 struct TagItem *TagList;    /* module @{"tag" link tagi} list, see below */

 BPTR SegList;               /* module segment  list, this  field  is filled by
                                DepthMenu and initial value isn't important */

 STRPTR ModulePath;          /* full path  to file  with module,  this field is
                                filled by DepthMenu,  and  initial value  isn't
                                important */
};

  I think explanations given on the right are quite clear. Maybe except TagList
field.  TagList  is very important as hooks are defined by means of @{"tags" link tagi}... but
not only...

@endnode
@node dyna "Dynamic modules"

  Dynamic  modules  are  added and deleted by other programs running in system.
Their  main  element  is initialized structure @{b}DM_Module@{ub}. Adding module to list
and  deleting  it from this list is done thanks to @{"depthmenu.library" link bibl}. Module is
added by @{"DM_AddModule()" link dm_addmodule()} function and deleted by function @{"DM_RemModule()" link dm_remmodule()}.


DM_Module structure in dynamic module looks like this:

struct DM_Module
{
 UWORD MatchWord;            /* always DM_MATCHWORD, using  this  one and  next
                                field DepthMenu will find structure in  file */

 struct DM_Module *MatchTag; /* it points the beginning of structure */

 UBYTE APIVersion;           /* version of API required by this module */

 BYTE Priority;              /* module  priority on the  modules  list, higher
                                priority means earlier calling of functions of
                                this module and added options will be placed
                                higher in menu */


 STRPTR IDString;            /* string  which  identifies  module, it  usually
                                contains  name,  version,  compilation date and
                                name of the author */

 struct TagItem *TagList;    /* module @{"tag" link tagi} list, see below */

 BPTR SegList;               /* nullified by DepthMenu, don't use is */

 STRPTR ModulePath;          /* not used */
};

  I think explanations given on the right are quite clear. Maybe except TagList
field.  TagList  is very important as hooks are defined by means of @{"tags" link tagi}... but
not only...

@endnode
@node zale "Advices"

Here are some advices useful during creation of modules: 

  Use (if you can) your own startup code when creating static module because it
will  be executed only in case of misrunning the module as program (like during
writing libraries) and a big startup module unnecessary uses valuable memory.

  Hooks  DM_Hook_#?Attrs  are  called  for every screen/window which appears in
menu.  That's why it is necessary for the biggest possible number of screen and
windows  to  be executed as quick as possible because in other case it can slow
down displaying menu.

  Name  archive  with  your static module DM_#?.lha for easy identification and
(if  you  want  to  spread  it as freeware) send it to yak@depthmenu.prv.pl and
it'll be placed at homepage of the program.

  In  documentation of your program, which creates dynamic module, inform about
that (place there address www.depthmenu.prv.pl aslo).

  Avoid requiering depthmenu.library (just use it if it's avaible) and add some
other way to execute the options added by your module.

@endnode
@node kont "Kontakt"

If you have any questions about modules, contact me by means of:

- @{b}E-MAIL@{ub} (recommended)
  yak@depthmenu.prv.pl

- @{b}SNAIL MAIL@{ub}
  Arkadiusz Wahlig
  os. 22 Lipca 3/16
  66-134 Konotop
  Poland

  You  are also invited to visit @{b}http://www.depthmenu.prv.pl@{ub} where you can find
the latest info, program and modules.

@endnode
@node tagi "Available tags"

    Here are tags available in this version of API:


    @{" DM_Hook_Setup          " link dm_hook_setup         }  @{" DM_Hook_Cleanup        " link dm_hook_cleanup}
    @{" DM_Hook_WindowAttrs    " link dm_hook_windowattrs   }  @{" DM_Hook_ScreenAttrs    " link dm_hook_screenattrs}
    @{" DM_Hook_WindowItems    " link dm_hook_windowitems   }  @{" DM_Hook_ScreenItems    " link dm_hook_screenitems}
    @{" DM_Hook_WindowSelected " link dm_hook_windowselected}  @{" DM_Hook_ScreenSelected " link dm_hook_screenselected}
    @{" DM_Hook_ItemsHandler   " link dm_hook_itemshandler  }


    @{b}Bazy bibliotek:@{ub}

    @{" DM_Get_CxBase          " link dm_get_cxbase            }  @{" DM_Get_DepthMenuBase   " link dm_get_depthmenubase}
    @{" DM_Get_DOSBase         " link dm_get_dosbase           }  @{" DM_Get_IconBase        " link dm_get_iconbase}
    @{" DM_Get_IntuitionBase   " link dm_get_intuitionbase     }  @{" DM_Get_LayersBase      " link dm_get_layersbase}
    @{" DM_Get_LocaleBase      " link dm_get_localebase        }  @{" DM_Get_SysBase         " link dm_get_sysbase}
    @{" DM_Get_UtilityBase     " link dm_get_utilitybase       }


    @{b}Pozostaîe:@{ub}

    @{" DM_Get_Language        " link dm_get_language          }

@endnode
@node "DM_Hook_Setup"
									   (V1)
@{u}DM_Hook_Setup@{uu} - initialization of module

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be  called  once  after  loading  a  module to memory (or after using
DM_AddModule()  function).  Hook  returns  BOOL which informs if initialization
succeeded.

@endnode
@node "DM_Hook_Cleanup"
									   (V1)
@{u}DM_Hook_Cleanup@{uu} - freeing resources of module

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be  called  once  after  loading  a  module to memory (or after using
DM_RemModule()  function).  Hook returns BOOL which informs if deinitialization
succeeded.

@endnode
@node "DM_Hook_WindowAttrs"
									   (V1)
@{u}DM_Hook_WindowAttrs@{uu} - defining window's attributes

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be  called  for each window during creation of windows' menus. Hook's
arguments   are   pointer   to   Window  structure  (in  A2  register)  and  to
DM_AttrsMessage structure (in A1 register).

DM_AttrsMessage structure looks like this:

struct DM_AttrsMessage
{
 struct Process *Process;   /* from here you can get address of window's
                               owner process */

 STRPTR ProcessName;        /* from here you can get name of window's owner
                               process */

 BOOL Remove;               /* set it to TRUE if you want the window not to
                               appear in menu */

 STRPTR TitleHead;          /* here you can enter a text, which will appear
                               in menu before window's name */

 STRPTR Title;              /* here you can enter a text, which will appear
                               in menu instead of window's name */

 STRPTR TitleTail;          /* here you can enter a text, which will appear
                               in menu after window's name */
};

Process field can have value NULL if finding window's owner failed.

  Name  of  the owner in ProcessName field contains, for task, name of the task
(from  ln_Name  field  of  system  node), and for process it's name of run file
(with exact letter case).

  Hook is called for all windows, even for those, which usually don't appear in
menu. You can then add them there by giving them names (Title field).

  Hook  returns  BOOL informing if any changes in DM_AttrsMessage structure has
been made.

@endnode
@node "DM_Hook_ScreenAttrs"
									   (V1)
@{U}DM_Hook_ScreenAttrs@{uu} - defining screen attributes

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be  called  for each screen during creation of screens' menus. Hook's
arguments   are   pointer   to   Screen  structure  (in  A2  register)  and  to
DM_AttrsMessage structure (in A1 register).

Structure DM_AttrsMessage looks like this:

struct DM_AttrsMessage
{
 struct Process *Process;   /* not used */

 STRPTR ProcessName;        /* not used */

 BOOL Remove;               /* set it to TRUE if you want screen not to
                               appear in menu */

 STRPTR TitleHead;          /* here you can enter a text, which will appear
                               in menu before screen's name */

 STRPTR Title;              /* here you can enter a text, which will appear
                               in menu instead of screen's name */

 STRPTR TitleTail;          /* here you can enter a text, which will appear
                               in menu after screen's name */
};

  Hook  returns  BOOL informing if any changes in DM_AttrsMessage structure has
been made.

@endnode
@node "DM_Hook_WindowItems"
									   (V1)
@{u}DM_Hook_WindowItems@{uu} - adding options to windows menu

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be called once during creation of windows' menu. Hook's arguments are
pointer  to  Window  structure  of window for which menu has been called (in A2
register) and to DM_ItemMessage structure (in A1 register).

DM_ItemsMessage structure looks like this:

struct DM_ItemsMessage
{
 struct Process *Process;   /* from here you can get address of window's
                               owner process */

 STRPTR ProcessName;        /* from here you can get name of window's owner
                               process */

 APTR Items;                /* here you can place menus/items (created by
                               @{"depthmenu.library" link bibl} functions) which are to be
                               added to menu */

 BOOL Reusable;             /* (V3) set it to TRUE if you want given
                               menus/items not to be freed after closing
                               menu (you'd have to do it by hand) */
};

Process field can have value NULL if finding window's owner failed.

  Name  of  the owner in ProcessName field contains, for task, name of the task
(from  ln_Name  field  of  system  node), and for process it's name of run file
(with exact letter case).

Depthmenu.library base can be obtained by @{"DM_Get_DepthMenuBase" link dm_get_depthmenubase} tag.

Handling of added items is done by hook defined by @{"DM_Hook_ItemsHandler" link dm_hook_itemshandler} tag.

  Hook  returns  BOOL  informing if any changes in DM_ItemMessage structure has
been made.

@endnode
@node "DM_Hook_ScreenItems"
									   (V1)
@{u}DM_Hook_ScreenItems@{uu} - adding options to screens menu

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will  be called once during creation of screens' menu. Hook's arguments are
pointer  to  Screen  structure  of screen for which menu has been called (in A2
register) and to DM_ItemMessage structure (in A1 register).

DM_ItemsMessage structure looks like this:

struct DM_ItemsMessage
{
 struct Process *Process;   /* not used */

 STRPTR ProcessName;        /* not used */

 APTR Items;                /* here you can place menus/items (created by
                               @{"depthmenu.library" link bibl} functions) which are to
                               be added to menu */

 BOOL Reusable;             /* (V3) set it to true if you want given
                               menus/items not to be freed after closing
                               menu (you'd have to do it by hand) */
};

Depthmenu.library base can be obtained by @{"DM_Get_DepthMenuBase" link dm_get_depthmenubase} tag.

Handling of added items is done by hook defined by @{"DM_Hook_ItemsHandler" link dm_hook_itemshandler} tag.

  Hook  returns  BOOL  informing if any changes in DM_ItemMessage structure has
been made.

@endnode
@node "DM_Hook_WindowSelected"
									   (V3)
@{u}DM_Hook_WindowSelected@{uu} - moving window to front

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will be called once just after selecting window from menu. Hook's arguments
are pointer to Window structure of selected window (in A2 register) and pointer
to structure DM_SelectedMessage (in A1 register).

DM_SelectedMessage structure looks like this:

struct DM_SelectedMessage
{
 struct Process *Process;   /* from here you can get address of window's
                               owner process */

 STRPTR ProcessName;        /* from here you can get name of window's owner
                               process */
};

Process field can have value NULL if finding window's owner failed.

  Name  of  the owner in ProcessName field contains, for task, name of the task
(from  ln_Name  field  of  system  node), and for process it's name of run file
(with exact letter case).

Hook returns BOOL informing if window has been moved to front.

  Hook  is  used  to  move windows in a non-standard way. Moving blockin window
(requester) in front of selected is good example.

@endnode
@node "DM_Hook_ScreenSelected"
									   (V3)
@{u}DM_Hook_ScreenSelected@{uu} - moving screen to front

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It  will be called once just after selecting screen from menu. Hook's arguments
are pointer to Screen structure of selected screen (in A2 register) and pointer
to DM_SelectedMessage structure (in A1 register).

DM_SelectedMessage structure looks like this:

struct DM_SelectedMessage
{
 struct Process *Process;   /* not used */

 STRPTR ProcessName;        /* not used */
};

As you can see this structure is not used yet.

Hook returns BOOL informing if screen has been moved to front.

Hook is used to move screens in a non-standard way.

@endnode
@node "DM_Hook_ItemsHandler"
									   (V3)
@{u}DM_Hook_ItemsHandler@{uu} - options handling

  Argument of this tag (ti_Data) points to properly initialized Hook structure.
It will be called after choosing option added by module (by @{"DM_Hook_WindowItems" link DM_Hook_WindowItems}
tag  or  @{"DM_Hook_ScreenItems" link DM_Hook_ScreenItems}  tag).  Hook's  arguments are pointer to Window or
Screen  structure (depends on where options had been added - windows or screens
menu)  of  window/screen  for  which  menu has been called (in A2 register) and
pointer to DM_ItemsHandlerMessage structure (in A1 register).

DM_ItemsHandlerMessage structure looks like this:

struct DM_ItemsHandlerMessage
{
 APTR UserData;             /* UserData value of selected option
                               (nm_UserData field of NewMenu structure) */
};

@endnode
@node "DM_Get_CxBase"
									   (V1)
@{u}DM_Get_CxBase@{uu} - auto-opening of commodities.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_DepthMenuBase"
									   (V1)
@{u}DM_Get_DepthMenuBase@{uu} - auto-opening of @{"depthmenu.library" link bibl}.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_DOSBase"
									   (V1)
@{u}DM_Get_DOSBase@{uu} - auto-opening of dos.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_IconBase"
									   (V1)
@{u}DM_Get_IconBase@{uu} - auto-opening of icon.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_IntuitionBase"
									   (V1)
@{u}DM_Get_IntuitionBase@{uu} - auto-opening of intuition.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_LayersBase"
									   (V1)
@{u}DM_Get_LayersBase@{uu} - auto-opening of layers.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_LocaleBase"
									   (V1)
@{u}DM_Get_LocaleBase@{uu} - auto-opening of locale.library V38.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_SysBase"
									   (V1)
@{u}DM_Get_SysBase@{uu} - auto-opening of exec.library V0.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_UtilityBase"
									   (V1)
@{u}DM_Get_UtilityBase@{uu} - auto-opening of utility.library V39.

  It  is  used for automatic initialization of library base variable. _Pointer_
to  base variable should be given as argument (ti_Data). Thanks to this tag you
don't have to open and close library yourself.

@endnode
@node "DM_Get_Language"
									   (V3)
@{u}DM_Get_Language@{uu} - obtaining language name.

  It  is  used  for obtaining language name, that is actualy used by DepthMenu.
_Pointer_  to STRPTR variable should be given as argument (ti_Data). The result
can  be  used  as  argument for locale.library/OpenCatalog()'s OC_Language tag.
Thanks  to  this  the  module will use the same language (if it's available) as
main program.

@endnode
@node bibl "depthmenu.library"

  @{b}Depthmenu.library@{ub}  is dynamicaly created in memory during start of DepthMenu.
It contains functions shown below.


    @{b}Functions which handle dynamic modules:@{ub}

    @{" DM_AddModule()           " link dm_addmodule()          }  @{" DM_RemModule()           " link dm_remmodule()}


    @{b}Functions which handle menus/items:@{ub}

    @{" DM_CreateItemsNewMenuA() " link dm_createitemsnewmenua()}  @{" DM_FreeItems()           " link dm_freeitems()}


  You  can  also access some interesting information through this library base.
Here is a structure of depthmenu.library's base:

struct DepthMenuBase
{
 struct Library Library;     /* lib_Version field contains maximal version of
                                handled API */

 struct MinList *Modules;    /* (V3) list of @{b}DM_ModuleNode@{ub} structures (see
                                below) describing all modules loaded or added
                                at the moment */

 UWORD DynamicModulesCnt;    /* (V3) number of @{"dynamic" link dyna} modules added at the
                                moment */
};

struct DM_ModuleNode
{
 struct Node Node;           /* ln_Pri field contains module priority */

 struct DM_Module *Module;   /* pointer to main structure of module */
};

@{b}WARNING!@{ub}
  Remember  to  enter  number  of requested API version as version argument for
OpenLibrary()  function  during  library  opening  (API version depends on what
functions you want to use).

@endnode
@node "DM_AddModule()"
									   (V1)
@{u}DM_AddModule()@{uu} - adding new module to the list of modules

ULONG DM_AddModule(struct DM_Module *module);
 D0                          A0


  It  is  used  to add new module to the list of modules of DepthMenu. The only
argument  here  is  pointer  to  properly  filled @{"DM_Module" link dyna} structure. Function
returns NULL when everything was OK, otherwise one of following error codes:

@{b}DM_ERROR_NOT_A_MODULE@{ub}
argument passed to function not points to module,

@{b}DM_ERROR_BAD_API_VERSION@{ub}
API version handled by DepthMenu is too old for this module,

@{b}DM_ERROR_SETUP_FAILED@{ub}
hook defined by @{"DM_Hook_Setup" link dm_hook_setup} tag returned FALSE,

@{b}DM_ERROR_ALREADY_EXISTS@{ub} (V3)
attempt to add already added module detected,

@{b}DM_ERROR_OUT_OF_MEMORY@{ub} (V3)
not enough memory to perform operation.


@{b}WARNING!@{ub}  It  is  not allowed to close depthmenu.library unless all modules you
added are @{"removed" link dm_remmodule()}.

@endnode
@node "DM_RemModule()"
									   (V1)
@{u}DM_RemModule()@{uu} - removing module from the list of modules

ULONG DM_RemModule(struct DM_Module *module);
 D0                          A0


  It  is  used to remove module from the list of modules of DepthMenu. The only
argument is pointer to @{"DM_Module" link dyna} structure of previously added module. Function
returns NULL when everything was OK, otherwise error code:

@{b}DM_ERROR_CLEANUP_FAILED@{ub}
hook defined by @{"DM_Hook_Cleanup" link dm_hook_cleanup} tag returned FALSE,

@{b}DM_ERROR_DOESNT_EXISTS@{ub}
given module has not been added by @{"DM_AddModule()" link dm_addmodule()} function before.

@endnode
@node "DM_CreateItemsNewMenuA()"
									   (V3)
@{U}DM_CreateItemsNewMenuA()@{UU} - creating menus/items from NewMenu structures

APTR DM_CreateItemsNewMenuA(struct NewMenu *newmenu, struct TagItem *tags);
 D0                          A0                       A1

APTR DM_CreateItemsNewMenu(struct NewMenu *newmenu, ULONG tag1, ...);


  It  is  used  to  create  menu  which  you  can  use  in  hook defined by tag
@{"DM_Hook_WindowItems" link DM_Hook_WindowItems} or tag @{"DM_Hook_ScreenItems" link DM_Hook_ScreenItems}. Function has two arguments. As
the first one (newmenu) pointer to array of filled NewMenu structures should be
given. I'm not going to describe this structure here as it is standard one used
to  create menus. You can find more about it in @{b}gadtools.library@{ub} documentation.
The second argument (tags) is a list of tags:

@{u}DM_RootItemLabel@{uu}
Allows  to place created menu in submenu. As argument of this tag (ti_Data) you
should give a name of this submenu.

  Function  returns  pointer  to  created  menu  (black box) or NULL in case of
memory shortage.

@endnode
@node "DM_FreeItems()"
									   (V3)
@{u}DM_FreeItems()@{uu} - removing of menus/items

void DM_FreeItems(APTR items);
                      A0


  It  is  used to remove previously created menu from memory. The only argument
is value returned by function which creates menu.

@endnode
