'\" @(#)cdecl.1	2.4 3/30/88
.TH CDECL 1
.SH NAME
cdecl, c++decl \- Compose C and C++ type declarations
.SH SYNOPSIS
.B cdecl
[\-a | \-+ | \-p | \-r]
[\-cidDV]
.br
.RS .5i
.RI [[ files
\&...] |
.B explain
\&... |
.B declare
\&... |
.B cast
\&... |
.B set
\&... |
.B help
\&... |
.B ?
\&... ]
.RE
.br
.B c++decl
[\-a | \-+ | \-p | \-r]
[\-cidDV]
.br
.RS .5i
.RI [[ files
\&...] |
.B explain
\&... |
.B declare
\&... |
.B cast
\&... |
.B set
\&... |
.B help
\&... |
.B ?
\&... ]
.RE
.br
.B explain
\&...
.br
.B declare
\&...
.br
.B cast
\&...
.SH DESCRIPTION
.I Cdecl
(and
.I c++decl )
is a program for encoding and decoding C (C++) type-declarations.
The C language (the default for 
.I cdecl ,
or with the
.B \-a
option) is based on the (draft proposed) X3J11 ANSI
Standard;
optionally, the C language may be based on the pre-ANSI definition defined by
Kernighan & Ritchie's 
.I "The C Programming Language"
book (the
.B \-p
option is used), or
the C language defined by the Ritchie PDP-11 C compiler (the
.B \-r
option is used).
The C++ language (the default for
.I c++decl ,
or with the
.B \-+
option) is based on Stroustrup's
.IR "The C++ Programming Language" ,
plus the version 2.0 additions to the language.
.PP
.I Cdecl
reads the named files for statements in the language described below.
A transformation is made from that language to C (C++) or pseudo-English.
The results of this transformation are written on standard output.
If no files are named, or a filename of ``\-'' is encountered, standard input
will be read.
If standard input is coming from a terminal, (or the
.B \-i
option is used), a prompt will be written to the terminal before each line.
If
.I cdecl
is invoked as 
.IR explain ,
.IR declare
or
.IR cast ,
or the first argument is one of the commands discussed below, the argument
list will be interpreted according to the grammar shown below instead of as
file names.
.PP
You can use
.I cdecl
as you create a C program with an editor like vi(1) or emacs(1).
You simply type in the pseudo-English version of the declaration and apply
.I cdecl
as a filter to the line.
(In vi(1), type ``!!cdecl<cr>''.)
.PP
If the 
.I "create program"
option
.B \-c
is used, the output will include semi-colons after variable declarations and
curly brace pairs after function declarations.
.PP
The
.B \-V
option will print out the version numbers of the files used to create the
process.
If the source is compiled with debugging information turned on, the
.B \-d
option will enable it to be output.
If the source is compiled with YACC debugging information turned on, the
.B \-D
option will enable it to be output.
.SH "COMMAND LANGUAGE"
There are six statements in the language.
The
.I "declare"
statement composes a C type-declaration from a verbose description.
The
.I "cast"
statement composes a C type-cast as might appear in an expression.
The
.I "explain"
statement decodes a C type-declaration or cast, producing a verbose
description.
The
.I "help"
(or
.IR ? )
statement provides a help message.
The
.I "quit"
(or
.IR "exit" )
statement (or the end of file) exits the program.
The
.I "set"
statement allows the command line options to be set interactively.
Each statement is separated by a semi-colon or a newline.
.PP
The following grammar describes the language.
In the grammar, words in "<>" are non-terminals,
bare lower-case words are terminals that stand for themselves.
Bare upper-case words are other lexical tokens:
NOTHING means the empty string;
NAME means a C identifier;
NUMBER means a string of decimal digits; and
NL means the new-line or semi-colon characters.
.PP
Some synonyms are permitted during a declaration:
character \(-> char,
constant \(-> const,
enumeration \(-> enum,
func \(-> function,
integer \(-> int,
ptr \(-> pointer,
ref \(-> reference,
ret \(-> returning,
structure \(-> struct,
and
vector \(-> array.
.PP
.nf
.ft CW
.ta .5i 1.5i
	<program>	::= NOTHING
		| <program> <stmt> NL
	<stmt>	::= NOTHING
		| declare NAME as <adecl>
		| declare <adecl>
		| cast NAME into <adecl>
		| cast <adecl>
		| explain <optstorage> <ptrmodlist> <type> <cdecl>
		| explain <storage> <ptrmodlist> <cdecl>
		| explain ( <ptrmodlist> <type> <cast> ) optional-NAME
		| set <options>
		| help | ?
		| quit
		| exit
	<adecl>	::= array of <adecl>
		| array NUMBER of <adecl>
		| function returning <adecl>
		| function ( <adecl-list> ) returning <adecl>
		| <ptrmodlist> pointer to <adecl>
		| <ptrmodlist> pointer to member of class NAME <adecl>
		| <ptrmodlist> reference to <adecl>
		| <ptrmodlist> <type>
	<cdecl>	::= <cdecl1>
		| * <ptrmodlist> <cdecl>
		| NAME :: * <cdecl>
		| & <ptrmodlist> <cdecl>
	<cdecl1>	::= <cdecl1> ( )
		| <cdecl1> ( <castlist> )
		| <cdecl1> [ ]
		| <cdecl1> [ NUMBER ]
		| ( <cdecl> )
		| NAME
	<cast>	::= NOTHING
		| ( )
		| ( <cast> ) ( )
		| ( <cast> ) ( <castlist> )
		| ( <cast> )
		| NAME :: * <cast>
		| * <cast>
		| & <cast>
		| <cast> [ ]
		| <cast> [ NUMBER ]
	<type>	::= <typename> | <modlist>
		| <modlist> <typename>
		| struct NAME | union NAME | enum NAME | class NAME
	<castlist>	::= <castlist> , <castlist>
		| <ptrmodlist> <type> <cast>
		| <name>
	<adecllist>	::= <adecllist> , <adecllist>
		| NOTHING
		| <name>
		| <adecl>
		| <name> as <adecl>
	<typename>	::= int | char | double | float | void
	<modlist>	::= <modifier> | <modlist> <modifier>
	<modifier>	::= short | long | unsigned | signed | <ptrmod>
	<ptrmodlist>	::= <ptrmod> <ptrmodlist> | NOTHING
	<ptrmod>	::= const | volatile | noalias
	<storage>	::= auto | extern | register | auto
	<optstorage>	::= NOTHING | <storage>
	<options>	::= NOTHING | <options>
		| create | nocreate
		| interactive | nointeractive
		| ritchie | preansi | ansi | cplusplus
		| debug | nodebug | yydebug | noyydebug
.ft P
.fi
.SH EXAMPLES
.de Ex
.    PP
.    RS .5i
..
.de Ee
.    RE
.    PP
..
To declare an array of pointers to functions like malloc(3), do
.Ex
declare fptab as array of pointer to function returning pointer to char
.Ee
The result of this command is
.Ex
char *(*fptab[])()
.Ee
When you see this declaration in someone else's code, you
can make sense out of it by doing
.Ex
explain char *(*fptab[])()
.Ee
The proper declaration for signal(2), ignoring function prototypes, is easily
described in
.IR cdecl 's
language:
.Ex
declare signal as function returning pointer to function returning void
.Ee
which produces
.Ex
void (*signal())()
.Ee
The function declaration that results has two sets of empty parentheses.
The author of such a function might wonder where to put the parameters:
.Ex
declare signal as function (arg1,arg2) returning pointer to function returning
void
.Ee
provides the following solution (when run with the
.I \-c
option):
.Ex
void (*signal(arg1,arg2))()
{
}
.Ee
If we want to add in the function prototypes, the function prototype for a
function such as _exit(2) would be declared with:
.Ex
declare _exit as function (retvalue as int) returning void
.Ee
giving
.Ex
void _exit(int retvalue)
{
}
.Ee
As a more complex example using function prototypes, signal(2) could be fully
defined as:
.Ex
declare signal as function(x as int, y as pointer to function(int)
returning void) returning pointer to function(int) returning void
.Ee
giving (with \-c)
.Ex
void (*signal(int x, void (*y)(int )))(int )
{
}
.Ee
.I Cdecl
can help figure out the where to put the "const" and "volatile" modifiers
in declarations, thus
.Ex
declare foo as pointer to const int
.Ee
gives
.Ex
const int *foo
.Ee
while
.Ex
declare foo as const pointer to int
.Ee
gives
.Ex
int * const foo
.Ee
.I C++decl
can help with declaring references, thus
.Ex
declare x as reference to pointer to character
.Ee
gives
.Ex
char *&x
.Ee
.I C++decl
can help with pointers to member of classes, thus
declaring a pointer to an integer member of a class X with
.Ex
declare foo as pointer to member of class X int
.Ee
gives
.Ex
int X::*foo
.Ee
and
.Ex
declare foo as pointer to member of class X function (arg1, arg2) returning
pointer to class Y
.Ee
gives
.Ex
class Y *(X::*foo)(arg1, arg2)
.Ee
.SH DIAGNOSTICS
The declare, cast and explain statements try to point out constructions that
are not supported in C.
In some cases, a guess is made as to what was really intended.
In these cases, the C result is a toy declaration whose semantics will work
only in Algol-68.
The list of unsupported C constructs is dependent on which version of the C
language is being used (see the ANSI, pre-ANSI, and Ritchie options).
The set of supported C++ constructs is a superset of the ANSI set, with the
exception of the
.B noalias
keyword.
.SH "SEE ALSO"
(draft proposed) ANSI National Standard X3J11
.sp
\(sc8.4 of the C Reference Manual within
.I "The C Programming Language"
by B. Kernighan & D. Ritchie.
.sp
\(sc8 of the C++ Reference Manual within
.I "The C++ Programming Language"
by B. Stroustrup.
.SH CAVEATS
The pseudo-English syntax is excessively verbose.
.PP
There is a wealth of semantic checking that isn't being done.
.PP
.I Cdecl's
scope is intentionally small.
It doesn't help you figure out initializations.
It expects storage classes to be at the beginning of a declaration,
followed by the the const, volatile and noalias modifiers, followed by the
type of the variable.
.I Cdecl
doesn't know anything about variable length argument lists.
(This includes the ``\f(CW,...\fP'' syntax.)
.PP
.I Cdecl
thinks all the declarations you utter are going to be used as external
definitions.
Some declaration contexts in C allow more flexibility than this.
An example of this is:
.Ex
declare argv as array of array of char
.Ee
where
.I cdecl
responds with
.Ex
.nf
Warning: Unsupported in C -- 'Inner array of unspecified size'
        (maybe you mean "array of pointer")
char argv[][]
.fi
.Ee
.PP
Tentative support for the
.I noalias
keyword has been put in because it is in the current ANSI specifications.
