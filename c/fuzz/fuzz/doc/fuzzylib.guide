@database "fuzzylib"
@master "Home:SAS-C/fuzzlib/src/doc/fuzzylib.doc"

@Node Main "fuzzylib.doc"
    @{" FL_Action() " Link "FL_Action()"}
    @{" FL_Action_Execute() " Link "FL_Action_Execute()"}
    @{" FL_Action_XExecute() " Link "FL_Action_XExecute()"}
    @{" FL_Add_Action() " Link "FL_Add_Action()"}
    @{" FL_Add_Clause() " Link "FL_Add_Clause()"}
    @{" FL_Add_Condition() " Link "FL_Add_Condition()"}
    @{" FL_Add_Memfunc() " Link "FL_Add_Memfunc()"}
    @{" FL_Add_Memfuncs() " Link "FL_Add_Memfuncs()"}
    @{" FL_Add_Object() " Link "FL_Add_Object()"}
    @{" FL_Add_Objects() " Link "FL_Add_Objects()"}
    @{" FL_Add_Rule() " Link "FL_Add_Rule()"}
    @{" FL_Add_Subset() " Link "FL_Add_Subset()"}
    @{" FL_Add_Variable() " Link "FL_Add_Variable()"}
    @{" FL_Add_Variables() " Link "FL_Add_Variables()"}
    @{" FL_Check_System() " Link "FL_Check_System()"}
    @{" FL_Clause() " Link "FL_Clause()"}
    @{" FL_Clause_Evaluate() " Link "FL_Clause_Evaluate()"}
    @{" FL_Clause_XEvaluate() " Link "FL_Clause_XEvaluate()"}
    @{" FL_Cleanup() " Link "FL_Cleanup()"}
    @{" FL_Clone_Action() " Link "FL_Clone_Action()"}
    @{" FL_Clone_Actions() " Link "FL_Clone_Actions()"}
    @{" FL_Clone_Clause() " Link "FL_Clone_Clause()"}
    @{" FL_Clone_Clauses() " Link "FL_Clone_Clauses()"}
    @{" FL_Clone_Condition() " Link "FL_Clone_Condition()"}
    @{" FL_Clone_Conditions() " Link "FL_Clone_Conditions()"}
    @{" FL_Clone_Memfunc() " Link "FL_Clone_Memfunc()"}
    @{" FL_Clone_Memfuncs() " Link "FL_Clone_Memfuncs()"}
    @{" FL_Clone_Object() " Link "FL_Clone_Object()"}
    @{" FL_Clone_Objects() " Link "FL_Clone_Objects()"}
    @{" FL_Clone_Rule() " Link "FL_Clone_Rule()"}
    @{" FL_Clone_Rules() " Link "FL_Clone_Rules()"}
    @{" FL_Clone_Subset() " Link "FL_Clone_Subset()"}
    @{" FL_Clone_Subsets() " Link "FL_Clone_Subsets()"}
    @{" FL_Clone_System() " Link "FL_Clone_System()"}
    @{" FL_Clone_Variable() " Link "FL_Clone_Variable()"}
    @{" FL_Clone_Variables() " Link "FL_Clone_Variables()"}
    @{" FL_Condition() " Link "FL_Condition()"}
    @{" FL_Condition_Evaluate() " Link "FL_Condition_Evaluate()"}
    @{" FL_Condition_XEvaluate() " Link "FL_Condition_XEvaluate()"}
    @{" FL_Get_Clause() " Link "FL_Get_Clause()"}
    @{" FL_Get_Memfunc() " Link "FL_Get_Memfunc()"}
    @{" FL_Get_Object() " Link "FL_Get_Object()"}
    @{" FL_Get_Rule() " Link "FL_Get_Rule()"}
    @{" FL_Get_Subset() " Link "FL_Get_Subset()"}
    @{" FL_Get_Variable() " Link "FL_Get_Variable()"}
    @{" FL_Get_Variables() " Link "FL_Get_Variables()"}
    @{" FL_Geterror() " Link "FL_Geterror()"}
    @{" FL_GeterrorName() " Link "FL_GeterrorName()"}
    @{" FL_GeterrorText() " Link "FL_GeterrorText()"}
    @{" FL_Getinfo() " Link "FL_Getinfo()"}
    @{" FL_Initialize() " Link "FL_Initialize()"}
    @{" FL_Kill_Clause() " Link "FL_Kill_Clause()"}
    @{" FL_Kill_Memfunc() " Link "FL_Kill_Memfunc()"}
    @{" FL_Kill_Object() " Link "FL_Kill_Object()"}
    @{" FL_Kill_Rule() " Link "FL_Kill_Rule()"}
    @{" FL_Kill_System() " Link "FL_Kill_System()"}
    @{" FL_Memfunc() " Link "FL_Memfunc()"}
    @{" FL_Object() " Link "FL_Object()"}
    @{" FL_Object_Evaluate() " Link "FL_Object_Evaluate()"}
    @{" FL_Object_Run() " Link "FL_Object_Run()"}
    @{" FL_Object_XEvaluate() " Link "FL_Object_XEvaluate()"}
    @{" FL_Read_Action() " Link "FL_Read_Action()"}
    @{" FL_Read_Clause() " Link "FL_Read_Clause()"}
    @{" FL_Read_Condition() " Link "FL_Read_Condition()"}
    @{" FL_Read_Memfunc() " Link "FL_Read_Memfunc()"}
    @{" FL_Read_Object() " Link "FL_Read_Object()"}
    @{" FL_Read_Rule() " Link "FL_Read_Rule()"}
    @{" FL_Read_Subset() " Link "FL_Read_Subset()"}
    @{" FL_Read_System() " Link "FL_Read_System()"}
    @{" FL_Read_Variable() " Link "FL_Read_Variable()"}
    @{" FL_Revise_Objects() " Link "FL_Revise_Objects()"}
    @{" FL_Revise_Variables() " Link "FL_Revise_Variables()"}
    @{" FL_Rule() " Link "FL_Rule()"}
    @{" FL_Rule_Evaluate() " Link "FL_Rule_Evaluate()"}
    @{" FL_Rule_XEvaluate() " Link "FL_Rule_XEvaluate()"}
    @{" FL_Set_Variable() " Link "FL_Set_Variable()"}
    @{" FL_Set_VariableByIndex() " Link "FL_Set_VariableByIndex()"}
    @{" FL_Set_Variables() " Link "FL_Set_Variables()"}
    @{" FL_Subset() " Link "FL_Subset()"}
    @{" FL_Subset_Init() " Link "FL_Subset_Init()"}
    @{" FL_Subset_Memship() " Link "FL_Subset_Memship()"}
    @{" FL_System() " Link "FL_System()"}
    @{" FL_System_Reset() " Link "FL_System_Reset()"}
    @{" FL_System_Run() " Link "FL_System_Run()"}
    @{" FL_System_XRun() " Link "FL_System_XRun()"}
    @{" FL_Variable() " Link "FL_Variable()"}
    @{" FL_Variable_Evaluate() " Link "FL_Variable_Evaluate()"}
    @{" FL_Variable_Get() " Link "FL_Variable_Get()"}
    @{" FL_Variable_Index() " Link "FL_Variable_Index()"}
    @{" FL_Variable_Reset() " Link "FL_Variable_Reset()"}
    @{" FL_Variable_Set() " Link "FL_Variable_Set()"}
    @{" FL_Variable_XEvaluate() " Link "FL_Variable_XEvaluate()"}
    @{" FL_Write_Action() " Link "FL_Write_Action()"}
    @{" FL_Write_Clause() " Link "FL_Write_Clause()"}
    @{" FL_Write_Condition() " Link "FL_Write_Condition()"}
    @{" FL_Write_Memfunc() " Link "FL_Write_Memfunc()"}
    @{" FL_Write_Object() " Link "FL_Write_Object()"}
    @{" FL_Write_Rule() " Link "FL_Write_Rule()"}
    @{" FL_Write_Subset() " Link "FL_Write_Subset()"}
    @{" FL_Write_System() " Link "FL_Write_System()"}
    @{" FL_Rule() " Link "FL_Rule()"}
    @{" FL_Clone_Rule() " Link "FL_Clone_Rule()"}
    @{" FL_Clone_Rules() " Link "FL_Clone_Rules()"}
    @{" FL_Get_Rule() " Link "FL_Get_Rule()"}
    @{" FL_Kill_Rule() " Link "FL_Kill_Rule()"}
    @{" FL_Read_Rule() " Link "FL_Read_Rule()"}
    @{" FL_Rule_Evaluate() " Link "FL_Rule_Evaluate()"}
    @{" FL_Rule_XEvaluate() " Link "FL_Rule_XEvaluate()"}
    @{" FL_Add_Rule() " Link "FL_Add_Rule()"}
    @{" FL_Variable_Set() " Link "FL_Variable_Set()"}
    @{" FL_Write_Rule() " Link "FL_Write_Rule()"}
    @{" FL_Write_Variable() " Link "FL_Write_Variable()"}
@EndNode

@Node "FL_Action()" "fuzzy.lib/FL_Action"

@{b}   NAME        @{ub}
       FL_Action -- Initialize a fuzzy action

@{b}   SYNOPSIS    @{ub}
       fuzzyaction = FL_Action(name)

       struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *FL_Action(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a fuzzyaction with name "name".

@{b}   INPUTS@{ub}
       Name of the fuzzyaction

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized action or 0 if not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Action_Execute()" "fuzzy.lib/FL_Action_Execute"

@{b}   NAME        @{ub}
       FL_Action_Execute -- Execute the consequent of a fuzzy rule

@{b}   SYNOPSIS    @{ub}
       result = FL_Action_Execute(action, degree_of_belief)

       int FL_Action_Execute(struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *, double)

@{b}   FUNCTION@{ub}
       Evaluate the consequent of a rule, i.e., set the variables used in tha
t
       rule according to the definitions and the degree of belief assigned to
       the rule's premises

@{b}   INPUTS@{ub}
       Pointer to the fuzzyaction, degree of belief 

@{b}   RESULTS@{ub}
       Returns 1 if the evaluation was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Action_XExecute()" "fuzzy.lib/FL_Action_XExecute"

@{b}   NAME        @{ub}
       FL_Action_Execute -- XExecute the consequent of a fuzzy rule QUICKLY

@{b}   SYNOPSIS    @{ub}
       result = FL_Action_XExecute(action, degree_of_belief)

       int FL_Action_XExecute(struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *, double)

@{b}   FUNCTION@{ub}
       Evaluate the consequent of a rule, i.e., set the variables used in tha
t
       rule according to the definitions and the degree of belief assigned to
       the rule's premises

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING

@{b}   INPUTS@{ub}
       Pointer to the fuzzyaction, degree of belief 

@{b}   RESULTS@{ub}
       Returns 1

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Add_Action()" "fuzzy.lib/FL_Add_Action"

@{b}   NAME        @{ub}
       FL_Add_Action -- Add a fuzzy action to a rule as a consequent

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Action(fuzzysystem, objectname, rulename, actionname,
                              variable, linguistic_term)

       int FL_Add_Action(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *, char *, char *, 
char *)

@{b}   FUNCTION@{ub}
       Add the action "variable IS_FUZZY linguistic_term" with name "actionna
me" to the 
       rule "rulename" belonging to the fuzzyobject "objectname". The action 
is evaluated
       in a fuzzy way, i.e., the crisp value of the variable is calculated by
 means of
       the defuzzification method assigned to the fuzzyobject.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of object, rule, and actio
n. 
       Name of variable to be set and name of linguistic term (the latter mus
t belong
       to the membershipfunction/type of the variable)

@{b}   RESULTS@{ub}
       Returns 1 if the action was added successfully, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Clause()" "fuzzy.lib/FL_Add_Clause"

@{b}   NAME        @{ub}
       FL_Add_Clause -- Add a clause to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Clause(fuzzysystem,object,rule,clause)

       int FL_Add_Clause(struct FL_system*, char *, char *, char *)

@{b}   FUNCTION@{ub}
       Add a clause to a the rule "rule" belonging to the object "object".

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the fuzzyobject,
       name of fuzzyrule, name of new clause.

@{b}   RESULTS@{ub}
       Returns 1 if the clause was added or 0 if the action was not succesful
.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Condition()" "fuzzy.lib/FL_Add_Condition"

@{b}   NAME        @{ub}
       FL_Add_Condition -- Add a fuzzy condition to a rule as a consequent

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Condition(fuzzysystem, objectname, rulename, clausenam
e,
                                 conditionname, variable, operator, linguisti
c_term)

       int FL_Add_Condition(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *, char *, char 
*, 
                            char *, enum FL_operator, char *)

@{b}   FUNCTION@{ub}
       Add the condition "IF variable operator linguistic_term" with name "co
nditionname" to 
       the clause "clausename" of rule "rulename" belonging to the fuzzyobjec
t "objectname". 
       The condition is evaluated in a fuzzy way, i.e., the crisp value of th
e variable is 
       calculated by means of the defuzzification method assigned to the fuzz
yobject.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of object, rule, clause, a
nd condition. 
       Name of variable to be set and name of linguistic term (the latter mus
t belong
       to the membershipfunction/type of the variable)

@{b}   RESULTS@{ub}
       Returns 1 if the condition was added successfully, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Memfunc()" "fuzzy.lib/FL_Add_Memfunc"

@{b}   NAME        @{ub}
       FL_Add_Memfunc -- Add a membership function to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Memfunc(fuzzysystem, memfuncname)

       int FL_Add_Memfunc(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *)

@{b}   FUNCTION@{ub}
       Add a membership function to the fuzzysystem with name "memfuncname".

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of membership function.

@{b}   RESULTS@{ub}
       Returns 1 if the membership function was added successfully, 0 otherwi
se.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Memfuncs()" "fuzzy.lib/FL_Add_Memfuncs"

@{b}   NAME        @{ub}
       FL_Add_Memfuncs -- Add a list of membership functions to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Memfuncs(fuzzysystem, memfuncname, ...)

       int FL_Add_Memfunc(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, ..., char*)

@{b}   FUNCTION@{ub}
       Add a list of membership functions to the fuzzysystem.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of membership functions, 0
.

@{b}   RESULTS@{ub}
       Returns 1 if the membership functions were added successfully, 0 other
wise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Object()" "fuzzy.lib/FL_Add_Object"

@{b}   NAME        @{ub}
       FL_Add_Object -- Add a fuzzyobject to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Object(fuzzysystem,name,evaluationmethod)

       int FL_Add_Object(struct FL_system*, char *, enum FL_evalmethod)

@{b}   FUNCTION@{ub}
       Add a fuzzy object to a fuzzy system, allocate memory for the object a
nd
       set the fuzzyobject's evaluation method.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the new fuzzyobject, e
valuation
       method.

@{b}   RESULTS@{ub}
       Returns 1 if the object was added or 0 if the action was not succesful
.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Objects()" "fuzzy.lib/FL_Add_Objects"

@{b}   NAME        @{ub}
       FL_Add_Objects -- Add a list of fuzzyobjects to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Objects(fuzzysystem,name,evaluationmethod, ... ,0,0)

       int FL_Add_Objects(struct FL_system*, char *, enum FL_evalmethod,
                          char *, enum FL_evalmethod, ... ,0,0)

@{b}   FUNCTION@{ub}
       Add several fuzzy objects to a fuzzy system, allocate memory for the o
bjects and
       set the fuzzyobjects' evaluation methods. After the variable number of
 objects,
       the parameter list must contain two 0s.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, list of tuples 
       (name of the new fuzzyobject, evaluation method), 0,0.

@{b}   RESULTS@{ub}
       Returns 1 if the objects were added or 0 if the action was not succesf
ul.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Rule()" "fuzzy.lib/FL_Add_Rule"

@{b}   NAME        @{ub}
       FL_Add_Rule -- Add a rule to a fuzzy object

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Rule(fuzzysystem, objectname, rulename)

       int FL_Add_Rule(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *)

@{b}   FUNCTION@{ub}
       Add a fuzzyrule with name <rulename> to the object <objectname>.
       Allocate space for the rule.

@{b}   INPUTS@{ub}
       Pointer to the fuzzysystem
       Name of fuzzy object
       Name of rule

@{b}   OUTPUTS@{ub}
       If rule could be added, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Add_Subset()" "fuzzy.lib/FL_Add_Subset"

@{b}   NAME        @{ub}
       FL_Add_Subset -- Add a linguistic term to a membership function

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Subset(fuzzysystem, memfuncname, subsetname,
                               type, center, leftspread, rightspread, 
                               degree_of_mem)

       int FL_Add_Subset(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *, enum FL_subsetty
pe,
                         double, double, double, double)

@{b}   FUNCTION@{ub}
       Add a linguistic term as "subsetname" to the membership function "memf
uncname"
       and initialize it according to the given parameters.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of membership function,
       name of the linguistic term, parameters for the initialization.

@{b}   RESULTS@{ub}
       Returns 1 if the linguistic term was added successfully, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Variable()" "fuzzy.lib/FL_Add_Variable"

@{b}   NAME        @{ub}
       FL_Add_Variable -- Add a linguistic variable to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Variable(fuzzysystem, variablename, memfuncname, defau
lt_value)

       int FL_Add_Variable(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *, double)

@{b}   FUNCTION@{ub}
       Add a variable to the fuzzysystem with name "variablename". The type o
f the variable
       is set to the memfunc "memfuncname". The variable's default value is s
et to 
       "default_value".

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, name of variable, name of membe
rship function 
       (must exist!), and default value.

@{b}   RESULTS@{ub}
       Returns 1 if the variable was added successfully, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Add_Variables()" "fuzzy.lib/FL_Add_Variables"

@{b}   NAME        @{ub}
       FL_Add_Variables -- Add several linguistic variables to a fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Variable(fuzzysystem, variablename, memfuncname, 
                                default_value,... , 0,0)

       int FL_Add_Variable(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *, double, ... , 
0,0)

@{b}   FUNCTION@{ub}
       Add variables to the fuzzysystem with name "variablename". The type of
 the variable
       is set to the memfunc "memfuncname". The variable's default value is s
et to 
       "default_value". The list of variables must end with two 0s.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem, list consisting of 
       (name of variable, name of membership function (must exist!), and defa
ult value), 0,0.

@{b}   RESULTS@{ub}
       Returns 1 if the variables were added successfully, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Check_System()" "fuzzy.lib/FL_Check_System"

@{b}   NAME        @{ub}
       FL_Check_System -- Check system integrity (names only!)

@{b}   SYNOPSIS    @{ub}
       result = FL_Check_System(fuzzysystem)

       int FL_Check_System(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Makes a complete survey of the system, looking for duplicate names of
       membership functions etc.

@{b}   INPUTS@{ub}
       Pointer to the original fuzzysystem

@{b}   RESULTS@{ub}
       Returns 1 if system was ok, 0 otherwise

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clause()" "fuzzy.lib/FL_Clause"

@{b}   NAME        @{ub}
       FL_Clause -- Initialize a clause

@{b}   SYNOPSIS    @{ub}
       clause = FL_Clause(name)

       struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *FL_Clause(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a clause with name "name".

@{b}   INPUTS@{ub}
       Name of the clause

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized clause or 0 if not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Clause_Evaluate()" "fuzzy.lib/FL_Clause_Evaluate"

@{b}   NAME        @{ub}
       FL_Clause_Evaluate -- Evaluate a clause

@{b}   SYNOPSIS    @{ub}
       degree_of_belief = FL_Clause_Evaluate(clause)

       double FL_Clause_Evaluate(struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *)

@{b}   FUNCTION@{ub}
       Evaluate the preconditions belonging to a clause. The degree of belief
 of a clause
       is the maximum of the dob of the individual literals.

@{b}   INPUTS@{ub}
       Pointer to the clause.

@{b}   RESULTS@{ub}
       Returns 1 if the evaluation was successul, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Clause_XEvaluate()" "fuzzy.lib/FL_Clause_XEvaluate"

@{b}   NAME        @{ub}
       FL_Clause_Evaluate -- Evaluate a clause QUICKLY

@{b}   SYNOPSIS    @{ub}
       degree_of_belief = FL_Clause_XEvaluate(clause)

       double FL_Clause_XEvaluate(struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *)

@{b}   FUNCTION@{ub}
       Evaluate the preconditions belonging to a clause. The degree of belief
 of a clause
       is the maximum of the dob of the individual literals.

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING

@{b}   INPUTS@{ub}
       Pointer to the clause.

@{b}   RESULTS@{ub}
       Returns 1

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Cleanup()" "fuzzy.lib/FL_Cleanup"

@{b}   NAME        @{ub}
       FL_Cleanup -- Free all memory that has been used by FCT

@{b}   SYNOPSIS    @{ub}
       result = FL_Cleanup()

       int FL_Cleanup(void)

@{b}   FUNCTION@{ub}
       Free all resources used by FCT

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns 1 if successful, 0 otherwise

@EndNode

@Node "FL_Clone_Action()" "fuzzy.lib/FL_Clone_Action"

@{b}   NAME        @{ub}
       FL_Clone_Action -- Make an identical copy of a action

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Action(action)

       struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *FL_Clone_Action(struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *)

@{b}   FUNCTION@{ub}
       Allocates memory for the action

@{b}   INPUTS@{ub}
       Pointer to original action

@{b}   RESULTS@{ub}
       Pointer to clone

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Actions()" "fuzzy.lib/FL_Clone_Actions"

@{b}   NAME        @{ub}
       FL_Clone_Actions -- Make an identical copy of a list of actions

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Action(actionlist,num_actions)

       struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *FL_Clone_Action(struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of actions

@{b}   INPUTS@{ub}
       Pointer to first original action, number of actions in array

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Clause()" "fuzzy.lib/FL_Clone_Clause"

@{b}   NAME        @{ub}
       FL_Clone_Clause -- Make an identical copy of a clause

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Clause(fuzzyclause)

       struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *FL_Clone_Clause(struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *)

@{b}   FUNCTION@{ub}
       Allocates memory for both the membership function and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to original membership function

@{b}   RESULTS@{ub}
       Pointer to clone


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Clauses()" "fuzzy.lib/FL_Clone_Clauses"

@{b}   NAME        @{ub}
       FL_Clone_Clauses -- Make an identical copy of a list of clauses

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Clause(fuzzyclauselist,num_clauses)

       struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *FL_Clone_Clause(struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of membership clauses and the 
       associated conditions.

@{b}   INPUTS@{ub}
       Pointer to first original membership function, number of clauses in ar
ray

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Condition()" "fuzzy.lib/FL_Clone_Condition"

@{b}   NAME        @{ub}
       FL_Clone_Condition -- Make an identical copy of a condition

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Condition(condition)

       struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *FL_Clone_Condition(struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *)

@{b}   FUNCTION@{ub}
       Allocates memory for the condition

@{b}   INPUTS@{ub}
       Pointer to original condition

@{b}   RESULTS@{ub}
       Pointer to clone

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Conditions()" "fuzzy.lib/FL_Clone_Conditions"

@{b}   NAME        @{ub}
       FL_Clone_Conditions -- Make an identical copy of a list of conditions

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Condition(conditionlist,num_conditions)

       struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *FL_Clone_Condition(struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of conditions

@{b}   INPUTS@{ub}
       Pointer to first original condition, number of conditions in array

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Memfunc()" "fuzzy.lib/FL_Clone_Memfunc"

@{b}   NAME        @{ub}
       FL_Clone_Memfunc -- Make an identical copy of a membership function

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Memfunc(fuzzymemfunc)

       struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *FL_Clone_Memfunc(struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *)

@{b}   FUNCTION@{ub}
       Allocates memory for both the membership function and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to original membership function

@{b}   RESULTS@{ub}
       Pointer to clone


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Memfuncs()" "fuzzy.lib/FL_Clone_Memfuncs"

@{b}   NAME        @{ub}
       FL_Clone_Memfuncs -- Make an identical copy of a list of membership fu
nction

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Memfunc(fuzzymemfunclist,num_memfuncs)

       struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *FL_Clone_Memfunc(struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of membership functions and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to first original membership function, number of memfuncs in a
rray

@{b}   RESULTS@{ub}
       Pointer to cloned array


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Object()" "fuzzy.lib/FL_Clone_Object"

@{b}   NAME        @{ub}
       FL_Clone_Object -- Make an identical copy of a object

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Object(fuzzyobject)

       struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *FL_Clone_Object(struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *)

@{b}   FUNCTION@{ub}
       Allocates memory for both the membership function and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to original membership function

@{b}   RESULTS@{ub}
       Pointer to clone


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Objects()" "fuzzy.lib/FL_Clone_Objects"

@{b}   NAME        @{ub}
       FL_Clone_Objects -- Make an identical copy of a list of objects

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Object(fuzzyobjectlist,num_objects)

       struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *FL_Clone_Object(struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of membership objects and the 
       associated rules.

@{b}   INPUTS@{ub}
       Pointer to first original membership function, number of objects in ar
ray

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Rule()" "fuzzy.lib/FL_Clone_Rule"

@{b}   NAME        @{ub}
       FL_Clone_Rule -- Make an identical copy of a rule

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Rule(fuzzyrule)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Clone_Rule(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Allocates memory for both the membership function and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to original membership function

@{b}   RESULTS@{ub}
       Pointer to clone


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Rules()" "fuzzy.lib/FL_Clone_Rules"

@{b}   NAME        @{ub}
       FL_Clone_Rules -- Make an identical copy of a list of rules

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Rules(fuzzyrulelist,num_rules)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Clone_Rules(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of membership rules and the 
       associated rules.

@{b}   INPUTS@{ub}
       Pointer to first original membership function, number of rules in arra
y

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Subset()" "fuzzy.lib/FL_Clone_Subset"

@{b}   NAME        @{ub}
       FL_Clone_Subset -- Make an identical copy of a subset/linguistic term

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Subset(subset)

       struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *FL_Clone_Subset(struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *)

@{b}   FUNCTION@{ub}
       Allocates memory for the subset

@{b}   INPUTS@{ub}
       Pointer to original subset

@{b}   RESULTS@{ub}
       Pointer to clone

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Subsets()" "fuzzy.lib/FL_Clone_Subsets"

@{b}   NAME        @{ub}
       FL_Clone_Subsets -- Make an identical copy of a list of subsets

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Subset(subsetlist,num_subsets)

       struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *FL_Clone_Subset(struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of subsets

@{b}   INPUTS@{ub}
       Pointer to first original subset, number of subsets in array

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_System()" "fuzzy.lib/FL_Clone_System"

@{b}   NAME        @{ub}
       FL_Clone_System -- Make an identical copy of a fuzzy system

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_System(fuzzysystem)

       struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *FL_Clone_System(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Makes a complete copy (i.e., object, rules, variables, etc. are cloned
)
       of a fuzzysystem

@{b}   INPUTS@{ub}
       Pointer to the original fuzzysystem

@{b}   RESULTS@{ub}
       Returns a pointer to the clone 0 if not succesful.

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Variable()" "fuzzy.lib/FL_Clone_Variable"

@{b}   NAME        @{ub}
       FL_Clone_Variable -- Make an identical copy of a variable

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Variable(variable)

       struct FL_variable *FL_Clone_Variable(struct FL_variable *)

@{b}   FUNCTION@{ub}
       Allocates memory for the variable

@{b}   INPUTS@{ub}
       Pointer to original variable

@{b}   RESULTS@{ub}
       Pointer to clone

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Variables()" "fuzzy.lib/FL_Clone_Variables"

@{b}   NAME        @{ub}
       FL_Clone_Variables -- Make an identical copy of a list of variables

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Variable(variablelist,num_variables)

       struct FL_variable *FL_Clone_Variable(struct FL_variable *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of variables

@{b}   INPUTS@{ub}
       Pointer to first original variable, number of variables in array

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Condition()" "fuzzy.lib/FL_Condition"

@{b}   NAME        @{ub}
       FL_Condition -- Initialize a condition

@{b}   SYNOPSIS    @{ub}
       condition = FL_Condition(name)

       struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *FL_Condition(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a condition with name "name".

@{b}   INPUTS@{ub}
       Name of the condition

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized condition or 0 if not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Condition_Evaluate()" "fuzzy.lib/FL_Condition_Evaluate"

@{b}   NAME        @{ub}
       FL_Condition_Evaluate -- Evaluate a condition

@{b}   SYNOPSIS    @{ub}
       degree_of_belief = FL_Condition_Evaluate(condition)

       double FL_Condition_Evaluate(struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *)

@{b}   FUNCTION@{ub}
       Evaluate a condition. The degree of belief of a condition 
       degree of membership of the corresponding variable to the given subset
.

@{b}   INPUTS@{ub}
       Pointer to the condition.

@{b}   RESULTS@{ub}
       Returns degree of belief of condition [0..1], -1 on error

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Condition_XEvaluate()" "fuzzy.lib/FL_Condition_XEvaluate"

@{b}   NAME        @{ub}
       FL_Condition_XEvaluate -- Evaluate a condition QUICKLY

@{b}   SYNOPSIS    @{ub}
       degree_of_belief = FL_Condition_XEvaluate(condition)

       double FL_Condition_XEvaluate(struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *)

@{b}   FUNCTION@{ub}
       Evaluate a condition. The degree of belief of a condition 
       degree of membership of the corresponding variable to the given subset
.

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING

@{b}   INPUTS@{ub}
       Pointer to the condition.

@{b}   RESULTS@{ub}
       Returns degree of belief of condition [0..1], -1 on error

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Get_Clause()" "fuzzy.lib/FL_Get_Clause"

@{b}   NAME        @{ub}
       FL_Get_Clause -- Get a clause by name

@{b}   SYNOPSIS    @{ub}
       clause = FL_Get_Clause(fuzzysystem,clausename)

       struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *FL_Get_Clause(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the clause with name "name". 

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the clause
       that is to be found.

@{b}   RESULTS@{ub}
       Returns a pointer to the clause 0 if none could be found or the 
       action was not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Get_Memfunc()" "fuzzy.lib/FL_Get_Memfunc"

@{b}   NAME        @{ub}
       FL_Get_Memfunc -- Get a membership function by name

@{b}   SYNOPSIS    @{ub}
       memfunc = FL_Get_Memfunc(fuzzysystem,memfuncname)

       struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *FL_Get_Memfunc(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the membership function with name "memfuncnam
e". 

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the membership functio
n
       that is to be found.

@{b}   RESULTS@{ub}
       Returns a pointer to the membership function or 0 if none could be fou
nd or the 
       action was not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Get_Object()" "fuzzy.lib/FL_Get_Object"

@{b}   NAME        @{ub}
       FL_Get_Object -- Get a fuzzyobject by name

@{b}   SYNOPSIS    @{ub}
       object = FL_Get_Object(fuzzysystem,objectname)

       struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *FL_Get_Object(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the object with name "objectname". 

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the fuzzyobject
       that is to be found.

@{b}   RESULTS@{ub}
       Returns a pointer to the fuzzyobject or 0 if none could be found or th
e 
       action was not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Get_Rule()" "fuzzy.lib/FL_Get_Rule"

@{b}   NAME        @{ub}
       FL_Get_Rule -- Get a specific rule from a fuzzy system/object

@{b}   SYNOPSIS    @{ub}
       rule = FL_Get_Rule(fuzzysystem, objectname, rulename)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Get_Rule(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *)

@{b}   FUNCTION@{ub}
       Get a pointer to a specific rule belonging to a specific object

@{b}   INPUTS@{ub}
       Pointer to the fuzzysystem
       Name of fuzzy object
       Name of rule

@{b}   OUTPUTS@{ub}
       If rule was found, return pointer to rule.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Get_Subset()" "fuzzy.lib/FL_Get_Subset"

@{b}   NAME        @{ub}
       FL_Get_Subset -- Get a linguistic term by name

@{b}   SYNOPSIS    @{ub}
       subset = FL_Get_Subset(fuzzysystem,memfuncname, subsetname)

       struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *FL_Get_Subset(struct FL_system*, char *, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the membership function with name "memfuncnam
e" and
       find the subset "subsetname".

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the membership functio
n and
       the linguistic term that is to be found.

@{b}   RESULTS@{ub}
       Returns a pointer to the linguistic term or 0 if none could be found o
r the 
       action was not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Get_Variable()" "fuzzy.lib/FL_Get_Variable"

@{b}   NAME        @{ub}
       FL_Get_Variable -- Get crisp value of a variable

@{b}   SYNOPSIS    @{ub}
       result = FL_Get_Variable(fuzzysystem,variablename,valuebuffer)

       int FL_Get_Variable(struct FL_system*, char *, double *)
                         

@{b}   FUNCTION@{ub}
       Get the crisp value (as calculated by FL_Evaluate_Variable()) for the 
variable 
       "variablename" and store it in *valuebuffer.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the variable, pointer 
to buffer for
       value.

@{b}   RESULTS@{ub}
       Returns 1 if the value could be read or 0 if none could be found or th
e 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Get_Variables()" "fuzzy.lib/FL_Get_Variables"

@{b}   NAME        @{ub}
       FL_Get_Variables -- Get crisp values of a set of variables

@{b}   SYNOPSIS    @{ub}
       result = FL_Get_Variables(fuzzysystem,variablename,valuebuffer, ..., 0
,0)

       int FL_Get_Variables(struct FL_system*, char *, double *, ..., 0,0)
                         

@{b}   FUNCTION@{ub}
       Get the crisp value (as calculated by FL_Evaluate_Variable()) for a li
st of
       variables described by ("variablename",*valuebuffer).

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, list of 
       (name of the variable, pointer to buffer for value), 0,0.

@{b}   RESULTS@{ub}
       Returns 1 if the values of the variables could be read 0 if none could
 be found or the 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Geterror()" "fuzzy.lib/FL_Geterror"

@{b}   NAME        @{ub}
       FL_Geterror -- Get FCT internal error code

@{b}   SYNOPSIS    @{ub}
       error = FL_Geterror()

       int FL_Geterror(void)

@{b}   FUNCTION@{ub}
       Get FCT internal error code according to the FCT error table.

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns error code.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_GeterrorName()" "fuzzy.lib/FL_GeterrorName"

@{b}   NAME        @{ub}
       FL_GeterrorName -- Get plain text for FCT internal error

@{b}   SYNOPSIS    @{ub}
       errortext = FL_GeterrorName()

       char *FL_GeterrorName(void)

@{b}   FUNCTION@{ub}
       Get FCT error description

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns pointer to error description.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_GeterrorText()" "fuzzy.lib/FL_GeterrorText"

@{b}   NAME        @{ub}
       FL_GeterrorText -- Get additional error information (if available)

@{b}   SYNOPSIS    @{ub}
       errortext = FL_GeterrorText()

       char *FL_GeterrorText(void)

@{b}   FUNCTION@{ub}
       Get FCT error description

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns pointer to error description.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Getinfo()" "fuzzy.lib/FL_Getinfo"

@{b}   NAME        @{ub}
       FL_Getinfo -- Get version information

@{b}   SYNOPSIS    @{ub}
       versionstring = FL_Getversion()

       char *FL_Get(void)

@{b}   FUNCTION@{ub}
       Get version information (e.g., to print it & check lib version in use)

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns a pointer to the FCT version string

@EndNode

@Node "FL_Initialize()" "fuzzy.lib/FL_Initialize"

@{b}   NAME        @{ub}
       FL_Initialize -- Initialize FCT

@{b}   SYNOPSIS    @{ub}
       result = FL_Initialize()

       int FL_Initialize(void)

@{b}   FUNCTION@{ub}
       Initialize FCT, alloc necessary memory, setup structures

@{b}   INPUTS@{ub}
       none

@{b}   RESULTS@{ub}
       Returns 1 if successful, 0 otherwise

@EndNode

@Node "FL_Kill_Clause()" "fuzzy.lib/FL_Kill_Clause"

@{b}   NAME        @{ub}
       FL_Kill_Clause -- Free memory allocated by a fuzzy clause

@{b}   SYNOPSIS    @{ub}
       FL_Kill_Clause(fuzzyclause)

       void FL_Kill_Clause(struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a fuzzyclause.

@{b}   INPUTS@{ub}
       Pointer to fuzzyclause

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Kill_Memfunc()" "fuzzy.lib/FL_Kill_Memfunc"

@{b}   NAME        @{ub}
       FL_Kill_Memfunc -- Free memory allocated by a membership function

@{b}   SYNOPSIS    @{ub}
       FL_Kill_Memfunc(fuzzymemfunc)

       void FL_Kill_Memfunc(struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a membership function

@{b}   INPUTS@{ub}
       Pointer to membership function

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Kill_Object()" "fuzzy.lib/FL_Kill_Object"

@{b}   NAME        @{ub}
       FL_Kill_Object -- Free memory allocated by a fuzzy object

@{b}   SYNOPSIS    @{ub}
       FL_Kill_Object(fuzzyobject)

       void FL_Kill_Object(struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a fuzzyobject.

@{b}   INPUTS@{ub}
       Pointer to fuzzyobject

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Kill_Rule()" "fuzzy.lib/FL_Kill_Rule"

@{b}   NAME        @{ub}
       FL_Kill_Rule -- Free memory allocated by a fuzzy rule

@{b}   SYNOPSIS    @{ub}
       FL_Kill_Rule(fuzzyrule)

       void FL_Kill_Rule(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a fuzzyrule.

@{b}   INPUTS@{ub}
       Pointer to fuzzyrule

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Kill_System()" "fuzzy.lib/FL_Kill_System"

@{b}   NAME        @{ub}
       FL_Kill_System -- Free memory allocated by a fuzzy system

@{b}   SYNOPSIS    @{ub}
       FL_Kill_System(fuzzysystem)

       void FL_Kill_System(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a fuzzysystem.

@{b}   INPUTS@{ub}
       Pointer to fuzzysystem

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Memfunc()" "fuzzy.lib/FL_Memfunc"

@{b}   NAME        @{ub}
       FL_Memfunc -- Initialize a membership function

@{b}   SYNOPSIS    @{ub}
       memfunc = FL_Memfunc(name)

       struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *FL_Memfunc(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a membership function with name "name".

@{b}   INPUTS@{ub}
       Name of the memfunc

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized membership function or 0 if not s
uccessful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Object()" "fuzzy.lib/FL_Object"

@{b}   NAME        @{ub}
       FL_Object -- Initialize a fuzzy object

@{b}   SYNOPSIS    @{ub}
       fuzzyobject = FL_Object(name)

       struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *FL_Object(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a fuzzyobject with name "name".

@{b}   INPUTS@{ub}
       Name of the fuzzyobject

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized object or 0 if not succesful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Object_Evaluate()" "fuzzy.lib/FL_Object_Evaluate"

@{b}   NAME        @{ub}
       FL_Object_Evaluate -- Evaluate complete fuzzyobject

@{b}   SYNOPSIS    @{ub}
       result = FL_Object_Evaluate(fuzzyobject)

       int FL_Object_Evaluate(struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *)

@{b}   FUNCTION@{ub}
       Perform an evaluation of all rules contained in the object.

@{b}   INPUTS@{ub}
       Pointer to a fuzzyobject.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Object_Run()" "fuzzy.lib/FL_Object_Run"

@{b}   NAME        @{ub}
       FL_Object_Run -- Evaluate complete fuzzyobject

@{b}   SYNOPSIS    @{ub}
       result = FL_Object_Run(fuzzysystem, name)

       int FL_Object_Run(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *)

@{b}   FUNCTION@{ub}
       Perform an evaluation of all rules contained in the object belonging t
o
       the fuzzysystem that can be identified by "name".

@{b}   INPUTS@{ub}
       Pointer to an initialized Fuzzysystem, name of the object to be evalua
ted.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Object_XEvaluate()" "fuzzy.lib/FL_Object_XEvaluate"

@{b}   NAME        @{ub}
       FL_Object_XEvaluate -- Evaluate complete fuzzyobject quickly

@{b}   SYNOPSIS    @{ub}
       result = FL_Object_XEvaluate(fuzzyobject)

       int FL_Object_XEvaluate(struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *)

@{b}   FUNCTION@{ub}
       Perform an evaluation of all rules contained in the object.
 
       THIS FUNCTION PERFORMS NO ERROR CHECKING!

@{b}   INPUTS@{ub}
       Pointer to a fuzzyobject.

@{b}   RESULTS@{ub}
       Returns 1.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Action()" "fuzzy.lib/FL_Read_Action"

@{b}   NAME        @{ub}
       FL_Read_Action -- Read a fuzzyaction from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Action(infile, fuzzyaction)

       int FL_Read_Action(FILE *, struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *)

@{b}   FUNCTION@{ub}
       Reads the action from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a fuzzyaction (memory must be allo
cated).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Clause()" "fuzzy.lib/FL_Read_Clause"

@{b}   NAME        @{ub}
       FL_Read_Clause -- Read a clause from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Clause(infile, clause)

       int FL_Read_Clause(FILE *, struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *)

@{b}   FUNCTION@{ub}
       Reads the clause from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a clause (memory must be allocated
).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Condition()" "fuzzy.lib/FL_Read_Condition"

@{b}   NAME        @{ub}
       FL_Read_Condition -- Read a condition from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Condition(infile, condition)

       int FL_Read_Condition(FILE *, struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *)

@{b}   FUNCTION@{ub}
       Reads the condition from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a condition (memory must be alloca
ted).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Memfunc()" "fuzzy.lib/FL_Read_Memfunc"

@{b}   NAME        @{ub}
       FL_Read_Memfunc -- Read a membership function from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Memfunc(infile, memfunc)

       int FL_Read_Memfunc(FILE *, struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *)

@{b}   FUNCTION@{ub}
       Reads the membership function from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a membership function (memory must
 be allocated).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Object()" "fuzzy.lib/FL_Read_Object"

@{b}   NAME        @{ub}
       FL_Read_Object -- Read a fuzzyobject from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Object(infile, fuzzyobject)

       int FL_Read_Object(FILE *, struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *)

@{b}   FUNCTION@{ub}
       Reads the object from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a fuzzyobject (memory must be allo
cated).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_Rule()" "fuzzy.lib/FL_Read_Rule"

@{b}   NAME        @{ub}
       FL_Read_Rule -- Read rule from FCT file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Rule(infile, rule)

       int FL_Read_Rule(FILE *, struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Read rule from FCT file. 

@{b}   INPUTS@{ub}
       Pointer to the input file
       Pointer to rule to be read

@{b}   OUTPUTS@{ub}
       If read was successful, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Read_Subset()" "fuzzy.lib/FL_Read_Subset"

@{b}   NAME        @{ub}
       FL_Read_Subset -- Read a linguistic term from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Subset(infile, subset)

       int FL_Read_Subset(FILE *, struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *)

@{b}   FUNCTION@{ub}
       Reads the linguistic term from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a linguistic term (memory must be 
allocated).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Read_System()" "fuzzy.lib/FL_Read_System"

@{b}   NAME        @{ub}
       FL_Read_System -- Read fuzzysystem from file

@{b}   SYNOPSIS    @{ub}
       fuzzysystem = FL_Read_System(filename)

       struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *FL_Read_System(char *)

@{b}   FUNCTION@{ub}
       Reads a fuzzysystem from a file that must use an 
       FCT compliant syntax. Allocates all necessary memory.

@{b}   INPUTS@{ub}
       Pointer to filename.

@{b}   RESULTS@{ub}
       Returns address of fuzzysystem, 0 if an error occured.

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Read_Variable()" "fuzzy.lib/FL_Read_Variable"

@{b}   NAME        @{ub}
       FL_Read_Variable -- Read a variable from a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Variable(infile, variable)

       int FL_Read_Variable(FILE *, struct FL_variable *)

@{b}   FUNCTION@{ub}
       Reads the variable from an FCT file.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a variable (memory must be allocat
ed).

@{b}   RESULTS@{ub}
       Returns 1 if read was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Revise_Objects()" "fuzzy.lib/FL_Revise_Objects"

@{b}   NAME        @{ub}
       FL_Revise_Objects -- Check fuzzysystem integrity

@{b}   SYNOPSIS    @{ub}
       result = FL_Revise_Objects(fuzzysystem)

       int FL_Revise_Objects(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Checks all fuzzyobjects for integrity, i.e., looks if all rules are us
ing only 
       existing variables and membership functions. Checks also all variables
 with 
       respect to their types. Resets all pointers to their correct locations
. Is 
       automatically called after @{"FL_Read_System()" Link "FL_Read_System()"}.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem.

@{b}   RESULTS@{ub}
       Returns 1 if revision was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Revise_Variables()" "fuzzy.lib/FL_Revise_Variables"

@{b}   NAME        @{ub}
       FL_Revise_Variables -- Check variable integrity

@{b}   SYNOPSIS    @{ub}
       result = FL_Revise_Variables(fuzzysystem)

       int FL_Revise_Variables(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Checks all variables for integrity, i.e., check them with respect to t
heir types. 
       Resets all pointers to their correct locations. Is automatically calle
d after 
       @{"FL_Read_System()" Link "FL_Read_System()"}.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzysystem.

@{b}   RESULTS@{ub}
       Returns 1 if revision was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Rule()" "fuzzy.lib/FL_Rule"

@{b}   NAME        @{ub}
       FL_Rule -- Allocate memory for a fuzzy rule 

@{b}   SYNOPSIS    @{ub}
       rule = FL_Rule(name)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Rule(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a rule. Initialize the rule with name.

@{b}   INPUTS@{ub}
       name - a pointer to the string to become the rule's name

@{b}   RESULTS@{ub}
       On success, returns a pointer to the rule.
       On failure, returns 0.

@EndNode

@Node "FL_Rule_Evaluate()" "fuzzy.lib/FL_Rule_Evaluate"

@{b}   NAME        @{ub}
       FL_Rule_Evaluate -- Evaluate Fuzzyrule

@{b}   SYNOPSIS    @{ub}
       result = FL_Rule_Evaluate(rule)

       int FL_Rule_Evaluate(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Evaluate the rule pointed to by rule. 

@{b}   INPUTS@{ub}
       Pointer to the rule to be evaluated.

@{b}   OUTPUTS@{ub}
       If evaluation could be performed, return 1.
       Otherwise, return 0.

@EndNode

@Node "FL_Rule_XEvaluate()" "fuzzy.lib/FL_Rule_XEvaluate"

@{b}   NAME        @{ub}
       FL_Rule_XEvaluate -- Evaluate Fuzzyrule QUICKLY

@{b}   SYNOPSIS    @{ub}
       result = FL_Rule_XEvaluate(rule)

       int FL_Rule_XEvaluate(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Evaluate the rule pointed to by rule. 

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING

@{b}   INPUTS@{ub}
       Pointer to the rule to be evaluated.

@{b}   OUTPUTS@{ub}
       If evaluation could be performed, return 1.
       Otherwise, return 0.

@EndNode

@Node "FL_Set_Variable()" "fuzzy.lib/FL_Set_Variable"

@{b}   NAME        @{ub}
       FL_Set_Variable -- Set the value of a variable

@{b}   SYNOPSIS    @{ub}
       result = FL_Set_Variable(fuzzysystem,variablename,value)

       int FL_Set_Variable(struct FL_system*, char *, double)
                         

@{b}   FUNCTION@{ub}
       Set the crisp value of the variable "variablename". This value is used
 to calculate
       the degrees of membership while the rules of the fuzzysystem are evalu
ated.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the variable, value.

@{b}   RESULTS@{ub}
       Returns 1 if the value could be set or 0 if no variable could be found
 or the 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Set_VariableByIndex()" "fuzzy.lib/FL_Set_VariableByIndex"

@{b}   NAME        @{ub}
       FL_Set_VariableByIndex -- Set the value of a variable given by its ind
ex

@{b}   SYNOPSIS    @{ub}
       result = FL_Set_VariableByIndex(fuzzysystem,variableindex,value)

       int FL_Set_VariableByIndex(struct FL_system*, int , double)
                         

@{b}   FUNCTION@{ub}
       Set the crisp value of the variable with index "variableindex". 
       This value is used to calculate the degrees of membership while the 
       rules of the fuzzysystem are evaluated. 

       ATTENTION! You should use @{"FL_Variable_Get()" Link "FL_Variable_Get()"} to obtain that index befor
e!

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, index of the variable, value.

@{b}   RESULTS@{ub}
       Returns 1 if the value could be set or 0 if no variable could be found
 or the 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Set_Variables()" "fuzzy.lib/FL_Set_Variables"

@{b}   NAME        @{ub}
       FL_Set_Variables -- Set the value of a list of variables

@{b}   SYNOPSIS    @{ub}
       result = FL_Set_Variables(fuzzysystem,variablename,value, ... ,0,0)

       int FL_Set_Variable(struct FL_system*, char *, double, ..., char *, do
uble)
                         

@{b}   FUNCTION@{ub}
       Set the crisp value of a list of variables according to the tuples 
       ("variablename",value). The last arguments must be 0,0.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, list of (name of the variable,
 value), 0,0.

@{b}   RESULTS@{ub}
       Returns 1 if the value could be set or 0 if a variable could be found 
or the 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Subset()" "fuzzy.lib/FL_Subset"

@{b}   NAME        @{ub}
       FL_Subset -- Allocate memory for a linguistic term

@{b}   SYNOPSIS    @{ub}
       subset = FL_Subset(name)

       struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *FL_Subset(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a linguistic term with name "name".

@{b}   INPUTS@{ub}
       Name of the subset

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized linguistic term or 0 if not succe
ssful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Subset_Init()" "fuzzy.lib/FL_Subset_Init"

@{b}   NAME        @{ub}
       FL_Subset_Init -- Initialize a linguistic term

@{b}   SYNOPSIS    @{ub}
       subset = FL_Subset_Init(set, subsettype, center, leftspread, rightspre
ad, 
                               degree_of_mem)

       struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *FL_Subset_Init(struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *, 
                                        enum FL_subsettype, double, double, d
ouble, double)

@{b}   FUNCTION@{ub}
       Initialize a linguistic term to be of type "type" with parameters as g
iven.

@{b}   INPUTS@{ub}
       Name of the subset

@{b}   RESULTS@{ub}
       Returns 1 if initialization was successful, 0 otherwise. 

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Subset_Memship()" "fuzzy.lib/FL_Subset_Memship"

@{b}   NAME        @{ub}
       FL_Subset_Memship -- Calculate dom of a value wrt a linguistic term

@{b}   SYNOPSIS    @{ub}
       degree = FL_Subset_Memship(set,crisp_value)

       double FL_Subset(struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *, double)

@{b}   FUNCTION@{ub}
       Calculate the degree of membership of the crisp_value with respect to 
the linguistic
       term defined by set.

@{b}   INPUTS@{ub}
       Name of the subset

@{b}   RESULTS@{ub}
       Returns 1 if initialization was successful, 0 otherwise. 

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_System()" "fuzzy.lib/FL_System"

@{b}   NAME        @{ub}
       FL_System -- Setup a fuzzy system

@{b}   SYNOPSIS    @{ub}
       fuzzysystem = FL_System(name)

       struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *FL_System(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a fuzzysystem. The pointer returned by @{"FL_system" Link "inc:fuzztypes.h/Main" 84} c
an be used
       in all calls to the library where a fuzzysystem is involved.

@{b}   INPUTS@{ub}
       Name of the fuzzysystem

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized system or 0 if not succesful.

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_System_Reset()" "fuzzy.lib/FL_System_Reset"

@{b}   NAME        @{ub}
       FL_System_Reset -- Reset fuzzysystem for later evaluation 

@{b}   SYNOPSIS    @{ub}
       result = FL_System_Reset(fuzzysystem)

       int FL_System_Reset(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Resets all internal status variables of a fuzzy system such that a new
 evaluation 
       can safely take place. Should be run before @{"FL_System_Run()" Link "FL_System_Run()"} is called.

@{b}   INPUTS@{ub}
       Pointer to an initialized Fuzzysystem.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_System_Run()" "fuzzy.lib/FL_System_Run"

@{b}   NAME        @{ub}
       FL_System_Run -- Evaluate complete fuzzysystem

@{b}   SYNOPSIS    @{ub}
       result = FL_System_Run(fuzzysystem)

       int FL_System_Run(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Perform an evaluation of all rules contained in all objects belonging 
to the 
       system *fuzzysystem. Before FL_System_Run() is used, @{"FL_System_Reset()" Link "FL_System_Reset()"}
 is usually
       executed. 

@{b}   INPUTS@{ub}
       Pointer to an initialized Fuzzysystem.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_System_XRun()" "fuzzy.lib/FL_System_XRun"

@{b}   NAME        @{ub}
       FL_System_XRun -- Evaluate complete fuzzysystem QUICKLY

@{b}   SYNOPSIS    @{ub}
       result = FL_System_XRun(fuzzysystem)

       int FL_System_XRun(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *)

@{b}   FUNCTION@{ub}
       Perform an evaluation of all rules contained in all objects belonging 
to the 
       system *fuzzysystem. Before @{"FL_System_Run()" Link "FL_System_Run()"} is used, @{"FL_System_Reset()" Link "FL_System_Reset()"}
 is usually
       executed. 

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING!

@{b}   INPUTS@{ub}
       Pointer to an initialized Fuzzysystem.

@{b}   RESULTS@{ub}
       Returns 1

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Variable()" "fuzzy.lib/FL_Variable"

@{b}   NAME        @{ub}
       FL_Variable -- Initialize a linguistic variable

@{b}   SYNOPSIS    @{ub}
       variable = FL_Variable(name)

       struct FL_variable *FL_Variable(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a linguistic variable with name "name".

@{b}   INPUTS@{ub}
       Name of the variable

@{b}   RESULTS@{ub}
       Returns a pointer to the initialized variable or 0 if not successful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Variable_Evaluate()" "fuzzy.lib/FL_Variable_Evaluate"

@{b}   NAME        @{ub}
       FL_Variable_Evaluate -- Calculate the crisp value of a linguistic vari
able

@{b}   SYNOPSIS    @{ub}
       result = FL_Variable_Evaluate(variable,evaluation_method)

       int FL_Variable_Evaluate(struct FL_variable *, enum FL_evalmethod)

@{b}   FUNCTION@{ub}
       Check the degree of membership of all subsets of the membership functi
on
       which is assigned to the variable. Calculate the crisp value by means 
of
       the given evaluation method (which is given by the corresponding objec
t).

@{b}   INPUTS@{ub}
       Pointer to the variable, evaluation method.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Variable_Get()" "fuzzy.lib/FL_Variable_Get"

@{b}   NAME        @{ub}
       FL_Variable_Get -- Get a variable by name

@{b}   SYNOPSIS    @{ub}
       variable = FL_Variable_Get(fuzzysystem,variablename)

       struct FL_variable *FL_Variable_Get(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the variable with name "variablename". 

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the variable
       that is to be found.

@{b}   RESULTS@{ub}
       Returns a pointer to the variable or 0 if none could be found or the 
       action was not successful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Variable_Index()" "fuzzy.lib/FL_Variable_Index"

@{b}   NAME        @{ub}
       FL_Variable_Index -- Get a variable by index

@{b}   SYNOPSIS    @{ub}
       variable = FL_Variable_Index(fuzzysystem,variablename)

       int FL_Variable_Get(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Scan the fuzzysystem for the variable with name "variablename". 

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the variable
       that is to be found.

@{b}   RESULTS@{ub}
       Returns the internal index of the variable or 0 if none could be found
 or the 
       action was not successful.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Variable_Reset()" "fuzzy.lib/FL_Variable_Reset"

@{b}   NAME        @{ub}
       FL_Variable_Reset -- Reset degrees of membership of a variable

@{b}   SYNOPSIS    @{ub}
       result = FL_Variable_Reset(fuzzysystem,variablename)

       int FL_Variable_Reset(struct FL_system*, char *)
                         

@{b}   FUNCTION@{ub}
       Set the dom of all subsets of the membership function of the variable 
to 0.

@{b}   INPUTS@{ub}
       Pointer to an initialized fuzzy system, name of the variable.

@{b}   RESULTS@{ub}
       Returns 1 if the variable was reset or 0 if none could be found or the
 
       action was not successful.

@{b}   USE@{ub}
       Application

@EndNode

@Node "FL_Variable_Set()" "fuzzy.lib/FL_Variable_Set"

@{b}   NAME        @{ub}
       FL_Variable_Set -- Set a variable to a linguistic term 

@{b}   SYNOPSIS    @{ub}
       result = FL_Variable_Set(variable,subset,degree_of_membership)

       int FL_Variable_Set(struct FL_variable *, char *, double)

@{b}   FUNCTION@{ub}
       Assign "degree_of_membership" with respect to the fuzzy subset "subset
" 
       for the "variable".

@{b}   INPUTS@{ub}
       Pointer to the variable, name of subset, degree of membership.

@{b}   RESULTS@{ub}
       Returns 1 if assignment was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Variable_XEvaluate()" "fuzzy.lib/FL_Variable_XEvaluate"

@{b}   NAME        @{ub}
       FL_Variable_XEvaluate -- Calculate the crisp value of a linguistic 
                                variable QUICKLY 

@{b}   SYNOPSIS    @{ub}
       result = FL_Variable_XEvaluate(variable,evaluation_method)

       int FL_Variable_XEvaluate(struct FL_variable *, enum FL_evalmethod)

@{b}   FUNCTION@{ub}
       Check the degree of membership of all subsets of the membership functi
on
       which is assigned to the variable. Calculate the crisp value by means 
of
       the given evaluation method (which is given by the corresponding objec
t).

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING!

@{b}   INPUTS@{ub}
       Pointer to the variable, evaluation method.

@{b}   RESULTS@{ub}
       Returns 1 if evaluation was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Action()" "fuzzy.lib/FL_Write_Action"

@{b}   NAME        @{ub}
       FL_Write_Action -- Write a fuzzyaction to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Action(outfile, fuzzyaction, indentation)

       int FL_Write_Action(FILE *, struct @{"FL_action" Link "inc:fuzztypes.h/Main" 54} *, int)

@{b}   FUNCTION@{ub}
       Writes the action to the file using FCT syntax and indentation for rea
dability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a fuzzyaction, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Clause()" "fuzzy.lib/FL_Write_Clause"

@{b}   NAME        @{ub}
       FL_Write_Clause -- Write a clause to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Clause(outfile, clause, indentation)

       int FL_Write_Clause(FILE *, struct @{"FL_clause" Link "inc:fuzztypes.h/Main" 48} *, int)

@{b}   FUNCTION@{ub}
       Writes the clause to the file using FCT syntax and indentation for rea
dability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a clause, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Condition()" "fuzzy.lib/FL_Write_Condition"

@{b}   NAME        @{ub}
       FL_Write_Condition -- Write a condition to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Condition(outfile, condition, indentation)

       int FL_Write_Condition(FILE *, struct @{"FL_condition" Link "inc:fuzztypes.h/Main" 35} *, int)

@{b}   FUNCTION@{ub}
       Writes the condition to the file using FCT syntax and indentation for 
readability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a condition, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Memfunc()" "fuzzy.lib/FL_Write_Memfunc"

@{b}   NAME        @{ub}
       FL_Write_Memfunc -- Write a membership function to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Memfunc(outfile, memfunc, indentation)

       int FL_Write_Memfunc(FILE *, struct @{"FL_memfunc" Link "inc:fuzztypes.h/Main" 16} *, int)

@{b}   FUNCTION@{ub}
       Writes the membership function to the file using FCT syntax and indent
ation 
       for readability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a membership function, indentation
.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Object()" "fuzzy.lib/FL_Write_Object"

@{b}   NAME        @{ub}
       FL_Write_Object -- Write a fuzzyobject to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Object(outfile, fuzzyobject, indentation)

       int FL_Write_Object(FILE *, struct @{"FL_object" Link "inc:fuzztypes.h/Main" 77} *, int)

@{b}   FUNCTION@{ub}
       Writes the object to the file using FCT syntax and indentation for rea
dability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a fuzzyobject, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Rule()" "fuzzy.lib/FL_Write_Rule"

@{b}   NAME        @{ub}
       FL_Write_Rule -- Write rule to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Rule(outfile, rule, indentation)

       int FL_Write_Rule(FILE *, struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *, int)

@{b}   FUNCTION@{ub}
       Write rule in FCT format to file f. Use indentation to make
       output more readable

@{b}   INPUTS@{ub}
       Pointer to the output file
       Pointer to rule to be written

@{b}   OUTPUTS@{ub}
       If write was successful, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Write_Subset()" "fuzzy.lib/FL_Write_Subset"

@{b}   NAME        @{ub}
       FL_Write_Subset -- Write a membership function to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Subset(outfile, subset, indentation)

       int FL_Write_Subset(FILE *, struct @{"FL_subset" Link "inc:fuzztypes.h/Main" 7} *, int)

@{b}   FUNCTION@{ub}
       Writes the linguistic term "subset" to the file using FCT syntax and i
ndentation 
       for readability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a linguistic term, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_System()" "fuzzy.lib/FL_Write_System"

@{b}   NAME        @{ub}
       FL_Write_System -- Write fuzzysystem to file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_System(fuzzysystem, filename, force_overwrite)

       int FL_System_Reset(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, int)

@{b}   FUNCTION@{ub}
       Writes a fuzzysystem to a file, using FCT compliant syntax, 
       thus the file can easily be edited afterwards.

@{b}   INPUTS@{ub}
       Pointer to an initialized Fuzzysystem, pointer to filename, flag. 
       If flag != 0, the file will be written even if it already exists. 
       Otherwise, the function will return 0.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   SIDE EFFECTS@{ub}
       Changes all blanks in all names to underscores

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Rule()" "fuzzy.lib/FL_Rule"

@{b}   NAME        @{ub}
       FL_Rule -- Allocate memory for a fuzzy rule 

@{b}   SYNOPSIS    @{ub}
       rule = FL_Rule(name)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Rule(char *)

@{b}   FUNCTION@{ub}
       Allocate memory for a rule. Initialize the rule with name.

@{b}   INPUTS@{ub}
       name - a pointer to the string to become the rule's name

@{b}   RESULTS@{ub}
       On success, returns a pointer to the rule.
       On failure, returns 0.

@EndNode

@Node "FL_Clone_Rule()" "fuzzy.lib/FL_Clone_Rule"

@{b}   NAME        @{ub}
       FL_Clone_Rule -- Make an identical copy of a rule

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Rule(fuzzyrule)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Clone_Rule(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Allocates memory for both the membership function and the 
       associated subsets.

@{b}   INPUTS@{ub}
       Pointer to original membership function

@{b}   RESULTS@{ub}
       Pointer to clone


@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Clone_Rules()" "fuzzy.lib/FL_Clone_Rules"

@{b}   NAME        @{ub}
       FL_Clone_Rules -- Make an identical copy of a list of rules

@{b}   SYNOPSIS    @{ub}
       clone = FL_Clone_Rules(fuzzyrulelist,num_rules)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Clone_Rules(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *,int)

@{b}   FUNCTION@{ub}
       Allocates memory for the whole array of membership rules and the 
       associated rules.

@{b}   INPUTS@{ub}
       Pointer to first original membership function, number of rules in arra
y

@{b}   RESULTS@{ub}
       Pointer to cloned array

@{b}   USAGE@{ub}
       Internal

@EndNode

@Node "FL_Get_Rule()" "fuzzy.lib/FL_Get_Rule"

@{b}   NAME        @{ub}
       FL_Get_Rule -- Get a specific rule from a fuzzy system/object

@{b}   SYNOPSIS    @{ub}
       rule = FL_Get_Rule(fuzzysystem, objectname, rulename)

       struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *FL_Get_Rule(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *)

@{b}   FUNCTION@{ub}
       Get a pointer to a specific rule belonging to a specific object

@{b}   INPUTS@{ub}
       Pointer to the fuzzysystem
       Name of fuzzy object
       Name of rule

@{b}   OUTPUTS@{ub}
       If rule was found, return pointer to rule.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Kill_Rule()" "fuzzy.lib/FL_Kill_Rule"

@{b}   NAME        @{ub}
       FL_Kill_Rule -- Free memory allocated by a fuzzy rule

@{b}   SYNOPSIS    @{ub}
       FL_Kill_Rule(fuzzyrule)

       void FL_Kill_Rule(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Free all memory allocated by a fuzzyrule.

@{b}   INPUTS@{ub}
       Pointer to fuzzyrule

@{b}   USAGE@{ub}
       Application

@EndNode

@Node "FL_Read_Rule()" "fuzzy.lib/FL_Read_Rule"

@{b}   NAME        @{ub}
       FL_Read_Rule -- Read rule from FCT file

@{b}   SYNOPSIS    @{ub}
       result = FL_Read_Rule(infile, rule)

       int FL_Read_Rule(FILE *, struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Read rule from FCT file. 

@{b}   INPUTS@{ub}
       Pointer to the input file
       Pointer to rule to be read

@{b}   OUTPUTS@{ub}
       If read was successful, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Rule_Evaluate()" "fuzzy.lib/FL_Rule_Evaluate"

@{b}   NAME        @{ub}
       FL_Rule_Evaluate -- Evaluate Fuzzyrule

@{b}   SYNOPSIS    @{ub}
       result = FL_Rule_Evaluate(rule)

       int FL_Rule_Evaluate(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Evaluate the rule pointed to by rule. 

@{b}   INPUTS@{ub}
       Pointer to the rule to be evaluated.

@{b}   OUTPUTS@{ub}
       If evaluation could be performed, return 1.
       Otherwise, return 0.

@EndNode

@Node "FL_Rule_XEvaluate()" "fuzzy.lib/FL_Rule_XEvaluate"

@{b}   NAME        @{ub}
       FL_Rule_XEvaluate -- Evaluate Fuzzyrule QUICKLY

@{b}   SYNOPSIS    @{ub}
       result = FL_Rule_XEvaluate(rule)

       int FL_Rule_XEvaluate(struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *)

@{b}   FUNCTION@{ub}
       Evaluate the rule pointed to by rule. 

       THIS FUNCTION DOES NOT PERFORM ANY ERROR CHECKING

@{b}   INPUTS@{ub}
       Pointer to the rule to be evaluated.

@{b}   OUTPUTS@{ub}
       If evaluation could be performed, return 1.
       Otherwise, return 0.

@EndNode

@Node "FL_Add_Rule()" "fuzzy.lib/FL_Add_Rule"

@{b}   NAME        @{ub}
       FL_Add_Rule -- Add a rule to a fuzzy object

@{b}   SYNOPSIS    @{ub}
       result = FL_Add_Rule(fuzzysystem, objectname, rulename)

       int FL_Add_Rule(struct @{"FL_system" Link "inc:fuzztypes.h/Main" 84} *, char *, char *)

@{b}   FUNCTION@{ub}
       Add a fuzzyrule with name <rulename> to the object <objectname>.
       Allocate space for the rule.

@{b}   INPUTS@{ub}
       Pointer to the fuzzysystem
       Name of fuzzy object
       Name of rule

@{b}   OUTPUTS@{ub}
       If rule could be added, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Variable_Set()" "fuzzy.lib/FL_Variable_Set"

@{b}   NAME        @{ub}
       FL_Variable_XSet -- Set a variable to a linguistic term QUICKLY

@{b}   SYNOPSIS    @{ub}
       result = FL_Variable_XSet(variable,subset,degree_of_membership)

       int FL_Variable_XSet(struct FL_variable *, char *, double)

@{b}   FUNCTION@{ub}
       Assign "degree_of_membership" with respect to the fuzzy subset "subset
" 
       for the "variable".

       THIS FUNCTION DOESN'T DO ANY ERROR CHECKING!

@{b}   INPUTS@{ub}
       Pointer to the variable, name of subset, degree of membership.

@{b}   RESULTS@{ub}
       Returns 1.

@{b}   USE@{ub}
       Internal

@EndNode

@Node "FL_Write_Rule()" "fuzzy.lib/FL_Write_Rule"

@{b}   NAME        @{ub}
       FL_Write_Rule -- Write rule to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Rule(outfile, rule, indentation)

       int FL_Write_Rule(FILE *, struct @{"FL_rule" Link "inc:fuzztypes.h/Main" 65} *, int)

@{b}   FUNCTION@{ub}
       Write rule in FCT format to file f. Use indentation to make
       output more readable

@{b}   INPUTS@{ub}
       Pointer to the output file
       Pointer to rule to be written

@{b}   OUTPUTS@{ub}
       If write was successful, return 1.
       Otherwise, return 0. In this case, check FL_Error.

@EndNode

@Node "FL_Write_Variable()" "fuzzy.lib/FL_Write_Variable"

@{b}   NAME        @{ub}
       FL_Write_Variable -- Write a variable to a file

@{b}   SYNOPSIS    @{ub}
       result = FL_Write_Variable(outfile, variable, indentation)

       int FL_Write_Variable(FILE *, struct FL_variable *, int)

@{b}   FUNCTION@{ub}
       Writes the variable to the file using FCT syntax and indentation for r
eadability.

@{b}   INPUTS@{ub}
       Pointer to an open file, pointer to a variable, indentation.

@{b}   RESULTS@{ub}
       Returns 1 if write was successful, 0 otherwise.

@{b}   USE@{ub}
       Internal

@EndNode

