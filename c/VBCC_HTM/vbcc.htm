<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<META NAME="Generator" CONTENT="Internet Assistant for Word Version 3.0">
</HEAD>
<BODY>

<FONT SIZE=6><P ALIGN="JUSTIFY">vbcc compiler system</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">Volker Barthelmann</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">  i</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">Table of Contents</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1 General . .. .. .. .. .. .. ... .. .. .. .. .. .. .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">1</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">1</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.2 Legal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">1</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.3 Installation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">2</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.3.1 Installing for Unix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">2</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.3.2 Installing for DOS/Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">3</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.3.3 Installing for AmigaOS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">3</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1.4 Tutorial . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">5</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">2 The Frontend. .. .. .. .. .. .. .. .. .. .. .. .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">7</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">2.1 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">7</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">2.2 Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">8</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3 The Compiler .. .. .. .. .. .. .. .. .. ... .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">11</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.1 General Compiler Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">11</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.2 Errors and Warnings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">14</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.3 Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">15</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4 Optimizations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">16</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.1 Register Allocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">18</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.2 Flow Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">18</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.3 Common Subexpression Elimination. . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">19</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.4 Copy Propagation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">19</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.5 Constant Propagation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">20</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.6 Dead Code Elimination . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">21</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.7 Loop-Invariant Code Motion. . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">21</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.8 Strength Reduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">22</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.9 Induction Variable Elimination . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">22</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.10 Loop Unrolling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">23</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.11 Function Inlining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.12 Intrinsic Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.13 Unused Object Elimination . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.14 Alias Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.15 Inter-Procedural Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.16 Cross-Module Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.17 Instruction Scheduling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">30</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.18 Target-Specific Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">31</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.4.19 Debugging Optimized Code . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">31</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">32</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.1 Pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">32</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.2 Register Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.3 Inline-Assembly Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.4 Variable Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> ii</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">3.5.5 Type Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.6 __typeof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.7 __alignof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.8 __offsetof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.9 Specifying side-e ects . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">35</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.10 Automatic constructor/destructor functions. . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">35</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.5.10.1 Predefined macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">36</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.6 Known Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">36</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">3.7 Credits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">36</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4 M68k/Coldfire Backend .. .. .. .. .. .. .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">39</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.1 Additional options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">39</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">40</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.3 Small data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">41</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.4 Small code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">41</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.5 CPUs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">41</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.6 FPUs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">42</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.7 Math . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">42</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.8 Target-Specific Variable Attributes . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">42</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.9 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">43</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.10 Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">43</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.11 Stdarg . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">43</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">4.12 Known problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">44</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5 PowerPC Backend . .. .. .. ... .. .. .. .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">45</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.1 Additional options for this version . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">45</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">46</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.3 Target-specific variable-attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">47</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.4 Target-specific pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">48</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.5 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">48</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.6 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">48</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.7 Stdarg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">48</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">5.8 Known problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">50</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6 DEC Alpha Backend .. .. .. .. .. .. .. .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">51</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">6.1 Additional options for this version . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">51</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">6.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">51</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">6.3 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">52</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">6.4 Stdarg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">52</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">6.5 Known problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">52</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7 i386 Backend .. .. .. .. .. .. .. .. .. ... .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">53</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">7.1 Additional options for this version . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">53</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">7.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">53</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">7.3 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">54</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">7.4 Stdarg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">54</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">7.5 Known Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">54</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> iii</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8 c16x Backend. .. .. .. .. .. .. .. .. .. .. .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">55</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.1 Additional options for this version . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">55</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">55</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.3 Target-specific variable-attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">56</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.4 Target-specific type-attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">57</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.5 Target-specific types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">57</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.6 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">57</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.7 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">58</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.8 Stdarg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">58</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">8.9 Known Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">58</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9 68hc12 Backend .. .. .. .. .. .. .. .. .. .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">59</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.1 Additional options for this version . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">59</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.2 ABI . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">59</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.3 Target-specific variable-attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">60</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.4 Predefined Macros. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">60</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.5 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">60</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.6 Stdarg. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">60</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">9.7 Known Problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">60</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">10 Instruction Scheduler .. .. .. .. .. .. .. ... .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">61</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">10.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">61</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">10.2 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">61</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">10.3 Known problems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">61</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11 C Library . .. .. .. .. .. .. .. .. .. .. .. .. .. .. ..</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">63</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">63</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.2 Legal. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">63</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3 Embedded Systems. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">64</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">64</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.2 Heap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">65</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.3 Input/Output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">65</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.4 Floating Point. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">65</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.5 Useless Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">65</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.3.6 Linking/Locating . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">66</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4 AmigaOS/68k . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">66</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">66</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">66</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">67</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.4 Small data model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">68</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">68</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.6 Minimal startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">68</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.7 amiga.lib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.4.8 auto.lib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5 PowerUp/PPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> iv</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">11.5.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.4 Small data model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.6 Minimal startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.7 libamiga.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.5.8 libauto.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">70</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6 WarpOS/PPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.4 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.5 amiga.lib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.6.6 auto.lib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7 MorphOS/PPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.4 Small data model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">72</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.6 libamiga.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.7.7 libauto.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8 AmigaOS4/PPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.4 Small data model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.5 Dynamic linking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.6 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.7 libamiga.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.8 libauto.a . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.9 newlib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.9.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">74</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.8.9.2 Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">75</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9 Atari MiNT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">75</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">75</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">75</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9.4 Small data model. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.9.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10 Atari TOS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10.1 Startup . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10.2 Floating point . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">76</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10.3 Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">77</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10.4 Small data model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">77</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">11.10.5 Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">77</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">12 List of Errors. .. .. .. .. .. .. .. .. .. .. .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">79</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> v</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13 Backend Interface .. .. .. .. .. .. .. .. .. .. .. .</P>
</FONT><FONT SIZE=4 COLOR="#0000ff"><P ALIGN="JUSTIFY">95</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">95</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2 Building vbcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">95</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.1 Directory Structure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">95</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.2 Adapting the Makefile . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">96</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.3 Building vc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">96</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.4 Building vsc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">97</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.5 Building vbcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">97</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.6 Configuring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">97</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.2.7 Building Cross-Compilers . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">97</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3 The Intermediate Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">98</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3.1 General Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">98</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3.2 Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">99</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3.3 Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">101</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3.4 Composite Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">102</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.3.5 Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">104</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.4 Type System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">107</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.4.1 Target Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">107</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.4.2 Target Arithmetic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">109</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.5 ‘machine.h’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">109</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6 ‘machine.c’ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">111</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6.1 Name and Copyright . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">111</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6.2 Command Line Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">111</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6.3 Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">112</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6.4 Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">113</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.6.5 Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">114</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.7 Available Support Functions, Macros and Variables . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">116</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8 Hints for common Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">120</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.1 Instruction Combining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">120</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.2 Adressing Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">120</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.3 Implicit setting of Condition Codes . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">123</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.4 Register Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">124</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.5 Register Pairs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">124</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.6 Elimination of Frame-Pointer . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">125</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.7 Delayed popping of Stack-Slots . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">125</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.8 Optimized Return . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">125</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.9 Jump Tables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">125</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.10 Context-sensitive Register-Allocation . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.11 Inter-procedural Register-Allocation. . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.12 Conditional Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.13 Extended ICs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.14 Peephole Optimizations on Assembly Output . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">127</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.15 Marking of e cient ICs . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">128</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.16 Function entry/exit Code . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">128</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.17 Multiplication/division with Constants . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">128</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.18 Block copying . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">128</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.19 Optimized Library Functions . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.8.20 Instruction Scheduler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> vi</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">13.9 Hints for common Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.1 Inline Assembly . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.2 -speed/-size . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.3 Target-specific Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.4 stdarg.h . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.5 Section Specifiers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.6 Target-specific Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.7 Target-specific #pragmas . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.8 Target-specific extended Types . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.9 Target-specific printval . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.10 Debug Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.10.1 DWARF2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.11 Interrupt Handlers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">133</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.12 Stack checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">133</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.9.13 Profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">134</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">13.10 Changes from 0.7 Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">134</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY"> Chapter 1: General</P>
<P ALIGN="JUSTIFY">1</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">1 General</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.1 Introduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc is a highly optimizing portable and retargetable ISO C compiler. It supports ISO</P>
<P ALIGN="JUSTIFY">C according to ISO/IEC 9899:1989 and a subset of the new standard ISO/IEC 9899:1999</P>
<P ALIGN="JUSTIFY">(C99).</P>
<P ALIGN="JUSTIFY">It is split into a target-independent and a target-dependent part, and provides complete</P>
<P ALIGN="JUSTIFY">abstraction of host- and target-arithmetic. Therefore, it fully supports cross-compiling for</P>
<P ALIGN="JUSTIFY">8, 16, 32 and 64bit architectures.</P>
<P ALIGN="JUSTIFY">Embedded systems are supported by features like di erent pointer-sizes (e.g. di erently</P>
<P ALIGN="JUSTIFY">sized function- and object-pointers or near- and far-pointers), ROM-able code, inline-</P>
<P ALIGN="JUSTIFY">assembly, bit-types, interrupt-handlers, section-attributes, stack-calculation and many oth-</P>
<P ALIGN="JUSTIFY">ers (depending on the backend).</P>
<P ALIGN="JUSTIFY">vbcc provides a large set of aggressive high-level optimizations (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4 [Optimiza-</P>
<P ALIGN="JUSTIFY">tions], page 16</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) as well as target-specific optimizations to produce faster or smaller code.</P>
<P ALIGN="JUSTIFY">Rather than restricting analysis and optimization to single functions or files, vbcc is able</P>
<P ALIGN="JUSTIFY">to optimize across functions and even modules. Target-independent optimizations include:</P>
<P ALIGN="JUSTIFY">- cross-module function-inlining</P>
<P ALIGN="JUSTIFY">- partial inlining of recursive functions</P>
<P ALIGN="JUSTIFY">- inter-procedural data- ow analysis</P>
<P ALIGN="JUSTIFY">- inter-procedural register-allocation</P>
<P ALIGN="JUSTIFY">- register-allocation for global variables</P>
<P ALIGN="JUSTIFY">- global common-subexpression-elimination</P>
<P ALIGN="JUSTIFY">- global constant-propagation</P>
<P ALIGN="JUSTIFY">- global copy-propagation</P>
<P ALIGN="JUSTIFY">- dead-code-elimination</P>
<P ALIGN="JUSTIFY">- alias-analysis</P>
<P ALIGN="JUSTIFY">- loop-unrolling</P>
<P ALIGN="JUSTIFY">- induction-variable elimination</P>
<P ALIGN="JUSTIFY">- loop-invariant code-motion</P>
<P ALIGN="JUSTIFY">- loop-reversal</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.2 Legal</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc is copyright in 1995-2009 by Volker Barthelmann.</P>
<P ALIGN="JUSTIFY">This archive may be redistributed without modifications and used for non-commercial pur-</P>
<P ALIGN="JUSTIFY">poses.</P>
<P ALIGN="JUSTIFY">Distributing modified versions and commercial usage needs my written consent.</P>
<P ALIGN="JUSTIFY">This copyright applies to vc, vbcc and vsc.</P>
<P ALIGN="JUSTIFY">This archive may contain other tools (e.g. assemblers or linkers) which do not fall under</P>
<P ALIGN="JUSTIFY">this license. Please consult the corresponding documentation of these tools.</P>
<P ALIGN="JUSTIFY"> 2</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">vbcc contains the preprocessor ucpp by Thomas Pornin. Included is the copyright notice of</P>
<P ALIGN="JUSTIFY">ucpp (note that this license does not apply to vbcc or any other part of this distribution):</P>
<P ALIGN="JUSTIFY">/*</P>
<P ALIGN="JUSTIFY">* (c) Thomas Pornin 1999, 2000</P>
<P ALIGN="JUSTIFY">*</P>
<P ALIGN="JUSTIFY">* Redistribution and use in source and binary forms, with or without</P>
<P ALIGN="JUSTIFY">* modification, are permitted provided that the following conditions</P>
<P ALIGN="JUSTIFY">* are met:</P>
<P ALIGN="JUSTIFY">* 1. Redistributions of source code must retain the above copyright</P>
<P ALIGN="JUSTIFY">* notice, this list of conditions and the following disclaimer.</P>
<P ALIGN="JUSTIFY">* 2. Redistributions in binary form must reproduce the above copyright</P>
<P ALIGN="JUSTIFY">* notice, this list of conditions and the following disclaimer in the</P>
<P ALIGN="JUSTIFY">* documentation and/or other materials provided with the distribution.</P>
<P ALIGN="JUSTIFY">* 4. The name of the authors may not be used to endorse or promote</P>
<P ALIGN="JUSTIFY">* products derived from this software without specific prior written</P>
<P ALIGN="JUSTIFY">* permission.</P>
<P ALIGN="JUSTIFY">*</P>
<P ALIGN="JUSTIFY">* THIS SOFTWARE IS PROVIDED ‘‘AS IS’’ AND WITHOUT ANY EXPRESS OR</P>
<P ALIGN="JUSTIFY">* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED</P>
<P ALIGN="JUSTIFY">* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</P>
<P ALIGN="JUSTIFY">* ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE</P>
<P ALIGN="JUSTIFY">* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</P>
<P ALIGN="JUSTIFY">* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT</P>
<P ALIGN="JUSTIFY">* OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR</P>
<P ALIGN="JUSTIFY">* BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,</P>
<P ALIGN="JUSTIFY">* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE</P>
<P ALIGN="JUSTIFY">* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,</P>
<P ALIGN="JUSTIFY">* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</P>
<P ALIGN="JUSTIFY">*</P>
<P ALIGN="JUSTIFY">*/</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.3 Installation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The vbcc directory tree looks as follows:</P>
<P ALIGN="JUSTIFY">‘vbcc/bin’</P>
<P ALIGN="JUSTIFY">The executables.</P>
<P ALIGN="JUSTIFY">‘vbcc/config’</P>
<P ALIGN="JUSTIFY">Config files for the frontend.</P>
<P ALIGN="JUSTIFY">‘vbcc/targets/&lt;target&gt;’</P>
<P ALIGN="JUSTIFY">Subdirectory containing all files specific to a certain target (e.g. m68k-amigaos</P>
<P ALIGN="JUSTIFY">or ppc-eabi).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.3.1 Installing for Unix</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1. Extract the archive.</P>
<P ALIGN="JUSTIFY">2. Set the environment variable VBCC to the vbcc directory. Depending on your shell this</P>
<P ALIGN="JUSTIFY">might be done e.g. by</P>
<P ALIGN="JUSTIFY"> Chapter 1: General</P>
<P ALIGN="JUSTIFY">3</P>
<P ALIGN="JUSTIFY">VBCC=&lt;prefix&gt;/vbcc</P>
<P ALIGN="JUSTIFY">or</P>
<P ALIGN="JUSTIFY">setenv VBCC &lt;prefix&gt;/vbcc</P>
<P ALIGN="JUSTIFY">3. Include &lt;prefix&gt;/vbcc/bin to your search-path. Depending on your shell this might be</P>
<P ALIGN="JUSTIFY">done e.g. by</P>
<P ALIGN="JUSTIFY">PATH=&lt;prefix&gt;/vbcc/bin:"$PATH"</P>
<P ALIGN="JUSTIFY">or</P>
<P ALIGN="JUSTIFY">setenv PATH &lt;prefix&gt;/vbcc/bin:"$PATH"</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.3.2 Installing for DOS/Windows</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">1. Extract the archive.</P>
<P ALIGN="JUSTIFY">2. Set the environment variable VBCC to the vbcc directory.</P>
<P ALIGN="JUSTIFY">set VBCC=&lt;prefix&gt;\vbcc</P>
<P ALIGN="JUSTIFY">3. Include &lt;prefix&gt;/vbcc/bin to your search-path.</P>
<P ALIGN="JUSTIFY">set PATH=&lt;prefix&gt;\vbcc\bin;%PATH%</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.3.3 Installing for AmigaOS</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Since vbcc 0.8g there is an Amiga Installer, which lets you install the binary and tar-</P>
<P ALIGN="JUSTIFY">get archives with a simple mouse click. vbcc for AmigaOS/MorphOS is divided into the</P>
<P ALIGN="JUSTIFY">following packages:</P>
<P ALIGN="JUSTIFY">‘vbcc_bin_amigaos68k’</P>
<P ALIGN="JUSTIFY">Binaries for AmigaOS 2.x/3.x (680x0).</P>
<P ALIGN="JUSTIFY">‘vbcc_bin_amigaosppc’</P>
<P ALIGN="JUSTIFY">Binaries for AmigaOS 4.x (PowerPC).</P>
<P ALIGN="JUSTIFY">‘vbcc_bin_morphos’</P>
<P ALIGN="JUSTIFY">Binaries for MorphOS (PowerPC).</P>
<P ALIGN="JUSTIFY">‘vbcc_bin_powerup’</P>
<P ALIGN="JUSTIFY">Additional PPC-native binaries using the PowerUp kernel for AmigaOS 3.x.</P>
<P ALIGN="JUSTIFY">‘vbcc_bin_warpos’</P>
<P ALIGN="JUSTIFY">Additional PPC-native binaries using the WarpOS kernel for AmigaOS 3.x.</P>
<P ALIGN="JUSTIFY">‘vbcc_target_m68k-amigaos’</P>
<P ALIGN="JUSTIFY">Header files and libraries for AmigaOS/M68k.</P>
<P ALIGN="JUSTIFY">‘vbcc_target_ppc-amigaos’</P>
<P ALIGN="JUSTIFY">Header files and libraries for AmigaOS 4.x.</P>
<P ALIGN="JUSTIFY">‘vbcc_target_ppc-morphos’</P>
<P ALIGN="JUSTIFY">Header files and libraries for MorphOS.</P>
<P ALIGN="JUSTIFY"> 4</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">‘vbcc_target_ppc-powerup’</P>
<P ALIGN="JUSTIFY">Header files and libraries for PowerUp.</P>
<P ALIGN="JUSTIFY">‘vbcc_target_ppc-warpos’</P>
<P ALIGN="JUSTIFY">Header files and libraries for WarpOS.</P>
<P ALIGN="JUSTIFY">Usually you will install the binary archive for your host architecture of choice, then add as</P>
<P ALIGN="JUSTIFY">many target archives you need.</P>
<P ALIGN="JUSTIFY">When installing manually it is recommended to add the following assigns to your</P>
<P ALIGN="JUSTIFY">‘s:User-Startup’ file (only do the assignments required for the installed targets):</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vbcc: &lt;path to vbcc directory&gt;</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: C: vbcc:bin add</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludeos3: vbcc:targets/m68k-amigaos/include</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludeos3: &lt;path to your AmigaOS3 header files&gt; ADD</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vlibos3: vbcc:targets/m68k-amigaos/lib</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludeos4: vbcc:targets/ppc-amigaos/include</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludeos4: &lt;path to your AmigaOS4 header files&gt; ADD</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vlibos4: vbcc:targets/ppc-amigaos/lib</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludemos: vbcc:targets/ppc-morphos/include</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludemos: &lt;path to your MorphOS header files&gt; ADD</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vlibmos: vbcc:targets/ppc-morphos/lib</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludepup: vbcc:targets/ppc-powerup/include</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludepup: &lt;path to your AmigaOS3 header files&gt; ADD</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vlibpup: vbcc:targets/ppc-powerup/lib</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludewos: vbcc:target/ppc-warpos/include</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vincludewos: &lt;path to your AmigaOS3 header files&gt; ADD</P>
<P ALIGN="JUSTIFY">assign &gt;NIL: vlibwos: vbcc:target/ppc-warpos/lib</P>
<P ALIGN="JUSTIFY">Also, the stack-size has to be increased from the default. 40KB is a sensible value, for very</P>
<P ALIGN="JUSTIFY">large projects higher values might be necessary.</P>
<P ALIGN="JUSTIFY">There are di erent configuration files provided in the ‘config’-subdirectory to choose dif-</P>
<P ALIGN="JUSTIFY">ferent targets (i.e. the system you want to generate programs for) and hosts (i.e. the system</P>
<P ALIGN="JUSTIFY">you want the compiler an tools to run on). The general naming-scheme for these files ist</P>
<P ALIGN="JUSTIFY">&lt;target&gt; &lt;host&gt;.</P>
<P ALIGN="JUSTIFY">Available config files, when all targets are installed, are ‘aos68k’ (AmigaOS on M68k),</P>
<P ALIGN="JUSTIFY">‘aosppc’ (AmigaOS4 on PPC using vclib), ‘newlib’ (AmigaOS4 on PPC using newlib),</P>
<P ALIGN="JUSTIFY">‘morphos’ (PPC systems running MorphOS), ‘powerup’ (PPC boards using the PowerUp</P>
<P ALIGN="JUSTIFY">system), ‘warpos’ (PPC boards using the WarpOS system).</P>
<P ALIGN="JUSTIFY">You can choose one of these systems using the ‘+’-option of vc, e.g.</P>
<P ALIGN="JUSTIFY">vc +aos68k_powerup ...</P>
<P ALIGN="JUSTIFY">will compile for AmigaOS/68k using the compiler running on PowerUp.</P>
<P ALIGN="JUSTIFY"> Chapter 1: General</P>
<P ALIGN="JUSTIFY">5</P>
<P ALIGN="JUSTIFY">You may choose to create copies of some of these configuration files with simpler names.</P>
<P ALIGN="JUSTIFY">E.g. if you usually want the compiler to run on WarpOS you could copy ‘aos68k_warpos’</P>
<P ALIGN="JUSTIFY">to ‘aos68k’, ‘warpos_warpos’ to ‘warpos’ and so on. Then you can just specify the target</P>
<P ALIGN="JUSTIFY">and your preferred host system will be chosen automatically.</P>
<P ALIGN="JUSTIFY">Additionally, you may copy the configuration file for your preferred host/target-combination</P>
<P ALIGN="JUSTIFY">to ‘vc.config’. This configuration will be chosen by default if you do not specify anything.</P>
<P ALIGN="JUSTIFY">By default, the target-only-specifications use 68k-native tools on AmigaOS 2.x/3.x, e.g.</P>
<P ALIGN="JUSTIFY">‘+warpos’ will create code for WarpOS, but the compiler and tools will run on the 68k.</P>
<P ALIGN="JUSTIFY">The default ‘vc.config’ will then create code for 68k using tools running on 68k. Having</P>
<P ALIGN="JUSTIFY">installed the MorphOS-native binary archive instead, the default ‘vc.config’ will create</P>
<P ALIGN="JUSTIFY">PPC code for MorphOS using tools running on MorphOS.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">1.4 Tutorial</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Now you should be able to use vbcc. To compile and link the program ‘hello.c’, type</P>
<P ALIGN="JUSTIFY">vc hello.c</P>
<P ALIGN="JUSTIFY">The file ‘hello.c’ will be compiled and linked to create the executable a.out in the current</P>
<P ALIGN="JUSTIFY">directory.</P>
<P ALIGN="JUSTIFY">vc hello.c -o hello</P>
<P ALIGN="JUSTIFY">will do the same, but the created executable will be called ‘hello’.</P>
<P ALIGN="JUSTIFY">vc -c t1.c t2.c</P>
<P ALIGN="JUSTIFY">will compile ‘t1.c’ and ‘t2.c’ without linking, creating the object files ‘t1.o’ and ‘t2.o’.</P>
<P ALIGN="JUSTIFY">vc t1.o t2.o -o tt</P>
<P ALIGN="JUSTIFY">will link them together and create the executable ‘tt’.</P>
<P ALIGN="JUSTIFY">If your program uses  oating point, you may have to link with a math-library. The details</P>
<P ALIGN="JUSTIFY">are dependent on the target, but usually ‘-lm’ will be suitable (for AmigaOS on m68k</P>
<P ALIGN="JUSTIFY">choose one of ‘-lmieee’, ‘-lm881’ or ‘-lm040’).</P>
<P ALIGN="JUSTIFY">vc calc.c -o calc -lmieee</P>
<P ALIGN="JUSTIFY"> 6</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY"> Chapter 2: The Frontend</P>
<P ALIGN="JUSTIFY">7</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">2 The Frontend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter describes vc, the frontend for vbcc. It knows how to deal with di erent file</P>
<P ALIGN="JUSTIFY">types and optimization settings and will call the compiler, assembler and linker. It is not</P>
<P ALIGN="JUSTIFY">recommended to call the di erent translation-phases directly. vc provides an easy-to-use</P>
<P ALIGN="JUSTIFY">interface which is mostly compatible to Unix cc.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">2.1 Usage</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The general syntax for calling vc</P>
<P ALIGN="JUSTIFY">vc [options] file1 file2 ...</P>
<P ALIGN="JUSTIFY">processes all files according to their su x and links all objects together (unless any of ‘-E’,</P>
<P ALIGN="JUSTIFY">‘-S’, ‘-c’ is specified). The following file types are recognized:</P>
<P ALIGN="JUSTIFY">‘.c’ C source</P>
<P ALIGN="JUSTIFY">‘.i’ already preprocessed C source</P>
<P ALIGN="JUSTIFY">‘.scs’ assembly source to be fed to the scheduler</P>
<P ALIGN="JUSTIFY">‘.asm’</P>
<P ALIGN="JUSTIFY">‘.s’ assembly source</P>
<P ALIGN="JUSTIFY">‘.obj’</P>
<P ALIGN="JUSTIFY">‘.o’ object file</P>
<P ALIGN="JUSTIFY">Usually pattern matching is supported - however this depends on the port and the host</P>
<P ALIGN="JUSTIFY">system.</P>
<P ALIGN="JUSTIFY">The options recognized by vc are:</P>
<P ALIGN="JUSTIFY">‘-v’ Verbose mode. Prints all commands before executing them.</P>
<P ALIGN="JUSTIFY">‘-vv’ Very verbose. Displays some internals as well.</P>
<P ALIGN="JUSTIFY">‘-Ox’ Sets the optimization level.</P>
<P ALIGN="JUSTIFY">-O0 is equivalent to -O=0.</P>
<P ALIGN="JUSTIFY">-O will activate some optimizations (at the moment -O=991).</P>
<P ALIGN="JUSTIFY">-O2 will activate most optimizations (at the moment -O=1023 -schedule).</P>
<P ALIGN="JUSTIFY">-O3 will activate all optimizations (at the moment -O=~0 -schedule).</P>
<P ALIGN="JUSTIFY">-O4 will activate full cross-module-optimization.</P>
<P ALIGN="JUSTIFY">Also, -O3 will activate cross-module-optimizations. All source files specified</P>
<P ALIGN="JUSTIFY">on the command line will be passed to the compiler at once. Only one</P>
<P ALIGN="JUSTIFY">assembly/object-file will be produced (by default the name is the name of the</P>
<P ALIGN="JUSTIFY">first source file with corresponding su x).</P>
<P ALIGN="JUSTIFY">When compiling with -O4 and -c vbcc will not produce real object files but</P>
<P ALIGN="JUSTIFY">special files containing all necessary information to defer optimization and code-</P>
<P ALIGN="JUSTIFY">generation to link-time. This is useful to provide all files of a project to the</P>
<P ALIGN="JUSTIFY">optimizer and make full use of cross-module optimizations. Note that you must</P>
<P ALIGN="JUSTIFY">use vc to do the linking. vc will detect and handle these files correctly. They</P>
<P ALIGN="JUSTIFY"> 8</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">can not be linked directly. Also, make sure to pass all relevant compiler options</P>
<P ALIGN="JUSTIFY">also to the linker-command.</P>
<P ALIGN="JUSTIFY">Higher values may or may not activate even more optimizations. The default</P>
<P ALIGN="JUSTIFY">is -O=1. It is also possible to specify an exact value with -O=n. However, I do</P>
<P ALIGN="JUSTIFY">not recommend this unless you know exactly what you are doing.</P>
<P ALIGN="JUSTIFY">‘-o file’ Save the target as ‘file’ (default for executables is ‘a.out’).</P>
<P ALIGN="JUSTIFY">‘-E’ Save the preprocessed C sources with .i su x.</P>
<P ALIGN="JUSTIFY">‘-S’ Do not assemble. Save the compiled files with .asm su x.</P>
<P ALIGN="JUSTIFY">‘-SCS’ Do not schedule. Save the compiled files with .scs su x.</P>
<P ALIGN="JUSTIFY">‘-c’ Do not link. Save the compiled files with .o su x.</P>
<P ALIGN="JUSTIFY">‘-k’ Keep all intermediate files. By default all generated files except the source files</P>
<P ALIGN="JUSTIFY">and the targets are deleted.</P>
<P ALIGN="JUSTIFY">‘-Dstr’ #define a preprocessor symbol, e.g. -DAMIGA or -DCPU=68000. The former</P>
<P ALIGN="JUSTIFY">syntax is equivalent to:</P>
<P ALIGN="JUSTIFY">#define AMIGA 1</P>
<P ALIGN="JUSTIFY">The latter form is equivalent to:</P>
<P ALIGN="JUSTIFY">#define CPU 68000</P>
<P ALIGN="JUSTIFY">‘-Ipath’ Add ‘path’ to the include-search-path.</P>
<P ALIGN="JUSTIFY">‘-lulib’ Link with library ‘ulib’.</P>
<P ALIGN="JUSTIFY">‘-Lpath’ Add ‘path’ to the library-search-path. This is passed through to the linker.</P>
<P ALIGN="JUSTIFY">‘-static’ Instruct the linker to link against static libraries. This may override the default</P>
<P ALIGN="JUSTIFY">to link against dynamic libraries first.</P>
<P ALIGN="JUSTIFY">‘-nostdlib’</P>
<P ALIGN="JUSTIFY">Do not link with standard-startup/libraries. Useful only for people who know</P>
<P ALIGN="JUSTIFY">what they are doing.</P>
<P ALIGN="JUSTIFY">‘-notmpfile’</P>
<P ALIGN="JUSTIFY">Do not use names from tmpnam() for temporary files.</P>
<P ALIGN="JUSTIFY">‘-schedule’</P>
<P ALIGN="JUSTIFY">Invoke the instruction-scheduler, if available.</P>
<P ALIGN="JUSTIFY">‘+file’ Use ‘file’ as config-file.</P>
<P ALIGN="JUSTIFY">All other options are passed through to vbcc.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">2.2 Configuration</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vc needs a config file to know how to call all the translation phases (compiler, assem-</P>
<P ALIGN="JUSTIFY">bler, linker). Unless a di erent file is specified using the ‘+’-option, it will look for a file</P>
<P ALIGN="JUSTIFY">‘vc.config’ (‘vc.cfg’ for DOS/Windows).</P>
<P ALIGN="JUSTIFY">On AmigaOS vc will search in the current directory, in ‘ENV:’ and ‘VBCC:’.</P>
<P ALIGN="JUSTIFY">On Unix vc will search in the current directory followed by ‘/etc/’.</P>
<P ALIGN="JUSTIFY"> Chapter 2: The Frontend</P>
<P ALIGN="JUSTIFY">9</P>
<P ALIGN="JUSTIFY">On DOS/Windows it will search in the current directory.</P>
<P ALIGN="JUSTIFY">If the config file was not found in the default search-paths and an environment variable</P>
<P ALIGN="JUSTIFY">$VBCC is set, vc will also look in $VBCC‘/config’.</P>
<P ALIGN="JUSTIFY">Once a config file is found, it will be treated as a collection of additional command line</P>
<P ALIGN="JUSTIFY">arguments. Every line of the file will be used as one argument. So no quoting shall be used</P>
<P ALIGN="JUSTIFY">and furthermore must each argument be placed on its own line.</P>
<P ALIGN="JUSTIFY">The following options can be used to tell vc how to call the translation phases (they will</P>
<P ALIGN="JUSTIFY">usually be contained in the config-file):</P>
<P ALIGN="JUSTIFY">‘-pp=string’</P>
<P ALIGN="JUSTIFY">The preprocessor will be called like in printf(string,opts,infile,outfile),</P>
<P ALIGN="JUSTIFY">e.g. the default for vcpp searching the includes in ‘vinclude:’ and defining __</P>
<P ALIGN="JUSTIFY">STDC__) is ‘-pp=vcpp -Ivinclude: -D__STDC__=1 %s %s %s’. Note that there</P>
<P ALIGN="JUSTIFY">is an internal preprocessor, called ucpp, since V0.8, you usually don’t need this</P>
<P ALIGN="JUSTIFY">option any more.</P>
<P ALIGN="JUSTIFY">‘-cc=string’</P>
<P ALIGN="JUSTIFY">For the compiler. Note that you cannot use vc to call another compiler than</P>
<P ALIGN="JUSTIFY">vbcc. But you can call di erent versions of vbcc this way, e.g.: ‘-cc=vbccm68k</P>
<P ALIGN="JUSTIFY">-quiet’ or ‘-cc=vbcci386 -quiet’</P>
<P ALIGN="JUSTIFY">‘-isc=string’</P>
<P ALIGN="JUSTIFY">The same for the scheduler, e.g.: ‘-isc=vscppc -quiet %s %s’ Omit, if there is</P>
<P ALIGN="JUSTIFY">no scheduler for the architecture.</P>
<P ALIGN="JUSTIFY">‘-as=string’</P>
<P ALIGN="JUSTIFY">The same for the assembler, e.g.: ‘-as=vasmm68k_mot -quiet -Fhunk -phxass</P>
<P ALIGN="JUSTIFY">-opt-pea -opt-clr %s -o %s’ or ‘-as=as %s -o %s’</P>
<P ALIGN="JUSTIFY">‘-rm=string’</P>
<P ALIGN="JUSTIFY">This is the string for the delete command and takes only one argument, e.g.</P>
<P ALIGN="JUSTIFY">‘-rm=delete quiet %s’ or ‘-rm=rm %s’</P>
<P ALIGN="JUSTIFY">‘-ld=string’</P>
<P ALIGN="JUSTIFY">This is for the linker and takes three arguments. The first one are the object</P>
<P ALIGN="JUSTIFY">files (separated by spaces), the second one the user specified libraries and</P>
<P ALIGN="JUSTIFY">the last one the name of the resulting executable. This has to link with</P>
<P ALIGN="JUSTIFY">proper startup-code and c-libraries, e.g.: ‘-ld=vlink -x -Bstatic -Cvbcc</P>
<P ALIGN="JUSTIFY">-nostdlib -Lvlibos3: vlibos3:startup.o %s %s -lvc -o %s’ or ‘-ld=ld</P>
<P ALIGN="JUSTIFY">/usr/lib/crt0.o %s %s -lc -o %s’</P>
<P ALIGN="JUSTIFY">‘-l2=string’</P>
<P ALIGN="JUSTIFY">The same like -ld, but standard-startup and -libraries should not be linked;</P>
<P ALIGN="JUSTIFY">used when -nostdlib is specified.</P>
<P ALIGN="JUSTIFY">‘-ldnodb=string’</P>
<P ALIGN="JUSTIFY">This option string is inserted in the linker command before specifying the li-</P>
<P ALIGN="JUSTIFY">braries, whenever an executable without debugging information and symbols</P>
<P ALIGN="JUSTIFY">should be created (AKA as a ’stripped’ executable).</P>
<P ALIGN="JUSTIFY"> 10</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">‘-ldstatic=string’</P>
<P ALIGN="JUSTIFY">This option string is inserted in the linker command before specifying the li-</P>
<P ALIGN="JUSTIFY">braries when static linking was requested with option ‘-static’.</P>
<P ALIGN="JUSTIFY">All those strings should tell the command to omit any output apart from error messages</P>
<P ALIGN="JUSTIFY">if possible. However for every of those options there exists one with an additional ‘v’, i.e.</P>
<P ALIGN="JUSTIFY">‘-ppv=’, ‘-asv=’, etc. which should produce some output, if possible. If vc is invoked with</P>
<P ALIGN="JUSTIFY">the ‘-vv’ option the verbose commands will be called, if not the quiet ones will be used.</P>
<P ALIGN="JUSTIFY">‘-ul=string’</P>
<P ALIGN="JUSTIFY">Format for additional libraries specified with ‘-l&lt;lib&gt;’. The result of</P>
<P ALIGN="JUSTIFY">printf(string,lib) will be added to the command invoking the linker.</P>
<P ALIGN="JUSTIFY">Examples are: ‘-ul=vlib:%s.lib’ or ‘-ul=-l%s’</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">11</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">3 The Compiler</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter describes the target-independent part of the compiler. It documents the op-</P>
<P ALIGN="JUSTIFY">tions and extensions which are not specific to a certain target. Be sure to also read the</P>
<P ALIGN="JUSTIFY">chapter on the backend you are using. It will likely contain important additional information</P>
<P ALIGN="JUSTIFY">like data-representation or additional options.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.1 General Compiler Options</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Usually vbcc will be called by vc. However, if called directly it expects the following syntax:</P>
<P ALIGN="JUSTIFY">vbcc&lt;target&gt; [options] file</P>
<P ALIGN="JUSTIFY">The following options are supported by the machine independent part of vbcc (and will be</P>
<P ALIGN="JUSTIFY">passed through by vc):</P>
<P ALIGN="JUSTIFY">‘-quiet’ Do not print the copyright notice.</P>
<P ALIGN="JUSTIFY">‘-ic1’ Write the intermediate code before optimizing to file.ic1.</P>
<P ALIGN="JUSTIFY">‘-ic2’ Write the intermediate code after optimizing to file.ic2.</P>
<P ALIGN="JUSTIFY">‘-debug=n’</P>
<P ALIGN="JUSTIFY">Set the debug level to n.</P>
<P ALIGN="JUSTIFY">‘-o=ofile’</P>
<P ALIGN="JUSTIFY">Write the generated assembler output to &lt;ofile&gt; rather than the default file.</P>
<P ALIGN="JUSTIFY">‘-noasm’ Do not generate assembler output (only for testing).</P>
<P ALIGN="JUSTIFY">‘-O=n’ Turns optimizing options on/o ; every bit set in n turns on an option. Usually</P>
<P ALIGN="JUSTIFY">the predefined optimization options by the compiler driver should be used. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4 [Optimizations], page 16</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-speed’ Turns on optimizations which improve speed even if they increase code-size</P>
<P ALIGN="JUSTIFY">quite a bit.</P>
<P ALIGN="JUSTIFY">‘-size’ Turns on optimizations which improve code-size even if they have negative e ect</P>
<P ALIGN="JUSTIFY">on execution-times.</P>
<P ALIGN="JUSTIFY">‘-final’ This  ag is useful only with higher optimization levels. It tells the compiler</P>
<P ALIGN="JUSTIFY">that all relevant files have been provided to the compiler (i.e. it is the link-</P>
<P ALIGN="JUSTIFY">stage). The compiler will try to eliminate all functions and variables which are</P>
<P ALIGN="JUSTIFY">not referenced.</P>
<P ALIGN="JUSTIFY">See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.13 [Unused Object Elimination], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-wpo’ Create a high-level pseudo object for cross-module optimization (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">‘-g’ Create debug output. Whether this is supported as well as the format of the</P>
<P ALIGN="JUSTIFY">debug information depends on the backend. Some backends may o er additional</P>
<P ALIGN="JUSTIFY">options to control the generation of debug output.</P>
<P ALIGN="JUSTIFY">Usually DWARF2-output will be generated by default, if possible.</P>
<P ALIGN="JUSTIFY">Also, options regarding optimization and code-generation may a ect the debug</P>
<P ALIGN="JUSTIFY">output (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.19 [Debugging Optimized Code], page 31</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY"> 12</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">‘-cmd=&lt;file&gt;’</P>
<P ALIGN="JUSTIFY">A file containing additional command line options can be specified using this</P>
<P ALIGN="JUSTIFY">command. This may be useful for very long command lines.</P>
<P ALIGN="JUSTIFY">‘-c99’ Switch to the 1999 ISO standard for C /ISO/IEC9899:1999). Currently the</P>
<P ALIGN="JUSTIFY">following changes of C99 are handled:</P>
<P ALIGN="JUSTIFY">- long long int (not supported by all backends)</P>
<P ALIGN="JUSTIFY">-  exible array members as last element of a struct</P>
<P ALIGN="JUSTIFY">- mixed statements and declarations</P>
<P ALIGN="JUSTIFY">- declarations within for-loops</P>
<P ALIGN="JUSTIFY">- inline function-specifier</P>
<P ALIGN="JUSTIFY">- restrict-qualifier</P>
<P ALIGN="JUSTIFY">- new reserved keywords</P>
<P ALIGN="JUSTIFY">- //-comments</P>
<P ALIGN="JUSTIFY">- vararg-macros</P>
<P ALIGN="JUSTIFY">- _Pragma</P>
<P ALIGN="JUSTIFY">- implicit int deprecated</P>
<P ALIGN="JUSTIFY">- implicit function-declarations deprecated</P>
<P ALIGN="JUSTIFY">- increased translation-limits</P>
<P ALIGN="JUSTIFY">- variable-length arrays (incomplete)</P>
<P ALIGN="JUSTIFY">‘-unsigned-char’</P>
<P ALIGN="JUSTIFY">Make the unqualified type of char unsigned.</P>
<P ALIGN="JUSTIFY">‘-maxoptpasses=n’</P>
<P ALIGN="JUSTIFY">Set maximum number of optimizer passes to n. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4 [Optimizations],</P>
<P ALIGN="JUSTIFY">page 16</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-inline-size=n’</P>
<P ALIGN="JUSTIFY">Set the maximum ’size’ of functions to be inlined. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.11 [Function</P>
<P ALIGN="JUSTIFY">Inlining], page 25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-inline-depth=n’</P>
<P ALIGN="JUSTIFY">Inline functions up to n nesting-levels (including recursive calls). The default</P>
<P ALIGN="JUSTIFY">value is 1. Be careful with values greater than 2. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.11 [Function</P>
<P ALIGN="JUSTIFY">Inlining], page 25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-unroll-size=n’</P>
<P ALIGN="JUSTIFY">Set the maximum ’size’ of unrolled loops. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.10 [Loop Unrolling],</P>
<P ALIGN="JUSTIFY">page 23</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-unroll-all’</P>
<P ALIGN="JUSTIFY">Unroll loops with a non-constant number of iterations if the number can be cal-</P>
<P ALIGN="JUSTIFY">culated at runtime before entering the loop. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.10 [Loop Unrolling],</P>
<P ALIGN="JUSTIFY">page 23</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-no-inline-peephole’</P>
<P ALIGN="JUSTIFY">Some backends provide peephole-optimizers which perform simple optimiza-</P>
<P ALIGN="JUSTIFY">tions on the assembly code output by vbcc. By default, these optimizations</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">13</P>
<P ALIGN="JUSTIFY">will also be performed on inline-assembly code of the application. This switch</P>
<P ALIGN="JUSTIFY">turns o  this behaviour. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.3 [Inline-Assembly Functions], page 33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-fp-associative’</P>
<P ALIGN="JUSTIFY">Floating point operations do not obey the law of associativity, e.g.</P>
<P ALIGN="JUSTIFY">(a+b)+c==a+(b+c) is not true for all  oating point numbers a,b,c. Therefore</P>
<P ALIGN="JUSTIFY">certain optimizations depending on this property cannot be performed on</P>
<P ALIGN="JUSTIFY">oating point numbers.</P>
<P ALIGN="JUSTIFY">This option tells vbcc to treat  oating point operations as associative and</P>
<P ALIGN="JUSTIFY">perform those optimizations even if that may change the results in some cases</P>
<P ALIGN="JUSTIFY">(not ISO conforming).</P>
<P ALIGN="JUSTIFY">‘-no-alias-opt’</P>
<P ALIGN="JUSTIFY">Do not perform type-based alias analysis. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis],</P>
<P ALIGN="JUSTIFY">page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">‘-no-multiple-ccs’</P>
<P ALIGN="JUSTIFY">If the backend supports multiple condition code registers, vbcc will try to use</P>
<P ALIGN="JUSTIFY">them when optimizing. This  ag prevents vbcc from using them.</P>
<P ALIGN="JUSTIFY">‘-double-push’</P>
<P ALIGN="JUSTIFY">On targets where function-arguments are passed in registers but also stack-slots</P>
<P ALIGN="JUSTIFY">are left empty for such arguments, pass those arguments both in registers and</P>
<P ALIGN="JUSTIFY">on the stack.</P>
<P ALIGN="JUSTIFY">This generates less e cient code but some broken code (e.g. code which calls</P>
<P ALIGN="JUSTIFY">varargs functions without correct prototypes in scope) may work.</P>
<P ALIGN="JUSTIFY">‘-short-push’</P>
<P ALIGN="JUSTIFY">In the presence of a prototype, no promotion will be done on function argu-</P>
<P ALIGN="JUSTIFY">ments. For example, &lt;char&gt; will be passed as &lt;char&gt; rather than &lt;int&gt; and</P>
<P ALIGN="JUSTIFY">&lt; oat&gt; will not be promoted to &lt;double&gt;. This may be more e cient on small</P>
<P ALIGN="JUSTIFY">targets.</P>
<P ALIGN="JUSTIFY">However, please note that this feature may not be supported by all backends</P>
<P ALIGN="JUSTIFY">and that using this option breaks ANSI/ISO conformance. For example, a</P>
<P ALIGN="JUSTIFY">function with a &lt;char&gt; parameter must never be called without a prototype in</P>
<P ALIGN="JUSTIFY">scope.</P>
<P ALIGN="JUSTIFY">‘-soft-float’</P>
<P ALIGN="JUSTIFY">On targets supporting this  ag, software  oating point emulation will be used</P>
<P ALIGN="JUSTIFY">rather than a hardware FPU. Please consult the corresponding backend docu-</P>
<P ALIGN="JUSTIFY">mentation when using this  ag.</P>
<P ALIGN="JUSTIFY">‘-stack-check’</P>
<P ALIGN="JUSTIFY">Insert code for dynamic stack checking/extending if the backend and the envi-</P>
<P ALIGN="JUSTIFY">ronment support this feature.</P>
<P ALIGN="JUSTIFY">‘-ansi’</P>
<P ALIGN="JUSTIFY">‘-iso’ Switch to ANSI/ISO mode.</P>
<P ALIGN="JUSTIFY">- In ISO mode warning 209 will be printed by default.</P>
<P ALIGN="JUSTIFY">- Inline-assembly functions are not recognized.</P>
<P ALIGN="JUSTIFY"> 14</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">- Assignments between pointers to &lt;type&gt; and pointers to unsigned &lt;type&gt;</P>
<P ALIGN="JUSTIFY">will cause warnings.</P>
<P ALIGN="JUSTIFY">‘-maxerrors=n’</P>
<P ALIGN="JUSTIFY">Abort the compilation after n errors; do not stop if n==0.</P>
<P ALIGN="JUSTIFY">‘-dontwarn=n’</P>
<P ALIGN="JUSTIFY">Suppress warning number n; suppress all warnings if n&lt;0. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.2</P>
<P ALIGN="JUSTIFY">[Errors and Warnings], page 14</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">‘-warn=n’ Turn on warning number n; turn on all warnings if n&lt;0. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.2 [Errors</P>
<P ALIGN="JUSTIFY">and Warnings], page 14</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">‘-strip-path’</P>
<P ALIGN="JUSTIFY">Strip the path of filenames from error messages. Error messages may look more</P>
<P ALIGN="JUSTIFY">convenient that way, but message browsers or similar programs might need full</P>
<P ALIGN="JUSTIFY">paths.</P>
<P ALIGN="JUSTIFY">‘-+’</P>
<P ALIGN="JUSTIFY">‘-cpp-comments’</P>
<P ALIGN="JUSTIFY">Allow C++ style comments (not ISO89 conforming).</P>
<P ALIGN="JUSTIFY">‘-no-trigraphs’</P>
<P ALIGN="JUSTIFY">Do not recognize trigraphs (not ISO conforming).</P>
<P ALIGN="JUSTIFY">‘-E’ Write the preprocessor output to &lt;file&gt;.i.</P>
<P ALIGN="JUSTIFY">‘-reserve-reg=&lt;register&gt;’</P>
<P ALIGN="JUSTIFY">Reserve that register not to be used by the backend. This option is dangerous</P>
<P ALIGN="JUSTIFY">and must only be used for registers otherwise available for the register allocator.</P>
<P ALIGN="JUSTIFY">If it used for special registers or registers used internally by the backend, it may</P>
<P ALIGN="JUSTIFY">be ignored, lead to corrupt code or even cause internal errors from the compiler.</P>
<P ALIGN="JUSTIFY">Only use if you know what you are doing!</P>
<P ALIGN="JUSTIFY">‘-dontkeep-initialized-data’</P>
<P ALIGN="JUSTIFY">By default vbcc keeps all data of initializations in memory during the whole</P>
<P ALIGN="JUSTIFY">compilation (it can sometimes make use of this when optimizing). This can</P>
<P ALIGN="JUSTIFY">take some amount of memory, though. This options tells vbcc to keep as little</P>
<P ALIGN="JUSTIFY">of this data in memory as possible. This has not yet been tested very well.</P>
<P ALIGN="JUSTIFY">The assembler output will be saved to ‘file.asm’ (if ‘file’ already contained a su x, this</P>
<P ALIGN="JUSTIFY">will first be removed; same applies to .ic1/.ic2)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.2 Errors and Warnings</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc knows the following kinds of messages:</P>
<P ALIGN="JUSTIFY">Fatal Errors</P>
<P ALIGN="JUSTIFY">Something is badly wrong and further compilation is impossible or pointless.</P>
<P ALIGN="JUSTIFY">vbcc will abort. E.g. no source file or really corrupt source.</P>
<P ALIGN="JUSTIFY">Errors There was an error and vbcc cannot generate useful code. Compilation contin-</P>
<P ALIGN="JUSTIFY">ues, but no code will be generated. E.g. unknown identifiers.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">15</P>
<P ALIGN="JUSTIFY">Warnings (1)</P>
<P ALIGN="JUSTIFY">Warnings with ISO-violations. The program is not ISO-conforming, but vbcc</P>
<P ALIGN="JUSTIFY">will generate code that could be what you want (or not). E.g. missing semi-</P>
<P ALIGN="JUSTIFY">colon.</P>
<P ALIGN="JUSTIFY">Warnings (2)</P>
<P ALIGN="JUSTIFY">The code has no ISO-violations, but contains some strange things you should</P>
<P ALIGN="JUSTIFY">perhaps look at. E.g. unused variables.</P>
<P ALIGN="JUSTIFY">Errors or the first kind of warnings are always displayed and cannot be suppressed.</P>
<P ALIGN="JUSTIFY">Only some warnings of the second kind are turned on by default. Many of them are very</P>
<P ALIGN="JUSTIFY">useful for some but annoying to others, and their usability may depend on programming</P>
<P ALIGN="JUSTIFY">style. Everybody is recommended to find their own preferences.</P>
<P ALIGN="JUSTIFY">A good way to do this is starting with all warnings turned on by ‘-warn=-1’. Now all possible</P>
<P ALIGN="JUSTIFY">warnings will be issued. Everytime a warning that is not considered useful appears, turn</P>
<P ALIGN="JUSTIFY">that one o  with ‘-dontwarn=n’.</P>
<P ALIGN="JUSTIFY">See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Chapter 12 [List of Errors], page 79</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">for a list of all diagnostic messages available.</P>
<P ALIGN="JUSTIFY">See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Chapter 2 [The Frontend], page 7</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">to find out how to configure vc to your preferences.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.3 Data Types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc can handle the following atomic data types:</P>
<P ALIGN="JUSTIFY">signed char</P>
<P ALIGN="JUSTIFY">unsigned char</P>
<P ALIGN="JUSTIFY">signed short</P>
<P ALIGN="JUSTIFY">unsigned short</P>
<P ALIGN="JUSTIFY">signed int</P>
<P ALIGN="JUSTIFY">unsigned int</P>
<P ALIGN="JUSTIFY">signed long int</P>
<P ALIGN="JUSTIFY">unsigned long int</P>
<P ALIGN="JUSTIFY">signed long long int</P>
<P ALIGN="JUSTIFY">(with ‘-c99’)</P>
<P ALIGN="JUSTIFY">unsigned long long int</P>
<P ALIGN="JUSTIFY">(with ‘-c99’)</P>
<P ALIGN="JUSTIFY">float</P>
<P ALIGN="JUSTIFY">double</P>
<P ALIGN="JUSTIFY">long double</P>
<P ALIGN="JUSTIFY">The default signedness for integer types is signed.</P>
<P ALIGN="JUSTIFY">Depending on the backend, some of these types can have identical representation. The</P>
<P ALIGN="JUSTIFY">representation (size, alignment etc.) of these types usually varies between di erent backends.</P>
<P ALIGN="JUSTIFY">vbcc is able to support arbitrary implementations.</P>
<P ALIGN="JUSTIFY">Backends may be restricted and omit some types (e.g.  oating point on small embedded</P>
<P ALIGN="JUSTIFY">architectures) or o er additional types. E.g. some backends may provide special bit types</P>
<P ALIGN="JUSTIFY">or di erent pointer types.</P>
<P ALIGN="JUSTIFY"> 16</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4 Optimizations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc o ers di erent levels of optimization, ranging from fast compilation with straight-</P>
<P ALIGN="JUSTIFY">forward code suitable for easy debugging to highly aggressive cross-module optimizations</P>
<P ALIGN="JUSTIFY">delivering very fast and/or tight code.</P>
<P ALIGN="JUSTIFY">This section describes the general phases of compilation and gives a short overview on the</P>
<P ALIGN="JUSTIFY">available optimizations.</P>
<P ALIGN="JUSTIFY">In the first compilation phase every function is parsed into a tree structure one expression</P>
<P ALIGN="JUSTIFY">after the other. Type-checking and some minor optimizations like constant-folding or some</P>
<P ALIGN="JUSTIFY">algebraic simplifications are done on the trees. This phase of the translation is identical in</P>
<P ALIGN="JUSTIFY">optimizing and non-optimizing compilation.</P>
<P ALIGN="JUSTIFY">Then intermediate code is generated from the trees. In non-optimizing compilation tem-</P>
<P ALIGN="JUSTIFY">poraries needed to evaluate the expression are immediately assigned to registers while in</P>
<P ALIGN="JUSTIFY">optimizing compilation, a new variable is generated for each temporary. Slightly di erent</P>
<P ALIGN="JUSTIFY">intermediate code is produced in optimizing compilation. Some minor optimizations are</P>
<P ALIGN="JUSTIFY">performed while generating the intermediate code (simple elimination of unreachable code,</P>
<P ALIGN="JUSTIFY">some optimizations on branches etc.).</P>
<P ALIGN="JUSTIFY">After intermediate code for the whole function has been generated, simple register alloca-</P>
<P ALIGN="JUSTIFY">tion may be done in non-optimizing compilation if bit 1 has been set in the ‘-O’ option.</P>
<P ALIGN="JUSTIFY">Afterwards, the intermediate code is passed to the code generator and then all memory for</P>
<P ALIGN="JUSTIFY">the function, its variables etc. is freed.</P>
<P ALIGN="JUSTIFY">In optimizing compilation  owgraphs are constructed, data  ow analysis is performed and</P>
<P ALIGN="JUSTIFY">many passes are made over the function’s intermediate code. Code may be moved around,</P>
<P ALIGN="JUSTIFY">new variables may be added, other variables removed etc. etc. (for more detailed informa-</P>
<P ALIGN="JUSTIFY">tion on the optimizations look at the description for the ‘-O’ option below).</P>
<P ALIGN="JUSTIFY">Many of the optimization routines depend on each other. If one routine finds an optimiza-</P>
<P ALIGN="JUSTIFY">tion, this often enables other routines to find further ones. Also, some routines only do a</P>
<P ALIGN="JUSTIFY">first step and let other routines ’clean up’ afterwards. Therefore vbcc usually makes many</P>
<P ALIGN="JUSTIFY">passes until no further optimizations are found. To avoid possible extremely long optimiza-</P>
<P ALIGN="JUSTIFY">tion times, the number of those passes can be limited with ‘-maxoptpasses’ (the default is</P>
<P ALIGN="JUSTIFY">max. 10 passes). vbcc will display a warning if more passes might be useful.</P>
<P ALIGN="JUSTIFY">Depending on the optimization level, a whole translation-unit or even several translation-</P>
<P ALIGN="JUSTIFY">units will be read at once. Also, the intermediate code for all functions may be kept in</P>
<P ALIGN="JUSTIFY">memory during the entire compilation. Be aware that higher optimization levels can take</P>
<P ALIGN="JUSTIFY">much more time and memory to complete.</P>
<P ALIGN="JUSTIFY">The following table lists the optimizations which are activated by bits in the argument of</P>
<P ALIGN="JUSTIFY">the ‘-O’ option. Note that not all combinations are valid. It is heavily recommended not to</P>
<P ALIGN="JUSTIFY">fiddle with this option but just use one of the settings provided by vc (e.g. ‘-O0’ - ‘-O4’).</P>
<P ALIGN="JUSTIFY">These options also automatically handle actions like invoking the scheduler or cross-module</P>
<P ALIGN="JUSTIFY">optimizer.</P>
<P ALIGN="JUSTIFY">Bit 0 (1) Perform Register allocation. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.1 [Register Allocation], page 18</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">Bit 1 (2) This  ag turns on the optimizer. If it is set to zero, no global optimizations will</P>
<P ALIGN="JUSTIFY">be performed, no matter what the other  ags are set to. Slightly di erent inter-</P>
<P ALIGN="JUSTIFY">mediate code will be generated by the first translation phases and a  owgraph</P>
<P ALIGN="JUSTIFY">will be constructed. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.2 [Flow Optimizations], page 18</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">17</P>
<P ALIGN="JUSTIFY">Bit 2 (4) Perform common subexpression elimination (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.3 [Common Subex-</P>
<P ALIGN="JUSTIFY">pression Elimination], page 19</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) and copy propagation (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.4 [Copy</P>
<P ALIGN="JUSTIFY">Propagation], page 19</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). This can be done globally or only within basic blocks</P>
<P ALIGN="JUSTIFY">depending on bit 5.</P>
<P ALIGN="JUSTIFY">Bit 3 (8) Perform constant propagation (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.5 [Constant Propagation],</P>
<P ALIGN="JUSTIFY">page 20</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). This can be done globally or only within basic blocks depending on</P>
<P ALIGN="JUSTIFY">bit 5.</P>
<P ALIGN="JUSTIFY">Bit 4 (16) Perform dead code elimination (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.6 [Dead Code Elimination],</P>
<P ALIGN="JUSTIFY">page 21</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Bit 5 (32) Some optimizations are available in local and global versions. This  ag turns</P>
<P ALIGN="JUSTIFY">on the global versions. Several major optimizations will not be performed and</P>
<P ALIGN="JUSTIFY">only one optimization pass is done unless this  ag is set.</P>
<P ALIGN="JUSTIFY">Bit 6 (64) Reserved.</P>
<P ALIGN="JUSTIFY">Bit 7 (128)</P>
<P ALIGN="JUSTIFY">vbcc will try to identify loops and perform some loop optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 3.4.8 [Strength Reduction], page 22</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.7 [Loop-Invariant Code</P>
<P ALIGN="JUSTIFY">Motion], page 21</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">. These only work if bit 5 (32) is set.</P>
<P ALIGN="JUSTIFY">Bit 8 (256)</P>
<P ALIGN="JUSTIFY">vbcc tries to place variables at the same memory addresses if possible (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.13 [Unused Object Elimination], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Bit 9 (512)</P>
<P ALIGN="JUSTIFY">Reserved.</P>
<P ALIGN="JUSTIFY">Bit 10 (1024)</P>
<P ALIGN="JUSTIFY">Pointers are analyzed and more precise alias-information is generated (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). Using this information, better data- ow</P>
<P ALIGN="JUSTIFY">analysis is possible.</P>
<P ALIGN="JUSTIFY">Also, vbcc tries to place global/static variables and variables which have their</P>
<P ALIGN="JUSTIFY">address taken in registers, if possible (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.1 [Register Allocation],</P>
<P ALIGN="JUSTIFY">page 18</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Bit 11 (2048)</P>
<P ALIGN="JUSTIFY">More aggressive loop optimizations are performed (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.10 [Loop</P>
<P ALIGN="JUSTIFY">Unrolling], page 23</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.9 [Induction Variable Elimination], page 22</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Only works if bit 5 (32) and bit 7 (128) are set.</P>
<P ALIGN="JUSTIFY">Bit 12 (4096)</P>
<P ALIGN="JUSTIFY">Perform function inlining (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.11 [Function Inlining], page 25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Bit 13 (8192)</P>
<P ALIGN="JUSTIFY">Reserved.</P>
<P ALIGN="JUSTIFY">Bit 14 (16384)</P>
<P ALIGN="JUSTIFY">Perform inter-procedural analysis (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analy-</P>
<P ALIGN="JUSTIFY">sis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) and cross-module optimizations (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module</P>
<P ALIGN="JUSTIFY">Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY"> 18</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Also look at the documentation for the target-dependent part of vbcc. There may be</P>
<P ALIGN="JUSTIFY">additional machine specific optimization options.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.1 Register Allocation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This optimization tries to assign variables or temporaries into machine registers to save</P>
<P ALIGN="JUSTIFY">time and space. The scope and details of this optimization vary on the optimization level.</P>
<P ALIGN="JUSTIFY">With ‘-O0’ only temporaries during expression-evaluation are put into registers. This may</P>
<P ALIGN="JUSTIFY">be useful for debugging.</P>
<P ALIGN="JUSTIFY">At the default level (without the optimizer), additionally local variables whose address has</P>
<P ALIGN="JUSTIFY">not been taken may be put into registers for a whole function. The decision which variables</P>
<P ALIGN="JUSTIFY">to assign to registers is based on very simple heuristics.</P>
<P ALIGN="JUSTIFY">In optimizing compilation a di erent algorithm will be used which uses hierarchical live-</P>
<P ALIGN="JUSTIFY">range-splitting. This means that variables may be assigned to di erent registers at di erent</P>
<P ALIGN="JUSTIFY">time. This typically allows to put the most used variables into registers in all inner loops.</P>
<P ALIGN="JUSTIFY">Note that this means that a variable can be located in di erent registers at di erent loca-</P>
<P ALIGN="JUSTIFY">tions. Most debuggers can not handle this.</P>
<P ALIGN="JUSTIFY">Also, the use of registers can be guided by information provided by the backend, if available.</P>
<P ALIGN="JUSTIFY">For architectures which are not very orthogonal this allows to choose registers which are</P>
<P ALIGN="JUSTIFY">better suited to certain operations. Constants can also be assigned to registers, if this is</P>
<P ALIGN="JUSTIFY">beneficial for the architecture.</P>
<P ALIGN="JUSTIFY">The options ‘-speed’ and ‘-size’ change the behaviour of the register-allocator to optimize</P>
<P ALIGN="JUSTIFY">for speed or size of the generated code.</P>
<P ALIGN="JUSTIFY">On low optimization levels, only local variables whose address has not been taken will be</P>
<P ALIGN="JUSTIFY">assigned to registers. On higher optimization levels, vbcc will also try to assign global/static</P>
<P ALIGN="JUSTIFY">variables and variables which had their address taken, to registers. Typically, this occurs</P>
<P ALIGN="JUSTIFY">during loops. The variables will be loaded into a register before entering a loop and stored</P>
<P ALIGN="JUSTIFY">back after the loop. However, this can only be done if vbcc can detect that the variable is</P>
<P ALIGN="JUSTIFY">not modified in unpredictable ways. Therefore, alias-analysis is crucial for this optimization.</P>
<P ALIGN="JUSTIFY">During register-allocation vbcc will use information on register usage of functions to mini-</P>
<P ALIGN="JUSTIFY">mize loading/saving of registers between function-calls. Therefore, other optimizations will</P>
<P ALIGN="JUSTIFY">a ect register allocation. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-</P>
<P ALIGN="JUSTIFY">Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.2 Flow Optimizations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When optimizing vbcc will construct a  owgraph for every function and perform optimiza-</P>
<P ALIGN="JUSTIFY">tions based on control- ow. For example, code which is unreachable will be removed and</P>
<P ALIGN="JUSTIFY">branches to other branches or branches around branches will be simplified.</P>
<P ALIGN="JUSTIFY">Also, unused labels will be removed and basic blocks united to allow further optimizations.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(x &gt; y)</P>
<P ALIGN="JUSTIFY">goto label1;</P>
<P ALIGN="JUSTIFY">q();</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">19</P>
<P ALIGN="JUSTIFY">label1:</P>
<P ALIGN="JUSTIFY">goto label2;</P>
<P ALIGN="JUSTIFY">r();</P>
<P ALIGN="JUSTIFY">label2:</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(x &lt;= y)</P>
<P ALIGN="JUSTIFY">q();</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Identical code at the beginning or end of basic blocks will be moved to the</P>
<P ALIGN="JUSTIFY">successors/predecessors under certain conditions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.3 Common Subexpression Elimination</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If an expression has been computed on all paths leading to a second evaluation and vbcc</P>
<P ALIGN="JUSTIFY">knows that the operands have not been changed, then the result of the original evaluation</P>
<P ALIGN="JUSTIFY">will be reused instead of recomputing it. Also, memory operands will be loaded into registers</P>
<P ALIGN="JUSTIFY">and reused instead of being reloaded, if possible.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">q(x * y, x * y);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int tmp;</P>
<P ALIGN="JUSTIFY">tmp = x * y;</P>
<P ALIGN="JUSTIFY">q(tmp, tmp);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Depending on the optimization level, vbcc will perform this optimization only locally within</P>
<P ALIGN="JUSTIFY">basic blocks or globally across an entire function.</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether operand of an expression may have changed,</P>
<P ALIGN="JUSTIFY">it will be a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Opti-</P>
<P ALIGN="JUSTIFY">mizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.4 Copy Propagation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If a variable is assigned to another one, the original variable will be used as long as it is not</P>
<P ALIGN="JUSTIFY">modified. This is especially useful in conjunction with other optimizations, e.g. common</P>
<P ALIGN="JUSTIFY">subexpression elimination.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY"> 20</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">int y;</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int x;</P>
<P ALIGN="JUSTIFY">x = y;</P>
<P ALIGN="JUSTIFY">return x;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int y;</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return y;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Depending on the optimization level, vbcc will perform this optimization only locally within</P>
<P ALIGN="JUSTIFY">basic blocks or globally across an entire function.</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether a variable may have changed, it will be</P>
<P ALIGN="JUSTIFY">a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15</P>
<P ALIGN="JUSTIFY">[Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations],</P>
<P ALIGN="JUSTIFY">page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.5 Constant Propagation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If a variable is known to have a constant value (this includes addresses of objects) at some</P>
<P ALIGN="JUSTIFY">use, it will be replaced by the constant.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int x;</P>
<P ALIGN="JUSTIFY">x = 1;</P>
<P ALIGN="JUSTIFY">return x;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return 1;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Depending on the optimization level, vbcc will perform this optimization only locally within</P>
<P ALIGN="JUSTIFY">basic blocks or globally across an entire function.</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether a variable may have changed, it will be</P>
<P ALIGN="JUSTIFY">a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15</P>
<P ALIGN="JUSTIFY">[Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations],</P>
<P ALIGN="JUSTIFY">page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">21</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.6 Dead Code Elimination</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If a variable is assigned a value which is never used (either because it is overwritten or its</P>
<P ALIGN="JUSTIFY">lifetime ends), the assignment will be removed. This optimization is crucial to remove code</P>
<P ALIGN="JUSTIFY">which has become dead due to other optimizations.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">int x;</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int y;</P>
<P ALIGN="JUSTIFY">x = 1;</P>
<P ALIGN="JUSTIFY">y = 2;</P>
<P ALIGN="JUSTIFY">x = 3;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int x;</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">x = 3;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether a variable may be read, it will be a ected</P>
<P ALIGN="JUSTIFY">by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-</P>
<P ALIGN="JUSTIFY">Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.7 Loop-Invariant Code Motion</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the operands of a computation within a loop will not change during iterations, the com-</P>
<P ALIGN="JUSTIFY">putation will be moved outside of the loop.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 100; i++)</P>
<P ALIGN="JUSTIFY">q(x * y);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i, tmp = x * y;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 100; i++)</P>
<P ALIGN="JUSTIFY">q(tmp);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"> 22</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether operands of an expression may</P>
<P ALIGN="JUSTIFY">have changed, it will be a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias</P>
<P ALIGN="JUSTIFY">Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16</P>
<P ALIGN="JUSTIFY">[Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.8 Strength Reduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This is an optimization applied to loops in order to replace more costly operations (usually</P>
<P ALIGN="JUSTIFY">multiplications) by cheaper ones (typically additions). Linear functions of an induction</P>
<P ALIGN="JUSTIFY">variable (a variable which is changed by a loop-invariant value in every iteration) will be</P>
<P ALIGN="JUSTIFY">replaced by new induction variables. If possible, the original induction variable will be</P>
<P ALIGN="JUSTIFY">eliminated.</P>
<P ALIGN="JUSTIFY">As array accesses are actually composed of multiplications and additions, they often benefit</P>
<P ALIGN="JUSTIFY">significantly by this optimization.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int *p)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 100; i++)</P>
<P ALIGN="JUSTIFY">p[i] = i;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int *p)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 100; i++)</P>
<P ALIGN="JUSTIFY">*p++ = i;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether operands of an expression may</P>
<P ALIGN="JUSTIFY">have changed, it will be a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias</P>
<P ALIGN="JUSTIFY">Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16</P>
<P ALIGN="JUSTIFY">[Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.9 Induction Variable Elimination</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If an induction variable is only used to determine the number of iterations through the loop,</P>
<P ALIGN="JUSTIFY">it will be removed. Instead, a new variable will be created which counts down to zero. This is</P>
<P ALIGN="JUSTIFY">generally faster and often enables special decrement-and-branch or decrement-and-compare</P>
<P ALIGN="JUSTIFY">instructions.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; n; i++)</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">23</P>
<P ALIGN="JUSTIFY">puts("hello");</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int tmp;</P>
<P ALIGN="JUSTIFY">for(tmp = n; tmp &gt; 0; tmp--)</P>
<P ALIGN="JUSTIFY">puts("hello");</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether operands of an expression may</P>
<P ALIGN="JUSTIFY">have changed, it will be a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias</P>
<P ALIGN="JUSTIFY">Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16</P>
<P ALIGN="JUSTIFY">[Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.10 Loop Unrolling</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc reduces the loop overhead by replicating the loop body and reducing the number of</P>
<P ALIGN="JUSTIFY">iterations. Also, additional optimizations between di erent iterations of the loop will often</P>
<P ALIGN="JUSTIFY">be enabled by creating larger basic blocks. However, code-size as well as compilation-times</P>
<P ALIGN="JUSTIFY">can increase significantly.</P>
<P ALIGN="JUSTIFY">This optimization can be controlled by ‘-unroll-size’ and ‘-unroll-all’. ‘-unroll-size’</P>
<P ALIGN="JUSTIFY">specifies the maximum number of intermediate instructions for the unrolled loop body. vbcc</P>
<P ALIGN="JUSTIFY">will try to unroll the loop as many times to suit this value.</P>
<P ALIGN="JUSTIFY">If the number of iterations is constant and the size of the loop body multiplied by this</P>
<P ALIGN="JUSTIFY">number is less or equal to the value specified by ‘-unroll-size’, the loop will be unrolled</P>
<P ALIGN="JUSTIFY">completely. If the loop is known to be executed exactly once, it will always be unrolled</P>
<P ALIGN="JUSTIFY">completely.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 4; i++)</P>
<P ALIGN="JUSTIFY">q(i);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">q(0);</P>
<P ALIGN="JUSTIFY">q(1);</P>
<P ALIGN="JUSTIFY">q(2);</P>
<P ALIGN="JUSTIFY">q(3);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"> 24</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">If the number of iteration is constant the loop will be unrolled as many times as permitted</P>
<P ALIGN="JUSTIFY">by the size of the loop and ‘-unroll-size’. If the number of iterations is not a multiple of</P>
<P ALIGN="JUSTIFY">the number of replications, the remaining iterations will be unrolled separately.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; 102; i++)</P>
<P ALIGN="JUSTIFY">q(i);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">q(0);</P>
<P ALIGN="JUSTIFY">q(1);</P>
<P ALIGN="JUSTIFY">for(i = 2; i &lt; 102;){</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">By default, only loops with a constant number of iterations will be unrolled. However, if</P>
<P ALIGN="JUSTIFY">‘-unroll-all’ is specified, vbcc will also unroll loops if the number of iterations can be</P>
<P ALIGN="JUSTIFY">calculated at entry to the loop.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">void f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i;</P>
<P ALIGN="JUSTIFY">for (i = 0; i &lt; n; i++)</P>
<P ALIGN="JUSTIFY">q(i);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">void f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int i, tmp;</P>
<P ALIGN="JUSTIFY">i = 0;</P>
<P ALIGN="JUSTIFY">tmp = n &amp; 3;</P>
<P ALIGN="JUSTIFY">switch(tmp){</P>
<P ALIGN="JUSTIFY">case 3:</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">25</P>
<P ALIGN="JUSTIFY">case 2:</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">case 1:</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">while(i &lt; n){</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">q(i++);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">As this optimization requires detecting whether operands of an expression may</P>
<P ALIGN="JUSTIFY">have changed, it will be a ected by other optimizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.14 [Alias</P>
<P ALIGN="JUSTIFY">Analysis], page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">,</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16</P>
<P ALIGN="JUSTIFY">[Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.11 Function Inlining</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To reduce the overhead, a function call can be expanded inline. Passing parameters can</P>
<P ALIGN="JUSTIFY">be optimized as the arguments can be directly accessed by the inlined function. Also,</P>
<P ALIGN="JUSTIFY">further optimizations are enabled, e.g. constant arguments can be evaluated or common</P>
<P ALIGN="JUSTIFY">subexpressions between the caller and the callee can be eliminated. An inlined function call</P>
<P ALIGN="JUSTIFY">is as fast as a macro. However (just as with using large macros), code size and compilation</P>
<P ALIGN="JUSTIFY">time can increase significantly.</P>
<P ALIGN="JUSTIFY">Therefore, this optimization can be controlled with ‘-inline-size’ and ‘-inline-depth’.</P>
<P ALIGN="JUSTIFY">vbcc will only inline functions which contain less intermediate instructions than specified</P>
<P ALIGN="JUSTIFY">with this option.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">int f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return q(&amp;n,1);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">void q(int *x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(y &gt; 0)</P>
<P ALIGN="JUSTIFY">*x = *x + y;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">abort();</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return n + 1;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY"> 26</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">void q(int *x, int y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(y &gt; 0)</P>
<P ALIGN="JUSTIFY">*x = *x + y;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">abort();</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">If a function to be inlined calls another function, that function can also be inlined. This</P>
<P ALIGN="JUSTIFY">also includes a recursive call of the function.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">int f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(n &lt; 2)</P>
<P ALIGN="JUSTIFY">return 1;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">return f(n - 1) + f(n - 2);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int f(int n)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(n &lt; 2)</P>
<P ALIGN="JUSTIFY">return 1;</P>
<P ALIGN="JUSTIFY">else{</P>
<P ALIGN="JUSTIFY">int tmp1 = n - 1, tmp2, tmp3 = n - 2, tmp4;</P>
<P ALIGN="JUSTIFY">if(tmp1 &lt; 2)</P>
<P ALIGN="JUSTIFY">tmp2 = 1;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">tmp2 = f(tmp1 - 1) + f(tmp2 - 2);</P>
<P ALIGN="JUSTIFY">if(tmp3 &lt; 2)</P>
<P ALIGN="JUSTIFY">tmp4 = 1;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">tmp4 = f(tmp3 - 1) + f(tmp3 - 2);</P>
<P ALIGN="JUSTIFY">return tmp2 + tmp4;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">By default, only one level of inlining is done. The maximum nesting of inlining can be set</P>
<P ALIGN="JUSTIFY">with ‘-inline-depth’. However, this option should be used with care. The code-size can</P>
<P ALIGN="JUSTIFY">increase very fast and in many cases the code will be slower. Only use it for fine-tuning</P>
<P ALIGN="JUSTIFY">after measuring if it is really beneficial.</P>
<P ALIGN="JUSTIFY">At lower optimization levels a function must be defined in the same translation-unit as the</P>
<P ALIGN="JUSTIFY">caller to be inlined. With cross-module optimizations, vbcc will also inline functions which</P>
<P ALIGN="JUSTIFY">are defined in other files. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">See also</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.3 [Inline-Assembly Functions], page 33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">27</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.12 Intrinsic Functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This optimization will replace calls to some known functions (usually library functions)</P>
<P ALIGN="JUSTIFY">with calls to di erent functions or special inline-code. This optimization usually depends</P>
<P ALIGN="JUSTIFY">on the arguments to a function. Typical candidates are the printf family of functions and</P>
<P ALIGN="JUSTIFY">string-functions applied to string-literals.</P>
<P ALIGN="JUSTIFY">For example, the following code</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return strlen("vbcc");</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">will be optimized like:</P>
<P ALIGN="JUSTIFY">int f()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">return 4;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Note that there are also other possibilities of providing specially optimized library functions.</P>
<P ALIGN="JUSTIFY">See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.3 [Inline-Assembly Functions], page 33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.11 [Function Inlining],</P>
<P ALIGN="JUSTIFY">page 25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.13 Unused Object Elimination</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Depending on the optimization level, vbcc will try to eliminate di erent objects and reduce</P>
<P ALIGN="JUSTIFY">the size needed for objects.</P>
<P ALIGN="JUSTIFY">Generally, vbcc will try to use common storage for local non-static variables with non-</P>
<P ALIGN="JUSTIFY">overlapping live-ranges .</P>
<P ALIGN="JUSTIFY">At some optimization levels and with ‘-size’ specified, vbcc will try to order the place-</P>
<P ALIGN="JUSTIFY">ment of variables with static storage-duration to minimize padding needed due to di erent</P>
<P ALIGN="JUSTIFY">alignment requirements. This optimization generally benefits from an increased scope of</P>
<P ALIGN="JUSTIFY">optimization. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">At higher optimization levels objects and functions which are not referenced are eliminated.</P>
<P ALIGN="JUSTIFY">This includes functions which have always been inlined or variables which have always been</P>
<P ALIGN="JUSTIFY">replaced by constants.</P>
<P ALIGN="JUSTIFY">When using separate compilation, objects and functions with external linkage usually can-</P>
<P ALIGN="JUSTIFY">not be eliminated, because they might be referenced from other translation-units. This</P>
<P ALIGN="JUSTIFY">precludes also elimination of anything referenced by such an object or function.</P>
<P ALIGN="JUSTIFY">However, unused objects and functions with external linkage can be eliminated if ‘-final’</P>
<P ALIGN="JUSTIFY">is specified. In this case vbcc will assume that basically the entire program is presented</P>
<P ALIGN="JUSTIFY">and eliminate everything which is not referenced directly or indirectly from main(). If some</P>
<P ALIGN="JUSTIFY">objects are not referenced but must not be eliminated, they have to be declared with the</P>
<P ALIGN="JUSTIFY">__entry attribute. Typical examples are callback functions which are called from a library</P>
<P ALIGN="JUSTIFY">function or from anywhere outside the program, interrupt-handlers or other data which</P>
<P ALIGN="JUSTIFY">should be preserved. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.14 Alias Analysis</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Many optimizations can only be done if it is known that two expressions are not aliased,</P>
<P ALIGN="JUSTIFY">i.e. they do not refer to the same object. If such information is not available, worst-case</P>
<P ALIGN="JUSTIFY"> 28</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">assumptions have to be made in order to create correct code. In the C language aliasing can</P>
<P ALIGN="JUSTIFY">occur by use of pointers. As pointers are generally a very frequently used feature of C and</P>
<P ALIGN="JUSTIFY">also array accesses are just disguised pointer arithmetic, alias analysis is very important.</P>
<P ALIGN="JUSTIFY">vbcc uses the following methods to obtain aliasing information:</P>
<P ALIGN="JUSTIFY">- The C language does not allow accessing an object using an lvalue of a di erent type.</P>
<P ALIGN="JUSTIFY">Exceptions are accessing an object using a qualified version of the same type and</P>
<P ALIGN="JUSTIFY">accessing an object using a character type. In the following example p1 and p2 must</P>
<P ALIGN="JUSTIFY">not point to the same object:</P>
<P ALIGN="JUSTIFY">f(int *p1, long *p2)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">...</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">vbcc will assume that the source is correct and does not break this requirement of</P>
<P ALIGN="JUSTIFY">the C language. If a program does break this requirement and cannot be fixed, then</P>
<P ALIGN="JUSTIFY">-no-alias-opt must be specified and some performance will be lost.</P>
<P ALIGN="JUSTIFY">- At higher optimization levels, vbcc will try to keep track of all objects a pointer can</P>
<P ALIGN="JUSTIFY">point to. In the following example, vbcc will see that p1 can only point to x or y</P>
<P ALIGN="JUSTIFY">whereas p2 can only point to z. Therefore it knows that p1 and p2 are not aliased.</P>
<P ALIGN="JUSTIFY">int x[10], y[10], z[10];</P>
<P ALIGN="JUSTIFY">int f(int a, int b, int c)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int *p1, *p2;</P>
<P ALIGN="JUSTIFY">if(a &lt; b)</P>
<P ALIGN="JUSTIFY">p1 = &amp;x[a];</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">p1 = &amp;y[b];</P>
<P ALIGN="JUSTIFY">p2 = &amp;z[c];</P>
<P ALIGN="JUSTIFY">...</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">As pointers itself may be aliased and function calls might modify pointers, this</P>
<P ALIGN="JUSTIFY">analysis sometimes benefits from a larger scope of optimization. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15</P>
<P ALIGN="JUSTIFY">[Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations],</P>
<P ALIGN="JUSTIFY">page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">This optimization will alter the behaviour of broken code which uses pointer arithmetic</P>
<P ALIGN="JUSTIFY">to step from one object into another.</P>
<P ALIGN="JUSTIFY">- The 1999 C standard provides the restrict-qualifier to help alias analysis. If a pointer</P>
<P ALIGN="JUSTIFY">is declared with this qualifier, the compiler may assume that the object pointed to by</P>
<P ALIGN="JUSTIFY">this pointer is only aliased by pointers which are derived from this pointer. For a formal</P>
<P ALIGN="JUSTIFY">definition of the rules for restrict please consult ISO/IEC9899:1999.</P>
<P ALIGN="JUSTIFY">vbcc will make use of this information at higher optimization levels (‘-c99’ must be</P>
<P ALIGN="JUSTIFY">used to use this new keyword).</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">29</P>
<P ALIGN="JUSTIFY">A very useful application for restrict are function parameters. Consider the following</P>
<P ALIGN="JUSTIFY">example:</P>
<P ALIGN="JUSTIFY">void cross_prod(float *restrict res,</P>
<P ALIGN="JUSTIFY">float *restrict x,</P>
<P ALIGN="JUSTIFY">float *restrict y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">res[0] = x[1] * y[2] - x[2] * y[1];</P>
<P ALIGN="JUSTIFY">res[1] = x[2] * y[0] - x[0] * y[2];</P>
<P ALIGN="JUSTIFY">res[2] = x[0] * y[1] - x[1] * y[0];</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Without restrict, a compiler has to assume that writing the results through res can</P>
<P ALIGN="JUSTIFY">modify the object pointed to by x and y. Therefore, the compiler has to reload all the</P>
<P ALIGN="JUSTIFY">values on the right side twice. With restrict vbcc will optimize this code like:</P>
<P ALIGN="JUSTIFY">void cross_prod(float *restrict res,</P>
<P ALIGN="JUSTIFY">float *restrict x,</P>
<P ALIGN="JUSTIFY">float *restrict y)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">float x0 = x[0], x1 = x[1], x2 = x[2];</P>
<P ALIGN="JUSTIFY">float y0 = y[0], y1 = x[1], y2 = y[2];</P>
<P ALIGN="JUSTIFY">res[0] = x1 * y2 - x2 * y1;</P>
<P ALIGN="JUSTIFY">res[1] = x2 * y0 - x0 * y2;</P>
<P ALIGN="JUSTIFY">res[2] = x0 * y1 - x1 * y0;</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.15 Inter-Procedural Analysis</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Apart from the number of di erent optimizations a compiler o ers, another important point</P>
<P ALIGN="JUSTIFY">is the scope of the underlying analysis. If a compiler only looks at small parts of code when</P>
<P ALIGN="JUSTIFY">deciding whether to do an optimization, it often cannot prove that a transformation does</P>
<P ALIGN="JUSTIFY">not change the behaviour and therefore has to reject it.</P>
<P ALIGN="JUSTIFY">Simple compilers only look at single expressions, simple optimizing compilers often restrict</P>
<P ALIGN="JUSTIFY">their analysis to basic blocks or extended basic blocks. Analyzing a whole function is</P>
<P ALIGN="JUSTIFY">common in today’s optimizing compilers.</P>
<P ALIGN="JUSTIFY">This already allows many optimizations but often worst-case assumptions have to be made</P>
<P ALIGN="JUSTIFY">when a function is called. To avoid this, vbcc will not restrict its analysis to single functions</P>
<P ALIGN="JUSTIFY">at higher optimization levels. Inter-procedural data- ow analysis often allows for example</P>
<P ALIGN="JUSTIFY">to eliminate more common subexpressions or dead code. Register allocation and many other</P>
<P ALIGN="JUSTIFY">optimizations also sometimes benefit from inter-procedural analysis.</P>
<P ALIGN="JUSTIFY">Further extension of the scope of optimizations is possible by activating cross-module opti-</P>
<P ALIGN="JUSTIFY">mizations. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.16 Cross-Module Optimizations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Separate compilation has always been an important feature of the C language. Splitting up</P>
<P ALIGN="JUSTIFY">an application into several modules does not only reduce turn-around times and resource-</P>
<P ALIGN="JUSTIFY">requirements for compilation, but it also helps writing reusable well-structured code.</P>
<P ALIGN="JUSTIFY"> 30</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">However, an optimizer has much more possibilities when it has access to the entire source</P>
<P ALIGN="JUSTIFY">code. In order to provide maximum possible optimizations without sacrificing structure and</P>
<P ALIGN="JUSTIFY">modularity of code, vbcc can do optimizations across di erent translation-units. Another</P>
<P ALIGN="JUSTIFY">benefit is that cross-module analysis also will detect objects which are declared inconsis-</P>
<P ALIGN="JUSTIFY">tently in di erent translation-units.</P>
<P ALIGN="JUSTIFY">Unfortunately common object-code does not contain enough information to perform ag-</P>
<P ALIGN="JUSTIFY">gressive optimization, To overcome this problem, vbcc o ers two solutions:</P>
<P ALIGN="JUSTIFY">- If cross-module optimizations are enabled and several files are passed to vbcc, it will</P>
<P ALIGN="JUSTIFY">read in all files at once, perform optimizations across these files and generate a single</P>
<P ALIGN="JUSTIFY">object file as output. This file is similar to what would have been obtained by separately</P>
<P ALIGN="JUSTIFY">compiling the files and linking the resulting objects together.</P>
<P ALIGN="JUSTIFY">- The method described above often requires changes in makefiles and somewhat di er-</P>
<P ALIGN="JUSTIFY">ent handling. Therefore vbcc also provides means to generate some kind of special</P>
<P ALIGN="JUSTIFY">pseudo object files which pretain enough high-level information to perform aggressive</P>
<P ALIGN="JUSTIFY">optimizations at link time.</P>
<P ALIGN="JUSTIFY">If ‘-wpo’ is specified (which will automatically be done by vc at higher optimization</P>
<P ALIGN="JUSTIFY">levels) vbcc will generate such files rather than normal assembly or object files. These</P>
<P ALIGN="JUSTIFY">files can not be handled by normal linkers. However, vc will detect these files and</P>
<P ALIGN="JUSTIFY">before linking it will pass all such files to vbcc again. vbcc will optimize the entire</P>
<P ALIGN="JUSTIFY">code and generate real code which is then passed to the linker.</P>
<P ALIGN="JUSTIFY">It is possible to pass vc a mixture of real and pseudo object files. vc will detect the</P>
<P ALIGN="JUSTIFY">pseudo objects, compile them and link them together with the real objects. Obviously,</P>
<P ALIGN="JUSTIFY">vc has to be used for linking. Directly calling the linker with pseudo objects will not</P>
<P ALIGN="JUSTIFY">work.</P>
<P ALIGN="JUSTIFY">Please note that optimization and code generation is deferred to link-time. Therefore,</P>
<P ALIGN="JUSTIFY">all compiler options related to optimization and code generation have to be specified</P>
<P ALIGN="JUSTIFY">at the linker command as well. Otherwise they would be ignored. Other options (e.g.</P>
<P ALIGN="JUSTIFY">setting paths or defining macros) have to be specified when compiling.</P>
<P ALIGN="JUSTIFY">Also, turn-around times will obviously increase as usually everything will be rebuild</P>
<P ALIGN="JUSTIFY">even if makefiles are used. While only the corresponding pseudo object may be rebuilt</P>
<P ALIGN="JUSTIFY">if one file is changed, all the real work will be done at the linking stage.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.17 Instruction Scheduling</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Some backends provide an instruction scheduler which is automatically run by vc at higher</P>
<P ALIGN="JUSTIFY">optimization levels. The purpose is to reorder instructions to make better use of the di erent</P>
<P ALIGN="JUSTIFY">pipelines a CPU may o er.</P>
<P ALIGN="JUSTIFY">The exact details depend heavily on the backend, but in general the scheduler will try to</P>
<P ALIGN="JUSTIFY">place instructions which can be executed in parallel (e.g. on super-scalar architectures)</P>
<P ALIGN="JUSTIFY">close to each other. Also, instructions which depend on the result of another instruction</P>
<P ALIGN="JUSTIFY">will be moved further apart to avoid pipeline-stalls.</P>
<P ALIGN="JUSTIFY">Please note that it may be crucial to specify the correct derivate of a CPU family in order to</P>
<P ALIGN="JUSTIFY">get best results from the sceduler. Di erent variants of an architecture may have a di erent</P>
<P ALIGN="JUSTIFY">number and behaviour of pipelines requiring di erent scheduling decisions.</P>
<P ALIGN="JUSTIFY">Consult the backend documentation for details.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">31</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.18 Target-Specific Optimizations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">In addition to those optimzations which are available for all targets, every backend will</P>
<P ALIGN="JUSTIFY">provide a series of additional optimizations. These vary between the di erent backends,</P>
<P ALIGN="JUSTIFY">but optimizations frequently done by backends are:</P>
<P ALIGN="JUSTIFY">- use of complex or auto-increment addressing-modes</P>
<P ALIGN="JUSTIFY">- implicit setting of condition-codes</P>
<P ALIGN="JUSTIFY">- instruction-combining</P>
<P ALIGN="JUSTIFY">- delayed popping of stack-slots</P>
<P ALIGN="JUSTIFY">- optimized function entry- and exit-code</P>
<P ALIGN="JUSTIFY">- elimination of a frame pointer</P>
<P ALIGN="JUSTIFY">- optimized multiplication/division by constants</P>
<P ALIGN="JUSTIFY">- inline code for block-copying</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.4.19 Debugging Optimized Code</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Debugging of optimized code is usually not possible without problems. Many compilers</P>
<P ALIGN="JUSTIFY">turn o  almost all optimizations when debugging. vbcc allows debugging output together</P>
<P ALIGN="JUSTIFY">with optimizations and tries to still do all optimizations (some restrictions have to be made</P>
<P ALIGN="JUSTIFY">regarding instruction-scheduling).</P>
<P ALIGN="JUSTIFY">However, depending on the debugger and debugging-format used, the information displayed</P>
<P ALIGN="JUSTIFY">in the debugger may di er from the real situation. Typical problems are:</P>
<P ALIGN="JUSTIFY">- Incorrectly displayed values of variables.</P>
<P ALIGN="JUSTIFY">When optimizing vbcc will often remove certain variables or eliminate code which sets</P>
<P ALIGN="JUSTIFY">them. Sometimes it is possible, to tell the debugger that a variable has been optimized</P>
<P ALIGN="JUSTIFY">away, but most of the time the debugger does not allow this and you will just get bogus</P>
<P ALIGN="JUSTIFY">values when trying to inspect a variable.</P>
<P ALIGN="JUSTIFY">Also, variables whose locations di ers at various locations of the program (e.g. a</P>
<P ALIGN="JUSTIFY">variable is in a register at one place and in memory at another) can only be correctly</P>
<P ALIGN="JUSTIFY">displayed, if the debugger supports this.</P>
<P ALIGN="JUSTIFY">Sometimes, this can even occur in non-optimized code (e.g. with register-parameters</P>
<P ALIGN="JUSTIFY">or a changing stack-pointer).</P>
<P ALIGN="JUSTIFY">- Strange program  ow.</P>
<P ALIGN="JUSTIFY">When stepping through a program, you may see lines of code be executed out-of-order</P>
<P ALIGN="JUSTIFY">or parts of the code skipped. This often occurs due to code being moved around or</P>
<P ALIGN="JUSTIFY">eliminated/combined.</P>
<P ALIGN="JUSTIFY">- Missed break-points.</P>
<P ALIGN="JUSTIFY">Setting break-points (especially on source-lines) needs some care when optimized code</P>
<P ALIGN="JUSTIFY">is debugged. E.g. code may have been moved or even replicated at di erent parts.</P>
<P ALIGN="JUSTIFY">A break-point set in a debugger will usually only be set on one instance of the code.</P>
<P ALIGN="JUSTIFY">Therefore, a di erent instance of the code may have been executed although the break-</P>
<P ALIGN="JUSTIFY">point was not hit.</P>
<P ALIGN="JUSTIFY"> 32</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5 Extensions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section lists and describes all extensions to the C language provided by vbcc. Most</P>
<P ALIGN="JUSTIFY">of them are implemented in a way which does not break correct C code and still allows all</P>
<P ALIGN="JUSTIFY">diagnostics required by the C standard by using reserved identifiers.</P>
<P ALIGN="JUSTIFY">The only exception (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.3 [Inline-Assembly Functions], page 33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) can be turned</P>
<P ALIGN="JUSTIFY">o  using ‘-iso’ or ‘-ansi’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.1 Pragmas</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc accepts the following #pragma-directives:</P>
<P ALIGN="JUSTIFY">#pragma printflike &lt;function&gt;</P>
<P ALIGN="JUSTIFY">#pragma scanflike &lt;function&gt;</P>
<P ALIGN="JUSTIFY">vbcc will handle &lt;function&gt; specially. &lt;function&gt; has to be an already de-</P>
<P ALIGN="JUSTIFY">clared function, with external linkage, that takes a variable number of argu-</P>
<P ALIGN="JUSTIFY">ments and a const char * as the last fixed parameter.</P>
<P ALIGN="JUSTIFY">If such a function is called with a string-constant as format-string, vbcc will</P>
<P ALIGN="JUSTIFY">check if the arguments seem to match the format-specifiers in the format-string,</P>
<P ALIGN="JUSTIFY">according to the rules of printf or scanf. Also, vbcc will replace the call by a</P>
<P ALIGN="JUSTIFY">call to a simplified version according to the following rules, if such a function</P>
<P ALIGN="JUSTIFY">has been declared with external linkage:</P>
<P ALIGN="JUSTIFY">- If no format-specifiers are used at all, __v0&lt;function&gt; will be called.</P>
<P ALIGN="JUSTIFY">- If no qualifiers are used and only d,i,x,X,o,s,c are used,</P>
<P ALIGN="JUSTIFY">__v1&lt;function&gt; will be called.</P>
<P ALIGN="JUSTIFY">- If no  oating-point arguments are used, __v2&lt;function&gt; will be called.</P>
<P ALIGN="JUSTIFY">#pragma dontwarn &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Disables warning number n. Must be followed by #pragma popwarn.</P>
<P ALIGN="JUSTIFY">#pragma warn &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Enables warning number n. Must be followed by #pragma popwarn.</P>
<P ALIGN="JUSTIFY">pragma popwarn</P>
<P ALIGN="JUSTIFY">Undoes the last modification done by #pragma warn or #pragma dontwarn.</P>
<P ALIGN="JUSTIFY">#pragma only-inline on</P>
<P ALIGN="JUSTIFY">The following functions will be parsed and are available for inlining (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 3.4.11 [Function Inlining], page 25</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">), but no out-of-line code will be gener-</P>
<P ALIGN="JUSTIFY">ated, even if some calls could not be inlined.</P>
<P ALIGN="JUSTIFY">Do not use this with functions that have local static variables!</P>
<P ALIGN="JUSTIFY">#pragma only-inline off</P>
<P ALIGN="JUSTIFY">The following functions are translated as usual again.</P>
<P ALIGN="JUSTIFY">#pragma opt &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Sets the optimization options to &lt;n&gt; (similar to -O=&lt;n&gt;) for the following</P>
<P ALIGN="JUSTIFY">functions. This is only used for debugging purposes. Do not use!</P>
<P ALIGN="JUSTIFY">#pragma begin_header</P>
<P ALIGN="JUSTIFY">Used to mark the beginning of a system-header. Must be followed by #pragma</P>
<P ALIGN="JUSTIFY">end_header. Not for use in applications!</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">33</P>
<P ALIGN="JUSTIFY">#pragma end_header</P>
<P ALIGN="JUSTIFY">The counterpart to #pragma begin_header. Marks the end of a system-header.</P>
<P ALIGN="JUSTIFY">Not for use in applications!</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.2 Register Parameters</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the parameters for certain functions should be passed in certain registers, it is possible</P>
<P ALIGN="JUSTIFY">to specify the registers using __reg("&lt;reg&gt;") in the prototype, e.g.</P>
<P ALIGN="JUSTIFY">void f(__reg("d0") int x, __reg("a0") char *y) { ... }</P>
<P ALIGN="JUSTIFY">The names of the available registers depend on the backend and will be listed in the cor-</P>
<P ALIGN="JUSTIFY">responding part of the documentation. Note that a matching prototype must be in scope</P>
<P ALIGN="JUSTIFY">when calling such a function - otherwise wrong code will be generated. Therefore it is not</P>
<P ALIGN="JUSTIFY">useful to use register parameters in an old-style function-definition.</P>
<P ALIGN="JUSTIFY">If the backend cannot handle the specified register for a certain type, this will cause an error.</P>
<P ALIGN="JUSTIFY">Note that this may happen although the register could store that type, if the backend does</P>
<P ALIGN="JUSTIFY">not provide the necessary support.</P>
<P ALIGN="JUSTIFY">Also note that this may force vbcc to create worse code.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.3 Inline-Assembly Functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Only use them if you know what you are doing!</P>
<P ALIGN="JUSTIFY">A function-declaration may be followed by ’=’ and a string-constant. If a function is called</P>
<P ALIGN="JUSTIFY">with such a declaration in scope, no function-call will be generated but the string-constant</P>
<P ALIGN="JUSTIFY">will be inserted in the assembly-output. Otherwise the compiler and optimizer will treat</P>
<P ALIGN="JUSTIFY">this like a function-call, i.e. the inline-assembly must not modify any callee-save registers</P>
<P ALIGN="JUSTIFY">without restoring them. However, it is also possible to specify the side-e ects of inline-</P>
<P ALIGN="JUSTIFY">assembly functions like registers used or variables used and modified (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.9</P>
<P ALIGN="JUSTIFY">[Specifying side-e ects], page 35</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Example:</P>
<P ALIGN="JUSTIFY">double sin(__reg("fp0") double) = "\tfsin.x\tfp0\n";</P>
<P ALIGN="JUSTIFY">There are several issues to take care of when writing inline-assembly.</P>
<P ALIGN="JUSTIFY">- As inline-assembly is subject to loop unrolling or function inlining it may be replicated</P>
<P ALIGN="JUSTIFY">at di erent locations. Unless it is absolutely known that this will not happen, the code</P>
<P ALIGN="JUSTIFY">should not define any labels (e.g. for branches). Use o sets instead.</P>
<P ALIGN="JUSTIFY">- If a backend provides an instruction scheduler, inline-assembly code will also be sched-</P>
<P ALIGN="JUSTIFY">uled. Some schedulers make assumptions about their input (usually compiler-generated</P>
<P ALIGN="JUSTIFY">code) to improve the code. Have a look at the backend documentation to see if there</P>
<P ALIGN="JUSTIFY">are any issues to consider.</P>
<P ALIGN="JUSTIFY">- If a backend provides a peephole optimizer which optimizes the assembly output, inline-</P>
<P ALIGN="JUSTIFY">assembly code will also be optimized unless ‘-no-inline-peephole’ is specified. Have</P>
<P ALIGN="JUSTIFY">a look at the backend documentation to see if there are any issues to consider.</P>
<P ALIGN="JUSTIFY">- vbcc assumes that inline-assembly does not introduce any new control- ow edges. I.e.</P>
<P ALIGN="JUSTIFY">control will only enter inline-assembly if the function call is reached and if control leaves</P>
<P ALIGN="JUSTIFY">inline-assembly it will continue after the call.</P>
<P ALIGN="JUSTIFY">Inline-assembly-functions are not recognized when ANSI/ISO mode is turned on.</P>
<P ALIGN="JUSTIFY"> 34</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.4 Variable Attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc o ers attributes to variables or functions. These attributes can be specified at the</P>
<P ALIGN="JUSTIFY">declaration of a variable or function and are syntactically similar to storage-class-specifiers</P>
<P ALIGN="JUSTIFY">(e.g. static).</P>
<P ALIGN="JUSTIFY">Often, these attributes are specific to one backend and will be documented in the backend-</P>
<P ALIGN="JUSTIFY">documentation (typical attributes would e.g. be __interrupt or __section). Attributes</P>
<P ALIGN="JUSTIFY">may also have parameters. A generally available attribute s __entry which is used to</P>
<P ALIGN="JUSTIFY">preserve unreferenced objects and functions (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.13 [Unused Object Elimination],</P>
<P ALIGN="JUSTIFY">page 27</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">):</P>
<P ALIGN="JUSTIFY">__entry __interrupt __section("vectab") void my_handler()</P>
<P ALIGN="JUSTIFY">Additional non-target-specific attributes are available to specify side-e ects of functions (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.9 [Specifying side-e ects], page 35</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">Please note that some common extensions like __far are variable attributes on some ar-</P>
<P ALIGN="JUSTIFY">chitectures, but actually type attributes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.5 [Type Attributes], page 34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) on</P>
<P ALIGN="JUSTIFY">others. This is due to significantly di erent meanings on di erent architectures.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.5 Type Attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Types may be qualified by additional attributes, e.g. __far, on some backends. Regarding</P>
<P ALIGN="JUSTIFY">the availability of type attributes please consult the backend documentation.</P>
<P ALIGN="JUSTIFY">Syntactically type attributes have to be placed like a type-qualifier (e.g. const). As exam-</P>
<P ALIGN="JUSTIFY">ple, some backends know the attribute __far.</P>
<P ALIGN="JUSTIFY">Declaration of a pointer to a far-qualified character would be</P>
<P ALIGN="JUSTIFY">__far char *p;</P>
<P ALIGN="JUSTIFY">whereas</P>
<P ALIGN="JUSTIFY">char * __far p;</P>
<P ALIGN="JUSTIFY">is a far-qualified pointer to an unqualified char.</P>
<P ALIGN="JUSTIFY">Please note that some common extensions like __far are type attributes on some architec-</P>
<P ALIGN="JUSTIFY">tures, but actually variable attributes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.4 [Variable Attributes], page 34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) on</P>
<P ALIGN="JUSTIFY">others. This is due to significantly di erent meanings on di erent architectures.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.6 __typeof</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">__typeof is syntactically equivalent to sizeof, but its result is of type int and is a number</P>
<P ALIGN="JUSTIFY">representing the type of its argument. This may be necessary for implementing ‘stdarg.h’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.7 __alignof</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">__alignof is syntactically equivalent to sizeof, but its result is of type int and is the</P>
<P ALIGN="JUSTIFY">alignment in bytes of the type of the argument. This may be necessary for implementing</P>
<P ALIGN="JUSTIFY">‘stdarg.h’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.8 __offsetof</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">__offsetof is a builtin version of the offsetof-macro as defined in the C language. The</P>
<P ALIGN="JUSTIFY">first argument is a structure type and the second a member of the structure type. The</P>
<P ALIGN="JUSTIFY">result will be a constant expression representing the o set of the specified member in the</P>
<P ALIGN="JUSTIFY">structure.</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">35</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.9 Specifying side-e ects</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Only use if you know what you are doing!</P>
<P ALIGN="JUSTIFY">When optimizing and generating code, vbcc often has to take into account side-e ects of</P>
<P ALIGN="JUSTIFY">function-calls, e.g. which registers might be modified by this function and what variables</P>
<P ALIGN="JUSTIFY">are read or modified.</P>
<P ALIGN="JUSTIFY">A rather imprecise way to make assumptions on side-e ects is given by the ABI of a certain</P>
<P ALIGN="JUSTIFY">system (that defines which registers have to be preserved by functions) or rules derived from</P>
<P ALIGN="JUSTIFY">the language (e.g. local variables whose address has not been taken cannot be accessed by</P>
<P ALIGN="JUSTIFY">another function).</P>
<P ALIGN="JUSTIFY">On higher optimization levels (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.15 [Inter-Procedural Analysis], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">and</P>
<P ALIGN="JUSTIFY">see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.4.16 [Cross-Module Optimizations], page 29</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">)) vbcc will try to analyse functions</P>
<P ALIGN="JUSTIFY">and often gets much more precise informations regarding side-e ects.</P>
<P ALIGN="JUSTIFY">However, if the source code of functions is not visible to vbcc, e.g. because the functions are</P>
<P ALIGN="JUSTIFY">from libraries or they are written in assembly (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.3 [Inline-Assembly Functions],</P>
<P ALIGN="JUSTIFY">page 33</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">), it is obviously not possible to analyze the code. In this case, it is possible to specify</P>
<P ALIGN="JUSTIFY">these side-e ects using the following special variable-attributes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 3.5.4 [Variable</P>
<P ALIGN="JUSTIFY">Attributes], page 34</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">The __regsused(&lt;register-list&gt;) attribute specifies the registers used or modified</P>
<P ALIGN="JUSTIFY">by a function. The register list is a list of register names (as defined in the</P>
<P ALIGN="JUSTIFY">backend-documentation) separated by slashes and enclosed in double-quotes, e.g.</P>
<P ALIGN="JUSTIFY">__regsused("d0/d1") int abs();</P>
<P ALIGN="JUSTIFY">declares a function abs which only uses registers d0 and d1.</P>
<P ALIGN="JUSTIFY">__varsmodified(&lt;variable-list&gt;) specifies a list of variables with external linkage which</P>
<P ALIGN="JUSTIFY">are modified by the function. __varsused is similar, but specifies the external variables</P>
<P ALIGN="JUSTIFY">read by the function. If a variable is read and written, both attributes have to be specified.</P>
<P ALIGN="JUSTIFY">The variable-list ist a list of identifiers, separated by slashes and enclosed in double quotes.</P>
<P ALIGN="JUSTIFY">The attribute __writesmem(&lt;type&gt;) is used to specify that the function accesses memory</P>
<P ALIGN="JUSTIFY">using a certain type. This is necessary if the function modifies memory accessible to the</P>
<P ALIGN="JUSTIFY">calling function which cannot be specified using __varsmodified (e.g. because it is accessed</P>
<P ALIGN="JUSTIFY">via pointers). __readsmem is similar, but specifies memory which is read.</P>
<P ALIGN="JUSTIFY">If one of __varsused, varsmodified, __readsmem and __writesmem is specified, all relevant</P>
<P ALIGN="JUSTIFY">side-e ects must be specified. If, for example, only __varsused("my_global") is specified,</P>
<P ALIGN="JUSTIFY">this implies that the function only reads my_global and does not modify any variable</P>
<P ALIGN="JUSTIFY">accessible to the caller.</P>
<P ALIGN="JUSTIFY">All of these attributes may be specified multiple times.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.10 Automatic constructor/destructor functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The linker vlink provides a feature to collect pointers to all functions starting with the</P>
<P ALIGN="JUSTIFY">names _INIT or _EXIT in a prioritized array, labeled by __CTOR_LIST__ and __DTOR_LIST_</P>
<P ALIGN="JUSTIFY">_. The C-library (vclib) calls the constructor functions before entering main() and the</P>
<P ALIGN="JUSTIFY">destructor functions on program exit.</P>
<P ALIGN="JUSTIFY">The format of these special function names is:</P>
<P ALIGN="JUSTIFY">void _INIT[_&lt;pri&gt;][_&lt;name&gt;](void)</P>
<P ALIGN="JUSTIFY"> 36</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">void _EXIT[_&lt;pri&gt;][_&lt;name&gt;](void)</P>
<P ALIGN="JUSTIFY">The optional priority &lt;pri&gt; may be a digit between 1 and 9, where a constructor with a</P>
<P ALIGN="JUSTIFY">priority of 1 is executed first while a destructor with a priority of 1 is executed last. &lt;name&gt;</P>
<P ALIGN="JUSTIFY">is an optional name, used to di erentiate functions of the same level.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.5.10.1 Predefined macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following macros are defined by the compiler.</P>
<P ALIGN="JUSTIFY">#define __VBCC__</P>
<P ALIGN="JUSTIFY">#define __entry __vattr("entry")</P>
<P ALIGN="JUSTIFY">#define __str(x) #x</P>
<P ALIGN="JUSTIFY">#define __asm(x) dostatic void inline_assembly()=x;inline_assembly();while(0)</P>
<P ALIGN="JUSTIFY">#define __regsused(x) __vattr("regused("x")")</P>
<P ALIGN="JUSTIFY">#define __varsused(x) __vattr("varused("x")")</P>
<P ALIGN="JUSTIFY">#define __varsmodified(x) __vattr("varchanged("x")")</P>
<P ALIGN="JUSTIFY">#define __noreturn __vattr("noreturn()")</P>
<P ALIGN="JUSTIFY">#define __alwaysreturn __vattr("alwaysreturn()")</P>
<P ALIGN="JUSTIFY">#define __nosidefx __vattr("nosidefx()")</P>
<P ALIGN="JUSTIFY">#define __stack(x) __vattr(__str(stack1(x)))</P>
<P ALIGN="JUSTIFY">#define __stack2(x) __vattr(__str(stack2(x)))</P>
<P ALIGN="JUSTIFY">#define __STDC_VERSION__ 199901L</P>
<P ALIGN="JUSTIFY">__STDC_VERSION__ is defined in C99-mode only.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.6 Known Problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Some known target-independent problems of vbcc at the moment:</P>
<P ALIGN="JUSTIFY">- Some exotic scope-rules are not handled correctly.</P>
<P ALIGN="JUSTIFY">- Debugging-infos may have problems on higher optimization-levels.</P>
<P ALIGN="JUSTIFY">- String-constants are not merged.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">3.7 Credits</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">All those who wrote parts of the vbcc distribution, made suggestions, answered my ques-</P>
<P ALIGN="JUSTIFY">tions, tested vbcc, reported errors or were otherwise involved in the development of vbcc</P>
<P ALIGN="JUSTIFY">(in descending alphabetical order, under work, not complete):</P>
<P ALIGN="JUSTIFY">• Frank Wille</P>
<P ALIGN="JUSTIFY">• Gary Watson</P>
<P ALIGN="JUSTIFY">• Andrea Vallinotto</P>
<P ALIGN="JUSTIFY">• Johnny Tevessen</P>
<P ALIGN="JUSTIFY">• Gabriele Svelto</P>
<P ALIGN="JUSTIFY">• Dirk Stoecker</P>
<P ALIGN="JUSTIFY">• Ralph Schmidt</P>
<P ALIGN="JUSTIFY">• Markus Schmidinger</P>
<P ALIGN="JUSTIFY">• Thorsten Schaaps</P>
<P ALIGN="JUSTIFY">• Anton Rolls</P>
<P ALIGN="JUSTIFY"> Chapter 3: The Compiler</P>
<P ALIGN="JUSTIFY">37</P>
<P ALIGN="JUSTIFY">• Michaela Pruess</P>
<P ALIGN="JUSTIFY">• Thomas Pornin</P>
<P ALIGN="JUSTIFY">• Joerg Plate</P>
<P ALIGN="JUSTIFY">• Gilles Pirio</P>
<P ALIGN="JUSTIFY">• Bartlomiej Pater</P>
<P ALIGN="JUSTIFY">• Gunther Nikl</P>
<P ALIGN="JUSTIFY">• Robert Claus Mueller</P>
<P ALIGN="JUSTIFY">• Joern Maass</P>
<P ALIGN="JUSTIFY">• Aki M Laukkanen</P>
<P ALIGN="JUSTIFY">• Kai Kohlmorgen</P>
<P ALIGN="JUSTIFY">• Uwe Klinger</P>
<P ALIGN="JUSTIFY">• Andreas Kleinert</P>
<P ALIGN="JUSTIFY">• Julian Kinraid</P>
<P ALIGN="JUSTIFY">• Acereda Macia Jorge</P>
<P ALIGN="JUSTIFY">• Dirk Holtwick</P>
<P ALIGN="JUSTIFY">• Tim Hanson</P>
<P ALIGN="JUSTIFY">• Kasper Graversen</P>
<P ALIGN="JUSTIFY">• Jens Granseuer</P>
<P ALIGN="JUSTIFY">• Volker Graf</P>
<P ALIGN="JUSTIFY">• Marcus Geelnard</P>
<P ALIGN="JUSTIFY">• Matthias Fleischer</P>
<P ALIGN="JUSTIFY">• Alexander Fichtner</P>
<P ALIGN="JUSTIFY">• Olivier Fabre</P>
<P ALIGN="JUSTIFY">• Robert Ennals</P>
<P ALIGN="JUSTIFY">• Thomas Dorn</P>
<P ALIGN="JUSTIFY">• Walter Doerwald</P>
<P ALIGN="JUSTIFY">• Aaron Digulla</P>
<P ALIGN="JUSTIFY">• Lars Dannenberg</P>
<P ALIGN="JUSTIFY">• Sam Crow</P>
<P ALIGN="JUSTIFY">• Michael Bode</P>
<P ALIGN="JUSTIFY">• Michael Bauer</P>
<P ALIGN="JUSTIFY">• Juergen Barthelmann</P>
<P ALIGN="JUSTIFY">• Thomas Arnhold</P>
<P ALIGN="JUSTIFY">• Alkinoos Alexandros Argiropoulos</P>
<P ALIGN="JUSTIFY">• Thomas Aglassinger</P>
<P ALIGN="JUSTIFY"> 38</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY"> Chapter 4: M68k/Coldfire Backend</P>
<P ALIGN="JUSTIFY">39</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">4 M68k/Coldfire Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the backend for the M68k and Coldfire processor families.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.1 Additional options</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-cpu=n’ Generate code for cpu n (e.g. -cpu=68020), default: 68000.</P>
<P ALIGN="JUSTIFY">‘-fpu=n’ Generate code for fpu n (e.g. -fpu=68881), default: 0.</P>
<P ALIGN="JUSTIFY">‘-sd’ Use small data model (see below).</P>
<P ALIGN="JUSTIFY">‘-sc’ Use small code model (see below).</P>
<P ALIGN="JUSTIFY">‘-prof’ Insert code for profiling.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in the code section (and therefore is</P>
<P ALIGN="JUSTIFY">accessable with faster pc-relative addressing modes). Using this option it will</P>
<P ALIGN="JUSTIFY">be placed in the data section.</P>
<P ALIGN="JUSTIFY">This could e.g. be useful if you want to use small data and small code, but your</P>
<P ALIGN="JUSTIFY">code gets too big with all the constant data.</P>
<P ALIGN="JUSTIFY">Note that on operating systems with memory protection this option will disable</P>
<P ALIGN="JUSTIFY">write-protection of constant data.</P>
<P ALIGN="JUSTIFY">‘-use-framepointer’</P>
<P ALIGN="JUSTIFY">By default automatic variables are addressed through a7 instead of a5. This</P>
<P ALIGN="JUSTIFY">generates slightly better code, because the function entry and exit overhead is</P>
<P ALIGN="JUSTIFY">reduced and a5 can be used as register variable etc.</P>
<P ALIGN="JUSTIFY">However this may be a bit confusing when debugging and you can force vbcc</P>
<P ALIGN="JUSTIFY">to use a5 as a fixed framepointer.</P>
<P ALIGN="JUSTIFY">‘-no-peephole’</P>
<P ALIGN="JUSTIFY">Do not perform peephole-optimizations.</P>
<P ALIGN="JUSTIFY">‘-no-delayed-popping’</P>
<P ALIGN="JUSTIFY">By default arguments of function calls are not always popped from the stack</P>
<P ALIGN="JUSTIFY">immediately after the call, so that the arguments of several calls may be popped</P>
<P ALIGN="JUSTIFY">at once. With this option vbcc can be forced to pop them after every function</P>
<P ALIGN="JUSTIFY">call. This may simplify debugging and reduce the stack size needed by the</P>
<P ALIGN="JUSTIFY">compiled program.</P>
<P ALIGN="JUSTIFY">‘-gas’ Create output suitable for the GNU assembler.</P>
<P ALIGN="JUSTIFY">‘-no-fp-return’</P>
<P ALIGN="JUSTIFY">Do not return  oats and doubles in  oating-point registers even if code for an</P>
<P ALIGN="JUSTIFY">fpu is generated.</P>
<P ALIGN="JUSTIFY">‘-no-mreg-return’</P>
<P ALIGN="JUSTIFY">Do not use multiple registers to return types that do not fit into a single register.</P>
<P ALIGN="JUSTIFY">This is mainly for backwards compatibility with certain libraries.</P>
<P ALIGN="JUSTIFY"> 40</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">‘-hunkdebug’</P>
<P ALIGN="JUSTIFY">When creating debug-output (‘-g’ option) create Amiga debug hunks rather</P>
<P ALIGN="JUSTIFY">than DWARF2. Does not work with ‘-gas’.</P>
<P ALIGN="JUSTIFY">‘-no-intz’</P>
<P ALIGN="JUSTIFY">When generating code for FPU do quick&amp;dirty conversions from  oating-point</P>
<P ALIGN="JUSTIFY">to integer. The code may be somewhat faster but will not correctly round to</P>
<P ALIGN="JUSTIFY">zero. Only use it if you know what you are doing.</P>
<P ALIGN="JUSTIFY">‘-use-commons’</P>
<P ALIGN="JUSTIFY">Use real common symbols instead of bss symbols for non-initialized external</P>
<P ALIGN="JUSTIFY">variables.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The current version generates assembler output for use with the vasmm68k_mot. Most</P>
<P ALIGN="JUSTIFY">peephole optimizations are done by the assembler so vbcc only does some that the assembler</P>
<P ALIGN="JUSTIFY">cannot make. The generated executables will probably only work with OS2.0 or higher.</P>
<P ALIGN="JUSTIFY">With ‘-gas’ assembler output suitable for the GNU assembler is generated (the version</P>
<P ALIGN="JUSTIFY">must understand the Motorola syntax - some old ones do not). The output is only slightly</P>
<P ALIGN="JUSTIFY">modified from the vasm-output and will therefore result in worse code on gas.</P>
<P ALIGN="JUSTIFY">The register names provided by this backend are:</P>
<P ALIGN="JUSTIFY">a0, a1, a2, a3, a4, a5, a6, a7</P>
<P ALIGN="JUSTIFY">d0, d1, d2, d3, d4, d5, d6, d7</P>
<P ALIGN="JUSTIFY">fp0, fp1, fp2, fp3, fp4, fp5, fp6, fp7</P>
<P ALIGN="JUSTIFY">The registers a0 - a7 are supported to hold pointer types. d0 - d7 can be used for integers</P>
<P ALIGN="JUSTIFY">types excluding long long, pointers and float if no FPU code is generated. fp0 - fp7 can</P>
<P ALIGN="JUSTIFY">be used for all  oating point types if FPU code is generated.</P>
<P ALIGN="JUSTIFY">Additionally the following register pairs can be used for long long:</P>
<P ALIGN="JUSTIFY">d0/d1, d2/d3, d4/d5, d6/d7</P>
<P ALIGN="JUSTIFY">The registers d0, d1, a0, a1, fp0 and fp1 are used as scratch registers (i.e. they can be</P>
<P ALIGN="JUSTIFY">destroyed in function calls), all other registers are preserved.</P>
<P ALIGN="JUSTIFY">By default, all function arguments are passed on the stack.</P>
<P ALIGN="JUSTIFY">All scalar types up to 4 bytes are returned in register d0, long long is returned in d0/d1.</P>
<P ALIGN="JUSTIFY">If compiled for FPU,  oating point values are returned in fp0 unless ‘-no-fpreturn’ is</P>
<P ALIGN="JUSTIFY">specified. Types which are 8, 12 or 16 bytes large will be returned in several registers</P>
<P ALIGN="JUSTIFY">(d0/d1/a0/a1) unless ‘-no-mreg-return’ is specified. All other types are returned by</P>
<P ALIGN="JUSTIFY">passing the function the address of the result as a hidden argument - such a function must</P>
<P ALIGN="JUSTIFY">not be called without a proper declaration in scope.</P>
<P ALIGN="JUSTIFY">Objects which have been compiled with di erent settings must not be linked together.</P>
<P ALIGN="JUSTIFY">a7 is used as stack pointer. If ‘-sd’ is used, a4 will be used as small data pointer. If</P>
<P ALIGN="JUSTIFY">‘-use-framepointer’ is used, a5 will be used as frame pointer. All other registers will be</P>
<P ALIGN="JUSTIFY">used by the register allocator and can be used for register parameters.</P>
<P ALIGN="JUSTIFY">The size of the stack frame is limited to 32KB for early members of the 68000 family prior</P>
<P ALIGN="JUSTIFY">to 68020.</P>
<P ALIGN="JUSTIFY">The basic data types are represented like:</P>
<P ALIGN="JUSTIFY"> Chapter 4: M68k/Coldfire Backend</P>
<P ALIGN="JUSTIFY">41</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes</P>
<P ALIGN="JUSTIFY">char 8 1</P>
<P ALIGN="JUSTIFY">short 16 2</P>
<P ALIGN="JUSTIFY">int 32 2</P>
<P ALIGN="JUSTIFY">long 32 2</P>
<P ALIGN="JUSTIFY">long long 64 2</P>
<P ALIGN="JUSTIFY">all pointers 32 2</P>
<P ALIGN="JUSTIFY">float(fpu) 32 2 see below</P>
<P ALIGN="JUSTIFY">double(fpu) 64 2 see below</P>
<P ALIGN="JUSTIFY">long double(fpu) 64 2 see below</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.3 Small data</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc can access static data in two ways. By default all such data will be accessed with</P>
<P ALIGN="JUSTIFY">full 32bit addresses (large data model). However there is a second way. You can set up an</P>
<P ALIGN="JUSTIFY">address register (a4) to point into the data segment and then address data with a 16bit</P>
<P ALIGN="JUSTIFY">o set through this register.</P>
<P ALIGN="JUSTIFY">The advantages of the small data model are that the program will usually be smaller (be-</P>
<P ALIGN="JUSTIFY">cause the 16bit o sets use less space and no relocation information is needed) and faster.</P>
<P ALIGN="JUSTIFY">The disadvantages are that one address register cannot be used by the compiler and that it</P>
<P ALIGN="JUSTIFY">can only be used if all static data occupies less than 64kb. Also object modules and libraries</P>
<P ALIGN="JUSTIFY">that have been compiled with di erent data models must not be mixed (it is possible to</P>
<P ALIGN="JUSTIFY">call functions compiled with large data model from object files compiled with small data</P>
<P ALIGN="JUSTIFY">model, but not vice versa and only functions can be called that way - other data cannot be</P>
<P ALIGN="JUSTIFY">accessed).</P>
<P ALIGN="JUSTIFY">If small data is used with functions which are called from functions which have not been</P>
<P ALIGN="JUSTIFY">compiled with vbcc or without the small data model then those functions must be declared</P>
<P ALIGN="JUSTIFY">with the __saveds attribute or call geta4() as the first statement (do not use automatic</P>
<P ALIGN="JUSTIFY">initializations prior to the call to geta4). Note that geta4() must not be called through a</P>
<P ALIGN="JUSTIFY">function pointer!</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.4 Small code</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">In the small code model calls to external functions (i.e. from libraries or other object files)</P>
<P ALIGN="JUSTIFY">are done with 16bit o sets through the program counter rather than with absolute 32bit</P>
<P ALIGN="JUSTIFY">addresses.</P>
<P ALIGN="JUSTIFY">The advantage is slightly smaller and faster code. The disadvantages are that all the code</P>
<P ALIGN="JUSTIFY">(including library functions) must be small enough. Objects/libraries can be linked together</P>
<P ALIGN="JUSTIFY">if they have been compiled with di erent code models.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.5 CPUs</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The values of ‘-cpu=n’ have those e ects:</P>
<P ALIGN="JUSTIFY">‘n&lt;68000’ Code for the Coldfire family is generated.</P>
<P ALIGN="JUSTIFY">‘n&gt;=68000’</P>
<P ALIGN="JUSTIFY">Code for the 68k family is generated.</P>
<P ALIGN="JUSTIFY"> 42</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">‘n&gt;=68020’</P>
<P ALIGN="JUSTIFY">- 32bit multiplication/division/modulo is done with the mul?.l, div?.l and</P>
<P ALIGN="JUSTIFY">div?l.l instructions.</P>
<P ALIGN="JUSTIFY">- tst.l ax is used.</P>
<P ALIGN="JUSTIFY">- extb.l dx is used.</P>
<P ALIGN="JUSTIFY">- 16/32bit o sets are used in certain addressing modes.</P>
<P ALIGN="JUSTIFY">- link.l is used.</P>
<P ALIGN="JUSTIFY">- Addressing modes with scaling are used.</P>
<P ALIGN="JUSTIFY">‘n==68040’</P>
<P ALIGN="JUSTIFY">- 8bit constants are not copied in data registers.</P>
<P ALIGN="JUSTIFY">- Static memory is not subject to common subexpression elimination.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.6 FPUs</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">At the moment the values of -fpu=n have those e ects:</P>
<P ALIGN="JUSTIFY">‘n&gt;68000’ Floating point calculations are done using the FPU.</P>
<P ALIGN="JUSTIFY">‘n=68040’</P>
<P ALIGN="JUSTIFY">‘n=68060’ Instructions that have to be emulated on these FPUs will not be used; at the</P>
<P ALIGN="JUSTIFY">moment this only includes the fintrz instruction in case of the 040.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.7 Math</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Long multiply on CPUs &lt;68020 uses inline routines. This may increase code size a bit,</P>
<P ALIGN="JUSTIFY">but it should be significantly faster, because function call overhead is not necessary. Long</P>
<P ALIGN="JUSTIFY">division and modulo is handled by calls to library functions. (Some operations involving</P>
<P ALIGN="JUSTIFY">constants (e.g. powers of two) are always implemented by more e cient inline code.)</P>
<P ALIGN="JUSTIFY">If no FPU is specified  oating point math is done using math libraries. 32bit IEEE format</P>
<P ALIGN="JUSTIFY">is used for  oat and 64bit IEEE for double and long double.</P>
<P ALIGN="JUSTIFY">If  oating point math is done with the FPU  oating point values are kept in registers and</P>
<P ALIGN="JUSTIFY">therefore may have extended precision sometimes. This is not ANSI compliant but will</P>
<P ALIGN="JUSTIFY">usually cause no harm. When  oating point values are stored in memory they use the same</P>
<P ALIGN="JUSTIFY">IEEE formats as without FPU. Return values are passed in fp0.</P>
<P ALIGN="JUSTIFY">Note that you must not link object files together if they were not compiled with the same</P>
<P ALIGN="JUSTIFY">-fpu settings and that a proper math library must be linked.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.8 Target-Specific Variable Attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend o ers the following variable attributes:</P>
<P ALIGN="JUSTIFY">__saveds Load the pointer to the small data segment at function-entry. Applicable only</P>
<P ALIGN="JUSTIFY">to functions.</P>
<P ALIGN="JUSTIFY">__chip Place variable in chip-memory. Only applicable on AmigaOS to variables with</P>
<P ALIGN="JUSTIFY">static storage-duration.</P>
<P ALIGN="JUSTIFY">__far Do not place this variable in the small-data segment in small data mode. No</P>
<P ALIGN="JUSTIFY">e ect in large data mode. Only applicable to variables with static storage-</P>
<P ALIGN="JUSTIFY">duration.</P>
<P ALIGN="JUSTIFY"> Chapter 4: M68k/Coldfire Backend</P>
<P ALIGN="JUSTIFY">43</P>
<P ALIGN="JUSTIFY">__near Currently ignored.</P>
<P ALIGN="JUSTIFY">__interrupt</P>
<P ALIGN="JUSTIFY">This is used to declare interrupt-handlers. The function using this attribute</P>
<P ALIGN="JUSTIFY">will save all registers it destroys (including scratch-registers) and return with</P>
<P ALIGN="JUSTIFY">rte rather than rts.</P>
<P ALIGN="JUSTIFY">__amigainterrupt</P>
<P ALIGN="JUSTIFY">Used to write interrupt-handlers for AmigaOS. Stack-checking for a function</P>
<P ALIGN="JUSTIFY">with this attribute will be disabled and if a value is returned in d0, the condition</P>
<P ALIGN="JUSTIFY">codes will be set accordingly.</P>
<P ALIGN="JUSTIFY">__section(&lt;string-literal&gt;)</P>
<P ALIGN="JUSTIFY">Places the variable/function in a section named according to the argument.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.9 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__M68K__</P>
<P ALIGN="JUSTIFY">__M680x0 (Depending on the settings of ‘-cpu’, e.g. __M68020.)</P>
<P ALIGN="JUSTIFY">__COLDFIRE</P>
<P ALIGN="JUSTIFY">(If a Coldfire CPU is selected.)</P>
<P ALIGN="JUSTIFY">__M68881 (If ‘-fpu=68881’ is selected.)</P>
<P ALIGN="JUSTIFY">__M68882 (If code for another FPU is selected; ‘-fpu=68040’ or ‘-fpu=68060’ will set</P>
<P ALIGN="JUSTIFY">__M68882.)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.10 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the ‘-stack-check’ option is used, every function-prologue will call the function __stack_</P>
<P ALIGN="JUSTIFY">check with the stacksize needed by the current function on the stack. This function has to</P>
<P ALIGN="JUSTIFY">consider its own stacksize and must restore all registers.</P>
<P ALIGN="JUSTIFY">If the compiler is able to calculate the maximum stack-size of a function including all callees,</P>
<P ALIGN="JUSTIFY">it will add a comment in the generated assembly-output (subject to change to labels).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.11 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A possible ‘&lt;stdarg.h&gt;’ could look like this:</P>
<P ALIGN="JUSTIFY">typedef unsigned char *va_list;</P>
<P ALIGN="JUSTIFY">#define __va_align(type) (__alignof(type)&gt;=4?__alignof(type):4)</P>
<P ALIGN="JUSTIFY">#define __va_do_align(vl,type) ((vl)=(char *)((((unsigned int)(vl))+__va_align(type)-1)/__va_align(type)*__va_align(type)))</P>
<P ALIGN="JUSTIFY">#define __va_mem(vl,type) (__va_do_align((vl),type),(vl)+=sizeof(type),((type*)(vl))[-1])</P>
<P ALIGN="JUSTIFY">#define va_start(ap, lastarg) ((ap)=(va_list)(&amp;lastarg+1))</P>
<P ALIGN="JUSTIFY"> 44</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">#define va_arg(vl,type) __va_mem(vl,type)</P>
<P ALIGN="JUSTIFY">#define va_end(vl) ((vl)=0)</P>
<P ALIGN="JUSTIFY">#define va_copy(new,old) ((new)=(old))</P>
<P ALIGN="JUSTIFY">#endif</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">4.12 Known problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- Converting  oating point values to unsigned integers is not correct if the value is</P>
<P ALIGN="JUSTIFY">&gt;LONG MAX and FPU code is generated.</P>
<P ALIGN="JUSTIFY">- The extended precision of the FPU registers can cause problems if a program depends</P>
<P ALIGN="JUSTIFY">on the exact precision. Most programs will not have trouble with that, but programs</P>
<P ALIGN="JUSTIFY">which do exact comparisons with  oating point types (e.g. to try to calculate the</P>
<P ALIGN="JUSTIFY">number of significant bits) may not work as expected (especially if the optimizer was</P>
<P ALIGN="JUSTIFY">turned on).</P>
<P ALIGN="JUSTIFY"> Chapter 5: PowerPC Backend</P>
<P ALIGN="JUSTIFY">45</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">5 PowerPC Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the Backend for the PowerPC processor family.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.1 Additional options for this version</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-merge-constants’</P>
<P ALIGN="JUSTIFY">Place identical  oating point constants at the same memory location. This can</P>
<P ALIGN="JUSTIFY">reduce program size.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in the .rodata section. Using this</P>
<P ALIGN="JUSTIFY">option it will be placed in the .data section. Note that on operating systems</P>
<P ALIGN="JUSTIFY">with memory protection this option will disable write-protection of constant</P>
<P ALIGN="JUSTIFY">data.</P>
<P ALIGN="JUSTIFY">‘-fsub-zero’</P>
<P ALIGN="JUSTIFY">Use fsub to load a  oating-point-register with zero. This is faster but requires</P>
<P ALIGN="JUSTIFY">all registers to always contain valid values (i.e. no NaNs etc.) which may not</P>
<P ALIGN="JUSTIFY">be the case depending on startup-code, libraries etc.</P>
<P ALIGN="JUSTIFY">‘-amiga-align’</P>
<P ALIGN="JUSTIFY">Do not require any alignments greater than 2 bytes. This is needed when</P>
<P ALIGN="JUSTIFY">accessing Amiga system-structures, but can cause a performance penalty.</P>
<P ALIGN="JUSTIFY">‘-elf’</P>
<P ALIGN="JUSTIFY">Do not prefix symbols with ’ ’. Prefix labels with ’.’.</P>
<P ALIGN="JUSTIFY">‘-poweropen’</P>
<P ALIGN="JUSTIFY">Generate code for the PowerOpen ABI like used in AIX. This does not work</P>
<P ALIGN="JUSTIFY">correctly yet.</P>
<P ALIGN="JUSTIFY">‘-sc’</P>
<P ALIGN="JUSTIFY">Generate code for the modified PowerOpen ABI used in the StormC compiler</P>
<P ALIGN="JUSTIFY">(aka WarpOS ABI).</P>
<P ALIGN="JUSTIFY">‘-no-regnames’</P>
<P ALIGN="JUSTIFY">Do not use register names but only numbers in the assembly output. This is</P>
<P ALIGN="JUSTIFY">necessary to avoid name-con icts when using ‘-elf’.</P>
<P ALIGN="JUSTIFY">‘-setccs’</P>
<P ALIGN="JUSTIFY">The V.4 ABI requires signalling (in a bit of the condition code register) when ar-</P>
<P ALIGN="JUSTIFY">guments to varargs-functions are passed in  oating-point registers. vbcc usually</P>
<P ALIGN="JUSTIFY">does not make use of this and therefore does not set that bit by default. This</P>
<P ALIGN="JUSTIFY">may lead to problems when linking objects compiled by vbcc to objects/libraries</P>
<P ALIGN="JUSTIFY">created by other compilers and calling varargs-functions with  oating-point ar-</P>
<P ALIGN="JUSTIFY">guments. ‘-setccs’ will fix this problem.</P>
<P ALIGN="JUSTIFY">‘-no-peephole’</P>
<P ALIGN="JUSTIFY">Do not perform several peephole optimizations. Currently includes:</P>
<P ALIGN="JUSTIFY"> 46</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">- better use of d16(r) addressing</P>
<P ALIGN="JUSTIFY">- use of indexed addressing modes</P>
<P ALIGN="JUSTIFY">- use of update- ag</P>
<P ALIGN="JUSTIFY">- use of record- ag</P>
<P ALIGN="JUSTIFY">- use of condition-code-registers to avoid certain branches</P>
<P ALIGN="JUSTIFY">‘-use-lmw’</P>
<P ALIGN="JUSTIFY">Use lmw/stmw-instructions. This can significantly reduce code-size. However</P>
<P ALIGN="JUSTIFY">these instructions may be slower on certain PPCs.</P>
<P ALIGN="JUSTIFY">‘-madd’ Use the fmadd/fmsub instructions for combining multiplication with</P>
<P ALIGN="JUSTIFY">addition/subtraction in one instruction. As these instructions do not round</P>
<P ALIGN="JUSTIFY">between the operations, they have increased precision over separate addition</P>
<P ALIGN="JUSTIFY">and multiplication.</P>
<P ALIGN="JUSTIFY">While this usually does no harm, it is not ISO conforming and therefore not</P>
<P ALIGN="JUSTIFY">the default behaviour.</P>
<P ALIGN="JUSTIFY">‘-eabi’ Use the PowerPC Embedded ABI (eabi).</P>
<P ALIGN="JUSTIFY">‘-sd’ Place all objects in small data-sections.</P>
<P ALIGN="JUSTIFY">‘-gas’ Create code suitable for the GNU assembler.</P>
<P ALIGN="JUSTIFY">‘-no-align-args’</P>
<P ALIGN="JUSTIFY">Do not align function arguments on the stack stricter than 4 bytes. Default</P>
<P ALIGN="JUSTIFY">with ‘-poweropen’.</P>
<P ALIGN="JUSTIFY">‘-use-commons’</P>
<P ALIGN="JUSTIFY">Use real common symbols instead of bss symbols for non-initialized external</P>
<P ALIGN="JUSTIFY">variables.</P>
<P ALIGN="JUSTIFY">‘-baserel32os4’</P>
<P ALIGN="JUSTIFY">Use 32bit base-relative addressing as used by AmigaOS 4.</P>
<P ALIGN="JUSTIFY">‘-baserel32mos’</P>
<P ALIGN="JUSTIFY">Use 32bit base-relative addressing as used by MorphOS.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend supports the following registers:</P>
<P ALIGN="JUSTIFY">- r0 through r31 for the general purpose registers,</P>
<P ALIGN="JUSTIFY">- f0 through f31 for the  oating point registers and</P>
<P ALIGN="JUSTIFY">- cr0 through cr7 for the condition-code registers.</P>
<P ALIGN="JUSTIFY">Additionally, the register pairs r3/r4, r5/r6, r7/r8, r9/r10, r14/r15, r16/r17,</P>
<P ALIGN="JUSTIFY">r18/r19, r20/r21, r22/r23, r24/r25, r26/r27, r28/r29 and r30/r31 are available.</P>
<P ALIGN="JUSTIFY">r0, r11, r12, f0, f12 and f13 are reserved by the backend.</P>
<P ALIGN="JUSTIFY">The current version generates assembly output for use with ‘vasmppc’ or the GNU assembler.</P>
<P ALIGN="JUSTIFY">The generated code should work on 32bit systems based on a PowerPC CPU using the V.4</P>
<P ALIGN="JUSTIFY">ABI or the PowerPC Embedded ABI (eabi).</P>
<P ALIGN="JUSTIFY"> Chapter 5: PowerPC Backend</P>
<P ALIGN="JUSTIFY">47</P>
<P ALIGN="JUSTIFY">The registers r0, r3-r12, f0-f13 and cr0-cr1 are used as scratch registers (i.e. they can be</P>
<P ALIGN="JUSTIFY">destroyed in function calls), all other registers are preserved. r1 is the stack-pointer and r13</P>
<P ALIGN="JUSTIFY">is the small-data-pointer if small-data-mode is used.</P>
<P ALIGN="JUSTIFY">The first 8 function arguments which have integer or pointer types are passed in registers</P>
<P ALIGN="JUSTIFY">r3 through r10 and the first 8  oating-point arguments are passed in registers f1 through</P>
<P ALIGN="JUSTIFY">f8. All other arguments are passed on the stack.</P>
<P ALIGN="JUSTIFY">Integers and pointers are returned in r3 (and r4 for long long),  oats and doubles in f1.</P>
<P ALIGN="JUSTIFY">All other types are returned by passing the function the address of the result as a hidden</P>
<P ALIGN="JUSTIFY">argument - so when you call such a function without a proper declaration in scope you can</P>
<P ALIGN="JUSTIFY">expect a crash.</P>
<P ALIGN="JUSTIFY">The elementary data types are represented like:</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes (-amiga-align)</P>
<P ALIGN="JUSTIFY">char 8 1 (1)</P>
<P ALIGN="JUSTIFY">short 16 2 (2)</P>
<P ALIGN="JUSTIFY">int 32 4 (2)</P>
<P ALIGN="JUSTIFY">long 32 4 (2)</P>
<P ALIGN="JUSTIFY">long long 64 8 (2)</P>
<P ALIGN="JUSTIFY">all pointers 32 4 (2)</P>
<P ALIGN="JUSTIFY">float 32 4 (2)</P>
<P ALIGN="JUSTIFY">double 64 8 (2)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.3 Target-specific variable-attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The PPC-backend o ers the following variable-attributes:</P>
<P ALIGN="JUSTIFY">__saveds Load the pointer to the small data segment at function-entry. Applicable only</P>
<P ALIGN="JUSTIFY">to functions.</P>
<P ALIGN="JUSTIFY">__chip Place variable in chip-memory. Only applicable on AmigaOS to variables with</P>
<P ALIGN="JUSTIFY">static storage-duration.</P>
<P ALIGN="JUSTIFY">__far Do not place this variable in the small-data segment in small-data-mode. No</P>
<P ALIGN="JUSTIFY">e ect in large-data-mode. Only applicable to variables with static storage-</P>
<P ALIGN="JUSTIFY">duration.</P>
<P ALIGN="JUSTIFY">__near Currently ignored.</P>
<P ALIGN="JUSTIFY">__saveall</P>
<P ALIGN="JUSTIFY">Make sure all registers are saved by this function. On lower optimization levels,</P>
<P ALIGN="JUSTIFY">all volatile registers will be saved additionally. On higher levels, only the ones</P>
<P ALIGN="JUSTIFY">that may be destroyed, are saved.</P>
<P ALIGN="JUSTIFY">__interrupt</P>
<P ALIGN="JUSTIFY">Return with en rfi-instruction rather than blr.</P>
<P ALIGN="JUSTIFY">__section("name","attr")</P>
<P ALIGN="JUSTIFY">Place this function/object in section "name" with attributes "attr".</P>
<P ALIGN="JUSTIFY"> 48</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.4 Target-specific pragmas</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The PPC-backend o ers the following #pragmas:</P>
<P ALIGN="JUSTIFY">#pragma amiga-align</P>
<P ALIGN="JUSTIFY">Set alignment like -amiga-alignment option.</P>
<P ALIGN="JUSTIFY">#pragma natural-align</P>
<P ALIGN="JUSTIFY">Align every type to its own size.</P>
<P ALIGN="JUSTIFY">#pragma default-align</P>
<P ALIGN="JUSTIFY">Set alignment according to command-line options.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.5 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__PPC__</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.6 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the ‘-stack-check’ option is used, every function-prologue will call the function __</P>
<P ALIGN="JUSTIFY">stack_check with the stacksize needed by this function in register r12. This function has</P>
<P ALIGN="JUSTIFY">to consider its own stacksize and must restore all registers.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.7 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A possible &lt;stdarg.h&gt; for V.4 ABI could look like this:</P>
<P ALIGN="JUSTIFY">typedef struct {</P>
<P ALIGN="JUSTIFY">int gpr;</P>
<P ALIGN="JUSTIFY">int fpr;</P>
<P ALIGN="JUSTIFY">char *regbase;</P>
<P ALIGN="JUSTIFY">char *membase;</P>
<P ALIGN="JUSTIFY">} va_list;</P>
<P ALIGN="JUSTIFY">char *__va_start(void);</P>
<P ALIGN="JUSTIFY">char *__va_regbase(void);</P>
<P ALIGN="JUSTIFY">int __va_fixedgpr(void);</P>
<P ALIGN="JUSTIFY">int __va_fixedfpr(void);</P>
<P ALIGN="JUSTIFY">#define va_start(vl,dummy) \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">vl.gpr=__va_fixedgpr(), \</P>
<P ALIGN="JUSTIFY">vl.fpr=__va_fixedfpr(), \</P>
<P ALIGN="JUSTIFY">vl.regbase=__va_regbase(), \</P>
<P ALIGN="JUSTIFY">vl.membase=__va_start() \</P>
<P ALIGN="JUSTIFY">)</P>
<P ALIGN="JUSTIFY">#define va_end(vl) ((vl).regbase=(vl).membase=0)</P>
<P ALIGN="JUSTIFY"> Chapter 5: PowerPC Backend</P>
<P ALIGN="JUSTIFY">49</P>
<P ALIGN="JUSTIFY">#define va_copy(new,old) ((new)=(old))</P>
<P ALIGN="JUSTIFY">#define __va_align(type) (__alignof(type)&gt;=4?__alignof(type):4)</P>
<P ALIGN="JUSTIFY">#define __va_do_align(vl,type) ((vl).membase=(char *)((((unsigned int)((vl).membase))+__va_align(type)-1)/__va_align(type)*__va_align(type)))</P>
<P ALIGN="JUSTIFY">#define __va_mem(vl,type) (__va_do_align((vl),type),(vl).membase+=sizeof(type),((type*)((vl).membase))[-1])</P>
<P ALIGN="JUSTIFY">#define va_arg(vl,type) \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">(__typeof(type)&amp;127)&gt;10? \</P>
<P ALIGN="JUSTIFY">__va_mem((vl),type) \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">(((__typeof(type)&amp;127)&gt;=6&amp;&amp;(__typeof(type)&amp;127)&lt;=8)) ? \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">++(vl).fpr&lt;=8 ? \</P>
<P ALIGN="JUSTIFY">((type*)((vl).regbase+32))[(vl).fpr-1] \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">__va_mem((vl),type) \</P>
<P ALIGN="JUSTIFY">) \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">++(vl).gpr&lt;=8 ? \</P>
<P ALIGN="JUSTIFY">((type*)((vl).regbase+0))[(vl).gpr-1] \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">__va_mem((vl),type) \</P>
<P ALIGN="JUSTIFY">) \</P>
<P ALIGN="JUSTIFY">) \</P>
<P ALIGN="JUSTIFY">)</P>
<P ALIGN="JUSTIFY">A possible &lt;stdarg.h&gt; for PowerOpen ABI could look like this:</P>
<P ALIGN="JUSTIFY">typedef unsigned char *va_list;</P>
<P ALIGN="JUSTIFY">#define __va_align(type) (4)</P>
<P ALIGN="JUSTIFY">#define __va_do_align(vl,type) ((vl)=(char *)((((unsigned int)(vl))+__va_align(type)-1)/__va_align(type)*__va_align(type)))</P>
<P ALIGN="JUSTIFY">#define __va_mem(vl,type) (__va_do_align((vl),type),(vl)+=sizeof(type),((type*)(vl))[-1])</P>
<P ALIGN="JUSTIFY">#define va_start(ap, lastarg) ((ap)=(va_list)(&amp;lastarg+1))</P>
<P ALIGN="JUSTIFY">#define va_arg(vl,type) __va_mem(vl,type)</P>
<P ALIGN="JUSTIFY">#define va_end(vl) ((vl)=0)</P>
<P ALIGN="JUSTIFY"> 50</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">#define va_copy(new,old) ((new)=(old))</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">5.8 Known problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- composite types are put on the stack rather than passed via pointer</P>
<P ALIGN="JUSTIFY">- indication of fp-register-args with bit 6 of cr is not done well</P>
<P ALIGN="JUSTIFY"> Chapter 6: DEC Alpha Backend</P>
<P ALIGN="JUSTIFY">51</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">6 DEC Alpha Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the Backend for the DEC Alpha processor family.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6.1 Additional options for this version</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-merge-constants’</P>
<P ALIGN="JUSTIFY">Place identical  oating point constants at the same memory location. This can</P>
<P ALIGN="JUSTIFY">reduce program size and increase compilation time.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in the code section (and therefore is</P>
<P ALIGN="JUSTIFY">accessable with faster pc-relative addressing modes). Using this option it will</P>
<P ALIGN="JUSTIFY">be placed in the data section. Note that on operating systems with memory</P>
<P ALIGN="JUSTIFY">protection this option will disable write-protection of constant data.</P>
<P ALIGN="JUSTIFY">‘-no-builtins’</P>
<P ALIGN="JUSTIFY">Do not replace certain builtin functions by inline code. This may be useful if</P>
<P ALIGN="JUSTIFY">you use this code generator with another frontend than vbcc. stdarg.h will not</P>
<P ALIGN="JUSTIFY">work with -no-builtins.</P>
<P ALIGN="JUSTIFY">‘-stabs’ Generate stabs debug infos (if -g is specified) rather than DWARF2 which is</P>
<P ALIGN="JUSTIFY">the default. Consider this obsolete.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend supports the following registers:</P>
<P ALIGN="JUSTIFY">- $0 through $31 for the general purpose registers and</P>
<P ALIGN="JUSTIFY">- $f0 through $f31 for the  oating point registers.</P>
<P ALIGN="JUSTIFY">The current version generates assembly output for use with the GNU assembler. The</P>
<P ALIGN="JUSTIFY">generated code should work on systems with 21064, 21066, 21164 and higher Alpha CPUs.</P>
<P ALIGN="JUSTIFY">The registers $0-$8, $16-$28, $f0, $f1 and $f10-$f30 are used as scratch registers (i.e.</P>
<P ALIGN="JUSTIFY">they can be destroyed in function calls), all other registers are preserved. Of course $31</P>
<P ALIGN="JUSTIFY">and $f31 cannot be used.</P>
<P ALIGN="JUSTIFY">The first 6 function arguments which have arithmetic or pointer types are passed in registers</P>
<P ALIGN="JUSTIFY">$16/$f16 through $21/$f21.</P>
<P ALIGN="JUSTIFY">Integers and pointers are returned in $0,  oats and doubles in $f0. All other types are</P>
<P ALIGN="JUSTIFY">returned by passing the function the address of the result as a hidden argument - so when</P>
<P ALIGN="JUSTIFY">you call such a function without a proper declaration in scope you can expect a crash.</P>
<P ALIGN="JUSTIFY">The elementary data types are represented like:</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes</P>
<P ALIGN="JUSTIFY">char 8 1</P>
<P ALIGN="JUSTIFY">short 16 2</P>
<P ALIGN="JUSTIFY">int 32 4</P>
<P ALIGN="JUSTIFY">long 64 8</P>
<P ALIGN="JUSTIFY"> 52</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">long long 64 8</P>
<P ALIGN="JUSTIFY">all pointers 64 8</P>
<P ALIGN="JUSTIFY">float 32 4</P>
<P ALIGN="JUSTIFY">double 64 8</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6.3 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__ALPHA__</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6.4 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A possible &lt;stdarg.h&gt; could look like this:</P>
<P ALIGN="JUSTIFY">typedef struct {</P>
<P ALIGN="JUSTIFY">char *regbase;</P>
<P ALIGN="JUSTIFY">char *membase;</P>
<P ALIGN="JUSTIFY">int arg;</P>
<P ALIGN="JUSTIFY">} va_list;</P>
<P ALIGN="JUSTIFY">char *__va_start(void);</P>
<P ALIGN="JUSTIFY">int __va_fixargs(void);</P>
<P ALIGN="JUSTIFY">#define va_start(vl,dummy) \</P>
<P ALIGN="JUSTIFY">(vl.arg=__va_fixargs(),vl.regbase=__va_start(),vl.membase=vl.regbase+(6-vl.arg)*16)</P>
<P ALIGN="JUSTIFY">#define va_end(vl) (vl.regbase=vl.membase=0)</P>
<P ALIGN="JUSTIFY">#define __va_size(type) ((sizeof(type)+7)/8*8)</P>
<P ALIGN="JUSTIFY">#define va_arg(vl,type) \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">((__typeof(type)&amp;15)&lt;=10&amp;&amp;++vl.arg&lt;=6) ? \</P>
<P ALIGN="JUSTIFY">( \</P>
<P ALIGN="JUSTIFY">((__typeof(type)&amp;15)&gt;=6&amp;&amp;(__typeof(type)&amp;15)&lt;=8) ? \</P>
<P ALIGN="JUSTIFY">(vl.regbase+=16,*(type *)(vl.regbase-8)) \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">(vl.regbase+=16,*(type *)(vl.regbase-16)) \</P>
<P ALIGN="JUSTIFY">) \</P>
<P ALIGN="JUSTIFY">: \</P>
<P ALIGN="JUSTIFY">(vl.membase+=__va_size(type),*(type *)(vl.membase-__va_size(type))) \</P>
<P ALIGN="JUSTIFY">)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">6.5 Known problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- generated code is rather poor</P>
<P ALIGN="JUSTIFY">- several other problems</P>
<P ALIGN="JUSTIFY"> Chapter 7: i386 Backend</P>
<P ALIGN="JUSTIFY">53</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">7 i386 Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the Backend for the Intel i386 processor family.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7.1 Additional options for this version</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-longalign’</P>
<P ALIGN="JUSTIFY">Align multibyte-values on 4-byte-boundaries. Needed by some operating sys-</P>
<P ALIGN="JUSTIFY">tems.</P>
<P ALIGN="JUSTIFY">‘-elf’ Do not use a ’ ’-prefix in front of external identifiers. Use a ’.’-prefix for label</P>
<P ALIGN="JUSTIFY">names.</P>
<P ALIGN="JUSTIFY">‘-merge-constants’</P>
<P ALIGN="JUSTIFY">Place identical  oating point constants at the same memory location. This can</P>
<P ALIGN="JUSTIFY">reduce program size and increase compilation time.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in a read-only section. Using this</P>
<P ALIGN="JUSTIFY">option it will be placed in the data section Note that on operating systems with</P>
<P ALIGN="JUSTIFY">memory protection this option will disable write-protection of constant data.</P>
<P ALIGN="JUSTIFY">‘-no-delayed-popping’</P>
<P ALIGN="JUSTIFY">By default arguments of function calls are not always popped from the stack</P>
<P ALIGN="JUSTIFY">immediately after the call, so that the arguments of several calls may be popped</P>
<P ALIGN="JUSTIFY">at once. With this option vbcc can be forced to pop them after every function</P>
<P ALIGN="JUSTIFY">call. This may simplify debugging and very slightly reduce the stack size needed</P>
<P ALIGN="JUSTIFY">by the compiled program.</P>
<P ALIGN="JUSTIFY">‘-safe-fp’</P>
<P ALIGN="JUSTIFY">Do not use the  oating-point-stack for register variables. At the moment this</P>
<P ALIGN="JUSTIFY">is necessary as vbcci386 still has problems in some cases otherwise.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend supports the following registers:</P>
<P ALIGN="JUSTIFY">- %eax, %ebx, %ecx, %edx</P>
<P ALIGN="JUSTIFY">- %esi, %edi, %ebp, %esp</P>
<P ALIGN="JUSTIFY">(And %st(0)-%st(7) for the  oating point stack but these must not bes used for register</P>
<P ALIGN="JUSTIFY">variables because they cannot be handled like normal registers.)</P>
<P ALIGN="JUSTIFY">The current version generates assembly output for use with the GNU assembler. The</P>
<P ALIGN="JUSTIFY">generated code should work on systems with Intel 80386 or higher CPUs with FPU and</P>
<P ALIGN="JUSTIFY">compatible chips.</P>
<P ALIGN="JUSTIFY">The registers %eax, %ecx and %edx (as well as the  oating point stack) are used as scratch</P>
<P ALIGN="JUSTIFY">registers (i.e. they can be destroyed in function calls), all other registers are preserved.</P>
<P ALIGN="JUSTIFY">All elementary types up to 4 bytes are returned in register %eax Floating point values are</P>
<P ALIGN="JUSTIFY">returned in %st(0). All other types are returned by passing the function the address of the</P>
<P ALIGN="JUSTIFY"> 54</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">result as a hidden argument - so when you call such a function without a proper declaration</P>
<P ALIGN="JUSTIFY">in scope you can expect a crash.</P>
<P ALIGN="JUSTIFY">vbcc uses %eax, %ebx, %ecx, %edx, %esi, %edi, %ebp and the  oating point stack for</P>
<P ALIGN="JUSTIFY">temporary results and register variables. Local variables are created on the stack and</P>
<P ALIGN="JUSTIFY">addressed via %esp.</P>
<P ALIGN="JUSTIFY">The elementary data types are represented like:</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes (-longalign)</P>
<P ALIGN="JUSTIFY">char 8 1 (1)</P>
<P ALIGN="JUSTIFY">short 16 2 (4)</P>
<P ALIGN="JUSTIFY">int 32 2 (4)</P>
<P ALIGN="JUSTIFY">long 32 2 (4)</P>
<P ALIGN="JUSTIFY">long long n/a n/a</P>
<P ALIGN="JUSTIFY">all pointers 32 2 (4)</P>
<P ALIGN="JUSTIFY">float 32 2 (4)</P>
<P ALIGN="JUSTIFY">double 64 2 (4)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7.3 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__I386__</P>
<P ALIGN="JUSTIFY">__X86__</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7.4 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A possible &lt;stdarg.h&gt; could look like this:</P>
<P ALIGN="JUSTIFY">typedef unsigned char *va_list;</P>
<P ALIGN="JUSTIFY">#define va_start(ap, lastarg) ((ap) = (va_list)(&amp;lastarg + 1))</P>
<P ALIGN="JUSTIFY">#define va_arg(ap, type) ((ap) += \</P>
<P ALIGN="JUSTIFY">(sizeof(type)&lt;sizeof(int)?sizeof(int):sizeof(type)), ((type *)(ap))[-1])</P>
<P ALIGN="JUSTIFY">#define va_end(ap) ((ap) = 0L)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">7.5 Known Problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- generated code is rather poor</P>
<P ALIGN="JUSTIFY">- functions which return  oating-point values sometimes are broken(?)</P>
<P ALIGN="JUSTIFY">- in some cases (scare registers) non-reentrant code is generated</P>
<P ALIGN="JUSTIFY"> Chapter 8: c16x Backend</P>
<P ALIGN="JUSTIFY">55</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">8 c16x Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the Backend for the c16x/st10 microcontroller family.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.1 Additional options for this version</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-merge-constants’</P>
<P ALIGN="JUSTIFY">Place identical  oating point constants at the same memory location. This can</P>
<P ALIGN="JUSTIFY">reduce program size and increase compilation time.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in a read-only section. Using this option</P>
<P ALIGN="JUSTIFY">it will be placed in the data section.</P>
<P ALIGN="JUSTIFY">‘-no-delayed-popping’</P>
<P ALIGN="JUSTIFY">By default arguments of function calls are not always popped from the stack</P>
<P ALIGN="JUSTIFY">immediately after the call, so that the arguments of several calls may be popped</P>
<P ALIGN="JUSTIFY">at once. With this option vbcc can be forced to pop them after every function</P>
<P ALIGN="JUSTIFY">call. This may simplify debugging and very slightly reduce the stack size needed</P>
<P ALIGN="JUSTIFY">by the compiled program.</P>
<P ALIGN="JUSTIFY">‘-no-peephole’</P>
<P ALIGN="JUSTIFY">Do not perform peephole-optimizations.</P>
<P ALIGN="JUSTIFY">‘-tasking’</P>
<P ALIGN="JUSTIFY">Produce output for the Tasking assembler.</P>
<P ALIGN="JUSTIFY">‘-mtiny’ Assume all functions are within one code-segment. Shorter instructions for</P>
<P ALIGN="JUSTIFY">calling functions are used and function-pointers will be only 2 bytes long. This</P>
<P ALIGN="JUSTIFY">results in shorter and faster code.</P>
<P ALIGN="JUSTIFY">‘-mlarge’ All objects which are not explicitly qualified are assumed to be far (i.e. they</P>
<P ALIGN="JUSTIFY">may be in di erent segments but must not cross one segment-boundary). The</P>
<P ALIGN="JUSTIFY">default pointer size will be 4.</P>
<P ALIGN="JUSTIFY">‘-mhuge’ All objects which are not explicitly qualified are assumed to be huge (i.e. they</P>
<P ALIGN="JUSTIFY">may be in di erent segments and may cross segment-boundaries). The default</P>
<P ALIGN="JUSTIFY">pointer size will be 4.</P>
<P ALIGN="JUSTIFY">‘-int32’ Do not use.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend supports the following registers:</P>
<P ALIGN="JUSTIFY">- R0 through R15 for the general purpose registers</P>
<P ALIGN="JUSTIFY">Additionally, the register pairs R2/R3, R3/R4, R4/R5, R6/R7, R7/R8, R8/R9, R12/R13,</P>
<P ALIGN="JUSTIFY">R13/R14, and R15/R15 are available.</P>
<P ALIGN="JUSTIFY">R1, R11 and R12 are reserved by the backend.</P>
<P ALIGN="JUSTIFY">The current version generates assembly output for use with the vasm assembler. Option-</P>
<P ALIGN="JUSTIFY">ally, assembly code for the Tasking assembler can be generated. The default memory</P>
<P ALIGN="JUSTIFY"> 56</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">model corresponds to the Tasking small-memory model with 16bit data-pointers and 32bit</P>
<P ALIGN="JUSTIFY">function-pointers. However, the DPPx registers have to be set up in a way to create a linear</P>
<P ALIGN="JUSTIFY">16bit address space (i.e. DPPx=x). The generated code should work on systems with c161,</P>
<P ALIGN="JUSTIFY">c163, c164, c165 and c167 microcontrollers as well as ST10 derivates. Old versions like the</P>
<P ALIGN="JUSTIFY">c166 are not supported</P>
<P ALIGN="JUSTIFY">The registers R1-R5 and R10-R15 are used as scratch registers (i.e. they can be destroyed</P>
<P ALIGN="JUSTIFY">in function calls), all other registers are preserved.</P>
<P ALIGN="JUSTIFY">R0 is used as user stack pointer. Automatic variables and temporaries are put on the user</P>
<P ALIGN="JUSTIFY">stack. Return addresses are pushed on the system stack.</P>
<P ALIGN="JUSTIFY">The first 4 function arguments which have integer or pointer types are passed in registers</P>
<P ALIGN="JUSTIFY">R12 through R15.</P>
<P ALIGN="JUSTIFY">Integers and pointers are returned in R4/R5. All other types are returned by passing the</P>
<P ALIGN="JUSTIFY">function the address of the result as a hidden argument - so when you call such a function</P>
<P ALIGN="JUSTIFY">without a proper declaration in scope you can expect a crash.</P>
<P ALIGN="JUSTIFY">The elementary data types are represented like:</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes</P>
<P ALIGN="JUSTIFY">char 8 1</P>
<P ALIGN="JUSTIFY">short 16 2</P>
<P ALIGN="JUSTIFY">int 16 2</P>
<P ALIGN="JUSTIFY">long 32 2</P>
<P ALIGN="JUSTIFY">long long n/a n/a</P>
<P ALIGN="JUSTIFY">near pointers 16 2</P>
<P ALIGN="JUSTIFY">far pointers 32 2</P>
<P ALIGN="JUSTIFY">huge pointers 32 2</P>
<P ALIGN="JUSTIFY">float n/a n/a</P>
<P ALIGN="JUSTIFY">double n/a n/a</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.3 Target-specific variable-attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The c16x-backend o ers the following variable attributes:</P>
<P ALIGN="JUSTIFY">__interrupt</P>
<P ALIGN="JUSTIFY">Return with rfi rather than blr. MDL/MDH will be saved, however it is recom-</P>
<P ALIGN="JUSTIFY">mended to switch to a new register bank as the gprs are not saved. Also,</P>
<P ALIGN="JUSTIFY">DPP0-DPP3 are not saved (the compiler does not use them).</P>
<P ALIGN="JUSTIFY">__interrupt(&lt;vector&gt;)</P>
<P ALIGN="JUSTIFY">Like __interrupt, but also places a jump-instruction to the interrupt service at</P>
<P ALIGN="JUSTIFY">the corresponding vector table address (needs support from library and linker</P>
<P ALIGN="JUSTIFY">file).</P>
<P ALIGN="JUSTIFY">__section(&lt;name&gt;)</P>
<P ALIGN="JUSTIFY">Place this object/function in section &lt;name&gt;.</P>
<P ALIGN="JUSTIFY">__rbank(&lt;bank&gt;)</P>
<P ALIGN="JUSTIFY">Switch to another register-bank for this function.</P>
<P ALIGN="JUSTIFY"> Chapter 8: c16x Backend</P>
<P ALIGN="JUSTIFY">57</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.4 Target-specific type-attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The c16x-backend o ers the following type attributes:</P>
<P ALIGN="JUSTIFY">__near Object resides within the same segment.</P>
<P ALIGN="JUSTIFY">__far Object may reside in a di erent segment, but does not cross a</P>
<P ALIGN="JUSTIFY">segment-boundary.</P>
<P ALIGN="JUSTIFY">__huge Object may reside in a di erent segment and may cross a segment-boundary</P>
<P ALIGN="JUSTIFY">__section(&lt;name&gt;)</P>
<P ALIGN="JUSTIFY">Place this function or object in section &lt;name&gt;.</P>
<P ALIGN="JUSTIFY">__sfr(&lt;addr&gt;)</P>
<P ALIGN="JUSTIFY">Used to declare a special function register at &lt;addr&gt;.</P>
<P ALIGN="JUSTIFY">Example:</P>
<P ALIGN="JUSTIFY">__sfr(0xff10) volatile unsigned int PSW;</P>
<P ALIGN="JUSTIFY">__esfr(&lt;addr&gt;)</P>
<P ALIGN="JUSTIFY">The same for extended special function registers.</P>
<P ALIGN="JUSTIFY">__sfrbit(&lt;addr&gt;,&lt;bit&gt;)</P>
<P ALIGN="JUSTIFY">Declare a single bit in the bit-addressable area.</P>
<P ALIGN="JUSTIFY">Example:</P>
<P ALIGN="JUSTIFY">__sfr(0xff10,11) volatile __bit IEN;</P>
<P ALIGN="JUSTIFY">__esfrbit(&lt;addr&gt;,&lt;bit&gt;)</P>
<P ALIGN="JUSTIFY">The same for the extended bit-addressable area.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.5 Target-specific types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The c16x-backend o ers the following additional types:</P>
<P ALIGN="JUSTIFY">__bit A single bit in the bit-addressable inernal RAM-area. Only static and external</P>
<P ALIGN="JUSTIFY">variables may use this type. It is not allowed for auto or register storage-class.</P>
<P ALIGN="JUSTIFY">Also, arrays of bits, pointers to bits or bits within aggregates are not allowed.</P>
<P ALIGN="JUSTIFY">Conversion of a bit to an integral type yields 0 if the bit is cleared and 1 if it is</P>
<P ALIGN="JUSTIFY">set.. Conversion of an integral type to a bit clears the bit if the integer is equal</P>
<P ALIGN="JUSTIFY">to 0 and sets it otherwise.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.6 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__C16X__</P>
<P ALIGN="JUSTIFY">__C167__</P>
<P ALIGN="JUSTIFY">__ST10__</P>
<P ALIGN="JUSTIFY"> 58</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.7 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the ‘-stack-check’ option is used, every function-prologue will call the function __</P>
<P ALIGN="JUSTIFY">stack_check with the stacksize needed by this function in register R1. This function has</P>
<P ALIGN="JUSTIFY">to consider its own stacksize and must restore all registers.</P>
<P ALIGN="JUSTIFY">Only stack-checking of the user-stack is supported. Checking the system-stack is supported</P>
<P ALIGN="JUSTIFY">by hardware.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.8 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A possible &lt;stdarg.h&gt; could look like this:</P>
<P ALIGN="JUSTIFY">typedef char *va_list;</P>
<P ALIGN="JUSTIFY">va_list __va_start(void);</P>
<P ALIGN="JUSTIFY">#define __va_rounded_size(__TYPE) \</P>
<P ALIGN="JUSTIFY">(((sizeof (__TYPE) + sizeof (int) - 1) / sizeof (int)) * sizeof (int))</P>
<P ALIGN="JUSTIFY">#define va_start(__AP,__LA) (__AP=__va_start())</P>
<P ALIGN="JUSTIFY">#define va_arg(__AP, __TYPE) \</P>
<P ALIGN="JUSTIFY">(__AP = ((char *) (__AP) + __va_rounded_size (__TYPE)), \</P>
<P ALIGN="JUSTIFY">*((__TYPE *)((__AP) - __va_rounded_size (__TYPE))))</P>
<P ALIGN="JUSTIFY">#define va_end(__AP) ((__AP) = 0)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">8.9 Known Problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- no  oating-point</P>
<P ALIGN="JUSTIFY">- huge-pointers are sometimes derferenced as far-pointers</P>
<P ALIGN="JUSTIFY">- addressing-modes sometimes ignore huge</P>
<P ALIGN="JUSTIFY">- initialized data is placed in RAM, bits are not initialized</P>
<P ALIGN="JUSTIFY">- struct-copy only works with near-pointers</P>
<P ALIGN="JUSTIFY">- near/far-conversion assumes DPP0-DPP3 linear</P>
<P ALIGN="JUSTIFY"> Chapter 9: 68hc12 Backend</P>
<P ALIGN="JUSTIFY">59</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">9 68hc12 Backend</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter documents the Backend for the 68hc12 microcontroller family.</P>
<P ALIGN="JUSTIFY">Note that this backend is not done!</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.1 Additional options for this version</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend provides the following additional options:</P>
<P ALIGN="JUSTIFY">‘-merge-constants’</P>
<P ALIGN="JUSTIFY">Place identical  oating point constants at the same memory location. This can</P>
<P ALIGN="JUSTIFY">reduce program size and increase compilation time.</P>
<P ALIGN="JUSTIFY">‘-const-in-data’</P>
<P ALIGN="JUSTIFY">By default constant data will be placed in a read-only section. Using this option</P>
<P ALIGN="JUSTIFY">it will be placed in the data section.</P>
<P ALIGN="JUSTIFY">‘-no-delayed-popping’</P>
<P ALIGN="JUSTIFY">By default arguments of function calls are not always popped from the stack</P>
<P ALIGN="JUSTIFY">immediately after the call, so that the arguments of several calls may be popped</P>
<P ALIGN="JUSTIFY">at once. With this option vbcc can be forced to pop them after every function</P>
<P ALIGN="JUSTIFY">call. This may simplify debugging and very slightly reduce the stack size needed</P>
<P ALIGN="JUSTIFY">by the compiled program.</P>
<P ALIGN="JUSTIFY">‘-no-peephole’</P>
<P ALIGN="JUSTIFY">Do not perform peephole-optimizations.</P>
<P ALIGN="JUSTIFY">‘-mem-cse’</P>
<P ALIGN="JUSTIFY">Try to hold values loaded from memory in registers and reuse them. Due to the</P>
<P ALIGN="JUSTIFY">small register-set of the hc12 this is disabled by default as it increases register-</P>
<P ALIGN="JUSTIFY">pressure and tends to spill to the stack.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.2 ABI</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The current version generates assembly output for use with the GNU assembler using the</P>
<P ALIGN="JUSTIFY">non-banked model.</P>
<P ALIGN="JUSTIFY">This backend supports the following registers:</P>
<P ALIGN="JUSTIFY">- d for the accumulator (also used for byte, i.e. a)</P>
<P ALIGN="JUSTIFY">- x for index register x</P>
<P ALIGN="JUSTIFY">- y for index register y</P>
<P ALIGN="JUSTIFY">- sp for the stack-pointer</P>
<P ALIGN="JUSTIFY">All registers are scratch (i.e. caller-save).</P>
<P ALIGN="JUSTIFY">The first function arguments which has integer or pointer types is passed in the accumulator</P>
<P ALIGN="JUSTIFY">d or the register pair d/x. The remaining arguments are passed on the stack.</P>
<P ALIGN="JUSTIFY">Integers and pointers are returned in d or d/x. All other types are returned by passing the</P>
<P ALIGN="JUSTIFY">function the address of the result as a hidden argument - so when you call such a function</P>
<P ALIGN="JUSTIFY">without a proper declaration in scope you can expect a crash.</P>
<P ALIGN="JUSTIFY">The elementary data types are represented like:</P>
<P ALIGN="JUSTIFY"> 60</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">type size in bits alignment in bytes</P>
<P ALIGN="JUSTIFY">char 8 1</P>
<P ALIGN="JUSTIFY">short 16 2</P>
<P ALIGN="JUSTIFY">int 16 2</P>
<P ALIGN="JUSTIFY">long currently not supported</P>
<P ALIGN="JUSTIFY">near pointers 16 2</P>
<P ALIGN="JUSTIFY">far pointers currently not supported</P>
<P ALIGN="JUSTIFY">huge pointers currently not supported</P>
<P ALIGN="JUSTIFY">float currently not supported</P>
<P ALIGN="JUSTIFY">double currently not supported</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.3 Target-specific variable-attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The hc12-backend o ers the following variable attributes:</P>
<P ALIGN="JUSTIFY">__interrupt</P>
<P ALIGN="JUSTIFY">Return with rfi rather than blr.</P>
<P ALIGN="JUSTIFY">__section("name","attr")</P>
<P ALIGN="JUSTIFY">Place this function/object in section "section" with attributes "attr".</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.4 Predefined Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This backend defines the following macros:</P>
<P ALIGN="JUSTIFY">__HC12__</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.5 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If the ‘-stack-check’ option is used, every function-prologue will call the function __stack_</P>
<P ALIGN="JUSTIFY">check with the stacksize needed by this function in register y. This function has to consider</P>
<P ALIGN="JUSTIFY">its own stacksize and must restore all registers.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.6 Stdarg</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To be written...</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">9.7 Known Problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- this backend is far from done...</P>
<P ALIGN="JUSTIFY"> Chapter 10: Instruction Scheduler</P>
<P ALIGN="JUSTIFY">61</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">10 Instruction Scheduler</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vsc - scheduler for vbcc (c) in 1997-99 by Volker Barthelmann</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">10.1 Introduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vsc is an instruction-scheduler which reorders the assembly output of vbcc and tries to</P>
<P ALIGN="JUSTIFY">improve performance of the generated code by avoiding pipeline stalls etc.</P>
<P ALIGN="JUSTIFY">Like the compiler vbcc it is split into a target independent and a target dependent part.</P>
<P ALIGN="JUSTIFY">However there may be code-generators for vbcc which do not have a corresponding scheduler.</P>
<P ALIGN="JUSTIFY">This document only deals with the target independent parts of vsc. Be sure to read all the</P>
<P ALIGN="JUSTIFY">documents for your machine.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">10.2 Usage</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Usually vsc will be called by a frontend. However if you call it directly, it has to be done</P>
<P ALIGN="JUSTIFY">like this:</P>
<P ALIGN="JUSTIFY">vsc [options] input-file output-file</P>
<P ALIGN="JUSTIFY">The following options are supported:</P>
<P ALIGN="JUSTIFY">‘-quiet’ Do not print the copyright notice.</P>
<P ALIGN="JUSTIFY">‘-debug=&lt;n&gt;’</P>
<P ALIGN="JUSTIFY">Set debug-level to &lt;n&gt;.</P>
<P ALIGN="JUSTIFY">Note that depending on the target vbcc may insert hints into the generated code to tell</P>
<P ALIGN="JUSTIFY">vsc what CPU to schedule for. Code scheduled for a certain CPU may run much slower on</P>
<P ALIGN="JUSTIFY">slightly di erent CPUs. Therefore it is especially important to specify the correct target-</P>
<P ALIGN="JUSTIFY">CPU when compiling.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">10.3 Known problems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">- works only on basic-blocks</P>
<P ALIGN="JUSTIFY"> 62</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">63</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">11 C Library</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter describes the C library usually provided with vbcc.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.1 Introduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To execute code compiled by vbcc, a library is needed. It provides basic interfaces to the</P>
<P ALIGN="JUSTIFY">underlying operating system or hardware as well as a set of often used functions.</P>
<P ALIGN="JUSTIFY">A big part of the library is portable across all architectures. However, some functions (e.g.</P>
<P ALIGN="JUSTIFY">for input/output or memory allocation) are naturally dependent on the operating system</P>
<P ALIGN="JUSTIFY">or hardware. There are several sections in this chapter dealing with di erent versions of the</P>
<P ALIGN="JUSTIFY">library.</P>
<P ALIGN="JUSTIFY">The library itself often is split into several parts. A startup-code will do useful initializations,</P>
<P ALIGN="JUSTIFY">like setting up IO, parsing the command line or initializing variables and hardware.</P>
<P ALIGN="JUSTIFY">The biggest part of the functions will usually be stored in one library file. The name and</P>
<P ALIGN="JUSTIFY">format of this file depends on the conventions of the underlying system (e.g. ‘vc.lib’ or</P>
<P ALIGN="JUSTIFY">‘libvc.a’).</P>
<P ALIGN="JUSTIFY">Often,  oating point code (if available) is stored in a di erent file (e.g. ‘m.lib’ or ‘libm.a’).</P>
<P ALIGN="JUSTIFY">If  oating point is used in an application, it might be necessary to explicitly link with this</P>
<P ALIGN="JUSTIFY">library (e.g. by specifying ‘-lm’).</P>
<P ALIGN="JUSTIFY">In many cases, the include files provide special inline-code or similar optimizations. There-</P>
<P ALIGN="JUSTIFY">fore, it is recommended to always include the corresponding include file when using a library</P>
<P ALIGN="JUSTIFY">function. Even if it is not necessary in all cases, it may a ect the quality of the generated</P>
<P ALIGN="JUSTIFY">code.</P>
<P ALIGN="JUSTIFY">The library implements the functions specified by ISO9899:1989 as well as a small number</P>
<P ALIGN="JUSTIFY">of the new functions from ISO9899:1999.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.2 Legal</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Most parts of this library are public domain. However, for some systems, parts may be</P>
<P ALIGN="JUSTIFY">under a di erent license. Please consult the system specific documentation. Usually, linking</P>
<P ALIGN="JUSTIFY">against this library will not put any restrictions on the created executable unless otherwise</P>
<P ALIGN="JUSTIFY">mentioned.</P>
<P ALIGN="JUSTIFY">Parts of the math library (e.g. transcendental functions) are derived from Sun’s free math</P>
<P ALIGN="JUSTIFY">library:</P>
<P ALIGN="JUSTIFY">* ====================================================</P>
<P ALIGN="JUSTIFY">* Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.</P>
<P ALIGN="JUSTIFY">*</P>
<P ALIGN="JUSTIFY">* Developed at SunPro, a Sun Microsystems, Inc. business.</P>
<P ALIGN="JUSTIFY">* Permission to use, copy, modify, and distribute this</P>
<P ALIGN="JUSTIFY">* software is freely granted, provided that this notice</P>
<P ALIGN="JUSTIFY">* is preserved.</P>
<P ALIGN="JUSTIFY">* ====================================================</P>
<P ALIGN="JUSTIFY">The soft oat functions, used by some targets, are derived from John Hauser’s IEC/IEEE</P>
<P ALIGN="JUSTIFY">Floating-point Artithmetic Package:</P>
<P ALIGN="JUSTIFY"> 64</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">This C source file is part of the SoftFloat IEC/IEEE Floating-point</P>
<P ALIGN="JUSTIFY">Arithmetic Package, Release 2.</P>
<P ALIGN="JUSTIFY">Written by John R. Hauser. This work was made possible in part by the</P>
<P ALIGN="JUSTIFY">International Computer Science Institute, located at Suite 600, 1947 Center</P>
<P ALIGN="JUSTIFY">Street, Berkeley, California 94704. Funding was partially provided by the</P>
<P ALIGN="JUSTIFY">National Science Foundation under grant MIP-9311980. The original version</P>
<P ALIGN="JUSTIFY">of this code was written as part of a project to build a fixed-point vector</P>
<P ALIGN="JUSTIFY">processor in collaboration with the University of California at Berkeley,</P>
<P ALIGN="JUSTIFY">overseen by Profs. Nelson Morgan and John Wawrzynek. More information</P>
<P ALIGN="JUSTIFY">is available through the web page ‘http://HTTP.CS.Berkeley.EDU/~jhauser/</P>
<P ALIGN="JUSTIFY">arithmetic/softfloat.html’.</P>
<P ALIGN="JUSTIFY">THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE. Although reasonable effort</P>
<P ALIGN="JUSTIFY">has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT</P>
<P ALIGN="JUSTIFY">TIMES RESULT IN INCORRECT BEHAVIOR. USE OF THIS SOFTWARE IS RESTRICTED TO</P>
<P ALIGN="JUSTIFY">PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY</P>
<P ALIGN="JUSTIFY">AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.</P>
<P ALIGN="JUSTIFY">Derivative works are acceptable, even for commercial purposes, so long as</P>
<P ALIGN="JUSTIFY">(1) they include prominent notice that the work is derivative, and (2) they</P>
<P ALIGN="JUSTIFY">include prominent notice akin to these three paragraphs for those parts of</P>
<P ALIGN="JUSTIFY">this code that are retained.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3 Embedded Systems</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for embedded systems.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup is usually split into two parts. The first part is done by assembly code that</P>
<P ALIGN="JUSTIFY">produces the object file ‘lib/startup.o’. This assembly code is usually provided with vbcc</P>
<P ALIGN="JUSTIFY">and may have to be adapted to the hardware you are using. The key actions that have to</P>
<P ALIGN="JUSTIFY">be performed by this code are:</P>
<P ALIGN="JUSTIFY">-hardware initialization</P>
<P ALIGN="JUSTIFY">It may be necessary to perform some hardware initialization right at the be-</P>
<P ALIGN="JUSTIFY">ginning, e.g. to configure the memory system. This has to be modified by the</P>
<P ALIGN="JUSTIFY">user.</P>
<P ALIGN="JUSTIFY">-variable initializations</P>
<P ALIGN="JUSTIFY">When running code from ROM, some memory sections have to be initialized.</P>
<P ALIGN="JUSTIFY">Usually, the init-values of initialized variables have to be copied from ROM to</P>
<P ALIGN="JUSTIFY">the data segment and the values of un-initialized variables have to be cleared</P>
<P ALIGN="JUSTIFY">in the bss segment. This code is usually provided in the startup code.</P>
<P ALIGN="JUSTIFY">-stack pointer</P>
<P ALIGN="JUSTIFY">The stack pointer has to be set to a suitable memory area. The startup code</P>
<P ALIGN="JUSTIFY">will set the stack pointer to the value of the pointer __stack. There is a default</P>
<P ALIGN="JUSTIFY">stack provided in the C library which will be used unless the application defines</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">65</P>
<P ALIGN="JUSTIFY">its own stack using, for example, the following code (assuming that the stack</P>
<P ALIGN="JUSTIFY">grows downwards):</P>
<P ALIGN="JUSTIFY">#define STACKSIZE &lt;whatever&gt;</P>
<P ALIGN="JUSTIFY">static long mystack[STACKSIZE/sizeof(long)];</P>
<P ALIGN="JUSTIFY">char *__stack=((char*)mystack)+STACKSIZE;</P>
<P ALIGN="JUSTIFY">-calling __main</P>
<P ALIGN="JUSTIFY">After all the above initializations have been performed, the function __main()</P>
<P ALIGN="JUSTIFY">has to be called. This function is provided by the library and performs high-</P>
<P ALIGN="JUSTIFY">level initializations, if necessary (mainly it calls constructors created by the</P>
<P ALIGN="JUSTIFY">linker) and will then call the user main() function. Note that the library may</P>
<P ALIGN="JUSTIFY">not work correctly if the user main() function is called directly from the startup</P>
<P ALIGN="JUSTIFY">code.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.2 Heap</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When dynamic memory management is used (e.g. by using the malloc() function), a heap</P>
<P ALIGN="JUSTIFY">memory area is needed to allocate memory from. The malloc() function assumes that __</P>
<P ALIGN="JUSTIFY">heapptr is a variable pointing to the beginning of the heap memory and that __heapsize</P>
<P ALIGN="JUSTIFY">specifies the size of the heap area in bytes. The library will provide a default heap memory</P>
<P ALIGN="JUSTIFY">area that can be replaced by adding, for example, the following file to the application:</P>
<P ALIGN="JUSTIFY">#define HEAPSIZE &lt;whatever&gt;</P>
<P ALIGN="JUSTIFY">char __heap[HEAPSIZE],*__heapptr=__heap;</P>
<P ALIGN="JUSTIFY">size_t __heapsize=HEAPSIZE;</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.3 Input/Output</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The standard C input/output functions are provided also for embedded systems. Read-</P>
<P ALIGN="JUSTIFY">ing/writing to a stream will be directed to void unless the following low-level I/O-functions</P>
<P ALIGN="JUSTIFY">are provided by the application:</P>
<P ALIGN="JUSTIFY">int __open(const char *name,const char *mode);</P>
<P ALIGN="JUSTIFY">void __close(int h);</P>
<P ALIGN="JUSTIFY">size_t __read(int h,char *p,size_t l);</P>
<P ALIGN="JUSTIFY">size_t __write(int h,const char *p,size_t l);</P>
<P ALIGN="JUSTIFY">The __open() function receives a name and a mode string (as in the C fopen() function)</P>
<P ALIGN="JUSTIFY">as arguments and has to return a file-descriptor if it is possible to open this file. The other</P>
<P ALIGN="JUSTIFY">functions are equivalent to the corresponding POSIX functions.</P>
<P ALIGN="JUSTIFY">Also, stdin, stdout and stderr can be used with the standard descriptors.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.4 Floating Point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Whether  oating point is supported, depends on the target architecture and chip. If it is</P>
<P ALIGN="JUSTIFY">supported, there will usually be a math-library that has to be linked (using option ‘-lm’)</P>
<P ALIGN="JUSTIFY">when  oating point is used.</P>
<P ALIGN="JUSTIFY"> 66</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.5 Useless Functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Of course, some of the C library functions can not be implemented reasonably on embedded</P>
<P ALIGN="JUSTIFY">systems. These functions are contained in the library but will always return an error value.</P>
<P ALIGN="JUSTIFY">Mainly a ected are:</P>
<P ALIGN="JUSTIFY">-locale</P>
<P ALIGN="JUSTIFY">-time</P>
<P ALIGN="JUSTIFY">-signal</P>
<P ALIGN="JUSTIFY">-filesystem functions</P>
<P ALIGN="JUSTIFY">Depending on the hardware provided by a system it is possible to implement these functions</P>
<P ALIGN="JUSTIFY">and add them to the application. In this case, the new functions will be used rather than</P>
<P ALIGN="JUSTIFY">the default ones returning only error values.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.3.6 Linking/Locating</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To produce ROM images (e.g. in the form of absolute ELF executables, Intel Hex files</P>
<P ALIGN="JUSTIFY">or Motorola S-Records), the linker is called with a linker script. This script can be used</P>
<P ALIGN="JUSTIFY">to join together di erent sections of the input files and locate them to suitable absolute</P>
<P ALIGN="JUSTIFY">memory areas. Also, this linker script can be used to set symbols that may be used by the</P>
<P ALIGN="JUSTIFY">application or the startup code, e.g. addresses of data sections, initialization values or small</P>
<P ALIGN="JUSTIFY">data pointers.</P>
<P ALIGN="JUSTIFY">Code or data that has to reside at special locations can be put into a special section using</P>
<P ALIGN="JUSTIFY">the __section attribute. This section can then be placed at the desired location using the</P>
<P ALIGN="JUSTIFY">linker script.</P>
<P ALIGN="JUSTIFY">Usually, an example linker script will be provided. While this is often not suitable for</P>
<P ALIGN="JUSTIFY">di erent chips, it may serve as a starting point.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4 AmigaOS/68k</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for AmigaOS/68k. The relevant files are</P>
<P ALIGN="JUSTIFY">‘startup.o’, ‘minstart.o’, ‘vc.lib’, ‘vcs.lib’, ‘mieee.lib’, ‘mieees.lib’, ‘m881.lib’,</P>
<P ALIGN="JUSTIFY">‘m881s.lib’, ‘m040.lib’, ‘m040s.lib’ ‘amiga.lib’, ‘amigas.lib’, ‘auto.lib’ and</P>
<P ALIGN="JUSTIFY">‘autos.lib’.</P>
<P ALIGN="JUSTIFY">Note that ‘extra.lib’ is no longer part of the vbcc distribution. It was replaced by</P>
<P ALIGN="JUSTIFY">’PosixLib’, available on Aminet ‘dev/c/vbcc_PosixLib.lha’, which has a much more com-</P>
<P ALIGN="JUSTIFY">prehensive support for POSIX and Unix functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code currently consists of a slightly modified standard Amiga startup</P>
<P ALIGN="JUSTIFY">(‘startup.o’). The startup code sets up some global variables and initializes stdin, stdout</P>
<P ALIGN="JUSTIFY">and stderr. The exit code closes all open files and frees all memory. If you link with a</P>
<P ALIGN="JUSTIFY">math library the startup/exit code will be taken from there if necessary.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only. At the moment there are three math libraries:</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">67</P>
<P ALIGN="JUSTIFY">‘mieee.lib’</P>
<P ALIGN="JUSTIFY">This one uses the C= math libraries. The startup code will always open</P>
<P ALIGN="JUSTIFY">MathIeeeSingBas.library, MathIeeeDoubBas.library and MathIeeeDoub-</P>
<P ALIGN="JUSTIFY">Trans.library. Float return values are passed in d0, double return values are</P>
<P ALIGN="JUSTIFY">passed in d0/d1. A 68000 is su cient to use this library. You must not specify</P>
<P ALIGN="JUSTIFY">‘-fpu=...’ when you use this library.</P>
<P ALIGN="JUSTIFY">‘m881.lib’</P>
<P ALIGN="JUSTIFY">This one uses direct FPU instructions and function return values are passed in</P>
<P ALIGN="JUSTIFY">fp0. You must have a 68020 or higher and an FPU to use this library. You</P>
<P ALIGN="JUSTIFY">also have to specify ‘-fpu=68881’. Several FPU instructions that have to be</P>
<P ALIGN="JUSTIFY">emulated on 040/060 may be used.</P>
<P ALIGN="JUSTIFY">‘m040.lib’</P>
<P ALIGN="JUSTIFY">This one uses only direct FPU instructions that do not have to be emulated</P>
<P ALIGN="JUSTIFY">on a 040/060. Other functions use the Motorola emulation routines modified</P>
<P ALIGN="JUSTIFY">by Aki M Laukkanen. It should be used for programs compiled for 040 or 060</P>
<P ALIGN="JUSTIFY">with FPU. Return values are passed in fp0.</P>
<P ALIGN="JUSTIFY">Depending on the CPU/FPU selected, #including ‘math.h’ will cause inline-code generated</P>
<P ALIGN="JUSTIFY">for certain math functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">An application can specify the stack-size needed by defining a variable __stack (of type</P>
<P ALIGN="JUSTIFY">size_t) with external linkage, e.g.</P>
<P ALIGN="JUSTIFY">size_t __stack=65536; /* 64KB stack-size */</P>
<P ALIGN="JUSTIFY">The startup code will check whether the stack-size specified is larger than the default stack-</P>
<P ALIGN="JUSTIFY">size (as set in the shell) and switch to a new stack of appropriate size, if necessary.</P>
<P ALIGN="JUSTIFY">If the ‘-stack-check’ option is specified when compiling, the library will check for a stack</P>
<P ALIGN="JUSTIFY">over ow and abort the program, if the stack over ows. Note, however, that only code</P>
<P ALIGN="JUSTIFY">compiled with this option will be checked. Calls to libraries which have not been compiled</P>
<P ALIGN="JUSTIFY">with ‘-stack-check’ or calls to OS function may cause a stack over ow which is not noticed.</P>
<P ALIGN="JUSTIFY">Additionally, if ‘-stack-check’ is used, the maximum stack-size used can be read by query-</P>
<P ALIGN="JUSTIFY">ing the external variable __stack_usage.</P>
<P ALIGN="JUSTIFY">#include &lt;stdio.h&gt;</P>
<P ALIGN="JUSTIFY">extern size_t __stack_usage;</P>
<P ALIGN="JUSTIFY">main()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">do_program();</P>
<P ALIGN="JUSTIFY">printf("stack used: %lu\n",(unsigned long)__stack_usage);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Like above, the stack used by functions not compiled using ‘-stack-check’ or OS functions</P>
<P ALIGN="JUSTIFY">is ignored.</P>
<P ALIGN="JUSTIFY"> 68</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model of the 68k series CPUs, you also have to link with ap-</P>
<P ALIGN="JUSTIFY">propriate libraries. Most libraries documented here are also available as small data versions</P>
<P ALIGN="JUSTIFY">(with an ’s’ attached to the file name). Exceptions are the math libraries.</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lvcs -lamigas</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.5 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because on AmigaOS it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.6 Minimal startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">If you want to write programs that use only Amiga functions and none from vc.lib you can</P>
<P ALIGN="JUSTIFY">use ‘minstart.o’ instead of ‘startup.o’ and produce smaller executables.</P>
<P ALIGN="JUSTIFY">This is only useful for people who know enough about the Amiga shared libraries, the stubs</P>
<P ALIGN="JUSTIFY">in amiga.lib etc. If you do not know enough about those things better forget minstart at</P>
<P ALIGN="JUSTIFY">all.</P>
<P ALIGN="JUSTIFY">This startup code does not set up all the things needed by vc.lib, so you must not use most</P>
<P ALIGN="JUSTIFY">of those functions (string and ctype funtions are ok, but most other functions - especially</P>
<P ALIGN="JUSTIFY">I/O and memory handling - must not be used). exit() is supplied by minstart and can be</P>
<P ALIGN="JUSTIFY">used.</P>
<P ALIGN="JUSTIFY">The command line is not parsed, but passed to main() as a single string, so you can declare</P>
<P ALIGN="JUSTIFY">main as int main(char *command) or int main(void).</P>
<P ALIGN="JUSTIFY">Also no Amiga libraries are opened (but SysBase ist set up), so you have to define and</P>
<P ALIGN="JUSTIFY">open DOSBase yourself if you need it. If you want to use  oating point with the IEEE</P>
<P ALIGN="JUSTIFY">libraries you have to define and open MathIeeeSingBas.library, MathIeeeDoubBas.library</P>
<P ALIGN="JUSTIFY">and MathIeeeDoubTrans.library (in this order!) and link with mieee.lib (if compiled for</P>
<P ALIGN="JUSTIFY">FPU this is not needed).</P>
<P ALIGN="JUSTIFY">A hello world using minstart could look like this:</P>
<P ALIGN="JUSTIFY">#include &lt;proto/exec.h&gt;</P>
<P ALIGN="JUSTIFY">#include &lt;proto/dos.h&gt;</P>
<P ALIGN="JUSTIFY">struct DosLibrary *DOSBase;</P>
<P ALIGN="JUSTIFY">main()</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">if(DOSBase=(struct DosLibrary *)OpenLibrary("dos.library",0)){</P>
<P ALIGN="JUSTIFY">Write(Output(),"Hello, world!\n",14);</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">69</P>
<P ALIGN="JUSTIFY">CloseLibrary((struct Library *)DOSBase);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">return 0;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">This can yield an executable of under 300 bytes when compiled with ‘-sc -sd -O2’ and</P>
<P ALIGN="JUSTIFY">linked with ‘minstart.o’ and amigas.lib (using vlink - may not work with other linkers).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.7 amiga.lib</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To write programs accessing AmigaOS (rather than standard C functions only), a replace-</P>
<P ALIGN="JUSTIFY">ment for the original (copyrighted) ‘amiga.lib’ is provided with vbcc. This replacement</P>
<P ALIGN="JUSTIFY">is adapted to vbcc, does not cause collisions with some functions (e.g. sprintf) provided</P>
<P ALIGN="JUSTIFY">by the original ‘amiga.lib’ and is available in small data. It is recommended to always use</P>
<P ALIGN="JUSTIFY">this library rather than the original version.</P>
<P ALIGN="JUSTIFY">Additionally, there are header files (in the ‘proto’- and ‘inline’-subdirectories) which cause</P>
<P ALIGN="JUSTIFY">inlined calls to Amiga library functions.</P>
<P ALIGN="JUSTIFY">Specify ‘-lamiga’ to link with ‘amiga.lib’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.4.8 auto.lib</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To link with ‘auto.lib’ (or the small data version ‘autos.lib’) specify the ‘-lauto’ or</P>
<P ALIGN="JUSTIFY">‘-lautos’ option to vc.</P>
<P ALIGN="JUSTIFY">When you are calling a standard Amiga library function and do not have defined the</P>
<P ALIGN="JUSTIFY">corresponding library base then the library base as well as code to open/close it will be</P>
<P ALIGN="JUSTIFY">taken from ‘auto.lib’.</P>
<P ALIGN="JUSTIFY">By default, ‘auto.lib’ will try to open any library version. If you need at least a certain</P>
<P ALIGN="JUSTIFY">version you can define and set a variable &lt;library-base&gt;Ver with external linkage, e.g. (on</P>
<P ALIGN="JUSTIFY">file-scope):</P>
<P ALIGN="JUSTIFY">int _IntuitionBaseVer = 39;</P>
<P ALIGN="JUSTIFY">Note that your program will abort before reaching main() if one of the libraries cannot</P>
<P ALIGN="JUSTIFY">be opened. Also note that the dos.library will be openened by the standard startup code,</P>
<P ALIGN="JUSTIFY">not by auto.lib. This means you have to open dos.library yourself, when linking with</P>
<P ALIGN="JUSTIFY">‘minstart.o’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5 PowerUp/PPC</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for PowerUp/PPC. The relevant files</P>
<P ALIGN="JUSTIFY">are ‘startup.o’, ‘minstart.o’, ‘libvc.a’, ‘libvcs.a’, ‘libm.a’, ‘libms.a’ ‘libamiga.a’,</P>
<P ALIGN="JUSTIFY">‘libamigas.a’, ‘libauto.a’ and ‘libautos.a’.</P>
<P ALIGN="JUSTIFY">Note that ‘libextra.a’ is no longer part of the vbcc distribution. It was replaced by</P>
<P ALIGN="JUSTIFY">’PosixLib’, available on Aminet ‘dev/c/vbcc_PosixLib.lha’, which has a much more com-</P>
<P ALIGN="JUSTIFY">prehensive support for POSIX and Unix functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout and</P>
<P ALIGN="JUSTIFY">stderr. The exit code closes all open files and frees all memory. If you link with a math</P>
<P ALIGN="JUSTIFY">library the startup/exit code will be taken from there if necessary.</P>
<P ALIGN="JUSTIFY"> 70</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY">The math library (‘libm.a’) is linked against the  oating point library libmoto by Motorola.</P>
<P ALIGN="JUSTIFY">Depending on the CPU/FPU selected, #including ‘math.h’ will cause inline-code generated</P>
<P ALIGN="JUSTIFY">for certain math functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Stack-handling is similar to AmigaOS/68k (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.3 [amiga-stack], page 67</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). The</P>
<P ALIGN="JUSTIFY">only di erence is that stack-swapping cannot be done. If the default stack-size is less than</P>
<P ALIGN="JUSTIFY">the stack-size specified with __stack the program will abort.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model of the PPC series CPUs, you also have to link with ap-</P>
<P ALIGN="JUSTIFY">propriate libraries. Most libraries documented here are also available as small data versions</P>
<P ALIGN="JUSTIFY">(with an ’s’ attached to the file name). Exceptions are the math libraries.</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lvcs -lamigas</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.5 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because on AmigaOS it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.6 Minimal startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The provided minimal startup code (‘minstart.o’) is used similarly like the one for 68k</P>
<P ALIGN="JUSTIFY">(See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.6 [Minimal startup], page 68</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). Only use it if you know what you are doing.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.7 libamiga.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To write programs accessing AmigaOS (rather than standard C functions only), a replace-</P>
<P ALIGN="JUSTIFY">ment for the original (copyrighted) ‘amiga.lib’ is provided with vbcc. This replacement</P>
<P ALIGN="JUSTIFY">(‘libamiga.a’) automatically performs a necessary context switch to the 68k to execute</P>
<P ALIGN="JUSTIFY">the system call. Furthermore, it is adapted to vbcc, does not cause collisions with some</P>
<P ALIGN="JUSTIFY">functions (e.g. sprintf) provided by the original ‘amiga.lib’ and is available in small</P>
<P ALIGN="JUSTIFY">data.</P>
<P ALIGN="JUSTIFY">Specify ‘-lamiga’ to link with ‘libamiga.a’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.5.8 libauto.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This library corresponds to the AmigaOS/68k version (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.8 [auto.lib],</P>
<P ALIGN="JUSTIFY">page 69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">71</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6 WarpOS/PPC</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for WarpOS/PPC. The relevant files are</P>
<P ALIGN="JUSTIFY">‘startup.o’, ‘vc.lib’, ‘m.lib’, ‘amiga.lib’ and ‘auto.lib’.</P>
<P ALIGN="JUSTIFY">Note that ‘extra.lib’ is no longer part of the vbcc distribution. It was replaced by</P>
<P ALIGN="JUSTIFY">’PosixLib’, available on Aminet ‘dev/c/vbcc_PosixLib.lha’, which has a much more com-</P>
<P ALIGN="JUSTIFY">prehensive support for POSIX and Unix functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout and</P>
<P ALIGN="JUSTIFY">stderr. The exit code closes all open files and frees all memory. If you link with a math</P>
<P ALIGN="JUSTIFY">library the startup/exit code will be taken from there if necessary.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY">The math library (‘m.lib’) contains functions from Sun’s portable  oating point library.</P>
<P ALIGN="JUSTIFY">Additionally, there is a vbcc version of Andreas Heumann’s ‘ppcmath.lib’. These routines</P>
<P ALIGN="JUSTIFY">are linked against Motorola’s  oating point routines optimized for PowerPC and therefore</P>
<P ALIGN="JUSTIFY">are much faster.</P>
<P ALIGN="JUSTIFY">To make use of this library, link with ‘ppcmath.lib’ before ‘m.lib’, e.g.</P>
<P ALIGN="JUSTIFY">vc test.c -lppcmath -lm</P>
<P ALIGN="JUSTIFY">Depending on the CPU/FPU selected, #including ‘math.h’ will cause inline-code generated</P>
<P ALIGN="JUSTIFY">for certain math functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Stack-handling is similar to AmigaOS/68k (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.3 [amiga-stack], page 67</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.4 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because on AmigaOS it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.5 amiga.lib</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To write programs accessing AmigaOS (rather than standard C functions only), a replace-</P>
<P ALIGN="JUSTIFY">ment for the original (copyrighted) ‘amiga.lib’ is provided with vbcc. This replacement</P>
<P ALIGN="JUSTIFY">automatically performs a necessary context switch to the 68k to execute the system call.</P>
<P ALIGN="JUSTIFY">Furthermore, it is adapted to vbcc, does not cause collisions with some functions (e.g.</P>
<P ALIGN="JUSTIFY">sprintf) provided by the original ‘amiga.lib’ and is available in small data.</P>
<P ALIGN="JUSTIFY">Specify ‘-lamiga’ to link with ‘amiga.lib’.</P>
<P ALIGN="JUSTIFY"> 72</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.6.6 auto.lib</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This library corresponds to the AmigaOS/68k version (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.8 [auto.lib],</P>
<P ALIGN="JUSTIFY">page 69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7 MorphOS/PPC</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for MorphOS/PPC. The relevant files</P>
<P ALIGN="JUSTIFY">are ‘startup.o’, ‘minstart.o’, ‘libvc.a’, ‘libvcs.a’, ‘libm.a’, ‘libms.a’ ‘libamiga.a’,</P>
<P ALIGN="JUSTIFY">‘libamigas.a’, ‘libauto.a’ and ‘libautos.a’.</P>
<P ALIGN="JUSTIFY">Note that ‘libextra.a’ is no longer part of the vbcc distribution. It was replaced by</P>
<P ALIGN="JUSTIFY">’PosixLib’, available on Aminet ‘dev/c/vbcc_PosixLib.lha’, which has a much more com-</P>
<P ALIGN="JUSTIFY">prehensive support for POSIX and Unix functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout and</P>
<P ALIGN="JUSTIFY">stderr. The exit code closes all open files and frees all memory. If you link with a math</P>
<P ALIGN="JUSTIFY">library the startup/exit code will be taken from there if necessary.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY">The math library (‘libm.a’) is linked against the  oating point library libmoto by Motorola.</P>
<P ALIGN="JUSTIFY">Depending on the CPU/FPU selected, #including ‘math.h’ will cause inline-code generated</P>
<P ALIGN="JUSTIFY">for certain math functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Stack-handling is similar to AmigaOS/68k (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.3 [amiga-stack], page 67</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model of the PPC series CPUs, you also have to link with ap-</P>
<P ALIGN="JUSTIFY">propriate libraries. Most libraries documented here are also available as small data versions</P>
<P ALIGN="JUSTIFY">(with an ’s’ attached to the file name). Exceptions are the math libraries.</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lvcs -lamigas</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.5 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because on MorphOS it is not possible to obtain the time used by</P>
<P ALIGN="JUSTIFY">the calling process.</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">73</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.6 libamiga.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To write programs using AmigaOS compatible functions, a replacement for the original</P>
<P ALIGN="JUSTIFY">(copyrighted) ‘amiga.lib’ is provided with vbcc. This replacement (‘libamiga.a’) will</P>
<P ALIGN="JUSTIFY">invoke the MorphOS 68k emulator to execute the system function. Furthermore, it is</P>
<P ALIGN="JUSTIFY">adapted to vbcc and does not cause collisions with some functions (e.g. sprintf) and is</P>
<P ALIGN="JUSTIFY">available in small data.</P>
<P ALIGN="JUSTIFY">Specify ‘-lamiga’ to link with ‘libamiga.a’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.7.7 libauto.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This library corresponds to the AmigaOS/68k version (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.8 [auto.lib],</P>
<P ALIGN="JUSTIFY">page 69</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8 AmigaOS4/PPC</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for AmigaOS4/PPC. The relevant files</P>
<P ALIGN="JUSTIFY">are ‘startup.o’, ‘minstart.o’, ‘libvc.a’, ‘libvcs.a’, ‘libm.a’, ‘libms.a’ ‘libamiga.a’,</P>
<P ALIGN="JUSTIFY">‘libamigas.a’, ‘libauto.a’ and ‘libautos.a’.</P>
<P ALIGN="JUSTIFY">Note that ‘libextra.a’ is no longer part of the vbcc distribution. It was replaced by</P>
<P ALIGN="JUSTIFY">’PosixLib’, available on Aminet ‘dev/c/vbcc_PosixLib.lha’, which has a much more com-</P>
<P ALIGN="JUSTIFY">prehensive support for POSIX and Unix functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout</P>
<P ALIGN="JUSTIFY">and stderr. Then it runs all constructors of dynamically linked libraries, before entering the</P>
<P ALIGN="JUSTIFY">main program. The exit code runs all destructors of dynamically linked libraries, closes all</P>
<P ALIGN="JUSTIFY">open files and frees all memory. If you link with a math library the startup/exit code will</P>
<P ALIGN="JUSTIFY">be taken from there if necessary.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY">The math library (‘libm.a’) is linked against the  oating point library libmoto by Motorola.</P>
<P ALIGN="JUSTIFY">Depending on the CPU/FPU selected, #including ‘math.h’ will cause inline-code generated</P>
<P ALIGN="JUSTIFY">for certain math functions.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">There is no automatic stack extension for AmigaOS 4! This should be done automatically</P>
<P ALIGN="JUSTIFY">by the operating system.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model of the PPC series CPUs, you also have to link with ap-</P>
<P ALIGN="JUSTIFY">propriate libraries. Most libraries documented here are also available as small data versions</P>
<P ALIGN="JUSTIFY">(with an ’s’ attached to the file name). Exceptions are the math libraries.</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY"> 74</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lvcs -lamigas</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.5 Dynamic linking</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Since ‘elf.library’ V52.2 AmigaOS4 supports dynamic linking with shared object files</P>
<P ALIGN="JUSTIFY">(‘.so’ extension), similar to Unix. The default behaviour is to prefer linking against a shared</P>
<P ALIGN="JUSTIFY">object over a static library. To force static linking you might want to give the ‘-static’</P>
<P ALIGN="JUSTIFY">option to the ‘vc’ frontend.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.6 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because on AmigaOS it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
<P ALIGN="JUSTIFY">Small data in dynamically linked executables</P>
<P ALIGN="JUSTIFY">There is a bug in ‘elf.library’ V52.4 (and earlier), which doesn’t load .sdata</P>
<P ALIGN="JUSTIFY">and .sbss as a contiguous block into memory, when the executable requires</P>
<P ALIGN="JUSTIFY">dynamic linking. I decided against writing a workaround, as the bug should be</P>
<P ALIGN="JUSTIFY">fixed in OS4.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.7 libamiga.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">In contrast to other amigalibs the OS4 ‘libamiga.a’ doesn’t contain any stubs for calling</P>
<P ALIGN="JUSTIFY">system functions. AmigaOS 4 system calls are done through special macros in the SDK’s</P>
<P ALIGN="JUSTIFY">interface header files.</P>
<P ALIGN="JUSTIFY">The library only includes some remaining amigalib functions, not already integrated into</P>
<P ALIGN="JUSTIFY">the OS, like CreateIO(), but its use is discouraged.</P>
<P ALIGN="JUSTIFY">Specify ‘-lamiga’ to link with ‘libamiga.a’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.8 libauto.a</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Auto-open -close functions for the following libraries are included:</P>
<P ALIGN="JUSTIFY">Asl, CyberGfx, DataTypes, Dos, GadTools, Graphics, Icon, IFFParse, Intuition,</P>
<P ALIGN="JUSTIFY">Locale, LowLevel, Picasso96, BSDSocket, Utility, Workbench</P>
<P ALIGN="JUSTIFY">Note that gcc’s ‘libauto.a’ doesn’t include CyberGfx.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.9 newlib</P>
<P ALIGN="JUSTIFY">11.8.9.1 Introduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">newlib.library is a shared AmigaOS4 library, which is covered by several BSD like licenses,</P>
<P ALIGN="JUSTIFY">and includes standard ANSI and POSIX functions as well as some functions common in</P>
<P ALIGN="JUSTIFY">Unix, BSD and similar operating systems. It is part of the OS4 SDK.</P>
<P ALIGN="JUSTIFY">The config file ‘newlib’ will be created on installation to use the paths for header files and</P>
<P ALIGN="JUSTIFY">libraries pointing to the newlib from the SDK.</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">75</P>
<P ALIGN="JUSTIFY">What are the main di erences between vclib and newlib?</P>
<P ALIGN="JUSTIFY">- vclib contains (almost) only standard ANSI functions. If you want to port Unix pro-</P>
<P ALIGN="JUSTIFY">grams you will probably miss a lot of functions. Also newlib supports things like</P>
<P ALIGN="JUSTIFY">mapping Unix directory paths to Amiga paths or expanding wildcards in command</P>
<P ALIGN="JUSTIFY">lines automatically.</P>
<P ALIGN="JUSTIFY">- Programs compiled for newlib will be shorter because the code for all functions is not</P>
<P ALIGN="JUSTIFY">contained in the executable itself.</P>
<P ALIGN="JUSTIFY">- Programs compiled for newlib will need the shared object ‘libc.so’ present when</P>
<P ALIGN="JUSTIFY">started.</P>
<P ALIGN="JUSTIFY">- Programs compiled for newlib will probably need more memory because the entire</P>
<P ALIGN="JUSTIFY">(rather large) ‘libc.so’ will be loaded into memory. With vclib only the functions</P>
<P ALIGN="JUSTIFY">your program uses will be in ram. However if you have several programs using newlib</P>
<P ALIGN="JUSTIFY">at the same time only one copy of ‘libc.so’ should be loaded.</P>
<P ALIGN="JUSTIFY">Things you should note:</P>
<P ALIGN="JUSTIFY">- With newlib you do not need extra math-libraries.</P>
<P ALIGN="JUSTIFY">- You must link with a vbcc-specific ‘startup.o’ from the newlib ‘lib/’ directory as</P>
<P ALIGN="JUSTIFY">startup code. The config-file ‘newlib’ will usually take care of this.</P>
<P ALIGN="JUSTIFY">- You must use the newlib-includes from the SDK rather than the ones which are for</P>
<P ALIGN="JUSTIFY">vc.lib. The config-file ‘newlib’ will usually take care of this.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.8.9.2 Usage</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">To compile a program to use newlib for OS4 you must make sure the proper config-file</P>
<P ALIGN="JUSTIFY">(‘newlib’) is used, e.g.</P>
<P ALIGN="JUSTIFY">vc +newlib hello.c</P>
<P ALIGN="JUSTIFY">With a new SDK this will usually generate a dynamically linked executable, which requires</P>
<P ALIGN="JUSTIFY">‘libc.so’. To force a statically linked executable:</P>
<P ALIGN="JUSTIFY">vc +newlib -static hello.c</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9 Atari MiNT</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for MiNT, a multitasking operating system</P>
<P ALIGN="JUSTIFY">for Atari 16/32 bit computers. Executables linked with this C library do also run on plain</P>
<P ALIGN="JUSTIFY">TOS, without modifications. The relevant files are ‘startup.o’, ‘minstart.o’, ‘libvc.a’,</P>
<P ALIGN="JUSTIFY">‘libvcs.a’, ‘libm.a’, ‘libms.a’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout and</P>
<P ALIGN="JUSTIFY">stderr and returns the unneeded memory to the system. The exit code closes all open files</P>
<P ALIGN="JUSTIFY">and frees all memory.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY"> 76</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">At the moment (‘libm.a’) is a soft- oat library, which is compatible with all the Atari</P>
<P ALIGN="JUSTIFY">models without an FPU. There may be real FPU support in future updates.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The default stack size is 64k. There is a MiNT tool called ‘stack’ which can adjust the</P>
<P ALIGN="JUSTIFY">stack size of an executable to any value, by looking for a symbol named __stksize (defined</P>
<P ALIGN="JUSTIFY">by vclib’s startup code).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model, you also have to link with appropriate libraries. Most</P>
<P ALIGN="JUSTIFY">libraries documented here are also available as small data versions (with an ’s’ attached to</P>
<P ALIGN="JUSTIFY">the file name).</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lms -lvcs</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.9.5 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because under MiNT it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10 Atari TOS</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes specifics of the C library for Atari 16/32 bit computers (Atari ST/TT,</P>
<P ALIGN="JUSTIFY">Atari Falcon, etc.). The relevant files are ‘startup.o’, ‘minstart.o’, ‘libvc.a’, ‘libvcs.a’,</P>
<P ALIGN="JUSTIFY">‘libm.a’, ‘libms.a’.</P>
<P ALIGN="JUSTIFY">This target di ers from Atari MiNT, as it uses 16 bit int data types. int arguments on</P>
<P ALIGN="JUSTIFY">the stack are also passed in 2 bytes. Therefore you should use the 16 bit aware vbccm68ks</P>
<P ALIGN="JUSTIFY">compiler.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10.1 Startup</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The startup code ‘startup.o’ sets up some global variables and initializes stdin, stdout and</P>
<P ALIGN="JUSTIFY">stderr and returns the unneeded memory to the system. The exit code closes all open files</P>
<P ALIGN="JUSTIFY">and frees all memory.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10.2 Floating point</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note that you have to link with a math library if you want to use  oating point. All math</P>
<P ALIGN="JUSTIFY">functions, special startup code and printf/scanf functions which support  oating point are</P>
<P ALIGN="JUSTIFY">contained in the math libraries only.</P>
<P ALIGN="JUSTIFY">At the moment (‘libm.a’) is a soft- oat library, which is compatible with all the Atari</P>
<P ALIGN="JUSTIFY">models without an FPU. There may be real FPU support in future updates.</P>
<P ALIGN="JUSTIFY"> Chapter 11: C Library</P>
<P ALIGN="JUSTIFY">77</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10.3 Stack</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Stack-handling is similar to AmigaOS/68k (See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 11.4.3 [amiga-stack], page 67</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). The</P>
<P ALIGN="JUSTIFY">default stack size is 4k.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10.4 Small data model</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">When using the small data model, you also have to link with appropriate libraries. Most</P>
<P ALIGN="JUSTIFY">libraries documented here are also available as small data versions (with an ’s’ attached to</P>
<P ALIGN="JUSTIFY">the file name).</P>
<P ALIGN="JUSTIFY">To compile and link a program using the small data model a command like</P>
<P ALIGN="JUSTIFY">vc test.c -o test -sd -lms -lvcs</P>
<P ALIGN="JUSTIFY">might be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">11.10.5 Restrictions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following list contains some restrictions of this version of the library:</P>
<P ALIGN="JUSTIFY">tmpfile()</P>
<P ALIGN="JUSTIFY">The tmpfile() function always returns an error.</P>
<P ALIGN="JUSTIFY">clock() The clock() function always returns -1. This is correct, according to the C</P>
<P ALIGN="JUSTIFY">standard, because under TOS it is not possible to obtain the time used by the</P>
<P ALIGN="JUSTIFY">calling process.</P>
<P ALIGN="JUSTIFY"> 78</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">79</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">12 List of Errors</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">0. "declaration expected" (Fatal, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Something is pretty wrong with the source.</P>
<P ALIGN="JUSTIFY">1. "only one input file allowed" (Fatal)</P>
<P ALIGN="JUSTIFY">vbcc accepts only a single filename to compile. You can use a frontend to compile</P>
<P ALIGN="JUSTIFY">multiple files or perhaps you mistyped an option.</P>
<P ALIGN="JUSTIFY">2. "Flag &lt;%s&gt; specified more than once" ()</P>
<P ALIGN="JUSTIFY">You specified a command line option that should be specified only once more than</P>
<P ALIGN="JUSTIFY">once. Maybe you have this option in your config-file and used it in the command line,</P>
<P ALIGN="JUSTIFY">too? The first occurrence will override the latter ones.</P>
<P ALIGN="JUSTIFY">3. "Flag &lt;%s&gt; needs string" (Fatal)</P>
<P ALIGN="JUSTIFY">This option hast to be specified with a string parameter, e.g. - ag=foobar</P>
<P ALIGN="JUSTIFY">4. "Flag &lt;%s&gt; needs value" (Fatal)</P>
<P ALIGN="JUSTIFY">This option hast to be specified with an integer parameter, e.g. - ag=1234</P>
<P ALIGN="JUSTIFY">5. "Unknown Flag &lt;%s&gt;" (Fatal)</P>
<P ALIGN="JUSTIFY">This option is not recognized by vbcc. Perhaps you mistyped it, used the wrong case</P>
<P ALIGN="JUSTIFY">or specified an option of the frontend to vbcc?</P>
<P ALIGN="JUSTIFY">6. "No input file" (Fatal)</P>
<P ALIGN="JUSTIFY">You did not specify an input file. Your source file should not start with a ’-’ and if you</P>
<P ALIGN="JUSTIFY">use a frontend make sure it has the proper su x.</P>
<P ALIGN="JUSTIFY">7. "Could not open &lt;%s&gt; for input" (Fatal)</P>
<P ALIGN="JUSTIFY">A file could not be opened.</P>
<P ALIGN="JUSTIFY">8. "need a struct or union to get a member" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The source contains something like a.b where a is not a structure or union.</P>
<P ALIGN="JUSTIFY">9. "too many (%d) nested blocks" (Fatal, Error)</P>
<P ALIGN="JUSTIFY">vbcc only allows a maximum number of nested blocks (compund-statements). You can</P>
<P ALIGN="JUSTIFY">increase this number by changing the line #define MAXN &lt;something&gt; in vbc.h and</P>
<P ALIGN="JUSTIFY">recompiling vbcc.</P>
<P ALIGN="JUSTIFY">10. "left block 0" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">This error should not occur.</P>
<P ALIGN="JUSTIFY">11. "incomplete struct &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to get a member of an incomplete structure/union. You defined struct x y;</P>
<P ALIGN="JUSTIFY">somewhere without defining struct x{...}.</P>
<P ALIGN="JUSTIFY">12. "out of memory" (Fatal, Error)</P>
<P ALIGN="JUSTIFY">Guess what.</P>
<P ALIGN="JUSTIFY">13. "redeclaration of struct &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You may not redeclare a struct/union in the same block.</P>
<P ALIGN="JUSTIFY">14. "incomplete type (%s) in struct" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Every member in a struct/union declaration must be complete. Perhaps you only</P>
<P ALIGN="JUSTIFY">wanted a pointer to that type and forgot the ’*’?</P>
<P ALIGN="JUSTIFY"> 80</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">15. "function (%s) in struct/union" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Functions cannot be members of structs/unions.</P>
<P ALIGN="JUSTIFY">16. "redeclaration of struct/union member &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Two members of a struct/union have the same name.</P>
<P ALIGN="JUSTIFY">17. "redeclaration of &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You used a name already in use in an enumeration.</P>
<P ALIGN="JUSTIFY">18. "invalid constant expression" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">??? Nowhere to find...</P>
<P ALIGN="JUSTIFY">19. "array dimension must be constant integer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The dimensions of an array must be constants (real constants, const int x=100; int</P>
<P ALIGN="JUSTIFY">y[x]; is not allowed) and integers (int y[100.0]; is not allowed either).</P>
<P ALIGN="JUSTIFY">20. "no declarator and no identifier in prototype" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">21. "invalid storage-class in prototype" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Function parameters may only be auto or register.</P>
<P ALIGN="JUSTIFY">22. "void not the only function argument" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to declare a function that has an argument of type void as well as other</P>
<P ALIGN="JUSTIFY">arguments.</P>
<P ALIGN="JUSTIFY">23. "&lt;%s&gt; no member of struct/union" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The struct/union does not contain a member called like that.</P>
<P ALIGN="JUSTIFY">24. "increment/decrement is only allowed for aithmetic and pointer types" (Error, ANSI-</P>
<P ALIGN="JUSTIFY">violation)</P>
<P ALIGN="JUSTIFY">25. "functions may not return arrays or functions" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">26. "only pointers to functions can be called" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to call something that did not decay into a pointer to a function.</P>
<P ALIGN="JUSTIFY">27. "redefinition of var &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">28. "redeclaration of var &lt;%s&gt; with new storage-class" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">29. "first operand of conditional-expression must be arithmetic or pointer type" (Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">30. "multiple definitions of var &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There have been multiple definitions of a global variable with initialization.</P>
<P ALIGN="JUSTIFY">31. "operands of : do not match" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">In an expression of the form a ? b : c - a and b must have the same type or - a and</P>
<P ALIGN="JUSTIFY">b both must have arithmetic types or - one of them must be a pointer and the other</P>
<P ALIGN="JUSTIFY">must be void * or 0</P>
<P ALIGN="JUSTIFY">32. "function definition in inner block" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">C does not allow nested functions.</P>
<P ALIGN="JUSTIFY">33. "redefinition of function &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Defining two functions with the same name in one translation-unit is no good idea.</P>
<P ALIGN="JUSTIFY">34. "invalid storage-class for function" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Functions must not have storage-classes register or auto.</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">81</P>
<P ALIGN="JUSTIFY">35. "declaration-specifiers expected" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">36. "declarator expected" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">37. "&lt;%s&gt; is no parameter" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">In an old-style function definition you tried to declare a name as parameter which was</P>
<P ALIGN="JUSTIFY">not in the identifier-list.</P>
<P ALIGN="JUSTIFY">38. "assignment of di erent structs/unions" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">39. "invalid types for assignment" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">In an assignment-context (this includes passing arguments to prototyped functions)</P>
<P ALIGN="JUSTIFY">the source and target must be one of the following types:</P>
<P ALIGN="JUSTIFY">- both are arithmetic types - both are the same struct/union - one of them is a pointer</P>
<P ALIGN="JUSTIFY">to void and the other one is any pointer - the target is any pointer and the source is an</P>
<P ALIGN="JUSTIFY">integral constant-expression with the value 0 - both are pointer to the same type (here</P>
<P ALIGN="JUSTIFY">the target may have additional const/volatile qualifiers - not recursively, however)</P>
<P ALIGN="JUSTIFY">Any other combinations should be illegal.</P>
<P ALIGN="JUSTIFY">40. "only 0 can be compared against pointer" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You may not compare a pointer against any other constant but a 0 (null pointer).</P>
<P ALIGN="JUSTIFY">41. "pointers do not point to the same type" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to compare or assign pointers that point to di erent types. E.g. the types</P>
<P ALIGN="JUSTIFY">they point to may have di erent attributes.</P>
<P ALIGN="JUSTIFY">42. "function initialized" (Error, Fatal, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was a ’=’ after a function declaration.</P>
<P ALIGN="JUSTIFY">43. "initialization of incomplete struct" (Error, Fatal, ANSI-violation)</P>
<P ALIGN="JUSTIFY">A structure is incomplete if the only its name, but not the content is known. You</P>
<P ALIGN="JUSTIFY">cannot do much with such structures.</P>
<P ALIGN="JUSTIFY">44. "initialization of incomplete union" (Error, Fatal, ANSI-violation)</P>
<P ALIGN="JUSTIFY">A union is incomplete if the only its name, but not the content is known. You cannot</P>
<P ALIGN="JUSTIFY">do much with such unions.</P>
<P ALIGN="JUSTIFY">45. "empty initialization" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was no valid expression after the ’=’ in a variable definition.</P>
<P ALIGN="JUSTIFY">46. "initializer not a constant" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Static variables and compound types may only be initialized with constants. Variables</P>
<P ALIGN="JUSTIFY">with const qualifier are no valid constant-expressions here.</P>
<P ALIGN="JUSTIFY">Addresses of static variables are ok, but casting them may turn them into non-constant-</P>
<P ALIGN="JUSTIFY">expressions.</P>
<P ALIGN="JUSTIFY">47. "double type-specifier" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">48. "illegal type-specifier" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">49. "multiple storage-classes" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">50. "storage-class specifier should be first" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">51. "bitfields must be ints" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">52. "bitfield width must be constant integer" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY"> 82</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">53. "struct/union member needs identifier" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">54. "; expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Probably you forgot a ’;’ or there is a syntactic error in an expression.</P>
<P ALIGN="JUSTIFY">55. "struct/union has no members" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You defined an empty struct or union.</P>
<P ALIGN="JUSTIFY">56. "} expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">57. ", expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">58. "invalid unsigned" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">59. ") expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">60. "array dimension has sidefx (will be ignored)" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">61. "array of size 0 (set to 1)" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">ANSI C does not allow arrays or any objects to have a size of 0.</P>
<P ALIGN="JUSTIFY">62. "] expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">63. "mixed identifier- and parameter-type-list" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">64. "var &lt;%s&gt; was never assigned a value" (Warning)</P>
<P ALIGN="JUSTIFY">65. "var &lt;%s&gt; was never used" (Warning)</P>
<P ALIGN="JUSTIFY">66. "invalid storage-class" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">67. "type defaults to int" (Warning)</P>
<P ALIGN="JUSTIFY">68. "redeclaration of var &lt;%s&gt; with new type" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">69. "redeclaration of parameter &lt;%s&gt;" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">70. ": expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">71. "illegal escape-sequence in string" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">72. "character constant contains multiple chars" (Warning)</P>
<P ALIGN="JUSTIFY">73. "could not evaluate sizeof-expression" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">74. "" expected (unterminated string)" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">75. "something wrong with numeric constant" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">76. "identifier expected" (Fatal, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">77. "definition does not match previous declaration" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">78. "integer added to illegal pointer" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">79. "o set equals size of object" (Warning)</P>
<P ALIGN="JUSTIFY">80. "o set out of object" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">81. "only 0 should be cast to pointer" (Warning)</P>
<P ALIGN="JUSTIFY">82. "unknown identifier &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">83. "too few function arguments" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">84. "division by zero (result set to 0)" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">85. "assignment of di erent pointers" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">86. "lvalue required for assignment" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">87. "assignment to constant type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">88. "assignment to incomplete type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">83</P>
<P ALIGN="JUSTIFY">89. "operands for || and &amp;&amp; have to be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">90. "bitwise operations need integer operands" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">91. "assignment discards const" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You assigned something like (const type *) to (type *).</P>
<P ALIGN="JUSTIFY">92. "relational expression needs arithmetic or pointer type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">93. "both operands of comparison must be pointers" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You wrote an expression like a == b where one operand was a pointer while the other</P>
<P ALIGN="JUSTIFY">was not. Perhaps a function is not declared correctly or you used NULL instead of 0?</P>
<P ALIGN="JUSTIFY">94. "operand needs arithmetic type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">95. "pointer arithmetic with void * is not possible" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Adding/subtracting from a pointer to void is not possible.</P>
<P ALIGN="JUSTIFY">96. "pointers can only be subtracted" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You cannot add, multiply etc. two pointers.</P>
<P ALIGN="JUSTIFY">97. "invalid types for operation &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">98. "invalid operand type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">99. "integer-pointer is not allowed" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You may not subtract a pointer from an integer. Adding an integer or subtracting it</P>
<P ALIGN="JUSTIFY">from a pointer is ok.</P>
<P ALIGN="JUSTIFY">100. "assignment discards volatile" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You assigned something like (volatile type *) to (type *).</P>
<P ALIGN="JUSTIFY">101. "&lt;&lt;, &gt;&gt; and % need integer operands" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">102. "casting from void is not allowed" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Casting something of type void to anything makes no sense.</P>
<P ALIGN="JUSTIFY">103. "integer too large to fit into pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to assign an integer to a pointer that is too small to hold the integer. Note</P>
<P ALIGN="JUSTIFY">that assignment of pointers&lt;-&gt;integers is never portable.</P>
<P ALIGN="JUSTIFY">104. "only integers can be cast to pointers" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">105. "invalid cast" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">106. "pointer too large to fit into integer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to assign a pointer to an integer that is too small to hold the pointer. Note</P>
<P ALIGN="JUSTIFY">that assignment of pointers&lt;-&gt;integers is never portable.</P>
<P ALIGN="JUSTIFY">107. "unary operator needs arithmetic type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">108. "negation type must be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">109. "complement operator needs integer type" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">110. "pointer assignment with di erent qualifiers" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to assign a pointer to a pointer that points to a type with di erent qualifiers</P>
<P ALIGN="JUSTIFY">(e.g. signed&lt;-&gt;unsigned).</P>
<P ALIGN="JUSTIFY">111. "dereferenced object is no pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">112. "dereferenced object is incomplete" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You tried to dereference a pointer to an incomplete object. Either you had a pointer to</P>
<P ALIGN="JUSTIFY">an array of unknown size or a pointer to a struct or union that was not (yet) defined.</P>
<P ALIGN="JUSTIFY"> 84</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">113. "only 0 should be assigned to pointer" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You may not assign constants other than a null pointer to any pointer.</P>
<P ALIGN="JUSTIFY">114. "typedef &lt;%s&gt; is initialized" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">115. "lvalue required to take address" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">You can only get the address of an object, but not of expressions etc.</P>
<P ALIGN="JUSTIFY">116. "unknown var &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">117. "address of register variables not available" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">If a variable is declared as ’register’ its address may not be taken (no matter if the</P>
<P ALIGN="JUSTIFY">variable actually gets assigned to a register).</P>
<P ALIGN="JUSTIFY">118. "var &lt;%s&gt; initialized after ’extern’" (Warning)</P>
<P ALIGN="JUSTIFY">119. "const var &lt;%s&gt; not initialized" (Warning)</P>
<P ALIGN="JUSTIFY">A constant variable was not initialized in its definition. As there is no other legal way</P>
<P ALIGN="JUSTIFY">to assign a value to a constant variable this is probable an error.</P>
<P ALIGN="JUSTIFY">120. "function definition after ’extern’" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">121. "return type of main is not int" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">main() should be defined as</P>
<P ALIGN="JUSTIFY">int main(int argc, char **argv)</P>
<P ALIGN="JUSTIFY">Especially the return type of main must be ’int’ - ’void’ is not allowed by ANSI C.</P>
<P ALIGN="JUSTIFY">122. "invalid storage-class for function parameter" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Function parameters may only have ’auto’ or ’register’ as storage-class. ’static’ or</P>
<P ALIGN="JUSTIFY">’extern’ are not allowed.</P>
<P ALIGN="JUSTIFY">123. "formal parameters con ict with parameter-type-list" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">124. "parameter type defaults to int" (Warning)</P>
<P ALIGN="JUSTIFY">A function definition contains no explicit type specifier. ’int’ will be assumed.</P>
<P ALIGN="JUSTIFY">125. "no declaration-specifier, used int" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">A variable was declared/defined without a type specified. This is not allowed in ANSI</P>
<P ALIGN="JUSTIFY">C (apart from functions).</P>
<P ALIGN="JUSTIFY">126. "no declarator in prototype" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">127. "static var &lt;%s&gt; never defined" (Warning)</P>
<P ALIGN="JUSTIFY">128. "} expected" (Warning)</P>
<P ALIGN="JUSTIFY">129. "left operand of comma operator has no side-e ects" (Warning)</P>
<P ALIGN="JUSTIFY">In an expression of the form a,b a has no side-e ects and is therefore super uous.</P>
<P ALIGN="JUSTIFY">130. "label empty" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was a ’:’ without an identifier before it.</P>
<P ALIGN="JUSTIFY">131. "redefinition of label &lt;%s&gt;" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The label was defined more than once in the same function. Consider that labels can</P>
<P ALIGN="JUSTIFY">not be hidden in inner blocks.</P>
<P ALIGN="JUSTIFY">132. "case without switch" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">A case label was found outside of any switch-statements.</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">85</P>
<P ALIGN="JUSTIFY">133. "case-expression must be constant" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after ’case’ must be constant.</P>
<P ALIGN="JUSTIFY">134. "case-expression must be integer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after ’case’ must be integer.</P>
<P ALIGN="JUSTIFY">135. "empty if-expression" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was no valid expression after ’if’.</P>
<P ALIGN="JUSTIFY">136. "if-expression must be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after ’if’ must be arithmetic (i.e. an integer or  oating point type) or</P>
<P ALIGN="JUSTIFY">a pointer.</P>
<P ALIGN="JUSTIFY">137. "empty switch-expression" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was no valid expression after ’switch’.</P>
<P ALIGN="JUSTIFY">138. "switch-expression must be integer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after ’switch’ must be an integer.</P>
<P ALIGN="JUSTIFY">139. "multiple default labels" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was more than one default label in a switch-statement.</P>
<P ALIGN="JUSTIFY">140. "while-expression must be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after the ’while’ must be arithmetic (i.e. an integer or  oating point</P>
<P ALIGN="JUSTIFY">type) or a pointer.</P>
<P ALIGN="JUSTIFY">141. "empty while-expression" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There was no valid expression after ’while’.</P>
<P ALIGN="JUSTIFY">142. "for-expression must be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression inside the ’for’ must be arithmetic (i.e. an integer or  oating point</P>
<P ALIGN="JUSTIFY">type) or a pointer.</P>
<P ALIGN="JUSTIFY">143. "do-while–expression must be arithmetic or pointer" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The expression after the ’while’ must be arithmetic (i.e. an integer or  oating point</P>
<P ALIGN="JUSTIFY">type) or a pointer.</P>
<P ALIGN="JUSTIFY">144. "goto without label" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">’goto’ must be followed by a label.</P>
<P ALIGN="JUSTIFY">145. "continue not within loop" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">’continue’ is only allowed inside of loops. Perhaps there are unbalanced ’{’ ’}’.</P>
<P ALIGN="JUSTIFY">146. "break not in matching construct" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">’break’ is only allowed inside of loops or switch-statements. Perhaps there are unbal-</P>
<P ALIGN="JUSTIFY">anced ’{’ ’}’.</P>
<P ALIGN="JUSTIFY">147. "label &lt;%s&gt; was never defined" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">There is a goto to a label that was never defined.</P>
<P ALIGN="JUSTIFY">148. "label &lt;%s&gt; was never used" (Warning)</P>
<P ALIGN="JUSTIFY">You defined a label, but there is no goto that jumps to it.</P>
<P ALIGN="JUSTIFY">149. "register %s not ok" (Warning)</P>
<P ALIGN="JUSTIFY">There was an internal error (i.e. a bug in the compiler)! Please report the error to</P>
<P ALIGN="JUSTIFY">vb@compilers.de. Thanks!</P>
<P ALIGN="JUSTIFY"> 86</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">150. "default not in switch" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">A default label that is not in any switch-statement was found. Perhaps there are</P>
<P ALIGN="JUSTIFY">unbalanced ’{’ ’}’.</P>
<P ALIGN="JUSTIFY">151. "( expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">152. "loop eliminated" (Warning)</P>
<P ALIGN="JUSTIFY">There was a loop that will never be executed (e.g. while(0)...) and therefore the entire</P>
<P ALIGN="JUSTIFY">loop was eliminated. I do not know any reason for such loops, so there is probably an</P>
<P ALIGN="JUSTIFY">error.</P>
<P ALIGN="JUSTIFY">153. "statement has no e ect" (Warning)</P>
<P ALIGN="JUSTIFY">There is a statement that does not cause any side-e ects (e.g. assignments, function</P>
<P ALIGN="JUSTIFY">calls etc.) and is therefore super uous. E.g. you might have typed a==b; instead of</P>
<P ALIGN="JUSTIFY">a=b;</P>
<P ALIGN="JUSTIFY">154. "’while’ expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The ’while’ in a do-while loop is missing.</P>
<P ALIGN="JUSTIFY">155. "function should not return a value" (Warning)</P>
<P ALIGN="JUSTIFY">You specified an argument to return although the function is void. Declare the function</P>
<P ALIGN="JUSTIFY">as non-void.</P>
<P ALIGN="JUSTIFY">156. "function should return a value" (Warning)</P>
<P ALIGN="JUSTIFY">You did not specify an argument to return although the function is not void. Declare</P>
<P ALIGN="JUSTIFY">the function as void or specify a return value.</P>
<P ALIGN="JUSTIFY">157. "{ expected" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">158. "internal error %d in line %d of file %s !!" (Fatal, Error)</P>
<P ALIGN="JUSTIFY">There was an internal error (i.e. a bug in the compiler)! Please report the error to</P>
<P ALIGN="JUSTIFY">vb@compilers.de. Thanks!</P>
<P ALIGN="JUSTIFY">159. "there is no message number %d" (Fatal)</P>
<P ALIGN="JUSTIFY">You tried to activate or suppress a message that does not exist.</P>
<P ALIGN="JUSTIFY">160. "message number %d cannot be suppressed" (Fatal)</P>
<P ALIGN="JUSTIFY">You cannot suppress a message that displays a real error, ANSI-violation or another</P>
<P ALIGN="JUSTIFY">real problem. Only ’harmless’ warnings can be suppressed.</P>
<P ALIGN="JUSTIFY">161. "implicit declaration of function &lt;%s&gt;" (Warning)</P>
<P ALIGN="JUSTIFY">A function was called before it was declared and therefore implicitly declared as</P>
<P ALIGN="JUSTIFY">int function();</P>
<P ALIGN="JUSTIFY">This should be avoided in new programs.</P>
<P ALIGN="JUSTIFY">162. "function call without prototype in scope" (Warning)</P>
<P ALIGN="JUSTIFY">When writing new programs it is probably sensible to use prototypes for every function.</P>
<P ALIGN="JUSTIFY">If a function is called without a prototype in scope this may cause incorrect type</P>
<P ALIGN="JUSTIFY">conversions and is usually an error.</P>
<P ALIGN="JUSTIFY">163. "#pragma used" (Warning)</P>
<P ALIGN="JUSTIFY">Usage of #pragma should be avoided in portable programs.</P>
<P ALIGN="JUSTIFY">164. "assignment in comparison context" (Warning)</P>
<P ALIGN="JUSTIFY">The expression in an if-, for-, while- or do-while-statement is an assignment, e.g.</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">87</P>
<P ALIGN="JUSTIFY">if(i=0)...</P>
<P ALIGN="JUSTIFY">This could an error, if you wanted if(i==0). If you turned on this warning and want</P>
<P ALIGN="JUSTIFY">it to shut up for a certain expression you can cast it to its type, e.g.</P>
<P ALIGN="JUSTIFY">if((int)(i=0))...</P>
<P ALIGN="JUSTIFY">Note that only assignments with ’=’ will be warned, not ’+=’ etc.</P>
<P ALIGN="JUSTIFY">165. "comparison redundant because operand is unsigned" (Warning)</P>
<P ALIGN="JUSTIFY">A comparison with an unsigned variable is redundant, because the result will always</P>
<P ALIGN="JUSTIFY">be constant, e.g.</P>
<P ALIGN="JUSTIFY">unsigned int i; if(i&lt;0)...</P>
<P ALIGN="JUSTIFY">This usually is a programming error and can be avoided in all cases.</P>
<P ALIGN="JUSTIFY">166. "cast to narrow type may cause loss of precision" (Warning)</P>
<P ALIGN="JUSTIFY">A variable is cast to a type smaller than its original type, so that some information</P>
<P ALIGN="JUSTIFY">may get lost. However this warning will be displayed in lots of cases where no problem</P>
<P ALIGN="JUSTIFY">can arise, e.g. (short)(a==b).</P>
<P ALIGN="JUSTIFY">167. "pointer cast may cause alignment problems" (Warning)</P>
<P ALIGN="JUSTIFY">A pointer is cast to a pointer to a type with stricter alignment requirements, i.e. the</P>
<P ALIGN="JUSTIFY">new pointer might be invalid if you do not know what you are doing. Those casts</P>
<P ALIGN="JUSTIFY">should be avoidable in all ’usual’ cases.</P>
<P ALIGN="JUSTIFY">168. "no declaration of global variable &lt;%s&gt; before definition" (Warning)</P>
<P ALIGN="JUSTIFY">It is usually good to declare all global variables (including functions) in header files.</P>
<P ALIGN="JUSTIFY">169. "’extern’ inside function" (Warning)</P>
<P ALIGN="JUSTIFY">Declaration of external variables in inner blocks is usually not a good idea.</P>
<P ALIGN="JUSTIFY">170. "dead assignment to &lt;%s&gt; eliminated" (Warning)</P>
<P ALIGN="JUSTIFY">A variable is assigned a value that is never used or gets overwritten before it is used.</P>
<P ALIGN="JUSTIFY">If this occurs in real code then there is either an errror or an unnecessary assignment.</P>
<P ALIGN="JUSTIFY">This is detected only in optimizing compilation.</P>
<P ALIGN="JUSTIFY">171. "var &lt;%s&gt; is used before defined" (Warning)</P>
<P ALIGN="JUSTIFY">The variable is used before it was assigned a value and therefore is undefined. It cannot</P>
<P ALIGN="JUSTIFY">be detected if the code where it is used can be reached, but if it is reached it will cause</P>
<P ALIGN="JUSTIFY">undefined behaviour. So it is most probably an error either way (see 170).</P>
<P ALIGN="JUSTIFY">However not all unitialized usages can be found.</P>
<P ALIGN="JUSTIFY">Also note that the compiler may choose convenient values for uninitialized variables.</P>
<P ALIGN="JUSTIFY">Example:</P>
<P ALIGN="JUSTIFY">int f(int a) { int x; if(a) x=0; return(x); }</P>
<P ALIGN="JUSTIFY">Here the optimizer may choose that x==0 if it is uninitialized and then only generate</P>
<P ALIGN="JUSTIFY">a return(0); It can also happen that you get di erent values if you read an uninitialized</P>
<P ALIGN="JUSTIFY">variable twice although it was not assigned a value inbetween.</P>
<P ALIGN="JUSTIFY">This is only detected in optimizing compilation.</P>
<P ALIGN="JUSTIFY">172. "would need more than %ld optimizer passes for best results" (Warning)</P>
<P ALIGN="JUSTIFY">The optimizer would probably be able to do some further optimizations if you increased</P>
<P ALIGN="JUSTIFY">the number of allowed passes with the -optpasses=n option.</P>
<P ALIGN="JUSTIFY"> 88</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">173. "function &lt;%s&gt; has no return statement" (Warning)</P>
<P ALIGN="JUSTIFY">A non-void function has no return statement. Either this function never returns (then</P>
<P ALIGN="JUSTIFY">better declare it as void) or it reaches end of control which would be an error.</P>
<P ALIGN="JUSTIFY">As main() cannot be declared as void you will not be warned if main has no return</P>
<P ALIGN="JUSTIFY">statement. If you want a warning for main, too, you can turn on warning 174.</P>
<P ALIGN="JUSTIFY">174. "function &lt;main&gt; has no return statement" (Warning)</P>
<P ALIGN="JUSTIFY">The same like 173 for main, so you can turn it on/o  separately.</P>
<P ALIGN="JUSTIFY">175. "this code is weird" (Warning)</P>
<P ALIGN="JUSTIFY">The code has a very strange control  ow. There is probably a jump inside a loop or</P>
<P ALIGN="JUSTIFY">something similar and the optimizer will not make any loop optimization and perhaps</P>
<P ALIGN="JUSTIFY">worse register allocation on this construct. There must be goto statements in the</P>
<P ALIGN="JUSTIFY">source.</P>
<P ALIGN="JUSTIFY">This warning is only detected in optimizing compilation.</P>
<P ALIGN="JUSTIFY">176. "size of incomplete type not available" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">An incomplete type must not be the argument for sizeof.</P>
<P ALIGN="JUSTIFY">177. "line too long" (FATAL, Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">178. "identifier must begin with a letter or underscore" (FATAL, Error, ANSI-violation,</P>
<P ALIGN="JUSTIFY">Preprocessor)</P>
<P ALIGN="JUSTIFY">179. "cannot redefine macro" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">180. "missing ) after argumentlist" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">181. "identifier expected" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">182. "illegal character in identifier" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">183. "missing operand before/after ##" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">184. "no macro-argument after #-operator" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">185. "macro redefinition not allowed" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">186. "unexpected end of file (unterminated comment)" (FATAL, Error, Preprocessor)</P>
<P ALIGN="JUSTIFY">187. "too many nested includes" (FATAL, Error, Preprocessor)</P>
<P ALIGN="JUSTIFY">188. "#else without #if/#ifdef/#ifndef" (FATAL, Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">189. "#else after #else" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">190. "#endif without #if" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">191. "cannot include file" (FATAL, Error, Preprocessor)</P>
<P ALIGN="JUSTIFY">192. "expected \" or &lt; in #include-directive" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">193. "unknown #-directive" (Warning, Preprocessor)</P>
<P ALIGN="JUSTIFY">194. "wrong number of macro arguments" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">195. "macro argument expected" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">196. "out of memory" (FATAL, Error, Preprocessor)</P>
<P ALIGN="JUSTIFY">197. "macro redefinition" (Warning, Preprocessor)</P>
<P ALIGN="JUSTIFY">198. "/* in comment" (Warning, Preprocessor)</P>
<P ALIGN="JUSTIFY">199. "cannot undefine macro" (Error, ANSI-violation, Preprocessor)</P>
<P ALIGN="JUSTIFY">200. "characters after #-directive ignored" (Warning, Preprocessor)</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">89</P>
<P ALIGN="JUSTIFY">201. "duplicate case labels" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Each case-label in a switch-statement must have a distinct constant value attached</P>
<P ALIGN="JUSTIFY">(after converting it to the type of the switch-expression).</P>
<P ALIGN="JUSTIFY">202. "var &lt;%s&gt; is incomplete" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">An incomplete var was defined. probably you wrote something like:</P>
<P ALIGN="JUSTIFY">int a[];</P>
<P ALIGN="JUSTIFY">203. "long  oat is no longer valid" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">’long  oat’ was a synonym for double in K&amp;R C, but this is no longer allowed in ANSI</P>
<P ALIGN="JUSTIFY">C.</P>
<P ALIGN="JUSTIFY">204. "long double is not really supported by vbcc" (Warning)</P>
<P ALIGN="JUSTIFY">vbcc does not know about long double yet and therefore will use it simply as a synonym</P>
<P ALIGN="JUSTIFY">for double. This should not break any legal code, but you will not get error messages</P>
<P ALIGN="JUSTIFY">if you e.g. assign a pointer to double to a pointer to long double.</P>
<P ALIGN="JUSTIFY">205. "empty struct-declarations are not yet handled correct" (Warning)</P>
<P ALIGN="JUSTIFY">obsolete</P>
<P ALIGN="JUSTIFY">206. "identifier too long (only %d characters are significant)" (Warning)</P>
<P ALIGN="JUSTIFY">207. "illegal initialization of var &lt;%s&gt;" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Perhaps you tried to initialize a variable with external linkage in an inner block.</P>
<P ALIGN="JUSTIFY">208. "suspicious loop" (Warning)</P>
<P ALIGN="JUSTIFY">vbcc thinks a loop-condition looks suspicious. A possible example could be</P>
<P ALIGN="JUSTIFY">for(i=0;i!=7;i+=2)</P>
<P ALIGN="JUSTIFY">209. "ansi/iso-mode turned on" (Warning)</P>
<P ALIGN="JUSTIFY">You turned on the ANSI/ISO-conforming mode. This warning is always displayed</P>
<P ALIGN="JUSTIFY">unless it is suppressed. So vbcc cannot be blamed to miss a diagnostic for any constraint</P>
<P ALIGN="JUSTIFY">violation. :-)</P>
<P ALIGN="JUSTIFY">210. "division by zero (result set to 0)" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">Similar to warning 84.</P>
<P ALIGN="JUSTIFY">211. "constant out of range" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">An integral constant is too large to fit into an unsigned long.</P>
<P ALIGN="JUSTIFY">212. "constant is unsigned due to size" (Warning)</P>
<P ALIGN="JUSTIFY">If an integral constant is so large that it cannot be represented as long its type is</P>
<P ALIGN="JUSTIFY">promoted to unsigned long.</P>
<P ALIGN="JUSTIFY">213. "varargs function called without prototype in scope" (Warning)</P>
<P ALIGN="JUSTIFY">A function which takes a variable number of arguments must not be called without a</P>
<P ALIGN="JUSTIFY">prototype in scope. E.g. calling printf() without #include &lt;stdio.h&gt; may cause this</P>
<P ALIGN="JUSTIFY">warning.</P>
<P ALIGN="JUSTIFY">214. "suspicious format string" (Warning)</P>
<P ALIGN="JUSTIFY">The format-string of a printf-/scan ike function seems to be corrupt or not matching</P>
<P ALIGN="JUSTIFY">the type of the arguments.</P>
<P ALIGN="JUSTIFY">215. "format string contains \’\\0\’" (Warning)</P>
<P ALIGN="JUSTIFY">The format string for a printf-/scan ike function contains an embedded ’\0’ character.</P>
<P ALIGN="JUSTIFY"> 90</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">216. "illegal use of keyword &lt;%s&gt;" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">The reserved keywords of C may not be used as identifier.</P>
<P ALIGN="JUSTIFY">217. "register &lt;%s&gt; used with wrong type" (Error)</P>
<P ALIGN="JUSTIFY">218. "register &lt;%s&gt; is not free" (Error)</P>
<P ALIGN="JUSTIFY">219. "’ reg’ used in old-style function definition" (Warning)</P>
<P ALIGN="JUSTIFY">220. "unknown register \"%s\"" (Warning)</P>
<P ALIGN="JUSTIFY">221. "’...’ only allowed with prototypes" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">222. "Hey, do you really know the priority of ’&amp;&amp;’ vs. ’||’?" (Warning)</P>
<P ALIGN="JUSTIFY">223. "be careful with priorities of &lt;&lt;/&gt;&gt; vs. +/-" (Warning)</P>
<P ALIGN="JUSTIFY">224. "adress of auto variable returned" (Warning)</P>
<P ALIGN="JUSTIFY">225. "void function returns a void expression" (Warning)</P>
<P ALIGN="JUSTIFY">226. "redeclaration of typedef &lt;%s&gt;" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">227. "multiple specification of attribute \"%s\"" (Warning)</P>
<P ALIGN="JUSTIFY">228. "redeclaration of var \"%s\" with di ering setting of attribute \"%s\"" (Warning)</P>
<P ALIGN="JUSTIFY">229. "string-constant expected" (Error)</P>
<P ALIGN="JUSTIFY">230. "tag \"%s\" used for wrong type" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">231. "member after  exible array member" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">232. "illegal number" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">233. "void character constant" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">234. "spurious tail in octal character constant" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">235. "spurious tail in hexadecimal character constant" (Preprocessor, Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">236. "illegal escape sequence in character constant" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">237. "invalid constant integer value" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">238. "a right parenthesis was expected" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">239. "a colon was expected" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">240. "truncated constant integral expression" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">241. "rogue operator ’%s’ in constant integral expression" (Preprocessor, Error, ANSI-</P>
<P ALIGN="JUSTIFY">violation)</P>
<P ALIGN="JUSTIFY">242. "invalid token in constant integral expression" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">243. "trailing garbage in constant integral expression" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">244. "void condition for a #if/#elif" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">245. "void condition (after expansion) for a #if/#elif" (Preprocessor, Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">246. "invalid ’#include’" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">247. "macro expansion did not produce a valid filename for #include" (Preprocessor, Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">248. "file ’%s’ not found" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">249. "not a valid number for #line" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">91</P>
<P ALIGN="JUSTIFY">250. "not a valid filename for #line" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">251. "rogue ’#’" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">252. "rogue #else" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">253. "rogue #elif" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">254. "unmatched #endif" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">255. "unknown cpp directive ’#%s’" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">256. "unterminated #if construction" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">257. "could not  ush output (disk full ?)" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">258. "truncated token" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">259. "illegal character ’%c’" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">260. "unfinished string at end of line" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">261. "missing macro name" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">262. "trying to redefine the special macro %s" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">263. "truncated macro definition" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">264. "’...’ must end the macro argument list" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">265. "void macro argument" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">266. "missing comma in macro argument list" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">267. "invalid macro argument" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">268. "duplicate macro argument" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">269. "’ VA ARGS ’ is forbidden in macros with a fixed number of arguments" (Prepro-</P>
<P ALIGN="JUSTIFY">cessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">270. "operator ’##’ may neither begin nor end a macro" (Preprocessor, Error, ANSI-</P>
<P ALIGN="JUSTIFY">violation)</P>
<P ALIGN="JUSTIFY">271. "operator ’#’ not followed by a macro argument" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">272. "macro ’%s’ redefined unidentically" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">273. "not enough arguments to macro" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">274. "unfinished macro call" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">275. "too many argument to macro" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">276. "operator ’##’ produced the invalid token ’%s%s’" (Preprocessor, Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">277. "quad sharp" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">278. "void macro name" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">279. "macro %s already defined" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">280. "trying to undef special macro %s" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">281. "illegal macro name for #ifdef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">282. "unfinished #ifdef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">283. "illegal macro name for #undef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">284. "unfinished #undef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">285. "illegal macro name for #ifndef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY"> 92</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">286. "unfinished #ifndef" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">287. "reconstruction of &lt;foo&gt; in #include" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">288. "comment in the middle of a cpp directive" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">289. "null cpp directive" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">290. "rogue ’#’ in code compiled out" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">291. "rogue ’#’ dumped" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">292. "#error%s" (Preprocessor, ANSI-violation, Error)</P>
<P ALIGN="JUSTIFY">293. "trigraph ?""?%c encountered" (Preprocessor, Warning)</P>
<P ALIGN="JUSTIFY">294. "unterminated #if construction (depth %ld)" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">295. "malformed identifier with UCN: ’%s’" (Preprocessor, Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">296. "truncated UTF-8 character" (Preprocessor, Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">297. "identifier not followed by whitespace in #define" (Preprocessor, Warning, ANSI-</P>
<P ALIGN="JUSTIFY">violation)</P>
<P ALIGN="JUSTIFY">298. "assignment discards restrict" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">299. "storage-class in declaration within for() converted to auto" (Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">300. "corrupted special object" (ANSI-violation, Fatal)</P>
<P ALIGN="JUSTIFY">301. "&lt;inline&gt; only allowed in function declarations" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">302. "reference to static variable &lt;%s&gt; in inline function with external linkage" (Error,</P>
<P ALIGN="JUSTIFY">ANSI-violation)</P>
<P ALIGN="JUSTIFY">303. "under ow of pragma popwarn" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">304. "invalid argument to Pragma" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">305. "missing comma before ’...’" (Preprocessor, Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">306. "padding bytes behind member &lt;%s&gt;" (Warning)</P>
<P ALIGN="JUSTIFY">307. "member &lt;%s&gt; does not have natural alignment" (Warning)</P>
<P ALIGN="JUSTIFY">308. "function &lt;%s&gt; exceeds %s limit" (Warning)</P>
<P ALIGN="JUSTIFY">309. "%s could not be calculated for function &lt;%s&gt;" (Warning)</P>
<P ALIGN="JUSTIFY">310. "o setof applied to non-struct" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">311. "trailing garbage in #ifdef" (Preprocessor, Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">312. "too many arguments to macro" (Preprocessor, Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">313. "truncated comment" (Preprocessor, Warning|ANSI-violation)</P>
<P ALIGN="JUSTIFY">314. "trailing garbage in preprocessing directive" (Preprocessor, Warning, ANSI-violation)</P>
<P ALIGN="JUSTIFY">315. "variable-length array must have auto storage-class" (Error, ANSI-violation)</P>
<P ALIGN="JUSTIFY">316. "member &lt;%s&gt; has type with zero alignment/size (probably void)" (Error, ANSI-</P>
<P ALIGN="JUSTIFY">violation, Fatal)</P>
<P ALIGN="JUSTIFY">317. "stack information for target &lt;%s&gt; unavailable" (Warning)</P>
<P ALIGN="JUSTIFY">318. "used registers information unavailable for target &lt;%s&gt;" (Warning)</P>
<P ALIGN="JUSTIFY">319. "computed %sstack usage %d but set to %d" (Warning)</P>
<P ALIGN="JUSTIFY">320. "unable to compute call targets" (Warning)</P>
<P ALIGN="JUSTIFY">321. "computed register usage di ers from specified one" (Warning)</P>
<P ALIGN="JUSTIFY"> Chapter 12: List of Errors</P>
<P ALIGN="JUSTIFY">93</P>
<P ALIGN="JUSTIFY">322. "trailing garbage in #include" (Preprocessor, Warning ,ANSI-violation)</P>
<P ALIGN="JUSTIFY">323. "target-warning: %s" (Warning)</P>
<P ALIGN="JUSTIFY">324. "target-error: %s" (Error)</P>
<P ALIGN="JUSTIFY"> 94</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">95</P>
</FONT><FONT SIZE=5><P ALIGN="JUSTIFY">13 Backend Interface</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.1 Introduction</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This chapter is under construction!</P>
<P ALIGN="JUSTIFY">This chapter describes some of the internals of vbcc and tries to explain what has to be</P>
<P ALIGN="JUSTIFY">done to write a code generator for vbcc. However if someone wants to write one, I suggest</P>
<P ALIGN="JUSTIFY">to contact me first, so that it can be integrated into the source tree.</P>
<P ALIGN="JUSTIFY">You have to create a new directory for the new target named ‘machines/&lt;target-name&gt;’</P>
<P ALIGN="JUSTIFY">and write the files ‘machine.c’, ‘machine.h’ and ‘machine.dt’. The compiler for this target</P>
<P ALIGN="JUSTIFY">will be called vbcc&lt;target-name&gt; and can be built doing a make TARGET=&lt;target-name&gt;</P>
<P ALIGN="JUSTIFY">bin/vbcc&lt;target-name&gt;.</P>
<P ALIGN="JUSTIFY">From now on integer means any of char, short, int, long, long long or their unsigned</P>
<P ALIGN="JUSTIFY">couterparts. Arithmetic means integer or float or double or long double. Elementary</P>
<P ALIGN="JUSTIFY">type means arithmetic or pointer.</P>
<P ALIGN="JUSTIFY">Note that this documentation may mention explicit values when introducing symbolic con-</P>
<P ALIGN="JUSTIFY">stants. This is due to copying and pasting from the source code. These values may not be</P>
<P ALIGN="JUSTIFY">up to date and in some cases can be overridden. Therefore do never use the absolute values</P>
<P ALIGN="JUSTIFY">but rather the symbolic representations.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2 Building vbcc</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section deals with the steps necessary to build the typical vbcc executables from the</P>
<P ALIGN="JUSTIFY">sources.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.1 Directory Structure</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The vbcc-directory contains the following important files and directories:</P>
<P ALIGN="JUSTIFY">‘vbcc/’ The main directory containing the compiler sources.</P>
<P ALIGN="JUSTIFY">‘vbcc/Makefile’</P>
<P ALIGN="JUSTIFY">The Makefile used to build vbcc.</P>
<P ALIGN="JUSTIFY">‘vbcc/frontend/’</P>
<P ALIGN="JUSTIFY">Directory containing the source to vc, the compiler driver.</P>
<P ALIGN="JUSTIFY">‘vbcc/machines/&lt;target&gt;/’</P>
<P ALIGN="JUSTIFY">Directory for the &lt;target&gt; backend.</P>
<P ALIGN="JUSTIFY">‘vbcc/machines/ucpp/’</P>
<P ALIGN="JUSTIFY">Directory containing the builtin preprocessor.</P>
<P ALIGN="JUSTIFY">‘vbcc/vsc/’</P>
<P ALIGN="JUSTIFY">Directory containing source to vsc, the instruction scheduler.</P>
<P ALIGN="JUSTIFY">‘vbcc/bin/’</P>
<P ALIGN="JUSTIFY">Directory the executables will be placed in.</P>
<P ALIGN="JUSTIFY">All compiling is done from the main directory. The frontend vc is not target-dependend</P>
<P ALIGN="JUSTIFY">and therefore only one version is created.</P>
<P ALIGN="JUSTIFY"> 96</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Every available target has at least one subdirectory with its name in ‘vbcc/machines’</P>
<P ALIGN="JUSTIFY">and contains at least the files ‘machine.h’, ‘machine.c’ and ‘machine.dt’. Target-specific</P>
<P ALIGN="JUSTIFY">object-files will also be stored in that directory.</P>
<P ALIGN="JUSTIFY">The executables will be placed in ‘vbcc/bin/’. The main compiler will be called</P>
<P ALIGN="JUSTIFY">vbcc&lt;target&gt;.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.2 Adapting the Makefile</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Before building anything you have to insert correct values for CC, NCC, LDFLAGS and</P>
<P ALIGN="JUSTIFY">NLDFLAGS in the ‘Makefile’.</P>
<P ALIGN="JUSTIFY">CC Here you have to insert a command that invokes an ANSI C compiler you want</P>
<P ALIGN="JUSTIFY">to use to build vbcc. It must support ‘-D’, ‘-I’, ‘-c’ and ‘-o’ the same like e.g.</P>
<P ALIGN="JUSTIFY">vc or gcc. Additional options should also be inserted here. E.g. if you are</P>
<P ALIGN="JUSTIFY">compiling for the Amiga with vbcc you should add ‘-DAMIGA’.</P>
<P ALIGN="JUSTIFY">LDFLAGS Here you have to add options which are necessary for linking. E.g. some</P>
<P ALIGN="JUSTIFY">compilers need special libraries for  oating-point.</P>
<P ALIGN="JUSTIFY">NCC</P>
<P ALIGN="JUSTIFY">NLDFLAGS These are similar to CC and LDFLAGS but they must always describe a native</P>
<P ALIGN="JUSTIFY">compiler, i.e. Programs compiled with NCC/NLDFLAGS must be executable on</P>
<P ALIGN="JUSTIFY">the host system. This is needed because during the build programs may have</P>
<P ALIGN="JUSTIFY">to be executed on the host.</P>
<P ALIGN="JUSTIFY">An example for the Amiga using vbcc would be:</P>
<P ALIGN="JUSTIFY">CC = vc -DAMIGA -c99</P>
<P ALIGN="JUSTIFY">LDFLAGS = -lmieee</P>
<P ALIGN="JUSTIFY">NCC = $(CC)</P>
<P ALIGN="JUSTIFY">NLDFLAGS = $(LDFLAGS)</P>
<P ALIGN="JUSTIFY">An example for a typical Unix-installation would be:</P>
<P ALIGN="JUSTIFY">CC = cc</P>
<P ALIGN="JUSTIFY">LDFLAGS = -lm</P>
<P ALIGN="JUSTIFY">NCC = $(CC)</P>
<P ALIGN="JUSTIFY">NLDFLAGS = $(LDFLAGS)</P>
<P ALIGN="JUSTIFY">The following settings are probably necessary for Open/Free/Any BSD i386 systems:</P>
<P ALIGN="JUSTIFY">CC = gcc -D_ANSI_SOURCE</P>
<P ALIGN="JUSTIFY">LDFLAGS = -lm</P>
<P ALIGN="JUSTIFY">NCC = $(CC)</P>
<P ALIGN="JUSTIFY">NLDFLAGS = $(LDFLAGS)</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.3 Building vc</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Note to users of Open/Free/Any BSD i386 systems: You will probably have to use GNU</P>
<P ALIGN="JUSTIFY">make instead of BSD make, i.e. in the following examples replace "make" with "gmake".</P>
<P ALIGN="JUSTIFY">Type:</P>
<P ALIGN="JUSTIFY">make bin/vc</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">97</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.4 Building vsc</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Type:</P>
<P ALIGN="JUSTIFY">make TARGET=&lt;target&gt; bin/vsc&lt;target&gt;</P>
<P ALIGN="JUSTIFY">For example:</P>
<P ALIGN="JUSTIFY">make TARGET=alpha bin/vscalpha</P>
<P ALIGN="JUSTIFY">Omit this step if there is no file ‘machines/&lt;target&gt;/schedule.c’.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.5 Building vbcc</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Type:</P>
<P ALIGN="JUSTIFY">make TARGET=&lt;target&gt; bin/vbcc&lt;target&gt;</P>
<P ALIGN="JUSTIFY">For example:</P>
<P ALIGN="JUSTIFY">make TARGET=alpha bin/vbccalpha</P>
<P ALIGN="JUSTIFY">During the build the program dtgen will be generated and executed on the host-system.</P>
<P ALIGN="JUSTIFY">First it will ask you whether you are building a cross-compiler.</P>
<P ALIGN="JUSTIFY">Answer y only if you are building a cross-compiler (i.e. a compiler which does not produce</P>
<P ALIGN="JUSTIFY">code for the same machine it it running on).</P>
<P ALIGN="JUSTIFY">Note that it does not matter if you are cross-building a compiler, i.e. if you are running</P>
<P ALIGN="JUSTIFY">on system A and building a B-&gt;B compiler by using an A-&gt;B compiler then you can answer</P>
<P ALIGN="JUSTIFY">n.</P>
<P ALIGN="JUSTIFY">If you answered y you will be asked if your system/compiler o ers certain datatypes. This</P>
<P ALIGN="JUSTIFY">refers to the compiler you described with CC in the Makefile. E.g. if CC is an A-&gt;B cross-</P>
<P ALIGN="JUSTIFY">compiler you have to answer the questions according to B. To each question answer y or</P>
<P ALIGN="JUSTIFY">n depending if such a datatype is available on that compiler. If you answered y you have</P>
<P ALIGN="JUSTIFY">to type in the name of that type on the compiler (e.g. signed int, unsigned char etc.).</P>
<P ALIGN="JUSTIFY">If there are not enough datatypes available to build vbcc an error message will be printed</P>
<P ALIGN="JUSTIFY">and the build aborts.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.6 Configuring</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Consult the vbcc-documentation for information on how to create the necessary config-files.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.2.7 Building Cross-Compilers</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">As there is often confusion when it comes to cross-building compilers or building cross-</P>
<P ALIGN="JUSTIFY">compilers, here is what has to be done to cross-build a B-&gt;C cross-compiler on system A</P>
<P ALIGN="JUSTIFY">with only a native A-&gt;A compiler available.</P>
<P ALIGN="JUSTIFY">This is done by first building an A-&gt;B compiler and then cross-building the B-&gt;C compiler</P>
<P ALIGN="JUSTIFY">using the A-&gt;B compiler.</P>
<P ALIGN="JUSTIFY">For the first step you use the A-&gt;A compiler for CC as well as NCC. Now you type:</P>
<P ALIGN="JUSTIFY">make bin/vc</P>
<P ALIGN="JUSTIFY">make TARGET=B bin/vscB # omit if there is no machines/B/schedule.c</P>
<P ALIGN="JUSTIFY">make TARGET=B bin/vbccB</P>
<P ALIGN="JUSTIFY">The questions about datatypes are answered according to A. Then you should write a</P>
<P ALIGN="JUSTIFY">‘vc.config’ for the vbccB cross-compiler.</P>
<P ALIGN="JUSTIFY"> 98</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Now create a second directory containing all the sources to vbcc and set CC/LDFLAGS to vc</P>
<P ALIGN="JUSTIFY">using the config-file for vbccB and NCC/NLDFLAGS to the A-&gt;A compiler. Type:</P>
<P ALIGN="JUSTIFY">make bin/vc</P>
<P ALIGN="JUSTIFY">make TARGET=C bin/vscC # omit if there is no machines/C/schedule.c</P>
<P ALIGN="JUSTIFY">make TARGET=C bin/vbccC</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3 The Intermediate Code</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">vbcc will generate intermediate code for every function and pass this code to the code</P>
<P ALIGN="JUSTIFY">generator which has to convert it into the desired output.</P>
<P ALIGN="JUSTIFY">In the future there may be a code generator generator which reads a machine description</P>
<P ALIGN="JUSTIFY">file and generates a code generator from that, but it is not clear whether this could simplify</P>
<P ALIGN="JUSTIFY">much without taking penalties in the generated code. Anyway, this would be a layer on</P>
<P ALIGN="JUSTIFY">top of the current interface to the code generator, so that the interface described in this</P>
<P ALIGN="JUSTIFY">document would still be valid and accessible.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3.1 General Format</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The intermediate code is represented as a doubly linked list of quadruples (I am calling</P>
<P ALIGN="JUSTIFY">them ICs from now on) consisting mainly of an operator, two source operands and a target.</P>
<P ALIGN="JUSTIFY">They are represented like this:</P>
<P ALIGN="JUSTIFY">struct IC{</P>
<P ALIGN="JUSTIFY">struct IC *prev;</P>
<P ALIGN="JUSTIFY">struct IC *next;</P>
<P ALIGN="JUSTIFY">int code;</P>
<P ALIGN="JUSTIFY">int typf;</P>
<P ALIGN="JUSTIFY">int typf2;</P>
<P ALIGN="JUSTIFY">[...]</P>
<P ALIGN="JUSTIFY">struct obj q1;</P>
<P ALIGN="JUSTIFY">struct obj q2;</P>
<P ALIGN="JUSTIFY">struct obj z;</P>
<P ALIGN="JUSTIFY">[...]</P>
<P ALIGN="JUSTIFY">struct ext_ic ext; /* optional */</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">The only members relevant to the code generator are prev, next, code, typf, typf2,</P>
<P ALIGN="JUSTIFY">q1, q2, z and (optionally) ext_ic.</P>
<P ALIGN="JUSTIFY">prev and next are pointers to the previous and next IC. The first IC has prev==0 and the</P>
<P ALIGN="JUSTIFY">last one has next==0.</P>
<P ALIGN="JUSTIFY">typf and typf2 are the type of the operands of this IC. In most ICs all operands have the</P>
<P ALIGN="JUSTIFY">same type and therefore only typf is used. However, some ICs have operands of di erent</P>
<P ALIGN="JUSTIFY">types (e.g. converting an operand to another type or adding an integer to a pointer). typf2</P>
<P ALIGN="JUSTIFY">is used in these cases.</P>
<P ALIGN="JUSTIFY">Macros are provided which yield the type of an operand. q1typ(), q2typ() and ztyp()</P>
<P ALIGN="JUSTIFY">return the type of the first source operand, the second source operand and the destination,</P>
<P ALIGN="JUSTIFY">respectively. They have to be passed a pointer to a valid IC as argument. The results are</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">99</P>
<P ALIGN="JUSTIFY">undefined if the IC does not contain the specified operand (e.g. q2typ() for an IC with</P>
<P ALIGN="JUSTIFY">only a single operand).</P>
<P ALIGN="JUSTIFY">The standard types which are defined by default are:</P>
<P ALIGN="JUSTIFY">#define CHAR</P>
<P ALIGN="JUSTIFY">#define SHORT</P>
<P ALIGN="JUSTIFY">#define INT</P>
<P ALIGN="JUSTIFY">#define LONG</P>
<P ALIGN="JUSTIFY">#define LLONG</P>
<P ALIGN="JUSTIFY">#define FLOAT</P>
<P ALIGN="JUSTIFY">#define DOUBLE</P>
<P ALIGN="JUSTIFY">#define LDOUBLE</P>
<P ALIGN="JUSTIFY">#define VOID</P>
<P ALIGN="JUSTIFY">#define POINTER</P>
<P ALIGN="JUSTIFY">#define ARRAY</P>
<P ALIGN="JUSTIFY">#define STRUCT</P>
<P ALIGN="JUSTIFY">#define UNION</P>
<P ALIGN="JUSTIFY">#define ENUM /* not relevant for code generator */</P>
<P ALIGN="JUSTIFY">#define FUNKT</P>
<P ALIGN="JUSTIFY">and can be additionally or’ed by</P>
<P ALIGN="JUSTIFY">#define UNSIGNED</P>
<P ALIGN="JUSTIFY">#define CONST</P>
<P ALIGN="JUSTIFY">#define VOLATILE</P>
<P ALIGN="JUSTIFY">#define UNCOMPLETE</P>
<P ALIGN="JUSTIFY">However, only UNSIGNED is of real importance for the code generator. typf&amp;NQ yields the</P>
<P ALIGN="JUSTIFY">type without any qualifiers, typf&amp;NU yields the type without any qualifiers but UNSIGNED.</P>
<P ALIGN="JUSTIFY">It is possible for backends to define additional types. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.8 [exttypes], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">for documentation on how to extend the type system.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3.2 Operands</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">q1, q2 and z are the source1 (quelle1 in German), source2 and target (ziel) operands,</P>
<P ALIGN="JUSTIFY">respectively. If a result has to be computed, it always will be stored in the object z and</P>
<P ALIGN="JUSTIFY">the objects q1 and q2 usually may not be destroyed during this operation (unless they are</P>
<P ALIGN="JUSTIFY">aliased with the destination).</P>
<P ALIGN="JUSTIFY">The objects are described by this structure:</P>
<P ALIGN="JUSTIFY">struct obj{</P>
<P ALIGN="JUSTIFY">int flags;</P>
<P ALIGN="JUSTIFY">int reg;</P>
<P ALIGN="JUSTIFY">int dtyp;</P>
<P ALIGN="JUSTIFY">struct Var *v;</P>
<P ALIGN="JUSTIFY">struct AddressingMode *am;</P>
<P ALIGN="JUSTIFY">union atyps{</P>
<P ALIGN="JUSTIFY">zchar vchar;</P>
<P ALIGN="JUSTIFY">zchar vuchar;</P>
<P ALIGN="JUSTIFY">zshort vshort;</P>
<P ALIGN="JUSTIFY"> 100</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">zushort vushort;</P>
<P ALIGN="JUSTIFY">zint vint;</P>
<P ALIGN="JUSTIFY">zuint vuint;</P>
<P ALIGN="JUSTIFY">zlong vlong;</P>
<P ALIGN="JUSTIFY">zulong vulong;</P>
<P ALIGN="JUSTIFY">zllong vllong;</P>
<P ALIGN="JUSTIFY">zullong vullong;</P>
<P ALIGN="JUSTIFY">zmax vmax;</P>
<P ALIGN="JUSTIFY">zumax vumax;</P>
<P ALIGN="JUSTIFY">zfloat vfloat;</P>
<P ALIGN="JUSTIFY">zdouble vdouble;</P>
<P ALIGN="JUSTIFY">zldouble vldouble;</P>
<P ALIGN="JUSTIFY">} val;</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">flags specifies the kind of object. It can be a combination of</P>
<P ALIGN="JUSTIFY">#define KONST 1</P>
<P ALIGN="JUSTIFY">The object is a constant. Its value is in the corresponding (to typf or typf2)</P>
<P ALIGN="JUSTIFY">member of val.</P>
<P ALIGN="JUSTIFY">#define VAR 2</P>
<P ALIGN="JUSTIFY">The object is a variable. The pointer to its struct Var is in v. val.vlong von-</P>
<P ALIGN="JUSTIFY">tains an o set that has to be added to it. Fur further details, see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.3</P>
<P ALIGN="JUSTIFY">[Variables], page 101</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">#define DREFOBJ 32</P>
<P ALIGN="JUSTIFY">The content of the location in memory the object points to is used. dtyp</P>
<P ALIGN="JUSTIFY">contains the type of the pointer. In systems with only one pointer type, this</P>
<P ALIGN="JUSTIFY">will always be POINTER.</P>
<P ALIGN="JUSTIFY">#define REG 64</P>
<P ALIGN="JUSTIFY">The object is a register. reg contains its number.</P>
<P ALIGN="JUSTIFY">#define VARADR 128</P>
<P ALIGN="JUSTIFY">The address of the object is to be used. Only together with static variables (i.e.</P>
<P ALIGN="JUSTIFY">storage_class == STATIC or EXTERN).</P>
<P ALIGN="JUSTIFY">The possible combinations of these  ags should be:</P>
<P ALIGN="JUSTIFY">• 0 (no object)</P>
<P ALIGN="JUSTIFY">• KONST</P>
<P ALIGN="JUSTIFY">• KONST|DREFOBJ</P>
<P ALIGN="JUSTIFY">• REG</P>
<P ALIGN="JUSTIFY">• VAR</P>
<P ALIGN="JUSTIFY">• VAR|REG</P>
<P ALIGN="JUSTIFY">• REG|DREFOBJ</P>
<P ALIGN="JUSTIFY">• KONST|DREFOBJ</P>
<P ALIGN="JUSTIFY">• VAR|DREFOBJ</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">101</P>
<P ALIGN="JUSTIFY">• VAR|REG|DREFOBJ</P>
<P ALIGN="JUSTIFY">• VAR|VARADR</P>
<P ALIGN="JUSTIFY">Also some other bits which are not relevant to the code generator may be set.</P>
<P ALIGN="JUSTIFY">Constants will usually be in q2 if possible. One of the sources always is not constant and</P>
<P ALIGN="JUSTIFY">the target is always an lvalue. The types of the operands can be queried using the macros</P>
<P ALIGN="JUSTIFY">q1typ(), q2typ() and ztyp(). In most cases (i.e. when not explicitly stated) the type is</P>
<P ALIGN="JUSTIFY">an elementary type (i.e. arithmetic or pointer).</P>
<P ALIGN="JUSTIFY">am can be used to store information on special addressing modes. This has to be han-</P>
<P ALIGN="JUSTIFY">dled by the by the code generator. However am has to be 0 or has to point to a struct</P>
<P ALIGN="JUSTIFY">AddressingMode that was allocated using malloc() when the code generator returns.</P>
<P ALIGN="JUSTIFY">struct AddressingMode has to be defined in ‘machine.h’.</P>
<P ALIGN="JUSTIFY">val stores either the value of the object if it is a constant or an o set if it is a variable.</P>
<P ALIGN="JUSTIFY">code specifies the operation. Fur further details see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.5 [operations], page 104</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3.3 Variables</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A struct Var looks like:</P>
<P ALIGN="JUSTIFY">struct Var{</P>
<P ALIGN="JUSTIFY">int storage_class;</P>
<P ALIGN="JUSTIFY">[...]</P>
<P ALIGN="JUSTIFY">char *identifier;</P>
<P ALIGN="JUSTIFY">[...]</P>
<P ALIGN="JUSTIFY">zmax offset;</P>
<P ALIGN="JUSTIFY">struct Typ *vtyp;</P>
<P ALIGN="JUSTIFY">[...]</P>
<P ALIGN="JUSTIFY">char *vattr;</P>
<P ALIGN="JUSTIFY">unsigned long tattr; /* optional */</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">The relevant entries are:</P>
<P ALIGN="JUSTIFY">identifier</P>
<P ALIGN="JUSTIFY">The name of the variable. Usually only of interest for variables with external-</P>
<P ALIGN="JUSTIFY">linkage.</P>
<P ALIGN="JUSTIFY">storage_class</P>
<P ALIGN="JUSTIFY">One of:</P>
<P ALIGN="JUSTIFY">#define AUTO 1</P>
<P ALIGN="JUSTIFY">#define REGISTER 2</P>
<P ALIGN="JUSTIFY">#define STATIC 3</P>
<P ALIGN="JUSTIFY">#define EXTERN 4</P>
<P ALIGN="JUSTIFY">#define TYPEDEF 5 /* not relevant */</P>
<P ALIGN="JUSTIFY">The backend should use the macros isauto(), isstatic() and isextern()</P>
<P ALIGN="JUSTIFY">to check which category a variable falls into.</P>
<P ALIGN="JUSTIFY">offset Contains an o set relative to the beginning of the variable’s storage. Used, for</P>
<P ALIGN="JUSTIFY">example, when accessing members of structures.</P>
<P ALIGN="JUSTIFY"> 102</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">vtyp The type of the variable (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.4 [compositetypes], page 102</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">vattr A string with attributes used in the declaration of the variable. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 13.9.6 [targetattributes], page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">for further details.</P>
<P ALIGN="JUSTIFY">tattr Flags used when declaring the variable. See</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.6 [targetattributes],</P>
<P ALIGN="JUSTIFY">page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">for further details.</P>
<P ALIGN="JUSTIFY">If the variable is not assigned to a register (i.e. bit REG is not set in the  ags of the</P>
<P ALIGN="JUSTIFY">corresponding struct obj) then the variable can be addressed in the following ways (with</P>
<P ALIGN="JUSTIFY">examples of 68k-code):</P>
<P ALIGN="JUSTIFY">isauto(storage_class) != 0</P>
<P ALIGN="JUSTIFY">offset contains the o set inside the local-variables section. The code generator</P>
<P ALIGN="JUSTIFY">must decide how it’s going to handle the activation record. If offset &lt; 0 then</P>
<P ALIGN="JUSTIFY">the variable is a function argument on the stack. In this case the o set in the</P>
<P ALIGN="JUSTIFY">parameter-area is - (offset + maxalign).</P>
<P ALIGN="JUSTIFY">The code generator may have to calculate the actual o set to a stack- or frame-</P>
<P ALIGN="JUSTIFY">pointer from the value in offset.</P>
<P ALIGN="JUSTIFY">offset + val.vlong(sp)</P>
<P ALIGN="JUSTIFY">Note that storage_class == REGISTER is equivalent to AUTO - whether the</P>
<P ALIGN="JUSTIFY">variable is actually assigned a register is specified by the bit REG in the flags</P>
<P ALIGN="JUSTIFY">of the struct obj.</P>
<P ALIGN="JUSTIFY">isextern(storage_class) != 0</P>
<P ALIGN="JUSTIFY">The variable can be addressed through its name in identifier.</P>
<P ALIGN="JUSTIFY">val.vlong + ’_’identifier</P>
<P ALIGN="JUSTIFY">isstatic(storage_class) != 0</P>
<P ALIGN="JUSTIFY">The variable can be addressed through a numbered label. The label number is</P>
<P ALIGN="JUSTIFY">stored in offset.</P>
<P ALIGN="JUSTIFY">val.vlong+’l’offset</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3.4 Composite Types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The C language o ers types which are composed out of other types, e.g. structures or</P>
<P ALIGN="JUSTIFY">arrays. Therefore, a C type can be an arbitrarily complex structure. Usually the backend</P>
<P ALIGN="JUSTIFY">does not need to deal with those structures. The ICs contain only the simple type  ags,</P>
<P ALIGN="JUSTIFY">e.g. INT or STRUCT, but not the members of a structure (instead the size is given).</P>
<P ALIGN="JUSTIFY">Most backends do not have to deal with complex types at all, but there are some ways to ac-</P>
<P ALIGN="JUSTIFY">cess them, if needed (for example, they may be needed when generating debug information).</P>
<P ALIGN="JUSTIFY">Therefore, this chapter describes the representation of such full types.</P>
<P ALIGN="JUSTIFY">Types are represented by the following structure:</P>
<P ALIGN="JUSTIFY">struct Typ {</P>
<P ALIGN="JUSTIFY">int flags;</P>
<P ALIGN="JUSTIFY">struct Typ *next;</P>
<P ALIGN="JUSTIFY">struct struct_declaration *exact;</P>
<P ALIGN="JUSTIFY">zmax size;</P>
<P ALIGN="JUSTIFY">char *attr;</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">103</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">flags is the simple type as it is generally used in the backend. The meaning of the other</P>
<P ALIGN="JUSTIFY">members depends on flags. attr is an attribute that can be added to the type using the</P>
<P ALIGN="JUSTIFY">sytax __attr("...") (which is parsed like a type-qualifier, e.g. const). If several attributes</P>
<P ALIGN="JUSTIFY">are specified for a type, the strings will be concatenated, separated by semi-colons.</P>
<P ALIGN="JUSTIFY">If the type is a pointer (ISPOINTER(flags) != 0), then next will point to the type the</P>
<P ALIGN="JUSTIFY">pointer points to.</P>
<P ALIGN="JUSTIFY">If the type is an array (ISARRAY(flags) != 0), then size contains the number of elements</P>
<P ALIGN="JUSTIFY">and next points to a type structure representing the type of each array element.</P>
<P ALIGN="JUSTIFY">If the type is a structure (ISSTRUCT(flags) != 0), a union (ISUNION(flags) != 0) or a</P>
<P ALIGN="JUSTIFY">function (ISFUNC(flags) != 0), then exact is a pointer to a struct_declaration (which</P>
<P ALIGN="JUSTIFY">is also used to represent unions and function prototypes) that looks like this:</P>
<P ALIGN="JUSTIFY">struct struct_declaration {</P>
<P ALIGN="JUSTIFY">int count;</P>
<P ALIGN="JUSTIFY">int label;</P>
<P ALIGN="JUSTIFY">int typ;</P>
<P ALIGN="JUSTIFY">...</P>
<P ALIGN="JUSTIFY">struct struct_list (*sl)[];</P>
<P ALIGN="JUSTIFY">char *identifier;</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">count is the number of members, label can be used to store a label when generating</P>
<P ALIGN="JUSTIFY">debug information. typ is either STRUCT, UNION or FUNKT to denote whether it applies to a</P>
<P ALIGN="JUSTIFY">structure, union or function-prototype.</P>
<P ALIGN="JUSTIFY">identifier is only available for struct- and union-tags.</P>
<P ALIGN="JUSTIFY">sl points to an array of struct struct_lists which contain information on each mem-</P>
<P ALIGN="JUSTIFY">ber/parameter:</P>
<P ALIGN="JUSTIFY">struct struct_list {</P>
<P ALIGN="JUSTIFY">char *identifier;</P>
<P ALIGN="JUSTIFY">struct Typ *styp;</P>
<P ALIGN="JUSTIFY">zmax align;</P>
<P ALIGN="JUSTIFY">int bfoffset;</P>
<P ALIGN="JUSTIFY">int bfsize;</P>
<P ALIGN="JUSTIFY">int storage_class;</P>
<P ALIGN="JUSTIFY">int reg;</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">identifier is the identifier of the member/parameter, if available. styp denotes the full</P>
<P ALIGN="JUSTIFY">type, align the alignment in bytes (only for struct/union), bfoffset and bfsize the size</P>
<P ALIGN="JUSTIFY">and o set of bitfield-members, storage_class the storage class of function parameters</P>
<P ALIGN="JUSTIFY">(may be AUTO or REGISTER) and reg denotes the register a parameter is passed in.</P>
<P ALIGN="JUSTIFY">Example: If struct Typ *t points to a structure-type, then the type of the second structure</P>
<P ALIGN="JUSTIFY">member can be accessed through (*t-&gt;exact-&gt;sl)[1].styp.</P>
<P ALIGN="JUSTIFY">A prototyped function will have a last argument of type VOID unless it is a function accepting</P>
<P ALIGN="JUSTIFY">a variable number of arguments. If a function was declared without a prototype it will have</P>
<P ALIGN="JUSTIFY"> 104</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">no parameters, a function declared with prototype accepting no arguments will have one</P>
<P ALIGN="JUSTIFY">parameter of type VOID.</P>
<P ALIGN="JUSTIFY">Also, in the case of a function type, the next-member of a struct Typ points to the return</P>
<P ALIGN="JUSTIFY">type of the function.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.3.5 Operations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section lists all the di erent operations allowed in the intermediate code passed to the</P>
<P ALIGN="JUSTIFY">backend. It lists the symbolic name of the code value (the value should not be used), a</P>
<P ALIGN="JUSTIFY">template of the operands and a description. The description sometimes contains internals</P>
<P ALIGN="JUSTIFY">(e.g. which types are stored in typf and which in typf2), but they should not be used.</P>
<P ALIGN="JUSTIFY">Access them using the macros provided (e.g. q1typ,q2typ,ztyp) whenever possible.</P>
<P ALIGN="JUSTIFY">#define ASSIGN 2</P>
<P ALIGN="JUSTIFY">Copy q1 to z. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">q2.val.vmax contains the size of the objects (this is necessary if it is an array</P>
<P ALIGN="JUSTIFY">or a struct). It should be accessed using the opsize()-macro. typf does not</P>
<P ALIGN="JUSTIFY">have to be an elementary type!</P>
<P ALIGN="JUSTIFY">The only case where typf == ARRAY should be in automatic initializations.</P>
<P ALIGN="JUSTIFY">It is also possible that (typf&amp;NQ) == CHAR but the size is != 1. This is created</P>
<P ALIGN="JUSTIFY">for an inline memcpy/strcpy where the type is not known.</P>
<P ALIGN="JUSTIFY">#define OR 16</P>
<P ALIGN="JUSTIFY">#define XOR 17</P>
<P ALIGN="JUSTIFY">#define AND 18</P>
<P ALIGN="JUSTIFY">Bitwise boolean operations. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">All operands are integers.</P>
<P ALIGN="JUSTIFY">#define LSHIFT 25</P>
<P ALIGN="JUSTIFY">#define RSHIFT 26</P>
<P ALIGN="JUSTIFY">Bit shifting. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">’q2’ is the number of shifts. All operands are integers.</P>
<P ALIGN="JUSTIFY">#define ADD 27</P>
<P ALIGN="JUSTIFY">#define SUB 28</P>
<P ALIGN="JUSTIFY">#define MULT 29</P>
<P ALIGN="JUSTIFY">#define DIV 30</P>
<P ALIGN="JUSTIFY">Standard arithmetic operations. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">All operands are of arithmetic types (integers or  oating point).</P>
<P ALIGN="JUSTIFY">#define MOD 31</P>
<P ALIGN="JUSTIFY">Modulo (%). q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">All operands are integers.</P>
<P ALIGN="JUSTIFY">#define KOMPLEMENT 33</P>
<P ALIGN="JUSTIFY">Bitwise complement. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">All operands are integers.</P>
<P ALIGN="JUSTIFY">#define MINUS 38</P>
<P ALIGN="JUSTIFY">Unary minus. q1-&gt;z.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">105</P>
<P ALIGN="JUSTIFY">All operands are of arithmetic types (integers or  oating point).</P>
<P ALIGN="JUSTIFY">#define ADDRESS 40</P>
<P ALIGN="JUSTIFY">Get the address of an object. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">z is always a pointer and q1 is always an auto variable.</P>
<P ALIGN="JUSTIFY">#define CALL 42</P>
<P ALIGN="JUSTIFY">Call the function q1. q1.</P>
<P ALIGN="JUSTIFY">q2.val.vmax contains the number of bytes pushed on the stack as function</P>
<P ALIGN="JUSTIFY">arguments for this call (use the pushedargsize()-macro to access this size).</P>
<P ALIGN="JUSTIFY">Those may have to be popped from the stack after the function returns depend-</P>
<P ALIGN="JUSTIFY">ing on the calling mechanism.</P>
<P ALIGN="JUSTIFY">A CALL IC has a member arg_cnt which contains the number of arguments to</P>
<P ALIGN="JUSTIFY">this function call. arg_list[i] (with i in the range 0...arg_cnt-1) contains</P>
<P ALIGN="JUSTIFY">the pointer to the IC passing the i-th argument.</P>
<P ALIGN="JUSTIFY">#define CONVERT 50</P>
<P ALIGN="JUSTIFY">Convert one type to another. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">z is always of the type typf, q1 of type typf2.</P>
<P ALIGN="JUSTIFY">Conversions between  oating point and pointers do not occur, neither do con-</P>
<P ALIGN="JUSTIFY">versions to and from structs, unions, arrays or void.</P>
<P ALIGN="JUSTIFY">#define ALLOCREG 65</P>
<P ALIGN="JUSTIFY">Allocate a register. q1.</P>
<P ALIGN="JUSTIFY">From now on the register q1.reg is in use. No code has to be generated for</P>
<P ALIGN="JUSTIFY">this, but it is probably useful to keep track of the registers in use to know</P>
<P ALIGN="JUSTIFY">which registers are available for the code generator at a certain time and which</P>
<P ALIGN="JUSTIFY">registers are trashed by the function.</P>
<P ALIGN="JUSTIFY">#define FREEREG 66</P>
<P ALIGN="JUSTIFY">Release a register. q1.</P>
<P ALIGN="JUSTIFY">From now on the register q1.reg is free.</P>
<P ALIGN="JUSTIFY">Also it means that the value currently stored in q1.reg is not used any more</P>
<P ALIGN="JUSTIFY">and provides a little bit of data  ow information. Note however, if a FREEREG</P>
<P ALIGN="JUSTIFY">follows a branch, the value of the register may be used at the target of the</P>
<P ALIGN="JUSTIFY">branch.</P>
<P ALIGN="JUSTIFY">#define COMPARE 77</P>
<P ALIGN="JUSTIFY">Compare and set condition codes. q1,q2(-&gt;z).</P>
<P ALIGN="JUSTIFY">Compare the operands and set the condition code, so that BEQ, BNE, BLT,</P>
<P ALIGN="JUSTIFY">BGE, BLE or BGT works as desired. If z.flags == 0 (this is always the case</P>
<P ALIGN="JUSTIFY">unless the backend sets multiple_ccs to 1 and ‘-no-multiple-ccs’ is not</P>
<P ALIGN="JUSTIFY">used) the condition codes will be evaluated only by an IC immediately following</P>
<P ALIGN="JUSTIFY">the COMPARE, i.e. the next instruction (except possible FREEREGs) will be a</P>
<P ALIGN="JUSTIFY">conditional branch.</P>
<P ALIGN="JUSTIFY">However, if a target supports several condition code registers and sets the global</P>
<P ALIGN="JUSTIFY">variable multiple_ccs to 1, vbcc might use those registers and perform certain</P>
<P ALIGN="JUSTIFY">optimizations. In this case z may be non-empty and the condition codes have</P>
<P ALIGN="JUSTIFY">to be stored in z.</P>
<P ALIGN="JUSTIFY"> 106</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Note that even if multiple_ccs is set, a backend must nevertheless be able to</P>
<P ALIGN="JUSTIFY">deal with z == 0.</P>
<P ALIGN="JUSTIFY">#define TEST 68</P>
<P ALIGN="JUSTIFY">Test q1 against 0 and set condition codes. q1(-&gt;z)</P>
<P ALIGN="JUSTIFY">This is equivalent to COMPARE q1,#0 but only the condition code for BEQ and</P>
<P ALIGN="JUSTIFY">BNE has to be set.</P>
<P ALIGN="JUSTIFY">#define LABEL 69</P>
<P ALIGN="JUSTIFY">Generate a label. typf specifies the number of the label.</P>
<P ALIGN="JUSTIFY">#define BEQ 70</P>
<P ALIGN="JUSTIFY">#define BNE 71</P>
<P ALIGN="JUSTIFY">#define BLT 72</P>
<P ALIGN="JUSTIFY">#define BGE 73</P>
<P ALIGN="JUSTIFY">#define BLE 74</P>
<P ALIGN="JUSTIFY">#define BGT 75</P>
<P ALIGN="JUSTIFY">Branch on condition codes. (q1).</P>
<P ALIGN="JUSTIFY">typf specifies the label where program execution shall continue, if the condition</P>
<P ALIGN="JUSTIFY">code is true (otherwise continue with next statement). The condition codes</P>
<P ALIGN="JUSTIFY">mean equal, not equal, less than, greater or equal, less or equal and greater</P>
<P ALIGN="JUSTIFY">than. If q1 is empty (q1.flags == 0), the codes set by the last COMPARE or</P>
<P ALIGN="JUSTIFY">TEST must be evaluated. Otherwise q1 contains the condition codes.</P>
<P ALIGN="JUSTIFY">On some machines the type of operands of a comparison (e.g unsigned or signed)</P>
<P ALIGN="JUSTIFY">is encoded in the branch instructions rather than in the comparison instruc-</P>
<P ALIGN="JUSTIFY">tions. In this case the code generator has to keep track of the type of the last</P>
<P ALIGN="JUSTIFY">comparison.</P>
<P ALIGN="JUSTIFY">Similarly, in some architectures, the compare and the branch can be combined.</P>
<P ALIGN="JUSTIFY">#define BRA 76</P>
<P ALIGN="JUSTIFY">Branch always. typf specifies the label where program execution continues.</P>
<P ALIGN="JUSTIFY">#define PUSH 78</P>
<P ALIGN="JUSTIFY">Push q1 on the stack (for argument passing). q1.</P>
<P ALIGN="JUSTIFY">q2.val.vmax contains the size of the object (should be accessed using the</P>
<P ALIGN="JUSTIFY">opsize()-macro), z.val.vmax contains the size that has to be pushed (ac-</P>
<P ALIGN="JUSTIFY">cess it using the pushsize()-macro). These sizes may di er due to alignment</P>
<P ALIGN="JUSTIFY">issues.</P>
<P ALIGN="JUSTIFY">q1 does not have to be an elementary type (see ASSIGN). Also, q1 can be empty.</P>
<P ALIGN="JUSTIFY">This is used for ABIs which require stack-slots to be omitted.</P>
<P ALIGN="JUSTIFY">Depending on ORDERED_PUSH the PUSH ICs are generated starting with the first</P>
<P ALIGN="JUSTIFY">or the last arguments. The direction of the stack-growth can be chosen by</P>
<P ALIGN="JUSTIFY">the backend. Note that this is only used for function-arguments, they can be</P>
<P ALIGN="JUSTIFY">pushed in opposite direction of the real stack.</P>
<P ALIGN="JUSTIFY">#define ADDI2P 81</P>
<P ALIGN="JUSTIFY">Add an integer to a pointer. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">q1 and z are always pointers (of type typf2) and q2 is an integer of type typf.</P>
<P ALIGN="JUSTIFY">z has to be q1 increased by q2 bytes.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">107</P>
<P ALIGN="JUSTIFY">#define SUBIFP 82</P>
<P ALIGN="JUSTIFY">Subtract an Integer from a pointer. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">q1 and z are always pointers (of type typf2) and q2 is an integer of type typf.</P>
<P ALIGN="JUSTIFY">z has to be q1 decreased by q2 bytes.</P>
<P ALIGN="JUSTIFY">#define SUBPFP 83</P>
<P ALIGN="JUSTIFY">Subtract a pointer from a pointer. q1,q2-&gt;z.</P>
<P ALIGN="JUSTIFY">q1 and q2 are pointers (of type typf2) and z is an integer of type typf. z has</P>
<P ALIGN="JUSTIFY">to be q1 - q2 in bytes.</P>
<P ALIGN="JUSTIFY">#define GETRETURN 93</P>
<P ALIGN="JUSTIFY">Get the return value of the last function call. -&gt;z.</P>
<P ALIGN="JUSTIFY">If the return value is in a register, its number will be q1.reg. Otherwise q1.reg</P>
<P ALIGN="JUSTIFY">will be 0. GETRETURN immediately follows a CALL IC (except possible FREEREGs).</P>
<P ALIGN="JUSTIFY">#define SETRETURN 94</P>
<P ALIGN="JUSTIFY">Set the return value of the current function. q1.</P>
<P ALIGN="JUSTIFY">If the return value is in a register, its number will be z.reg. Otherwise z.reg</P>
<P ALIGN="JUSTIFY">will be 0. SETRETURN is immediately followed by a function exit (i.e. it is the</P>
<P ALIGN="JUSTIFY">last IC or followed by an unconditional branch to a label which is the last IC -</P>
<P ALIGN="JUSTIFY">always ignoring possible FREEREGs).</P>
<P ALIGN="JUSTIFY">#define MOVEFROMREG 95</P>
<P ALIGN="JUSTIFY">Move a register to memory. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">q1 is always a register and z an array of size regsize[q1.reg].</P>
<P ALIGN="JUSTIFY">#define MOVETOREG 96</P>
<P ALIGN="JUSTIFY">Load a register from memory. q1-&gt;z.</P>
<P ALIGN="JUSTIFY">z is always a register and q1 an array of size regsize[z.reg].</P>
<P ALIGN="JUSTIFY">#define NOP 97</P>
<P ALIGN="JUSTIFY">Do nothing.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.4 Type System</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.4.1 Target Data Types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">As the compiler should be portable, we must not assume anything about the data types of</P>
<P ALIGN="JUSTIFY">the host system which is not guaranteed by ANSI/ISO C. Especially do not assume that</P>
<P ALIGN="JUSTIFY">the data types of the host system correspond to the ones of the target system.</P>
<P ALIGN="JUSTIFY">Therefore, vbcc will provide typedefs which can hold a data type of the target machine</P>
<P ALIGN="JUSTIFY">and (as there is no operator overloading in C) functions or macros to perform arithmetic</P>
<P ALIGN="JUSTIFY">on these types.</P>
<P ALIGN="JUSTIFY">The typedefs for the basic target’s data types (they can be extended by additional types)</P>
<P ALIGN="JUSTIFY">are:</P>
<P ALIGN="JUSTIFY">zchar Type char on the target machine.</P>
<P ALIGN="JUSTIFY">zuchar Type unsigned char on the target machine.</P>
<P ALIGN="JUSTIFY">zshort Type short on the target machine.</P>
<P ALIGN="JUSTIFY"> 108</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">zushort Type unsigned short on the target machine.</P>
<P ALIGN="JUSTIFY">zint Type int on the target machine.</P>
<P ALIGN="JUSTIFY">zuint Type unsigned int on the target machine.</P>
<P ALIGN="JUSTIFY">zlong Type long on the target machine.</P>
<P ALIGN="JUSTIFY">zulong Type unsigned long on the target machine.</P>
<P ALIGN="JUSTIFY">zllong Type long long on the target machine.</P>
<P ALIGN="JUSTIFY">zullong Type unsigned long long on the target machine.</P>
<P ALIGN="JUSTIFY">zmax A type capable of storing (and correctly doing arithmetic on) every signed</P>
<P ALIGN="JUSTIFY">integer type. Defaults to zllong.</P>
<P ALIGN="JUSTIFY">zumax A type capable of storing (and correctly doing arithmetic on) every unsigned</P>
<P ALIGN="JUSTIFY">integer type. Defaults to zullong.</P>
<P ALIGN="JUSTIFY">zfloat Type float on the target machine.</P>
<P ALIGN="JUSTIFY">zdouble Type double on the target machine.</P>
<P ALIGN="JUSTIFY">zldouble Type long double on the target machine.</P>
<P ALIGN="JUSTIFY">zpointer A byte pointer on the target machine. Not really used.</P>
<P ALIGN="JUSTIFY">These typedefs and arithmetic functions to work on them will be generated by the program</P>
<P ALIGN="JUSTIFY">dtgen when compiling vbcc. It will create the files ‘machines/$(TARGET)/dt.h’ and ‘dt.c’.</P>
<P ALIGN="JUSTIFY">These files are generated from ‘machines/$(TARGET)/machine.dt’ which must describe</P>
<P ALIGN="JUSTIFY">what representations the code generator needs. dtgen will then ask for available types on</P>
<P ALIGN="JUSTIFY">the host system and choose appropriate ones and/or install emulation functions, if available.</P>
<P ALIGN="JUSTIFY">In ‘machine.dt’, every data type representation gets a symbol (the ones which are already</P>
<P ALIGN="JUSTIFY">available can be looked up in ‘datatypes/datatypes.h’ - new ones will be added when</P>
<P ALIGN="JUSTIFY">necessary). The first 14 lines must contain the representations for the following types:</P>
<P ALIGN="JUSTIFY">1. signed char</P>
<P ALIGN="JUSTIFY">2. unsigned char</P>
<P ALIGN="JUSTIFY">3. signed short</P>
<P ALIGN="JUSTIFY">4. unsigned short</P>
<P ALIGN="JUSTIFY">5. signed int</P>
<P ALIGN="JUSTIFY">6. unsigned int</P>
<P ALIGN="JUSTIFY">7. signed long</P>
<P ALIGN="JUSTIFY">8. unsigned long</P>
<P ALIGN="JUSTIFY">9. signed long long</P>
<P ALIGN="JUSTIFY">10. unsigned long long</P>
<P ALIGN="JUSTIFY">11. float</P>
<P ALIGN="JUSTIFY">12. double</P>
<P ALIGN="JUSTIFY">13. long double</P>
<P ALIGN="JUSTIFY">14. void *</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">109</P>
<P ALIGN="JUSTIFY">If the code generator can use several representations, these can be added on the same line</P>
<P ALIGN="JUSTIFY">separated by spaces. E.g. the code generator for m68k does not care if the integers are</P>
<P ALIGN="JUSTIFY">stored big-endian or little-endian on the host system because it only accesses them through</P>
<P ALIGN="JUSTIFY">the provided arithmetic functions. It does, however, access  oats and doubles through</P>
<P ALIGN="JUSTIFY">byte-pointers and therefore requires them to be stored in big-endian-format.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.4.2 Target Arithmetic</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Now you have a lot of functions/macros performing operations using the target machine’s</P>
<P ALIGN="JUSTIFY">arithmetic. You can look them up in ‘dt.h/dt.c’. E.g. zmadd() takes two zmax and returns</P>
<P ALIGN="JUSTIFY">their sum as zmadd. zumadd() does the same with zumax, zldadd() with long doubles. No</P>
<P ALIGN="JUSTIFY">functions for smaller types are needed because you can calculate with the wider types and</P>
<P ALIGN="JUSTIFY">convert the results down if needed.</P>
<P ALIGN="JUSTIFY">Therefore, there are also conversion functions which convert between types of the target</P>
<P ALIGN="JUSTIFY">machine. E.g. zm2zc takes a zmax and returns the value converted to a zchar. Again, look</P>
<P ALIGN="JUSTIFY">at ‘dt.h/dt.c’ to see which ones are there.</P>
<P ALIGN="JUSTIFY">A few functions for converting between target and host types are also there, e.g. l2zm takes</P>
<P ALIGN="JUSTIFY">a long and returns it converted to zmax.</P>
<P ALIGN="JUSTIFY">At last there are functions for comparing target data types. E.g. zmleq(a,b) returns true</P>
<P ALIGN="JUSTIFY">if zlong a &lt;= zlong b and false otherwise. zleqto(a,b) returns true if zlong a == zlong</P>
<P ALIGN="JUSTIFY">b and false otherwise.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.5 ‘machine.h’</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section describes the contents of the file ‘machine.h’. Note that some optional</P>
<P ALIGN="JUSTIFY">macros/declaration may be described someplace else in this manual.</P>
<P ALIGN="JUSTIFY">#include "dt.h"</P>
<P ALIGN="JUSTIFY">This should be the first statement in ‘machine.h’.</P>
<P ALIGN="JUSTIFY">struct AddressingMode { ... };</P>
<P ALIGN="JUSTIFY">If machine-specific addressing modes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.2 [addressingmodes],</P>
<P ALIGN="JUSTIFY">page 120</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) are used, an appropriate structure can be specified here. Otherwise,</P>
<P ALIGN="JUSTIFY">just enter the following code:</P>
<P ALIGN="JUSTIFY">struct AddressingMode {</P>
<P ALIGN="JUSTIFY">int never_used;</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">#define MAXR &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Insert the number of available registers.</P>
<P ALIGN="JUSTIFY">#define MAXGF &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Insert the number of command line  ags that can be used to configure the</P>
<P ALIGN="JUSTIFY">behaviour of the code generator. This must be at least one even if you do not</P>
<P ALIGN="JUSTIFY">use any  ags.</P>
<P ALIGN="JUSTIFY">#define USEQ2ASZ &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">If this is set to zero, vbcc will not generate ICs with the target operand being</P>
<P ALIGN="JUSTIFY">the same as the 2nd source operand. This can sometimes simplify the code-</P>
<P ALIGN="JUSTIFY">generator, but usually the code is better if the code-generator allows it.</P>
<P ALIGN="JUSTIFY"> 110</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">#define MINADDI2P &lt;type&gt;</P>
<P ALIGN="JUSTIFY">Insert the smallest integer type that can be added to a pointer. Smaller types</P>
<P ALIGN="JUSTIFY">will be automatically converted to type MINADDI2P when they are to be added</P>
<P ALIGN="JUSTIFY">to a pointer. This may be subsumed by shortcut() in the future.</P>
<P ALIGN="JUSTIFY">#define BIGENDIAN &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">Insert 1 if integers are represented in big endian, i.e. the most significant byte</P>
<P ALIGN="JUSTIFY">is at the lowest memory address, the least significant byte at the highest.</P>
<P ALIGN="JUSTIFY">#define LITTLEENDIAN &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">Insert 1 if integers are represented in little endian, i.e. the least significant byte</P>
<P ALIGN="JUSTIFY">is at the lowest memory address, the most significant byte at the highest.</P>
<P ALIGN="JUSTIFY">#define SWITCHSUBS &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">Insert 1 if switch-statements should be compiled into a series of SUB/TEST/BEQ</P>
<P ALIGN="JUSTIFY">instructions rather than COMPARE/BEQ. This may be useful if the target has a</P>
<P ALIGN="JUSTIFY">more e cient SUB-instruction which sets condition codes (e.g. 68k).</P>
<P ALIGN="JUSTIFY">#define INLINEMEMCPY &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Insert the largest size in bytes allowed for inline memcpy. In optimizing compi-</P>
<P ALIGN="JUSTIFY">lation, certain library memcpy/strcpy-calls with length known at compile-time</P>
<P ALIGN="JUSTIFY">will be inlined using an ASSIGN IC if the size is less or equal to INLINEMEMCPY.</P>
<P ALIGN="JUSTIFY">The type used for the ASSIGN IC will be UNSIGNED|CHAR.</P>
<P ALIGN="JUSTIFY">This may be replaced by a variable of type zmax in the future.</P>
<P ALIGN="JUSTIFY">#define ORDERED_PUSH &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">Insert 1 if PUSH ICs for function arguments shall be generated from left to right</P>
<P ALIGN="JUSTIFY">instead right to left.</P>
<P ALIGN="JUSTIFY">#define HAVE_REGPARMS 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend supports register parameters (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.4</P>
<P ALIGN="JUSTIFY">[regparm], page 124</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_REGPAIRS 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend supports register pairs (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.5 [reg-</P>
<P ALIGN="JUSTIFY">pairs], page 124</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_INT_SIZET 1</P>
<P ALIGN="JUSTIFY">Insert this line if size_t shall be of type unsigned int rather than unsigned</P>
<P ALIGN="JUSTIFY">long.</P>
<P ALIGN="JUSTIFY">#define EMIT_BUF_LEN &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Insert the maximum length of a line of code output.</P>
<P ALIGN="JUSTIFY">#define EMIT_BUF_DEPTH &lt;n&gt;</P>
<P ALIGN="JUSTIFY">Insert the number of ouput lines that should be bu ered. This can be useful</P>
<P ALIGN="JUSTIFY">for peephole-optimizing the assembly output (see below).</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_PEEPHOLE &lt;0/1&gt;</P>
<P ALIGN="JUSTIFY">Insert 1 if the backend provides an asm_peephole() function (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.14 [asmpeephole], page 127</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_ATTRIBUTES 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend provides old target-specific variable-attributes</P>
<P ALIGN="JUSTIFY">(see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.6 [targetattributes], page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">111</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_PRAGMAS 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend provides target-specific #pragma-directives (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.7 [targetpragmas], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_REGS_MODIFIED 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend supports inter-procedural register-allocation (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.11 [regsmodified], page 126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_RALLOC 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend supports context-sensitive register-allocation (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.10 [targetralloc], page 126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_EFF_IC 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend provides a mark_eff_ics() function (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 13.8.15 [marke cs], page 128</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_EXT_IC 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend provides a struct ext_ic (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.13</P>
<P ALIGN="JUSTIFY">[extic], page 126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_EXT_TYPES 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend supports additional types (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.8</P>
<P ALIGN="JUSTIFY">[exttypes], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">#define HAVE_TGT_PRINTVAL 1</P>
<P ALIGN="JUSTIFY">Insert this line if the backend provides an own printval function see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Sec-</P>
<P ALIGN="JUSTIFY">tion 13.9.9 [tgtprintval], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6 ‘machine.c’</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This is the main part of the code generator. The first statement should be #include</P>
<P ALIGN="JUSTIFY">"supp.h" which will include all necessary declarations.</P>
<P ALIGN="JUSTIFY">The following variables and functions must be provided by machine.c.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6.1 Name and Copyright</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The codegenerater must define a zero-terminated character array char cg_copyright[];</P>
<P ALIGN="JUSTIFY">containing name and copyright-notice of the code-generator.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6.2 Command Line Options</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">You can use code generator specific commandline options. The number of  ags is specified</P>
<P ALIGN="JUSTIFY">as MAXGF in ‘machine.h’. Insert the names for the  ags as char *g_flags_name[MAXGF]. If</P>
<P ALIGN="JUSTIFY">an option was specified (g_flags[i]&amp;USEDFLAG) is not zero. In int g_flags[MAXGF] you</P>
<P ALIGN="JUSTIFY">can choose how the options are to be used:</P>
<P ALIGN="JUSTIFY">0 The option can only be specified. E.g. if g_flags_name[2]=="myflag", the</P>
<P ALIGN="JUSTIFY">commandline may contain ‘-myflag’ and (g_flags[2]&amp;USEDFLAG)!=0.</P>
<P ALIGN="JUSTIFY">VALFLAG The option must be specified with an integer constant, e.g. ‘-myflag=1234’.</P>
<P ALIGN="JUSTIFY">This value can be found in g_flags_val[2].l.</P>
<P ALIGN="JUSTIFY">STRINGFLAG</P>
<P ALIGN="JUSTIFY">The option must be specified with a string, e.g. ‘-myflag=Hallo’. The pointer</P>
<P ALIGN="JUSTIFY">to the string can be found in g_flags_val[2].p.</P>
<P ALIGN="JUSTIFY"> 112</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6.3 Data Types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following variables have to be initialized to describe the representation of the data</P>
<P ALIGN="JUSTIFY">types.</P>
<P ALIGN="JUSTIFY">MAX_TYPE This macro contains the number of di erent types. In case of target-specific ex-</P>
<P ALIGN="JUSTIFY">tended types (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.8 [exttypes], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) this is set by the backend,</P>
<P ALIGN="JUSTIFY">otherwise the frontend will use a default.</P>
<P ALIGN="JUSTIFY">zmax char_bit;</P>
<P ALIGN="JUSTIFY">The number of bits in a char on the target (usually 8).</P>
<P ALIGN="JUSTIFY">zmax align[MAX_TYPE+1];</P>
<P ALIGN="JUSTIFY">This array must contain the necessary alignments for every type in bytes. Some</P>
<P ALIGN="JUSTIFY">of the entries in this array are not actually used, but align[type&amp;NQ] must yield</P>
<P ALIGN="JUSTIFY">the correct alignment for every type. align[CHAR] must be 1.</P>
<P ALIGN="JUSTIFY">The alignment of a structure depends not only on sizetab[STRUCT] but also</P>
<P ALIGN="JUSTIFY">on the alignment of the members. The maximum of the alignments of all</P>
<P ALIGN="JUSTIFY">members and sizetab[STRUCT] is the alignment of any particular structure,</P>
<P ALIGN="JUSTIFY">i.e. sizetab[STRUCT] is only a minimum alignment.</P>
<P ALIGN="JUSTIFY">The same applies to unions and arrays.</P>
<P ALIGN="JUSTIFY">zmax maxalign;</P>
<P ALIGN="JUSTIFY">This variable must be set to an alignment in bytes that is used when pushing</P>
<P ALIGN="JUSTIFY">arguments on the stack. (FIXME: describe stackalign)</P>
<P ALIGN="JUSTIFY">zmax sizetab[MAX_TYPE+1];</P>
<P ALIGN="JUSTIFY">This array must contain the sizes of every type in bytes.</P>
<P ALIGN="JUSTIFY">zmax t_min[MAX_TYPE+1];</P>
<P ALIGN="JUSTIFY">This array must contain the smallest representable number for every signed</P>
<P ALIGN="JUSTIFY">integer type.</P>
<P ALIGN="JUSTIFY">zumax t_min[MAX_TYPE+1];</P>
<P ALIGN="JUSTIFY">This array must contain the largest representable number for every signed in-</P>
<P ALIGN="JUSTIFY">teger type.</P>
<P ALIGN="JUSTIFY">zumax tu_min[MAX_TYPE+1];</P>
<P ALIGN="JUSTIFY">This array must contain the largest representable number for every unsigned</P>
<P ALIGN="JUSTIFY">integer type.</P>
<P ALIGN="JUSTIFY">As zmax and zumax may be no elementary types on the host machine, those arrays have to</P>
<P ALIGN="JUSTIFY">be initialized dynamically (in init_cg()). It is recommended to use explicit typenames,</P>
<P ALIGN="JUSTIFY">e.g. sizetab[INT]=l2zm(4L); to keep it portable and allow later extensions of the type</P>
<P ALIGN="JUSTIFY">system.</P>
<P ALIGN="JUSTIFY">Also note that those values may not be representable as constants by the host architecture</P>
<P ALIGN="JUSTIFY">and have to be calculated using the functions for arithmetic on the target’s data types. E.g.</P>
<P ALIGN="JUSTIFY">the smallest representable value of a 32bit twos-complement data type is not guaranteed to</P>
<P ALIGN="JUSTIFY">be valid on every ANSI C implementation.</P>
<P ALIGN="JUSTIFY">You may not use simple operators on the target data types but you have to use the functions</P>
<P ALIGN="JUSTIFY">or convert them to an elementary type of the host machine before (if you know that it is</P>
<P ALIGN="JUSTIFY">representable as such).</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">113</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6.4 Register Set</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following variables have to be initialized to describe the register set of the target.</P>
<P ALIGN="JUSTIFY">MAXR The valid registers are numbered from 1..MAXR. MAXR must be #defined in</P>
<P ALIGN="JUSTIFY">‘machine.h’.</P>
<P ALIGN="JUSTIFY">char *regnames[MAXR+1]</P>
<P ALIGN="JUSTIFY">This array must contain the names for every register. They do not necessar-</P>
<P ALIGN="JUSTIFY">ily have to be used in the assembly output but are used for explicit register</P>
<P ALIGN="JUSTIFY">arguments.</P>
<P ALIGN="JUSTIFY">zmax regsize[MAXR+1]</P>
<P ALIGN="JUSTIFY">This array must contain the size of each register in bytes. It is used to create</P>
<P ALIGN="JUSTIFY">storage if registers have to be saved.</P>
<P ALIGN="JUSTIFY">int regscratch[MAXR+1]</P>
<P ALIGN="JUSTIFY">This array must contain information whether a register is a scratchregister,</P>
<P ALIGN="JUSTIFY">i.e. may be destroyed during a function call (1 or 0). vbcc will generate code</P>
<P ALIGN="JUSTIFY">to save/restore all scratch-registers which are assigned a value when calling a</P>
<P ALIGN="JUSTIFY">function (unless it knows the register will not be modified). However, if the code</P>
<P ALIGN="JUSTIFY">generator uses additional scratch-registers it has to take care to save/restore</P>
<P ALIGN="JUSTIFY">them.</P>
<P ALIGN="JUSTIFY">Also, the code generator must take care that used non-scratch-registers are</P>
<P ALIGN="JUSTIFY">saved/restored on function entry/exit.</P>
<P ALIGN="JUSTIFY">int regsa[MAXR+1]</P>
<P ALIGN="JUSTIFY">This array must contain information whether a register is in use or not at</P>
<P ALIGN="JUSTIFY">the beginning of a function (1 or 0). The compiler will not use any of those</P>
<P ALIGN="JUSTIFY">registers for register variables or temporaries, therefore this can be used to mark</P>
<P ALIGN="JUSTIFY">special registers like a stack- or frame-pointer and to reserve registers to the</P>
<P ALIGN="JUSTIFY">code-generator. The latter may be reasonable if for many ICs code cannot be</P>
<P ALIGN="JUSTIFY">generated without using additional registers.</P>
<P ALIGN="JUSTIFY">You must set regsratch[i] = 0 if regsa[i] == 1. If you want it to be saved</P>
<P ALIGN="JUSTIFY">across function calls the code generator has to take care of this.</P>
<P ALIGN="JUSTIFY">int reg_prio[MAXR+1];</P>
<P ALIGN="JUSTIFY">This array must contain a priority (&gt;=0) for every register. When the register</P>
<P ALIGN="JUSTIFY">allocator has to choose between several registers which seem to be equal, it</P>
<P ALIGN="JUSTIFY">will choose the one with the highest priority (if several registers have the same</P>
<P ALIGN="JUSTIFY">priority it is undefined which one will be taken).</P>
<P ALIGN="JUSTIFY">Note that this priority is only the last decision factor if everything else seems</P>
<P ALIGN="JUSTIFY">to be equal. If one register seems to give a higher cost saving (according to the</P>
<P ALIGN="JUSTIFY">estimation of the register allocator) but has a lower priority, it will nevertheless</P>
<P ALIGN="JUSTIFY">be used. The priority can be used to fine-tune the register selection. Some</P>
<P ALIGN="JUSTIFY">guidelines:</P>
<P ALIGN="JUSTIFY">- Scratch registers might have a higher priority than non-scratch registers</P>
<P ALIGN="JUSTIFY">(although the register-allocator will usually handle this anyway).</P>
<P ALIGN="JUSTIFY">- Registers which are more restricted should have a higher priority (if they</P>
<P ALIGN="JUSTIFY">seem to give the same saving it is usually better to use the restricted</P>
<P ALIGN="JUSTIFY"> 114</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">registers and try to keep the more versatile ones for situation in which</P>
<P ALIGN="JUSTIFY">they can give better savings).</P>
<P ALIGN="JUSTIFY">- Registers which are used for argument-passing should have lower priority</P>
<P ALIGN="JUSTIFY">than registers not used for arguments. The priority within the argument-</P>
<P ALIGN="JUSTIFY">registers should decrease as the frequency of usage as argument increases</P>
<P ALIGN="JUSTIFY">(typically the register for the first argument ist used most frequently, etc.).</P>
<P ALIGN="JUSTIFY">Note that for the array zmax regsize[] the same comments mentioned in the section on</P>
<P ALIGN="JUSTIFY">data types regarding initialization apply.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.6.5 Functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The following functions have to be implemented by the code generator. There may be</P>
<P ALIGN="JUSTIFY">optional additional functions described in other sections.</P>
<P ALIGN="JUSTIFY">int init_cg(void);</P>
<P ALIGN="JUSTIFY">This function is called after the commandline arguments are parsed. It can</P>
<P ALIGN="JUSTIFY">set up certain internal data, etc. The arrays regarding the data types and</P>
<P ALIGN="JUSTIFY">the register set can be set up at this point rather than with a static initializa-</P>
<P ALIGN="JUSTIFY">tion, however the arrays regarding the commandline options have to be static</P>
<P ALIGN="JUSTIFY">initialized. The results of the commandline options are available at this point.</P>
<P ALIGN="JUSTIFY">If something goes wrong, 0 has to be returned, otherwise 1.</P>
<P ALIGN="JUSTIFY">void cleanup_cg(FILE *f);</P>
<P ALIGN="JUSTIFY">This function is called before the compiler exits. f is the output file which must</P>
<P ALIGN="JUSTIFY">be checked against 0 before using.</P>
<P ALIGN="JUSTIFY">int freturn(struct Typ *t);</P>
<P ALIGN="JUSTIFY">This function has to return the number of the register return values of type</P>
<P ALIGN="JUSTIFY">t are passed in. If the type is not passed in a register, 0 must be returned.</P>
<P ALIGN="JUSTIFY">Usually the decision can be made only considering t-&gt;flags, ignoring the full</P>
<P ALIGN="JUSTIFY">type (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.4 [compositetypes], page 102</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">int regok(int r, int t, int mode);</P>
<P ALIGN="JUSTIFY">Check whether the type t can be stored in register r and whether the usual</P>
<P ALIGN="JUSTIFY">operations (for this type) can be generated. Return 0, if not.</P>
<P ALIGN="JUSTIFY">If t is a pointer and mode==0 the register only has to be able to store the pointer</P>
<P ALIGN="JUSTIFY">and do arithmetic, but if mode!=0 it has to be able to dereference the pointer.</P>
<P ALIGN="JUSTIFY">mode==-1 is used with context-sensitive register-allocation (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.10</P>
<P ALIGN="JUSTIFY">[targetralloc], page 126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">). If the backend does not support it, this case can be</P>
<P ALIGN="JUSTIFY">handled equivalent to mode==0.</P>
<P ALIGN="JUSTIFY">If t==0 return whether the register can be used to store condition codes. This</P>
<P ALIGN="JUSTIFY">is only relevant if multiple_ccs is set to 1.</P>
<P ALIGN="JUSTIFY">int dangerous_IC(struct IC *p);</P>
<P ALIGN="JUSTIFY">Check if this IC can raise exceptions or is otherwise dangerous. Movement of</P>
<P ALIGN="JUSTIFY">ICs which are dangerous is restricted to preserve the semantics of the program.</P>
<P ALIGN="JUSTIFY">Typical dangerous ICs are divisions or pointer dereferencing. On certain targets</P>
<P ALIGN="JUSTIFY">oating point or even signed integer arithmetic can raise exceptions, too.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">115</P>
<P ALIGN="JUSTIFY">int must_convert(int from,int to,int const_expr);</P>
<P ALIGN="JUSTIFY">Check if code must be generated to convert from type from to type to. E.g.</P>
<P ALIGN="JUSTIFY">on many machines certain types have identical representations (integers of the</P>
<P ALIGN="JUSTIFY">same size or pointers and integers of the same size).</P>
<P ALIGN="JUSTIFY">If const_expr != 0 return if a conversion was necessary in a constant expres-</P>
<P ALIGN="JUSTIFY">sion.</P>
<P ALIGN="JUSTIFY">For example, a machine may have identical pointers and integers, but di erent</P>
<P ALIGN="JUSTIFY">sets of registers (one set supports integer operations and the other pointer</P>
<P ALIGN="JUSTIFY">operations). Therefore, must_convert() would return 1 (we need a CONVERT</P>
<P ALIGN="JUSTIFY">IC to move the value from one register set to the other).</P>
<P ALIGN="JUSTIFY">This would imply that vbcc would not allow a cast from a pointer to an integer</P>
<P ALIGN="JUSTIFY">or vice-versa in constant expressions (as it will not generate code for static</P>
<P ALIGN="JUSTIFY">initializations). However, in this case, a static initialization would be ok as</P>
<P ALIGN="JUSTIFY">the representation is identical and registers are not involved. Therefore, the</P>
<P ALIGN="JUSTIFY">backend can return 1 if const_expr == 0 and 0 otherwise.</P>
<P ALIGN="JUSTIFY">int shortcut(int code, int t);</P>
<P ALIGN="JUSTIFY">In C no operations are done with chars and shorts because of integral promotion.</P>
<P ALIGN="JUSTIFY">However sometimes vbcc might see that an operation could be performed with</P>
<P ALIGN="JUSTIFY">the short types yielding the same result.</P>
<P ALIGN="JUSTIFY">Before generating such an instruction with short types vbcc will ask the code</P>
<P ALIGN="JUSTIFY">generator by calling shortcut() to find out whether it should do so. Return</P>
<P ALIGN="JUSTIFY">true i  it is a win to perform the operation code with type t rather than</P>
<P ALIGN="JUSTIFY">promoting the operands and using e.g. int.</P>
<P ALIGN="JUSTIFY">void gen_code(FILE *f, struct IC *p, struct Var *v, zmax offset);</P>
<P ALIGN="JUSTIFY">This function has to emit code for a function to stream f. v is the function</P>
<P ALIGN="JUSTIFY">being generated, p is a pointer to the list of ICs, that has to be converted.</P>
<P ALIGN="JUSTIFY">offset is the space needed for local variables in bytes.</P>
<P ALIGN="JUSTIFY">This function has to take care that only scratchregisters are destroyed by this</P>
<P ALIGN="JUSTIFY">function. The array regused contains information about the registers that</P>
<P ALIGN="JUSTIFY">have been used by vbcc in this function. However if the code generator uses</P>
<P ALIGN="JUSTIFY">additional registers it has to take care of them, too.</P>
<P ALIGN="JUSTIFY">The regs[] and regused[] arrays may be overwritten by gen_code() as well</P>
<P ALIGN="JUSTIFY">as parts of the list of ICs. However the list of ICs must still be a valid list of</P>
<P ALIGN="JUSTIFY">ICs after gen_code() returns.</P>
<P ALIGN="JUSTIFY">All assembly output should be generated using the available emit functions.</P>
<P ALIGN="JUSTIFY">These functions are able to keep several lines of assembly output bu ered and</P>
<P ALIGN="JUSTIFY">allow peephole optimizations on assembly output (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.14 [asmpeep-</P>
<P ALIGN="JUSTIFY">hole], page 127</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
<P ALIGN="JUSTIFY">void gen_ds(FILE *f, zmax size, struct Typ *t);</P>
<P ALIGN="JUSTIFY">Has to emit output that generates size bytes of type t initialized with proper</P>
<P ALIGN="JUSTIFY">0.</P>
<P ALIGN="JUSTIFY">t is a pointer to a struct Typ which contains the precise type of the variable.</P>
<P ALIGN="JUSTIFY">On machines where every type can be initialized to 0 by setting all bits to</P>
<P ALIGN="JUSTIFY"> 116</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">zero, the type does not matter. Otherwise see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.4 [compositetypes],</P>
<P ALIGN="JUSTIFY">page 102</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">All assembly output should be generated using the available emit functions.</P>
<P ALIGN="JUSTIFY">void gen_align(FILE *f, zmax align);</P>
<P ALIGN="JUSTIFY">Has to emit output that ensures the following data to be aligned to align bytes.</P>
<P ALIGN="JUSTIFY">All assembly output should be generated using the available emit functions.</P>
<P ALIGN="JUSTIFY">void gen_var_head(FILE *f, struct Var *v);</P>
<P ALIGN="JUSTIFY">Has to print the head of a static or external variable v. This includes the label</P>
<P ALIGN="JUSTIFY">and necessary informations for external linkage etc.</P>
<P ALIGN="JUSTIFY">Typically variables will be generated by a call to gen_align() followed by gen_</P>
<P ALIGN="JUSTIFY">var_head() and (a series of) calls to gen_dc() and/or gen_ds(). It may be</P>
<P ALIGN="JUSTIFY">necessary to keep track of the information passed to gen_var_head().</P>
<P ALIGN="JUSTIFY">All assembly output should be generated using the available emit functions.</P>
<P ALIGN="JUSTIFY">void gen_dc(FILE *f, int t, struct const_list *p);</P>
<P ALIGN="JUSTIFY">Emit initialized data. t is the basic type that has to be emitted. p points to a</P>
<P ALIGN="JUSTIFY">struct const_list.</P>
<P ALIGN="JUSTIFY">If p-&gt;tree != 0 then p-&gt;tree-&gt;o is a struct obj which has to be emitted.</P>
<P ALIGN="JUSTIFY">This will usually be the address of a variable of storage class static or unsigned,</P>
<P ALIGN="JUSTIFY">possibly with an o set added (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.3.2 [operands], page 99</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">for further</P>
<P ALIGN="JUSTIFY">details).</P>
<P ALIGN="JUSTIFY">if p-&gt;tree == 0 then p-&gt;val is a union atyps which contains (in the member</P>
<P ALIGN="JUSTIFY">corresponding to t) the constant value to be emitted.</P>
<P ALIGN="JUSTIFY">All assembly output should be generated using the available emit functions.</P>
<P ALIGN="JUSTIFY">void init_db(FILE *f);</P>
<P ALIGN="JUSTIFY">If debug-information is requested, this functions is called after init_cg(), but</P>
<P ALIGN="JUSTIFY">before any code is generated. See also</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.10 [debuginfo], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
<P ALIGN="JUSTIFY">void cleanup_db(FILE *f);</P>
<P ALIGN="JUSTIFY">If debug-information is requested, this functions is called prior to cleanup_</P>
<P ALIGN="JUSTIFY">cg(). See also</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.10 [debuginfo], page 131</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.7 Available Support Functions, Macros and Variables</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section lists a series of general variables, macros and functions which are available to</P>
<P ALIGN="JUSTIFY">the backend and may prove useful. Note that there may be additional support specific to</P>
<P ALIGN="JUSTIFY">certain features which will be mentioned at appropriate sections in this manual.</P>
<P ALIGN="JUSTIFY">MAXINT A constant for the largest target integer type (zmax). It is outside the range of</P>
<P ALIGN="JUSTIFY">the other types and cannot be accessed by an application (although there will</P>
<P ALIGN="JUSTIFY">usually be an accessible type with the same representation).</P>
<P ALIGN="JUSTIFY">MAX_TYPE The type number of the last type.</P>
<P ALIGN="JUSTIFY">NQ A mask. t &amp; NQ will delete all type-qualifiers of a type.</P>
<P ALIGN="JUSTIFY">NU A mask. t &amp; NU will delete all type-qualifiers but UNSIGNED of a type.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">117</P>
<P ALIGN="JUSTIFY">q1typ(p) Yields the type of the first source operand of IC p. Undefined if the operand is</P>
<P ALIGN="JUSTIFY">not used!</P>
<P ALIGN="JUSTIFY">q2typ(p) Yields the type of the second source operand of IC p. Undefined if the operand</P>
<P ALIGN="JUSTIFY">is not used!</P>
<P ALIGN="JUSTIFY">ztyp(p) Yields the type of the destination operand of IC p. Undefined if the operand is</P>
<P ALIGN="JUSTIFY">not used!</P>
<P ALIGN="JUSTIFY">iclabel(p)</P>
<P ALIGN="JUSTIFY">Returns the label of an IC. Only defined if p-&gt;code is LABEL, BEQ, BNE, BLT,</P>
<P ALIGN="JUSTIFY">BGT, BLE or BGE.</P>
<P ALIGN="JUSTIFY">opsize(p)</P>
<P ALIGN="JUSTIFY">Returns the size of the operand of an ASSIGN or PUSH IC as zmax.</P>
<P ALIGN="JUSTIFY">pushsize(p)</P>
<P ALIGN="JUSTIFY">Returns the stack-adjustment value of a PUSH IC as zmax. It is always greater</P>
<P ALIGN="JUSTIFY">or equal than opsize(p).</P>
<P ALIGN="JUSTIFY">pushedargsize(p)</P>
<P ALIGN="JUSTIFY">Returns the space occupied by arguments passed on the stack as parameters</P>
<P ALIGN="JUSTIFY">for a function call. Only valid for CALL ICs.</P>
<P ALIGN="JUSTIFY">isstatic(sc)</P>
<P ALIGN="JUSTIFY">Tests whether the storage-class sc denotes a variable with static storage and</P>
<P ALIGN="JUSTIFY">no external linkage.</P>
<P ALIGN="JUSTIFY">isextern(sc)</P>
<P ALIGN="JUSTIFY">Tests whether the storage-class sc denotes a variable with static storage and</P>
<P ALIGN="JUSTIFY">external linkage.</P>
<P ALIGN="JUSTIFY">isauto(sc)</P>
<P ALIGN="JUSTIFY">Tests whether the storage-class sc denotes a variable with automatic storage-</P>
<P ALIGN="JUSTIFY">duration.</P>
<P ALIGN="JUSTIFY">t_min(t)</P>
<P ALIGN="JUSTIFY">t_max(t) These macros yield the smallest and largest representable value of any target</P>
<P ALIGN="JUSTIFY">integer type, e.g. t_min(INT) or t_max(UNSIGNED|LONG).</P>
<P ALIGN="JUSTIFY">ISPOINTER(t)</P>
<P ALIGN="JUSTIFY">ISINT(t)</P>
<P ALIGN="JUSTIFY">ISFLOAT(t)</P>
<P ALIGN="JUSTIFY">ISFUNC(t)</P>
<P ALIGN="JUSTIFY">ISSTRUCT(t)</P>
<P ALIGN="JUSTIFY">ISUNION(t)</P>
<P ALIGN="JUSTIFY">ISARRAY(t)</P>
<P ALIGN="JUSTIFY">ISSCALAR(t)</P>
<P ALIGN="JUSTIFY">ISARITH(t)</P>
<P ALIGN="JUSTIFY">These macros test whether the simple type t is a pointer type, an integral type,</P>
<P ALIGN="JUSTIFY">a  oating point type, a function, a structure type, a union type, an array type,</P>
<P ALIGN="JUSTIFY">a scalar (integer,  oating point or pointer) and an arithmetic type (integer or</P>
<P ALIGN="JUSTIFY">oating point), respectively.</P>
<P ALIGN="JUSTIFY"> 118</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">int label;</P>
<P ALIGN="JUSTIFY">The number of the last label used so far. For a new label number, use ++label.</P>
<P ALIGN="JUSTIFY">zmax falign(struct Typ *t);</P>
<P ALIGN="JUSTIFY">This function returns the alignment of a full type. Contrary to the align[]</P>
<P ALIGN="JUSTIFY">array provided by the backend (which is used by this function), it will yield</P>
<P ALIGN="JUSTIFY">correct values for composite types like structures and arrays.</P>
<P ALIGN="JUSTIFY">zmax szof(struct Typ *t);</P>
<P ALIGN="JUSTIFY">This function returns the size in bytes of a full type. Contrary to the sizetab[]</P>
<P ALIGN="JUSTIFY">array provided by the backend (which is used by this function), it will yield</P>
<P ALIGN="JUSTIFY">correct values for composite types like structures and arrays.</P>
<P ALIGN="JUSTIFY">void *mymalloc(size_t size);</P>
<P ALIGN="JUSTIFY">void *myrealloc(void *p,size_t size);</P>
<P ALIGN="JUSTIFY">void myfree(void *p);</P>
<P ALIGN="JUSTIFY">Memory allocation functions similar to malloc(), realloc() and free. They</P>
<P ALIGN="JUSTIFY">will automatically clean up the exit in the case an allocation fails. Also, some</P>
<P ALIGN="JUSTIFY">debug possibilities are available.</P>
<P ALIGN="JUSTIFY">void emit(FILE *f,const char *fmt,...);</P>
<P ALIGN="JUSTIFY">void emit_char(FILE *f,int c) ;</P>
<P ALIGN="JUSTIFY">void emitval(FILE *f,union atyps *p,int t);</P>
<P ALIGN="JUSTIFY">void emitzm(FILE *f,zmax x);</P>
<P ALIGN="JUSTIFY">void emitzum(FILE *f,zumax x);</P>
<P ALIGN="JUSTIFY">All output produced by the backend should be produced using these functions.</P>
<P ALIGN="JUSTIFY">emit() uses a format like printf(), emitval(), emitzm() and emitzum() are</P>
<P ALIGN="JUSTIFY">suitable to output target integers as decimal text. Currently emitting  oating</P>
<P ALIGN="JUSTIFY">point constants has to be done by the backend.</P>
<P ALIGN="JUSTIFY">int is_const(struct Typ *);</P>
<P ALIGN="JUSTIFY">Tests whether a full type is constant (e.g. to decide whether it can be put into</P>
<P ALIGN="JUSTIFY">a ROM section).</P>
<P ALIGN="JUSTIFY">int is_volatile_obj(struct obj *);</P>
<P ALIGN="JUSTIFY">int is_volatile_ic(struct IC *);</P>
<P ALIGN="JUSTIFY">Tests whether an object or IC is volatile. Only of interest to the backend in</P>
<P ALIGN="JUSTIFY">rare cases.</P>
<P ALIGN="JUSTIFY">int switch_IC(struct IC *p);</P>
<P ALIGN="JUSTIFY">This function checks whether p-&gt;q2 and p-&gt;z use the same register (including</P>
<P ALIGN="JUSTIFY">register pairs). If they do, it will try to swap p-&gt;q1 and p-&gt;q2 (only possible if</P>
<P ALIGN="JUSTIFY">the IC is commutative). It is often possible to generate better code if p-&gt;q2 and</P>
<P ALIGN="JUSTIFY">p-&gt;z do not collide. Note however, that it is not always possible to eliminate a</P>
<P ALIGN="JUSTIFY">con ict and the code generator still has to be able to handle such a case.</P>
<P ALIGN="JUSTIFY">The function returns 0 if no modification took place and non-zero if the IC has</P>
<P ALIGN="JUSTIFY">been modified.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">119</P>
<P ALIGN="JUSTIFY">union atyps gval;</P>
<P ALIGN="JUSTIFY">void eval_const(union atyps *p,int t);</P>
<P ALIGN="JUSTIFY">void insert_const(union atyps *p,int t);</P>
<P ALIGN="JUSTIFY">For every target data type there is a corresponding global variable of that</P>
<P ALIGN="JUSTIFY">type, e.g. zchar vchar, zuchar vuchar, zmax vmax etc. These two functions</P>
<P ALIGN="JUSTIFY">simplify handling of target data types by transferring between a union atyps</P>
<P ALIGN="JUSTIFY">and these variables.</P>
<P ALIGN="JUSTIFY">eval_const() reads the member of the union corresponding to the type t and</P>
<P ALIGN="JUSTIFY">converts it into all the global variables while insert_const() takes the global</P>
<P ALIGN="JUSTIFY">variable according to t and puts it into the appropriate member of the union</P>
<P ALIGN="JUSTIFY">atyps.</P>
<P ALIGN="JUSTIFY">The global variable gval may be used as a temporary union atyps by the</P>
<P ALIGN="JUSTIFY">backend.</P>
<P ALIGN="JUSTIFY">void printzm(FILE *f,zmax x);</P>
<P ALIGN="JUSTIFY">void printzum(FILE *f,zumax x) ;</P>
<P ALIGN="JUSTIFY">void printval(FILE *f,union atyps *p,int t);</P>
<P ALIGN="JUSTIFY">void printtype(FILE *o,struct Typ *p);</P>
<P ALIGN="JUSTIFY">void printobj(FILE *f,struct obj *p,int t);</P>
<P ALIGN="JUSTIFY">void printic(FILE *f,struct IC *p);</P>
<P ALIGN="JUSTIFY">void printiclist(FILE *f,struct IC *first);</P>
<P ALIGN="JUSTIFY">This is a series of functions which print a more or less human readable version</P>
<P ALIGN="JUSTIFY">of the corresponding type to a stream. These functions are to be used only for</P>
<P ALIGN="JUSTIFY">debugging purposes, not for generating code. Also, the arguments must contain</P>
<P ALIGN="JUSTIFY">valid values.</P>
<P ALIGN="JUSTIFY">bvtype</P>
<P ALIGN="JUSTIFY">BVSIZE(n)</P>
<P ALIGN="JUSTIFY">vbcc provides macros and functions for handling bit-vectors which may also</P>
<P ALIGN="JUSTIFY">be used by the backend. bvtype is the basic type to create bit-vectors of.</P>
<P ALIGN="JUSTIFY">BVSIZE(n) yields the number of bytes needed to implement a bit-vector with n</P>
<P ALIGN="JUSTIFY">elements.</P>
<P ALIGN="JUSTIFY">bvtype *mybv = mymalloc(BVSIZE(n));</P>
<P ALIGN="JUSTIFY">BSET(bv,n)</P>
<P ALIGN="JUSTIFY">BCLR(bv,n)</P>
<P ALIGN="JUSTIFY">BTST(bv,n)</P>
<P ALIGN="JUSTIFY">Macros which set, clear and test the n-th bit in bit-vector bv.</P>
<P ALIGN="JUSTIFY">void bvunite(bvtype *dest,bvtype *src,size_t len);</P>
<P ALIGN="JUSTIFY">void bvintersect(bvtype *dest,bvtype *src,size_t len);</P>
<P ALIGN="JUSTIFY">void bvdiff(bvtype *dest,bvtype *src,size_t len);</P>
<P ALIGN="JUSTIFY">These functions calculate the union, intersection and di erence of two bit-</P>
<P ALIGN="JUSTIFY">vectors. dest is the first operand as well as the destination. len is the length</P>
<P ALIGN="JUSTIFY">of the bit-vectors in bytes, not in bits.</P>
<P ALIGN="JUSTIFY">void bvcopy(bvtype *dest,bvtype *src,size_t len);</P>
<P ALIGN="JUSTIFY">void bvclear(bvtype *dest,size_t len);</P>
<P ALIGN="JUSTIFY">void bvsetall(bvtype *dest,size_t len);</P>
<P ALIGN="JUSTIFY">These functions copy, clear and fill bit-vectors.</P>
<P ALIGN="JUSTIFY"> 120</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">int bvcmp(bvtype *bv1,bvtype *bv2,size_t len);</P>
<P ALIGN="JUSTIFY">int bvdointersect(bvtype *bv1,bvtype *bv2,size_t len);</P>
<P ALIGN="JUSTIFY">These functions test whether two bit-vectors are equal or have a non-empty</P>
<P ALIGN="JUSTIFY">intersection, respectively. The do not modify the bit-vectors.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8 Hints for common Optimizations</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">While it is no easy job to produce a stable code generator for a new target architecture,</P>
<P ALIGN="JUSTIFY">there is a huge di erence between a simple backend and a highly optimized code generator</P>
<P ALIGN="JUSTIFY">which produces small and e cient high quality code. Although vbcc is able to do a lot</P>
<P ALIGN="JUSTIFY">machine independent global optimizations for every target automatically, it is still common</P>
<P ALIGN="JUSTIFY">for an optimized backend to produce code up to twice as fast on average as a simple one.</P>
<P ALIGN="JUSTIFY">Sometimes, a simple backend is su cient and the work required to produce high-quality</P>
<P ALIGN="JUSTIFY">code is not worthwile. However, this section lists a series of common backend optimizations</P>
<P ALIGN="JUSTIFY">which are often done in case that good code-quality is desired. Note that neither are all of</P>
<P ALIGN="JUSTIFY">these optimizations applicable (without modifications or at all) to all architectures nor is</P>
<P ALIGN="JUSTIFY">this an exhaustive list. It is just a list of recommendations to consider. You have to make</P>
<P ALIGN="JUSTIFY">sure that the optimization is safe and beneficial for the architecture you are targetting.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.1 Instruction Combining</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">While ICs are often a bit more powerful than instructions of a typical microprocessor,</P>
<P ALIGN="JUSTIFY">sometimes several of them can be implemented by a single instruction or more e cient</P>
<P ALIGN="JUSTIFY">code can be generated when looking at a few of them rather than at each one separately.</P>
<P ALIGN="JUSTIFY">In the simple case, this can be done by looking at the current IC, deciding whether it</P>
<P ALIGN="JUSTIFY">is a candidate for combining and then test whether the next IC (or ICs) are suitable for</P>
<P ALIGN="JUSTIFY">combining. This is relatively easy to perform, however some care has to be taken to verify</P>
<P ALIGN="JUSTIFY">that the combination is indeed legal (e.g. what happens if the first IC modifies a value</P>
<P ALIGN="JUSTIFY">which is used by the following IC).</P>
<P ALIGN="JUSTIFY">A more sophisticated implementation might look at a larger sequence of instructions to find</P>
<P ALIGN="JUSTIFY">more possibilities for optimization. Detecting whether the combination is legal becomes</P>
<P ALIGN="JUSTIFY">much more di cult then.</P>
<P ALIGN="JUSTIFY">Sometimes the IC migh compute a temporary result which would be eliminated by the</P>
<P ALIGN="JUSTIFY">complex machine instruction. Then it is necessary to verify that it was indeed a temporary</P>
<P ALIGN="JUSTIFY">result which is not used anywhere else. As long as the result is in a register, this can be</P>
<P ALIGN="JUSTIFY">done by checking for a FREEREG IC.</P>
<P ALIGN="JUSTIFY">Examples for instruction combining are multiply-and-add or bit-test instructions which are</P>
<P ALIGN="JUSTIFY">available on many architectures. Special cases are complex addressing modes and instruc-</P>
<P ALIGN="JUSTIFY">tions which can automatically set condition codes which are described in the following</P>
<P ALIGN="JUSTIFY">sections.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.2 Adressing Modes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The intermediate code generated by vbcc does not use any addressing-modes a target might</P>
<P ALIGN="JUSTIFY">o er. Therefore the code generator must find a way to combine several statements if it wants</P>
<P ALIGN="JUSTIFY">to make use of these modes. E.g. on the m68k the intermediate code</P>
<P ALIGN="JUSTIFY">ADDI2P int a0,#20-&gt;a1</P>
<P ALIGN="JUSTIFY">ASSIG int #10-&gt;(a1)</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">121</P>
<P ALIGN="JUSTIFY">FREEREG a1</P>
<P ALIGN="JUSTIFY">could be translated to</P>
<P ALIGN="JUSTIFY">move.l #10,20(a0)</P>
<P ALIGN="JUSTIFY">(notice the FREEREG which is important).</P>
<P ALIGN="JUSTIFY">To aid in this there is a pointer to a struct AdressingMode in every struct obj. A code</P>
<P ALIGN="JUSTIFY">generator could e.g. do a pass over the intermediate code, find possible uses for addressing-</P>
<P ALIGN="JUSTIFY">modes, allocate a struct AddressingMode and store a pointer in the struct obj, e ectively</P>
<P ALIGN="JUSTIFY">replacing the obj.</P>
<P ALIGN="JUSTIFY">If the code generator supports extended addressing-modes, you have to think of a way to</P>
<P ALIGN="JUSTIFY">represent them and define the struct AddressingMode so that all modes can be stored in</P>
<P ALIGN="JUSTIFY">it. The machine independant part of vbcc will not use these modes, so your code generator</P>
<P ALIGN="JUSTIFY">has to find a way to combine several statements to make use of these modes.</P>
<P ALIGN="JUSTIFY">A possible implementation of a structure to handle the addressing mode described above</P>
<P ALIGN="JUSTIFY">as well as a register-indirect mode could be:</P>
<P ALIGN="JUSTIFY">#define IMM_IND 1</P>
<P ALIGN="JUSTIFY">#define REG_IND 2</P>
<P ALIGN="JUSTIFY">struct AddressingMode {</P>
<P ALIGN="JUSTIFY">int flags; /* either IMM_IND or REG_IND */</P>
<P ALIGN="JUSTIFY">int base; /* base register */</P>
<P ALIGN="JUSTIFY">zmax offset; /* offset in case of IMM_IND */</P>
<P ALIGN="JUSTIFY">int idx; /* index register in case of REG_IND */</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">When the code generator is done that pointer in every struct obj must either be zero or</P>
<P ALIGN="JUSTIFY">point to a mymalloced struct AddressingMode which will be free’d by vbcc.</P>
<P ALIGN="JUSTIFY">Following is an example of a function which traverses a list of ICs and inserts addressing</P>
<P ALIGN="JUSTIFY">modes with constant o sets where possible.</P>
<P ALIGN="JUSTIFY">/* search for possible addressing-modes */</P>
<P ALIGN="JUSTIFY">static void find_addr_modes(struct IC *p)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int c,c2,r;</P>
<P ALIGN="JUSTIFY">struct IC *p2;</P>
<P ALIGN="JUSTIFY">struct AddressingMode *am;</P>
<P ALIGN="JUSTIFY">for(;p;p=p-&gt;next){</P>
<P ALIGN="JUSTIFY">c=p-&gt;code;</P>
<P ALIGN="JUSTIFY">if(IMM_IND&amp;&amp;(c==ADDI2P||c==SUBIFP)&amp;&amp;</P>
<P ALIGN="JUSTIFY">isreg(z)&amp;&amp;(p-&gt;q2.flags&amp;(KONST|DREFOBJ))==KONST){</P>
<P ALIGN="JUSTIFY">/* we have found addi2p q1,#const-&gt;reg */</P>
<P ALIGN="JUSTIFY">int base;zmax of;struct obj *o;</P>
<P ALIGN="JUSTIFY">eval_const(&amp;p-&gt;q2.val,p-&gt;typf);</P>
<P ALIGN="JUSTIFY">/* handle sub instead of add */</P>
<P ALIGN="JUSTIFY">if(c==SUBIFP)</P>
<P ALIGN="JUSTIFY"> 122</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">of=zmsub(l2zm(0L),vmax);</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">of=vmax;</P>
<P ALIGN="JUSTIFY">/* Is the offset suitable for an addressing mode? */</P>
<P ALIGN="JUSTIFY">if(ISVALID_OFFSET(vmax)){</P>
<P ALIGN="JUSTIFY">r=p-&gt;z.reg;</P>
<P ALIGN="JUSTIFY">/* If q1 is a register, we use it as base-register,</P>
<P ALIGN="JUSTIFY">otherwise q1 is loaded in the temporary register</P>
<P ALIGN="JUSTIFY">and this one used as base register. */</P>
<P ALIGN="JUSTIFY">if(isreg(q1))</P>
<P ALIGN="JUSTIFY">base=p-&gt;q1.reg;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">base=r;</P>
<P ALIGN="JUSTIFY">o=0;</P>
<P ALIGN="JUSTIFY">/* Now search the following instructions. */</P>
<P ALIGN="JUSTIFY">for(p2=p-&gt;next;p2;p2=p2-&gt;next){</P>
<P ALIGN="JUSTIFY">c2=p2-&gt;code;</P>
<P ALIGN="JUSTIFY">/* End of a basic block. We have to abort. */</P>
<P ALIGN="JUSTIFY">if(c2==CALL||c2==LABEL||(c2&gt;=BEQ&amp;&amp;c2&lt;=BRA)) break;</P>
<P ALIGN="JUSTIFY">/* The temporary register is used. We have to abort. */</P>
<P ALIGN="JUSTIFY">if(c2!=FREEREG&amp;&amp;(p2-&gt;q1.flags&amp;(REG|DREFOBJ))==REG&amp;&amp;</P>
<P ALIGN="JUSTIFY">p2-&gt;q1.reg==r)</P>
<P ALIGN="JUSTIFY">break;</P>
<P ALIGN="JUSTIFY">if(c2!=FREEREG&amp;&amp;(p2-&gt;q2.flags&amp;(REG|DREFOBJ))==REG&amp;&amp;</P>
<P ALIGN="JUSTIFY">p2-&gt;q2.reg==r)</P>
<P ALIGN="JUSTIFY">break;</P>
<P ALIGN="JUSTIFY">if(c2!=CALL&amp;&amp;(c2&lt;LABEL||c2&gt;BRA)&amp;&amp;c2!=ADDRESS){</P>
<P ALIGN="JUSTIFY">/* See, if we find a valid use (dereference) of the</P>
<P ALIGN="JUSTIFY">temporary register. */</P>
<P ALIGN="JUSTIFY">if(!p-&gt;q1.am&amp;&amp;(p2-&gt;q1.flags&amp;(REG|DREFOBJ))==(REG|DREFOBJ)&amp;&amp;</P>
<P ALIGN="JUSTIFY">p2-&gt;q1.reg==r){</P>
<P ALIGN="JUSTIFY">if(o) break;</P>
<P ALIGN="JUSTIFY">o=&amp;p2-&gt;q1;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">if(!p-&gt;q1.am&amp;&amp;(p2-&gt;q2.flags&amp;(REG|DREFOBJ))==(REG|DREFOBJ)&amp;&amp;</P>
<P ALIGN="JUSTIFY">p2-&gt;q2.reg==r){</P>
<P ALIGN="JUSTIFY">if(o) break;</P>
<P ALIGN="JUSTIFY">o=&amp;p2-&gt;q2;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">if(!p-&gt;q1.am&amp;&amp;(p2-&gt;z.flags&amp;(REG|DREFOBJ))==(REG|DREFOBJ)&amp;&amp;</P>
<P ALIGN="JUSTIFY">p2-&gt;z.reg==r){</P>
<P ALIGN="JUSTIFY">if(o) break;</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">123</P>
<P ALIGN="JUSTIFY">o=&amp;p2-&gt;z;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">if(c2==FREEREG||(p2-&gt;z.flags&amp;(REG|DREFOBJ))==REG){</P>
<P ALIGN="JUSTIFY">int m;</P>
<P ALIGN="JUSTIFY">if(c2==FREEREG)</P>
<P ALIGN="JUSTIFY">m=p2-&gt;q1.reg;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">m=p2-&gt;z.reg;</P>
<P ALIGN="JUSTIFY">if(m==r){</P>
<P ALIGN="JUSTIFY">/* The value of the temporary register is not used any more</P>
<P ALIGN="JUSTIFY">(either due to FREEREG or because it is overwritten).</P>
<P ALIGN="JUSTIFY">If we have found exactly one dereference, we can use</P>
<P ALIGN="JUSTIFY">a target addressing mode. */</P>
<P ALIGN="JUSTIFY">if(o){</P>
<P ALIGN="JUSTIFY">o-&gt;am=am=mymalloc(sizeof(*am));</P>
<P ALIGN="JUSTIFY">am-&gt;flags=IMM_IND;</P>
<P ALIGN="JUSTIFY">am-&gt;base=base;</P>
<P ALIGN="JUSTIFY">am-&gt;offset=zm2l(of);</P>
<P ALIGN="JUSTIFY">if(isreg(q1)){</P>
<P ALIGN="JUSTIFY">/* The base already was in a register. We can</P>
<P ALIGN="JUSTIFY">eliminate the ADDI2P IC. */</P>
<P ALIGN="JUSTIFY">p-&gt;code=c=NOP;p-&gt;q1.flags=p-&gt;q2.flags=p-&gt;z.flags=0;</P>
<P ALIGN="JUSTIFY">}else{</P>
<P ALIGN="JUSTIFY">/* The base was not in a register.</P>
<P ALIGN="JUSTIFY">We have to load it . */</P>
<P ALIGN="JUSTIFY">p-&gt;code=c=ASSIGN;p-&gt;q2.flags=0;</P>
<P ALIGN="JUSTIFY">p-&gt;typf=p-&gt;typf2;p-&gt;q2.val.vmax=sizetab[p-&gt;typf2&amp;NQ];</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">break;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">if(c2!=FREEREG&amp;&amp;m==base) break;</P>
<P ALIGN="JUSTIFY">continue;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.3 Implicit setting of Condition Codes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Many architectures have instruction that automatically set the condition codes according</P>
<P ALIGN="JUSTIFY">to the computed result. For these architectures it is generally a good idea to keep track of</P>
<P ALIGN="JUSTIFY">the setting of condition codes (e.g. if they re ect the state of some object or register). A</P>
<P ALIGN="JUSTIFY">subsequent TEST or COMPARE instruction can then often be eliminated.</P>
<P ALIGN="JUSTIFY"> 124</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Care has to be taken to delete this information if either the condition codes may be modified</P>
<P ALIGN="JUSTIFY">or the object they represent is modified. Also, this optimization is usually hard to do across</P>
<P ALIGN="JUSTIFY">labels.</P>
<P ALIGN="JUSTIFY">Some architectures provide versions of instructions which set condition codes as well as</P>
<P ALIGN="JUSTIFY">versions which do not. This obviously enable more optimizations, but it is more di cult to</P>
<P ALIGN="JUSTIFY">make use of this. One possibility is to search the list of ICs backwards starting from every</P>
<P ALIGN="JUSTIFY">suitable TEST or COMPARE instruction. If an IC is found which computes the tested object,</P>
<P ALIGN="JUSTIFY">the IC can be marked (extended ICs can be used for marking, see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.8.13 [extic],</P>
<P ALIGN="JUSTIFY">page 126</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.4 Register Parameters</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">While passing of arguments to functions can be done by pushing them on the stack, it is</P>
<P ALIGN="JUSTIFY">often more e cient to pass them in registers if the architecture has enough registers.</P>
<P ALIGN="JUSTIFY">To use register parameters you have to add the line</P>
<P ALIGN="JUSTIFY">#define HAVE_REGPARMS 1</P>
<P ALIGN="JUSTIFY">to ‘machine.h’ and define a</P>
<P ALIGN="JUSTIFY">struct reg_handle {...}</P>
<P ALIGN="JUSTIFY">This struct is used by the compiler to find out which register should be used to pass an</P>
<P ALIGN="JUSTIFY">argument. ‘machine.c’ has to contain an initialized variable</P>
<P ALIGN="JUSTIFY">struct reg_handle empty_reg_handle;</P>
<P ALIGN="JUSTIFY">which represents the default state, and a function</P>
<P ALIGN="JUSTIFY">int reg_parm(struct reg_handle *, struct Typ *, int vararg, struct Typ *);</P>
<P ALIGN="JUSTIFY">which returns the number of the register the next argument will be passed in (or 0 if the</P>
<P ALIGN="JUSTIFY">argument is not passed in a register). Also, it has to update the reg handle in a way that</P>
<P ALIGN="JUSTIFY">successive calls to reg_parm() yield the correct register for every argument.</P>
<P ALIGN="JUSTIFY">vararg is di erent from zero, if the argument is part of the variable arguments of a function</P>
<P ALIGN="JUSTIFY">accepting a variable number of arguments.</P>
<P ALIGN="JUSTIFY">It is also possible to return a negative number x. In this case, the argument will be passed</P>
<P ALIGN="JUSTIFY">in register number -x, but also a stack-slot will be reserved for this argument (i.e. a PUSH</P>
<P ALIGN="JUSTIFY">IC without an operand will be generated). If ‘-double-push’ is specified, the argument will</P>
<P ALIGN="JUSTIFY">also be written to the stack-slot (i.e. it will be passed twice, in a register and on the stack).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.5 Register Pairs</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Often, there are types which cannot be stored in a single machine register, but it may be</P>
<P ALIGN="JUSTIFY">more e cient to store them in two registers rather than in memory. Typical examples are</P>
<P ALIGN="JUSTIFY">integers which are bigger than the register size or architectures which combine two  oating</P>
<P ALIGN="JUSTIFY">point registers into one register of double precision.</P>
<P ALIGN="JUSTIFY">To make use of register pairs, the line</P>
<P ALIGN="JUSTIFY">#define HAVE_REGPAIRS 1</P>
<P ALIGN="JUSTIFY">has to be added to ‘machine.h’. The register pairs are declared as normal registers (each</P>
<P ALIGN="JUSTIFY">register pair counts as an own register and MAXR has to be adjusted). Usually only adjacent</P>
<P ALIGN="JUSTIFY">registers are declared as register pairs. Note that regscratch must be identical for both</P>
<P ALIGN="JUSTIFY">registers of a pair.</P>
<P ALIGN="JUSTIFY">Now the function</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">125</P>
<P ALIGN="JUSTIFY">int reg_pair(int r,struct rpair *p);</P>
<P ALIGN="JUSTIFY">must be implemented. If register r is a register pair, the function has to set p-&gt;r1 and</P>
<P ALIGN="JUSTIFY">p-&gt;r2 to the first and second register which comprise the pair and return 1. Otherwise,</P>
<P ALIGN="JUSTIFY">zero has to be returned.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.6 Elimination of Frame-Pointer</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Local variables on the stack can usually be addressed via a so-called frame-pointer which is</P>
<P ALIGN="JUSTIFY">set set to current stack-pointer at the entry of a function. However, in the code generated</P>
<P ALIGN="JUSTIFY">by vbcc, the di erence between the stack-pointer and the frame-pointer is fixed at any</P>
<P ALIGN="JUSTIFY">instruction.</P>
<P ALIGN="JUSTIFY">Therefore it is possible to keep track of this o set (by counting the bytes every time code</P>
<P ALIGN="JUSTIFY">for pushing or popping from the stack is generated). Using this o set, local variables can</P>
<P ALIGN="JUSTIFY">perhaps be addressed using the stack-pointer directly. Benefit would be smaller function</P>
<P ALIGN="JUSTIFY">entry/exit code as well as an additional free register which can be used for other purposes.</P>
<P ALIGN="JUSTIFY">Note that only few debuggers can handle such a situation.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.7 Delayed popping of Stack-Slots</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">In most ABIs arguments which are pushed on the stack are not popped by the called</P>
<P ALIGN="JUSTIFY">function but the caller pops them by adjusting the stack after the callee returns (otherwise</P>
<P ALIGN="JUSTIFY">variable arguments would be hard to implement).</P>
<P ALIGN="JUSTIFY">If several functions are called in sequence, it is not necessary to adjust the stack after each</P>
<P ALIGN="JUSTIFY">call but the arguments for several calls can be popped at once. It can be implemented by</P>
<P ALIGN="JUSTIFY">keeping track of the size to be popped and deferring popping to a point where it has to be</P>
<P ALIGN="JUSTIFY">done (e.g. a label or a branch). Also, in the case of nested calls, care has to be taken to</P>
<P ALIGN="JUSTIFY">pop arguments at the right time.</P>
<P ALIGN="JUSTIFY">Note that this usually saves code-size and execution time but will increase stack-usage.</P>
<P ALIGN="JUSTIFY">Therefore, it may not be advisable for small systems.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.8 Optimized Return</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Return instructions are not explicitly represented in ICs. Rather, they are branches to a</P>
<P ALIGN="JUSTIFY">label which is the last IC in the list (except possible FREEREGs).</P>
<P ALIGN="JUSTIFY">It is possible to generate working code by translating these branches normally, but directly</P>
<P ALIGN="JUSTIFY">inserting the function exit code instead of a branch is often faster. It is most recommendable</P>
<P ALIGN="JUSTIFY">if the exit code is small (e.g. no registers have to be restored and no stack-frame removed).</P>
<P ALIGN="JUSTIFY">Another common possibility for optimization is a function call as the last IC. If return</P>
<P ALIGN="JUSTIFY">addresses are pushed on the stack and no function exit code is needed, it is usually possible</P>
<P ALIGN="JUSTIFY">to generate a jump-instruction, i.e. replace</P>
<P ALIGN="JUSTIFY">call somefunc</P>
<P ALIGN="JUSTIFY">ret</P>
<P ALIGN="JUSTIFY">by</P>
<P ALIGN="JUSTIFY">jmp somefunc</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.9 Jump Tables</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
<P ALIGN="JUSTIFY"> 126</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.10 Context-sensitive Register-Allocation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The regok() function is only a simple means of telling the register allocator which registers</P>
<P ALIGN="JUSTIFY">to use. It works fairly well with orthogonal register and instruction sets. However, it does</P>
<P ALIGN="JUSTIFY">not really care about the operations performed and it allocates variables to registers only</P>
<P ALIGN="JUSTIFY">according to their type, not according to the operations performed.</P>
<P ALIGN="JUSTIFY">Some architectures provide di erent kinds of registers which are able to store a type, but</P>
<P ALIGN="JUSTIFY">not all of them are able to perform all operations or some operations are more expensive</P>
<P ALIGN="JUSTIFY">with some registers. To do good register allocation for these systems, the operations which</P>
<P ALIGN="JUSTIFY">are used on variables have to be considered.</P>
<P ALIGN="JUSTIFY">If the backend wants to support this kind of register allocation, it has to define HAVE_</P>
<P ALIGN="JUSTIFY">TARGET_RALLOC and provide the following functions or macros:</P>
<P ALIGN="JUSTIFY">int cost_move_reg(int x,int y);</P>
<P ALIGN="JUSTIFY">The cost of copying register x to register y.</P>
<P ALIGN="JUSTIFY">int cost_load_reg(int r,struct Var *v);</P>
<P ALIGN="JUSTIFY">The cost of loading register r from variable v.</P>
<P ALIGN="JUSTIFY">int cost_save_reg(int r,struct Var *v);</P>
<P ALIGN="JUSTIFY">The cost of storing register r into variable v.</P>
<P ALIGN="JUSTIFY">int cost_pushpop_reg(int r);</P>
<P ALIGN="JUSTIFY">The cost of storing register r during function prologue and restoring it in the</P>
<P ALIGN="JUSTIFY">epilogue.</P>
<P ALIGN="JUSTIFY">int cost_savings(struct IC *p,int r,struct obj *o);</P>
<P ALIGN="JUSTIFY">Estimate the savings which would be obtained if the object o in IC p would be</P>
<P ALIGN="JUSTIFY">assigned to register r (in this IC). If the backend was not able to emit code in</P>
<P ALIGN="JUSTIFY">this case, INT_MIN must be returned.</P>
<P ALIGN="JUSTIFY">If (o-&gt;flags &amp; VKONST) != 0, the register allocator is thinking about putting</P>
<P ALIGN="JUSTIFY">a constant (or address of a static variable) in a register. In this case, the real</P>
<P ALIGN="JUSTIFY">object which would be put in a register is found in o-&gt;v-&gt;cobj.</P>
<P ALIGN="JUSTIFY">The unit of the costs can be chosen by the backend, but should be some reasonable small</P>
<P ALIGN="JUSTIFY">values.</P>
<P ALIGN="JUSTIFY">If regok() is called with a third parameter of -1, it is possible to return non-zero for a register</P>
<P ALIGN="JUSTIFY">which cannot perform all operations. The register allocator will call cost_savings() and</P>
<P ALIGN="JUSTIFY">returning INT_MIN can be used to prevent this register from being allocated, if the register</P>
<P ALIGN="JUSTIFY">is not suitable for a certain operation.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.11 Inter-procedural Register-Allocation</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.12 Conditional Instructions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.13 Extended ICs</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">127</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.14 Peephole Optimizations on Assembly Output</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Some optimizations are easier to do on the generated assembly code rather than doing them</P>
<P ALIGN="JUSTIFY">before emitting code. Therefore it is possible to do peephole optimizations on the emitted</P>
<P ALIGN="JUSTIFY">code before it is really written to a file.</P>
<P ALIGN="JUSTIFY">EMIT_BUF_DEPTH lines will be stored in a ring bu er and are available to examination and</P>
<P ALIGN="JUSTIFY">modification by a function emit_peephole(). The actual assembly output is stored in</P>
<P ALIGN="JUSTIFY">emit_buffer, the index of the first line to be output in emit_f and the index of the last</P>
<P ALIGN="JUSTIFY">one in emit_l (note that you have to calculate modulo EMIT_BUF_DEPTH - it is a ring bu er).</P>
<P ALIGN="JUSTIFY">The output may be modified in memory and the first line may be removed using remove_</P>
<P ALIGN="JUSTIFY">asm(). If a modification took place, a non-zero value has to be returned (0 otherwise). The</P>
<P ALIGN="JUSTIFY">following example code would combine two consecutive additions to the same register:</P>
<P ALIGN="JUSTIFY">int emit_peephole(void)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">int entries,i,r1,r2;</P>
<P ALIGN="JUSTIFY">long x,y;</P>
<P ALIGN="JUSTIFY">/* pointer to the lines in order of output */</P>
<P ALIGN="JUSTIFY">char *asmline[EMIT_BUF_DEPTH];</P>
<P ALIGN="JUSTIFY">i=emit_l;</P>
<P ALIGN="JUSTIFY">/* compute number of entries in ring buffer */</P>
<P ALIGN="JUSTIFY">if(emit_f==0)</P>
<P ALIGN="JUSTIFY">entries=i-emit_f+1;</P>
<P ALIGN="JUSTIFY">else</P>
<P ALIGN="JUSTIFY">entries=EMIT_BUF_DEPTH;</P>
<P ALIGN="JUSTIFY">/* the first line */</P>
<P ALIGN="JUSTIFY">asmline[0]=emit_buffer[i];</P>
<P ALIGN="JUSTIFY">if(entries&gt;=2){</P>
<P ALIGN="JUSTIFY">/* we have at least two line sin the buffer */</P>
<P ALIGN="JUSTIFY">/* calculate the next line (modulo EMIT_BUF_DEPTH) */</P>
<P ALIGN="JUSTIFY">i--;</P>
<P ALIGN="JUSTIFY">if(i&lt;0) i=EMIT_BUF_DEPTH-1;</P>
<P ALIGN="JUSTIFY">asmline[1]=emit_buffer[i];</P>
<P ALIGN="JUSTIFY">if(sscanf(asmline[0],"\tadd\tR%d,#%ld",&amp;r1,&amp;x)==2&amp;&amp;</P>
<P ALIGN="JUSTIFY">sscanf(asmline[1],"\tadd\tR%d,#%ld",&amp;r2,&amp;y)==2&amp;&amp;</P>
<P ALIGN="JUSTIFY">r1==r2){</P>
<P ALIGN="JUSTIFY">sprintf(asmline[1],"\tadd\tR%d,#%ld\n",r1,x+y);</P>
<P ALIGN="JUSTIFY">remove_asm();</P>
<P ALIGN="JUSTIFY">return 1;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">return 0;</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Be very careful when doing such optimizations. Only perform optimizations which are really</P>
<P ALIGN="JUSTIFY">legal. Especially assembly code often has side e ects like setting of  ags.</P>
<P ALIGN="JUSTIFY"> 128</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">Depending on command line  ags inline assembly code may or may not be passed through</P>
<P ALIGN="JUSTIFY">this peephole optimizer. By default, it will be done, enabling optimizations between gener-</P>
<P ALIGN="JUSTIFY">ated code and inline assembly.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.15 Marking of e cient ICs</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.16 Function entry/exit Code</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">At entry and exit of function, there is usually some code to set up the new environment</P>
<P ALIGN="JUSTIFY">for this function. For example, registers will have to be saved/restored, a frame pointer</P>
<P ALIGN="JUSTIFY">may be set up and a stack frame will be created. It is generally worthwile to optimize this</P>
<P ALIGN="JUSTIFY">entry/exit code. For example, if no registers need to be saved and no local variables are</P>
<P ALIGN="JUSTIFY">used on the stack, it may not be necessary to create a stack frame.</P>
<P ALIGN="JUSTIFY">The exact possibilities for optimization depend on the architecture and the ABI.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.17 Multiplication/division with Constants</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Many architectures do not provide instruction for multiplication, division or modulo calcula-</P>
<P ALIGN="JUSTIFY">tion. And on most architectures providing such instructions they are rather slow. Therefore,</P>
<P ALIGN="JUSTIFY">it is recommended to emit cheaper instructions, if possible.</P>
<P ALIGN="JUSTIFY">Usually, this can only be done if one operand of the operation is a constant. Multiplications</P>
<P ALIGN="JUSTIFY">may be replaced by a series of shift and add instructions, for example. The simplest and</P>
<P ALIGN="JUSTIFY">most important cases to replace are multiplication, division and modulo with a power of</P>
<P ALIGN="JUSTIFY">two. Multiplication by x can be replaced by a left shift of log2(x), unsigned division of x</P>
<P ALIGN="JUSTIFY">can be replaced by logical right shift of log2(x) and unsigned modulo by x can be replaced</P>
<P ALIGN="JUSTIFY">by anding with x-1.</P>
<P ALIGN="JUSTIFY">Note that signed division and modulo can usually not be replaced that simple because</P>
<P ALIGN="JUSTIFY">most division instructions give di erent results for some negative values. An additional</P>
<P ALIGN="JUSTIFY">adjustment would be necessary to get correct results. Whether this is still an improvement,</P>
<P ALIGN="JUSTIFY">depends on the architecture details.</P>
<P ALIGN="JUSTIFY">The following function can be used to test whether a value is a power of two:</P>
<P ALIGN="JUSTIFY">static long pof2(zumax x)</P>
<P ALIGN="JUSTIFY">/* Yields log2(x)+1 oder 0. */</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">zumax p;int ln=1;</P>
<P ALIGN="JUSTIFY">p=ul2zum(1L);</P>
<P ALIGN="JUSTIFY">while(ln&lt;=32&amp;&amp;zumleq(p,x)){</P>
<P ALIGN="JUSTIFY">if(zumeqto(x,p)) return ln;</P>
<P ALIGN="JUSTIFY">ln++;p=zumadd(p,p);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">return 0;</P>
<P ALIGN="JUSTIFY">}</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.18 Block copying</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">129</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.19 Optimized Library Functions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.8.20 Instruction Scheduler</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9 Hints for common Extensions</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">This section lists some common extensions to the C language which are often very helpful</P>
<P ALIGN="JUSTIFY">when using a compiler in practice. Depending on the kind of target system they may range</P>
<P ALIGN="JUSTIFY">from nobody-really-cares to absolutely essential. For example, consider the ability to specify</P>
<P ALIGN="JUSTIFY">the section within an object file a variable or function should be placed in. This is rarely</P>
<P ALIGN="JUSTIFY">of any interest when targetting a Unix-like operating system. On a stand-alone embedded</P>
<P ALIGN="JUSTIFY">system, however, it may be absolutely necessary.</P>
<P ALIGN="JUSTIFY">Therefore, consider this list as a recommendation of ideas that might be helpful.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.1 Inline Assembly</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The possibility to insert assembly code into C source is very handy in many cases. It can be</P>
<P ALIGN="JUSTIFY">used in headers to implement specially optimized versions of time-critical library routines or</P>
<P ALIGN="JUSTIFY">enable access to CPU features which are not otherwise accessible by normal C constructs.</P>
<P ALIGN="JUSTIFY">In general, almost all work is done by the frontend and only a few lines have to be inserted</P>
<P ALIGN="JUSTIFY">in the backend to make it work. Therefore, it is recommended to always support this</P>
<P ALIGN="JUSTIFY">important feature.</P>
<P ALIGN="JUSTIFY">Everything that has to be done is to check a certain condition when code for a CALL IC</P>
<P ALIGN="JUSTIFY">is generated. Instead of emitting a normal call instruction, call the emit_inline_asm()</P>
<P ALIGN="JUSTIFY">function:</P>
<P ALIGN="JUSTIFY">if((p-&gt;q1.flags &amp; (VAR|DREFOBJ)) == VAR &amp;&amp;</P>
<P ALIGN="JUSTIFY">p-&gt;q1.v-&gt;fi &amp;&amp;</P>
<P ALIGN="JUSTIFY">p-&gt;q1.v-&gt;fi-&gt;inline_asm){</P>
<P ALIGN="JUSTIFY">emit_inline_asm(f,p-&gt;q1.v-&gt;fi-&gt;inline_asm);</P>
<P ALIGN="JUSTIFY">}else{</P>
<P ALIGN="JUSTIFY">emit(f,"\tcall\t");</P>
<P ALIGN="JUSTIFY">emit_obj(f,&amp;p-&gt;q1,t);</P>
<P ALIGN="JUSTIFY">emit(f,"\n");</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">Note that argument-passing, adjusting the stack after a CALL IC etc. is not a ected. Only</P>
<P ALIGN="JUSTIFY">the actual emitting of call code is changed in the case of inline assembly.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.2 -speed/-size</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Often it is desired to generate code which runs as fast as possible but sometimes small code</P>
<P ALIGN="JUSTIFY">is needed. The command line options ‘-speed’ and ‘-size’ are provided for the user to</P>
<P ALIGN="JUSTIFY">specify his intention.</P>
<P ALIGN="JUSTIFY">These options already may change the intermediate code produced by the frontend, but</P>
<P ALIGN="JUSTIFY">the backend should also respect these switches, if possible. The variables optspeed and</P>
<P ALIGN="JUSTIFY">optsize can be queried to see if these options were specified.</P>
<P ALIGN="JUSTIFY"> 130</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">If e.g. optspeed was specified, the backend should choose faster code-sequences, even if</P>
<P ALIGN="JUSTIFY">code-size is increased significantly. Vice-versa, if optsize is specified, it should always</P>
<P ALIGN="JUSTIFY">choose the shorter code if there is a trade-o  between size and speed.</P>
<P ALIGN="JUSTIFY">Typical cases for such tradeo s are for example, block-copy (ASSIGN and PUSH) ICs. Often</P>
<P ALIGN="JUSTIFY">it is possible to call a library function or generate a simple short loop for small code, but</P>
<P ALIGN="JUSTIFY">an unrolled inlined loop for fast code.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.3 Target-specific Macros</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">A backend is able to provide macro definitions which are automatically active. It is recom-</P>
<P ALIGN="JUSTIFY">mended to define macros which allow applications to query the target architecture and the</P>
<P ALIGN="JUSTIFY">selected chip (if possible). Also, it is recommended to provide internal macros for backend</P>
<P ALIGN="JUSTIFY">specific attributes using the __attr() and __vattr() attributes.</P>
<P ALIGN="JUSTIFY">The definition of these macros can be done in init_cg() (the results of command line</P>
<P ALIGN="JUSTIFY">parsing are available at this point). There is a variable</P>
<P ALIGN="JUSTIFY">char **target_macros;</P>
<P ALIGN="JUSTIFY">which can be set to an array of pointers to strings which contain the macro definitions.</P>
<P ALIGN="JUSTIFY">The array has to be terminated by a null pointer and the syntax of the macro definitions is</P>
<P ALIGN="JUSTIFY">similar to the command line option ‘-D’:</P>
<P ALIGN="JUSTIFY">static char *marray[] = {</P>
<P ALIGN="JUSTIFY">"__TARGET_ARCH__",</P>
<P ALIGN="JUSTIFY">"__section(x)=__vattr(\"section(\"#x\")\")",</P>
<P ALIGN="JUSTIFY">0</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">...</P>
<P ALIGN="JUSTIFY">target_macros = marray;</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.4 stdarg.h</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.5 Section Specifiers</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Especially for embedded systems it can be very important to be able to place variables and</P>
<P ALIGN="JUSTIFY">functions in specific section to override default placement. This can relatively easily be done</P>
<P ALIGN="JUSTIFY">using variable attributes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.6 [targetattributes], page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">).</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.6 Target-specific Attributes</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">There are two ways of adding target-specific attributes to variables and functions. A general</P>
<P ALIGN="JUSTIFY">way is the use of __vattr() which will add the string argument to the vattr member of</P>
<P ALIGN="JUSTIFY">the corresponding struct Var, separating it by a semi-colon. The backend can use this</P>
<P ALIGN="JUSTIFY">information by parsing the string. The frontend will just build the string, it will not interpret</P>
<P ALIGN="JUSTIFY">it. If a backend o ers attributes using the __vattr() mechanism, it is recommended to</P>
<P ALIGN="JUSTIFY">provide target-specific macros (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.3 [targetmacros], page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) which expand</P>
<P ALIGN="JUSTIFY">to the appropriate __vattr()-syntax. Only these macros should be documented.</P>
<P ALIGN="JUSTIFY">A second way to specify attributes is enabled by adding</P>
<P ALIGN="JUSTIFY">#define HAVE_TARGET_PRAGMAS 1</P>
<P ALIGN="JUSTIFY">to ‘machine.h’ and adding an array</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">131</P>
<P ALIGN="JUSTIFY">char *g_attr_name[];</P>
<P ALIGN="JUSTIFY">to ‘machine.c’. This array should point to the strings used for the attributes, terminated</P>
<P ALIGN="JUSTIFY">by a null-pointer, e.g.:</P>
<P ALIGN="JUSTIFY">char *g_attr_name[] = {</P>
<P ALIGN="JUSTIFY">"__far",</P>
<P ALIGN="JUSTIFY">"__near",</P>
<P ALIGN="JUSTIFY">"__interrupt",</P>
<P ALIGN="JUSTIFY">0</P>
<P ALIGN="JUSTIFY">};</P>
<P ALIGN="JUSTIFY">These attributes can be queried in the member</P>
<P ALIGN="JUSTIFY">unsigned long tattr;</P>
<P ALIGN="JUSTIFY">of a struct Var. The first attribute is represented by bit 1, the second by bit 2 and so</P>
<P ALIGN="JUSTIFY">on. Using this mechanism, the frontend will check for redeclarations with di erent setting</P>
<P ALIGN="JUSTIFY">of attributes or multiple specification of attributes. However, only boolean attributes are</P>
<P ALIGN="JUSTIFY">possible. If parameters have to be specified, the __vattr()-mechanism has to be used.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.7 Target-specific #pragmas</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.8 Target-specific extended Types</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.9 Target-specific printval</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.10 Debug Information</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Debug information which enables (source level) debugging of compiled programs is an im-</P>
<P ALIGN="JUSTIFY">portant feature to improve the user-friendliness of a compiler. Depending on the object for-</P>
<P ALIGN="JUSTIFY">mat and debugger used, the format and capabilities of debug information can vary widely.</P>
<P ALIGN="JUSTIFY">Therefore, it is the responsibility of each backend to generate debug information. However,</P>
<P ALIGN="JUSTIFY">for common debug standards there will be modules which can be used by the backends</P>
<P ALIGN="JUSTIFY">and will do most of the work. Currently there is one such module for the DWARF2 debug</P>
<P ALIGN="JUSTIFY">standard.</P>
<P ALIGN="JUSTIFY">The compiler frontend provides a variable debug_info which can be queried to test whether</P>
<P ALIGN="JUSTIFY">debug information is desired. Also, the functions init_db() and cleanup_db() are helpful.</P>
<P ALIGN="JUSTIFY">Each struct Var contains the members char *dfilename and int dline which specify the</P>
<P ALIGN="JUSTIFY">file and line number of the variable’s definition. Also, every IC contains the members char</P>
<P ALIGN="JUSTIFY">*file and int line with the file name and line number this IC belongs to. Note however,</P>
<P ALIGN="JUSTIFY">that there may be ICs with file == 0 - not all ICs can be assigned a certain code location.</P>
<P ALIGN="JUSTIFY">Also, ICs do not always have increasing line numbers and line numbers may repeat. Not</P>
<P ALIGN="JUSTIFY">all debuggers may be able to deal with this.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.10.1 DWARF2</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">There is support for the DWARF2 debug standard which can be added to a backend rather</P>
<P ALIGN="JUSTIFY">easily. The following additions are necessary:</P>
<P ALIGN="JUSTIFY"> 132</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
<P ALIGN="JUSTIFY">1. Add the line</P>
<P ALIGN="JUSTIFY">#include "dwarf2.c"</P>
<P ALIGN="JUSTIFY">to ‘machine.c’.</P>
<P ALIGN="JUSTIFY">2. Add the following lines to init_db():</P>
<P ALIGN="JUSTIFY">dwarf2_setup(sizetab[POINTER],</P>
<P ALIGN="JUSTIFY">".byte",</P>
<P ALIGN="JUSTIFY">".2byte",</P>
<P ALIGN="JUSTIFY">".4byte",</P>
<P ALIGN="JUSTIFY">".4byte",</P>
<P ALIGN="JUSTIFY">labprefix,</P>
<P ALIGN="JUSTIFY">idprefix,</P>
<P ALIGN="JUSTIFY">".section");</P>
<P ALIGN="JUSTIFY">dwarf2_print_comp_unit_header(f);</P>
<P ALIGN="JUSTIFY">The arguments to dwarf2_setup() have the following meanings:</P>
<P ALIGN="JUSTIFY">1. The size of an address on the target.</P>
<P ALIGN="JUSTIFY">2. An assembler directive to create one byte of initialized storage.</P>
<P ALIGN="JUSTIFY">3. An assembler directive to create two bytes of initialized storage (without any</P>
<P ALIGN="JUSTIFY">padding for alignment).</P>
<P ALIGN="JUSTIFY">4. An assembler directive to create four bytes of initialized storage (without any</P>
<P ALIGN="JUSTIFY">padding for alignment).</P>
<P ALIGN="JUSTIFY">5. An assembler directive to create initialized storage representing a target address</P>
<P ALIGN="JUSTIFY">(without any padding for alignment).</P>
<P ALIGN="JUSTIFY">6. A prefix which is used for emitting numbered labels (or empty string).</P>
<P ALIGN="JUSTIFY">7. A prefix which is used for emitting external identifiers (or empty string).</P>
<P ALIGN="JUSTIFY">8. An assembler directive to switch to a new named section.</P>
<P ALIGN="JUSTIFY">3. Add the line</P>
<P ALIGN="JUSTIFY">dwarf2_cleanup(f);</P>
<P ALIGN="JUSTIFY">to cleanup_db().</P>
<P ALIGN="JUSTIFY">4. Write the function</P>
<P ALIGN="JUSTIFY">static int dwarf2_regnumber(int r);</P>
<P ALIGN="JUSTIFY">which returns the DWARF2 regnumber for a vbcc register number.</P>
<P ALIGN="JUSTIFY">5. Write the function</P>
<P ALIGN="JUSTIFY">static zmax dwarf2_fboffset(struct Var *v);</P>
<P ALIGN="JUSTIFY">which returns the o set of variable v from the DWARF2 frame-pointer.</P>
<P ALIGN="JUSTIFY">6. Write the function</P>
<P ALIGN="JUSTIFY">static void dwarf2_print_frame_location(FILE *f,struct Var *v);</P>
<P ALIGN="JUSTIFY">which prints a DWARF2 location of the frame pointer. It can use the function</P>
<P ALIGN="JUSTIFY">void dwarf2_print_location(FILE *f,struct obj *o);</P>
<P ALIGN="JUSTIFY">to output the location. For example, if the frame pointer is a simple register, it might</P>
<P ALIGN="JUSTIFY">look like this:</P>
<P ALIGN="JUSTIFY"> Chapter 13: Backend Interface</P>
<P ALIGN="JUSTIFY">133</P>
<P ALIGN="JUSTIFY">static void dwarf2_print_frame_location(FILE *f,struct Var *v)</P>
<P ALIGN="JUSTIFY">{</P>
<P ALIGN="JUSTIFY">struct obj o;</P>
<P ALIGN="JUSTIFY">o.flags=REG;</P>
<P ALIGN="JUSTIFY">o.reg=frame_pointer_register;</P>
<P ALIGN="JUSTIFY">o.val.vmax=l2zm(0L);</P>
<P ALIGN="JUSTIFY">o.v=0;</P>
<P ALIGN="JUSTIFY">dwarf2_print_location(f,&amp;o);</P>
<P ALIGN="JUSTIFY">}</P>
<P ALIGN="JUSTIFY">7. Before emitting code for an IC p, execute the code</P>
<P ALIGN="JUSTIFY">if(debug_info)</P>
<P ALIGN="JUSTIFY">dwarf2_line_info(f,p);</P>
<P ALIGN="JUSTIFY">8. After emitting code for a function v, a new numbered label has to be emitted after the</P>
<P ALIGN="JUSTIFY">function code and the function</P>
<P ALIGN="JUSTIFY">void dwarf2_function(FILE *f,struct Var *v,int endlabel);</P>
<P ALIGN="JUSTIFY">must be called.</P>
<P ALIGN="JUSTIFY">Note that the DWARF2 standard supports use of location lists which can be used to describe</P>
<P ALIGN="JUSTIFY">a variable whose location changes during the program (e.g. in a register for some time, then</P>
<P ALIGN="JUSTIFY">in memory and again in a register) as well as a moving frame pointer (very useful if no</P>
<P ALIGN="JUSTIFY">separate frame pointer is used but all local variables are accessed through a moving stack</P>
<P ALIGN="JUSTIFY">pointer). Unfortunately, none of the debuggers I have tried so far could handle these location</P>
<P ALIGN="JUSTIFY">lists. Therefore, the current DWARF2 module does not output location lists, but future</P>
<P ALIGN="JUSTIFY">version will probably o er them as an option.</P>
<P ALIGN="JUSTIFY">Without location lists, accessing local variables will only work with a fixed frame pointer and</P>
<P ALIGN="JUSTIFY">no register variables. Even with these restrictions, function parameters which are passed in</P>
<P ALIGN="JUSTIFY">registers will not be correctly displayed during the function entry code.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.11 Interrupt Handlers</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Especially for embedded systems, support for writing interrupt handlers in C is a common</P>
<P ALIGN="JUSTIFY">feature. Variable attributes (see</P>
</FONT><FONT SIZE=2 COLOR="#0000ff"><P ALIGN="JUSTIFY">Section 13.9.6 [targetattributes], page 130</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">) can be used to</P>
<P ALIGN="JUSTIFY">mark functions which are used as interrupt handlers.</P>
<P ALIGN="JUSTIFY">Typical changes which might be necessary for interrupt handlers are:</P>
<P ALIGN="JUSTIFY">- Using a di erent return instruction.</P>
<P ALIGN="JUSTIFY">- Saving all modified registers, including scratch-registers.</P>
<P ALIGN="JUSTIFY">- Creating an entry in the interrupt vector table.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.12 Stack checking</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">Dynamic checking of the stack used (or possibly extending the stack size if possible) is</P>
<P ALIGN="JUSTIFY">another useful feature. If the variable stack_check is set, stack-checking code should</P>
<P ALIGN="JUSTIFY">be emitted, if possible. Every function should call a library function (usually called __</P>
<P ALIGN="JUSTIFY">stack_check) and pass the maximum size of stack used in this function as argument. This</P>
<P ALIGN="JUSTIFY">obviously has to be done before allocating the stack-frame.</P>
<P ALIGN="JUSTIFY">The library function is responsible to take into account its own stack-frame.</P>
<P ALIGN="JUSTIFY"> 134</P>
<P ALIGN="JUSTIFY">vbcc manual</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.9.13 Profiling</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">FIXME: To be written.</P>
</FONT><FONT SIZE=4><P ALIGN="JUSTIFY">13.10 Changes from 0.7 Interface</P>
</FONT><FONT SIZE=2><P ALIGN="JUSTIFY">The backend interface has changed in several ways since vbcc 0.7. The following list men-</P>
<P ALIGN="JUSTIFY">tions most(all?) di erences between the old and new interfaces (not including new optional</P>
<P ALIGN="JUSTIFY">features which do not have to be used):</P>
<P ALIGN="JUSTIFY">- There are more types (LLONG, LDOUBLE, MAXINT). Therefore the align[] and</P>
<P ALIGN="JUSTIFY">sizetab[] arrays have dimension MAX_TYPES+1 rather than 16.</P>
<P ALIGN="JUSTIFY">- The representation and access of t_min[] and t_max[] has been changed.</P>
<P ALIGN="JUSTIFY">- zmax replaces zlong as largest integer target type. zlong is only used when actually</P>
<P ALIGN="JUSTIFY">referring to a long on the target. Also, the macros for target arithmetic are available</P>
<P ALIGN="JUSTIFY">for zmax/zumax instead of zlong/zulong.</P>
<P ALIGN="JUSTIFY">- PUSH ICs contain a second size (actual stack-adjustment).</P>
<P ALIGN="JUSTIFY">- The second argument of SHIFT ICs has an own type.</P>
<P ALIGN="JUSTIFY">- DREFOBJ objects contain the type of the dereferenced pointer (only meaningful if there</P>
<P ALIGN="JUSTIFY">are di erent pointer types).</P>
<P ALIGN="JUSTIFY">- The new CONVERT IC replaces the series of old ICs (CONVINT etc.).</P>
<P ALIGN="JUSTIFY">- emit()-functions have to be used to generate output rather than fprintf().</P>
<P ALIGN="JUSTIFY">- The functions init_db() and cleanup_db() have to be provided (they do not have do</P>
<P ALIGN="JUSTIFY">to anything).</P>
<P ALIGN="JUSTIFY">- A new array reg_prio[] is needed and controls the order in which registers are allo-</P>
<P ALIGN="JUSTIFY">cated.</P>
<P ALIGN="JUSTIFY">- The parameters of must_convert() have changed.</P>
<P ALIGN="JUSTIFY">- Static functions must not use identifiers, but have to use numbered labels.</P>
<P ALIGN="JUSTIFY">Volker Barthelmann vb@compilers.de</P>
<P> </P></FONT></BODY>
</HTML>
