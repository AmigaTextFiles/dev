10.08.96

* Wrong data width at assign of  "enum" constants to Bytes or Words

11.08.96 (V 1.10.02)

* Up form optimisation level 5 e.g. triangle exchanges are making 
  trouble when the help variable is at a register and the both other 
  variables are at the stack.
  
* The "mathieeedoubbas.library" has not been closed by the compiler.

* Constant __STORM__ now has a value of 11


18.08.96 (V 1.10.03)

* Initialisation of static data: unnecessary INIT code was created
  for pointers to functions.

19.08.96

* If there was a switch instruction with a difference between the 
  smallest and biggest case label >=2ˆ31, then there an attempt to
  create a jump table. That led to a Workspace overflow.

31.08.96

* 68k Code generation fault (> optimisation level 5) removed.

01.09.96 (V 1.10.04)

* If there was a vector of objects created with "new[number]"
  it could happen that the constructor was called for the 1st element
  of the vector only. And this was done as often as the vector has
  elements.

* When a function used more than 32KByte of Stack frame it came very
  often to an incorrect addressing.

05.09.96

* When a function gives back an object that will be given directly as 
  an argument to another function this caused wrong code or compiler
  panic.

09.09.96

* There was an Enforcer hit when the error message "Unexpected end 
  of source" appeared.

* There was a crash when there was a defined, but not declared 
  destructor and debug-file-creation was active.

10.09.96

* There was wrong code when there was an access to an array of 
  "double" (without FPU) or "long long": When an element of an 
  array was loaded in double data register and at the same time the 
  index expression stands in the first of these two data registers, 
  then the first long word was loaded first, the index expression was
  trashed and then the second long word was loaded with a disallowed 
  index.

12.09.96 (V 1.10.05)

* From 1.10.03 on there was an optimisation test in the compiler 
  that should not have been there - sorry for that.

17.09.96 (V 1.10.06)

* The "double" comparison "<" and ">=" were handled as communicative, 
  for that the compiler exchanged their arguments if this seamed to 
  be of any advantage.

* When there was register confusion before a double arithmetic 
  library function it could happen principally that he both arguments 
  were exchanged first, but were not swapped back later.

21.09.96 (V 1.10.07)

* There was a compiler crash or Enforcer hit, when the conditioned 
  operator "?:" was abused with two "void" expressions instead of 
  an "if" instruction.

* When there was something derived from a template class, the name 
  of the basis class, e.g. "Basis<int>", could not be used in the
  initialisation list.

* Access to bit fields was very faulty.

