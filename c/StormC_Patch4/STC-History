10.08.96

* Falsche Datenbreite bei Zuweisung von "enum"-Konstanten an Bytes oder Words

11.08.96 (V 1.10.02)

* Ab Optimierungsstufe 5 machte z.B. der Dreieckstausch von Variablen Ärger,
  wenn die Hilfsvariable im Register und die beiden anderen Variablen auf
  dem Stack lagen.

* Die "mathieeedoubbas.library" wurde vom Compiler nicht geschlossen.

* Konstante __STORM__ auf Wert 11 gesetzt


18.08.96 (V 1.10.03)

* Initialisierung statischer Daten: für Zeiger auf Funktionen wurde
  unnötigerweise Init-Code erzeugt.

19.08.96

* Für Switch-Anweisungen, bei denen die Differenz zwischen kleinstem
  und größtem Case-Label >= 2^31 ist, wurde fälschlich versucht,
  eine Sprungtabelle anzulegen -> Workspace-Überlauf

31.08.96

* Ziemlich schwierig eingrenzbarer 68k-Codegenerierungsfehler
  ab Optimierungsstufe 5

01.09.96 (V 1.10.04)

* Wurde ein Vektor von Objekten mit "new[anzahl]" angelegt, konnte es
  passieren, daß der Konstruktor immer nur auf dem 1. Vektorelement (und
  das so oft, wie der Vektor Elemente hat) aufgerufen wurde.

* Häufig fehlerhafte Adressierungen, wenn eine Funktion mehr als 32kByte
  als Stackframe benutzt.

05.09.96

* Vermurxter Code oder Compiler Panic, wenn eine Funktion ein Objekt
  zurückgibt und dieses ohne Umweg wieder als Argument an eine Funktion
  übergeben wird.

09.09.96

* Enforcer Hit bei Fehlermeldung "Unexpected end of source"

* Absturz bei definierter, aber nicht deklariertem Destruktor
  und eigeschalter Debug-Datei-Erzeugung

10.09.96

* Falscher Code bei Zugriff auf Arrays von "double" (ohne FPU)
  oder "long long": wenn ein Element aus dem Array in ein
  Doppel-Datenregister geladen und dabei der Indexausdruck im
  ersten dieser beiden Datenregister stand, wurde zuerst das
  erste Langwort geladen, dabei der Indexausdruck getrasht und
  anschließend das zweite Langwort mit ungültigem Index geladen.

12.09.96 (V 1.10.05)

* Ab 1.10.03 versehentlich reingerutschtes
  Optimierungs-Experiment (machte ziemlich global Ärger!) wieder
  entfernt (Sorry for that...)

17.09.96 (V 1.10.06)

* Die "double"-Vergleiche "<" und ">=" wurden fälschlich für
  Kommutativ gehalten, so daß der Compiler hier manchmal die
  Argumente vertauschte, wenns ihm gerade so besser paßte.

* Bei Register-Konfusiuon vor Aufruf von
  Double-Arithmetik-Bibliotheksfunktionen konnte es prinzipiell
  passieren, daß die beiden Argumente anfangs vertauscht waren
  und dann nicht vollständig zurechtgedreht wurden.

21.09.96 (V 1.10.07)

* Wurde der bedingte Operator "?:" mit zwei "void"-Ausdrücken als
  Ersatz für die "if"-Anweisung mißbraucht, kam der Compiler
  ins Schleudern (Absturz oder Enforcer Hits)

* Wurde von einer Template-Klasse abgeleitet, so konnte der Name
  dieser Basisklasse, z.B. "Basis<int>", nicht in der Initialisie-
  rungsliste des Konstruktors verwendet werden.

* Zugriff auf Bitfelder war gröbstens fehlerhaft.
