/* FindETag.ttx by Daniel J. Barrett, barrett@cs.umass.edu.
 * $VER: FindETag 1.03 (4.6.94)
 *
 * This file is copyright 1994 Daniel J. Barrett.  It is freely distributable
 * as long as it is distributed in its entirety.
 *
 * Locate and load the file containing a function definition, given the
 * name of the function (the "tag").
 * This program works with tag files generated by GNU "etags".
 * (And therefore is useless without etags.)
 *
 * We check for the following in order:
 *  1.	Exact name match.
 *  2.	Prefix match.
 * 	(Ask user if we should try case insensitive match.)
 *  3.	Exact name match, case insensitive.
 *  4.	Prefix name match, case insensitive.
 * If there are multiple matches, a menu is displayed, allowing the user to
 * pick the one he/she wants.
 *
 * If the file is not loaded, we load it.
 * If the file is already loaded in a buffer, we use that buffer rather than
 * loading a second copy of the file.  As a convenience, we set the Automark
 * at the current position before moving the cursor, so the user can return
 * to the old position with MoveAutomark.
 *
 * The tag name may be supplied as an argument.
 * The special argument CURSOR causes the tag name to be the word
 *  currently under the cursor.
 * If no argument is supplied, the user is prompted for a tag name.
 *
 * History:
 *
 *	1.00:	9/4/92
 *		First "real" version.
 *
 *	1.01:	9/5/92
 *		Updated a few comments.
 *
 *	1.02:	9/6/92
 *		Forgot to check that source file exists before loading.
 *
 *	1.03:	6/4/94
 *		If TAGS doesn't exist, create it automatically.
 *
 * Future improvements:
 *	Should we load the entire tag table into memory each time this
 *	is run?  Should cut down the search time for multiple searches.
 *	Or maybe into a RAM: file just once, and check for this file first?
 *	Or both?
 *
 *	If "Find" fails, don't display the stupid console error message.
 *	Trap it with SIGNAL FAILURE.
 *
 *	If tags file is older than the source file it locates, complain.
 *	 (Started on this; not working yet.)
 *	
 */

OPTIONS RESULTS

/*************************************************************************
* Constants.
*************************************************************************/

TAGFILE		= 'TAGS'	/* The name of the "tags" file. */
FILE_SEPARATOR	= '0C'X		/* ^L, file separator in tags file. */
TEMPMARK	= 192		/* A temporary bookmark. */

/*************************************************************************
* Open the support library -- need for StateF function.
*************************************************************************/

SUPLIB		= 'rexxsupport.library'

IF ~Show('L', SUPLIB) THEN DO
	IF ~AddLib(SUPLIB, 0, -30, 0) THEN DO
		CALL ReportError(SUPLIB "not found!")
		EXIT
	END
END

/*************************************************************************
* Data structure and initialization.
* We use a record called MatchTags with the following fields:
*
*	MatchTags.size		= Number of entries in the table.
*	MatchTags.i.func	= Function name of ith entry.
*	MatchTags.i.filename	= Filename containing func definition.
*	MatchTags.i.line	= Line number of the definition.
*	MatchTags.i.char	= Character position marking the definition.
*	MatchTags.i.search	= Search string to find the definition.
*************************************************************************/

MatchTags.	= ""		/* The table of entries matching target. */

/*************************************************************************
* A variable for holding the results of tests.
* Allows us to save a lot of coding with the 4 "match" functions.
*************************************************************************/

MatchResult	= 0


/*************************************************************************
* Open the tags file.  If unsuccessful, try to create it.
* If unsuccessful, complain and exit.
*************************************************************************/

IF ~Open('tagfile', TAGFILE, 'r') THEN DO
	RequestBool '"No tag file"' '"No tag file - create it?"'
	IF RESULT = "YES" THEN DO
		ADDRESS COMMAND "etags #?.c #?.h"
		IF ~Open('tagfile', TAGFILE, 'r') THEN DO
			CALL ReportError("Can't create" TAGFILE "file!")
			EXIT
		END
	END
	ELSE DO
		CALL ReportError("Find tag operation FAILED")
		EXIT
	END
END


IF Word(statef(TAGFILE), 2) = 0 THEN DO
	CALL ReportError(TAGFILE "file is empty!")
	EXIT
END


/*************************************************************************
* If a tag name was supplied as an argument, use it.
* (The special argument "CURSOR" means to use the word under the cursor.)
* Otherwise, prompt the user for the tag.
*************************************************************************/

PARSE ARG findMe
IF findMe = CURSOR THEN DO
	GetWord
	findMe = RESULT
END
ELSE IF findMe = "" THEN DO
	RequestStr PROMPT '"Function name/prefix?"'
	findMe = RESULT
	IF rc ~= 0 THEN DO
		CALL TellUser("Tag operation cancelled")
		EXIT
	END
END


/*************************************************************************
* Look for a match!
*************************************************************************/

CALL TellUser("Hello," findMe || "...")
SetPrefs FindIgnoreCase OFF

IF FindMatch(findMe, 'tagfile', "ExactMatch") > 0 THEN
	CALL LoadTag()
ELSE IF FindMatch(findMe, 'tagfile', "PrefixMatch") > 0 THEN
	CALL LoadTag()
ELSE IF UserWantsCaseInsensitive(findMe) THEN DO
	CALL TellUser("Trying again...")
	SetPrefs FindIgnoreCase ON

	IF FindMatch(findMe, 'tagfile', "ExactNoCaseMatch") > 0 THEN
		CALL LoadTag()
	ELSE IF FindMatch(findMe, 'tagfile', "PrefixNoCaseMatch") > 0 THEN
		Call LoadTag()
	ELSE DO
		CALL ReportError("Tag" findMe "not found")
	END
END


/*************************************************************************
* Goodbye!
*************************************************************************/

CALL Close('tagfile')
EXIT




/*************************************************************************
 ************************** Support Functions ****************************
 ************************************************************************/

/*************************************************************************
* Reinitialize the tags table.
*************************************************************************/

ResetTagsTable: PROCEDURE EXPOSE MatchTags.
	PARSE ARG tagfile
	MatchTags.size = 0
	CALL Seek(tagfile, 0, 'b')
	RETURN


/*************************************************************************
* Ask the user whether s/he wants to try re-searching with
* case-sensitivity turned off.
*************************************************************************/

UserWantsCaseInsensitive: PROCEDURE
	PARSE ARG func
	RequestBool func '"Not found -- Try ignoring case?"'
	RETURN (RESULT == "YES")


/*************************************************************************
* Report an error to the user.
*************************************************************************/

ReportError: PROCEDURE
	PARSE ARG msg
	BeepScreen
	SetStatusBar TEMPORARY msg
	RETURN


/*************************************************************************
* Report a non-error message to the user.
*************************************************************************/

TellUser: PROCEDURE
	PARSE ARG msg
	SetStatusBar TEMPORARY msg
	RETURN

/*************************************************************************
* Convert a search string into a function name, by converting tabs to
* spaces, finding the last word,
* and stripping off all parentheses and asterisks.
*************************************************************************/

Search2Func: PROCEDURE
	PARSE ARG str
	str = Translate(str, ' ', '09'X)
	RETURN Strip(Word(str, Words(str)), 'B', "()*")


/*************************************************************************
* Scan the tags file.
* Find matches and fill up MatchTags with them.
* Uses data-driven programming for the "match" function.
*************************************************************************/

FindMatch:
	PARSE ARG target, tagfile, MatchFunc

	CALL ResetTagsTable(tagfile)
	oneline = ReadLn(tagfile)
	DO WHILE ~EOF(tagfile)
		IF oneline == FILE_SEPARATOR THEN DO
			oneline = ReadLn(tagfile)
			PARSE VAR oneline myfile ',' dum
		END
		ELSE DO
			PARSE VAR oneline searcher '7F'X lineNum ',' charNum
			funcname = Search2Func(searcher)
			INTERPRET "CALL" MatchFunc || "(target, funcname)"
			IF (MatchResult == 1) THEN DO
				MatchTags.size		= MatchTags.size + 1
				i			= MatchTags.size
				MatchTags.i.search	= searcher
				MatchTags.i.func	= funcname
				MatchTags.i.char	= charNum
				MatchTags.i.line	= lineNum
				MatchTags.i.filename	= myfile
			END
		END
		oneline = ReadLn(tagfile)
	END

	IF (MatchTags.size > 0) THEN
		CALL TellUser("Found it!")

	RETURN(MatchTags.size)

/*************************************************************************
* Our 4 "MatchResult" setting functions, used by FindMatch.
*************************************************************************/

ExactMatch: PROCEDURE EXPOSE MatchResult
	PARSE ARG target, candidate
	MatchResult = (target == candidate)
	RETURN

PrefixMatch: PROCEDURE EXPOSE MatchResult
	PARSE ARG target, candidate
	MatchResult = (target == Substr(candidate, 1, length(target)))
	RETURN

ExactNoCaseMatch: PROCEDURE EXPOSE MatchResult
	PARSE UPPER ARG target, candidate
	MatchResult = (target == candidate)
	RETURN

PrefixNoCaseMatch: PROCEDURE EXPOSE MatchResult
	PARSE UPPER ARG target, candidate
	MatchResult = (target == Substr(candidate, 1, length(target)))
	RETURN


/*************************************************************************
* Load the requested tag.  Return success or failure.
*************************************************************************/

LoadTag: PROCEDURE EXPOSE MatchTags. TEMPMARK TAGFILE
	IF MatchTags.size == 1 THEN DO
		ret = LoadOneTag(1)
	END
	ELSE DO
		choice = GetUserChoice()
		IF (choice ~== "") THEN
			ret = LoadOneTag(choice)
		ELSE
			ret = 1
	END
	RETURN ret


/*************************************************************************
* Getting and displaying the user's choices.
*************************************************************************/

GetUserChoice: PROCEDURE EXPOSE MatchTags.
	OPTIONS PROMPT "Which tag? (1-" || MatchTags.size || ", ?=menu," ,
		       "RETURN=quit): "

	CALL PrintUserChoices()
	answer = -1
	DO WHILE (answer < 1) | (answer > MatchTags.size)
		PULL answer
		IF (answer = "") THEN
			RETURN ""
		ELSE IF (answer = "?") THEN
			CALL PrintUserChoices()
	END

	RETURN answer

PrintUserChoices: PROCEDURE EXPOSE MatchTags.
	DO i=1 TO MatchTags.size
		SAY i || ">" MatchTags.i.func ,
		    "("||MatchTags.i.filename||")"
	END
	RETURN

/*************************************************************************
* Load one tag whose index is given as an argument.
* Return success or failure.
*************************************************************************/

LoadOneTag: PROCEDURE EXPOSE MatchTags. TEMPMARK
	PARSE ARG choice
	dum = GetAndDisplayFile(MatchTags.choice.filename) 
	PARSE VAR dum port " " oldNew
	IF port == "" THEN DO
		RETURN 1
	END
	ELSE DO
		ADDRESS VALUE port
		SetDisplayLock ON
		xx = GetIt(MatchTags.choice.func, MatchTags.choice.line)
		IF (xx == 0) & (oldNew == "OLD") THEN DO
			MoveBookmark TEMPMARK
			MoveAutomark
			ActivateWindow
			Window2Front
			CALL TellUser("Old buffer")
		END
		SetDisplayLock OFF
		RETURN(xx)
	END


/*************************************************************************
* Get and display the given file.  It must exist; else return "".
* If already loaded into a document, return the port name and "OLD".
* Otherwise, read the file from disk and return the port name and "NEW".
*************************************************************************/

GetAndDisplayFile: PROCEDURE EXPOSE TEMPMARK
	PARSE ARG filename

	IF ~Exists(filename) THEN DO
		CALL ReportError("File" filename "not found")
		RETURN ""
	END

	port = BufferIsLoaded(filename)
	IF port = "" THEN DO
		OpenDoc			/* Window is blank */
		port = RESULT
		ADDRESS VALUE port
		SetDisplayLock ON	/* Keep it blank. */
		OpenFile NAME filename	/* Load silently... */
		RETURN port || ' ' || "NEW"
	END
	ELSE DO
		ADDRESS VALUE port
		SetBookmark TEMPMARK
		RETURN port || ' ' || "OLD"
	END


/*************************************************************************
* Once the file is loaded, move to the tag.
* Note that if the cursor is on the first letter of the name, forward
* searching won't find it!  So we move to the end of the line and
* search backwards.
*************************************************************************/

GetIt: PROCEDURE
	PARSE ARG searchString, lineNum
	Move FOLDS lineNum 1
	MoveEOL
	SetPrefs FindBackward ON
	SetPrefs FindWholeWords ON
	Find '"' || searchString || '"'
	IF rc ~= 0 THEN DO
		CALL ReportError("Found the file, not the tag.")
		RETURN 1
	END
	ELSE DO
		RETURN 0
	END


/*************************************************************************
* Is a given file loaded?  If so, return its port name.
* Otherwise, return the empty string. 
*************************************************************************/

BufferIsLoaded: PROCEDURE
	PARSE UPPER ARG bufName

	GetDocuments
	docList = RESULT

	foundit = 0
	DO WHILE (docList ~= "") & ~foundit
		PARSE VAR docList '"' filename '" ' port ' ' docList
		IF bufName = upper(filename) THEN DO
			tagPort = port
			foundit = 1
		END
	END

	IF foundit THEN
		RETURN tagPort
	ELSE
		RETURN ""
