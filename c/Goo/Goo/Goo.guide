@database Goo.autodoc
@$VER: Goo.autodoc 0.19 (25.9.98)
@author Andrew King (oondy@q-group.demon.co.uk)
@(c) 1998 Q Software Limited, all rights reserved
@remark Created by hand :)
@remark Report bugs to bugs@q-group.demon.co.uk

@node "Main" "Goo.o Autodocs"

Sorry, these docs are a bit rushed.  I haven't got the time at the
moment to do proper docs since I'm trying to code FUBAR :)

Report any bugs you find in Goo to bugs@q-group.demon.co.uk.

TABLE OF CONTENTS

Goo.o/@{"--background--" link "--background--"}
Goo.o/@{"--history--" link "--history--"}
Goo.o/@{"GOO_CloseWindow" link "GOO_CloseWindow"}
Goo.o/@{"GOO_FreeObject" link "GOO_FreeObject"}
Goo.o/@{"GOO_FreeObjects" link "GOO_FreeObjects"}
Goo.o/@{"GOO_GetIMsg" link "GOO_GetIMsg"}
Goo.o/@{"GOO_GetInternal" link "GOO_GetInternal"}
Goo.o/@{"GOO_GetObjectAttr" link "GOO_GetObjectAttr"}
Goo.o/@{"GOO_NewObject" link "GOO_NewObject"}
Goo.o/@{"GOO_OpenWindow" link "GOO_OpenWindow"}
Goo.o/@{"GOO_RefreshObject" link "GOO_RefreshObject"}
Goo.o/@{"GOO_RefreshObjects" link "GOO_RefreshObjects"}
Goo.o/@{"GOO_ReplyIMsg" link "GOO_ReplayIMsg"}
Goo.o/@{"GOO_SetInternal" link "GOO_SetInternal"}
Goo.o/@{"GOO_SetObjectAttrs" link "GOO_SetObjectAttrs"}
Goo.o/@{"GOO_WaitIMsg" link "GOO_WaitIMsg"}

@endnode

@node "--background--" "Goo.o/--background--"

   @{b}NAME    @{ub}
    Goo link library

   @{b}USAGE@{ub}
    Link Goo.o with your C compiler.

   @{b}FUNCTION@{ub}
    Provides the developer with a simple and "modular" "object-orientated"
    graphical user interface system for use with games (but could also
    be used for applications, but there are far better systems for those).
    All gadgets (or objects) are Intuition-based, but do not use actual
    Intuition gadgets - uses windows, but that's about it.

    You might say that this module isn't very "system friendly" or follows
    any "standards" which is very true - it doesn't follow Amiga Inc's
    standards, but not many games that look good do.  Writing games using
    gadtools or some such not only looks like an application, but doesn't
    provide the directness that some games require.  But, I can assure you
    that Goo is 100% system friendly and requires multitasking to be
    ENABLED (because it uses Intuition).  

   @{b}NAME EXPLANATION@{ub}
    Why's it called Goo?  Well, the term "graphical user interface" is
    shortened to the acronym GUI and some people pronounce "GUI" as
    "gooey" - so, "goo" because goo is goo.  Erm, it's one of those names
    that gets less and less funny the more times you hear it I suppose.

   @{b}RESULT@{ub}
    After linking and utilisation, the result is a simple, effective and
    just darn right nifty standardised graphical user interface for games.
    We love it, we hope you do too.

   @{b}EXAMPLE@{ub}
    See the enclosed GooTest.c program for a simple demonstration.
    Note that it uses some custom routines which aren't included, but
    its just there to give you an idea on how to use Goo :)

   @{b}COPYRIGHT AND DISTRIBUTION@{ub}
    Goo and its assoicated files and documentation are (c) 1998 Q
    Software Ltd, all rights reserved.  Goo is FREEWARE.  Use it in 
    anything you see fit - albeit public domain, freeware, shareware, 
    anyware or commerical software.  Just don't touch the module (just 
    link it) and you're free to do what you want with it.

    You are not required to pay any royalties or give us anything if you
    use Goo in your software, but we're not all millionares (yet).

    If you want to redistribute the Goo package (Goo.o, include files and
    documentation) feel free - just don't charge anything more than usual
    copying fees or edit anything.  CD-ROM collection inclusion is 
    permitted.
    If you distribute your program that uses Goo.o/Goo.h, you are not
    required to distribute anything to do with the Goo package, although
    don't edit, disassemble or anything to Goo.o - we want to be famous
    as well you know.

   @{b}BUGS@{ub}
    Probably loads.  Mail bugs@q-group.demon.co.uk.

   @{b}CONTACT INFORMATION@{ub}
    If you should desire to contact the author of Goo, feel free:

    Q Software Limited
    Technical Development
    6 Beaufort Close
    AYLESBURY
    Buckinghamshire
    HP21 9BB
    England

    Phone: ++44 (0) 1296 589974 (9am-5pm UK time)
    WWW:   http://www.q-group.demon.co.uk

   @{b}SEE ALSO@{ub}
    Some form of life.

@endnode

@node "--history--" "Goo.o/--history--"

   @{b}MODULE HISTORY@{ub}
    0.19 (24-Sep-98)
    - Fixed a memory leak in FreeObject() regarding string buffers

    0.18 (23-Sep-98)
    - Removed TEXT objects :)
    - Wasn't obeying JAM1 draw modes, fixed.
    - Altered LABEL objects so they can be changed (why not in the first 
      place :)
    - Button pressing is a bit glitchy still :/

    0.17 (10-Aug-98)
    - Added TEXT objects hehe.
    - Old TEXT objects are now called LABEL objects.
    - TEXT objects CAN have the label changed, LABEL objects CANNOT.  A
      TEXT object is essentially a STRING object that has been perminately
      disabled, but without the "ghosting" effect.

    0.16 (09-Aug-98)
    - Image buttons can now have ALTERNATE images! (after Ash-badgering)
    - Buttons can also be cancelled by moving the mouse away from the
      button and letting go of the mouse.

    0.15 (01-Aug-98)
    - Extended GOOIMsg structure to hold Seconds and Micros for double-
      click support.
    - Updated embedded copyright message (woo, major bugfix ;)

    0.14 (11-Jul-98)
    - Added TEXT objects.
    - Fixed bug in SetObjectAttr() that didn't allow an object's
      read-only state to be changed.

    0.13 (7-Jul-98)
    - Single objects can be freed from a window
    - Closing of windows now replies any messages before it is closed.

    0.12 (5-Jul-98)
    - String objects now have a border around them.
    - Added functions to alter internal settings (shine/shadow pens..)
    - Fixed bugs with fonts; now always uses the screen's font.
    - Text button objects now don't go over the border.
    - String objects now cause events; GOOCL_STRINGCHANGED
    - All objects now obey the new pen settings in internal structs.

    0.11 (4-Jul-98)
    - Added STRING objects!

    0.10 (26-Jun-98)
    - Fixed serious bug in event loop handling, resulting in the
      IMsg varible in struct GOOIMsg becoming private.
    - TipText windows now appear underneath hi-res mouse pointers.
    - Added basic textual button to button object; do not use in final
      programs as it is very simple and ugly.

    0.0 - 0.09
    - Basic program functioning.

@endnode

@node "GOO_CloseWindow" "Goo.o/GOO_CloseWindow"

   @{b}NAME    @{ub}
    GOO_CloseWindow - closes a window opened with GOO_OpenWindow()

   @{b}SYNOPSIS@{ub}
    void GOO_CloseWindow(struct GOOWindow *GOOWindow, BOOL FreeObjects)

   @{b}FUNCTION@{ub}
    Closes and frees structures allocated to do with the Goo window.  Also
    frees the objects that are attached to the window if FreeObjects == TRUE.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a GOOWindow structure made by GOO_OpenWindow()
    FreeObjects - if TRUE, this function will free the objects which are
        attached to the window.  If FALSE, the objects won't be touched, but
        detached from the window.

   @{b}RESULT@{ub}
    A closed window.

   @{b}NOTES@{ub}
    Safe to call if GOOWindow is NULL.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_OpenWindow, Goo.o/GOO_FreeObjects

@endnode

@node "GOO_FreeObject" "Goo.o/GOO_FreeObject"

   @{b}NAME    @{ub}
    GOO_FreeObject - frees and detaches one object from a window

   @{b}SYNOPSIS@{ub}
    void GOO_FreeObject(struct GOOWindow *GOOWindow, ULONG ID)

   @{b}FUNCTION@{ub}
    Frees up memory and removes any gadgets which an object may be
    using.  The object is disconnected from the object tree that
    a GOOWindow has, and then forgotten about.  Useful if you just
    want to remove one or two objects from a window without having
    to remove them all and remake them.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a GOOWindow with some objects on
    ID - the ID of the object you want to remove

   @{b}NOTES@{ub}
    This does not refresh the window in any way - if you remove an
    object, the object may still be visible but not really there.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_FreeObjects

@endnode

@node "GOO_FreeObjects" "Goo.o/GOO_FreeObjects"

   @{b}NAME    @{ub}
    GOO_FreeObjects - frees all GOO objects attached to a window

   @{b}SYNOPSIS@{ub}
    void GOO_FreeObjects(struct GOOWindow *GOOWindow)

   @{b}FUNCTION@{ub}
    Frees up all memory assoicated with objects that are attached to the
    window GOOWindow.  Any bitmap's that objects utilise will not be freed.
    Once all objects are freed, the object list is detached from the window.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a GOOWindow structure you have opened previously

   @{b}NOTES@{ub}
    If the window has no objects, this function does nothing.
    This function is considered low-level, as GOO_CloseWindow calls this for
    you.  However, it may be useful if you don't want to close and re-open a
    GOO window.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_CloseWindow, Goo.o/GOO_NewObject

@endnode

@node "GOO_GetIMsg" "Goo.o/GOO_GetIMsg"

   @{b}NAME    @{ub}
    GOO_GetIMsg - gets a GOOIMsg structure from a GOO window

   @{b}SYNOPSIS@{ub}
    struct GOOIMsg *GOO_GetIMsg(struct GOOWindow *GOOWindow)

   @{b}FUNCTION@{ub}
    Examines a GOOWindow's UserPort and processes any events that
    may be present at the window's port.  After any processing is
    done, this returns a GOOIMsg structure - an extended IntuiMessage
    structure that has some GOO related information you will be
    interested in.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a valid GOOWindow structure

   @{b}RESULT@{ub}
    Returns a pointer to a GOOIMsg structure or NULL if no message.

   @{b}NOTES@{ub}
    Passing NULL as GOOWindow is safe.
    You must use GOO_ReplyIMsg to reply to the message, otherwise bad
    things are bound to happen.  And don't reply to the IntuiMessage
    that is in the GOOIMsg structure yourself, otherwise similar bad
    things will occur - it is provided for your convienance.

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_ReplyIMsg, Goo.o/GOO_WaitIMsg, exec.library/GetMsg,
        gadtools.library/GT_GetIMsg

@endnode

@node "GOO_GetInternal" "Goo.o/GOO_GetInternal"

   @{b}NAME    @{ub}
    GOO_GetInternal - queries the internal structures about something

   @{b}SYNOPSIS@{ub}
    LONG GOO_GetInternal(ULONG Varible)

   @{b}FUNCTION@{ub}
    Asks around the Goo subsystem about Varible.  This function is
    basically the same as GOO_SetInternal() except that this doesn't
    change anything.

   @{b}INPUTS@{ub}
    Varible - what you want to know about; see Goo.h for possibilities

   @{b}RESULT@{ub}
    Whatever Varible is equal to or NULL.

   @{b}NOTES@{ub}
    Returns NULL if Varible is private or is unknown to the subsystem.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_SetInternal, Goo.h

@endnode

@node "GOO_GetObjectAttr" "Goo.o/GOO_GetObjectAttr"

   @{b}NAME    @{ub}
    GOO_GetObjectAttr - enquires an object about something

   @{b}SYNOPSIS@{ub}
    LONG GOO_GetObjectAttr(struct GOOWindow *GOOWindow, ULONG ID, ULONG Tag)

   @{b}FUNCTION@{ub}
    Allows appliprog to ask an object attached to a window about something.
    If the object knows what appliprog wants to know, this function returns
    the result.

   @{b}INPUTS@{ub}
    GOOWindow - window with the object you want to query attached
    ID - the object's ID
    Tag - the tag you want to ask the object with; uses the same tags as
          what you supply to GOO_NewObject()

   @{b}RESULT@{ub}
    Either the answer to your query (whatever type it may be) or NULL if the
    object doesn't understand you or because what you asked for was private.

   @{b}EXAMPLE@{ub}
    This simple example shows how to get an object's tiptext.

    ...
    struct GOOWindow *GOOWindow;
    STRPTR TheText;
    ...
    if(TheText = (STRPTR)GOO_GetObjectAttr(GOOWindow, 1, GOOTAG_TipText))
    /* TheText now contains a pointer to the object's tip text */
    ...

   @{b}NOTES@{ub}
    If GOOWindow, ID or Tag is NULL, this function returns NULL.
    Some object's can have tags set at object creation time or using
    GOO_SetObjectAttr(), but these tags may not be able to get queried for
    some reason.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_NewObject, Goo.o/GOO_SetObjectAttr

@endnode

@node "GOO_NewObject" "Goo.o/GOO_NewObject"

   @{b}NAME    @{ub}
    GOO_NewObject - creates a new Goo object

   @{b}SYNOPSIS@{ub}
    BOOL GOO_NewObject(struct GOOWindow *GOOWindow, struct TagItem *TagList)
    BOOL GOO_NewObjectTags(struct GOOWindow *GOOWindow, Tags, ...)

   @{b}FUNCTION@{ub}
    Creates and (optionally) attaches a Goo object to a Goo window.
    Types and tags are defined in Goo.h.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a window you previously opened; not a struct 
      Window!
    Tags - various tags; see Goo.h.

   @{b}RESULT@{ub}
    If successful, returns TRUE or FALSE if not.

   @{b}NOTES@{ub}
    Once the object has been created, don't alter the objects structure 
    yourself.
    Please use GOO_SetObjectAttrs() to change things.
    This routine may alter the IDCMP flags of a window.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_FreeObjects, Goo.o/GOO_SetObjectAttrs, Goo.h

@endnode

@node "GOO_OpenWindow" "Goo.o/GOO_OpenWindow"

   @{b}NAME    @{ub}
    GOO_OpenWindow - opens a window which can be used for GOO objects

   @{b}SYNOPSIS@{ub}
    struct GOOWindow *GOO_OpenWindow(struct Screen *Screen,
        struct TagItem *TagList)
    struct GOOWindow *GOO_OpenWindowTags(struct Screen *Screen,
        TagList, ...)

   @{b}FUNCTION@{ub}
    Opens a standard Intuition window, but with properties favoured
    by the Goo system.  Miscellanous things can also be set for the
    window and other stuff specific to the GOOWindow structure.

   @{b}INPUTS@{ub}
    Screen - the screen the window should open on
    TagList - a list of tags to open the window with your options

   @{b}RESULT@{ub}
    struct GOOWindow - pointer to a GOOWindow structure; read-only!

   @{b}NOTES@{ub}
    Suppling no tags (i.e. {TAG_DONE}) results in this function failing.
    Be aware that some tags may change some SCREEN attributes on the screen
    that you want to open the window on - this warning only really applies
    when using public screens.
    WA_AutoAdjust tag is set to ON so set it to off if you don't want it.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_CloseWindow, Goo.o/GOO_SetWindowAttrs

@endnode

@node "GOO_RefreshObject" "Goo.o/GOO_RefreshObject"

   @{b}NAME    @{ub}
    GOO_RefreshObject - refreshs an individual object on a window

   @{b}SYNOPSIS@{ub}
    void GOO_RefreshObject(struct GOOWindow *GOOWindow, ULONG ID)

   @{b}FUNCTION@{ub}
    Redraws a single object on a GOOWindow.  Anything where the object's
    due to be refreshed in the rastport, is overwritten.

   @{b}INPUTS@{ub}
    GOOWindow - the window where objects are
    ID - the ID of the object to refresh

   @{b}NOTES@{ub}
    Using ID of (ULONG)~0 is private!
    Passing NULL for GOOWindow is safe.
    Passing 0 for ID isn't normal - use a real number like 1.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_RefreshObjects, Goo.o/GOO_NewObject

@endnode

@node "GOO_RefreshObjects" "Goo.o/GOO_RefreshObjects"

   @{b}NAME    @{ub}
    GOO_RefreshObjects - redraws objects on the specified window

   @{b}SYNOPSIS@{ub}
    void GOO_RefreshObjects(struct GOOWindow *GOOWindow, BOOL AllowClear)

   @{b}FUNCTION@{ub}
    Redraws all the objects attached to a GOOWindow.  If AllowClear is
    specified, the window will be covered in a filled rectangle before
    the objects are drawn.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a valid GOOWindow structure or NULL
    AllowClear - see above

   @{b}RESULT@{ub}
    A refreshed/redrawn window with objects.

   @{b}NOTES@{ub}
    If GOOWindow is NULL, this function does nothing.
    If GOOWindow has no objects, this function does nothing.
    This routine is best done when the window is originally opened, and
    calls to GOO_RefreshObject() would be better suited to each object
    when the window is open.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_RefreshObject, Goo.o/GOO_OpenWindow, Goo.o/GOO_NewObject

@endnode

@node "GOO_ReplyIMsg" "Goo.o/GOO_ReplyIMsg"

   @{b}NAME    @{ub}
    GOO_ReplyIMsg - removes a message from a previous GOO_GetIMsg

   @{b}SYNOPSIS@{ub}
    void GOO_ReplyIMsg(struct GOOIMsg *IMsg)

   @{b}FUNCTION@{ub}
    Replies and frees up a previously obtained pointer to an GOOIMsg
    structure using GOO_GetIMsg().

   @{b}INPUTS@{ub}
    IMsg - pointer to an GOOIMsg returned by GOO_GetIMsg()

   @{b}NOTES@{ub}
    Passing NULL as IMsg is safe.  Don't attempt to read from the
    GOOIMsg structure after you've replied to it.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_GetIMsg, Goo.o/GOO_WaitIMsg, exec.library/ReplyMsg,
        gadtools.library/GT_ReplyIMsg

@endnode

@node "GOO_SetInternal" "Goo.o/GOO_SetInternal"

   @{b}NAME    @{ub}
    GOO_SetInternal - sets an internal preference varible

   @{b}SYNOPSIS@{ub}
    LONG GOO_SetInternal(ULONG Varible, LONG Value)

   @{b}FUNCTION@{ub}
    GOO has an internal (private) structure which has some varibles that
    appliprog can change to alter how GOO works in some respects.  Only
    one varible may be changed at once, since the varible you change may
    effect the whole Goo subsystem.

   @{b}INPUTS@{ub}
    Varible - which varible you want to change; see Goo.h for a list
    Value - what you want to change the varible to

   @{b}RESULT@{ub}
    Returns the previous value of Varible before you changed it or NULL
    if Varible is private data or unknown.

   @{b}NOTES@{ub}
    Any varible you may change will not effect any objects or windows you
    have created before you call this routine.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_GetInternal, Goo.h

@endnode

@node "GOO_SetObjectAttrs" "Goo.o/GOO_SetObjectAttrs"

   @{b}NAME    @{ub}
    GOO_SetObjectAttrs - change some characteristics for an object

   @{b}SYNOPSIS@{ub}
    BOOL GOO_SetObjectAttr(struct GOOWindow *GOOWindow, ULONG ID,
                            struct TagItem *TagList)
    BOOL GOO_SetObjectAttrTags(struct GOOWindow *GOOWindow, ULONG ID, ...)

   @{b}FUNCTION@{ub}
    Allows appliprog to change certain things about an object after the
    object has been created using GOO_NewObject().  Note that not
    everything can change for an object, and it also depends on whether
    or not an object has anything to change or set.  Use the same tags
    as you would for GOO_NewObject() to specify what you want to change.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a GOOWindow structure that has some objects
    ID - the ID of the object you want to change
    TagList - list of tags to change as per GOO_NewObject()

   @{b}RESULT@{ub}
    Always TRUE at the moment.

   @{b}NOTES@{ub}
    Not all tags support changing values after the object has been 
    created.
    If GOOWindow has no objects, GOOWindow is NULL or ID is NULL or 0,
    this routine does nothing.
    After attributes are changed (if any), the object is NOT refreshed
    unless you specify so using the tag GOOTAG_RefreshWhenDone, TRUE.

   @{b}BUGS@{ub}
    This routine always returns TRUE for now, but may return FALSE
    at a later date to tell appliprog that no changes were done to the
    object.

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_NewObject, Goo.o/GOO_GetObjectAttr

@endnode

@node "GOO_WaitIMsg" "Goo.o/GOO_WaitIMsg"

   @{b}NAME    @{ub}
    GOO_WaitIMsg - wait for a GOOIMsg from a window

   @{b}SYNOPSIS@{ub}
    struct GOOIMsg *GOO_WaitIMsg(struct GOOWindow *GOOWindow)

   @{b}FUNCTION@{ub}
    Waits on a GOOWindow's userport until a message appears on it,
    and then returns the a GOOIMsg structure based on the message
    received.  See GOO_GetIMsg for more info on the GOOIMsg struct.

   @{b}INPUTS@{ub}
    GOOWindow - pointer to a GOOWindow structure

   @{b}RESULT@{ub}
    Returns an GOOIMsg structure or NULL.  Don't forget to reply to
    the message and be able to handle a NULL return!

   @{b}EXAMPLE@{ub}
    The following example details how to handle this routine correctly.

    ...
    struct GOOIMsg *Msg;
    struct GOOWindow *GOOWindow;
    ...
        if(Msg = GOO_WaitIMsg(GOOWindow))
        {
            while(Msg)
            {
                /* get the data from the GOOIMsg here */
                GOO_ReplyIMsg(Msg);
                ...
                /* your message processing here */
                ...
                /* get the next message */
                Msg = GOO_GetIMsg(GOOWindow);
            }
        }

   @{b}WARNING@{ub}
    This function will wait forever if no messages arrive at the window!

   @{b}NOTES@{ub}
    Passing NULL in GOOWindow returns NULL.
    If a message is at the port when this function gets called, it
    will immediately return with it and not wait.  Remember that more than
    one message could be waiting at the port - as with standard Intuition
    and GadTools methods.

   @{b}BUGS@{ub}

   @{b}SEE ALSO@{ub}
    Goo.o/GOO_GetIMsg, Goo.o/GOO_ReplyIMsg, exec.library/WaitPort

@endnode

@remark God that was boring.
