head	1.2;
branch	1.2.1.99;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	93.02.08.01.32.20;	author jason;	state Exp;
branches
	1.2.1.1;
next	;

1.2.1.1
date	94.03.29.05.41.32;	author jason;	state Exp;
branches;
next	1.2.1.2;

1.2.1.2
date	94.04.06.02.42.55;	author jason;	state Exp;
branches;
next	1.2.1.3;

1.2.1.3
date	94.09.13.03.53.54;	author jason;	state Exp;
branches;
next	1.2.1.4;

1.2.1.4
date	94.11.16.06.31.09;	author jason;	state Exp;
branches;
next	1.2.1.5;

1.2.1.5
date	94.11.18.07.49.22;	author jason;	state Exp;
branches;
next	1.2.1.6;

1.2.1.6
date	94.12.09.05.29.56;	author jason;	state Exp;
branches;
next	;


desc
@initialization and window handling
@


1.2
log
@Initial RCS Version
@
text
@#define NOT_EXTERN
#include"agl.h"

#define BORDERSIZEX	4	/* displace lower left for border */
#define BORDERSIZEY	2

short NextWindow_Initialized=FALSE,Gfx_Initialized=FALSE;
struct Library *ConsoleDevice,*DiskfontBase;


/*******************************************************************************
void	gversion(char *string)

*******************************************************************************/
/*PROTOTYPE*/
void gversion(char *string)
	{
	sprintf(string,"GLAMECS-1.0");
	}


/*******************************************************************************
long	getgdesc(long inquiry)

*******************************************************************************/
/*PROTOTYPE*/
long getgdesc(long inquiry)
	{
	long value=0;

	switch(inquiry)
		{
		case GD_XPMAX:
			value=SCREENX;
			break;
		case GD_YPMAX:
			value=SCREENY;
			break;
		case GD_BITS_NORM_SNG_CMODE:
			value=SCREENDEPTH;
			break;
		case GD_BITS_NORM_DBL_CMODE:
			value=SCREENDEPTH;
			break;
		case GD_NVERTEX_POLY:
			value=MAX_POLY_VERTS;
			break;
	 	}

	return value;
	}


/******************************************************************************
void	doublebuffer(void)

******************************************************************************/
/*PROTOTYPE*/
void doublebuffer(void)
	{
	DoubleBuffered[CurrentWid]=TRUE;
	}


/******************************************************************************
void	singlebuffer(void)

******************************************************************************/
/*PROTOTYPE*/
void singlebuffer(void)
	{
	DoubleBuffered[CurrentWid]=FALSE;
	}


/******************************************************************************
long	getdisplaymode(void)

	0 = RGB single
	1 = single
	2 = double
	5 = RGB double
******************************************************************************/
/*PROTOTYPE*/
long getdisplaymode(void)
	{
	return 1+DoubleBuffered[CurrentWid];
	}


/*******************************************************************************
void	gconfig(void)

*******************************************************************************/
/*PROTOTYPE*/
void gconfig(void)
	{
	long d,dd,abort=FALSE;

	if(DoubleBuffered[CurrentWid] && !DoubleBufferSet[CurrentWid])
		{
		memcpy(&BackRPort[CurrentWid],GLWindow[CurrentWid]->RPort,sizeof(struct RastPort));

		InitBitMap(&BackBitMap[CurrentWid],SCREENDEPTH,SCREENX,SCREENY);
		for(d=0;d<SCREENDEPTH && !abort;d++)
			if((BackBitMap[CurrentWid].Planes[d]=(PLANEPTR)AllocRaster(SCREENX,SCREENY))==NULL)
				abort=TRUE;

		if(abort)
			{
			GL_error("Could not allocate backbuffer");

			for(dd=0;dd<d-1;dd++)
				FreeRaster(BackBitMap[CurrentWid].Planes[dd],SCREENX,SCREENY);
			}
		else
			{
			BackRPort[CurrentWid].BitMap= &BackBitMap[CurrentWid];
			DoubleBufferSet[CurrentWid]=TRUE;
			}
		}

	if(!DoubleBuffered[CurrentWid] && DoubleBufferSet[CurrentWid])
		{
		for(d=0;d<SCREENDEPTH;d++)
			FreeRaster(BackBitMap[CurrentWid].Planes[d],SCREENX,SCREENY);

		DoubleBufferSet[CurrentWid]=FALSE;
		}

	set_rasterport();
	}


/*******************************************************************************
void	swapbuffers(void)

*******************************************************************************/
/*PROTOTYPE*/
void swapbuffers(void)
	{
	if(DoubleBuffered[CurrentWid])
		{
/*
		OwnBlitter();
		WaitBlit();
		BltBitMap(DrawRPort->BitMap,0,0,VisibleRPort->BitMap,0,0,CurrentWidth,CurrentHeight,0xC0,0xFF,NULL);
		DisownBlitter();
*/
		ClipBlit(DrawRPort,0,0,VisibleRPort,0,0,CurrentWidth,CurrentHeight,0xC0);
		}
/*
	else
		GL_error("swapbuffers() called in single buffer mode");
*/
	}


/*******************************************************************************
void	set_rasterport(void)

*******************************************************************************/
/*PROTOTYPE*/
void set_rasterport(void)
	{
	VisibleRPort=GLWindow[CurrentWid]->RPort;

	if(DoubleBuffered[CurrentWid])
		DrawRPort= &BackRPort[CurrentWid];
	else
		DrawRPort=VisibleRPort;
	}


/*******************************************************************************
void	winpush(void)

*******************************************************************************/
/*PROTOTYPE*/
void winpush(void)
	{
	WindowToBack(GLWindow[CurrentWid]);
	}


/*******************************************************************************
void	winpop(void)

*******************************************************************************/
/*PROTOTYPE*/
void winpop(void)
	{
	WindowToFront(GLWindow[CurrentWid]);
	}


/*******************************************************************************
long	winget(void)

*******************************************************************************/
/*PROTOTYPE*/
long winget(void)
	{
	return CurrentWid;
	}


/*******************************************************************************
void	winset(long wid)

*******************************************************************************/
/*PROTOTYPE*/
void winset(long wid)
	{
	static char string[100];

	if(GLWindow[wid]==NULL)
		{
		if(wid)
			{
			sprintf(string,"winset(%d): window not open",wid);
			GL_error(string);
			}

		CurrentWid=0;
		}
	else
		{
		CurrentWid=wid;

		set_rasterport();
		get_dimensions(CurrentWid,&CurrentPosX,&CurrentPosY,&CurrentWidth,&CurrentHeight);
		}
	}


/******************************************************************************
short	get_dimensions(long wid,long *x,long *y,long *lenx,long *leny)

	returns 0 if window is not opened
******************************************************************************/
/*PROTOTYPE*/
short get_dimensions(long wid,long *x,long *y,long *lenx,long *leny)
	{
	if(GLWindow[wid]==NULL)
		return 0;

	if(GLWindow[wid]->Flags & BORDERLESS)
		{
		*lenx=GLWindow[wid]->Width;
		*leny=GLWindow[wid]->Height;
		}
	else
		{
		*lenx=GLWindow[wid]->GZZWidth;
		*leny=GLWindow[wid]->GZZHeight;
		}

	*x=GLWindow[wid]->LeftEdge+GLWindow[wid]->BorderLeft;
	*y=GLWindow[wid]->TopEdge+GLWindow[wid]->BorderTop;

	*y=SCREENY-1-(*y)- *leny;

	return 1;
	}


/*******************************************************************************
void	sleep(long seconds)

*******************************************************************************/
/*PROTOTYPE*/
void sleep(long seconds)
	{
	Delay(60*seconds);
	}


/*******************************************************************************
void	micropause(void)

*******************************************************************************/
/*PROTOTYPE*/
void micropause(void)
	{
	Delay(5);
	}


/*******************************************************************************
void	prefposition(long x1,long x2,long y1,long y2)

*******************************************************************************/
/*PROTOTYPE*/
void prefposition(long x1,long x2,long y1,long y2)
	{
	if(!NextWindow_Initialized)
		initialize_nextwindow();

	NextWindow.LeftEdge=x1;
	NextWindow.Width=	x2-x1+1;

	NextWindow.TopEdge=	SCREENY-1-y2;
	NextWindow.Height=	y2-y1+1;

/*
printf("X %3d   %3d  Y %3d   %3d\n",x1,x2,y1,y2);
printf("L %3d W %3d  T %3d H %3d\n\n",NextWindow.LeftEdge,NextWindow.Width,
																	NextWindow.TopEdge,NextWindow.Height);
*/
	}


/*******************************************************************************
void	noborder(void)

*******************************************************************************/
/*PROTOTYPE*/
void noborder(void)
	{
	if(!NextWindow_Initialized)
		initialize_nextwindow();

	NextWindow.Flags|=BORDERLESS;
	}


/******************************************************************************
void	winposition(long x1,long x2,long y1,long y2)

******************************************************************************/
/*PROTOTYPE*/
void winposition(long x1,long x2,long y1,long y2)
	{
	long lenx,leny;

	lenx=abs(x2-x1);
	leny=abs(y2-y1);

	if(x1>x2)
		x1=x2;
	if(y1>y2)
		y1=y2;

	winmove(x1,y1);
	SizeWindow(GLWindow[CurrentWid],lenx,leny);
	}


/******************************************************************************
void	winmove(long orgx,long orgy)

******************************************************************************/
/*PROTOTYPE*/
void winmove(long orgx,long orgy)
	{
	long dx,dy;

	dx=orgx-CurrentPosX;
	dy=orgy-CurrentPosY;

	MoveWindow(GLWindow[CurrentWid],dx,-dy);
	}


/******************************************************************************
void	wintitle(char *name)

******************************************************************************/
/*PROTOTYPE*/
void wintitle(char *name)
	{
	strcpy(TitleList[CurrentWid],name);
	}


/******************************************************************************
void	getsize(long *x,long *y)

******************************************************************************/
/*PROTOTYPE*/
void getsize(long *x,long *y)
	{
	*x=CurrentWidth;
	*y=CurrentHeight;
	}


/******************************************************************************
void	getorigin(long *x,long *y)

******************************************************************************/
/*PROTOTYPE*/
void getorigin(long *x,long *y)
	{
	*x=CurrentPosX;
	*y=CurrentPosY;
	}


/*******************************************************************************
long	winopen(char *title)

*******************************************************************************/
/*PROTOTYPE*/
long winopen(char *title)
	{
	long wid=1;

	if(!NextWindow_Initialized)
		initialize_nextwindow();

	while(wid<MAX_WINDOWS && GLWindow[wid])
		wid++;

	if(wid==MAX_WINDOWS)
		{
		GL_error("Too many windows");
		return -1;
		}

	if(!Gfx_Initialized)
		gfxinit();

	DefaultWindow.Screen=GLScreen;
	NextWindow.Screen=GLScreen;

	if( !(NextWindow.Flags & BORDERLESS) )
		{
		NextWindow.Flags|= ACTIVATE | WINDOWDRAG | WINDOWCLOSE | GIMMEZEROZERO;
		NextWindow.Title=TitleList[wid];
		strcpy(NextWindow.Title,title);

		NextWindow.LeftEdge-=BORDERSIZEX;
		NextWindow.TopEdge+=BORDERSIZEY;
		}

	GLWindow[wid]=(struct Window *)OpenWindow(&NextWindow);
	if(GLWindow[wid]==NULL)
	 	{
	 	printf("Window won't open\n");
	 	CloseScreen(GLScreen);
	 	CloseLibrary((void *)IntuitionBase);
	 	CloseLibrary((void *)GfxBase);
	 	exit(400);
	 	}

	winset(wid);

	InitArea(&AInfo[wid],AreaBuffer[wid],MAX_POLY_VERTS);
	DrawRPort->AreaInfo= &AInfo[wid];
	TempBuffer[wid]=(PLANEPTR)AllocRaster(SCREENX,SCREENY);
	if(TempBuffer[wid]==NULL)
		{
		GL_error("Error alocating Poly Space");
		return -1;
		}
	DrawRPort->TmpRas=
			(struct TmpRas *)InitTmpRas(&TempRaster[wid],TempBuffer[wid],RASSIZE(SCREENX,SCREENY));

	SetDrMd(DrawRPort,JAM1);
	OneToOne[wid]=TRUE;
	Dimensions[wid]=2;

	initialize_nextwindow();

	return wid;
	}


/*******************************************************************************
void	winclose(long wid)

*******************************************************************************/
/*PROTOTYPE*/
void winclose(long wid)
	{
	char string[100];
	long temp_wid;
	short m,on;

	if(GLWindow[wid]==NULL)
		{
		sprintf(string,"cannot close unopened window %d",wid);
		GL_error(string);
		}
	else
		{
		/* remove backbuffer */
		temp_wid=CurrentWid;

		winset(wid);
		singlebuffer();
		gconfig();

		if(GLWindow[temp_wid])
			winset(temp_wid);

		FreeRaster(TempBuffer[wid],SCREENX,SCREENY);

		CloseWindow(GLWindow[wid]);
		GLWindow[wid]=NULL;
		}

	on=0;
	for(m=1;m<MAX_WINDOWS;m++)
		if(GLWindow[m])
			on=1;

	if(!on)
		{
#if MICE
		free_mousesprite();
		stop_gameport();
#endif

		CloseFont(FontPtr);
	 	CloseLibrary((void *)DiskfontBase);

		CloseScreen(GLScreen);
	 	CloseLibrary((void *)IntuitionBase);
	 	CloseLibrary((void *)GfxBase);
		}
	}


/*******************************************************************************
void	initialize_nextwindow(void)

*******************************************************************************/
/*PROTOTYPE*/
void initialize_nextwindow(void)
	{
	static short first=1;
	short m;

	if(first)
		{
		for(m=0;m<MAX_WINDOWS;m++)
			{
			GLWindow[m]=NULL;
			DoubleBuffered[m]=0;
			DoubleBufferSet[m]=0;
			}

		first=0;
		}

	memcpy(&NextWindow,&DefaultWindow,sizeof(struct NewWindow));

	NextWindow_Initialized=TRUE;
	}


/*******************************************************************************
void	gfxinit(void)

*******************************************************************************/
/*PROTOTYPE*/
void gfxinit(void)
	{
	GfxBase=(struct GfxBase *)OpenLibrary("graphics.library",0L);
	if(GfxBase==NULL)
	 	{
		GL_error("Error opening GraFiX Library\n");

	 	exit(1);
	 	}

	IntuitionBase=(struct IntuitionBase *)OpenLibrary("intuition.library",0L);
	if(IntuitionBase==NULL)
	 	{
		GL_error("Error opening Intuition Library\n");

	 	CloseLibrary((void *)GfxBase);
	 	exit(2);
	 	}

	GLScreen=(struct Screen *)OpenScreen(&ScreenDef);
	if(GLScreen==NULL)
	 	{
		GL_error("Error opening Screen\n");

	 	CloseLibrary((void *)IntuitionBase);
	 	CloseLibrary((void *)GfxBase);
	 	exit(3);
	 	}

	if(!(OpenDevice("console.device",-1L,(struct IORequest *)&IOStandardRequest,0L)))
		ConsoleDevice=(struct Library *)IOStandardRequest.io_Device;
	else
		{
		GL_error("Error Opening Console\n");

	 	CloseScreen(GLScreen);
	 	CloseLibrary((void *)IntuitionBase);
	 	CloseLibrary((void *)GfxBase);
	 	exit(4);
		}

	DiskfontBase=OpenLibrary("diskfont.library",0L);
	if(DiskfontBase==NULL)
		GL_error("Error opening Diskfont Library\n");

	FontPtr=OpenDiskFont(&StdFont);
	if(FontPtr==NULL)
		GL_error("Error Opening Font\n");

/* 	SetRast(&GLScreen->RastPort,BLUEGREEN); */

	GLView= &GLScreen->ViewPort;
	LoadRGB4(GLView,ColorMap,16);
	DrawType=FALSE;
	CurrentColor=0;
	init_matrices();

#if MICE
	start_gameport();
	create_mousesprite();
#endif

	qinit();

	Gfx_Initialized=TRUE;
	}


/*******************************************************************************
void	GL_error(char *message)

*******************************************************************************/
/*PROTOTYPE*/
void GL_error(char *message)
	{
	printf("Amiga GL Error: %s\n",message);
	}
@


1.2.1.1
log
@Added RCS Header
@
text
@a0 16

/******************************************************************************

$Id: window.c,v 1.2.1.1 2002/03/26 22:04:26 jason Exp jason $

$Log: window.c,v $
 * Revision 1.2.1.1  2002/03/26  22:04:26  jason
 * Added RCS Header
 *
 * Revision 1.2.1.1  2002/03/26  22:00:51  jason
 * RCS/agl.h,v
 *

******************************************************************************/


d34 1
a34 1
			value=ScreenDef.Width;
d37 1
a37 1
			value=ScreenDef.Height;
d40 1
a40 1
			value=ScreenDef.Depth;
d43 1
a43 1
			value=ScreenDef.Depth;
d104 3
a106 4
		InitBitMap(&BackBitMap[CurrentWid],(long)ScreenDef.Depth,(long)ScreenDef.Width,(long)ScreenDef.Height);
		for(d=0;d<ScreenDef.Depth && !abort;d++)
			if((BackBitMap[CurrentWid].Planes[d]=(PLANEPTR)AllocRaster((ULONG)ScreenDef.Width,
																	(ULONG)ScreenDef.Height))==NULL)
d114 1
a114 1
				FreeRaster(BackBitMap[CurrentWid].Planes[dd],(ULONG)ScreenDef.Width,(ULONG)ScreenDef.Height);
d125 2
a126 2
		for(d=0;d<ScreenDef.Depth;d++)
			FreeRaster(BackBitMap[CurrentWid].Planes[d],(ULONG)ScreenDef.Width,(ULONG)ScreenDef.Height);
d262 1
a262 1
	*y=ScreenDef.Height-1-(*y)- *leny;
d303 1
a303 1
	NextWindow.TopEdge=	ScreenDef.Height-1-y2;
d441 1
a441 1
	 	printf("Window won't open: \"%s\"\n",title);
d452 1
a452 1
	TempBuffer[wid]=(PLANEPTR)AllocRaster((ULONG)ScreenDef.Width,(ULONG)ScreenDef.Height);
d458 2
a459 2
	DrawRPort->TmpRas=(struct TmpRas *)
				InitTmpRas(&TempRaster[wid],TempBuffer[wid],RASSIZE(ScreenDef.Width,ScreenDef.Height));
d499 1
a499 1
		FreeRaster(TempBuffer[wid],(ULONG)ScreenDef.Width,(ULONG)ScreenDef.Height);
a554 53
/******************************************************************************
long	AGLconfig(short screenx,short screeny,short bitplanes)

	this the only AGL specific command

	it configures the screen for all windows to use

	returns TRUE if sucessful, ie. no GL command had been previously issued

******************************************************************************/
/*PROTOTYPE*/
long AGLconfig(short screenx,short screeny,short bitplanes)
	{
	if(Gfx_Initialized)
		{
		GL_error("AGLconfig(): must be called before all GL commands\n");
		return FALSE;
		}
	else
		{
		ScreenDef.ViewModes=NULL;

		if(bitplanes>5)
			bitplanes=5;

		if(screenx>360)
			{
			ScreenDef.ViewModes|=HIRES;

			if(screenx>720)
				screenx=720;

			if(bitplanes>4)
				bitplanes=4;
			}

		if(screeny>225)
			{
			ScreenDef.ViewModes|=LACE;

			if(screeny>450)
				screeny=450;
			}

		ScreenDef.Width=screenx;
		ScreenDef.Height=screeny;
		ScreenDef.Depth=bitplanes;

		return TRUE;
		}
	}


a561 4
	long colors;

	colors=pow(2.0,(float)ScreenDef.Depth);

d612 1
a612 1
	LoadRGB4(GLView,ColorMap,colors);
@


1.2.1.2
log
@winset() calls reset_matrix_pointers()
@
text
@d4 1
a4 1
$Id: window.c,v 1.2.1.1 1994/03/29 05:41:32 jason Exp jason $
a6 3
 * Revision 1.2.1.1  1994/03/29  05:41:32  jason
 * Added RCS Header
 *
a249 2

		reset_matrix_pointers();
@


1.2.1.3
log
@use true double-buffering for single window
added prefsize
added minsize(), maxsize()
fixed border corrections
@
text
@d4 1
a4 1
$Id: window.c,v 1.2.1.2 1994/04/06 02:42:55 jason Exp $
a6 3
 * Revision 1.2.1.2  1994/04/06  02:42:55  jason
 * winset() calls reset_matrix_pointers()
 *
d23 2
a24 4
#define BORDERSIZEX	4		/* displace lower left for border */
#define BORDERSIZEY	11

#define BORDERSIZE_TITLEY	12
d27 1
a27 3
short NumberWindows=0;

struct Library *ConsoleDevice,*DiskfontBase,*LayersBase;
a161 2
	struct BitMap *swap;

a163 16
		if(NumberWindows==1)
			{
			MakeScreen(GLScreen);
			RethinkDisplay();

			swap=VisibleRPort->BitMap;
			VisibleRPort->BitMap=DrawRPort->BitMap;
			DrawRPort->BitMap=swap;

			GLScreen->RastPort.BitMap=swap;
			GLScreen->ViewPort.RasInfo->BitMap=swap;
/* 			GLWindow[CurrentWid]->RPort->BitMap=swap; */
			}
		else
			{
			deactivate_clipping();
d165 4
a168 4
			OwnBlitter();
			WaitBlit();
			BltBitMap(DrawRPort->BitMap,0,0,VisibleRPort->BitMap,0,0,CurrentWidth,CurrentHeight,0xC0,0xFF,NULL);
			DisownBlitter();
d170 1
a170 4
			ClipBlit(DrawRPort,0,0,VisibleRPort,0,0,CurrentWidth,CurrentHeight,0xC0);

			activate_clipping();
			}
d172 1
d175 1
d301 2
a302 2
/******************************************************************************
void	minsize(long x,long y)
d304 1
a304 1
******************************************************************************/
d306 1
a306 1
void minsize(long x,long y)
d308 1
a308 14
	NextWindow.MinWidth=x;
	NextWindow.MinHeight=y;
	}


/******************************************************************************
void	maxsize(long x,long y)

******************************************************************************/
/*PROTOTYPE*/
void maxsize(long x,long y)
	{
	NextWindow.MaxWidth=x;
	NextWindow.MaxHeight=y;
a327 3
	if(NextWindow.Flags&WINDOWSIZING)
		NextWindow.Flags^=WINDOWSIZING;

d329 3
a331 3
	printf("X %3d   %3d  Y %3d   %3d\n",x1,x2,y1,y2);
	printf("L %3d W %3d  T %3d H %3d\n\n",NextWindow.LeftEdge,NextWindow.Width,
															NextWindow.TopEdge,NextWindow.Height);
a335 13
/******************************************************************************
void	prefsize(long x,long y)

******************************************************************************/
/*PROTOTYPE*/
void prefsize(long x,long y)
	{
	prefposition(BORDERSIZEX,BORDERSIZEX+x-1,1,1+y-1);

	NextWindow.Flags|=WINDOWSIZING;
	}


d457 1
a457 4
		NextWindow.TopEdge-=BORDERSIZEY;

		NextWindow.Height+=BORDERSIZE_TITLEY;
		NextWindow.Width+=BORDERSIZEX*2;
a479 1

d484 1
a484 3

	ortho2(-0.5,CurrentWidth-0.5,-0.5,CurrentHeight-0.5);
	viewport(0,CurrentWidth-1,0,CurrentHeight-1);
a488 2
	NumberWindows++;

a492 21
/******************************************************************************
void	kill_AGL(void)

	set as trap to occur on completion of execution

	closes all opened windows
	should result in complete release of all of AGL's resources
******************************************************************************/
/*PROTOTYPE*/
void kill_AGL(void)
	{
	long m;

	printf("KILL AGL\n");

	for(m=1;m<MAX_WINDOWS;m++)
		if(GLWindow[m])
			winclose(m);
	}


a503 2
	NumberWindows--;

d564 2
a565 3
			DoubleBuffered[m]=FALSE;
			DoubleBufferSet[m]=FALSE;
			Clipped[m]=FALSE;
d568 1
a568 1
		first=FALSE;
d599 4
a602 1
		if(screeny>225)
d604 1
a604 1
			printf("HiRes Lace\n");
a608 3
			if(screeny>450)
				screeny=450;

d611 1
d613 2
a614 1
			ScreenDef.ViewModes|=HIRES;
a615 6
			}
		else
			{
			printf("LoRes\n");
			if(screenx>360)
				screenx=360;
d617 2
a618 5
			if(screeny>225)
				screeny=225;

			if(bitplanes>5)
				bitplanes=5;
a632 2
	startup AGL and initialize all it's resources

a657 10
	LayersBase=OpenLibrary("layers.library",0L);
	if(LayersBase==NULL)
	 	{
		GL_error("Error opening Intuition Library\n");

	 	CloseLibrary((void *)IntuitionBase);
	 	CloseLibrary((void *)GfxBase);
	 	exit(3);
	 	}

a662 1
	 	CloseLibrary((void *)LayersBase);
d665 1
a665 1
	 	exit(4);
a674 1
	 	CloseLibrary((void *)LayersBase);
d677 1
a677 1
	 	exit(5);
a703 4

	/* set an exit trap */
	if(atexit(kill_AGL))
		GL_error("Error setting exit trap\n");
@


1.2.1.4
log
@added border support
fixed double-buffering
@
text
@d4 1
a4 1
$Id: window.c,v 1.2.1.3 1994/09/13 03:53:54 jason Exp jason $
a6 6
 * Revision 1.2.1.3  1994/09/13  03:53:54  jason
 * use true double-buffering for single window
 * added prefsize
 * added minsize(), maxsize()
 * fixed border corrections
 *
a25 2
#define COOL_BORDERS	TRUE

d31 1
a31 4
short NextWindow_Initialized=FALSE;
short NextBordered=TRUE;
short NextSizeable=TRUE;
short Gfx_Initialized=FALSE;
a80 22
void	cmode(void)

******************************************************************************/
/*PROTOTYPE*/
void cmode(void)
	{
	RGBmodeOn[CurrentWid]=FALSE;
	}


/******************************************************************************
void	RGBmode(void)

******************************************************************************/
/*PROTOTYPE*/
void RGBmode(void)
	{
	RGBmodeOn[CurrentWid]=TRUE;
	}


/******************************************************************************
a116 51
/******************************************************************************
void	clone_new_bitmap(void)

	if true double-buffing (single window), copy visible bitmap to drawbuffer
	intended to update window borders and screen background in backbuffer
******************************************************************************/
/*PROTOTYPE*/
void clone_new_bitmap(void)
	{
	struct BitMap *old_bitmap;

	if(NumberWindows==1 && DoubleBufferSet[CurrentWid])
		{

#if FALSE
		BltBitMap(
					&BackBitMap[CurrentWid],0,0,
					GLScreen->RastPort.BitMap,0,0,
											(long)ScreenDef.Width,(long)ScreenDef.Height,0xC0,0xFF,NULL);

		old_bitmap=GLWindow[CurrentWid]->RPort->BitMap;
		memcpy(GLWindow[CurrentWid]->RPort,&BackRPort[CurrentWid],sizeof(struct RastPort));

		GLWindow[CurrentWid]->RPort->BitMap=old_bitmap;
#endif

#if FALSE
		BltBitMap(
					GLScreen->RastPort.BitMap,0,0,
					&BackBitMap[CurrentWid],0,0,
										(long)ScreenDef.Width,(long)ScreenDef.Height,0xC0,0xFF,NULL);

		old_bitmap=BackRPort[CurrentWid].BitMap;
		memcpy(&BackRPort[CurrentWid],GLWindow[CurrentWid]->RPort,sizeof(struct RastPort));
		BackRPort[CurrentWid].BitMap=old_bitmap;
#endif

#if TRUE
		BltBitMap(
					VisibleRPort->BitMap,0,0,
					DrawRPort->BitMap,0,0,
										(long)ScreenDef.Width,(long)ScreenDef.Height,0xC0,0xFF,NULL);

		old_bitmap=DrawRPort->BitMap;
		memcpy(DrawRPort,VisibleRPort,sizeof(struct RastPort));
		DrawRPort->BitMap=old_bitmap;
#endif
		}
	}


d130 1
a130 2
		InitBitMap(&BackBitMap[CurrentWid],(long)ScreenDef.Depth,
															(long)ScreenDef.Width,(long)ScreenDef.Height);
a131 1
			{
a135 11
/* 			clone_new_bitmap(); */

			BltBitMap(
						GLScreen->RastPort.BitMap,0,0,
						&BackBitMap[CurrentWid],0,0,
											(long)ScreenDef.Width,(long)ScreenDef.Height,0xC0,0xFF,NULL);

			memcpy(&BackRPort[CurrentWid],GLWindow[CurrentWid]->RPort,sizeof(struct RastPort));
			BackRPort[CurrentWid].BitMap= &BackBitMap[CurrentWid];
			}

d141 1
a141 2
				FreeRaster(BackBitMap[CurrentWid].Planes[dd],
														(ULONG)ScreenDef.Width,(ULONG)ScreenDef.Height);
a157 2
	RGBmodeSet[CurrentWid]=RGBmodeOn[CurrentWid];

a170 2
	long x,y;

a174 4
			/* make sure any window movements/sizing taken care of */
			update_queue(-1);

			/* update to make visible */
a177 1
			/* swap bitmaps */
a179 4

			if(DrawRPort->BitMap==swap)
				GL_error("swapbuffers() software error, bitmaps are the same");

d184 1
a184 8

			GLWindow[CurrentWid]->RPort->BitMap=VisibleRPort->BitMap;

			if(RedoBorder[CurrentWid])
				{
				drawborder(CurrentWid);
				RedoBorder[CurrentWid]=FALSE;
				}
d188 1
a188 1
			deactivate_clipping(CurrentWid);
d192 1
a192 2
			BltBitMap(DrawRPort->BitMap,0,0,VisibleRPort->BitMap,0,0,CurrentWidth,CurrentHeight,
																						0xC0,0xFF,NULL);
d195 1
a195 12
			if(COOL_BORDERS && Bordered[CurrentWid])
				{
				x=BorderWidth;
				y=BorderWidth+BorderHeight;
				}
			else
				{
				x=0;
				y=0;
				}

			ClipBlit(DrawRPort,x,y,VisibleRPort,x,y,CurrentWidth,CurrentHeight,0xC0);
d197 1
a197 1
			activate_clipping(CurrentWid);
d278 1
a278 1
		get_dimensions(CurrentWid,FALSE,&CurrentPosX,&CurrentPosY,&CurrentWidth,&CurrentHeight);
d286 1
a286 1
short	get_dimensions(long wid,long whole,long *x,long *y,long *lenx,long *leny)
d288 1
a288 3
	if whole==TRUE, get whole window dimensions including border

	returns FALSE if window is not opened
d291 1
a291 1
short get_dimensions(long wid,long whole,long *x,long *y,long *lenx,long *leny)
d294 1
a294 1
		return FALSE;
d296 1
a296 1
	if(COOL_BORDERS || !Bordered[wid])
d310 1
a310 3
	*y=ScreenDef.Height-(*y)- *leny;

#if COOL_BORDERS
d312 1
a312 12
	if(Bordered[wid] && !whole)
		{
		*x+=BorderWidth;
		*y+=BorderWidth;

		*lenx-=2*BorderWidth;
		*leny-=2*BorderWidth+BorderHeight;
		}

#endif

	return TRUE;
a374 1
	NextSizeable=FALSE;
a384 9
	if(!NextWindow_Initialized)
		initialize_nextwindow();

#if COOL_BORDERS

	prefposition(BorderWidth,BorderWidth+x-1,BorderWidth,BorderWidth+BorderHeight+y-1);

#else

a387 4

#endif

	NextSizeable=TRUE;
a400 4
	NextBordered=FALSE;

#if !COOL_BORDERS

a401 2

#endif
d412 1
a412 7
	long posx,posy,lenx,leny;
	long sizex,sizey;

/* 	printf("\nwinposition(%d,%d,%d,%d)\n",x1,x2,y1,y2); */

	get_dimensions(CurrentWid,FALSE,&posx,&posy,&lenx,&leny);
	posy=ScreenDef.Height-posy-leny;
d414 2
a415 10
/* 	printf(" %d,%d %d,%d\n",posx,posy,lenx,leny); */

	sizex=abs(x2-x1)-lenx;
	sizey=abs(y2-y1)-leny;

	lenx+=sizex;
	leny+=sizey;

	y1=ScreenDef.Height-y1-leny;
	y2=ScreenDef.Height-y2-leny;
d419 1
a419 1
	if(y1<y2)
d422 2
a423 17
	x1-=posx;
	y1-=posy;

/* 	printf(" %d,%d+%d,%d %d,%d+%d,%d\n",posx,posy,x1,y1,lenx,leny,sizex,sizey); */

	/* in two passes to prevent possible crossing of screen borders */
	do_move_and_resize(CurrentWid,x1<0,x1,0,sizex,0);
	do_move_and_resize(CurrentWid,y1<0,0,y1,0,sizey);

	winset(CurrentWid);

	get_dimensions(CurrentWid,FALSE,&posx,&posy,&lenx,&leny);
/* 	printf(" %d,%d %d,%d ->",posx,posy,lenx,leny); */

	posy=ScreenDef.Height-posy-leny;

/* 	printf("%d\n",posy); */
d439 1
a439 5
	do_move_and_resize(CurrentWid,FALSE,dx,-dy,0,0);

	winset(CurrentWid);

/* 	MoveWindow(GLWindow[CurrentWid],dx,-dy); */
a450 5

	drawborder(CurrentWid);

	if(NumberWindows==1 && DoubleBufferSet[CurrentWid])
		RedoBorder[CurrentWid]=TRUE;
d505 1
a505 12
	Sizeable[wid]=NextSizeable;
	Bordered[wid]=NextBordered;
	NextSizeable=TRUE;
	NextBordered=TRUE;
	
#if COOL_BORDERS

	NextWindow.Flags|=BORDERLESS;

#endif

	if(Bordered[wid])
a506 10
#if COOL_BORDERS

		NextWindow.LeftEdge-=BorderWidth;
		NextWindow.TopEdge-=BorderWidth+BorderHeight;

		NextWindow.Width+=BorderWidth*2;
		NextWindow.Height+=BorderHeight+BorderWidth*2;

#else

d508 2
a515 6

		NextWindow.Title=TitleList[wid];

#endif

		strcpy(TitleList[wid],title);
a543 2
	Dimensions[wid]=2;

a544 4

	if(Bordered[wid])
		drawborder(wid);

d546 1
d557 1
a557 1
void	gexit(void)
d565 1
a565 1
void gexit(void)
d625 1
a625 2
		if(FontPtr)
			CloseFont(FontPtr);
a646 3
		BorderWidth=4;
		BorderHeight=11;

a649 2
			Bordered[m]=FALSE;
			RedoBorder[m]=FALSE;
d688 1
a688 1
/* 			printf("HiRes Lace\n"); */
d704 1
a704 2
/* 			printf("LoRes\n"); */

a802 1
	initialize_RGB();
d814 1
a814 1
	if(atexit(gexit))
@


1.2.1.5
log
@added foreground() check
@
text
@d4 1
a4 1
$Id: window.c,v 1.2.1.4 1994/11/16 06:31:09 jason Exp jason $
a6 4
 * Revision 1.2.1.4  1994/11/16  06:31:09  jason
 * added border support
 * fixed double-buffering
 *
a44 2
short Foregrounded=FALSE;

a91 11
void	foreground(void)

******************************************************************************/
/*PROTOTYPE*/
void foreground(void)
	{
	Foregrounded=TRUE;
	}


/******************************************************************************
a688 7

	if(!Foregrounded)
		{
		GL_error("AGL cannot background process: foreground() assumed");

		Foregrounded=TRUE;
		}
@


1.2.1.6
log
@fixed bitmap crashes
@
text
@d1 1
d4 1
a4 4
Copyright © 1994 Jason Weber
All Rights Reserved

$Id: window.c,v 1.2.1.5 1994/11/18 07:49:22 jason Exp jason $
a6 3
 * Revision 1.2.1.5  1994/11/18  07:49:22  jason
 * added foreground() check
 *
d77 1
a77 1
			value=ScreenWidth;
d80 1
a80 1
			value=ScreenHeight;
d83 1
a83 1
			value=ScreenDeep;
d86 1
a86 1
			value=ScreenDeep;
d185 1
a185 1
											(long)ScreenWidth,(long)ScreenHeight,0xC0,0xFF,NULL);
d197 1
a197 1
										(long)ScreenWidth,(long)ScreenHeight,0xC0,0xFF,NULL);
d208 1
a208 1
										(long)ScreenWidth,(long)ScreenHeight,0xC0,0xFF,NULL);
a209 1
/*
a212 1
*/
d231 3
a233 2
		InitBitMap(&BackBitMap[CurrentWid],(long)ScreenDeep,(long)ScreenWidth,(long)ScreenHeight);
		for(d=0;d<ScreenDeep && !abort;d++)
d235 2
a236 2
			if((BackBitMap[CurrentWid].Planes[d]=(PLANEPTR)AllocRaster((ULONG)ScreenWidth,
																	(ULONG)ScreenHeight))==NULL)
d238 10
d256 1
a256 1
														(ULONG)ScreenWidth,(ULONG)ScreenHeight);
a259 9
/* 			clone_new_bitmap(); */

			BltBitMap(
						GLScreen->RastPort.BitMap,0,0,
						&BackBitMap[CurrentWid],0,0,
											(long)ScreenWidth,(long)ScreenHeight,0xC0,0xFF,NULL);

/* 			memcpy(&BackRPort[CurrentWid],GLWindow[CurrentWid]->RPort,sizeof(struct RastPort)); */

d267 2
a268 2
		for(d=0;d<ScreenDeep;d++)
			FreeRaster(BackBitMap[CurrentWid].Planes[d],(ULONG)ScreenWidth,(ULONG)ScreenHeight);
d313 1
a313 1
/* 			GLWindow[CurrentWid]->RPort->BitMap=VisibleRPort->BitMap; */
d317 1
a317 1
				drawborder(CurrentWid,0);
d328 1
a328 1
																					0xC0,0xFF,NULL);
d459 1
a459 1
	*y=ScreenHeight-(*y)- *leny;
d526 1
a526 1
	NextWindow.TopEdge=	ScreenHeight-1-y2;
d600 1
a600 1
	posy=ScreenHeight-posy-leny;
d604 2
a605 2
	sizex=abs(x2-x1)+1-lenx;
	sizey=abs(y2-y1)+1-leny;
d610 2
a611 2
	y1=ScreenHeight-y1-leny;
	y2=ScreenHeight-y2-leny;
d632 1
a632 1
	posy=ScreenHeight-posy-leny;
d667 1
a667 1
	drawborder(CurrentWid,0);
a735 5

	Maximization[wid][0]=BorderWidth;
	Maximization[wid][1]=BorderWidth;
	Maximization[wid][2]=ScreenWidth-2*BorderWidth;
	Maximization[wid][3]=ScreenHeight-2*BorderWidth-BorderHeight;
d784 1
a784 1
	TempBuffer[wid]=(PLANEPTR)AllocRaster((ULONG)ScreenWidth,(ULONG)ScreenHeight);
d792 1
a792 1
				InitTmpRas(&TempRaster[wid],TempBuffer[wid],RASSIZE(ScreenWidth,ScreenHeight));
d801 1
a801 1
		drawborder(wid,0);
d864 1
a864 1
		FreeRaster(TempBuffer[wid],(ULONG)ScreenWidth,(ULONG)ScreenHeight);
a982 4
		ScreenWidth=ScreenDef.Width;
		ScreenHeight=ScreenDef.Height;
		ScreenDeep=ScreenDef.Depth;

d999 1
a999 1
	colors=pow(2.0,(float)ScreenDeep);
a1060 3

	ScreenWidth=GLScreen->Width;
	ScreenHeight=GLScreen->Height;
@
