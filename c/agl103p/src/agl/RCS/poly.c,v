head	1.2;
branch	1.2.1.99;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	93.02.19.01.41.33;	author jason;	state Exp;
branches
	1.2.1.1;
next	;

1.2.1.1
date	94.03.29.05.41.32;	author jason;	state Exp;
branches;
next	1.2.1.2;

1.2.1.2
date	94.04.06.02.41.16;	author jason;	state Exp;
branches;
next	1.2.1.3;

1.2.1.3
date	94.09.13.03.51.13;	author jason;	state Exp;
branches;
next	1.2.1.4;

1.2.1.4
date	94.11.16.06.25.54;	author jason;	state Exp;
branches;
next	1.2.1.5;

1.2.1.5
date	94.12.09.05.29.56;	author jason;	state Exp;
branches;
next	;


desc
@points, lines, and polygons
@


1.2
log
@Initial RCS Version
@
text
@#include"agl.h"


/******************************************************************************
void	recti(long x1,long y1,long x2,long y2)

******************************************************************************/
/*PROTOTYPE*/
void recti(long x1,long y1,long x2,long y2)
	{
	bgnline();
	rectvert((float)x1,(float)y1,(float)x2,(float)y2,TRUE);
	endline();
	}


/******************************************************************************
void	rectfi(long x1,long y1,long x2,long y2)

******************************************************************************/
/*PROTOTYPE*/
void rectfi(long x1,long y1,long x2,long y2)
	{
	if(OneToOne[CurrentWid])	/* bypass transforms if no effect */
		{
		y1=CurrentHeight-y1-1;
		y2=CurrentHeight-y2-1;

		RectFill(DrawRPort,x1,y2,x2,y1);
		return;
		}

	bgnpolygon();
	rectvert((float)x1,(float)y1,(float)x2,(float)y2,FALSE);
	endpolygon();
	}


/******************************************************************************
void	rects(short x1,short y1,short x2,short y2)

******************************************************************************/
/*PROTOTYPE*/
void rects(short x1,short y1,short x2,short y2)
	{
	bgnline();
	rectvert((float)x1,(float)y1,(float)x2,(float)y2,TRUE);
	endline();
	}


/******************************************************************************
void	rectfs(short x1,short y1,short x2,short y2)

******************************************************************************/
/*PROTOTYPE*/
void rectfs(short x1,short y1,short x2,short y2)
	{
	bgnpolygon();
	rectvert((float)x1,(float)y1,(float)x2,(float)y2,FALSE);
	endpolygon();
	}


/******************************************************************************
void	rect(float x1,float y1,float x2,float y2)

******************************************************************************/
/*PROTOTYPE*/
void rect(float x1,float y1,float x2,float y2)
	{
	bgnline();
	rectvert(x1,y1,x2,y2,TRUE);
	endline();
	}


/******************************************************************************
void	rectf(float x1,float y1,float x2,float y2)

******************************************************************************/
/*PROTOTYPE*/
void rectf(float x1,float y1,float x2,float y2)
	{
	bgnpolygon();
	rectvert(x1,y1,x2,y2,FALSE);
	endpolygon();
	}


/******************************************************************************
void	rectvert(float x1,float y1,float x2,float y2,long line)

******************************************************************************/
/*PROTOTYPE*/
void rectvert(float x1,float y1,float x2,float y2,long line)
	{
	static float vert[4][2];
	short n;

	vert[0][0]=x1;
	vert[0][1]=y1;
	vert[1][0]=x2;
	vert[1][1]=y1;
	vert[2][0]=x2;
	vert[2][1]=y2;
	vert[3][0]=x1;
	vert[3][1]=y2;

	for(n=0;n<4;n++)
		v2f(vert[n]);

	if(line)
		v2f(vert[0]);
	}


/*******************************************************************************
void	bgnpoint(void)

*******************************************************************************/
/*PROTOTYPE*/
void bgnpoint(void)
	{
	if(DrawType)
		GL_error("bgnpoint(): bad command order");

	DrawType=GL_POINT;
	}


/*******************************************************************************
void	endpoint(void)

*******************************************************************************/
/*PROTOTYPE*/
void endpoint(void)
	{
	if(DrawType!=GL_POINT)
		GL_error("endpoint(): bad command order");

	DrawType=FALSE;
	}


/*******************************************************************************
void	bgnline(void)

*******************************************************************************/
/*PROTOTYPE*/
void bgnline(void)
	{
	if(DrawType)
		GL_error("bgnline(): bad command order");

	DrawType=GL_LINE;
	BgnLine=TRUE;
	}


/*******************************************************************************
void	endline(void)

*******************************************************************************/
/*PROTOTYPE*/
void endline(void)
	{
	if(DrawType!=GL_LINE)
		GL_error("endline(): bad command order");

	DrawType=FALSE;
	}


/*******************************************************************************
void	bgnpolygon(void)

*******************************************************************************/
/*PROTOTYPE*/
void bgnpolygon(void)
	{
	if(DrawType)
		GL_error("bgnpolygon(): bad command order");

	DrawType=GL_POLYGON;
	Verts=0;
	}


/*******************************************************************************
void	endpolygon(void)

*******************************************************************************/
/*PROTOTYPE*/
void endpolygon(void)
	{
	if(DrawType!=GL_POLYGON)
		GL_error("endpolygon(): bad command order");

	AreaEnd(DrawRPort);

	DrawType=FALSE;
	}


/*******************************************************************************
void	render_vertex(short vert[2])

*******************************************************************************/
/*PROTOTYPE*/
void render_vertex(short vert[2])
	{
	long x,y;

	x=vert[0];
	y=CurrentHeight-vert[1]-1;

	switch(DrawType)
		{
		case FALSE:
			GL_error("v2s(): bad command order");
			break;
		case GL_POINT:
			WritePixel(DrawRPort,x,y);
			break;
		case GL_LINE:
			if(BgnLine)
				{
				BgnLine=FALSE;
				Move(DrawRPort,x,y);
				}
			else
				Draw(DrawRPort,x,y);
			break;
		case GL_POLYGON:
			if(Verts==MAX_POLY_VERTS)
				GL_error("Exceeded max points in polygon");
			else
				{
				if(Verts)
					AreaDraw(DrawRPort,x,y);
				else
					AreaMove(DrawRPort,x,y);
				Verts++;
				}
			break;
		}
	}


/******************************************************************************
void	mapcolor(long m,long r,long g,long b)

	maintain 256 shade standard
******************************************************************************/
/*PROTOTYPE*/
void mapcolor(long m,long r,long g,long b)
	{
	char string[100];

	if(m<0 || m>15)
		{
		sprintf(string,"mapcolor(): bad index %d",m);
		GL_error(string);
		return;
		}

	r=(r+7)/16;
	g=(g+7)/16;
	b=(b+7)/16;

	ColorMap[m]= (((r<<4)+g)<<4)+b;
	SetRGB4(GLView,m,r,g,b);
	}


/******************************************************************************
void	getmcolor(long m,long *r,long *g,long *b)

******************************************************************************/
/*PROTOTYPE*/
void getmcolor(long m,long *r,long *g,long *b)
	{
	*r=ColorMap[m];

	*b= *r&15;
	*r= *r>>4;
	*g= *r&15;
	*r= *r>>4;

	*r *=16;
	*g *=16;
	*b *=16;
	}


/*******************************************************************************
void	color(long c)

*******************************************************************************/
/*PROTOTYPE*/
void color(long c)
	{
	CurrentColor=c;
	SetAPen(DrawRPort,c);
	}


/*******************************************************************************
long	getcolor(void)

*******************************************************************************/
/*PROTOTYPE*/
long getcolor(void)
	{
	return CurrentColor;
	}


/*******************************************************************************
void	clear(void)

*******************************************************************************/
/*PROTOTYPE*/
void clear(void)
	{
#if TRUE

	/* clear window */
	RectFill(DrawRPort,0,0,CurrentWidth-1,CurrentHeight-1);

#else

	/* clear whole screen (clipped to window) */
	SetRast(DrawRPort,CurrentColor);

#endif
	}
@


1.2.1.1
log
@Added RCS Header
@
text
@a0 16

/******************************************************************************

$Id: poly.c,v 1.2.1.1 2002/03/26 22:04:19 jason Exp jason $

$Log: poly.c,v $
 * Revision 1.2.1.1  2002/03/26  22:04:19  jason
 * Added RCS Header
 *
 * Revision 1.2.1.1  2002/03/26  22:00:51  jason
 * RCS/agl.h,v
 *

******************************************************************************/


@


1.2.1.2
log
@Back to rectangular clear
@
text
@d4 1
a4 1
$Id: poly.c,v 1.2.1.1 1994/03/29 05:41:32 jason Exp jason $
a6 3
 * Revision 1.2.1.1  1994/03/29  05:41:32  jason
 * Added RCS Header
 *
a342 8
	long bit,value;
	long m,line,screenwidth,offset,lineoff;
	size_t linewidth;
	PLANEPTR planes,planem;

	/* only activate one of the following three methods */


d348 1
a348 4
#endif


#if FALSE
a351 51

#endif


#if FALSE
	size=ScreenDef.Width*ScreenDef.Height/8;

	/* individually clear each full plane */
	for(m=0;m<ScreenDef.Depth;m++)
		memset(DrawRPort->BitMap->Planes[m],2<<m,size);

#endif


#if FALSE

	screenwidth=ScreenDef.Width/8+1;
	offset=screenwidth*(ScreenDef.Height-CurrentPosY-CurrentHeight-1)+CurrentPosX/8;
	linewidth=(CurrentWidth+7)/8+1;
	bit=1;

	if(offset)
		{
		offset--;
		linewidth++;
		}

	/* individually clear area in each plane */
	for(m=0;m<ScreenDef.Depth;m++)
		{
		if(CurrentColor&bit)
			value=255;
		else
			value=0;

		lineoff=offset;
		planem= (DrawRPort->BitMap->Planes[m]);

		for(line=0;line<CurrentHeight;line++)
			{
			memset(&(planem[lineoff]),value,linewidth);

			lineoff+=screenwidth;
			}

		bit<<=1;
		}

/*
		BltClear((DrawRPort->BitMap->Planes[m])+offset,size,0);
*/
@


1.2.1.3
log
@PolyDraw() test
@
text
@d4 1
a4 1
$Id: poly.c,v 1.2.1.2 1994/04/06 02:41:16 jason Exp jason $
a6 3
 * Revision 1.2.1.2  1994/04/06  02:41:16  jason
 * Back to rectangular clear
 *
a19 1
#ifndef NOT_EXTERN
a20 6
#endif

#define POLYLINE		FALSE	/* use PolyDraw() instead of Move(), Draw() */
#define MAX_LINE_VERTS	512		/* max # of lines vertices (2 times max lines) */

short LineBuffer[MAX_LINE_VERTS];
a176 1
	Verts=0;
a189 7
#if POLYLINE

	else
		PolyDraw(DrawRPort,Verts/2,LineBuffer);

#endif

d240 1
a240 1
			GL_error("v??(): bad command order");
a241 1

a244 1

a245 9
#if POLYLINE
			if(Verts==MAX_LINE_VERTS)
				GL_error("Exceeded max points in polyline");
			else
				{
				LineBuffer[Verts++]=x;
				LineBuffer[Verts++]=y;
				}
#else
a252 1
#endif
a253 1

a262 1

@


1.2.1.4
log
@adjust for borders
@
text
@d4 1
a4 1
$Id: poly.c,v 1.2.1.3 1994/09/13 03:51:13 jason Exp jason $
a6 3
 * Revision 1.2.1.3  1994/09/13  03:51:13  jason
 * PolyDraw() test
 *
a254 6
	if(Bordered[CurrentWid])
		{
		x+=BorderWidth;
		y+=BorderWidth+BorderHeight;
		}

d386 1
a386 1
#if FALSE
d394 1
a394 1
#if TRUE
@


1.2.1.5
log
@uses global screen settings instead of structure
@
text
@d1 1
d4 1
a4 4
Copyright © 1994 Jason Weber
All Rights Reserved

$Id: poly.c,v 1.2.1.4 1994/11/16 06:25:54 jason Exp jason $
a6 3
 * Revision 1.2.1.4  1994/11/16  06:25:54  jason
 * adjust for borders
 *
d412 1
a412 1
	size=ScreenWidth*ScreenHeight/8;
d415 1
a415 1
	for(m=0;m<ScreenDeep;m++)
d423 2
a424 2
	screenwidth=ScreenWidth/8+1;
	offset=screenwidth*(ScreenHeight-CurrentPosY-CurrentHeight-1)+CurrentPosX/8;
d435 1
a435 1
	for(m=0;m<ScreenDeep;m++)
@


















































































