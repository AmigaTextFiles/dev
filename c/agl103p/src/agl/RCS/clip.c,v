head	1.2;
branch	1.2.1.99;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	94.08.24.04.19.39;	author jason;	state Exp;
branches
	1.2.1.1;
next	;

1.2.1.1
date	94.09.13.03.47.14;	author jason;	state Exp;
branches;
next	1.2.1.2;

1.2.1.2
date	94.11.16.06.23.56;	author jason;	state Exp;
branches;
next	1.2.1.3;

1.2.1.3
date	94.12.09.05.29.56;	author jason;	state Exp;
branches;
next	;


desc
@clipping mask using Region's
@


1.2
log
@original revision
@
text
@/******************************************************************************

$Id: $

$Log: $

******************************************************************************/


#ifndef NOT_EXTERN
#include"agl.h"
#endif


short ClipLimits[MAX_WINDOWS][4];


/******************************************************************************
void	scrmask(Screencoord left,Screencoord right,
											Screencoord bottom,Screencoord top)

******************************************************************************/
/*PROTOTYPE*/
void scrmask(Screencoord left,Screencoord right,Screencoord bottom,Screencoord top)
	{
	struct Region *old_region;

	long y1,y2;

	ClipLimits[CurrentWid][0]=left;
	ClipLimits[CurrentWid][1]=right;
	ClipLimits[CurrentWid][2]=top;
	ClipLimits[CurrentWid][3]=bottom;

	y1=CurrentHeight-top-1;
	y2=CurrentHeight-bottom-1;

	if( (old_region=clip_window(GLWindow[CurrentWid]->WLayer,left,y1,right,y2) != NULL )
		DisposeRegion(old_region);
	}


/******************************************************************************
void	getscrmask(Screencoord *left,Screencoord *right,
										Screencoord *bottom,Screencoord *top)

******************************************************************************/
/*PROTOTYPE*/
void getscrmask(Screencoord *left,Screencoord *right,Screencoord *bottom,Screencoord *top)
	{
	left=	ClipLimits[CurrentWid][0];
	right=	ClipLimits[CurrentWid][1];
	top=	ClipLimits[CurrentWid][2];
	bottom=	ClipLimits[CurrentWid][3];
	}


/******************************************************************************
void	unclip_window(struct Window *window)

	install NULL region
	dispose of old region, if one existed

******************************************************************************/
/*PROTOTYPE*/
void unclip_window(struct Window *window)
	{
	struct Region *old_region;

	if( (old_region=InstallClipRegion(window->WLayer,NULL)) != NULL )
		DisposeRegion(old_region);
	}


/******************************************************************************
struct Region *clip_window(struct Window *window,
									long minx,long miny,long maxx,long maxy)

	clip window to given bounds
	return old region, if one existed

******************************************************************************/
/*PROTOTYPE*/
struct Region *clip_window(struct Window *window,long minx,long miny,long maxx,long maxy)
	{
	struct Region *new_region;
	struct Rectangle rectangle;

	rectangle.minx=minx;
	rectangle.miny=miny;
	rectangle.maxx=maxx;
	rectangle.maxy=maxy;

	if( (new_region=NewRegion()) != NULL )
		{
		if( OrRectRegion(new_region,&rectangle) == FALSE )
			DisposeRegion(new_region);
			new_region=NULL;
		}

	return(InstallClipRegion(window->WLayer,new_region));
	}
@


1.2.1.1
log
@debugged and tested
@
text
@d3 1
a3 1
$Id: clip.c 1.2 1994/08/24 04:19:39 jason Exp jason $
d5 1
a5 4
$Log: clip.c $
 * Revision 1.2  1994/08/24  04:19:39  jason
 * original revision
 *
d26 4
d35 2
a36 4
	if(left==0 && right==CurrentWidth-1 && bottom==0 && top==CurrentHeight-1)
		Clipped[CurrentWid]=FALSE;
	else
		Clipped[CurrentWid]=TRUE;
d38 2
a39 1
	activate_clipping();
a42 1

d51 4
a54 45
	*left=		ClipLimits[CurrentWid][0];
	*right=		ClipLimits[CurrentWid][1];
	*top=		ClipLimits[CurrentWid][2];
	*bottom=	ClipLimits[CurrentWid][3];
	}


/******************************************************************************
void	activate_clipping(void)

	activates clipping in current window
******************************************************************************/
/*PROTOTYPE*/
void activate_clipping(void)
	{
	struct Region *old_region;

	Screencoord left,right,bottom,top;

	long y1,y2;

	if(Clipped[CurrentWid])
		{
		getscrmask(&left,&right,&bottom,&top);

		y1=CurrentHeight-top-1;
		y2=CurrentHeight-bottom-1;

		if( (old_region=clip_window(GLWindow[CurrentWid],(long)left,y1,(long)right,y2)) != NULL )
			DisposeRegion(old_region);
		}
	else
		unclip_window(GLWindow[CurrentWid]);
	}


/******************************************************************************
void	deactivate_clipping(void)

	activates clipping in current window
******************************************************************************/
/*PROTOTYPE*/
void deactivate_clipping(void)
	{
	unclip_window(GLWindow[CurrentWid]);
d89 4
a92 4
	rectangle.MinX=minx;
	rectangle.MinY=miny;
	rectangle.MaxX=maxx;
	rectangle.MaxY=maxy;
a96 3
			{
			printf("Error setting clipping region\n");

a98 1
			}
a99 2
	else
		printf("Error creating clipping region\n");
@


1.2.1.2
log
@separate calls to activate/deactivate clipping for specific windows
@
text
@d3 1
a3 1
$Id: clip.c,v 1.2.1.1 1994/09/13 03:47:14 jason Exp jason $
d5 1
a5 4
$Log: clip.c,v $
 * Revision 1.2.1.1  1994/09/13  03:47:14  jason
 * debugged and tested
 *
d34 1
a34 1
	if(!Bordered[CurrentWid] && left==0 && right==CurrentWidth-1 && bottom==0 && top==CurrentHeight-1)
d39 1
a39 1
	activate_clipping(CurrentWid);
d60 1
a60 1
void	activate_clipping(long wid)
d65 1
a65 1
void activate_clipping(long wid)
d73 1
a73 1
	if(Clipped[wid])
d80 1
a80 10
		if(Bordered[wid])
			{
			left+=BorderWidth;
			right+=BorderWidth;

			y1+=BorderWidth+BorderHeight;
			y2+=BorderWidth+BorderHeight;
			}

		if( (old_region=clip_window(GLWindow[wid],(long)left,y1,(long)right,y2)) != NULL )
d84 1
a84 1
		unclip_window(GLWindow[wid]);
d89 1
a89 1
void	deactivate_clipping(long wid)
d94 1
a94 1
void deactivate_clipping(long wid)
d96 1
a96 1
	unclip_window(GLWindow[wid]);
@


1.2.1.3
log
@added copyright
@
text
@d3 1
a3 4
Copyright © 1994 Jason Weber
All Rights Reserved

$Id: clip.c,v 1.2.1.2 1994/11/16 06:23:56 jason Exp jason $
a5 3
 * Revision 1.2.1.2  1994/11/16  06:23:56  jason
 * separate calls to activate/deactivate clipping for specific windows
 *
@


















































































