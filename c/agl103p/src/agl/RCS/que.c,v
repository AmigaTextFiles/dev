head	1.2;
branch	1.2.1.99;
access;
symbols;
locks; strict;
comment	@ * @;


1.2
date	93.01.27.17.42.22;	author jason;	state Exp;
branches
	1.2.1.1;
next	;

1.2.1.1
date	94.03.29.05.41.32;	author jason;	state Exp;
branches;
next	1.2.1.2;

1.2.1.2
date	94.04.06.02.42.15;	author jason;	state Exp;
branches;
next	1.2.1.3;

1.2.1.3
date	94.09.13.03.52.07;	author jason;	state Exp;
branches;
next	1.2.1.4;

1.2.1.4
date	94.11.16.06.28.44;	author jason;	state Exp;
branches;
next	1.2.1.5;

1.2.1.5
date	94.12.09.05.29.56;	author jason;	state Exp;
branches;
next	;


desc
@device event que handling
@


1.2
log
@Initial RCS Version
@
text
@#include"agl.h"
#include"keymap.h"

#define QDEBUG		FALSE
#define MAXKEYINPUT	128

struct InputEvent InEvent={0,IECLASS_RAWKEY,0,0,0};

short Tie[MAX_DEVICE][2];
short Queued[MAX_DEVICE];
short ButtonState[MAX_DEVICE];
short QRead,QWrite;
short Mousex,Mousey,LastMousex=0,LastMousey=0;
short Mouse2x=0,Mouse2y=0;

long Queue[QUEUE_SIZE][2];
long GLFocus=0;



/******************************************************************************
void	qinit(void)

******************************************************************************/
/*PROTOTYPE*/
void qinit(void)
	{
	short m;

	QRead=0;
	QWrite=0;

	for(m=0;m<MAX_DEVICE;m++)
		{
		Queued[m]=FALSE;
		Tie[m][0]=0;
		Tie[m][1]=0;
		}

	clear_buttons(TRUE);

	Queued[REDRAW]=TRUE;
	Queued[INPUTCHANGE]=TRUE;
	}


/******************************************************************************
void	tie(long dev,long valuator1,long valuator2)

******************************************************************************/
/*PROTOTYPE*/
void tie(long dev,long valuator1,long valuator2)
	{
	Tie[dev][0]=valuator1;
	Tie[dev][1]=valuator2;
	}


/******************************************************************************
void	qdevice(long dev)

******************************************************************************/
/*PROTOTYPE*/
void qdevice(long dev)
	{
	Queued[dev]=TRUE;
	}


/******************************************************************************
void	unqdevice(long dev)

******************************************************************************/
/*PROTOTYPE*/
void unqdevice(long dev)
	{
	Queued[dev]=FALSE;
	}


/******************************************************************************
long	isqueued(long dev)

******************************************************************************/
/*PROTOTYPE*/
long isqueued(long dev)
	{
	return Queued[dev];
	}


/******************************************************************************
void	qenter(long dev,short val)

******************************************************************************/
/*PROTOTYPE*/
void qenter(long dev,short val)
	{
	Queue[QWrite][0]=dev;
	Queue[QWrite][1]=val;
	QWrite++;
	if(QWrite==QRead)
		{
		GL_error("Queue filled: event overrun");
		QRead++;
		if(QRead==QUEUE_SIZE)
			QRead=0;
		}
	if(QWrite==QUEUE_SIZE)
		QWrite=0;
	}


/******************************************************************************
long	qtest(void)

******************************************************************************/
/*PROTOTYPE*/
long qtest(void)
	{
	update_queue();

	if(QRead==QWrite)
		return 0;
	else
		return Queue[QRead][0];
	}


/******************************************************************************
long	qread(short *data)

******************************************************************************/
/*PROTOTYPE*/
long qread(short *data)
	{
	long device;

	while(QRead==QWrite)
		{
		update_queue();
		micropause();
		}

	device=Queue[QRead][0];
	*data=Queue[QRead][1];
	QRead++;
	if(QRead==QUEUE_SIZE)
		QRead=0;

	return device;
	}


/******************************************************************************
void	qreset(void)

******************************************************************************/
/*PROTOTYPE*/
void qreset(void)
	{
	QRead=QWrite;
	}


/******************************************************************************
long	getvaluator(long val)

******************************************************************************/
/*PROTOTYPE*/
long getvaluator(long val)
	{
	long result=0;

	switch(val)
		{
		case MOUSEX:
			result=GLScreen->MouseX;
			break;
		case MOUSEY:
			result=SCREENY-1-GLScreen->MouseY;
			break;
		}
	return result;
	}


/******************************************************************************
long	getbutton(long num)

******************************************************************************/
/*PROTOTYPE*/
long getbutton(long num)
	{
	update_queue();

	return (long)ButtonState[num];
	}


/******************************************************************************
void clear_buttons(long init)

	resets state of mouse buttons

	unless init, issues que entry for switch off

******************************************************************************/
/*PROTOTYPE*/
void clear_buttons(long init)
	{
	long m;

	for(m=0;m<MAX_DEVICE;m++)
		{
		if(ButtonState[m] && Queued[m] && !init)
			qenter_tie(m,(short)FALSE);

		ButtonState[m]=FALSE;
		}
	}


/*******************************************************************************
void	update_queue(void)

	a manual MOUSEX,MOUSEY move check is much better than having Intuition
		flood the system with reports

*******************************************************************************/
/*PROTOTYPE*/	 
void update_queue(void)
	{
	struct IntuiMessage *message,*mess1,*mess2;
	struct MsgPort *userport;
	ULONG class;
	USHORT code;
	UWORD qualifier;
	char string[MAXKEYINPUT];
	long wid,device;
	short inside,data;
	short ascii,c,length,mx,my;

	Mousex=getvaluator(MOUSEX);
	Mousey=getvaluator(MOUSEY);

#if MICE
	while(gameport_event(&device,&data,&mx,&my))	/* mx,my = delta mouse position */
		{
/*
		if(device && Queued[device])
			qenter_tie(device,data);
*/
			
		if(mx || my)
			{
			Mouse2x+=mx;
			Mouse2y+=my;

			if(Mouse2x<0)
				Mouse2x=0;
			if(Mouse2x>SCREENX-1)
				Mouse2x=SCREENX-1;

			if(Mouse2y<0)
				Mouse2y=0;
			if(Mouse2y>SCREENY-1)
				Mouse2y=SCREENY-1;

/*
			if(Queued[BPADX])
				qenter(BPADX,Mouse2x);

			if(Queued[BPADY])
				qenter(BPADY,Mouse2y);
*/

			move_mousesprite((long)Mouse2x,(long)Mouse2y);
			}
		}
#endif

	if( (Queued[MOUSEX]||Queued[MOUSEY]) && (Mousex!=LastMousex||Mousey!=LastMousey)
																&& is_inside(GLFocus,Mousex,Mousey) )
		{
		if(Queued[MOUSEX])
			qenter(MOUSEX,Mousex);
		if(Queued[MOUSEY])
			qenter(MOUSEY,Mousey);
		}

	LastMousex=Mousex;
	LastMousey=Mousey;

	for(wid=1;wid<MAX_WINDOWS;wid++)
		{
		if(GLWindow[wid])
			{
			userport=GLWindow[wid]->UserPort;
			inside=is_inside(wid,Mousex,Mousey);

			while(message=(struct IntuiMessage *)GetMsg(userport))
				{																	   
				device=0;
				data=0;

				class=message->Class;
				code=message->Code;
				qualifier=message->Qualifier;
				mx=message->MouseX;
				my=message->MouseY;

				ButtonState[LEFTMOUSE]= (qualifier&IEQUALIFIER_LEFTBUTTON)!=0;
				ButtonState[MIDDLEMOUSE]= (qualifier&IEQUALIFIER_MIDBUTTON)!=0;
				ButtonState[RIGHTMOUSE]= (qualifier&IEQUALIFIER_RBUTTON)!=0;
			
				ReplyMsg((struct Message *)message);

				switch(class)
					{
					case CLOSEWINDOW:
						if(QDEBUG)
							printf("Msg: CLOSEWINDOW on %d: %d,%d code=%d\n",wid,mx,my,code);
						device=WINQUIT;
						data=TRUE;
						break;
					case REFRESHWINDOW:
						if(QDEBUG)
							printf("Msg: REFRESHWINDOW on %d: %d,%d code=%d\n",wid,mx,my,code);

						/* optimally refresh occurs between these, but not convenient in GL */
						BeginRefresh(GLWindow[wid]);
						EndRefresh(GLWindow[wid],TRUE);

						device=REDRAW;
						data=wid;
						break;
					case ACTIVEWINDOW:
						if(QDEBUG)
							printf("Msg: ACTIVEWINDOW on %d: %d,%d code=%d\n",wid,mx,my,code);
						if(GLFocus!=0)
							qenter_tie(INPUTCHANGE,(short)0);
						GLFocus=wid;
						device=INPUTCHANGE;
						data=wid;
						break;
					case INACTIVEWINDOW:
						if(QDEBUG)
							printf("Msg: INACTIVEWINDOW on %d: %d,%d code=%d\n",wid,mx,my,code);
						if(GLFocus==wid)
							{
							GLFocus=0;
							device=INPUTCHANGE;
							data=0;
							clear_buttons(FALSE);
							}
						break;
					case MOUSEMOVE:
						if(QDEBUG)
							printf("Msg: MOUSEMOVE on %d: %d,%d code=%d\n",wid,mx,my,code);
						if(inside)
							{
							if(Queued[MOUSEX])
								qenter(MOUSEX,Mousex);
							if(Queued[MOUSEY])
								qenter(MOUSEY,Mousey);
							}
						break;
					case MOUSEBUTTONS:
						if(QDEBUG)
							printf("Msg: MOUSEBUTTONS on %d: %d,%d code=%d\n",wid,mx,my,code);
						switch(code)
							{
							case SELECTDOWN:
								device=LEFTMOUSE;
								data=TRUE;
								break;
							case SELECTUP:
								device=LEFTMOUSE;
								data=FALSE;
								break;
							case MIDDLEDOWN:
								device=MIDDLEMOUSE;
								data=TRUE;
								break;
							case MIDDLEUP:
								device=MIDDLEMOUSE;
								data=FALSE;
								break;
							case MENUDOWN:
								device=RIGHTMOUSE;
								data=TRUE;
								break;
							case MENUUP:
								device=RIGHTMOUSE;
								data=FALSE;
								break;
							}

/*
						if(!inside)
							device=NULL;
*/
						break;
					case RAWKEY:
						if(QDEBUG)
							printf("Msg: RAWKEY on %d: %d,%d code=%d\n",wid,mx,my,code);
						if(inside)
							{
							if(!(code&IECODE_UP_PREFIX))
								{
								InEvent.ie_Code=code;
								InEvent.ie_Qualifier=qualifier;
								length=RawKeyConvert(&InEvent,string,MAXKEYINPUT,NULL);

								if(length>0)
									{
									string[length]=0;

									if(QDEBUG)
										for(c=0;string[c];c++)
											printf("     %2x %3d '%c'\n",string[c],string[c],string[c]);

									if(Queued[KEYBD] && length==1)
										{
										ascii=string[0];
										device=KEYBD;
										data=ascii;
										}
									}
								}
							}
						quekeys(code,inside);

						/* prevent running */
						mess1=(struct IntuiMessage *) userport->mp_MsgList.lh_Head;
						while(mess2=(struct IntuiMessage *)mess1->ExecMessage.mn_Node.ln_Succ)
							{
							if(mess2->ExecMessage.mn_Node.ln_Succ==NULL)
								break;
							if(mess1->Class!=RAWKEY)
								break;
							if(!(mess1->Qualifier & IEQUALIFIER_REPEAT))
								break;
							if(mess2->Class != RAWKEY)
								break;
							if(!(mess2->Qualifier & IEQUALIFIER_REPEAT))
								break;

							/* Message removed */
							mess1=(struct IntuiMessage *)GetMsg(userport);
							ReplyMsg((struct Message *)mess1);

							mess1=(struct IntuiMessage *) userport->mp_MsgList.lh_Head;
							}
						break;
					}
				if(device && Queued[device])
					qenter_tie(device,data);
				}
			}
		}
	}


/******************************************************************************
void	qenter_tie(long device,short data)
******************************************************************************/
/*PROTOTYPE*/
void qenter_tie(long device,short data)
	{
	short n;

	qenter(device,data);

	for(n=0;n<2;n++)
		{
		if(Tie[device][n]==MOUSEX)
			qenter(MOUSEX,Mousex);
		if(Tie[device][n]==MOUSEY)
			qenter(MOUSEY,Mousey);
		}
	}


/******************************************************************************
void	quekeys(USHORT code,short inside)

******************************************************************************/
/*PROTOTYPE*/
void quekeys(USHORT code,short inside)
	{
	long device;
	short data=TRUE;

	if( code & IECODE_UP_PREFIX )
		{
		data=FALSE;
		code-=IECODE_UP_PREFIX;
		}

	if(code<KEYMAPLENGTH)
		{
 		device=KeyRemap[code];

		if(data != ButtonState[device])
			{
			if(QDEBUG)
				printf("Code %2X %3d -> device=%d\n",code,data,device);

			ButtonState[device]=data;

			if(Queued[device] && inside)
				qenter_tie(device,data);
			}
		}
	}


/******************************************************************************
short 	is_inside(long wid,short x,short y)

******************************************************************************/
/*PROTOTYPE*/
short is_inside(long wid,short x,short y)
	{
	long posx,posy,lenx,leny;
	short inside;

	get_dimensions(wid,&posx,&posy,&lenx,&leny);
	inside=	x>posx && x<(posx+lenx) && y>posy && y<(posy+leny) ;

	return inside;
	}
@


1.2.1.1
log
@Added RCS Header
@
text
@a0 16

/******************************************************************************

$Id: que.c,v 1.2.1.1 2002/03/26 22:04:21 jason Exp jason $

$Log: que.c,v $
 * Revision 1.2.1.1  2002/03/26  22:04:21  jason
 * Added RCS Header
 *
 * Revision 1.2.1.1  2002/03/26  22:00:51  jason
 * RCS/agl.h,v
 *

******************************************************************************/


d181 1
a181 1
			result=GLScreen->Height-1-GLScreen->MouseY;
d262 2
a263 2
			if(Mouse2x>GLScreen->Width-1)
				Mouse2x=GLScreen->Width-1;
d267 2
a268 2
			if(Mouse2y>GLScreen->Height-1)
				Mouse2y=GLScreen->Height-1;
@


1.2.1.2
log
@Now only updates que when it's empty
@
text
@d4 1
a4 1
$Id: que.c,v 1.2.1.1 1994/03/29 05:41:32 jason Exp jason $
a6 3
 * Revision 1.2.1.1  1994/03/29  05:41:32  jason
 * Added RCS Header
 *
a132 3
	checks if there is event in the queue
	doesn't wait, returns immediately

d137 1
a137 2
	if(QRead==QWrite)
		update_queue();
a148 3
	reads queue
	will wait for an event

a162 1

a163 1

a450 1
#if FALSE
a471 1
#endif
@


1.2.1.3
log
@replaced micropause() with delay()
@
text
@d4 1
a4 1
$Id: que.c,v 1.2.1.2 1994/04/06 02:42:15 jason Exp jason $
d7 2
a8 2
 * Revision 1.2.1.2  1994/04/06  02:42:15  jason
 * Now only updates que when it's empty
d10 1
a10 1
 * Revision 1.2.1.1  1994/03/29  05:41:32  jason
d12 4
a19 1
#ifndef NOT_EXTERN
a20 2
#endif

a120 1

a127 1

a152 11
/*******************************************************************************
void	delay(void)

*******************************************************************************/
/*PROTOTYPE*/
void delay(void)
	{
	Delay(5);
	}


d168 1
a168 1
		delay();
a354 1

a365 1

a374 1

a385 1

a396 1

a432 1

a487 1

@


1.2.1.4
log
@border support
@
text
@d4 1
a4 1
$Id: que.c,v 1.2.1.3 1994/09/13 03:52:07 jason Exp jason $
a6 3
 * Revision 1.2.1.3  1994/09/13  03:52:07  jason
 * replaced micropause() with delay()
 *
d22 2
a23 11

#define QDEBUG			FALSE

#define MAXKEYINPUT		128

#define BORDER_LEFT		1
#define BORDER_RIGHT	2
#define BORDER_TOP		4
#define BORDER_BOTTOM	8
#define BORDER_MENU		16

a26 1
short LastOrigin[MAX_WINDOWS][2];
d35 1
a47 2
	GLFocus=0;

a50 6
	for(m=0;m<MAX_WINDOWS;m++)
		{
		LastOrigin[m][0]= -1;
		LastOrigin[m][1]= -1;
		}

d145 1
a145 1
		update_queue(-1);
d179 1
a179 1
		update_queue(-1);
a223 1

d235 1
a235 1
	update_queue(-1);
a253 2
/* 	printf("clear buttons\n"); */

d265 1
a265 1
void	update_queue(short waitid)
a269 2
	if waitid>=0, wait for event in wid specified by waitid

d272 1
a272 1
void update_queue(short waitid)
a275 1

a278 1

d280 3
a282 15

	long wid,old_wid;
	long border_touch=NULL;	/* wid of window whose border is being touched */
	long device;
	long originx,originy;
	long sizex,sizey;

	short inside;
	short border;
	short data;
	short ascii;
	short c;
	short length;
	short mx,my;
	short waited=FALSE;
d324 1
a324 1
														&& is_inside(GLFocus,Mousex,Mousey,FALSE) )
d335 3
a337 2
	do	{
		for(wid=1;wid<MAX_WINDOWS;wid++)
d339 2
a340 5
			if(GLWindow[wid])
				{
				/* check if window has moved (no Intuition event for this) */
				get_dimensions(wid,TRUE,&originx,&originy,&sizex,&sizey);
				originy=ScreenDef.Height-originy-sizey;
d342 16
a357 23
				if(originx!=LastOrigin[wid][0] || originy!=LastOrigin[wid][1])
					{
					if(QDEBUG)
						printf("MOVEWINDOW (pseudo-event)\n");

					LastOrigin[wid][0]=originx;
					LastOrigin[wid][1]=originy;

					if(wid==waitid)
						waited=TRUE;
					}

				userport=GLWindow[wid]->UserPort;
				inside=is_inside(wid,Mousex,Mousey,TRUE);
				if(inside)
					{
					border=!is_inside(wid,Mousex,Mousey,FALSE);

					/* not considered inside if on border */
					inside=!border;
					}
				else
					border=FALSE;
d359 1
a359 1
				while(message=(struct IntuiMessage *)GetMsg(userport))
d361 35
a395 72
					device=0;
					data=0;

					class=message->Class;
					code=message->Code;
					qualifier=message->Qualifier;
					mx=message->MouseX;
					my=message->MouseY;

/*	Note: ignoring button info from refresh and newsize to prevent
 *	false-positive leftmouse after a resize
 */

					if( class!=NEWSIZE && class!=REFRESHWINDOW &&
															class!=ACTIVEWINDOW && class!=INACTIVEWINDOW )
						{
						ButtonState[LEFTMOUSE]= (qualifier&IEQUALIFIER_LEFTBUTTON)!=0;
						ButtonState[MIDDLEMOUSE]= (qualifier&IEQUALIFIER_MIDBUTTON)!=0;
						ButtonState[RIGHTMOUSE]= (qualifier&IEQUALIFIER_RBUTTON)!=0;
						}
				
					if(QDEBUG)
						printf("Msg on %d: %d,%d mb=%d%d%d code=%d ",wid,mx,my,ButtonState[LEFTMOUSE],
													ButtonState[MIDDLEMOUSE],ButtonState[RIGHTMOUSE],code);

					ReplyMsg((struct Message *)message);

					switch(class)
						{
						case CLOSEWINDOW:
							if(QDEBUG)
								printf("CLOSEWINDOW\n");
							device=WINQUIT;
							data=TRUE;
							break;

						case NEWSIZE:
							if(QDEBUG)
								printf("NEWSIZE\n");

#if FALSE
							/* window resize indicates an otherwise unseen left mouse release */
							ButtonState[LEFTMOUSE]=FALSE;

#endif
							if(wid==waitid)
								waited=TRUE;
							break;

						case REFRESHWINDOW:
							if(QDEBUG)
								printf("REFRESHWINDOW\n");

							/* optimally refresh occurs between these, but not convenient in GL */
							BeginRefresh(GLWindow[wid]);
							EndRefresh(GLWindow[wid],TRUE);

							device=REDRAW;
							data=wid;

							drawborder(wid);
							break;

						case ACTIVEWINDOW:
							if(QDEBUG)
								printf("ACTIVEWINDOW\n");

							if(GLFocus!=0)
								qenter_tie(INPUTCHANGE,(short)0);

							old_wid=GLFocus;
							GLFocus=wid;
d397 47
a443 82
							data=wid;

							drawborder(old_wid);
							drawborder(wid);

							RedoBorder[wid]=TRUE;
							RedoBorder[old_wid]=TRUE;
							break;

						case INACTIVEWINDOW:
							if(QDEBUG)
								printf("INACTIVEWINDOW\n");

							if(GLFocus==wid)
								{
								old_wid=GLFocus;
								GLFocus=0;
								device=INPUTCHANGE;
								data=0;
								clear_buttons(FALSE);

								drawborder(old_wid);
								RedoBorder[old_wid]=TRUE;
								}

							break;

						case MOUSEMOVE:
							if(QDEBUG)
								printf("MOUSEMOVE\n");

							if(inside)
								{
								if(Queued[MOUSEX])
									qenter(MOUSEX,Mousex);
								if(Queued[MOUSEY])
									qenter(MOUSEY,Mousey);
								}
							break;

						case MOUSEBUTTONS:
							if(QDEBUG)
								printf("MOUSEBUTTONS\n");

							switch(code)
								{
								case SELECTDOWN:
									device=LEFTMOUSE;
									data=TRUE;

									if(border)
										border_touch=wid;
									break;

								case SELECTUP:
									device=LEFTMOUSE;
									data=FALSE;
									break;

								case MIDDLEDOWN:
									device=MIDDLEMOUSE;
									data=TRUE;

									if(border)
										border_touch= -wid;
									break;

								case MIDDLEUP:
									device=MIDDLEMOUSE;
									data=FALSE;
									break;

								case MENUDOWN:
									device=RIGHTMOUSE;
									data=TRUE;
									break;

								case MENUUP:
									device=RIGHTMOUSE;
									data=FALSE;
									break;
								}
d446 2
a447 2
							if(!inside)
								device=NULL;
d449 1
a449 1
							break;
d451 10
a460 3
						case RAWKEY:
							if(QDEBUG)
								printf("RAWKEY\n");
d462 1
a462 3
							if(inside)
								{
								if(!(code&IECODE_UP_PREFIX))
d464 5
a468 3
									InEvent.ie_Code=code;
									InEvent.ie_Qualifier=qualifier;
									length=RawKeyConvert(&InEvent,string,MAXKEYINPUT,NULL);
d470 1
a470 1
									if(length>0)
d472 3
a474 12
										string[length]=0;

										if(QDEBUG)
											for(c=0;string[c];c++)
												printf("     %2x %3d '%c'\n",string[c],string[c],string[c]);

										if(Queued[KEYBD] && length==1)
											{
											ascii=string[0];
											device=KEYBD;
											data=ascii;
											}
d478 2
a479 1
							quekeys(code,inside);
d482 19
a500 1
							/* prevent running */
d502 1
a502 19
							while(mess2=(struct IntuiMessage *)mess1->ExecMessage.mn_Node.ln_Succ)
								{
								if(mess2->ExecMessage.mn_Node.ln_Succ==NULL)
									break;
								if(mess1->Class!=RAWKEY)
									break;
								if(!(mess1->Qualifier & IEQUALIFIER_REPEAT))
									break;
								if(mess2->Class != RAWKEY)
									break;
								if(!(mess2->Qualifier & IEQUALIFIER_REPEAT))
									break;

								/* Message removed */
								mess1=(struct IntuiMessage *)GetMsg(userport);
								ReplyMsg((struct Message *)mess1);

								mess1=(struct IntuiMessage *) userport->mp_MsgList.lh_Head;
								}
d504 2
a505 2
							break;
						}
d507 2
a508 3
					if(device && Queued[device])
						qenter_tie(device,data);
					}
a510 13
		} while(waitid>=0 && !waited);

	if(border_touch && waitid<0)
		{
		if(border_touch<0)
			{
			border_touch= -border_touch;
			data=TRUE;
			}
		else
			data=FALSE;

		border_action(border_touch,Mousex,Mousey,data);
a516 1

d570 1
a570 3
short 	is_inside(long wid,short x,short y,short border)

	if border==TRUE, will also report inside if on border
d574 1
a574 1
short is_inside(long wid,short x,short y,short border)
d579 2
a580 8
	get_dimensions(wid,border,&posx,&posy,&lenx,&leny);

	x-=posx;
	y-=posy;

	inside=	x>=0 && x<lenx && y>=0 && y<leny;

/* 	printf("border=%d pos=%d,%d len=%d,%d %d,%d inside=%d\n",border,posx,posy,lenx,leny,x,y,inside); */
a582 299
	}


/******************************************************************************
short	border_edge(long wid,short x,short y)

	returns which edge/corner is touched as sum of the following
		BORDER_LEFT
		BORDER_RIGHT
		BORDER_TOP
		BORDER_BOTTOM
		BORDER_MENU

	note that all combinations of flags are not possible

	assuming you know x,y is on the border, return of 0 indicates title bar
******************************************************************************/
/*PROTOTYPE*/
short border_edge(long wid,short x,short y)
	{
	long posx,posy,lenx,leny;

	short result=0;

	get_dimensions(wid,TRUE,&posx,&posy,&lenx,&leny);

	x-=posx;
	y-=posy;

	if(x< BorderWidth+BorderHeight)
		result+=BORDER_LEFT;

	if(x> lenx - (BorderWidth+BorderHeight) )
		result+=BORDER_RIGHT;

	if(y< BorderWidth+BorderHeight)
		result+=BORDER_BOTTOM;

	if(y>= leny - (BorderWidth+BorderHeight) )
		result+=BORDER_TOP;

	if( x>= BorderWidth && x< lenx-BorderWidth && y>= BorderWidth && y< leny-BorderWidth )
		{
		if( x< BorderWidth+BorderHeight && y> leny-BorderWidth-BorderHeight )
			result=BORDER_MENU;
		else
			result=0;
		}

	return result;
	}


/******************************************************************************
void 	border_action(long wid,short ox,short oy,short middle)

******************************************************************************/
/*PROTOTYPE*/
void border_action(long wid,short ox,short oy,short middle)
	{
	long dx,dy;
	long x,y;
	long movex,movey;
	long sizex,sizey;
	long edge=0;
	long posx,posy,lenx,leny;

	short first=TRUE;
	short movefirst;

	get_dimensions(wid,TRUE,&posx,&posy,&lenx,&leny);
	posy=ScreenDef.Height-posy-leny;

	if(!middle && Sizeable[wid])
		edge=border_edge(wid,ox,oy);

	if(edge==BORDER_MENU)
		qenter(WINQUIT,TRUE);
	else
		{
		while( (!middle && getbutton(LEFTMOUSE)) || (middle && getbutton(MIDDLEMOUSE)) )
			{
			x=getvaluator(MOUSEX);
			y=getvaluator(MOUSEY);

			dx=x-ox;
			dy=y-oy;

			if(dx || dy)
				{
				if(first)
					{
					first=FALSE;

					GLScreen->RastPort.BitMap=VisibleRPort->BitMap;
					GLScreen->ViewPort.RasInfo->BitMap=VisibleRPort->BitMap;

					MakeScreen(GLScreen);
					RethinkDisplay();
					}

				sizex=0;
				sizey=0;

				movefirst=TRUE;

				if(edge==0)
					{
					movex=dx;
					movey= -dy;
					}
				else
					{
					movex=0;
					movey=0;
					}

				if(edge&BORDER_TOP)
					{
					movey= -dy;
					sizey=dy;

					movefirst= (movey<0);
					}

				if(edge&BORDER_BOTTOM)
					sizey= -dy;

				if(edge&BORDER_LEFT)
					{
					movex=dx;
					sizex= -dx;

					movefirst= (movex<0);
					}

				if(edge&BORDER_RIGHT)
					sizex=dx;

				if(movex< -posx)
					{
					movex= -posx;
					if(sizex)
						sizex= -movex;
					}

				if(movey< -posy)
					{
					movey= -posy;
					if(sizey)
						sizey= -movey;
					}

				move_and_resize(wid,movefirst,movex,movey,sizex,sizey);

				posx+=movex;
				posy+=movey;

				lenx+=sizex;
				leny+=sizey;
				}

			ox=x;
			oy=y;
			}

		clone_new_bitmap();
		}
	}


/******************************************************************************
void	do_move_and_resize(long wid,long movefirst,long movex,long movey,
														long sizex,long sizey)

	does proper setup for double buffering
	calls move_and_resize()

******************************************************************************/
/*PROTOTYPE*/
void do_move_and_resize(long wid,long movefirst,long movex,long movey,long sizex,long sizey)
	{
/* 	printf("do(%d,%d, %d,%d, %d,%d)\n",wid,movefirst,movex,movey,sizex,sizey); */

	GLScreen->RastPort.BitMap=VisibleRPort->BitMap;
	GLScreen->ViewPort.RasInfo->BitMap=VisibleRPort->BitMap;

	MakeScreen(GLScreen);
	RethinkDisplay();

	move_and_resize(wid,movefirst,movex,movey,sizex,sizey);

	clone_new_bitmap();
	}


/******************************************************************************
void	move_and_resize(long wid,long movefirst,long movex,long movey,
														long sizex,long sizey)

******************************************************************************/
/*PROTOTYPE*/
void move_and_resize(long wid,long movefirst,long movex,long movey,long sizex,long sizey)
	{
	long posx,posy,lenx,leny;
	long limit;

	get_dimensions(wid,TRUE,&posx,&posy,&lenx,&leny);
	posy=ScreenDef.Height-posy-leny;

/*
	printf("\n wid=%d movefirst=%d pos=%d,%d+%d,%d size=%d,%d+%d,%d\n",wid,movefirst,posx,posy,movex,movey,
																				lenx,leny,sizex,sizey);
*/

	if(lenx+sizex<MIN_WINX)
		sizex=MIN_WINX-lenx;

	if(leny+sizey<MIN_WINY)
		sizey=MIN_WINY-leny;

	limit=ScreenDef.Width-posx-lenx-sizex;
	if(movex>limit && limit>=0)
		movex=limit;

	limit=ScreenDef.Height-posy-leny-sizey;
	if(movey>limit && limit>=0)
		movey=limit;

	if(movex< -posx)
		movex= -posx;

	if(movey< -posy)
		movey= -posy;

	limit=ScreenDef.Width-posx-lenx-movex;
	if(sizex>limit && limit>=0)
		sizex=limit;

	limit=ScreenDef.Height-posy-leny-movey;
	if(sizey>limit && limit>=0)
		sizey=limit;

/*
	printf("                   pos=%d,%d+%d,%d size=%d,%d+%d,%d\n",posx,posy,movex,movey,
																				lenx,leny,sizex,sizey);
*/

	if( movefirst && (movex || movey) )
		{
		MoveWindow(GLWindow[wid],movex,movey);
		update_queue(wid);
		}

	if(sizex || sizey)
		{
		SizeWindow(GLWindow[wid],sizex,sizey);
		update_queue(wid);

		clear_void(wid,sizex,sizey);
		}

	if( !movefirst && (movex || movey) )
		{
		MoveWindow(GLWindow[wid],movex,movey);
		update_queue(wid);
		}

	drawborder(wid);
	}


/******************************************************************************
void	clear_void(long wid,short x,short y)

	clears space left by expanding window
******************************************************************************/
/*PROTOTYPE*/
void clear_void(long wid,short x,short y)
	{
	struct RastPort *rp;

	long posx,posy,lenx,leny;

	rp=GLWindow[wid]->RPort;

	get_dimensions(wid,TRUE,&posx,&posy,&lenx,&leny);

	SetAPen(rp,0);

	deactivate_clipping(wid);

	if(x>0)
		RectFill(rp,lenx-BorderWidth-x,BorderWidth+BorderHeight,lenx-BorderWidth,leny-BorderWidth);

	if(y>0)
		RectFill(rp,BorderWidth,leny-BorderWidth-y,lenx-BorderWidth,leny-BorderWidth);

	activate_clipping(wid);
@


1.2.1.5
log
@border buttons with feedback
@
text
@d1 1
d4 1
a4 4
Copyright © 1994 Jason Weber
All Rights Reserved

$Id: que.c,v 1.2.1.4 1994/11/16 06:28:44 jason Exp jason $
a6 3
 * Revision 1.2.1.4  1994/11/16  06:28:44  jason
 * border support
 *
a29 1
#define BORDER_TITLE	0
a34 2
#define BORDER_MINIMIZE	32
#define BORDER_MAXIMIZE	64
d381 1
a381 1
				originy=ScreenHeight-originy-sizey;
d423 1
a423 1
													class!=ACTIVEWINDOW && class!=INACTIVEWINDOW )
d432 1
a432 1
												ButtonState[MIDDLEMOUSE],ButtonState[RIGHTMOUSE],code);
d469 1
a469 1
							drawborder(wid,0);
d484 2
a485 2
							drawborder(old_wid,0);
							drawborder(wid,0);
d503 1
a503 1
								drawborder(old_wid,0);
d589 1
a589 2
												printf("     %2x %3d '%c'\n",
																		string[c],string[c],string[c]);
a738 2
		BORDER_MINIMIZE
		BORDER_MAXIMIZE
d770 3
a772 3
		/* not on outer edge */

		if( y <= leny-BorderWidth-BorderHeight )
a773 13
		else
			{
			/* title bar */

			if( x< BorderWidth+BorderHeight )
				result=BORDER_MENU;
			else if( x>= lenx-BorderWidth-BorderHeight )
				result=BORDER_MAXIMIZE;
			else if( x>= lenx-BorderWidth-2*BorderHeight )
				result=BORDER_MINIMIZE;
			else
				result=0;
			}
a786 1
	long old_wid;
d791 1
a792 1
	long edge=BORDER_TITLE;
d798 1
a798 3
	posy=ScreenHeight-posy-leny;

	edge=border_edge(wid,ox,oy);
d800 2
a801 2
	if( (middle || !Sizeable[wid]) && edge!=BORDER_MENU)
		edge=BORDER_TITLE;
a803 8
		{
		drawborder(wid,1);

		while( (!middle && getbutton(LEFTMOUSE)) || (middle && getbutton(MIDDLEMOUSE)) )
			/* NOP */ ;

		drawborder(wid,0);

a804 40
		}
	else if(edge==BORDER_MINIMIZE)
		{
		drawborder(wid,3);

		while( (!middle && getbutton(LEFTMOUSE)) || (middle && getbutton(MIDDLEMOUSE)) )
			/* NOP */ ;

		drawborder(wid,0);
		}
	else if(edge==BORDER_MAXIMIZE)
		{
		drawborder(wid,4);

		while( (!middle && getbutton(LEFTMOUSE)) || (middle && getbutton(MIDDLEMOUSE)) )
			/* NOP */ ;

		get_dimensions(wid,FALSE,&posx,&posy,&lenx,&leny);

		x=Maximization[wid][0];
		y=Maximization[wid][1];
		dx=x+Maximization[wid][2]-1;
		dy=y+Maximization[wid][3]-1;

/*
		printf("\n%d,%d %d,%d,%d,%d %d,%d\n",ScreenWidth,ScreenHeight,
																BorderWidth,BorderHeight,x,y,dx,dy);
*/
		old_wid=winget();
		winset(wid);

		winposition(x,dx,y,dy);

		Maximization[wid][0]=posx;
		Maximization[wid][1]=posy;
		Maximization[wid][2]=lenx;
		Maximization[wid][3]=leny;

		winset(old_wid);
		}
a806 3
		if(!middle && edge==0)
			drawborder(wid,2);

a881 3
				if(!middle && edge==0)
					drawborder(wid,2);

a892 2
		drawborder(wid,0);

d935 1
a935 1
	posy=ScreenHeight-posy-leny;
d938 2
a939 2
	printf("\n wid=%d movefirst=%d pos=%d,%d+%d,%d size=%d,%d+%d,%d\n",wid,movefirst,posx,posy,
																movex,movey,lenx,leny,sizex,sizey);
d948 1
a948 1
	limit=ScreenWidth-posx-lenx-sizex;
d952 1
a952 1
	limit=ScreenHeight-posy-leny-sizey;
d962 1
a962 1
	limit=ScreenWidth-posx-lenx-movex;
d966 1
a966 1
	limit=ScreenHeight-posy-leny-movey;
d972 1
a972 1
																			lenx,leny,sizex,sizey);
d994 2
@


















































































