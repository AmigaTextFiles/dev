/*
** This file was generated by LibGen and is based upon the
** output from idltool.
*/

#include <proto/exec.h>

#include "init.h"

#include "vectors.h"

#include "lib_init.h"

/* Uncomment this line (and see below) if your library has a 68k jump table */
/* extern APTR VecTable68K []; */

struct Library *NewlibBase = NULL;
struct Interface *INewlib = NULL;

STATIC CONST struct TagItem amijanssonTags [] =
{
	{ MIT_Name, (Tag) "main" },
	{ MIT_VectorTable, (Tag) amijansson_vectors },
	{ MIT_Version,	1 },
	{ TAG_DONE, 0 }
};

STATIC CONST CONST_APTR libInterfaces [] =
{
	lib_managerTags,
	amijanssonTags,
	NULL
};

STATIC CONST struct TagItem libCreateTags [] =
{
	{ CLT_DataSize, sizeof (struct Library)	},
	{ CLT_InitFunc, (Tag) LibInit },
	{ CLT_Interfaces, (Tag) libInterfaces },

	/* Uncomment the following line if you have a 68k jump table */
	/* { CLT_Vector68K, (Tag) VecTable68K }, */

	{TAG_DONE, 0 }
};


/* ------------------- ROM Tag ------------------------ */
STATIC CONST struct Resident lib_res USED =
{
	RTC_MATCHWORD,
	(struct Resident *) &lib_res,
	(APTR) (&lib_res + 1),
	RTF_NATIVE | RTF_AUTOINIT, /* Add RTF_COLDSTART if you want to be resident */
	VERSION,
	NT_LIBRARY, /* Make this NT_DEVICE if needed */
	0, /* PRI, usually not needed unless you're resident */
	"jansson.library",
	VSTRING,
	(APTR) libCreateTags
};

uint32 _amijansson_Obtain (struct JanssonIFace *Self)
{
	/* Write me. Really, I dare you! */
	((struct ExecIFace *) ((*(struct ExecBase **) 4)->MainInterface))->DebugPrintF ("Function test::Obtain not implemented");

	return (uint32) 0;
}

uint32 _amijansson_Release (struct JanssonIFace *Self)
{
	/* Write me. Really, I dare you! */
	((struct ExecIFace *) ((*(struct ExecBase **) 4)->MainInterface))->DebugPrintF ("Function test::Release not implemented");
	return (uint32) 0;
}

/* Open the library */
struct Library *LibOpen (struct LibraryManagerInterface *Self, ULONG version)
{
	struct JanssonBase *lib_base_p = (struct JanssonBase *) Self->Data.LibBase;

	if (version > VERSION)
		{
			return NULL;
		}
	/*
	 * Add any specific open code here
	 * Return 0 before incrementing OpenCnt to fail opening
		*/

	/* Add up the open count */
	lib_base_p -> libNode.lib_OpenCnt ++;
	return ((struct Library *) lib_base_p);
}

/* Close the library */
struct Library *LibClose (struct LibraryManagerInterface *Self)
{
	struct JanssonBase *lib_base_p = (struct JanssonBase *) Self->Data.LibBase;

	/*
	 * Add any specific close code here
	 */

	/* decrement up the open count */
	lib_base_p -> libNode.lib_OpenCnt --;
	return 0;
}

/* The ROMTAG Init Function */
struct Library *LibInit(struct Library *LibraryBase, APTR seglist, struct Interface *exec)
{
	struct ExecIFace *IExec UNUSED = (struct ExecIFace *) exec;
	struct JanssonBase *lib_base_p = (struct JanssonBase *) LibraryBase;

	lib_base_p -> libNode.lib_Node.ln_Type = NT_LIBRARY;
	lib_base_p -> libNode.lib_Node.ln_Pri  = 0;
	lib_base_p -> libNode.lib_Node.ln_Name = "jansson.library";
	lib_base_p -> libNode.lib_Flags        = LIBF_SUMUSED | LIBF_CHANGED;
	lib_base_p -> libNode.lib_Version      = VERSION;
	lib_base_p -> libNode.lib_Revision     = REVISION;
	lib_base_p -> libNode.lib_IdString     = VSTRING;

	lib_base_p -> segList = (BPTR) seglist;

	/* Add any additional code here */
	NewlibBase = IExec->OpenLibrary ("newlib.library", 52);
	if (NewlibBase)
		{
			INewlib = (struct Interface *) IExec->GetInterface (NewlibBase, "main", 1, NULL);

			if(!INewlib)
				{
					return NULL;
				}
		}
	return (struct Library *) lib_base_p;
}

/* Expunge the library */
struct Library *LibExpunge (struct LibraryManagerInterface *Self)
{
	/* If your library cannot be expunged, return 0 */
	struct ExecIFace *IExec = (struct ExecIFace *)(* (struct ExecBase **)4) -> MainInterface;
	APTR result_p = (APTR) 0;
	struct JanssonBase *lib_base_p = (struct JanssonBase *) Self->Data.LibBase;

	if (lib_base_p -> libNode.lib_OpenCnt != 0)
		{
			lib_base_p -> libNode.lib_Flags |= LIBF_DELEXP;
		}
	else
		{
			result_p = (APTR) lib_base_p -> segList;
			/* Undo the code in LibInit */

			if (NewlibBase)
				{
					if (INewlib)
						{
							IExec->DropInterface (INewlib);
							INewlib = NULL;
						}

					IExec->CloseLibrary (NewlibBase);
					NewlibBase = NULL;
				}

			IExec->Remove ((struct Node *) lib_base_p);
			IExec->DeleteLibrary ((struct Library *) lib_base_p);
		}
	return result_p;
}

