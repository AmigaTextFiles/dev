@database cquickref.guide
@master cquickref.txt
@author "Bruce M. Simpson <bsimpson@touchdwn.demon.co.uk>"
@$VER: cquickref.guide 39.1 (4.8.95)
@wordwrap
@index foo_index
@node main "C Quick Reference - Index"
 @{"About C Quick Reference" link ABOUT}

 @{"C Datatypes" link C_DATATYPES}
 @{"C Keywords" link C_KEYWORDS}
 @{"C Operators" link C_OPERATORS}
 @{"C Statements and Constructs" link STATEMENTS}

 @{"Character Functions - Quick Reference" link CHAR_GUIDE}
 @{"Math Functions - Quick Reference" link MATH_GUIDE}
 @{"String Functions - Quick Reference" link STRING_GUIDE}

 @{"scanf() Formatting Commands" link SCANF_CMDS}
 @{"printf() Formatting Commands" link PRINTF_CMDS}
 @{"printf() Examples" link PRINTF_EXAMPLES}

 @{"Literal Character Constants" link CHAR_LITERALS}
 @{"Preprocessor Commands" link PP_CMDS}
 @{"Structure <> Pointer Relationships" link STRUCTS_AND_PTRS}

 @{"Mac Data Types" link MAC_DT}  @{"Mac Pascal <> C Conversions" link MAC_P2C}
@endnode
@node foo_index "Alphabetical Index of Nodes"

 @{b}A@{ub}

 @{"About C Quick Reference" link ABOUT}
 @{"Arithmetic Operators" link OP_MATH}

 @{b}B@{ub}

 @{"Bitwise Operators" link OP_BITWISE}

 @{b}C@{ub}

 @{"C Datatypes" link C_DATATYPES}
 @{"C Keywords" link C_KEYWORDS}
 @{"C Operators" link C_OPERATORS}
 @{"C Statements and Constructs" link STATEMENTS}
 @{"Character Functions - Quick Reference" link CHAR_GUIDE}
 @{"Comma Operator" link OP_COMMA}
 @{"Comparison Operators" link OP_COMPARISON}
 @{"Compound Assignment Operators" link OP_COMPOUND}
 @{"Conditional Operator" link OP_CONDITIONAL}

 @{b}D@{ub}

 @{"do..while" link SYNOPSIS_DO_WHILE}

 @{b}E@{ub}

 @{"Enumerations" link SYNOPSIS_ENUM}

 @{b}F@{ub}

 @{"for" link SYNOPSIS_FOR}
 @{"Function Call, Subscripting and Selection Operators" link OP_SUBSCRIPT}
 @{"Functions" link SYNOPSIS_FUNCS}

 @{b}I@{ub}

 @{"Initializers" link SYNOPSIS_INITS}

 @{b}L@{ub}

 @{"Literal Character Constants" link CHAR_LITERALS}
 @{"Logical Operators" link OP_LOGICAL}

 @{b}M@{ub}

 @{"Mac Data Types" link MAC_DT}
 @{"Mac Pascal <> C Conversions" link MAC_P2C}
 @{"Math Functions - Quick Reference" link MATH_GUIDE}

 @{b}O@{ub}

 @{"Order of Precedence" link OP_ASSOC_AND_PREC}

 @{b}P@{ub}

 @{"Preprocessor Commands" link PP_CMDS}
 @{"printf() Examples" link PRINTF_EXAMPLES}
 @{"printf() Formatting Commands" link PRINTF_CMDS}

 @{b}R@{ub}

 @{"Relative costs of various C operations" link OP_COSTS}

 @{b}S@{ub}

 @{"scanf() Formatting Commands" link SCANF_CMDS}
 @{"String Functions - Quick Reference" link STRING_GUIDE}
 @{"Structure <> Pointer Relationships" link STRUCTS_AND_PTRS}
 @{"Structures" link SYNOPSIS_STRUCT}
 @{"switch" link SYNOPSIS_SWITCH}

 @{b}T@{ub}

 @{"Type Definitions" link SYNOPSIS_TYPEDEF}

 @{b}U@{ub}

 @{"Unary Operators" link OP_UNARY}
 @{"Unions" link SYNOPSIS_UNION}

 @{b}W@{ub}

 @{"while" link SYNOPSIS_WHILE}

@endnode
@node ABOUT "About C Quick Reference"

    This AmigaGuide (tm) file is merely a collection of nuggets of useful
    information it's handy to have with you when you're developing in C for
    any platform.  There are some bits of interest for the Mac and the
    Amiga  though, and you're welcome to add to what has been built up here
    (but please mail the changes to me first).  It often saves you having
    to look up a C reference book, thus keeping your attention on the
    screen...  ;-)

    Remember, you can contribute to this AmigaGuide.  If you want a summary
    of types contained in the <exec/types.h> header file, then say so.  If
    you want more information on translating special storage classes and
    keywords from compiler to compiler, then tell me.

    Bruce M. Simpson  <bsimpson@touchdwn.demon.co.uk>

@endnode
@node C_DATATYPES "Basic Data Types"

    @{b}Type	Size@{ub} (bits)	@{b}Description@{ub}

    int		32		integers
    char	 8		character
    short	16		short integer
    long	32		long integer
    float	32		single precision floating point
    double	64		double precision floating point

 (Sizes given are for 32 bit Amigas)

@endnode
@node C_OPERATORS "Operators"

 The integer or arithmetic type of an operator result conforms to the
 result type as specified by the "usual arithmetic conversion" rules.

 @{"Order of Precedence" link OP_ASSOC_AND_PREC}
 @{"Relative costs of various C operations" link OP_COSTS}

 @{"Arithmetic Operators" link OP_MATH}
 @{"Bitwise Operators" link OP_BITWISE}
 @{"Comma Operator" link OP_COMMA}
 @{"Comparison Operators" link OP_COMPARISON}
 @{"Compound Assignment Operators" link OP_COMPOUND}
 @{"Conditional Operator" link OP_CONDITIONAL}
 @{"Function Call, Subscripting and Selection Operators" link OP_SUBSCRIPT}
 @{"Logical Operators" link OP_LOGICAL}
 @{"Unary Operators" link OP_UNARY}


@endnode
@node OP_SUBSCRIPT "Function Call, Subscripting And Selection Operators"


	@{b}Operator	Synopsis		Description@{ub}

	()		funcname()		Function call
	[]		arrayptr[]		subscript
	 .		struct.member		direct selection
	->		structptr->member	indirect selection

@endnode
@node OP_UNARY "Unary Operators"

 @{b}Operator	Operation	  Operands		Result Type@{ub}

	*	dereferencing	  pointer to any type	base type
	&	address of	  variable of any type	pointer to type
	-	negation	  arithmetic		arithmetic
	!	logical not	  arithmetic or ptr	integer
	~	one's complement  integer		int, long or unsigned
	++	increment	  arithmetic or ptr	arithmetic
	--	decrement	  arithmetic or ptr	arithmetic
      (type)	cast		  any type		specified type
     sizeof()	size of		  expression or type	unsigned


 @{b}Note:@{ub}	variables of arithmetic type are incremented by 1 and those of
	pointer-type by the size in bytes of the object they point to; i++
	signifies post-increment and ++i pre-increment before expression
	evaluation respectively.  Similar conditions for the '--' operator.


@endnode
@node OP_MATH "Arithmetic Operators"

@{b}Operator	   Operation	    Operand		Result Type@{ub}

    *		multiplication	arithmetic		arithmetic
    /		division	arithmetic		arithmetic
    %		modulo		integer			integer
    +		addition	arithmetic or ptr	integer or ptr
    -		subtraction	aritmetic or ptr	integer or ptr


 @{b}Note:@{ub}	In the case of pointer and int add/subtract, the integral operand
	is multiplied by the size of the pointer's base type before the
	operation.  Also, when one pointer is subtracted from another, the
	result is divided by the size of the pointer's base type.


@endnode
@node OP_BITWISE "Bitwise Operators"

 @{b}Operator	Operation	Operands	Result Type@{ub}

	<<	left shift	integer		same as left operand
	>>	right shift	integer		same as left operand
	&	bitwise and	integer		integer
	^	bitwise xor	integer		integer
	|	bitwise or	integer		integer


 @{b}Note:@{ub}	0 fill for vacated bits, unless right shift and SIGNED, in which
	case the sign bit is propagated.

@endnode
@node OP_COMPARISON "Comparison Operators"

 @{b}Operator	Operation		Operands		RResult Type@{ub}

	<	less than		arithmetic or ptr	integer
	>	greater than		arithmetic or ptr	integer
	<=	less than or = to	arithmetic or ptr	integer
	>=	greater than/= to	arithmetic or ptr	integer
	==	equality		arithmetic or ptr	integer
	!=	inequality		arithmetic or ptr	integer

@endnode
@node OP_LOGICAL "Logical Operators"

 @{b}Operator	Operation	Operands		Result Type@{ub}

	&&	logical and	arithmetic or ptr	integer
	||	logical or	arithmetic or ptr	integer

 The second operand of the logical operators is evaluated only if necessary.

@endnode
@node OP_CONDITIONAL "Conditional Operator"

 @{b}Synopsis@{ub}

	expression ? exp_true : exp_false

 @{b}Notes@{ub}

	The value of the conditional expression evaluates to exp_true if
	'expression' is true, else exp_false.

@endnode
@node OP_COMPOUND "Compound Assignment Operators"

 This allows expressions such as " var = var op exp " to be abbreviated to
 " var op= exp ", where `op' is a compound assignment operator.  Result
 type is always same as left operand.  The same rules apply for operand
 type as for the long forms of these operators.

 @{b}WARNING:@{ub} older K&R compilers may treat e.g.  =+ as being += which result
  in ambiguous meanings for expressions not seperated with white space!


 @{b}Operator		Operation		Operands@{ub}

	+=		add to variable		arithmetic
	-=		subtract from variable	arithmetic
	*=		multiply variable	arithmetic
	/=		divide variable by	arithmetic
	%=		modulo of variable	integer
	>>=		right shift variable	integer
	<<=		left shift variable	integer
	&=		bitwise AND variable	integer
	^=		bitwise XOR variable	integer
	|=		bitwise OR variable	integer


@endnode
@node OP_COMMA "Comma Operator"

 @{b}Synopsis@{ub}

	exp1, exp2

 @{b}Notes@{ub}

	This should not be confused with the use of the comma in function
	calls, definitions and declarations, or in block initialization.  The
	expression 'exp1' is evaluated first, and the type and value of the
	expression is that of exp2.

@endnode
@node OP_ASSOC_AND_PREC "Operator Associativity and Precedence"

 Operators are listed in decreasing order of precedence.

 @{b}Direction	Operators@{ub}

    LR		() [] -> .
    RL		! ~ ++ -- - * & (type) sizeof
    LR		* / %
    LR		+ -
    LR		<< >>
    LR		< <= > >=
    LR		== !=
    LR		&
    LR		^
    LR		|
    LR		&&
    LR		||
    RL		?
    RL		= += -= *= /= %= &= ^= |= <<= >>=
    LR		,

@endnode
@node OP_COSTS "Relative computational cost of common C operations"

	@{b}Operation			Relative Cost@{ub}

	Standard IO (printf..)		1000
	Trigonometric functions		500
	Floating point math		100
	Integer divide			30
	Integer multiply		20
	Function call			10
	Simple array index		6
	Bit shifting			5
	Add / subtract			5
	Pointer dereferencing		2
	Bitwise AND / OR / NOT		1
	Logical AND / OR / NOT		1

@endnode
@node STRUCTS_AND_PTRS "Structure and Pointer Relations"

	structure.item	     =	(*structure_ptr).item = structure_ptr->item
	*(character_ptr)     =	character_ptr[0]
	*(character_ptr + n) =	character_ptr[n]
	*a[i]		     =	object pointed to by ith element of a.
	(*b)[i]		     =	ith element of the array pointed to by b.


@endnode
@node STATEMENTS "Synopsis of C Language Constructs"

 @{"Enumerations" link SYNOPSIS_ENUM}

 @{"Functions" link SYNOPSIS_FUNCS}

 @{"Initializers" link SYNOPSIS_INITS}

 @{"Structures" link SYNOPSIS_STRUCT}

 @{b}Statements@{ub}

	@{"switch" link SYNOPSIS_SWITCH}
	@{"for" link SYNOPSIS_FOR}
	@{"while" link SYNOPSIS_WHILE}
	@{"do..while" link SYNOPSIS_DO_WHILE}

 @{"Type Definitions" link SYNOPSIS_TYPEDEF}

 @{"Unions" link SYNOPSIS_UNION}

@endnode
@node SYNOPSIS_SWITCH "Synopsis of 'switch' Statement"

	switch (exp)
	{
		case-label-1: statements-1
		case-label-2: statements-2
		case-label-n: statements-n
		default-case: statements-default
	}

@endnode
@node SYNOPSIS_FOR "Synopsis of 'for' Statement"


	for (initial-value; termination-condition; next-value) statement;

@endnode
@node SYNOPSIS_WHILE "Synopsis of 'while' Statement"

	while (expression) statement;

@endnode
@node SYNOPSIS_DO_WHILE "Synopsis of 'do..while' Statement"

	do statement while (expression);

 @{b}Notes@{ub}

	This expression is evaluated _after_ each execution of the loop body,
	as opposed to the 'ordinary' WHILE statement, where the expression is
	evaluated first thing.

@endnode
@node SYNOPSIS_TYPEDEF "Synopsis of Type Definitions"

	typedef <type> <type-name>

@endnode
@node SYNOPSIS_ENUM "Synopsis of Enumerated Type Declarations"

	enum <tag>
	{
		name1 [=const_exp],
		name2 [=const_exp],
		...
		nameN [=const_exp]
	};

@endnode
@node SYNOPSIS_STRUCT "Synopsis of Structure Declarations"

 @{b}Declaring a Structure@{ub}

	struct <tag>
	{
		type1 name1;
		type2 name2;
		...
		typeN nameN;
	};

 @{b}Defining a Structure@{ub}

	struct	[tag] |
		[{	type-1 name-1;
			type-2 name-2;
			...    ...
			type-n name-n;
		}]
		<name>;
@endnode
@node SYNOPSIS_UNION "Union Declarations"

	union <tag>
	{
		component-1;
		component-2;
		...
		component-n;
	}

@endnode
@node SYNOPSIS_INITS "Initializers"

	var = <initial-value>
	var = { <initial-value-list> }
	var = { <initial-value-list>, }
	var = "<sequence-of-characters>"

@endnode
@node SYNOPSIS_FUNCS "Functions"

 @{b}Defining a Function@{ub}

	<result-type> <function-name>(<parameter-declarations>)
	{
		<type declarations, variable definitions, and declarations>
		<statements>
	}

 @{b}Function Declarations@{ub}

	<result-type> <function-name>(<parameter-declarations>);

 @{b}Function Calls@{ub}

	<function-name>(<arguments>)

@endnode
@node CHAR_LITERALS "Literal Character Constants"

    @{b}Literal	ASCII	Description@{ub}

	\n	LF	linefeed
	\t	HT	horizontal tab
	\v	VT	vertical tab
	\b	BS	backspace
	\r	CR	carriage return
	\f	FF	formfeed
	\a	BEL	alert
	\\	\	backslash
	\?	?	question mark
	\'	'	single quote
	\"	"	double quote
	\ooo	ooo	octal number
	\xhh	xhh	hexadecimal number
	\0	NUL	NUL character

@endnode
@node PP_CMDS "ANSI Standard Preprocessor Commands"

 @{b}Command		Synopsis		Description@{ub}

#define	identifier   token string	define an identifier
#define	id (id, ...) token string	define a macro
#undef	identifier			undefine an identifier or macro

#include  "filename"			include file relative to current dir
#include  <filename>			include file from include path
#include  token-sequence		include ?

#if	constant-expression		if expression is true...
#ifdef	identifier			if identifier is defined...
#ifndef	identifier			if idnetifier is not defined...
#elif	constant-expression		else if expression is true...
#else					else...
#endif					terminate conditional construct

#line	constant  "filename"		change line counter and filename
#line	constant			change line counter **

#error	token-sequence(opt)		cause compilation error
#pragma	token-sequence(opt)		compiler specific
#					no-op

 ** ANSI Standard specifies that constant < 32767, although some
    implementations ignore this limitation, notably SAS/C.

@endnode
@node C_KEYWORDS "C Language Reserved Keywords"

	auto		double		int		struct
	break		else		long		switch
	case		enum		register	typedef
	char		extern		return		union
	const		float		short		unsigned
	continue	for		signed		void
	default		goto		sizeof		volatile
	do		if		static		while

@endnode
@node SCANF_CMDS "Formatting Commands for scanf() family of functions"

    @{b}Command	Description			Operand type@{ub}

	%d	decimal integer			int *
	%i	integer				int *
	%o	octal integer			int *
	%u	unsigned decimal integer	unsigned int *
	%x	hexadecimal integer		int *
	%c	characters			char *
	%s	string				char[] or char *
	%e,f,g	floating-point number		float *
	%p	pointer				void *
	%%	literal %			n/a.

Note: '%p' is not ANSI standard.


@endnode
@node PRINTF_CMDS "Formatting Commands for printf() family of functions"

    @{b}Command	Description			Operand type@{ub}

	%d,i	decimal notation		int
	%ld	long integer decimal		int
	%o	unsigned octal			int
	%x,X	unsigned hexadecimal		int
	%u	unsigned decimal		unsigned int
	%c	character			int or char
	%s	string				char[] char *
	%f	decimal notation		double or float
	%e,E	exponential notation		double or float
	%g,G	use shorter of %e or %f		double or float
	%p	pointer				void *
	%%	literal %			n/a

 @{b}Note:@{ub}	'%p' is not ANSI standard.
	Format of %e is usually "[-]m.nnnnnnE[±]xx"


@endnode
@node PRINTF_EXAMPLES "Example Uses of printf()"

	%3d	print in a 3 digit field, right justified
	%3.0f	print no decimal point and no fraction
	%3.1f	print 1 digit after the decimal point
	%.1f	print 1 digit after the decimal point, any width

	Between the % and the conversion character there may be a minus sign,
	to specify left adjustment of the field, and two digit strings
	separated by a period.  The first string speci- fies minimum field
	width, and the second string specifies the maximum number of chars
	to be printed from the string.

	:%10s:		:hello, world:
	:%-10s:		:hello, world:
	:%20s:		:        hello, world:
	:%-20s:		:hello, world        :
	:%20.10s:	:          hello, wor:
	:%-20.10s:	:hello, wor          :
	:%.10s:		:hello, wor:

@endnode
@node MATH_GUIDE "Quick Guide to Standard Math Library"

    @{b}Function	Description@{ub}

	sin(x)		sine of x
	cos(x)		cosine of x
	tan(x)		tangent of x
	asin(x)		inverse sine of x (i.e. returns the angle)
	acos(x)		inverse cosine of x
	atan(x)		inverse tan of x
	atan2(y,x)	inverse tan of (x / y)
	sinh(x)		hyperbolic sine of x
	cosh(x)		hyperbolic cosine of x
	tanh(x)		hyperbolic tangent of x
	exp(x)		exponential function
	log(x)		natural [base e] logarithm
	log10(x)	base 10 logarithm
	pow(x,y)	x to the power of y
	sqrt(x)		square root of x
	ceil(x)		smallest integer not less than x
	floor(x)	largest integer not greater than x
	fabs(x)		absolute value
	fmod(x,y)	floating-point remainder of x/y


@endnode
@node STRING_GUIDE "Quick Guide to Standard String Functions"

@{b}	Function		Description@{ub}

	strcat(s,t)		concatenate t to the end of s
	strncat(s,t,n)		concatenate n characters of t to end of s
	strcmp(s,t)		<0 if(s<t), 0 if(s==t), >0 if(s>t)
	strncmp(s,t,n)		same as strcmp but only in first n characters
	strcpy(s,t)		copy t into s
	strncpy(s,t,n)		copy at most n characters of t into s
	strlen(s)		return length of s
	strchr(s,c)		return pointer to first c in s, else NULL
	strrchr(s,c)		return pointer to last c in s, else NULL


@endnode
@node CHAR_GUIDE "Quick Guide to Standard Character Class Functions"

@{b}	Function / Macro	Description@{ub}

	isalpha(c)		is c an alphabetic char ?
	isupper(c)		is c upper case ?
	islower(c)		is c lower case ?
	isdigit(c)		is c a numeric char [0..9] ?
	isalnum(c)		is c an alphanumeric char ?
	isspace(c)		is c whitespace (space, TAB, LF, FF, VT or CR) ?
	toupper(c)		return c converted to upper case
	tolower(c)		return c converted to lower case

@endnode
@node MAC_P2C "Mac Pascal-to-C Type Conversions"

	@{b}Pascal Type		C Type@{ub}

	INTEGER			int
	LONGINT			long
	CHAR			int
	BOOLEAN			char
	Byte			Byte(struct), int(passed)
	VAR Byte		int *
	Handle			Handle
	VAR Handle		Handle *
	Ptr			Ptr
	VAR Ptr			Ptr *
	OSType, ResType		long
	PACKED ARRAY[]		long
	String255		Str255 or char *
	VAR String255		Str255 or char *
	StringPtr		StrPtr or char *
	VAR StringPtr		StrPtr * or char *
	Rect			Rect *
	VAR Rect		Rect *
	Point			Point
	VAR Point		Point *

@endnode
@node MAC_DT "Mac Data Types"

	@{b}Type		Size [bits]	Description@{ub}

	char		 8		character
	short		16		short integer
	int		16		integer
	long		32		long integer
	float		32		single precision floating point
	short double	64		short double precision f.p.
	double		80		double precision floating point
	double		96		double precision (when using an FFP)
	Ptr		32		pointer
	Handle		32		handle
	Byte		 8		byte
	Boolean		 8		boolean

	Str255		256 bytes (4 when passed)
	(255 char Pascal string)


 @{b}Mac Parameter Passing@{ub}

	Object			What gets passed

	VAR Parameter		pointer to object
	sizeof(type) < 4	object
	sizeof(type) > 4	pointer to object

@endnode
