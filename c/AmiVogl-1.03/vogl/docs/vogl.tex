\documentstyle[12pt]{article}
\pagestyle{myheadings}

\markright{\hfill VOGL\hfill\today\hfill}
\makeindex

\title{{\bf V O G L} \\
\normalsize\bf A very ordinary GL Library}

\author{Eric H. Echidna}

% Abbreviations
\newcommand{\FORTRAN}{{\small FORTRAN}}
\newcommand{\NULL}{{\small NULL}}
\newcommand{\VDEVICE}{{\small VDEVICE}}
\newcommand{\VOGL}{{\small VOGL}}
\newtheorem{alg}{Algorithm}

% Hyphenation Control Center
\hyphenation{Screen-coord}

% Make the text a bit wider than default
\newcommand{\widepage}{
 \setlength{\footheight}{0in}
 \setlength{\topmargin}{0.0in}
 \setlength{\oddsidemargin}{0in}
 \setlength{\textwidth}{6.5in}
 \setlength{\textheight}{9.0in}
 }
\widepage

\begin{document}

\maketitle

\begin{abstract}

     \VOGL\ is a library of C routines which try to  allow  a  programmer  to
     write  programs  which can be moved to machines which have the Silicon
     Graphics GL library on  them.  It  is based  entirely  on  the  {\small
     VOGLE}  graphics  library, and as a result  can  handle  circles, curves,
     arcs,  patches,  and polygons in a device independent fashion.  Simple
     hidden line removal is also available via polygon backfacing.  Access  to
     hardware  text  and  double buffering of drawings depends on the driver.
     There is also a \FORTRAN\ interface  but  as  it goes through  the  C
     routines \FORTRAN\ users are warned that arrays are in row-column order in
     C. Both the  long  \FORTRAN\ names  and  the shortened six character names
     are supported.  People interested in using  software text  should  see
     the hershey library, {\small HERSHEY}(3).  More information on the \FORTRAN\ 
     interface is contained in {\em vogl.doc}; the interface described herein
     is the C interface.

     Some routines are only available in \VOGL.  If  you  include
     them  in  programs  it  is  advisable to put \verb^#ifdef VOGL^ ...
     \#endif around them. The constant \verb^VOGL^ is defined whenever  a
     \VOGL\ header file is included.

     It should be noted that there are a number of routines  that
     take the type Angle for some of their parameters. All angles
     specified this way are actually Integer Tenths  Of  Degrees.
     (Don't ask!)

\end{abstract}

\newpage
\setcounter{page}{1}
\renewcommand{\thepage}{\roman{page}}

\small
\tableofcontents
\normalsize
\newpage
\setcounter{page}{1}
\renewcommand{\thepage}{\arabic{page}}

\section{Include Files}
     There are two include files provided with vogl:  \verb`vogl.h`  and
     \verb`vodevice.h`.   The  file  \verb`vogl.h` has the type definitions and
     function interfaces, ideally it is included where you  would otherwise
     include  \verb`gl.h` on an SGI. The file \verb`vodevice.h` has the devices
     in it, and it is included where you would  include  \verb`device.h`
     on an SGI.

     The following is a brief summary of the \VOGL\ subroutines.


\section{Device routines}

  \begin{description}
     \item[void vinit]{(\small char *device)} \\
     \index{vinit}
          Tell \VOGL\ what the device is. This routine needs to  be
          called  if  the environment variable \VDEVICE\ isn't set,
          or if the value in \VDEVICE\ is not to be used.

       \begin{enumerate}
         \item Current available devices are:
           \begin{description}
             \item[amiga]    Amiga graphics {\it implemented by Dr.~Charles
                             E. Campbell, Jr.}
             \item[apollo]   Apollo workstations
             \item[cga]      IBM PC cga graphics card
             \item[decX11]   The decstation (old) window manager.
                             This is only included in case you need it.
             \item[dxy]      Roland DXY plotter language
             \item[ega]      IBM PC ega graphics card
             \item[hercules] IBM PC hercules graphics card
             \item[hpgl]     HP Graphics language and compatibles
             \item[NeXT]     NeXTStep
             \item[postscript]  postscript devices
             \item[ppostscript] postscript devices (portrait mode)
             \item[sigma]    IBM PC sigma graphics card.
             \item[sun]      Sun workstations running sunview
             \item[tek]      Tektronix 4010 and compatibles
             \item[vga]      IBM PC vga graphics card
             \item[X11]      X windows (SUN's Openwindows etc etc)
           \end{description}

           Sun, X11, decX11, apollo, hercules, cga and ega support double buffering.

         \item If device is a \NULL\ or a null string the value
                    of the environment variable \VDEVICE\ is taken as the
                    device type to be opened.

         \item after init it is wise to explicitly clear the screen.
           \begin{verbatim}
             color(BLACK);
             clear();
           \end{verbatim}
         \end{enumerate}


     \item[void ginit]() \\ \index{ginit}
	      Open the graphics device and do the  basic  initialisation. This
	      routine is marked for obsolescence. The routine winopen (see below)
	      should be used instead.

     \item[long winopen]{\small (char *title)} \\ \index{winopen}
          Open the graphics device and do the  basic  initialisation.
          This routine should be used instead of ginit.


     \item[void gexit]{\small ()} \\ \index{gexit}
          Reset the window/terminal (must be the last  \VOGL\  rou
          tine called)

     \item[void voutput]{\small (char *path)} \\ \index{voutput}
          Redirect output from {\em next}  ginit  to  file  given  by
          path. This routine only applies to devices drivers that
          write to stdout e.g. postscript and hpgl.


     \item[void vnewdev]{\small (char *device)} \\ \index{vnewdev}
          Reinitialize \VOGL\ to use a new device without  changing
          attributes,  viewport  etc.   (eg.  window and viewport
          specifications)

     \item[int getplanes]{\small ()} \\ \index{getplanes}
          Returns the number of bit planes (or  color
          planes)  for  a particular device. The number of colors
          displayable by the device is then $2^{(nplanes-1)}$
  \end{description}


\section{Routines For Setting Up Windows}

     Some devices are basically window orientated - like  sunview
     and X11. You can give \VOGL\ some information about the window
     that it will use with these routines.  These can  make  your
     code  very  device  dependent.  Both routines take arguments
     which are in device space. (0, 0) is the  bottom  left  hand
     corner  in  device  space. To have any effect these routines
     must be called before ginit or winopen.  For the X11 device,
     an  entry  may  be  made in your .Xdefaults file of the form
     $vogl.Geometry  =150x500+550+50$ (where  you   specify   your
     geometry as you please).

     \begin{description}
     \item[void prefposition]{\small (long x1, long y1, long x2, long y2)} \\
     \index{prefposition}
          Specify the preferred position of the window opened  by
          the {\em next} winopen.

     \item[void prefsize]{\small (long width,long height)} \\
     \index{prefsize}
          Specify the preferred width and height  of  the  window
          opened by the *next* winopen.

     \item[void reshapeviewport]{\small ()} \\
     \index{reshapeviewport}
          This is occasionally used in Iris GL if a {\small REDRAW}  event
          rolls  up.  While  \VOGL\ is  unlikely to ever provide a
          {\small REDRAW} event the call is provided for compatibility.
     \end{description}


\section{General Routines}

     \begin{description}
     \item[void clear]{\small ()} \\
     \index{clear}
          Clears the current viewport to the current color.

     \item[void color]{\small (Colorindex col)} \\
     \index{color}
          Set the current color. The standard colors are as follows:

          \begin{center}
            \begin{tabular}{||lcc|lcc|lcc|lcc||}
            \hline\hline
            black & = & 0 & red     & = & 1 & green & = & 2 & yellow & = & 3 \\
            blue  & = & 4 & magenta & = & 5 & cyan  & = & 6 & white  & = & 7 \\
            \hline\hline
            \end{tabular}
          \end{center}

          These are included in \verb`vogl.h` as:
          {\small BLACK}, {\small RED}, {\small GREEN}, {\small YELLOW},
          {\small BLUE}, {\small MAGENTA}, {\small CYAN} and {\small WHITE}.

     \item[void colorf]{\small (float col)} \\
     \index{colorf}
          Same as color only it takes a floating point  argument.
          In  Iris  GL there are sometimes good reasons for using
          this routine over color. See the  GL  manual  for  more
          details.

    \item[void mapcolor]{\small (Colorindex indx,short red,short green,short blue)} \\
     \index{mapcolor}
          Set the color map index indx to the  color  represented
          by  (red, green, blue).  If the device has no color map
          this call does nothing.

     \item[void defbasis]{\small (short id, Matrix mat)} \\
     \index{defbasis}
          Define basis number id to be the matrix mat.

     \item[void polymode]{\small (long mode)} \\
     \index{polymode}
    	  {\small NOTE}: For this call to have any effect  it  must  have been
    	  conditionally  compilied  into  the library. (See \verb`polygons.c` for
    	  details)  Control   the   filling   of polygons.  The \verb`mode`
    	  must be {\small PYM\_LINE}, which means only the edges
    	  of the polygon will be drawn, or {\small PYM\_FILL}, which  means
    	  fill the  polygon  (the default). {\small PYM=\_POINT} and {\small
    	  PYM\_HOLLOW} are also  recognised but they don't behave quite as they
    	  would with {\small SGI GL}.
      \end{description}


\section{The Device Queue and Valuator Routines}

     The available  devices  are  defined  in  the  header  files
     {\em vodevice.h}.

     \begin{description}
     \item[void qdevice]{\small (Device dev)} \\
     \index{qdevice}
          Enable a device. Note: in \VOGL\ the queue is of length 1.

     \item[void unqdevice]{\small (Device dev)} \\
     \index{unqdevice}
          Disable a device.

     \item[long qread]{\small (short *data)} \\
     \index{qread}
          Read an event from  the  device  queue.  This  routines
          blocks  until  something happens. Note: it is important
          to have called qdevice before doing this.

     \item[Boolean isqueued]{\small (Device dev)} \\
     \index{isqueued}
          Check to see if device dev is enabled for queueing.

     \item[Boolean qtest]{\small ()} \\
     \index{qtest}
          Check if there is anything in the queue. Note: in  VOGL
          the queue is only 1 entry deep.

     \item[void qreset]{\small ()} \\
     \index{qreset}
          Reset the device queue. This will get rid of any  pending events.

     \item[Boolean getbutton]{\small (Device dev)} \\
     \index{getbutton}
          Returns the up (0) or down (1) state of a button.

     \item[long getvaluator]{\small (Device dev)} \\
     \index{getvaluator}
          Return the current value of the valuator. Currently the
          only valuators supported are {\small MOUSEX} and {\small MOUSEY}.
     \end{description}


\section{Viewport Routines}

     \begin{description}
     \item[void viewport] {\small (Screencoord left, Screencoord right,
     \index{viewport}
       Screencoord bottom, Screencoord top)} \\
          Specify which part of the  screen  to  draw  in.  Left,
          right,  bottom,  and  top  are integer values in screen
          coordinates.

     \item[void pushviewport]{\small ()} \\
     \index{pushviewport}
          Save current viewport on the viewport stack.

     \item[void popviewport]{\small ()} \\
     \index{popviewport}
          Retrieve last pushed viewport.

     \item[void getviewport]{\small (Screencoord *left, Screencoord *right,
     \index{getviewport}
       Screencoord *bottom, Screencoord *top)} \\
          Returns the left, right, bottom and top limits  of  the
          current viewport in screen coordinates.
     \end{description}


\section{Attribute Stack Routines}
     The attribute stack contains details such as current  color,
     and  the  current font number. If you need to prevent object
     calls form changing these,  use  pushattributes  before  the
     call and popattributes after.

     \begin{description}
     \item[void pushattributes]{\small ()} \\
     \index{pushattributes}
          Save the current attributes on the attribute stack.

     \item[void popattributes]{\small ()} \\
     \index{popattributes}
          Restore the attributes to what they were  at  the  last
          pushattribute().
     \end{description}


\section{Projection Routines}

     All the projection  routines  define  a  new  transformation matrix,  and
     consequently the world units. Parallel projections are defined by ortho
     or  ortho2.  Perspective  projections  can be  defined by perspective and
     window.  Note the types Angle, etc, are defined in vogl.h. Remember angles
     are in tenths of degrees.

     \begin{description}
     \item[void ortho]{\small (Coord left, Coord right, Coord bottom, Coord top,
     \index{ortho}
       Coord near\_fd,Coord far\_d)} \\
          Define x (left, right), y (bottom, top), and  z  (near,
          far)  clipping planes. The near and far clipping planes
          are actually specified as distances along the  line  of
          sight.  These  distances  can  also  be  negative.  The
          actual location of the clipping planes is z  =  -near\_d
          and z = -far\_d.

     \item[void ortho2]{\small (Coord left,Coord right,Coord bottom,Coord top)} \\
     \index{ortho2}
          Define x (left, right), and y  (bottom,  top)  clipping
          planes.

     \item[void perspective]{\small (Angle fov,float aspect,Coord near,Coord far)} \\
     \index{perspective}
	  Specify a perspective viewing pyramid in world  coordinates  by
	  giving a field of view, aspect ratio and the distance from the eye
	  of  the  near  and  far  clipping plane.

     \item[void window]{\small (Coord left,Coord right,Coord bot,Coord top,
     \index{window}
                             Coord near,Coord far)} \\
          Specify a perspective viewing pyramid in world coordinates by
          giving the rectangle closest to the eye (ie. at the near clipping
          plane) and the distances to the near and far clipping planes.
     \end{description}


\section{Matrix Stack Routines}

     \begin{description}
     \item[void pushmatrix]{\small ()} \\
     \index{pushmatrix}
          Save the current transformation matrix  on  the  matrix
          stack.

     \item[void popmatrix]{\small ()} \\
     \index{popmatrix}
          Retrieve the last matrix pushed and make it the current
          transformation matrix.
     \end{description}


\section{Viewpoint Routines}

     Viewpoint routines alter the current tranformation matrix.

     \begin{description}
     \item[void polarview]{\small (Coord dist,Angle azim,Angle inc,Angle twist)} \\
     \index{polarview}
          Specify the viewer's position in polar  coordinates  by
          giving  the  distance  from  the viewpoint to the world
          origin, the azimuthal angle in the x-y plane,  measured
          from  the y-axis, the incidence angle in the y-z plane,
          measured from the z-axis, and the twist angle about the
          line of sight.

     \item[void lookat]{\small (Coord vx,Coord vy,Coord vz,Coord px,Coord py,Coord pz,
     \index{lookat}
                             Angle twist)} \\
          Specify the viewer's position by giving a viewpoint and
          a  reference  point in world coordinates. A twist about
          the line of sight may also be given.
     \end{description}


\section{Move Routines}

     There are variations on all these routines that end  in  {\it s\/} and  also end
     in {\it i}.
     \begin{description}
     \item[\it s\/]: These variations they take arguments of type {\it Scoord}.
     \item[\it i\/]: These variations they take arguments of type {\it Icoord}.
     \end{description}

     \begin{description}
     \item[void move]{\small (Coord x,Coord y,Coord z)} \\
     \index{move}
          Move current graphics position to (x, y, z). (x, y,  z)
          is a point in world coordinates.

     \item[void rmv]{\small (Coord deltax,Coord deltay,Coord deltaz)} \\
     \index{rmv}
          Relative move. deltax, deltay, and deltaz  are  offsets
          in world units.

     \item[void move2]{\small (Coord x,Coord y)} \\
     \index{move2}
          Move graphics position to point (x, y).  (x,  y)  is  a
          point in world coordinates.

     \item[void rmv2]{\small (Coord deltax,Coord deltay)} \\
     \index{rmv2}
          Relative move2. deltax and deltay are offsets in  world
          units.
     \end{description}


\section{Drawing Routines}

     There are variations on all these routines that end  in  {\it s\/} and  also end
     in {\it i}.
     \begin{description}
     \item[void draw]{\small (Coord x,Coord y,Coord z)} \\
     \index{draw}
	  Draw from current graphics position to (x, y,  z), a point in world
	  coordinates.

     \item[void rdr]{\small (Coord deltax,Coord deltay,Coord deltaz)} \\
     \index{rdr}
          Relative draw. deltax, deltay, and deltaz  are  offsets
          in world units.

     \item[void draw2]{\small (Coord x,Coord y)} \\
     \index{draw2}
          Draw from current graphics position to  point  (x,  y).
          (x, y) is a point in world coordinates.

     \item[void rdr2]{\small (Coord deltax,Coord deltay)} \\
     \index{rdr2}
          Relative draw2. deltax and deltay are offsets in  world
          units.
     \end{description}


\section{Vertex calls}

     There are calls which we term 'vertex  calls'  which  simply
     specify  a  point in 4D, 3D or 2D. These calls take an array
     which specifies the coordinates of the point. The  interpretation
     of these points is described below.

     \begin{description}
     \item[void v4d]{\small (double v[4])} \\
     \index{v4d}
           Specify a vertex(point) in 4D using double  precision
           numbers.

     \item[void v4f]{\small (float v[4])} \\
     \index{v4f}
          Specify a vertex(point) in 4D using single  precision
          floating point numbers.

     \item[void v4i]{\small (long v[4])} \\
     \index{v4i}
          Specify a vertex(point) in 4D using integer numbers

     \item[void v4s]{\small (short v[4])} \\
     \index{v4s}
          Specify a vertex(point) in  4D  using  short  integer numbers
     \end{description}

     There are also equivalent calls for 3D points ({\it v3d, v3f, v3i, v3s\/})
     and 2D points ({\it v2d, v2f, v2i, v2s\/}).  The only difference is the
     number of elements that each vertex needs to be specified. It should also
     be noted the the different data types (ie.~double, float, long and
     short)  are merely different  ways  of representing  the same basic
     coordinate data (calling v3s with \verb`v[] = {100,200,200}` is the same
     as calling v3f with \verb`v[] = {100.0, 200.0, 200.0}`).

     The way these points are interpreted depends  on  what  mode
     has  be  set  up  with  one  of the calls {\it bgnpoint, bgnline,
     bgnclosedline\/} or {\it bgnpolygon}.

     \begin{description}
     \item[void bgnpoint]{\small ()} \\
     \index{bgnpoint}
         The  bgnpoint  call  specifies that  the next series of vertex
         calls are specifying a chain of points (dots) to be drawn.

     \item[void endpoint]{\small ()} \\
     \index{endpoint}
         A bgnpoint is terminated  with a endpoint call.

     \item[void bgnline]{\small ()} \\
     \index{bgnline}
         The bgnline call specifies that the next  series  of  vertex
         calls are specifying the points on a polyline.

     \item[void endline]{\small ()} \\
     \index{endline}
         A bgnline is terminated with a endline call.

     \item[void bgnclosedline]{\small ()} \\
     \index{bgnclosedline}
         The bgnclosedline call is similar to the bgnline except that
         when  endclosedline is called the first point given (ie. the
         one first after the bgnclosedline call)  is  joined  to  the
         last  point given (ie. the one just before the endclosedline
         call).

     \item[void endclosedline]{\small ()} \\
     \index{endclosedline}
         A bgnclosedline is terminated with a endline call.

     \item[void bgnpolygon]{\small ()} \\
     \index{bgnpolygon}
         The bgnpolygon call specifies that the next series of vertex
         calls  are  defining  a polygon. 

     \item[void endpolygon]{\small ()} \\
     \index{endpolygon}
         When endpolygon is called, the polygon is closed and filled (or
         drawn  as  an  outline depending  on  the  mode that has been
         set with the polymode call if this call has been compilied into
         the library.
     \end{description}


\section{Arcs and Circles}

     There are variations on all these routines that end  in  {\it s} and 
     also end in {\it i\/}.
     \begin{description}
     \item[\it s\/]: These variations they take arguments of type {\it Scoord}.
     \item[\it i\/]: These variations they take arguments of type {\it Icoord}.
     \end{description}

     The functions supporting arc and circle drawing are as follows.

     \begin{description}
     \item[void circleprecision]{\small (int nsegs)} \\
     \index{circleprecision}
          Set the number of line segments  making  up  a  circle.
          Default  is  currently $32$. The number of segments in an
          arc is calculated from nsegs according the span of  the
          arc.  This routine is only available in \VOGL.

     \item[void arc]{\small (Coord x,Coord y,Coord radius,Angle startang,Angle endang)} \\
     \index{arc}
          Draw an arc. x, y,  and  radius  are  values  in  world
          units.

     \item[void arcf]{\small (Coord x,Coord y,Coord radius,Angle startang,Angle endang)} \\
     \index{arcf}
          Draw a filled arc. x, y, and radius are values in world
          units.  (How the filling is done may be changed by calling polymode,
          if this call has  been  compilied  into the library).

     \item[void circ]{\small (Coord x,Coord y,Coord radius)} \\
     \index{circ}
          Draw a circle. x, y, and radius  are  values  in  world coordinates.

     \item[void circf]{\small (Coord x,Coord y,Coord radius)} \\
     \index{circf}
          Draw a filled circle. x, y, and radius  are  values  in
          world units.  How the filling is done may be changed by
          calling polymode.
     \end{description}


\section{Curve Routines}
     
     \begin{description}
     \item[void curvebasis]{\small (short id)} \\
     \index{curvebasis}
          Set the basis matrix for a curve to the  matrix  referenced  by
          id.  The matrix and it's id are tied together with a call to defbasis.

     \item[void curveprecision]{\small (short nsegs)} \\
     \index{curveprecision}
          Define the number of  line  segments  used  to  draw  a
          curve.

     \item[void rcrv]{\small (Coord geom\verb`[4][4]`)} \ \\
     \index{rcrv}
          Draw a rational curve.

     \item[void rcrvn]{\small (long n,Coord geom\verb`[][4]`)} \ \\
     \index{rcrvn}
          Draw $n - 3$ rational curve segments. Note: n must be  at
          least $4$.

     \item[void crv]{\small (geom\verb`[4][3]`)} \ \\
     \index{crv}
          Draw a curve.

     \item[void crvn]{\small (long n,Coord geom\verb`[][3]`)} \ \\
     \index{crvn}
          Draw $n - 3$ curve segments. Note: n must be at least $4$.

     \item[void curveit]{\small (short n)} \\
     \index{curveit}
          Draw a curve segment by iterating the top matrix in the
          matrix  stack as a forward difference matrix. This performs
          $n$ iterations.
     \end{description}


\section{Rectangles and General Polygon Routines}

     See also Vertex  calls  above.   The  way  in  which  filled
     polygons (including circles and arcs) are treated depends on
     the mode that has been set with the polymode call.

     There are variations on all these routines that end  in {\it s} and  also end
     in {\it i}.
     \begin{description}
     \item[\it s\/]: These variations they take arguments of type {\it Scoord}.
     \item[\it i\/]: These variations they take arguments of type {\it Icoord}.
     \end{description}

     \begin{description}
     \item[void rect]{\small (Coord x1,Coorc y1,COord x2,Coord y2)} \\
     \index{rect}
          Draw a rectangle.

     \item[void rectf]{\small (Coord x1,Coord y1,Coord x2,Coord y2)} \\
     \index{rectf}
          Draw a filled rectangle. (How the filling is  done  may
          be  changed by calling polymode , if this call has been
          compilied into the library).

     \item[void poly2]{\small (long n,Coord points\verb`[][2]`)} \\
     \index{poly2}
          Construct a (x, y) polygon from an array of points provided
          by the user.

     \item[void polf2]{\small (long n,Coord points\verb`[][2]`)} \\
     \index{polf2}
          Construct a filled (x, y)  polygon  from  an  array  of
          points  provided by the user.  (How the filling is done
          may be changed by calling polymode , if this  call  has
          been compilied into the library).

     \item[void poly]{\small (long n,float points \verb`[][3]`)} \\
     \index{poly}
          Construct a polygon from an array of points provided by
          the user.

     \item[void polf]{\small (long n,Coord points\verb`[][3]`)} \\
     \index{polf}
          Construct a filled polygon from an array of points provided
          by  the  user.   (How the filling is done may be
          changed by calling polymode , if  this  call  has  been
          compilied into the library).

     \item[void backface]{\small (Boolean onoff)} \\
     \index{backface}
          Turns on culling of backfacing polygons. A  polygon  is
          backfacing  if  it's  orientation in {\em screen} coords is
          clockwise.

     \item[void frontface]{\small (Boolean onoff)} \\
     \index{frontface}
          Turns on culling of frontfacing polygons. A polygon  is
          frontfacing  if  it's orientation in {\em screen} coords is
          anticlockwise.
     \end{description}


\section{Text routines}

     The original \VOGL\ hardware fonts {\it small} and  {\it large}
     have the font numbers 0 and 1 respectively.  The default font is
     0. For X11 displays the default fonts used  by  the  program
     can  be  overridden by placing the following defaults in the
     \verb`~/.Xdefaults `file:

     \begin{description}
     \item[vogl.smallfont] <font name>
     \item[vogl.largefont] <font name>
     \end{description}

     \begin{description}
     \item[void font]{\small (short fontid)} \\
     \index{font}
          Set the current font

     \item[void cmov]{\small (Coord x,Coord y,Coord z)} \\
     \index{cmov}
          Change the current character position. The usual variations
          with the extensions {\it i\/} and {\it s\/} also apply here.

     \item[void cmov2]{\small (Coord x,Coord y)} \\
     \index{cmov2}
          Change the current character position in x and  y.  The
          usual  variations  with the extensions {\it i\/} and {\it s\/} also
          apply here (ie.~{\it cmov2i} and {\it cmov2s}).

     \item[long getheight]{\small ()} \\
     \index{getheight}
          Return the maximum height in the current font.

     \item[long getwidth]{\small ()} \\
     \index{getwidth}
          Return the maximum width in the current font.

     \item[void charstr]{\small (char *str)} \\
     \index{charstr}
          Draw the text in string at the current position.
     \end{description}


\section{Transformation Routines}

     All transformations are cumulative, so if you  rotate  something and  then
     do a translate you are translating relative to the rotated axes. If you
     need  to  preserve  the  current transformation  matrix use pushmatrix(),
     do the drawing, and then call popmatrix() to get back where you were
     before.

     \begin{description}
     \item[void translate]{\small (Coord x,Coord y,Coord z)} \\
     \index{translate}
          Set up a translation.  Subsequent drawing will be translated by
          the specified amount.

     \item[void scale]{\small (Coord x,Coord y,Coord z)} \\
     \index{scale}
          Set up scaling factors in x, y, and z axis.  Subsequent drawing
          will be scaled by the specified amount.

     \item[void rot]{\small (float angle,char axis)} \\
     \index{rot}
          Set up a rotation in axis axis. Axis  is  one  of  {\it x},
          {\it y},  or {\it z}.  The angle in this case is a real number
          in {\it degrees}.

     \item[void rotate]{\small (Angle angle,char axis)} \\
     \index{rotate}
          Set up a rotation in axis axis. Axis  is  one  of  {\it x},
          {\it y},  or  {\it z},  and  the angle is in tenths of degrees.
     \end{description}


\section{Patch Routines}

     \begin{description}
     \item[void patchbasis]{\small (long tid,long uid)} \\
     \index{patchbasis}
          Define the t and u basis matrix id's of a patch. It  is
          assumed  that tbasisid and ubasisid have matrices associated
          with  them  already  (this  is  done  using  the
          defbasis call).

     \item[void patchprecision]{\small (long tseg,long useg)} \\
     \index{patchprecision}
          Set the minimum  number  of  line  segments  making  up
          curves in a patch.

     \item[void patchcurves]{\small (long nt,long nu)} \\
     \index{patchcurves}
          Set the number of curves making up a patch.

     \item[void rpatch]{\small (Matrix gx,Matrix gy,Matrix gz,Matrix gw)} \\
     \index{rpatch}
          Draws a rational patch in the current basis,  according
          to the geometry matrices gx, gy, gz, and gw.

     \item[void patch]{\small (Matrix gx,Matrix gy,Matrix gz)} \\
     \index{patch}
          Draws a patch in the current basis,  according  to  the
          geometry matrices gx, gy, and gz.
     \end{description}


\section{Point Routines}

     There are variations on all these routines that end  in {\it s} and  also end
     in {\it i}.
     \begin{description}
     \item[\it s\/]: These variations they take arguments of type {\it Scoord}.
     \item[\it i\/]: These variations they take arguments of type {\it Icoord}.
     \end{description}

     \begin{description}
     \item[void pnt]{\small (Coord x,Coord y,Coord z)} \\
     \index{pnt}
          Draw a point at x, y, z

     \item[void pnt2]{\small (Coord x,Coord y)} \\
     \index{pnt2}
          Draw a point at x, y.
     \end{description}


\section{Object Routines}

     Objects are graphical entities created by the  drawing  routines
     called  between  makeobj and closeobj. Objects may be
     called from within other objects. When an object is  created
     most  of  the  calculations required by the drawing routines
     called within it are  done  up  to  where  the  calculations
     involve the current transformation matrix. So if you need to
     draw the same thing several times on the screen but in  different
     places  it is faster to use objects than to call the
     appropriate drawing routines each time.

     \begin{description}
     \item[void makeobj]{\small (Object n)} \\
     \index{makeobj}
          Commence the object number n.

     \item[void closeobj]{\small ()} \\
     \index{closeobj}
          Close the current object.

     \item[Object genobj]{\small ()} \\
     \index{genobj}
          Returns a unique object identifier.

     \item[Object getopenobj]{\small ()} \\
     \index{getopenobj}
          Return the number of the current object.

     \item[void callobj]{\small (Object n)} \\
     \index{callobj}
          Draw object number n.

     \item[void isobj]{\small (Object n)} \\
     \index{isobj}
          Returns non-zero if there is an object of number n.
     \end{description}


\section{Double Buffering}

     Where possible \VOGL\ allows for front  and  back  buffers  to
     enable  things  like  animation  and  smooth updating of the
     screen. Note: it  isn't  possible  to  have  backbuffer  and
     frontbuffer true at the same time.

     \begin{description}
     \item[void gconfig]{\small ()} \\
     \index{gconfig}
          With Iris GL you must  call  gconfig  for  things  like
          doublebuffering to take effect.

     \item[void doublebuffer]{\small ()} \\
     \index{doublebuffer}
          Flags our intention to do double buffering.

     \item[void singlebuffer]{\small ()} \\
     \index{singlebuffer}
          Switch back to singlebuffer mode.

     \item[void backbuffer]{\small (Boolean yesno)} \\
     \index{backbuffer}
          Make \VOGL\ draw in the backbuffer.

     \item[void frontbuffer]{\small (Boolean yesno)} \\
     \index{frontbuffer}
          Make \VOGL\ draw in the front buffer.

     \item[void swapbuffers]{\small ()} \\
     \index{swapbuffers}
          Swap the front and back buffers.
     \end{description}


\section{Position Routines}

     \begin{description}
     \item[void getgpos]{\small (Coord *x,Coord *y,Coord *z,Coord *w)} \\
     \index{getgpos}
          Gets the current graphics position in world coords.
     \end{description}


\section{BUGS}

     \begin{enumerate}
     \item Double buffering isn't supported on all devices.
     \item The yobbarays may be turned on or they may be turned off.
     \end{enumerate}

\newpage
\twocolumn[\hfil\Large\bf Index\hfil] \small
\newcounter{indxctr}

\begin{list}{}{%
  \usecounter{indxctr}%
  \topsep=4ex plus 2pt minus 2pt%
  \setlength{\leftmargin}{.5in}%
  \setlength{\rightmargin}{\leftmargin}%
  \setlength{\parsep}{.5ex}%
  \setlength{\itemsep}{0pt}%
  \setlength{\labelwidth}{.75in}%
  \setlength{\labelsep}{.25in}}
  \item arcf \hfill 8
  \item arc \hfill 8
  \item backbuffer \hfill 12
  \item backface \hfill 9
  \item bgnclosedline \hfill 7
  \item bgnline \hfill 7
  \item bgnpoint \hfill 7
  \item bgnpolygon \hfill 7
  \item callobj \hfill 12
  \item charstr \hfill 10
  \item circf \hfill 8
  \item circleprecision \hfill 8
  \item circ \hfill 8
  \item clear \hfill 3
  \item closeobj \hfill 12
  \item cmov2 \hfill 10
  \item cmov \hfill 10
  \item colorf \hfill 3
  \item color \hfill 3
  \item crvn \hfill 8
  \item crv \hfill 8
  \item curvebasis \hfill 8
  \item curveit \hfill 9
  \item curveprecision \hfill 8
  \item defbasis \hfill 3
  \item doublebuffer \hfill 12
  \item draw2 \hfill 6
  \item draw \hfill 6
  \item endclosedline \hfill 7
  \item endline \hfill 7
  \item endpoint \hfill 7
  \item endpolygon \hfill 7
  \item font \hfill 10
  \item frontbuffer \hfill 12
  \item frontface \hfill 9
  \item gconfig \hfill 12
  \item genobj \hfill 12
  \item getbutton \hfill 4
  \item getgpos \hfill 12
  \item getheight \hfill 10
  \item getopenobj \hfill 12
  \item getplanes \hfill 2
  \item getvaluator \hfill 4
  \item getviewport \hfill 4
  \item getwidth \hfill 10
  \item gexit \hfill 2
  \item ginit \hfill 2
  \item isobj \hfill 12
  \item isqueued \hfill 4
  \item lookat \hfill 5
  \item makeobj \hfill 12
  \item mapcolor \hfill 3
  \item move2 \hfill 6
  \item move \hfill 6
  \item ortho2 \hfill 5
  \item ortho \hfill 5
  \item patchbasis \hfill 11
  \item patchcurves \hfill 11
  \item patchprecision \hfill 11
  \item patch \hfill 11
  \item perspective \hfill 5
  \item pnt2 \hfill 11
  \item pnt \hfill 11
  \item polarview \hfill 5
  \item polf2 \hfill 9
  \item polf \hfill 9
  \item poly2 \hfill 9
  \item polymode \hfill 3
  \item poly \hfill 9
  \item popattributes \hfill 4
  \item popmatrix \hfill 5
  \item popviewport \hfill 4
  \item prefposition \hfill 2
  \item prefsize \hfill 2
  \item pushattributes \hfill 4
  \item pushmatrix \hfill 5
  \item pushviewport \hfill 4
  \item qdevice \hfill 3
  \item qread \hfill 3
  \item qreset \hfill 4
  \item qtest \hfill 4
  \item rcrvn \hfill 8
  \item rcrv \hfill 8
  \item rdr2 \hfill 6
  \item rdr \hfill 6
  \item rectf \hfill 9
  \item rect \hfill 9
  \item reshapeviewport \hfill 2
  \item rmv2 \hfill 6
  \item rmv \hfill 6
  \item rotate \hfill 11
  \item rot \hfill 10
  \item rpatch \hfill 11
  \item scale \hfill 10
  \item singlebuffer \hfill 12
  \item swapbuffers \hfill 12
  \item translate \hfill 10
  \item unqdevice \hfill 3
  \item v4d \hfill 6
  \item v4f \hfill 6
  \item v4i \hfill 7
  \item v4s \hfill 7
  \item viewport \hfill 4
  \item vinit \hfill 1
  \item vnewdev \hfill 2
  \item voutput \hfill 2
  \item window \hfill 5
  \item winopen \hfill 2
\end{list}
\end{document}
