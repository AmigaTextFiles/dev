@DATABASE DICE_Manual
@NODE MAIN "The DICE 3.xx Clib Documentation"
@INDEX DICE_Index/MAIN
@TOC dice.guide/MAIN

@prev  dice.guide/clib
@next  dice.guide/clib

    @{b}CLIB/Amiga Documentaion@{ub}

    Contents: @{b}Char Routines@{ub}

    @{" " link isalnum} isalnum - is char alphanumeric
    @{" " link isalpha} isalpha - is char alphabetical
    @{" " link iscntrl} iscntrl - is char a control char
    @{" " link isdigit} isdigit - is char a digit
    @{" " link isgraph} isgraph - is char diplayable
    @{" " link isprint} isprint - is char printable
    @{" " link ispunct} ispunct - is char puctuation
    @{" " link isspace} isspace - is char a space
    @{" " link islower} islower - is char lowercase
    @{" " link isupper} isupper - is char uppercase
    @{" " link isxdigit} isxdigit - is char a hex digit

    @{" " link tolower} tolower - convert to lowercase
    @{" " link toupper} toupper - convert to uppercase


@ENDNODE

@NODE isalnum "isalnum command"
@prev main
@next isalpha

 @{b}isalnum@{ub}

 NAME
  isalnum - check that a character is in the alpha numeric domain

 SYNOPSIS
  int r = isalnum(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is an alpha numeric (a-z, A-Z, 0-9),
  zero if it is not.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isalnum('a'));
      assert(isalnum('Z'));
      assert(isalnum('1'));
      assert(!isalnum('%'));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE isalpha "isalpha command"
@prev isalnum
@next iscntrl

 @{b}isalpha@{ub}

 NAME
  isalpha - check that a character is in the alphabetic domain

 SYNOPSIS
  int r = isalpha(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is a letter in the alphabet
  (a-z, A-Z), zero if it is not.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isalpha('a'));
      assert(isalpha('Z'));
      assert(!isalpha('1'));
      assert(!isalpha('%'));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE iscntrl "iscntrl command"
@prev isalpha
@next isdigit

 @{b}iscntrl@{ub}

 NAME
  iscntrl - check for a control character

 SYNOPSIS
  int r = iscntrl(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is a control character (0-31),
  zero if it is not.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(iscntrl(10));
      assert(iscntrl(8));
      assert(!iscntrl('1'));
      assert(!iscntrl('%'));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE isdigit "isdigit command"
@prev iscntrl
@next isgraph

 @{b}isdigit@{ub}

 NAME
  isdigit - check for a numeric character

 SYNOPSIS
  int r = isdigit(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is a digit ('0' through '9'),
  zero if it is not.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isdigit('9'));
      assert(isdigit('0'));
      assert(!isdigit('x'));
      assert(!isdigit(7));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE isgraph "isgraph command"
@prev isdigit
@next islower

 @{b}isgraph@{ub}

 NAME
  isgraph - check for a printable character, excludes the space character

 SYNOPSIS
  int r = isgraph(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is printable and not a space,
  zero otherwise.

  This function is the isprint() function but with space character
  excluded from the printable set.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isgraph('^'));
      assert(isgraph('$'));
      assert(!isgraph(' '));
      assert(!isgraph(127));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE islower "islower command"
@prev isgraph
@next isprint

 @{b}islower@{ub}

 NAME
  islower - check for a lower case alphabetic character

 SYNOPSIS
  int r = islower(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is a lower case letter 'a' - 'z',
  zero otherwise.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(islower('a'));
      assert(islower('g'));
      assert(!islower('Z'));
      assert(!islower(127));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE isprint "isprint command"
@prev islower
@next ispunct

 @{b}isprint@{ub}

 NAME
  isprint - check for a printable character, includes the space character

 SYNOPSIS
  int r = isprint(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is printable, zero otherwise.

  This function is the isgraph() function but with space character
  included in the printable set.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input and always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isprint(' '));
      assert(isprint('^'));
      assert(!isprint(23));
      assert(!isprint(127));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE


@NODE ispunct "ispunct command"
@prev isprint
@next isspace

 @{b}ispunct@{ub}

 NAME
  ispunct - check for a printable character, except the space,
  letter or digit  character

 SYNOPSIS
  int r = ispunct(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is printable, zero otherwise.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  EOF is a valid input and always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(ispunct(' ')); // true
      assert(ispunct('?')); // false
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE


@NODE isspace "isspace command"
@prev ispunct
@next isupper

 @{b}isspace@{ub}

 NAME
  isspace - space, formfeed, newline, carriage return, tab or vertical
  tab character

 SYNOPSIS
  int r = isspace(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is printable, zero otherwise.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isspace('|'));  // true
      assert(isspace('Q'));  // false
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE


@NODE isupper "isupper command"
@prev isspace
@next isxdigit

 @{b}isupper@{ub}

 NAME
  isupper - check for an upper case alphabetic character

 SYNOPSIS
  int r = isupper(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character is an upper case letter 'A' - 'Z',
  zero otherwise.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input and always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isupper('A'));
      assert(isupper('G'));
      assert(!isupper('z'));
      assert(!isupper(127));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE isxdigit "isxdigit command"
@prev isupper
@next tolower

 @{b}isxdigit@{ub}

 NAME
  isxdigit - check for a character representable as a hexadecimal digit

 SYNOPSIS
  int r = isxdigit(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  Returns non-zero if the character represents a hexadecimal digit
  '0' - '9', 'a' - 'f', or 'A' - 'F', zero otherwise.

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <ctype.h>
  #include <assert.h>

  main()
  {
      assert(isxdigit('9'));
      assert(isxdigit('0'));
      assert(isxdigit('A'));
      assert(isxdigit('d'));
      assert(!isxdigit('x'));
      assert(!isxdigit(27));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      0 if the check failed, non-zero if the check is true


@ENDNODE

@NODE tolower "tolower command"
@prev isxdigit
@next toupper

 @{b}tolower@{ub}

 NAME
  tolower - converts a character into lower case

 SYNOPSIS
  int lc = tolower(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  If the character is in upper case the equivalent lower case
  character is returned, else the argument is returned (i.e. no
  change)

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <stdio.h>
  #include <ctype.h>


  main()
  {
      printf("%c%c%c%c", tolower('a'), tolower('B'), tolower('%'), tolower('Q'));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      converted character


@ENDNODE

@NODE toupper "toupper command"
@prev tolower
@next main

 @{b}toupper@{ub}

 NAME
  toupper - converts a character into upper case

 SYNOPSIS
  int lc = toupper(c);
  int c;

  This is a MACRO if you #include <ctype.h>, a subroutine call if
  you do not.

 FUNCTION
  If the character is in lower case the equivalent upper case
  character is returned, else the argument is returned (i.e. no
  change)

 NOTE
  When a non-zero value is returned, this value can be *anything*
  other than zero.  It is not necessarily a 1.  It is guarenteed to
  fit in a short, however, and still remain non-zero.

  characters in the 128-255 range are valid inputs.  characters
  less than -1 or larger than 255 are ILLEGAL and the results will
  be random.  If you are passing a CHAR, you must cast it to an
  UNSIGNED CHAR first.

  EOF is a valid input an always returns false

 EXAMPLE
  #include <stdio.h>
  #include <ctype.h>


  main()
  {
      printf("%c%c%c%c", toupper('a'), toupper('B'), toupper('%'), toupper('Q'));
  }

 INPUTS
  int c;      character that we are checking

 RESULTS
  int r;      converted character


@ENDNODE
