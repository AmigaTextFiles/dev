@DATABASE DICE_Manual
@NODE MAIN "The DICE 3.xx Clib Documentation"
@INDEX DICE_Index/MAIN
@TOC dice.guide/MAIN

@prev  dice.guide/main
@next  dice.guide/clib

    @{b}CLIB/Amiga Documentaion@{ub}

    Contents: @{b}DICE/ANSI/Amiga Functions@{ub}

    @{i}Amiga Memory Routines@{ui}
    @{" " link alloca} alloca.a
    @{" " link x.a} x.a - autoint terminating tags
    @{" " link rega4} rega4 - return register A4 contents

    @{i}Startup / Stutdown Functions@{ui}
    @{" " link c.a} c.a - DICE startup module
    @{" " link chkabort} chkabort - ^C control
    @{" " link exit} exit - standard program exit
    @{" " link _exit} _exit - exit without relasing resourses
    @{" " link _main} _main - bypass standard c.lib initialization
    @{" " link *main} main - standard entry point
    @{" " link wbmain} wbmain - workbench entry point
    @{" " link onbreak} onbreak - spesific ^C control
    @{" " link stack_abort} stack_abort - stack allocation failed

    @{i}Amiga Maths Routines @{b}(not useable in C !)@{ub}@{ui}
    @{" " link _mods} _mods - signed long modulus
    @{" " link _modu} _modu - un-signed long modulus
    @{" " link _muls} _muls - signed long multiply
    @{" " link _mulu} _mulu - un-signed long multiply
    @{" " link _divs} _divs - signed long devide
    @{" " link _divu} _divu - un-signed long devide

    @{i}Internal DICE Functions@{ui}
    @{" " link exec_dcc} exec_dcc - Internal DICE Function @{b}(DO NOT USE !)@{ub}
    @{" " link _ExecSeg} _ExecSeg - Internal DICE Function @{b}(DO NOT USE !)@{ub}
    @{" " link _SearchPath} _SearchPath - Internal DICE Function @{b}(DO NOT USE !)@{ub}
    @{" " link _SearchResident} _SearchResident - Internal DICE Function @{b}(DO NOT USE !)@{ub}
            
    @{i}ARexx Functions@{ui}
    @{" " link CreateDiceRexxPort      }  CreateDiceRexxPort - Create an application ARexx port
    @{" " link CreateGlobalDiceRexxPort}  CreateGobalDiceRexxPort - Create a global ARexx port
    @{" " link DeleteDiceRexxPort      }  DeleteDiceRexxPort - Delete a DICE ARexx port
    @{" " link DoRexxCommand           }  DoRexxCommand - Parse an incomming ARexx command
    @{" " link GetDiceRexxPortSlot     }  GetDiceRexxPortSlot - Determine an application ARexx slot
    @{" " link PlaceRexxCommand        }  PlaceRexxCommand - Send a command to ARexx
    @{" " link PlaceRexxCommandDirect  }  PlaceRexxCommandDirect - Send an ARexx command to an application
    @{" " link ProcessRexxCommands     }  ProcessRexxCommands - Handle incomming ARexx commands


@ENDNODE

@NODE alloca "alloca command"
@prev main
@next c.a

 @{b}alloca@{ub}

 NAME
  alloca - allocate memory from the stack

 SYNOPSIS
  void *ptr = alloca(long bytes);

 FUNCTION
  alloca() comes from the UNIX world.  It allocates memory off the
  stack for use within a procedure.  The allocated memory is
  automatically freed when the subroutine returns.

  DO NOT USE ALLOCA() IF YOU CAN HELP IT.  alloca() is not easily
  portable across machines.

 NOTE
  When a low stack condition arises, alloca() will abort by printing
  an error message and calling abort();  alloca() does NOT currently
  try to allocate dynamic memory when it runs out of stack.

  Some implementations of alloca() use alloca(0) to free allocated
  stack.  This feature is NOT currently implemented in DICE's
  alloca() call.

 EXAMPLE
  #include <alloca.h>
  #include <stdio.h>

  main(ac, av)
  char *av[];
  {
      char *ptr;
      if (ac == 1) {
      puts("test string");
      exit(1);
      }
      ptr = alloca(strlen(av[1]) + 8);
      sprintf(ptr, "FOO.%s", av[1]);
      puts(ptr);
      return(0);
  }

 SEE ALSO
  @{"setjmp" link clib_setjmp/MAIN}, @{"longjmp" link clib_longjmp/MAIN}
  

@ENDNODE

@NODE c.a "c.a command"
@prev alloca
@next chkabort

 @{b}c.a@{ub}

 NAME
  c.a  - DICE startup module for all C programs

 SYNOPSIS
  c.a is entered when the program segment is run

 FUNCTION
  DCC specifies DLIB:C.O first when linking objects into an
  executable.  C.O also exists in C.LIB but is not normally pulled
  since it is already included in the link line.

  C.O does the following:

      (1) save non-scratch registers

      (2) If Resident:
          Allocate space for both data & bss and copy the
          initialized data into the allocated space.  Clear
          the BSS portion of the data space
      Else
          The BSS has already been allocated by the load module
          but not cleared, Clear the BSS portion of the data space

      (3) Clear the ^C signal

      (4) Setup _SysBase

      (5) Call all AUTOINIT subroutines (this usually results in at
      least the dos.library being openned).

      (6) call _main()    (usually in c.lib as well)

      (7) fall through to _exit(0)

  Note that while c.a falls through to _exit(0) after calling _main(),
  _main itself calls main() with: exit(main(args...));  Thus, main()
  is always expected to return a valid value (i.e. not void).

  C.O also handles the low level exit _exit() (__exit:) in the
  following sequence:

      (1) Call autoinit exit subroutines (this normally closes the
      DOS library and other automatically openned libraries such
      as floating point libraries).

      (2) Free all memory allocated by the task, including the small
      data segment & BSS space.  Note that all variables that we
      use after this have already been placed in registers since
      the dataspace is no longer valid.

      (3) If the _WBMsg is not NULL then:
      (a) Forbid()
      (b) ReplyMsg(_WBMsg)

      (4) restore original registers and rts (exit out of the process)


 NOTE
  Normally the programmer does not overide the startup object file
  (c.o) since this is the entry point into the program.  However, in
  many cases a programmer will want to overide _main().  I.E.:

  _main(len, arg)
  int len;
  char *arg;
  {
      ...
  }

  In which case he is given the length and arg pointer passed to the
  program on startup.  When you overide _main() you cannot call any
  stdio (fopen, fclose, puts, etc...), low level IO (open, close,
  read, write, etc...), or memory allocation routines.

  Normally _main will be overriden if the program makes only system
  calls (such as Open, Close, Read, Write, FindTask, etc...).
  Overriding the c.lib generally makes executables much smaller as no
  extranious stdio/low level IO routines are brought in from c.lib .

  Normally you exit out of _main by calling _exit(code) (note the
  underscore).


@ENDNODE

@NODE chkabort " command"
@prev c.a
@next _divs

 @{b}chkabort@{ub}

 NAME
  chkabort - check for ^C and take the appropriate action

 SYNOPSIS
  (void) chkabort(void);

 FUNCTION
  Checks for a ^C and takes the appropriate action.  If the appropriate
  action is to exit than this routine does not return.  stdio and other
  routines will call chkabort() at various points.

  The action taken by ^C may be set by the signal() or onbreak() calls.

 EXAMPLE
  /*
   *  wait for somebody to hit ^C (note that this is very wasteful of
   *  CPU and thus isn't a real good example).
   */

  main()
  {
      int i;

      for (i = 0; i < 10000000; ++i)
      chkabort();
      return(0);
  }

 SEE ALSO
  @{"atexit" link clib_stdlib/atexit}, @{"signal" link clib_signal/MAIN}


@ENDNODE

@NODE _divs "_divs command"
@prev chkabort
@next _divu

 _divs

 NAME
  _divs - signed long divide 32/32->32 assembly tag not callable from C

 ENTRY
  D0 = 32 bit signed integer
  D1 = 32 bit signed integer

 RETURN
  D0 = D0 / D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to
  do a long division.  This function is not callable from C.

 SEE ALSO
  _divu, _mods, _modu, _muls, _mulu


@ENDNODE

@NODE _divu "_divu command"
@prev _divs
@next exec_dcc

 @{b}_divu@{ub}

 NAME
  _divu - unsigned long divide 32/32->32 assembly tag
      not callable from C

 ENTRY
  D0 = 32 bit unsigned integer
  D1 = 32 bit unsigned integer

 RETURN
  D0 = D0 / D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to do
  an unsigned long division.  This function is not callable from C.

 SEE ALSO
  @{"_divs" link _divs}, @{"_mods" link _mods}, @{"_modu" link _modu}, @{"_muls" link _muls}, @{"_mulu" link _mulu}



@ENDNODE

@NODE Exec_dcc "exec_dcc command"
@prev _divu
@next _ExecSeg

 @{b}exec_dcc@{ub}

 NAME
  exec_dcc - call DICE executable

 FUNCTION
  @{b}DO NOT EVER USE THIS FUNCTION.@{ub}  This is an internal DICE function
  used by DCC and is subject to change without notice.  This function
  can easily break under new versions of the OS and special care is
  taken by DCC when using it.

  The 2.0 version of the Amiga operating system has calls that will
  properly accomplish this operation.

 SEE ALSO
  @{"_ExecSeg" link _ExecSeg}


@ENDNODE

@NODE _ExecSeg "_ExecSeg command"
@prev exec_dcc
@next exit

 @{b}_ExecSeg@{ub}

 NAME
  _ExecSeg - call a segment

 FUNCTION
  @{b}DO NOT EVER USE THIS FUNCTION.@{ub}  This is an internal DICE function
  used by DCC and is subject to change without notice.  This function
  can easily break under new versions of the OS and special care is
  taken by DCC when using it.

  The 2.0 version of the Amiga operating system has calls that will
  properly accomplish this operation.

 SEE ALSO
  @{"exec_dcc" link exec_dcc}


@ENDNODE

@NODE exit "exit command"
@prev _ExecSeg
@next _exit

 @{b}exit@{ub}

 NAME
  exit - exit from a program 'nicely'

 SYNOPSIS
  (void) exit(code)

 FUNCTION
  exits the program and returns the specified exit code.  Normally you
  pass 0 to indicate no errors, a positive number to indicate a program
  error to the parent.

  exit() closes all stdio file pointers, low level file descriptors,
  perhaps other things, then finally calls _exit with the code.

  If you use main() you should call exit() to exit the program or
  return an error code from main.  If you use the _main() entry
  point (only for programmers dead set on optimizing executable
  size and using only system library calls) you should use the _exit()
  exit point.

 EXAMPLE
  main(ac, av)
  char *av[];
  {
      if (ac <= 1) {
      puts("I expected an argument you idiot!");
      exit(1);
      }
      puts("thanks for the argument!");
      exit(0);
  }

 SEE ALSO
  @{"main" link *main}, @{"_main" link _main}, @{"_exit" link _exit}


@ENDNODE

@NODE _exit "_exit command"
@prev exit
@next *main

 @{b}_exit@{ub}

 NAME
  _exit - exit from a program without bother to release resources

 SYNOPSIS
  (void) _exit(code)
  int code;

 FUNCTION
  exits the program and returns the specified exit code.  Normally you
  pass 0 to indicate no errors, a positive number to indicate a program
  error to the parent.  Note that since auto-init openned libraries
  are closed in the startup module (c.o), automatically openned
  libraries WILL be automatically closed for you.  However, any
  libraries you manually declare the library base variable for and
  manually open must be closed by you.

  You should only call _exit() if you used the _main() entry point
  (instead of the usual main()), and then only after releasing all
  resources (such as file handles openned with Open()).

 EXAMPLE
  /*
   *  This program comes to approximately a 552 byte executable
   */

  _main()
  {
      Write(Output(), "OW!\n", 4);
      _exit(1);
  }

 SEE ALSO
  @{"main" link *main}, @{"_main" link _main}, @{"exit" link exit}


@ENDNODE

@NODE *main "main command"
@prev _exit
@next onbreak

 @{b}main@{ub}

 NAME
  main - main program entry

 SYNOPSIS
  int
  main(int argc, char **argv)
  {
      /* your main routine goes here */
  }

 FUNCTION
  The main() routine is the entry point called after normal
  initialization of c.lib and the program enviroment is done
  by the startup module (c.o) and _main() routine (in c.lib).

  under ANSI C main() is expected to return an integer exit code.
  You can no longer simply fall through without returning any
  value.  returning an exit code from your main routine is exactly
  the same as exit()ing with it.

 NOTE
  Any program run from the WORKBENCH uses a different access point.
  Specifically, a program run from the workbench will run wbmain()
  instead of main().  Please refer to the manual page for wbmain()
  for workbench operation.

  If you do not supply a wbmain() a dummy wbmain() will be supplied
  by the library which simply exits out of the program.

 EXAMPLE
  #include <stdio.h>

  int
  main(ac, av)
  int ac;
  char **av;
  {
      int i;
      for (i = 0; i < ac; ++i) {
      printf("Arg #%d = %s\n", i, av[i]);
      }
      return(0);
  }

  1> sampleprogram this is a test
  Arg #0 = sampleprogram
  Arg #1 = this
  Arg #2 = is
  Arg #3 = a
  Arg #4 = test
  1>

 SEE ALSO
  @{"wbmain" link wbmain}, @{"_main" link _main}, @{"exit" link exit}, @{"_exit" link _exit}


@ENDNODE

@NODE onbreak "onbreak command"
@prev *main
@next _main

 @{b}onbreak@{ub}

 NAME
  onbreak - set special ^C handler    (not ANSI)

 SYNOPSIS
  typedef int (*fptr)();

  fptr oldfunc = onbreak(newfunc);
  fptr newfunc;

 FUNCTION
  onbreak() sets a special function to handle ^C.  It takes a pointer to
  this function and returns a pointer to the previous onbreak function,
  if any.  When ^C is hit, the special onbreak function is called before
  any other action.

  If the onbreak function returns a non-zero value, ^C aborts the program
  like it usually does.  If the function returns 0, however, the ^C
  is completely ignored.

 EXAMPLE
  /*
   *  note: The reentrancy check is needed because of both the puts
   *    and the sleep() all.
   */

  #include <stdio.h>
  #include <stdlib.h>

  int
  brk()
  {
      static short cnt = 0;   /*  check for reentrancy */

      if (cnt)                /*  if not 0 then reentered!    */
      return(0);
      ++cnt;

      puts("Nah Nah, you can't break me!");
      sleep(1);
      --cnt;
      return(0);
  }

  int
  main()
  {
      short i;

      onbreak(brk);
      puts("Hit ^C while I loop from 1 to 100, as many times as you want");
      sleep(2);
      for (i = 1; i <= 100; ++i)
      printf("Loop, counting, count = %d\n", i);
      return(0);
  }

 SEE ALSO
  @{"atexit" link clib_stdlib/atexit}


@ENDNODE

@NODE _main "_main command"
@prev onbreak
@next _mods

 @{b}_main@{ub}

 NAME
  _main - main program entry, bypass standard c.lib initialization

 SYNOPSIS
  void _main(int arglen, char *argptr)
  {
      /* your main routine goes here */
  }

 FUNCTION
  The _main() entry point is called by the startup module (c.o).
  Normally _main() is part of c.lib and does stdio and other
  initialization before calling the user main() routine.  _main()
  is responsible for openning the stderr channel as well.

  However, if you specify your own _main() you will overide the
  c.lib version.  Normally you either fall through or _exit() from
  _main.

  A programmable can use the _main entry point when the executable
  uses nothing but system library routines.  That is, you make no
  calls to stdio functions such as puts(), printf(), etc..., to low
  level IO routines such as open(), close(), read(), etc..., or
  malloc() or any routine that uses malloc().

  Self contained routines such as strcpy() may still be called, and, of
  course, you may open any libraries you wish and make library calls.

  Since the auto-library openning and closing is done by the startup
  module (c.o), "dos.library" will still be openned for you
  automatically if you make any DOS calls.

  Using the _main entry point usually results in a substantially
  smaller executable because stdio and other library routines
  referenced by the c.lib _main() and exit() are never referenced
  and thus never become part of the executable.  It is NOT SUGGESTED
  that beginning C programmers use the _main() entry point.

 NOTE
  _main is called by the startup module whether the program was run
  from the CLI or the WORKBENCH.  You must detect which yourself and
  also deal with the workbench message yourself.

 EXAMPLE
  /*
   *  This program comes to approximately a 552 byte executable
   */

  _main()
  {
      Write(Output(), "UG!\n", 4);
      _exit(1);
  }

 SEE ALSO
  @{"_exit" link _exit}, @{"main" link *main}, @{"exit" link exit}


@ENDNODE

@NODE _mods "_mods command"
@prev _main
@next _modu

 @{b}_mods@{ub}

 NAME
  _mods - signed long modulus 32%32->32 assembly tag
      not callable from C

 ENTRY
  D0 = 32 bit signed integer
  D1 = 32 bit signed integer

 RETURN
  D0 = D0 % D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to
  do a long modulus.  This function is not callable from C.

 SEE ALSO
  @{"_divs" link _divs},  @{"_modu" link _modu}, @{"_muls" link _muls}, @{"_mulu" link _mulu}

@ENDNODE

@NODE _modu "_modu command"
@prev _mods
@next _muls

 @{b}_modu@{ub}

 NAME
  _modu - unsigned long modulus 32%32->32 assembly tag
      not callable from C

 ENTRY
  D0 = 32 bit unsigned integer
  D1 = 32 bit unsigned integer

 RETURN
  D0 = D0 % D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to do
  an unsigned long modulus.  This function is not callable from C.

 SEE ALSO
  @{"_divs" link _divs}, @{"_mods" link _mods}, @{"_muls" link _muls}, @{"_mulu" link _mulu}


@ENDNODE

@NODE _muls "_muls command"
@prev _modu
@next _mulu

 @{b}_muls@{ub}

 NAME
  _muls - signed long multiply 32*32->32 assembly tag
      not callable from C

 ENTRY
  D0 = 32 bit signed integer
  D1 = 32 bit signed integer

 RETURN
  D0 = D0 * D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to
  do a long multiply.  This function is not callable from C.

 SEE ALSO
  @{"_divs" link _divs}, @{"_mods" link _mods}, @{"_modu" link _modu}, @{"_mulu" link _mulu}


@ENDNODE

@NODE _mulu "_mulu command"
@prev _muls
@next _SearchPath

 @{b}_mulu@{ub}

 NAME
  _mulu - unsigned long multiply 32/32->32 assembly tag
      not callable from C

 ENTRY
  D0 = 32 bit unsigned integer
  D1 = 32 bit unsigned integer

 RETURN
  D0 = D0 * D1

 FUNCTION
  This is an assembly function that DICE uses whenever it needs to do
  an unsigned long multiply.  This function is not callable from C.

 SEE ALSO
@{"_divs" link _divs}, @{"_mods" link _mods}, @{"_modu" link _modu}, @{"_muls" link _muls}


@ENDNODE

@NODE _SearchPath "_SearchPath command"
@prev _mulu
@next _SearchResident

 @{b}_SearchPath@{ub}

 NAME
  _SearchPath - search the current Path for an executable file

 FUNCTION
  DO NOT EVER USE THIS FUNCTION.  This is an internal DICE function
  used by DCC and is subject to change without notice.  This function
  can easily break under new versions of the OS and special care is
  taken by DCC when using it.

  The 2.0 version of the Amiga operating system has calls that will
  properly accomplish this operation.

 SEE ALSO
  @{"_SearchResident" link _SearchResident}


@ENDNODE

@NODE _SearchResident "_SearchResident command"
@prev _SearchPath
@next stack_abort

 @{b}_SearchResident@{ub}

 NAME
  _SearchResident - search the Resident list for an executable

 FUNCTION
  DO NOT EVER EVER EVER USE THIS FUNCTION.  This is an internal DICE
  function used by DCC and is subject to change without notice.  This
  function can easily break under new versions of the OS and special
  care is taken by DCC when using it.

  The 2.0 version of the Amiga operating system has calls that will
  properly accomplish this operation.

 SEE ALSO
  @{"_SearchPath" link _SearchPath}


@ENDNODE

@NODE stack_abort "stack_abort command"
@prev _SearchResident
@next x.a

 @{b}stack_abort@{ub}

 NAME
  stack_abort - exit point when dynamic stack allocation fails

 SYNOPSIS

  void
  stack_abort(void)
  {
      /* .. your exit code .. */
      abort();
  }

 FUNCTION
  When dynamic stack allocation is enabled via the -gs option and
  such an allocation fails, stack_abort() is called.  If you do
  not specify a stack_abort() routine, the c.lib stack_abort()
  will be used and simply call abort().

  If you do specify a stack_abort() routine, you have two choices.
  (1) You can exit out of the program, or (2) you can simply return
  from the subroutine which RETRIES the allocation, and calls
  stack_abort() again if it fails.

  The program has about 2KB of stack left at the time this function
  is called.

  Since a low memory condition exists when this function is called
  you should NOT do anything that might require additional
  allocations!

 EXAMPLE
  none - anybody got a good example?


@ENDNODE

@NODE x.a "x.a command"
@prev stack_abort
@next wbmain

 @{b}x.a@{ub}

 NAME
  x.a - autoinit terminating tags

 SYNOPSIS

 FUNCTION
  The x.o module is the last object module in the link line DCC
  specifies to DLINK when linking an executable.  This module
  terminates the autoinit and autoexit sections with an RTS allowing
  the base of the section(s) to be called by the startup and exit
  code.

  autoinit/exit sections work as follows: Any object module may
  define a specially named section which will be linked, in sequence,
  with other module's sections of the same name.  These sections
  contain only code and NO RTS.  The terminating module X.O adds a
  single RTS to each section allowing the base of the section to be
  called by the startup/exit module (C.O), propogating through all
  autoinit/exit routines before hitting the RTS placed in the section
  by X.O

  DICE uses autoinit/exit sections to handle the following things:

  (1)     Code to initialize initialized data containing references to
      other initialized data (i.e.  int a, *b = &a;)  when the code
      must be made residentable.  This precludes the need for the
      startup code to handle Data-Data Reloc32's for resident code.

  (2)     Code to open libraries whos base variables are referenced but
      never declared.  _DOSBase and the various floating point
      libraries are automatically openned in this way whenever
      library calls to them are made.

      This precludes the need for DICE to have complex, room-
      consuming, and many times unncessary code in c.lib to
      handle these situations.

  (3)     Code to close libraries that were openned by (2) on exit.

  (4)     Entry points for the special __autoinit keyword 

 SEE ALSO
  @{"c.a" link c.a}

@ENDNODE

@NODE wbmain "wbmain command"
@prev x.a
@next rega4

 @{b}wbmain@{ub}

 NAME
  wbmain - main program entry when run from workbench

 SYNOPSIS

  int
  wbmain(struct WBStartup *wbs)
  {
      /*  your main code goes here */
      return(exitcode);
  }

 FUNCTION
  The wbmain() routine is the entry point called after normal
  initialization of c.lib and the program enviroment is done
  by the startup module (c.o) and _main() routine (in c.lib).

  wbmain() is called when the program is run from the workbench,
  main() is called when the program is run from the CLI.  Currently
  the exit code is ignored.

  The standard workbench startup message is passed to wbmain(), you
  can process or ignore this message as you like but should NOT
  ReplyMsg() it.  I repeat, do NOT ReplyMsg() it.  When you return
  from wbmain() or exit() out of the program the exit code will
  automatically deal with the message.

 EXAMPLE
  /*
   *  If run from the workbench this program will create a file
   *  T:XX instead of printing something on the console (since there
   *  is no console in that case).
   */

  #include <stdio.h>

  int
  main(ac, av)
  int ac;
  char **av;
  {
      puts("This was run from a CLI");
      return(0);
  }

  int
  wbmain(msg)
  void *msg;  /*  to make the example less complex */
  {
      FILE *fi = fopen("T:xx", "w");
      fprintf(fi, "This was run from the WORKBENCH\n");
      fclose(fi);
  }

 SEE ALSO
  @{"maic.an" link *main}

@ENDNODE

@NODE rega4 "rega4 command"
@prev wbmain
@next main

 @{b}rega4@{ub}

 NAME
  rega4 - return current contents of register A4

 SYNOPSIS

  char *basePtr = rega4();

 FUNCTION
  rega4() is NOT geta4() .. rega4() simply returns the current
  contents of the A4 register when you need it.  Note that DICE
  offsets the A4 register 32766 from the actuall small-data base
  so as to be able to use the entire -32768 to 32767 range to
  access 64KBytes of small-data

  see also the __geta4 keyword in EXTENSIONS.DOC .. note that a
  rega4() call inside a subroutine qualified with __geta4 is
  guarenteed to return the data base pointer.  Also, a rega4() call
  from any subroutine not called from an interrupt or a callback will
  return the proper data base pointer.


 EXAMPLE


@ENDNODE


@NODE CreateDiceRexxPort "CreateDiceRexxPort command"
@prev main
@next CreateGlobalDiceRexxPort

 @{b}CreateDiceRexxPort@{ub}

 FUNCTION
 Create an application ARexx port (DICE)

 SYNTAX
 #include <lib/rexx.h>
 short r = CreateDiceRexxPort(port, name)
 struct MsgPort *port;
 char *name;

 DESCRIPTION
 This call integrates any number of ARexx ports beyond the master port
 into DICE's ARexx system.  This call may be made from any point in
 your program.  After this call returns the message port will accept
 incomming ARexx messages.

 || NOTE: For simple programs you can simply use the master port
 || (RexxPort) that DICE sets up for you automatically and need not
 || bother with creating additional ports.  This call is more of use
 || in more complex programs which handle multiple projects
 || simultaniously.

 If you had declared RexxHostName as NULL causing DICE to not
 initialize an internal default RexxPort, you can pass NULL for port
 to initialize DICE's internal default RexxPort, thereby allowing
 PlaceRexxCommand() calls that specify a NULL port (i.e. to use DICE's
 internal default RexxPort).  You are not required to use DICE's
 internal message port, it is simply convenient.

 INPUTS
 struct MsgPort *port;
             A blank msgPort structure (that is, totally
             zero'd out). DICE will fill the structure with
             appropriate values. DICE uses the same signal bit
             as it allocated for the master port (RexxPort).
             DICE makes this message port public through the
             AddPort() call.

 char *name      A pointer to the name of the message port. DICE
             adds a .NN extension to this name, finding a free
             slot number when creating a public message port.
             If you pass NULL for this field, DICE will create
             a private message port suitable for handling
             ARexx call-backs.  An error (-1) is returned if
             no slots are available (all 99 are in use).  If
             you had passed NULL for the port structure then
             DICED will initialize RexxHostName to the
             extended name.

 RESULTS
 int r;          the slot number for the port or -1 if an error occured.



@ENDNODE

@NODE CreateGlobalDiceRexxPort "CreateGlobalDiceRexxPort command"
@prev CreateDiceRexxPort
@next DeleteDiceRexxPort

 @{b}CreateGlobalDiceRexxPort@{ub}

 FUNCTION
 Create a global ARexx port (DICE)

 SYNTAX
 #include <lib/rexx.h>
 rc = CreateGlobalDiceRexxPort(port, name)
 int rc;
 struct MsgPort *port;
 char *name;

 DESCRIPTION
 CreateGlobalDiceRexxPort integrates any number of ARexx ports beyond
 the master port into DICE's ARexx system. This call may be made from
 any point in your program. After this call returns the message port
 will accept incomming ARexx messages.

 || NOTE: For simple programs you can simply use the master port
 || (RexxPort) that DICE sets up for you automatically and need not
 || bother with creating additional ports.  This call is more of use
 || in more complex programs which handle multiple projects
 || simultaniously.

 If you had declared RexxHostName as NULL causing DICE to not
 initialize an internal default RexxPort, you can pass NULL for
 msgPort to initialize DICE's internal default RexxPort, thereby
 allowing PlaceRexxCommand calls that specify a NULL port (i.e. to use
 DICE's internal default RexxPort).  You are not required to use
 DICE's internal message port, it is simply convenient.

 INPUTS
 struct MsgPort *port;
             A blank msgPort structure (that is, totally
             zero'd out). DICE will fill the structure with
             appropriate values. DICE uses the same signal bit
             as it allocated for the master port (RexxPort).
             DICE will make this message port public through
             the AddPort() call.

 char *name;     A pointer to the name of the message port.  DICE
             uses this name verbatim.  An error (-1) is
             returned if the port already exists.  If you had
             passed NULL for the MsgPort structure DICE will
             initialize RexxHostName to name.

 RESULTS
 int r;          0 for success, -1 for error


@ENDNODE


@NODE DeleteDiceRexxPort "DeleteDiceRexxPort command"
@prev CreateDiceRexxPort
@next DoRexxCommand

 DeleteDiceRexxPort

 FUNCTION
 Delete a DICE ARexx port (DICE)

 SYNTAX
 #include <lib/rexx.h>
 void DeleteDiceRexxPort(port)
 struct MsgPort *port;

 DESCRIPTION
 This call deletes a previously created DICE ARexx port. You may NOT
 delete any ARexx port while within DoRexxCommand().  This call may
 only be made from the top level of your program or you run the risk
 of deleted an ARexx port out from under yourself.

 ## WARNING: You may NOT delete the master ARexx port, only those you
 ## specifically create.

 This call automatically clears out any as yet unread messages on the
 port, removes the port from the public message list with RemPort(),
 and zero's the structure.

 INPUTS
 struct MsgPort *port;
             The message port to delete.  You must have
             created it using CreateGlobalDiceRexxPort or
             CreateDiceRexxPort


@ENDNODE


@NODE DoRexxCommand "DoRexxCommand command"
@prev DeleteDiceRexxPort
@next GetDiceRexxPortSlot

 @{b}DoRexxCommand@{ub}

 FUNCTION
 Parse an incomming ARexx command (DICE)

 SYNTAX
 #include <lib/rexx.h>
 /* YOU DECLARE THIS IN YOUR CODE */
 long DoRexxCommand(msg, port, arg0, pres)
 void *msg;
 struct MsgPort *port;
 char *arg0;
 char **pres;
 {
    long rc = 0;
    *pres = "return string";
    return(rc);
 }

 DESCRIPTION
 DoRexxCommand is a routine that YOU supply to process incomming ARexx
 requests.  DICE will call your routine for any requests it processes
 with ProcessRexxCommands as well as for any requests that come in
 during processing of a PlaceRexxCommand. DICE presets pres to NULL.

 To return an error simply return a non-zero error code.

 To return a string, set pres to point to the string and return 0.
 DICE will make a copy of the string to return to ARexx.  Note that
 the application requesting the string will not see if if they have
 not requested 'OPTIONS RESULTS' as part of their processing.

 ## WARNING: Because your procedure must return before DICE can
 ## process the string, you MUST not assign pres to any local stack
 ## variables.  The resulting crash can be quite spectacular.

 INPUTS
 void *msg;      Incomming ARexx message if necessary.

 struct MsgPort *port; Port that the message came in on.

 char *arg0;     The ARexx command that is to be processed.  Your
             code must parse this in whatever way you want.

 char **pres;        Place to store result string.

 RESULTS
 int rc;         Return code to be passed to the application
             requesting the ARexx command.


@ENDNODE

@NODE GetDiceRexxPortSlot "GetDiceRexxPortSlot command"
@prev DoRexxCommand
@next PlaceRexxCommand

 @{b}GetDiceRexxPortSlot@{ub}

 FUNCTION
 Determine an Application ARexx slot (DICE)

 SYNTAX
 #include <lib/rexx.h>
 slot = GetDiceRexxPortSlot(port, &nameptr);
 int slot;
 MsgPort *port;
 char *nameptr;

 DESCRIPTION
 GetDiceRexxPortSlot returns the ln_Name field of the specified port
 (i.e. the fully qualified port name) and extracts and returns the
 slot number.  -1 is returned if the port name does not terminate with
 ".xx" where xx is a number.  If a char ** pointer is passed as
 nameptr it will be initialized to point to the ln_Name field of the
 port.

 This call is normally used with port = NULL to obtain information
 about DICE's internally setup Rexx port.

 INPUTS
 struct MsgPort *port;
             message port structure to extract ln_Name and
             slot field from. You can pass NULL to extract the
             full name and slot number selected by DICE when
             automatic startup is used (i.e. your declaration
             of RexxHostName is assigned a non-NULL pointer).

 char **nameptr;     The port name or NULL.  If not NULL the pointer
             will be assigned the ln_Name field of the port.
             Normally used when port is passed as NULL to
             obtain the fully qualified rexx port name DICE
             has constructed for you in an automatic startup.

 RESULTS
 int slot;       the slot number extracted from the port name or
             -1 if the port name is not in the proper format.


@ENDNODE


@NODE PlaceRexxCommand "PlaceRexxCommand command"
@prev GetDiceRexxPortSlot
@next PlaceRexxCommandDirect

 @{b}PlaceRexxCommand@{ub}

 FUNCTION
 Send a command to ARexx (DICE)

 SYNTAX
 #include <lib/rexx.h>
 rc = PlaceRexxCommand(port, str, &res, &ec)
 struct MsgPort *port;
 char *str;
 char *res;
 long ec;

 DESCRIPTION
 PlaceRexxCommand sends an ARexx command off to ARexx. (compare to
 PlaceRexxCommandDirect which talks to an application) The command is
 normally a script file to run.  You must specify the ARexx port that
 is to act as the default host port for the command or NULL to use
 DICE's default port. The default extension for the script is always
 the RexxHostName variable.  Note that if you specify NULL for the
 port to use DICE's default, then you must have previously setup
 DICE's default port.  This occurs automatically if RexxHostName was
 declared non-NULL, or manually if you had called
 Create[Global]DiceRexxPort(NULL, "name").

 You supply the command in str which is passed to ARexx as  Arg0.
 Currently there is no support for additional arguments.  DICE will
 run the command synchronously and return the result code.

 The result string pointer will be set to either NULL or a malloc()'d
 string.  If not NULL you are responsible for free()ing the result
 string when you are through with it!!  If you wish to ignore any
 result you may pass NULL for this argument.

 The ec longword will be set to an internal ARexx error code... if the
 returned result code is non-zero and ec == 1 then ARexx was unable to
 find the specified ARexx command.  You may pass NULL for this
 argument if you do not care about the error code.

 It is possible that your program will receive ARexx commands while it
 is waiting for the command you have sent to be returned.  DICE will
 automatically call DoRexxCommand() from within the PlaceRexxCommand()
 routine when this case occurs.

 ARexx will set the error-code ec, which is different from the
 result-code.  ec is set to 1 if the script could not be found. ARexx
 normally returns a severity code of 5 for this case.  If the return
 code is 0 then ec will be 0.

 INPUTS
 struct MsgPort *port;
             Message port for processing.  Typically you pass
             NULL to use the default port.

 char *str;      String to be passed to ARexx for execution

 char **res;     Pointer to place to store result string from
             ARexx.  NULL indicates no result is desired.

 long *ec;       Pointer to place to store error code from ARexx.
             Set to 1 for script not found.  NULL indicates no
             result code desired.

 RESULTS
 int rc;         Return code from ARexx


@ENDNODE

@NODE PlaceRexxCommandDirect "PlaceRexxCommandDirect command"
@prev PlaceRexxCommand
@next ProcessRexxCommands

 @{b}PlaceRexxCommandDirect@{ub}

 FUNCTION
 Send an ARexx command to an Application (DICE)

 SYNTAX
 #include <lib/rexx.h>
 rc = PlaceRexxCommandDirect(port, apport,str, &res, &ec);
 struct MsgPort *port;
 char *apport;
 char *str;
 char *res;
 long ec;

 DESCRIPTION
 PlaceRexxCommandDirect sends an ARexx command to a specification
 application (compare to PlaceRexxCommand which talks to ARexx
 directly). The command is normally a script file to run.  You must
 specify the ARexx port that is to act as the default host port for
 the command or NULL to use DICE's default port. The default extension
 for the script is always the RexxHostName variable.  Note that if you
 specify NULL for the port to use DICE's default, then you must have
 previously setup DICE's default port.  This occurs automatically if
 RexxHostName was declared non-NULL, or manually if you had called
 Create[Global]DiceRexxPort(NULL, "name").

 You supply the command in str which is made Arg0.  Currently there is
 no support for additional arguments.  DICE will run the command
 synchronously and return the result code.

 The result string pointer will be set to either NULL or a malloc()'d
 string.    If you wish to ignore any result you may pass NULL for
 this argument.

 || NOTE: If you do not pass NULL, you are responsible for free()ing
 || the result string when you are through with it!

 The ec longword will be set to an internal ARexx error code... if the
 returned result code is non-zero and ec == 1 then ARexx was unable to
 find the specified ARexx command.  You may pass NULL for this
 argument if you do not care about the error code.

 It is possible that your program will receive ARexx commands while it
 is waiting for the command you have sent to be returned.  DICE will
 automatically call DoRexxCommand() from within the PlaceRexxCommand()
 routine when this case occurs.

 ARexx will set the error-code ec, which is different from the
 result-code.  ec is set to 1 if the script could not be found. ARexx
 normally returns a severity code of 5 for this case.  If the return
 code is 0 then ec will be 0.

 INPUTS
 struct MsgPort *port;
             Message port for processing.  Typically you pass
             NULL to use the default port.

 char *apport;       Name of application to send commands to.

 char *str;      String to be passed to ARexx for execution

 char **res;     Pointer to place to store result string from
             ARexx.  NULL indicates no result is desired.

 long *ec;       Pointer to place to store error code from ARexx.
             Set to 1 for script not found.  NULL indicates no
             result code desired.

 RESULTS
 int rc;         Return code from ARexx

@ENDNODE


@NODE ProcessRexxCommands "ProcessRexxCommands command"
@prev PlaceRexxCommandDirect
@next main

 @{b}ProcessRexxCommands@{ub}

 FUNCTION
 Handle incomming ARexx commands (DICE)

 SYNTAX
 #include <lib/rexx.h>
 ProcessRexxCommands(port)
 struct MsgPort *port;

 DESCRIPTION
 In order to process incomming ARexx commands you must call
 ProcessRexxCommands when you receive the signal RexxSigBit (signal
 mask is (1 << RexxSigBit)).

 Passing NULL to this routine will cause DICE to scan ALL KNOWN ARexx
 ports belonging to this program... that is, the master port and all
 created ports.  DICE will call DoRexxCommand for each ARexx command
 received as well as weed out returned messages from any ARexx
 commands we have sent that are still in progress.

 If you wish, you can pass a specific message port to have DICE only
 process ARexx commands received on a specific port, but beware that
 your Wait on the signal bit has cleared the signal and you should be
 sure to process all message ports before calling Wait again, else
 risk leaving unprocessed ARexx messages queued in and then blocking
 in Wait.

 INPUTS
 struct MsgPort *port;

 Message port to process or NULL to process all ports.


@ENDNODE






