@DATABASE DICE_Manual
@NODE MAIN "The DICE 3.xx Tutorial Set"
@INDEX DICE_Index/MAIN
@TOC dice.guide/MAIN

@prev  _beginner_readme/MAIN
@next  dice_tutor/MAIN


                         @{B}C Codeing Tutorials@{UB}


 Nobody ever said that learing dice or even C was going to be easy, so i 
 have put together (with the help of those mentioned) a short section 
 covering some of the more advanced (to the beginner) features of C, all
 are short and hopefully easily understadable. MF

 
 @{b}DICE / AMIGA - COMPILER EXTENSIONS@{ub}

  Contents: @{" Matteo Cortese's C Code     " link matteos}
            @{" ?? " link }
            @{" ?? " link }
            @{" ?? " link }


@ENDNODE

@NODE matteos "C Tutorials"

@prev  MAIN
@next  ??

                           @{b}Matteo Cortese's C Code@{ub}

These should appear in the examples draw if not (i forgot), sorry but here
they are, you can either type them out, they are not that long but if you
lazy you could use the save button from muiltiview and then edit them to
cut out all of this meaningless jabba. MF

These are not strictly ANSI or even SAS/C as they use some of DICE unieque 
featues to auto open libraries and the such like, but hay thats why they are
here.....

/*  head.c   The classic UNIX command
**
**  Matteo Cortese
**  15 Nov 1996
*/

#include <stdlib.h>
#include <string.h>

#include <clib/dos_protos.h>
#include <clib/utility_protos.h>
#include <clib/exec_protos.h>

#define SIZE	    256
#define DEFLINES    10
#define NUMCOL	    80

/*
**  Prototypes:
*/
void doit(BPTR, BPTR, int, APTR);


/*
**  Globals:
*/
const STRPTR Version = "$VER: head 1.2 (" __COMMODORE_DATE__ ")";
const STRPTR Template = "FILES/M,LINES/N/K";
int errore = 0;



/*
**|¯¯¯¯¯¯¯¯¯¯¯|
**|  _main()  |
**|___________|
*/

__stkargs
void _main()
{
    BPTR out = Output();


    /* Read the parameters: */

    LONG argv[2] = { 0, 0 };
    struct RDArgs *rda = ReadArgs(Template, argv, NULL);
    if (rda)
    {
	int lines = DEFLINES;
	if (argv[1])
	    lines = *((int *) argv[1]);

	APTR buf = AllocMem(SIZE, 0);
	if (buf != NULL)
	{
	    if (argv[0] == 0)
	    {
		/*  Input is stdin */

		doit(Input(), out, lines, buf);
	    }
	    else
	    {
		/* Input is one or more files */

		STRPTR *p;
		for (p = (STRPTR *) argv[0] ; *p && !errore ; ++p)
		{
		    __aligned struct AnchorPath myap;
		    myap.ap_Flags = 0;
		    myap.ap_BreakBits = SIGBREAKF_CTRL_C;
		    myap.ap_FoundBreak = 0;
		    myap.ap_Strlen = 0;

		    errore = MatchFirst((STRPTR) *p, &myap);
		    while (errore == 0)
		    {
			BPTR cd = CurrentDir(myap.ap_Current->an_Lock);
			BPTR in = Open(&myap.ap_Info.fib_FileName, MODE_OLDFILE);
			if (in)
			{
			    FPrintf(out, "--- %s ---\n", &myap.ap_Info.fib_FileName);
			    doit(in, out, lines, buf);
			    FPrintf(out, "\n");
			    Close(in);
			}
			else errore = IoErr();
			CurrentDir(cd);

			if (errore) break;

			errore = MatchNext(&myap);
		    }
		    MatchEnd(&myap);
		    if (errore == ERROR_NO_MORE_ENTRIES) errore = 0;
		}
	    }
	    FreeMem(buf, SIZE);
	}
	else errore = IoErr();

	FreeArgs(rda);
    }
    else errore = IoErr();


    /*
     *	Exit...
     */
    switch (errore)
    {
	case 0:
	    _exit(RETURN_OK);

	case ERROR_BREAK:
	    PrintFault(ERROR_BREAK, NULL);
	    _exit(RETURN_WARN);

	default:
	    PrintFault(errore, NULL);
	    _exit(RETURN_FAIL);
    }
}

void doit(BPTR in, BPTR out, int lines, APTR buf)
{
    int n=0;
    while (n<lines && !errore && FGets(in, buf, SIZE))
    {
	n += strlen(buf) / NUMCOL + 1;

	if (FPuts(out, buf))
	    errore = IoErr();

	if (CheckSignal(SIGBREAKF_CTRL_C))
	    errore = ERROR_BREAK;
    }
}

<----------------------------- AND ALSO ---------------------------------->

/*  Led.c

    Usage:
	Led 1	turn on the LED
	Led 0	turn off the LED
	Led	toggle the LED state

    Compilation:
	dcc -mi -ms -c Led.c
	dlink -o Led Led.o

    Author:
	Matteo Cortese - Oct 1997.
*/

#include <clib/exec_protos.h>
#include <clib/dos_protos.h>


start()
{

    struct Library *SysBase;
    struct Library *DOSBase;

    SysBase = *(struct Library **) 4;
    DOSBase = OpenLibrary("dos.library", 0);

    LONG c = FGetC(Input());

    switch (c)
    {
	case '0':
	    *(char *)0xBFE001 |= 0x02;
	    break;

	case '1':
	    *(char *)0xBFE001 &= ~0x02;
	    break;

	default:
	    *(char *)0xBFE001 ^= 0x02;
    }

    CloseLibrary(DOSBase);
    return 0;
}



<----------------------------- AND ALSO ---------------------------------->

/*  page.c   The classic UNIX command

    Matteo Cortese
    9 Dec 1997
*/


#include <stdlib.h>
#include <string.h>

#include <clib/dos_protos.h>
#include <clib/utility_protos.h>
#include <clib/exec_protos.h>

#define size	    256

/*
 *  Globals:
 */
const STRPTR Version = "$VER: Page 1.3 (9.12.97)";
const STRPTR Template = "FILE";



/*
**|¯¯¯¯¯¯¯¯¯¯¯|
**|  _main()  |
**|___________|
*/

__stkargs
void _main()
{
    int errore = 0;
    BPTR in = Input();
    BPTR out = Output();

    if (IsInteractive(out))
    {
	/* Read the parameters: */

	LONG argv[1] = { 0 };
	struct RDArgs *rda = ReadArgs(Template, argv, NULL);
	if (rda)
	{
	    SetMode(out, 1);

	    int lines = 0;
	    int columns = 0;

	    {
		/* We are writing to a console, so we'll use */
		/* the Window-Status_Request sequence "<ESC>[0 q" */
		/* to interrogate the console. The answer will come */
		/* in a Window-Dound-Report sequence "<ESC>[1;1;<r>;<c> r" */
		/* stating the # of rows <r>  and the # of columns <c> */
		/* of the current window */

		unsigned char WSR[4] = { 0x9b, 0x30, 0x20, 0x71 };
		unsigned char c;

		Write(out, WSR, 4);

		do {
		    Read(out, &c, 1);
		} while (c != 0x9b);

		/* Discard the first 2 numbers: */

		do {
		    Read(out, &c, 1);
		} while (c != 0x3b);
		do {
		    Read(out, &c, 1);
		} while (c != 0x3b);

		/* Read the # of lines: */

		for (;;)
		{
		    Read(out, &c, 1);
		    if (c == 0x3b)
			break;
		    lines = lines*10 + (c - '0');
		}

		/* Read the # of columns: */

		for (;;)
		{
		    Read(out, &c, 1);
		    if (c == 0x20)
			break;
		    columns = columns*10 + (c - '0');
		}

		Read(out, &c, 1);   /* The last 'r' */
	    }

	    APTR buf = AllocMem(size, 0);
	    if (buf != NULL)
	    {
		if (argv[0])
		{
		    in = Open((STRPTR) argv[0], MODE_OLDFILE);

		    if (in == NULL)
			errore = IoErr();
		}

		int n = 0;

		FPuts(out, "\f");
		while (!errore && FGets(in, buf, size))
		{
		    n += strlen(buf)/columns + 1;
		    if (n>=lines)
		    {
			FPuts(out, "___more___");
			Flush(out);
			int c = FGetC(out);
			if (c == ' ')
			{
			    FPuts(out, "\f");
			    n = strlen(buf)/columns + 1;
			}
			else
			{
			    FPuts(out, "\b\b\b\b\b\b\b\b\b\b");
			    FPuts(out, "          ");

			    if (c=='q' || c==0x1b)
			    {
				FPuts(out, "\033[A\033E");
				break;
			    }
			    else
				FPuts(out, "\033E\033[A");

			}
		    }

		    if (FPuts(out, buf))
			errore = IoErr();

		    if (CheckSignal(SIGBREAKF_CTRL_C))
			errore = ERROR_BREAK;
		}


		/* Close everithing and quit: */

		if (argv[0] && in)
		    Close(in);

		FreeMem(buf, size);
	    }
	    else errore = IoErr();

	    SetMode(out, 0);
	    FreeArgs(rda);
	}
	else errore = IoErr();
    }
    else errore = ERROR_BAD_STREAM_NAME;


    /*
     *	Exit...
     */
    switch (errore)
    {
	case 0:
	    _exit(RETURN_OK);

	case ERROR_BREAK:
	    PrintFault(ERROR_BREAK, NULL);
	    _exit(RETURN_WARN);

	default:
	    PrintFault(errore, NULL);
	    _exit(RETURN_FAIL);
    }
}


<----------------------------- AND ALSO ---------------------------------->

/*
**  xowner -- identifies the owner of the active window
**
**  ©1998 Matteo Cortese
**
**  Usage:
**
**	xowner [FULL] <command>
**
**  where <command> can contain spaces and the "%s" sequence which will
**  be replaced by the name of the task who owns the active window.
**  If the FULL switch is not used, the taskname will be truncated at
**  the first non-alpha character. The sequence "%s" can occur only once
**  inside <command>. Remember to enclose "%s" in quotes if you use the
**  FULL switch, since the task name can contain spaces.
**
**  Examples:
**
**  add the following lines to the ENV:MCP/MCP.config file, then press:
**  - LAMIGA+O to know the owner of the active window
**  - LAMIGA+H to get help about the active prg (if you have some sort
**	of man-pages installed).
**  - LAMIGA+K to send a ^C to the active program (uses Kill from the
**	Executive package).
**
**  HOTKEY=14 D 0 "" "LCOMMAND o" xowner <>NIL: FULL RequestChoice Owner "%s" Ok
**  HOTKEY=14 D 0 "" "LCOMMAND h" xowner <>NIL: man %s
**  HOTKEY=14 D 0 "" "LCOMMAND k" xowner <>NIL: FULL kill name "%s"
**
**  Compilation:
**
**	dcc -3.0 -// -proto -ms -mRR -mi [-020] -pi xowner.c
**
**  change -pi to -pr if you want it to be "pure" i.e. ready to be made resident.
**
*/

#include <stdlib.h>
#include <ctype.h>
#include <stdarg.h>
#include <string.h>
#include <intuition/intuitionbase.h>
#include <clib/dos_protos.h>
#include <clib/exec_protos.h>


#define BUF_LEN     256
#define CMD_LEN     256


/* Prototypes: */
char *get_task_name(void);
void SPrintf(char *, char *, ...);


/* Global variables: */
extern struct IntuitionBase *IntuitionBase;
static char buffer[BUF_LEN];
static char cmd[CMD_LEN];
static const ULONG dummy_taglist[2] = {TAG_DONE, 0};

/* Version tag: */
static const char Version[] = "$VER: xowner 1.0 (" __COMMODORE_DATE__ ")";



__stkargs void _main(int al, char *as)
{
    /* We store the arguments-list as a complex struct */
    /* so we have to cast the single struct to (ULONG *) */
    /* instead of casting each argument during processing: */
    struct {
	ULONG	full;
	STRPTR	lformat;
    } opt = {
	0,	    /* Default: no FULL task names */
	"Echo %s"   /* Default: print task names to the console*/
    };

    struct RDArgs *rda = ReadArgs("FULL/S,LFORMAT/F", (ULONG *) &opt, NULL);
    if (rda)
    {
	char *taskname = get_task_name();

	if (taskname)
	{
	    if (!opt.full)
	    {
		/* If not FULL, then we must truncate the task name */
		/* at the first character which is not isalpha(): */

		char *p = taskname;

		while (*p && isalpha(*p))
		    ++p;

		*p = '\0';
	    }

	    /* Execute the LFORMAT command, after having substituted */
	    /* the %s (if present) with the task name: */

	    SPrintf(cmd, opt.lformat, taskname);
	    System(cmd, dummy_taglist);
	}

	FreeArgs(rda);
    }

    _exit(0);
}






char *get_task_name(void)
{
    /* We start off by getting the address of the "object" which */
    /* owns the active window. It can be a task or a process. */

    struct Node *node = IntuitionBase->ActiveWindow->UserPort->mp_SigTask;

    if (node->ln_Type == NT_PROCESS)
    {
	/* If the owner is a process, then it may have a CLI structure */
	/* attached. We use BADDR() to convert a BCPL pointer (BPTR) */
	/* to a standard C pointer. */

	struct CommandLineInterface *cli =
	    BADDR( ((struct Process *) node)->pr_CLI );

	if (cli)
	{
	    /* If the owner is a process and does have a CLI structure */
	    /* then it is a background CLI process. The real name of this */
	    /* task is "Background CLI" which is not what we really want. */
	    /* Instead, we will read the name of the command being executed */
	    /* by this background CLI, discarding the path-part. */

	    char *title = BADDR( cli->cli_CommandName );

	    /* For historical reasons, "title" is a BCPL string. We must */
	    /* copy it to a more usual C (null-terminated) string. */

	    short i = title[0];
	    if (i > BUF_LEN-1)
		i = BUF_LEN - 1;
	    strncpy(buffer, title+1, i);
	    buffer[i] = '\0';

	    /* Discard the path-part: */
	    return FilePart(buffer);
	}
    }

    /* The owner is a task or does not have a CLI structure, so its name */
    /* is... its name! We copy it in a gobal buffer so that it will be */
    /* possible to manipulate it (e.g. to eliminate non-alpha caracters). */

    strncpy(buffer, node->ln_Name, BUF_LEN-1);
    return FilePart(buffer);
}






/*
 * SPrintf - a sprintf clone using exec/RawDoFmt()
 *
 * Jörgen Grahn
 * Wetterlinsgatan 13E
 * S-521 34 Falköping
 * Sverige
 *
 */


/*
    move.b d0,(a3)+     ;16C04E
    rts 		;75
*/
static const UBYTE sprintfhook[] = "\x16\xc0\x4e\x75";

void SPrintf(char *buf, char *fmt, ...)
{
   va_list args;

   va_start(args, fmt);
   RawDoFmt(fmt, args, (void (*)) sprintfhook, buf);
   va_end(args);
}


@ENDNODE
