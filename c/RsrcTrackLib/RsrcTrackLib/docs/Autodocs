
$VER: Autodocs of ressourcetracking.library 37.0 (20.07.98)

(C) Copyright 1998 Patrick BURNAND
All Rights Reserved.

Original code for the example.library done by Andreas R. Kleinert.
See Clib37x.lha on Aminet !


===============================================================================


ressourcetracking.library/rt_AddManager


NAME
    rt_AddManager  -  Sets up a ressource tracking stack for the calling task.


SYNOPSIS
    ULONG rt_AddManager (ULONG recNum)
      D0                       D1


FUNCTION
    Adds a ressource tracking stack for the calling task.  This call must be
    done before trying to allocate any system ressource using the
    ressourcetracking.library.  

    It is safe to call this function several times for the same task.   If the
    stack already exists rt_AddManager() always returns successfully.

    WARNING: the stack allocated using this function is strictly local the
    calling task.  If your program is divided in several tasks, each one must
    rt_AddManager() to get ressources using ressourcetracking.library.


INPUTS
    recNum:
        Number of ressources tracking records to allocate.  (Number of elements
        of the ressource tracking stack.)  Each record needs 16 bytes; it's not
        dramatic if this number is to big.  The number you provide here must be
        large enough or the stack will overflow and the system will probably
        crash.


RESULT
    Non-zero if the stack has been successfully created, else zero.


NOTE
    If you don't know how to estimate the number of necessary records, you can
    get the number of really used records using rt_FindNumUsed().


BUGS
    None known.


SEE ALSO
    rt_RemManager(), rt_FindNumUsed().


TODO
    Add the possibility to create several ressource tracking stacks per task.


===============================================================================


ressourcetracking.library/rt_RemManager


NAME
    rt_RemManager  -  Frees ressources and deletes ressource tracking stack.


SYNOPSIS
    void rt_RemManager (void)


FUNCTION
    Closes or frees all the ressources remaining on the ressource tracking
    stack and deletes the ressource tracking stack.  The ressources are freed
    in the reverse order as the allocation.

    This function must be called before your program exits.  This is a good
    idea to do an 'atexit(rt_RemManager)', so that your program can exit from
    everywhere.

    rt_RemManager() and rt_AddManager() must be called by the same task.

    It is safe to call this function several times.  It is safe to call this
    function even if rt_AddManager() didn't succeed.


INPUTS


RESULT


BUGS
    None known.


SEE ALSO
    rt_AddManager(), rt_SetMarker(), rt_UnsetMarker().


===============================================================================


ressourcetracking.library/rt_SetMarker


NAME
    rt_SetMarker  -  Puts a marker onto the ressource tracking stack.


SYNOPSIS
    void rt_SetMarker (void)


FUNCTION
    Puts a marker onto the ressource tracking stack.  This marker is used to
    remember a particular position in the stack.  When you call
    rt_UnsetMarker(), all the ressources allocated since the last
    rt_SetMarker() will be freed.
    A marker is itself considered as a ressource and takes one ressource
    tracking record.

    Usage example:  (rt_AddManager() has already been called)
        /* ... do something ... */
        myPort = rt_CreateMsgPort();
        rt_SetMarker();     /* Puts a marker in this place. */
        rt_SetCustomF0 ((APTR)myFunc);
        rt_AllocMem (1024, MEMF_CLEAR);
        rt_UnsetMarker();   /* Frees the block of memory and calls myFunc(). */
                            /* But myPort is still valid since */
                            /* CreateMsgPort() was called before the last */
                            /* rt_SetMarker(). */

INPUTS


RESULT


NOTE
    The calls to rt_SetMarker() and rt_UnsetMarker() can be nested.


BUGS
    None known.


SEE ALSO
    rt_UnsetMarker()


===============================================================================


ressourcetracking.library/rt_UnsetMarker


NAME
    rt_UnsetMarker  -  Removes a marker out off the ressource tracking stack.


SYNOPSIS
    void rt_UnsetMarker (void)


FUNCTION
    Frees all the ressources allocated since the last call to rt_SetMarker() in
    the reverse order of the allocation and then removes the marker.

    Usage example:  (rt_AddManager() has already been called)
        /* ... do something ... */
        myPort = rt_CreateMsgPort();
        rt_SetMarker();     /* Puts a marker in this place. */
        rt_SetCustomF0 ((APTR)myFunc);
        rt_AllocMem (1024, MEMF_CLEAR);
        rt_UnsetMarker();   /* Frees the block of memory and calls myFunc(). */
                            /* But myPort is still valid since */
                            /* CreateMsgPort() was called before the last */
                            /* rt_SetMarker(). */

INPUTS


RESULT


NOTE
    If you call rt_UnsetMarker() more times than you called rt_SetMarker(), all
    the ressources will be freed but the ressource tracking stack will still 
    exist.  (You must call rt_RemManager() at the end of your program anyway)


BUGS
    None known.


SEE ALSO
    rt_SetMarker()


===============================================================================


ressourcetracking.library/rt_FindNumUsed


NAME
    rt_FindNumUsed  -  Finds the number of used ressource tracking records.


SYNOPSIS
    ULONG rt_FindNumUsed (void)
      D0


FUNCTION
    Finds the number of used ressource tracking records.  It is useful not to
    waste to much memory when you do an rt_AddManager().  This function only
    returns a meaningfull number when it's called just before rt_RemManager().

    It can be used for debugging purposes too.  If you do allocation in a loop
    and suspect a problem.

    Usage example:
        /* ... prepare to quit ... */
        #ifdef DEBUG
        printf ("Number of used records: %ld\n", rt_FindNumUsed());
        #endif
        rt_RemManager();



INPUTS


RESULT


BUGS
    None known.


SEE ALSO
    rt_AddManager()


===============================================================================


ressourcetracking.library/rt_SetCustomF0


NAME
    rt_SetCustomF0  -  Calls a function when ressources are freed.


SYNOPSIS
    void rt_SetCustomF0 (APTR func)
                             D1


FUNCTION
    Adds the adress of a function on the ressource tracking stack.  The
    function you pass the adress of will be called when ressources are freed,
    i.e. when you call rt_UnsetMarker() or rt_RemManager().

    This mechanism is typically used to have custom (more sophisticated)
    liberation function or to do ressource tracking on ressources not supported
    by the ressource tracking library  (on not supported shared libraries).

    The function you pass to rt_SetCustomF0() must be parameter-less.  You must
    use rt_SetCustomF1() or rt_SetCustomF2() to pass function which take 1 or 2
    parameters.

    Usage example:
        rt_SetMarker();
        rt_SetCustomF0 ((APTR)myFunc);  /* Pass the adress of your function */
        rt_AllocMem (1024, MEMF_CLEAR);
        rt_UnsetMarker();   /* Frees the block of memory and calls myFunc(). */

    rt_SetCustomF0 takes 1 ressource tracking record.


INPUTS
    func:
        Address of a parameter-less function.  Note that any return value of
        your function will be ignored.


RESULT


BUGS
    None known.


SEE ALSO
    rt_SetCustomF1(), rt_SetCustomF2()


===============================================================================


ressourcetracking.library/rt_SetCustomF1


NAME
    rt_SetCustomF1  -  Calls a function when ressources are freed.


SYNOPSIS
    void rt_SetCustomF1 (APTR func, ULONG arg1)
                             D1         D2


FUNCTION
    This function is the same as rt_SetCustomF0() except that the function you
    pass must have 1 parameter. When ressources are freed, your function will
    be called with the parameter arg1.

    See the docs of rt_SetCustomF0().

    Usage example:
        rt_SetMarker();
        rt_SetCustomF1 ((APTR)myFunc, myParam); /* Pass the adress of your */
                                                /* function and myParam. */
        rt_AllocMem (1024, MEMF_CLEAR);
        rt_UnsetMarker();   /* Frees the block of memory */
                            /* and do a myFunc(myParam). */


INPUTS
    func:
        Address of a function taking 1 parameter.  Note that any return value
        of your function will be ignored.
    arg1:
        The value to pass to your function as a parameter.


RESULT


NOTE
    How your function will get the parameter arg1 may depend of your compiler.
    Perhaps you won't even be able to use rt_SetCustomF1() or rt_SetCustomF2()
    if the way the parameters of the functions are passed are not compatible.
    Anyway you should make some tests before using rt_SetCustomF1() or
    rt_SetCustomF2().


BUGS
    None known.


SEE ALSO
    rt_SetCustomF0(), rt_SetCustomF2()


===============================================================================


ressourcetracking.library/rt_SetCustomF2


NAME
    rt_SetCustomF2  -  Calls a function when ressources are freed.


SYNOPSIS
    void rt_SetCustomF2 (APTR func, ULONG arg1, ULONG arg2)
                             D1         D2          D3


FUNCTION
    This function is the same as rt_SetCustomF0() except that the function you
    pass must have 2 parameters. When ressources are freed, your function will
    be called with the parameters arg1 and arg2.

    See the docs of rt_SetCustomF0().

    Usage example:
        rt_SetMarker();
        rt_SetCustomF2 ((APTR)myFunc, 
                        myParam1, myParam2); /* Pass the adress of your */
                                             /* function and myParam1 and */
                                             /* myParam2. */
        rt_AllocMem (1024, MEMF_CLEAR);
        rt_UnsetMarker();   /* Frees the block of memory and do */
                            /* a myFunc(myParam1, myParam2). */


INPUTS
    func:
        Address of a function taking 2 parameters.  Note that any return value
        of your function will be ignored.
    arg1:
        The value to pass to your function as the first of the two parameters.
    arg2:
        The value to pass to your function as the second of the two parameters.


RESULT


NOTE
    How your function will get the parameter arg1 may depend of your compiler.
    Perhaps you won't even be able to use this rt_SetCustomF1() or
    rt_SetCustomF2() if the way the parameters of the functions are passed
    are not compatible.
    It is even possible that the order of the two parameters is wrong.  
    (i.e. arg1, arg2 becomes arg2, arg1.)
    Anyway you should make some tests before using rt_SetCustomF1() or
    rt_SetCustomF2().


BUGS
    None known.


SEE ALSO
    rt_SetCustomF0(), rt_SetCustomF1()


===============================================================================


ressourcetracking.library/rt_AllocMem
ressourcetracking.library/rt_AllocSignal
ressourcetracking.library/rt_OpenLibrary
ressourcetracking.library/rt_AddSemaphore
ressourcetracking.library/rt_Forbid
ressourcetracking.library/rt_AllocTrap
ressourcetracking.library/rt_CreateMsgPort
ressourcetracking.library/rt_AddPort




NAME
    rt_AllocMem  -  Allocates memory given certain requirements.
    rt_AllocSignal  -  Allocates a signal.
    rt_OpenLibrary  -  Opens an Amiga shared library.
    rt_AddSemaphore  -  Adds a semaphore.
    rt_Forbid  -  Disable multitasking.
    rt_AllocTrap  -  Allocates a trap.
    rt_CreateMsgPort  -  Creates a new message port.
    rt_AddPort  -  Adds a port the public port list.



SYNOPSIS
    APTR rt_AllocMem (ULONG byteSize, ULONG requirements)
     D0                     D1                D2

    BYTE rt_AllocSignal (ULONG signalNum)
     D0                        D1

    struct Library * rt_OpenLibrary (UBYTE *libName, ULONG version)
          D0                               D1             D2

    void rt_AddSemaphore (struct SignalSemaphore *sigSem)
                                        D1
    void rt_Forbid (void)

    ULONG rt_AllocTrap (ULONG trapNum)
      D0                     D1

    struct MsgPort * rt_CreateMsgPort (void)
          D0

    void rt_AddPort (struct MsgPort *port)
                             D1


FUNCTION
    These functions performs exactly the same task as the corresponding ones in
    AmigaOS.  The only difference is that each one creates a ressource tracking
    record and that it is forbidden to call the «reverse» function.  (i.e. it's
    forbidden to call FreeMem after an rt_AllocMem.)  But you can go through
    the ressource tracking stack using rt_SetMarker() and rt_UnsetMarker().

    See the documentation of AmigaOS.


INPUTS
    See the documentation of AmigaOS.


RESULT
    See the documentation of AmigaOS.


NOTE
    Assembly programmers must note that register specification isen't the same
    as in the AmigaOS.


BUGS
    None known.


SEE ALSO
    Documentation of AmigaOS


