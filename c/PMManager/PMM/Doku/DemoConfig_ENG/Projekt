; This is a project. Here are a lot of setup's, the programs
; and the phadnames for source, objects und exe-files.
; The *-entry is a general setting, it will work as default
; The programs can use it or set own setup's
; $1, $2 ... $9 (This are variables for pmm.cfg)
; $$.c=  Phat to source, if not identical with PFAD=
;
; Important:
; This file is only use by the compiler. The pathes that will be
; scan for include by the depend-scanner comes from pmm.userincludes.
; pmm.userincludes: every line ONE scanpath. Don't set pathes to the
; compilerincludes. Only include/libraries if you really use that.
; Else alle include-.h-files are checked everytime you start compiling
; and that cost many time for nothing.
; After a compilerupdate where the .h-files really changed best work
; is to remake all files.
; Note, that the depend-pathes are used for all programs same. The
; sourcedirectory is everytime another and only the real include-dir's
; are scanned.
; The depend look everytime at the source-home-dir of the program.
; The compiler dosn't do that. Use the pseudoinclude -I$I to set
; up the homedir for the compiler. Pmm do this not alone, because
; I will be open in for all things in future.
;
; Lines with MAKE at the beginning:
; First the 1%, 2% ... etc. now become content
; MAKE=5    means: Start Pmm without a makeoption (like only make) internal
;                  use is equal 5 that set as 68040 in my default).
; MAKE:xyz=1,2,3   This means, if you start pmm with -o xyz the system
                   make the type 1, 2 and 3. 
; MAKE:ALL=....    Important! This set what be happend if Pmm is starting
;                  with A, Q, I or -o ALL.
; This all are additives to pmm.cfg. But there are more things:
;
; Source und sonstige Files:
; $&.c ist source.c     Preprozessor Input  ( .c -> vcpp )
; $&.i ist soirce.i     Preprozessor Output ( .c -> vcpp -> .i )
; $&.a ist source.asm   Compiler Output     ( .i -> vbcc -> .asm )
; $&.s ist source.s     Compiler Output     ( .i -> vbcc -> .s (vsc) -> .asm )
; $&.o ist source.o     Assembler Output    ( .asm -> Assembler -> .o [ -> Linker] )
; $$   ist PROGRAMM     Letzter Output (Programm, Library, Lib etc.)
; vsc ist der Scheduler, siehe Docs für Warp-Version!!!
; Dies alles geschieht automatisch. Für .i, .a, .s und .o werden nur noch die
; Pfade festgelegt. Bei $$ der Name des Programmes INCL. Pfad, wenn gewünscht.
; Falls nicht, wird a.out imaktuellen Verzeichnis benutzt. Siehe $$ unten...
; $L Ergänzung der .Lib/.a-Dateien für den Linker.
;
; Warum dieser Eintrag, ginge doch genauso gut in Pmm.Cfg?
; WEIL Pmm.Cfg nur Dinge enthalten sollte die allgemein gültig sind.
; Diese Projektdatei wird künftig mehrfach angelegt werden können, so
; das Projekte in Sub-Projekte unterteilt werden können, bzw. auch
; mehrere Projekte möglich werden. Dann sollte hier das stehen, was
; für das Projekt vom sonstigen Standard abweicht.
;
:BEGIN *
MAKE=5
MAKE:60=5,6
MAKE:PPC=7,8
MAKE:ALL=1,2,3,4,5,6,7,8
1%$&.o=obj/000/
2%$&.o=obj/010/
3%$&.o=obj/020/
4%$&.o=obj/030/
5%$&.o=obj/040/
6%$&.o=obj/060/
7%$&.o=obj/ppc/
8%$&.o=obj/wos/
$&.i=T:
$&.a=T:
$&.s=T:
$$=a.out
$L=Lib:DOSLIB_000.Lib Lib:All.Lib
5%$L=Lib:DOSLIB_040.Lib Lib:All_040.Lib
6%$L=Lib:DOSLIB_060.Lib Lib:All_040.Lib
7%$L=Lib:DOSLIB_ppc.a Lib:All_ppc.a
8%$L=Lib:DOSLIB_wos.a Lib:All_wos.Lib
$o=T:LinkOBJ
:END
;    <- Das END in der vorigen Zeile beendet die Config. AB hier kann
;       wieder ein BEGIN gesetzt werden. $o ist der Name für ein Temp-File
;       das die Lise der Objektfiles für den Linker enthält. Diese wird
;       von Pmm erstellt.
; 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; DEMO-EINTRAG -- KEINE FUNKTION --
; ----------------------------------
; DOSLIB ist ein SPECIAL, der Linker wird übersteuert mit L=PmmLibr!
;        Hier entsteht eine .LIB, gesteuert über den eigenen Libr-Befehl
;        Um Libr wie einen Linker funktionieren zu lassen ist die
;        Steuerung F aufgenommen worden. Diese Version eines Libr könnte
;        auch ohne Probleme z.B. in vc integriert werden. Da hätte nur
;        mal jemand früher drauf kommen müssen (meine erste Version war
;        ein List-Batch wie bei 7% noch zu sehen).
;        Y0 startet einen Stub-Batch der weitere Link-Libs erstellt, wenn
;        dies notwendig ist (siehe Verzeichnis Batch).
;        Bei PPC wird Y1 als Erweiterung von L= eingesetzt, so kommt der
;        Batch zur Ausführung und das .a-File für PPC wird gebildet. 
;
:BEGIN DOSLIB
PFAD=Proj:DOSLIB
$5=-Ivinclude: -IInclude: -I$I
7%$5=-Ivincludeppc: -IInclude: -I$I
8%$5=-Ivincludewos: -IInclude: -I$I
1%$$=Lib:DOSLIB_000.Lib
2%$$=Lib:DOSLIB_010.Lib
3%$$=Lib:DOSLIB_020.Lib
4%$$=Lib:DOSLIB_030.Lib
5%$$=Lib:DOSLIB_040.Lib
6%$$=Lib:DOSLIB_060.Lib
7%$$=Lib:DOSLIB_ppc.a
8%$$=Lib:DOSLIB_wos.Lib
$o=T:LibList
1%L=PmmLibr F Lib:DosLib_000 $o
2%L=PmmLibr F Lib:DosLib_010 $o
3%L=PmmLibr F Lib:DosLib_020 $o
4%L=PmmLibr F Lib:DosLib_030 $o
5%L=PmmLibr F Lib:DosLib_040 $o
6%L=PmmLibr F Lib:DosLib_060 $o
7%L=List Proj:DOSLIB/obj/ppc/#?.o lformat="ppc-amigaos-ar q Lib:DOSLIB_ppc.a %s%s" >Ram:LibList
8%L=PmmLibr F Lib:DosLib_wos $o
5%X5=Execute Pmm:Batch/ManProto.s Proj:DOSLIB Include:DOSLIB_protos.h
Y0=Execute Pmm:Batch/MakeStubAll.s
7%Y1=Execute Ram:LibList
:END
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Als Demo habe ich das zum vbcc-Compiler gehörende Programm vc gewählt
; PFAD=    Wo liegen die Sourcen?
; $9=      Variable, wird in Pmm.Cfg eingefügt, vc muß mit -DAMIGA übersetzt werden
; $$=      Executable (hier gleich 8 unterschiedliche, aufgeteilt in eigene Verzeich-
;          nissse in denen auch die .o-Files gelagert werden). Mag etwas übertrieben
;          aussehen, aber bei 100 .c-Files kämen 800 .o-Files raus. Wer's nicht, oder
;          anders möchte kann sich das ja umstellen.
; $L       Link-Lib, Erweiterung zum Standard, hier auskommentiert, vc braucht meine
;          persönlichen Files nicht. Das muß auch jede Nutzer selber einrichten.
; $o       Obj-Liste für den Linker (Temp-File)
; X0       Aufruf Programmes VOR dem Make z.b. Versionsdumper
; Y0       Copy der 68040-Version ins vbcc-bin-Verzeichnis (zur Sicherheit aber
;          unter anderem Namen). Und, als Demo, 4 der maximal 8 Versionen werden
;          kopiert.
;
:BEGIN vc
PFAD=vbcc://frontend
$9=-DAMIGA
1%$$=obj/000/vc
2%$$=obj/010/vc
3%$$=obj/020/vc
4%$$=obj/030/vc
5%$$=obj/040/vc
6%$$=obj/060/vc
7%$$=obj/ppc/vc.elf
8%$$=obj/wos/vc
;
;     Die folgenden Zeilen definieren .Lib's für den Linker.
;     Sie sind jetzt auskommentiert, da das eigene Lib's sind und vc
;     braucht sie definitiv nicht.
;
;$L=Lib:DOSLIB_000.Lib Lib:All.Lib
;5%$L=Lib:DOSLIB_040.Lib Lib:All_040.Lib
;6%$L=Lib:DOSLIB_060.Lib Lib:All_040.Lib
;7%$L=Lib:DOSLIB_ppc.a Lib:All_ppc.a
;8%$L=Lib:DOSLIB_wos.Lib Lib:All_wos.Lib
$o=T:LinkVC
5%X0=Echo "Ich simuliere einen Versionsdumper, der aber nur bei 68040 anläuft."
1%Y0=Copy obj/000/vc vbcc://bin/vc_000
5%Y0=Copy obj/040/vc vbcc://bin/vc_040
7%Y0=Copy obj/ppc/vc.elf vbcc://bin/vc_ppc
8%Y0=Copy obj/040/vc vbcc://bin/vc_wos
:END

; :BEGIN xxx ist der Anfang einer Programmdefinition. Diese muß mit :END beendet
; werden. Der Name hinter BEGIN hat keine Bedeutung für's Compilat, er verbindet
; jedoch diese Definition mit den Dateien List_xxx und Work_xxx und ist auch der
; Parameter für Pmm 'Pmm -p xxx'. Der Programmname den der Compiler erzeugt ist
; in $$ festgelegt, ggf. auch mehrmals (siehe oben). BEGIN/END dürfen immer nur
; im Wechsel genau EINMAL benutzt werden. Alle anderen Zeilen können mit #%, also
; 0%, 1% ... 9% CPU-typisch gesetzt werden. An Y0 ist zu erkennen, wie eine
; Funktion nur bei einzelnen CPU's benutzt wird. $L zeigt eine Variante wo es
; einen Standard-Wert gibt, der in Einzelfällen verändert ist. $$ wiederum ist
; für alle CPU's einzeln festgelegt. PFAD ist die letzte Möglichkeit, nur eine
; Definition für alle ($9 und $o dito).
