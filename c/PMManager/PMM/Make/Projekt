; Diese Datei stellt ein Projekt dar. Hier wird auf die
; Programm-Dateien verwiesen, alle Pfade werden hier
; gesetzt. * gilt immer, außer ein Programm übersteuert.
; $1, $2 ... $9 (Variablen für pmm.cfg)
; $$.c=  Pfad für Source, wenn nicht identisch mit PFAD=
;
; Wichtig:
; Hier angegebene Include-Pfade sind nur für den Compiler
; und nicht für den Depend-Scan. Der Scan hat seine Include-
; pfade in der Pmm.UsrIncludes. Aufbau: Pro Zeile ein Include.
; Der Compiler sucht natürlich auch in in den Standard-Compiler-
; includes während der Depend-Scan ALLE Pfade mit den eigenen Dateien
; enthält. Bei Bedarf kommt vielleicht include/libraries mit da rein.
; Aber jedes Compiler-.h-File zu prüfen ist Unsinn. Nach einem Compiler-
; update sollte man ohnehin alles einheitlich neu übersetzen.
; Es ist für den Dependscan nicht nötig programmabhängig zu verwalten.
; Die Config dient mehr dem Ausschluß von Pfaden, nur wäre das wesent-
; lich mehr Arbeit. Der Homepfad der Sourcen ist für Depend immer ent-
; halten. Beim Compilieren wird der Pfad gebraucht, weil er an den
; Preprozessor übergeben werden muß. Pmm könnte das zwar auch alleine
; einsetzen, aber das würde die Möglichkeiten beschränken. Also immer
; -I$I als Include übergeben.
;
; Die Zeilen mit MAKE am Anfang:
; Hier bekommen die Zahlencodes 1%, 2% usw. ihre Zuordnung.
; MAKE=5 bedeutet: Make ohne Zusatz stellt Definition 5 her (ist als
;                  68040 vordefiniert).
; MAKE:xyz=1,2,3   Besagt nichts weiter als das Pmm ... -o xyz die
;                  Definitionen 1, 2 und 3 erstellen soll, so wie
;                  bei Make xyz im Makefile 'xyz:' als Festlegung für
;                  Aufrufparameter steht.
; MAKE:ALL=....    Das ist die Festlegung, welche Definitionen bei
;                  Pmm A, Q, I oder Pmm -o ALL erzeugt werden.
; Diese Einstellungen sind eine Erweiterung zu Pmm.Cfg, aber es geht
; weiter...
;
; Source und sonstige Files:
; $&.c ist source.c     Preprozessor Input  ( .c -> vcpp )
; $&.i ist soirce.i     Preprozessor Output ( .c -> vcpp -> .i )
; $&.a ist source.asm   Compiler Output     ( .i -> vbcc -> .asm )
; $&.s ist source.s     Compiler Output     ( .i -> vbcc -> .s (vsc) -> .asm )
; $&.o ist source.o     Assembler Output    ( .asm -> Assembler -> .o [ -> Linker] )
; $$   ist PROGRAMM     Letzter Output (Programm, Library, Lib etc.)
; vsc ist der Scheduler, siehe Docs für Warp-Version!!!
; Dies alles geschieht automatisch. Für .i, .a, .s und .o werden nur noch die
; Pfade festgelegt. Bei $$ der Name des Programmes INCL. Pfad, wenn gewünscht.
; Falls nicht, wird a.out imaktuellen Verzeichnis benutzt. Siehe $$ unten...
; $L Ergänzung der .Lib/.a-Dateien für den Linker.
;
; Warum dieser Eintrag, ginge doch genauso gut in Pmm.Cfg?
; WEIL Pmm.Cfg nur Dinge enthalten sollte die allgemein gültig sind.
; Diese Projektdatei wird künftig mehrfach angelegt werden können, so
; das Projekte in Sub-Projekte unterteilt werden können, bzw. auch
; mehrere Projekte möglich werden. Dann sollte hier das stehen, was
; für das Projekt vom sonstigen Standard abweicht.
;
:BEGIN *
MAKE=5
MAKE:60=5,6
MAKE:PPC=7,8
MAKE:ALL=1,2,3,4,5,6,7,8
1%$&.o=obj/000/
2%$&.o=obj/010/
3%$&.o=obj/020/
4%$&.o=obj/030/
5%$&.o=obj/040/
6%$&.o=obj/060/
7%$&.o=obj/ppc/
8%$&.o=obj/wos/
$&.i=T:
$&.a=T:
$&.s=T:
$$=a.out
1%$L=-Bsymbolic Lib:DOSLIB_000.Lib Lib:All.Lib
2%$L=-Bsymbolic Lib:DOSLIB_010.Lib Lib:All.Lib
3%$L=-Bsymbolic Lib:DOSLIB_020.Lib Lib:All.Lib
4%$L=-Bsymbolic Lib:DOSLIB_030.Lib Lib:All.Lib
5%$L=-Bsymbolic Lib:DOSLIB_040.Lib Lib:All_040.Lib
6%$L=-Bsymbolic Lib:DOSLIB_060.Lib Lib:All_040.Lib
7%$L=-Bdynamic Lib:DOSLIB_ppc.a Lib:All_ppc.a
8%$L=-Bsymbolic Lib:DOSLIB_wos.Lib Lib:All_wos.Lib
$o=T:LinkOBJ
:END
;    <- Das END in der vorigen Zeile beendet die Config. AB hier kann
;       wieder ein BEGIN gesetzt werden. $o ist der Name für ein Temp-File
;       das die Lise der Objektfiles für den Linker enthält. Diese wird
;       von Pmm erstellt.
; 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; DEMO-EINTRAG -- KEINE FUNKTION --
; ----------------------------------
; DOSLIB ist ein SPECIAL, der Linker wird übersteuert mit L=PmmLibr!
;        Hier entsteht eine .LIB, gesteuert über den eigenen Libr-Befehl
;        Um Libr wie einen Linker funktionieren zu lassen ist die
;        Steuerung F aufgenommen worden. Diese Version eines Libr könnte
;        auch ohne Probleme z.B. in vc integriert werden. Da hätte nur
;        mal jemand früher drauf kommen müssen (meine erste Version war
;        ein List-Batch wie bei 7% noch zu sehen).
;        Y0 startet einen Stub-Batch der weitere Link-Libs erstellt, wenn
;        dies notwendig ist (siehe Verzeichnis Batch).
;        Bei PPC wird Y1 als Erweiterung von L= eingesetzt, so kommt der
;        Batch zur Ausführung und das .a-File für PPC wird gebildet. 
;
:BEGIN DOSLIB
PFAD=Proj:DOSLIB
$5=-Ivinclude: -IInclude: -I$I
7%$5=-Ivincludeppc: -IInclude: -I$I
8%$5=-Ivincludewos: -IInclude: -I$I
1%$$=Lib:DOSLIB_000.Lib
2%$$=Lib:DOSLIB_010.Lib
3%$$=Lib:DOSLIB_020.Lib
4%$$=Lib:DOSLIB_030.Lib
5%$$=Lib:DOSLIB_040.Lib
6%$$=Lib:DOSLIB_060.Lib
7%$$=Lib:DOSLIB_ppc.a
8%$$=Lib:DOSLIB_wos.Lib
$o=T:LibList
1%L=PmmLibr F Lib:DosLib_000 $o
2%L=PmmLibr F Lib:DosLib_010 $o
3%L=PmmLibr F Lib:DosLib_020 $o
4%L=PmmLibr F Lib:DosLib_030 $o
5%L=PmmLibr F Lib:DosLib_040 $o
6%L=PmmLibr F Lib:DosLib_060 $o
7%L=List Proj:DOSLIB/obj/ppc/#?.o lformat="ppc-amigaos-ar q Lib:DOSLIB_ppc.a %s%s" >Ram:LibList
8%L=PmmLibr F Lib:DosLib_wos $o
5%X5=Execute Pmm:Batch/ManProto.s Proj:DOSLIB Include:DOSLIB_protos.h
Y0=Execute Pmm:Batch/MakeStubAll.s
7%Y1=Execute Ram:LibList
:END
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Als Demo habe ich das zum vbcc-Compiler gehörende Programm vc gewählt
; PFAD=    Wo liegen die Sourcen?
; $9=      Variable, wird in Pmm.Cfg eingefügt, vc muß mit -DAMIGA übersetzt werden
; $$=      Executable (hier gleich 8 unterschiedliche, aufgeteilt in eigene Verzeich-
;          nissse in denen auch die .o-Files gelagert werden). Mag etwas übertrieben
;          aussehen, aber bei 100 .c-Files kämen 800 .o-Files raus. Wer's nicht, oder
;          anders möchte kann sich das ja umstellen.
; $L       Link-Lib, Erweiterung zum Standard, hier auskommentiert, vc braucht meine
;          persönlichen Files nicht. Das muß auch jede Nutzer selber einrichten.
; $o       Obj-Liste für den Linker (Temp-File)
; X0       Aufruf Programmes VOR dem Make z.b. Versionsdumper
; Y0       Copy der 68040-Version ins vbcc-bin-Verzeichnis (zur Sicherheit aber
;          unter anderem Namen). Und, als Demo, 4 der maximal 8 Versionen werden
;          kopiert.
;
:BEGIN vc
PFAD=vbcc://frontend
$9=-DAMIGA
1%$$=obj/000/vc
2%$$=obj/010/vc
3%$$=obj/020/vc
4%$$=obj/030/vc
5%$$=obj/040/vc
6%$$=obj/060/vc
7%$$=obj/ppc/vc.elf
8%$$=obj/wos/vc
;
;     Die folgenden Zeilen definieren .Lib's für den Linker.
;     Sie sind jetzt auskommentiert, da das eigene Lib's sind und vc
;     braucht sie definitiv nicht.
;
;1%$L=-Bsymbolic Lib:DOSLIB_000.Lib Lib:All.Lib
;2%$L=-Bsymbolic Lib:DOSLIB_010.Lib Lib:All.Lib
;3%$L=-Bsymbolic Lib:DOSLIB_020.Lib Lib:All.Lib
;4%$L=-Bsymbolic Lib:DOSLIB_030.Lib Lib:All.Lib
;5%$L=-Bsymbolic Lib:DOSLIB_040.Lib Lib:All_040.Lib
;6%$L=-Bsymbolic Lib:DOSLIB_060.Lib Lib:All_040.Lib
;7%$L=-Bdynamic Lib:DOSLIB_ppc.a Lib:All_ppc.a
;8%$L=-Bsymbolic Lib:DOSLIB_wos.Lib Lib:All_wos.Lib
$o=T:LinkVC
5%X0=Echo "Ich simuliere einen Versionsdumper, der aber nur bei 68040 anläuft."
1%Y0=Copy obj/000/vc vbcc://bin/vc_000
5%Y0=Copy obj/040/vc vbcc://bin/vc_040
7%Y0=Copy obj/ppc/vc.elf vbcc://bin/vc_ppc
8%Y0=Copy obj/040/vc vbcc://bin/vc_wos
:END

; :BEGIN xxx ist der Anfang einer Programmdefinition. Diese muß mit :END beendet
; werden. Der Name hinter BEGIN hat keine Bedeutung für's Compilat, er verbindet
; jedoch diese Definition mit den Dateien List_xxx und Work_xxx und ist auch der
; Parameter für Pmm 'Pmm -p xxx'. Der Programmname den der Compiler erzeugt ist
; in $$ festgelegt, ggf. auch mehrmals (siehe oben). BEGIN/END dürfen immer nur
; im Wechsel genau EINMAL benutzt werden. Alle anderen Zeilen können mit #%, also
; 0%, 1% ... 9% CPU-typisch gesetzt werden. An Y0 ist zu erkennen, wie eine
; Funktion nur bei einzelnen CPU's benutzt wird. $L zeigt eine Variante wo es
; einen Standard-Wert gibt, der in Einzelfällen verändert ist. $$ wiederum ist
; für alle CPU's einzeln festgelegt. PFAD ist die letzte Möglichkeit, nur eine
; Definition für alle ($9 und $o dito).
