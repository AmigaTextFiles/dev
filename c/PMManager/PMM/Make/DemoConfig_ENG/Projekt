; This is a project. Here are a lot of setup's, the programs
; and the phadnames for source, objects und exe-files.
; The *-entry is a general setting, it will work as default
; The programs can use it or set own setup's
; $1, $2 ... $9 (This are variables for pmm.cfg)
; $$.c=  Phat to source, if not identical with PFAD=
;
; Important:
; This file is only use by the compiler. The pathes that will be
; scan for include by the depend-scanner comes from pmm.userincludes.
; pmm.userincludes: every line ONE scanpath. Don't set pathes to the
; compilerincludes. Only include/libraries if you really use that.
; Else alle include-.h-files are checked everytime you start compiling
; and that cost many time for nothing.
; After a compilerupdate where the .h-files really changed best work
; is to remake all files.
; Note, that the depend-pathes are used for all programs same. The
; sourcedirectory is everytime another and only the real include-dir's
; are scanned.
; The depend look everytime at the source-home-dir of the program.
; The compiler dosn't do that. Use the pseudoinclude -I$I to set
; up the homedir for the compiler. Pmm do this not alone, because
; I will be open in for all things in future.
;
; Lines with MAKE at the beginning:
; First the 1%, 2% ... etc. now become content
; MAKE=5    means: Start Pmm without a makeoption (like only make) internal
;                  use is equal 5 that set as 68040 in my default).
; MAKE:xyz=1,2,3   This means, if you start pmm with -o xyz the system
                   make the type 1, 2 and 3. 
; MAKE:ALL=....    Important! This set what be happend if Pmm is starting
;                  with A, Q, I or -o ALL.
; This all are additives to pmm.cfg. But there are more things:
;
; Source und sonstige Files:
; $&.c ist source.c     Preprozessor Input  ( .c -> vcpp )
; $&.i ist soirce.i     Preprozessor Output ( .c -> vcpp -> .i )
; $&.a ist source.asm   Compiler Output     ( .i -> vbcc -> .asm )
; $&.s ist source.s     Compiler Output     ( .i -> vbcc -> .s (vsc) -> .asm )
; $&.o ist source.o     Assembler Output    ( .asm -> Assembler -> .o [ -> Linker] )
; $$   ist PROGRAMM     Letzter Output (Programm, Library, Lib etc.)
; vsc is the scheduler, look at the vbcc-doc's for warpos!!!
; All there things done automaticly by pmm. .i, .a, .s and .o will used to
; specify the path-names. $$ specify the program that will be create. If you
; specify none a.out will be createt at the actual sourcedir. Look downline
; $L defines the additive .Lib or .a-Files for the linker.
;
; Why here and not in Pmm.Cfg. Because the settings here in pmm.cfg are
; correct for most (all) times. Setup includes here must changed if you
; begin another project. In future I will support multiple projects and
; so it is easy to work at every project with his own way.
; Warum dieser Eintrag, ginge doch genauso gut in Pmm.Cfg?. Also do
; all things here that not generell standard at you amiga.
;
; Take notice of BEGIN * and look at the next textblock:
;
:BEGIN *
MAKE=5
MAKE:60=5,6
MAKE:PPC=7,8
MAKE:ALL=1,2,3,4,5,6,7,8
1%$&.o=obj/000/
2%$&.o=obj/010/
3%$&.o=obj/020/
4%$&.o=obj/030/
5%$&.o=obj/040/
6%$&.o=obj/060/
7%$&.o=obj/ppc/
8%$&.o=obj/wos/
$&.i=T:
$&.a=T:
$&.s=T:
$$=a.out
1%$L=-Bsymbolic Lib:DOSLIB_000.Lib Lib:All.Lib
2%$L=-Bsymbolic Lib:DOSLIB_010.Lib Lib:All.Lib
3%$L=-Bsymbolic Lib:DOSLIB_020.Lib Lib:All.Lib
4%$L=-Bsymbolic Lib:DOSLIB_030.Lib Lib:All.Lib
5%$L=-Bsymbolic Lib:DOSLIB_040.Lib Lib:All_040.Lib
6%$L=-Bsymbolic Lib:DOSLIB_060.Lib Lib:All_040.Lib
7%$L=-Bdynamic Lib:DOSLIB_ppc.a Lib:All_ppc.a
8%$L=-Bsymbolic Lib:DOSLIB_wos.Lib Lib:All_wos.Lib
$o=T:LinkOBJ
:END
;    <- The END in the line bevor wil ending this config. From this line down
;       it is allowed to set a new BEGIN. $o is name of a temporary file.
;       after compile all source to object's the list of objectfiles will be
;       find in it. Pmm creates the list and it will be read from PmmLibr
;       or the Linkers. Look in Pmm.Cfg for more details.
; 
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Demonstartion --- no function ---
; ---------------------------------
; DOSLIB is a SPECIAL, the linker will be replaced with PmmLibr.
;        This is the way, I ccreate all source-link-lib's. Only the
;        stub-libs will created by own way with batches. To go the
;		 simple way with the link-list that will create by pmm I programming
;        the a function in PmmLibr, read object-list from file. So it is
;        very simple now. Look at PPC-Version with the ar-command. First
;        a complete ar-libr-batch must be created (with list an lformat).
;        After that the batch executed. Yes, it work, but not so quick and
;        not so "beatifull". To use a file as inputfile with PmmLibr use
;        the new option F. PmmLibr or a other libr with this option can
;        with minimal changes included in any compile-help-system. As example
;        the vc-tool from vbcc. Many things will work easy if the tools
;        good enough. That nobody create such a version (progamming is
;        very simple) can have only one reason. Nobody has the idea.
;        If you use PmmTool with filefunction with another link-system or
;        any other software, please let me know that. Hear from new ideas
;        or special usages help to build new own ideas.
;
:BEGIN DOSLIB
PFAD=Proj:DOSLIB
$5=-Ivinclude: -IInclude: -I$I
7%$5=-Ivincludeppc: -IInclude: -I$I
8%$5=-Ivincludewos: -IInclude: -I$I
1%$$=Lib:DOSLIB_000.Lib
2%$$=Lib:DOSLIB_010.Lib
3%$$=Lib:DOSLIB_020.Lib
4%$$=Lib:DOSLIB_030.Lib
5%$$=Lib:DOSLIB_040.Lib
6%$$=Lib:DOSLIB_060.Lib
7%$$=Lib:DOSLIB_ppc.a
8%$$=Lib:DOSLIB_wos.Lib
$o=T:LibList
1%L=PmmLibr F Lib:DosLib_000 $o
2%L=PmmLibr F Lib:DosLib_010 $o
3%L=PmmLibr F Lib:DosLib_020 $o
4%L=PmmLibr F Lib:DosLib_030 $o
5%L=PmmLibr F Lib:DosLib_040 $o
6%L=PmmLibr F Lib:DosLib_060 $o
7%L=List Proj:DOSLIB/obj/ppc/#?.o lformat="ppc-amigaos-ar q Lib:DOSLIB_ppc.a %s%s" >Ram:LibList
8%L=PmmLibr F Lib:DosLib_wos $o
5%X5=Execute Pmm:Batch/ManProto.s Proj:DOSLIB Include:DOSLIB_protos.h
Y0=Execute Pmm:Batch/MakeStubAll.s
7%Y1=Execute Ram:LibList
:END
;
; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
;
; Next: the first real working demonstration. It will be create the program vc from the
;          sources, so as includet in vbcc. I only do a little bit more as the makefile
; PFAD=    path to source
; $9=      a variable for use in Pmm.Cfg. NOTE that vc must compiled with -DAMIGA
; $$=      Path and name for the executable. You give little finger, I take the complete
;          hand, or more! vbcc is able to create versions for 8 cpu-types, If you really
;          thing about this, you will see, for all cpu's there is only one fpu that will
;          combined with it. The 68000 or 010 without fpu, 68020 most mit 68881 (or none,
;          take 68010-version). 68030 in most versions are combined with 68882 (if 881
;          use 020-version...) and so on. The result of thing so are 6 versions for
;          mc68k and the ppc. The ppc can be elf and used with PowerUp. Or elh for the
;          WarpUP/WarpOS. Since vbcc 0.6c both systems useable with vbcc and so, there
;          will be 8 programs to make. Please, write a makefile, compiling vc with
;          checking all included .h-files (this demo show the work on .h-files at the
;          standard-includes). OK, also, makefile, 8 cpu-types, all create single or
;          all, check includes, update the includes with a depend-scanner, create
;          prototypes, hold the objects for all 8 versions, hold all 8 created
;          programs, copy 3 or 4 after build directly to a special path and if you do
;          that hard work, please change a .h-file. Good, if you remember what
;          thing all to do for makefile, now note this:
;          ADOSLIB: LIB 100 .c-files, ca. 1000 .h-files, 8 cpu's,  .o-files hold
;          Port:    EXE 124 .c-files, ca  1400 .h-files, 8 cpu's, .o-files hold
;          And now thing back to makefile with full depending's.
;          Nobody do that work manually (and without errors!). For Pmm you do the
;          same thing (not more) as now demonstrated for vc:
;          First set BEGIN and a label (this is the name for pmm. Input this name
;          will start the make. Best you take the real programname, here vc. Pmm
;          can compile from every position, so the pathname must be set. Look PFAD=
;          for path (PFAD is german word for path. In a future release both word
;          will work. $9 add to the standard-defines set now -DAMIGA (else we
;          create a unix-version). For all 8 CPU-Versions you see the pathes and
;          the executables. from sourcedir a out-dir obj will created and in obj
;          a subdir for each cpu-type (the will be stored .o and executable). This
;          is so set for my big programs.
; $L       link-lib, addon to standard, not active in this demo, vc don't use it.
;          Bevor reaktive, change to your own addon-libs's.
; $o       Filename for linker-obj-files
; X0       Versionsdumper start here. A Revision-control later come IN Pmm.
; Y0       Copy the 68040-version to vbcc-bin-dir. (But not use the realname to
;          make the demo useable without risiko. At END of the demo you see, 4
;          from 8 versions that build will be also copy to another name and
;          place.
;
:BEGIN vc
PFAD=vbcc://frontend
$9=-DAMIGA
1%$$=obj/000/vc
2%$$=obj/010/vc
3%$$=obj/020/vc
4%$$=obj/030/vc
5%$$=obj/040/vc
6%$$=obj/060/vc
7%$$=obj/ppc/vc.elf
8%$$=obj/wos/vc
;
;     Addon link-libs, only to see how you use own libs.
;
;1%$L=-Bsymbolic Lib:DOSLIB_000.Lib Lib:All.Lib
;2%$L=-Bsymbolic Lib:DOSLIB_010.Lib Lib:All.Lib
;3%$L=-Bsymbolic Lib:DOSLIB_020.Lib Lib:All.Lib
;4%$L=-Bsymbolic Lib:DOSLIB_030.Lib Lib:All.Lib
;5%$L=-Bsymbolic Lib:DOSLIB_040.Lib Lib:All_040.Lib
;6%$L=-Bsymbolic Lib:DOSLIB_060.Lib Lib:All_040.Lib
;7%$L=-Bdynamic Lib:DOSLIB_ppc.a Lib:All_ppc.a
;8%$L=-Bsymbolic Lib:DOSLIB_wos.Lib Lib:All_wos.Lib
$o=T:LinkVC
5%X0=Echo "I do nothing, but you must know, normally here starts the versiondumper*Nif the 68040-version must new compiled."
1%Y0=Copy obj/000/vc vbcc://bin/vc_000
5%Y0=Copy obj/040/vc vbcc://bin/vc_040
7%Y0=Copy obj/ppc/vc.elf vbcc://bin/vc_ppc
8%Y0=Copy obj/040/vc vbcc://bin/vc_wos
:END
;
; that's it with 20-30 lines (cut, paste, edit) you can add a program to make here.
; source read in from Pmm and dependings will create also. Pmm takes the full control
; on it all. Normal I create the prototypes from script. The Script can found in batch
; -dir, Add a line like this directly bevor END
; 5%X5=Execute Pmm:Batch/ManProto.s vbcc://frontend MyInclude:vc_protos.h
;
