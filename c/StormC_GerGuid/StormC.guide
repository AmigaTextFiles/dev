@database StormC.guide

@Master manuals

@Width 72

@Index Main

This is the AmigaGuide® file StormC.guide

This file documents StormC, a development system for AmigaOS V2.04
or newer.


@Node Main "StormC.guide"
@Next "Main"
@Prev "Main"
@Title "Erste Seite"

    @{b}StormC Demoversion 2.0@{ub}

    Software und Dokumentation
    © 1996/97 by HAAGE & PARTNER Computer GmbH

    Inhaltsverzeichnis

     @{" Lizenzbedingungen" Link "ST_Lizenz"}

     @{" Kapitel  1 " Link "ST_Welcome"}    Willkommen zu einer neuen Ära
     @{" Kapitel  2 " Link "ST_Philo"}    Philosophisches
     @{" Kapitel  3 " Link "ST_Maschine"}    Anforderungen
     @{" Kapitel  4 " Link "ST_Install"}    Installation
     @{" Kapitel  5 " Link "ST_Problem"}    Was tun bei "unlösbaren" Problemen
     @{" Kapitel  6 " Link "ST_Tutorial"}    Tutorial
     @{" Kapitel  7 " Link "ST_Start"}    Programmstart
     @{" Kapitel  8 " Link "ST_Project"}    Erzeugen eines neuen Projektes
     @{" Kapitel  9 " Link "ST_Make"}    Make und Modulabhängigkeiten
     @{" Kapitel 10 " Link "ST_Source"}    Quelltext erfassen
     @{" Kapitel 11 " Link "ST_Compile"}    Quelltext kompilieren
     @{" Kapitel 12 " Link "ST_Start"}    Übersetztes Programm starten
     @{" Kapitel 13 " Link "ST_Debug"}    Der Debugger
     @{" Kapitel 14 " Link "ST_Sektion"}    Projektsektionen
     @{" Kapitel 15 " Link "ST_Owns"}    Eigenheiten des Compilersystems
     @{" Kapitel 16 " Link "ST_Referenz"}    Menübefehle
     @{" Kapitel 17 " Link "STC2_Project"}    Anmerkungen zur Portierung von SAS/C nach StormC
     @{" Kapitel 18 " Link "ST_Q&A"}    Die häufigsten Fragen und ihre Antworten
     @{" Kapitel 19 " Link "ST_ARexx"}    Die ARexx-Kommandos von StormC im einzelnen

     @{" Kapitel 20 " Link "ST_NEUES1"}    Neues in Version 1.1 und 1.2
     @{" Kapitel 21 " Link "ST_Neues2"}    Neues in Version 2.0
     @{" kapitel 22 " Link "Presse"}    Pressestimmen zu StormC

     @{" Copyrights " Link "ST_CRIGHT"}

     @{" Bestellformular " Link "ST_ORDER"}

@EndNode

@Node "ST_Order" "StormC.guide/ST_Order"
@Toc "Main"

Bitte drucken Sie das beiliegende Formular auf Ihrem Drucker aus.

Kreuzen Sie bitte das gewünschte Produkt an und faxen oder übersenden Sie 
uns das vollständig ausgefüllte Formular.

Unserer Anschrift lautet:
@{b}
        HAAGE & PARTNER Computer GmbH
        Postfach 80
        
        61188 Rosbach v.d.H.

        Fax: 06007 / 7543@{ub}


        @{b}@{i}Bestellung@{ub}@{ui} (Bitte entsprechendes ankreuzen!)


        *       Ja, ich bestelle die Vollversion von StormC zum Preis von 598,- DM
        
                
        *       Ich bestelle das Cross Upgrade auf mein altes
                
                Compilersystem:___________________________________________
                
                zum Preis von 498,- DM
                
                
                
                
        Vorname:_____________________________________________________
        
        Name:________________________________________________________
        
        Straße:______________________________________________________
        
        PLZ:__________ Ort:__________________________________________
        
        Telefon:_____________________________________________________
        
        EMail:_______________________________________________________
        
        
        Gewünschte Zahlungsweise bitte ankreuzen:
                
        *       per Nachnahme (zzgl. DM 13,- Porto und Verpackung,
                               nicht ins Ausland)
                
        *       per beiliegendem Vorauskasse-Scheck
                
        *       bequem und bargeldlos per Kreditkarte
                (zzgl. 8,- DM Porto und Verpackung)

        (bitte ankreuzen)

        * VISA         * Eurocard/Mastercard
                
        Kreditkarteninhaber:______________________________________
        
        Kartennummer:    |_|_|_|_| |_|_|_|_| |_|_|_|_| |_|_|_|_|
        
        Gültig ab:____________ Gültig bis:________________________
        
        Datum:__________________ Unterschrift:____________________
        

@EndNode

@Node "ST_CRIGHT" "StormC.guide/ST_CRIGHT"
@Next "ST_Lizenz"
@Prev "ST_ORDER"
@Toc "Main"


Copyrights und Warenzeichen:
Commodore und Amiga sind eingetragene Warenzeichen.
SAS und SAS/C sind eingetragene Warenzeichen des SAS-Instituts.
Amiga, AmigaDOS, Kickstart und Workbench sind Warenzeichen.
Die Nennung von Produkten, die nicht von der HAAGE & PARTNER Computer 
GmbH sind, dient ausschließlich Informationszwecken und stellt keinen 
Warenzeichenmißbrauch dar.

@EndNode

@Node "ST_Lizenz" "StormC.guide/ST_Lizenz"
@Next "ST_ORDER"
@Prev "ST_CRIGHT"
@Toc "Main"

@{b}Lizenzvereinbarungen@{ub}

@{i}1 Allgemeines@{ui}
(1)     Gegenstand dieses Vertrages ist das Benutzungsrecht für Computer-
        programme der HAAGE & PARTNER Computer GmbH, für die Benutzungs-
        anleitung sowie für sonstiges zugehöriges, schriftliches Material, 
        nachfolgend zusammenfassend als Produkt bezeichnet.
(2)     Die HAAGE & PARTNER Computer GmbH und/oder die in dem Produkt 
        angegebenen Lizenzgeber sind Inhaber sämtlicher Rechte an den 
        Produkten und Warenzeichen.

@{i}2 Nutzungsrechte@{ui}
(1)     Der Käufer erhält ein nicht übertragbares, nicht ausschließliches 
        Recht, das erworbene Produkt auf einem Computer bzw. an einem 
        Arbeitsplatz zu nutzen.
(2)     Darüber hinaus kann der Anwender eine einzige Kopie zu Sicherungs-
        zwecken anfertigen.
(3)     Der Käufer ist nicht berechtigt, das erworbene Produkt zu 
        vertreiben, zu vermieten, Dritten Unterlizenzen anzubieten oder 
        diese in anderer Weise Dritten zur Verfügung zu stellen.
(4)     Es ist verboten, das Produkt zu ändern, zu modifizieren oder 
        anzupassen oder in jeglicher Form rückzuentschlüsseln. Dieses 
        Verbot gilt auch für das Übersetzen, Abwandeln, Rückentschlüsseln 
        und Weiterverwenden von Teilen.

@{i}3 Gewährleistung@{ui}
(1)     Die HAAGE & PARTNER Computer GmbH gewährleistet, daß zum 
        Zeitpunkt der Lieferung die Datenträger physikalisch frei von 
        Material- und Herstellungsfehlern sind und das Produkt wie in der 
        Dokumentation beschriebenen Weise genutzt werden kann.
(2)     Mängel des gelieferten Produkts werden vom Lieferanten innerhalb 
        der Gewährleistungsfrist von sechs Monaten ab Lieferung nach ent-
        sprechender Mitteilung durch den Anwender behoben. Dies geschieht 
        nach Wahl des Lieferanten durch kostenfreie Nachbesserung oder 
        durch Ersatzlieferung in Form eines Updates.
(3)     Die HAAGE & PARTNER Computer GmbH übernimmt keine Haftung dafür, 
        daß das Produkt für die vom Kunden vorgesehene Aufgabe geeignet 
        ist. Für eventuell auftretende Folgeschäden übernimmt die 
        HAAGE & PARTNER Computer GmbH keine Haftung.
(4)     Der Anwender weiß, daß nach dem heutigen Stand der Technik die 
        Erstellung völlig fehlerfreier Software nicht möglich ist.

@{i}4 Sonstiges@{ui}
(1)     In diesem Vertrag sind sämtliche Rechte und Pflichten der 
        Vertragsparteien geregelt. Sonstige Vereinbarungen bestehen nicht. 
        Änderungen sind nur in Schriftform und bei Bezugnahme auf diesen 
        Vertrag wirksam und beiderseitig zu unterzeichnen.
(2)     Der Gerichtsstand für alle Streitigkeiten aus diesem Vertrag 
        ist, soweit vereinbar, das zuständige Gericht am Firmensitz der 
        HAAGE & PARTNER Computer GmbH.
(3)     Sollten einzelne Bestimmungen dieser Bedingungen nicht rechts-
        wirksam sein oder ihre Rechtswirksamkeit durch einen späteren 
        Umstand verlieren, oder sollte sich in diesen Bedingungen eine 
        Lücke herausstellen, so wird hierdurch die Rechtswirksamkeit der 
        übrigen Bestimmungen nicht berührt. Anstelle der unwirksamen 
        Vertragsbestimmungen oder zur Ausfüllung der Lücke soll eine 
        angemessene Regelung gelten, die, soweit rechtlich möglich, 
        dem am nächsten kommt, was die Vertragsparteien gewollt haben, 
        soweit sie von der Unwirksamkeit der Bestimmung Kenntnis 
        gehabt hätten.
(4)     Jede Verletzung vorstehender Lizenzbestimmungen oder von 
        Urheber- und Warenzeichenrechten wird straf- und zivilrechtlich 
        verfolgt.
(5)     Durch Installation der Software werden diese Lizenz-
        vereinbarungen anerkannt.
(6)     Sind Sie mit den Lizenzvereinbarungen nicht einverstanden, 
        so müssen Sie das Produkt unverzüglich gegen Erstattung 
        bereits geleisteter Zahlungen an den Lieferanten zurückgeben.

Stand: September 1995

@EndNode

@Node "ST_Welcome" "StormC.guide/ST_Welcome"
@Next "ST_Philo"
@Prev "ST_Main"
@Toc "Main"

@{b}Willkommen zu einer neuen Ära der Amiga-Programmierung.@{ub}

Mit der aktuellen Demoversion unseres modernen Compilersystems
lernen Sie die Fähigkeiten einer fortschrittlichen Programmiersprache 
kennen.
In einer sogenannten integrierten Umgebung finden Sie alles, was Sie 
zum Programmieren benötigen. Herzstück und Steuerzentrale ist die 
Projektverwaltung, von der aus alle weiteren Komponenten des 
Systems aufgerufen und mit Daten versorgt werden. 
Die Projektverwaltung ist nicht einfach nur ein besseres Make, sondern 
eine Verwaltung für alle Ihre Programmodule. Dazu zählen nicht nur 
Quelltexte und Objekt-Bibliotheken, auch die Programmdokumentation, 
zum Programm gehörende Arexx-Scripts, Bilder und Ressourcen werden 
darin verwaltet. Selbstverständlich werden von hier aus auch alle 
Compiler-, Editor- und Projekt-Optionen eingestellt. 
Wenn Sie jetzt der Meinung sind, daß das alles bestimmt viel 
zu kompliziert zu bedienen ist, kann ich Sie beruhigen. 
Blättern Sie doch einmal auf die nächsten Seiten, dorthin, wo das 
erste Beispiel beschrieben wird. Sie werden sehr schnell sehen, daß 
alles sehr einfach und intuitiv bedient werden kann.

Eine weitere Komponenten im System ist z. B. der Editor mit seiner 
besonderen Fähigkeit, Schlüsselworte und Syntax-Eigenschaften 
farbig im Text hervorzuheben. Die Farbmarkierung hilft nicht nur, 
daß Sie ihr Programm durch die besondere Strukturierung besser 
lesen können, sie hilft auch dabei, Fehler bei der Erfassung 
Ihrer Quelltexte zu vermeiden. Sobald ein Schlüsselwort oder 
eine Amiga-Funktion komplett eingegeben ist, wird das Wort 
farbig markiert und Sie haben die Sicherheit, daß die Schreibweise 
korrekt ist.

Mit der Version 2.0 von StormC erhalten Sie ebenfalls eine Lizenz des
populären GoldED 4. GoldEd ist ebenso harmonisch in die StormC-Umgebung
integriert wie StormED und bietet darüber hinaus so wichtige Funktionen
wie das Speichern von Unterbrechungspunkten im Debugmodus.

Bevor wir zum eigentlichen Arbeitspferd, dem Compiler kommen, möchte 
ich kurz auf den außergewöhnlichen Debugger eingehen. Außergewöhnlich 
deshalb, weil Sie den Unterschied, ob nun der Editor läuft oder ob es 
doch der Debugger ist, kaum bemerken werden auch bei der Nutzung zusammen
mit GoldED. Der Debugger nutzt nämlich die Fähigkeiten des Editors. Die
Quelltexte des zu debuggenden Programmes werden im Editorfenster angezeigt.
Wie gewohnt können Sie nun darin blättern, Unterbrechungspunkte setzen 
und Programmfunktionen oder Variablen suchen. Wie gewohnt wird auch die 
Quelltext-Strukturierung durch die farbige Textdarstellung unterstützt. 

Sie können so wesentlich flüssiger arbeiten.

Wir hatten natürlich bei der bisherigen Planung auch einen Hinter-
gedanken. Für zukünftige Versionen ist es vorgesehen, daß Änderungen, 
die man während des Debuggens in den Quelltext einfügt, direkt wieder 
übersetzt werden können. Das lästige Beenden des Debugger, das 
Neukompilieren und erneute Starten hat dann ein Ende. Schöne Aussichten, 
die die Software-Entwicklung auf dem Amiga noch effizienter gestalten.

Eine sehr große Hilfe für den Debugger ist auch unsere RunShell. Durch 
sie ist es möglich, die typischen Programmierfehler bei der Betriebs-
systemprogrammierung schnell zu lokalisieren. Ein Beispiel für Fehler, 
die immer wieder gemacht werden, ist am besten mit den Funktionen 
AllocMem() und FreeMem() zu beschreiben: Speicher zu allozieren, ist 
eine einfache Sache, ihn aber wieder an das System zurückzugeben, 
stellt für viele Programmierer ein großes Problem dar. Entweder wird 
vergessen, alle Speicherblöcke freizugeben oder der freigegebene Block 
ist zu groß oder zu klein, was meist in einer CPU-Exception endet. 

Die RunShell führt zu allen wichtigen Systemroutinen Protokoll, die 
etwas mit den Systemressourcen zu tun haben. So kann genau dokumentiert 
werden, wann Funktionen zuwenig, zuoft oder mit fehlerhaften Parametern 
aufgerufen werden. Ein weiterer großer Vorteil der RunShell ist die 
Möglichkeit, jederzeit während des Programmablaufs den Debugger zu 
starten. Sie müssen sich also nicht bereits vor dem Programmstart 
entscheiden, ob Sie nun debuggen möchten, oder ob das Programm im 
normalen Modus ablaufen soll. Wechseln Sie einfach im Bedarfsfall in 
den Debugger.

Mit der Version 2.0 bekam der Debugger ein weiteres Highlight an seine
eite - der Profiler. Dieses Werkzeug ermöglicht die einfache Protokol-
lierung von Funktionslaufzeiten. Der Profiler hilft Ihnen die Funktionen
zu entdecken, die in Ihren Programmen die meiste Zeit benötigen. Sie
haben dadurch die Möglichkeit gezielt an den Stellen zu optimieren, an
denen es nötig ist.

Aber nun zum eigentlichen Gehirn des Entwicklungspaketes, dem 
ANSI C/C++ Compiler. 

Der Begriff objektorientierte Programmierung ist in aller Munde. Kaum 
ein Softwarehaus entwickelt heute noch in ANSI C. Zumindest wird dieser 
Eindruck vermittelt. Das Gegenteil ist jedoch der Fall. Alle benutzen 
zwar einen C++ Compiler, aber der ist natürlich genauso gut geeignet, 
auch ANSI C Quelltexte zu übersetzen.
Unser Augenmerk richtet sich deshalb auch an diejenigen, die bisher mit 
ANSI-C gearbeitet haben, und bei einem Umstieg auf ein zukunftsicheres 
Compilersystem ihre Programme 1 zu 1 weiterverwenden möchten. Der sanfte 
Umstieg ist mit StormC gewährleistet.

Die C++-Implementation richtet sich nach den Vorgaben von Bjarne 
Stroustrup und ist damit zum erweiterten AT&T Standard 3 kompatibel.
Der Compiler generiert Code für alle Motorola 680x0 CPUs einschließlich 
der 68060 CPU, die immer mehr auf Turboboards zum Einsatz kommt. Die 
grundsätzlich überragende Kompiliergeschwindigkeit wird durch den 
Einsatz von vorkompilierten Headerdateien (precompiled Header) um 
Faktoren beschleunigt. Der integrierte Linker verarbeitet alle 
gängigen Bibliotheksformate (Standardformate, SAS/C, MaxonC++, ...)
und ist dabei einer der schnellsten auf dem Amiga.

StormC ist für alle Entwicklungsaufgaben geeignet, seien es 
Verwaltungs-, Grafik-, Musik- oder Spiel-Programme. Auch die 
Betriebssystem-Entwicklung ist für StormC kein Problem.

Die vorliegende Demo-Version von StormC soll Ihnen bei der
Entscheidung für Ihr zukünftiges Compilersystem helfen. 
Eine selbstablaufende Demoversion wäre dabei aber mehr als unsinnig. 
Schließlich wollen Sie auch eigene Projekte ausprobieren und eventuell 
testen, wie sich das System gegenüber Ihrem alten verhält. Die 
Demo-Version von StormC bietet Ihnen daher die Möglichkeit, alle
Funktionen des Compilers und der integrierten Umgebung genau unter 
die Lupe zu nehmen.

Sollten eventuell einzelne Funktionen nicht so arbeiten, wie Sie es
sich wünschen, oder haben Sie sonstige Verbesserungsvorschläge, scheuen
Sie sich bitte nicht uns anzurufen oder uns zu faxen. Wir werden jeden
Wunsch entgegen nehmen und mit unserem Programmiererteam darüber beraten.

@EndNode

@Node "ST_Philo" "StormC.guide/ST_Philo"
@Next "ST_Maschine"
@Prev "ST_Welcome"
@Toc "Main"

@{b}Philosophisches@{ub}

Eine Programmiersprache ist für den Programmierer ein Hilfsmittel, um 
auszuführende Aktionen zu spezifizieren. Sie stellt eine Menge von 
Begriffen zur Verfügung, mit denen der Programmierer die Möglichkeiten 
der Problemlösung bedenken kann. Aber nicht nur die Sprache und ihre 
sprachlichen Hilfsmittel sind für den Programmierer wichtig, auch die 
Implementation der zugehörigen Programmier-Hilfsmittel auf der 
jeweiligen Hardware-Plattform spielen eine entscheidende Rolle für den 
Erfolg.

Ein Aspekt bei der Sprachwahl erfordert daher eine Sprache, die im 
Idealfall nah an der Maschine ist, so daß mit allen wichtigen 
Aspekten der Maschine, für den Programmierer transparent und 
nachvollziehbar, handlich und effizient umgegangen werden kann. C ist 
eine Sprache, die primär unter diesem Aspekt entworfen wurde.

Der zweite Aspekt erfordert eine Sprache, die nah am Problem ist, so 
daß die Konzepte der Problemlösung direkt und schlüssig formuliert 
werden können. Die Sprachelemente, die in C++ über C hinausgehen, 
wurden in Hinblick auf diesen zweiten Aspekt entworfen.

Der dritte Aspekt betrifft die Implementation des Compilersystems 
und seiner Hilfsmittel. Die Programmierumgebung sollte dem 
Programmierer die Möglichkeit geben, sich ganz auf die Problemlösung 
zu konzentrieren. Die einfache und logisch durchdachte Handhabbarkeit 
vom StormC erfüllt diese Anforderung.

Darüberhinaus erhalten Sie durch den Einsatz von StormC die Gewißheit,
auch für zukünftige Aufgaben gerüstet zu sein. Denken Sie an die PowerPC-
Boards von Phase5 und das alternative Betriebssystem pOS von ProDAD, das
sehr nah an die Programmiermöglichkeiten von AmigaOS angelehnt ist.

Bereits heute arbeiten einige Entwickler an der Umsetzung Ihrer Software
auf den PowerPC und auf pOS. Der erste Schritt um einen prblemlosen Wechsel
zu vollziehen, ist die Anpassung der Quelltext an ein modernes Compilersystem
wie Sie es mit StormC erwerben können.

@EndNode

@Node "ST_Maschine" "StormC.guide/ST_Maschine"
@Next "ST_Install"
@Prev "ST_Philo"
@Toc "Main"

@{b}Anforderungen@{ub}

In der folgenden Liste finden Sie die Minimal-Konfiguration zum Betrieb 
von StormC:
@{b}@{i}
-       Amiga mit min. 68020 CPU und Festplattenlaufwerk
-       Kickstart/Workbench 3.0 (v39)
-       6 MB Hauptspeicher
-       10 MB Festplattenspeicher
@{ub}@{ui}
Mit dieser Zusammenstellung kann zwar entwickelt werden, aber die 
Projektgröße ist sehr begrenzt. Desweiteren können nicht alle Debugger-
Eigenschaften genutzt werden, wenn nicht wenigstens eine 68030 CPU 
mit MMU eingesetzt wird.

Am besten eignet sich die folgende Konfiguration:@{b}@{i}
-       Amiga mit mind. 68030 inkl. MMU
-       Kickstart/Workbench 3.1 (v40)
-       16 MB freier Hauptspeicher
-       40 MB freier Festplattenspeicher@{ub}@{ui}

In dieser Konfiguration werden der Compiler und auch die Shell kaum über 
zu wenig Ressourcen klagen.

@{b}Als Faustformel können Sie sich jedoch merken: VIEL HILFT VIEL!@{ub}

@EndNode

@Node "ST_Install" "StormC.guide/ST_Install"
@Next "ST_Problem"
@Prev "ST_Maschine"
@Toc "Main"

@{b}Installation@{ub}

Zur Installation auf Ihre Festplatte wird der Commodore Installer 
eingesetzt. Dieses Installationstool hat sich mittlerweile als 
Standard-Installierer durchgesetzt und sollte Ihnen in der Bedienung 
bekannt sein.
Zum besseren Verständnis finden Sie hier die Übersetzung 
der wichtigsten Tasten:

@{b}Proceed@{ub}        OK und weiter.
                Die abgefragte Aktion wird ausgeführt.
@{b}Abort Installation@{ub}     Installation beenden.
                Die Installation wird nicht fortgeführt.
@{b}Parent Drawer@{ub}  Mutterverzeichnis
                Den Inhalt des nächst höheren Verzeichnisses anzeigen.
@{b}Show Drives@{ub}    Laufwerke
                Alle Laufwerke anzeigen.
@{b}Make New Drawer@{ub}        Erzeuge neues Verzeichnis.
                Legt einen neuen Ordner im angegebenen Pfad an.
@{b}Help@{ub}   Das sollten Sie auch ohne Übersetzung wissen!
@{b}Cancel@{ub} Aktion abbrechen.

Wenn Sie die Demo-Version vom Internet geladen haben oder ein
CD-Variante installieren möchten, können Sie den folgenden Abschnitt
überlesen.

Legen Sie bitte die erste Diskette der Demo-Version in Ihr
Diskettenlaufwerk und Doppelklicken Sie auf das Disketten-Ikon.
Bevor Sie nun mit der Installation beginnen, sollten Sie sich die 
Datei "Liesmich" auf der Diskette durchlesen. Hierin sind wichtige 
Neuerungen und Tips beschrieben, die leider nicht mehr mit 
ins Handbuch übernommen werden konnten.

Doppelklicken Sie jetzt auf das Ikon "Install StormC-HD". Bitte 
haben Sie einen Augenblick Geduld, bis das Installationsprogramm 
und das -Script geladen sind.

Bitte folgen Sie den Anweisungen des Installationsprogrammes. 
Sollten Sie einmal nicht weiter wissen, klicken Sie einfach auf 
den "Help"-Knopf und lesen Sie nach, was zu tun ist.

Nach erfolgreicher Installation erhalten Sie eine entsprechende 
Meldung vom Installationsprogramm. 

Sollte die Installation nicht positiv verlaufen sein, wiederholen 
Sie bitte den Vorgang mit eingeschalteter "Log-Datei"-Generierung. 
Die Option @{i}"Log all actions to: Log File"@{ui} kann in dem 
Optionen-Fenster eingestellt werden, das nach dem Begrüßungs-Fenster 
angezeigt wird. Nach der erfolglosen Installation können Sie dann im 
Installationsprotokoll nachlesen, was nicht funktioniert hat. 

Beheben Sie bitte das Problem und installieren Sie erneut.

@EndNode

@Node "ST_Problem" "StormC.guide/ST_Problem"
@Next "ST_Tutorial"
@Prev "ST_Install"
@Toc "Main"

@{b}Was tun bei "unlösbaren" Problemen@{ub}

Sollten Sie nicht nur bei der Installation Schwierigkeiten mit der 
Software haben, scheuen Sie sich bitte nicht, uns anzurufen. Wir sind 
gerne bereit, Ihnen zu helfen und gemeinsam mit Ihnen die Probleme 
aus der Welt zu schaffen.

@{i}Hier können Sie uns erreichen:@{ui}

Werktags zwischen 9:00 und 18:00 Uhr unter:

Telefon:        06007/930051
Fax:            06007/7543
Per E-Mail:
Compuserve:     100654,3133
Internet:       100654.3133@compuserve.com


@EndNode

@Node "ST_Tutorial" "StormC.guide/ST_Tutorial"
@Next "ST_Start"
@Prev "ST_Problem"
@Toc "Main"

@{b}Tutorial@{ub}

Im Tutorialteil des Handbuchs erfahren Sie alles über den Umgang mit 
dem Programm. Anhand eindrucksvoller Beispiel wird Ihnen die Funktions-
weise des Compilersystems beigebracht. Sie lernen den Umgang mit der 
Projektverwaltung, wie man Quelltexte erfaßt und schließlich, wie man 
den Compiler startet. Ein weiteres Beispiel beschreibt den Umgang
mit dem Debugger. Ein kleines Demoprogramm wird erstellt und Schritt 
für Schritt im Debugger abgearbeitet.

Sie erhalten durch das Tutorial einen umfassenden Eindruck des 
Compilersystems und werden, nach dem Sie es durchgearbeitet haben, 
nie mehr mit einem anderen Compilersystem arbeiten wollen.

@EndNode

@Node "ST_Start" "StormC.guide/ST_Start"
@Next "ST_Project"
@Prev "ST_Tutorial"
@Toc "Main"

@{b}Programmstart@{ub}

Im ersten Beispiel lernen Sie, wie Sie ein neues Projekt erstellen, den 
Programm-Quelltext erfassen und das Programm kompilieren und starten.

Starten Sie bitte StormC durch Doppelklick auf das Programm-Piktogramm. 

Das Programm finden Sie in der Schublade, in das Sie das Compilersystem 
installiert haben.

Während des Starts sehen Sie eine Willkommensmeldung, die solange auf dem 
Bildschirm zu sehen ist, bis alle Programmkomponenten geladen sind.

Nach dem Laden aller Komponenten wird am oberen Bildschirmrand eine 
Piktogrammleiste angezeigt, die die wichtigsten Funktionen der 
integrierten Oberfläche zum schnellen Anklicken bereithält.

@{i}Die Piktogrammleiste stellt folgende Funktionen bereit:@{ui}
@{b}
        Neuer Text
        Text laden
        Text speichern
        
        Neues Projekt
        Projekt laden
        Projekt speichern
        
        Compiler starten (Make)
        Programm ausführen (Make and Run)
        Debugger starten (Make, Run and Debug)
@{ub}

Wir beginnen selbstverständlich mit dem typischen Beispiel beim ersten 
Kontakt mit einem neuen Programmiersystem: "HELLO WORLD".

@{" Hello World Source-Code " Link "ST_Source"}

@EndNode

@Node "ST_Project" "StormC.guide/ST_Project"
@Next "ST_Make"
@Prev "ST_Start"
@Toc "Main"

@{b}Erzeugen eines neuen Projektes@{ub}

Klicken Sie bitte in der Piktogrammleiste auf das Ikon 
@{i}"Neues Projekt"@{ui}. Ein neues Projektfenster wird angezeigt.

@{b}Was ist ein Projekt?@{ub}

In einem Projekt wird alles zusammengefaßt und verwaltet, was zu 
Ihrem Programm dazugehört: C-, C++-, und Assembler-Quelltexte, 
Headertexte, Objekt-Dateien, Linker-Bibliotheken, Dokumentationen, 
Grafiken, Bilder und sonstigen Ressourcen. Durch die Trennung in ver-
schiedene Sektionen bleibt die Dateien-Sammlung übersichtlich. Die 
Projektverwaltung ist aber auch ein grafisch orientiertes Make.

@EndNode

@Node "ST_Make" "StormC.guide/ST_Make"
@Next "ST_Source"
@Prev "ST_Project"
@Toc "Main"

@{b}Make und Modulabhängigkeiten@{ub}

Bei jedem Compilerlauf werden die Abhängigkeiten zwischen ".o"-, ".h"-, 
".ass"-, ".asm"-, ".i"- und ".c"-Dateien (selbstverständlich auch ".cc" 
oder ".cpp") ermittelt und der Projektverwaltung mitgeteilt. So weiß die 
Projektverwaltung ganz von alleine, daß ein C-Quelltext neu kompiliert 
werden muß, wenn eine ".h"-Header-Datei verändert wurde, die im ".c"-Quelltext 
"includet" wird.
Bei Klick auf die Piktogramme "Make" oder "Run" werden zuerst alle 
Abhängigkeiten geprüft und dann von Make entschieden, welche Programmodule 
neu kompiliert werden müssen und welche aktuell sind. "Run" unterscheidet 
sich gegenüber "Make" lediglich dadurch, daß bei erfolgreicher 
Kompilation das Programm automatisch gestartet wird.

@{b}Projekt speichern und neues Verzeichnis anlegen@{ub}

Als nächsten Schritt speichern Sie bitte das Projekt und legen dabei 
gleichzeitig ein neues Datei-Verzeichnis an.

Klicken Sie bitte auf das @{i}"Projekt speichern"@{ui}-Piktogramm. 
Wählen Sie bitte in der angezeigten ASL-Standard-Dateiauswahl das 
"StormC:" Verzeichnis aus und geben den Datei-Pfad und -Namen 
"Hello World/Hello World" in das Dateinamen-Eingabefeld ein. 

Die Endung ".¶" wird automatisch angehängt und symbolisiert Ihnen, 
daß es sich bei der jeweiligen Datei um ein StormC-Projekt handelt.

Sie werden sich sicher wundern, warum das leere Projekt gespeichert 
werden soll; auch wenn das Projekt noch keinen Inhalt hat, ist es 
sinnvoll bereits zu Beginn einen eindeutigen Projektpfad anzugeben. 
Die Dateinamen der Quelltexte und andere Ressourcen können dann 
relativ zum Projektpfad im Projekt aufgenommen und gespeichert werden. 
Andernfalls würde der absolute Pfad verwendet. Ein weiterer Vorteil 
ist, daß beim Hinzufügen von Projektdateien bereits der entsprechende 
Pfad im ASL-Dialog eingetragen ist. Sie sparen sich dadurch die 
Pfadsuche.

@EndNode

@Node "ST_Source" "StormC.guide/ST_Source"
@Next "ST_Compile"
@Prev "ST_Make"
@Toc "Main"

@{b}Quelltext erfassen@{ub}

Jetzt kommen wir zu der eigentlichen Programmierung. Öffnen Sie jetzt 
ein neues Quelltext-Fenster mit Klick auf das Piktogramm 
"Neuer Quelltext".

Bevor Sie nun anfangen Text einzugeben machen Sie sich bitte kurz mit 
den Bedienelementen des Editors vertraut.

Tippen Sie jetzt bitte folgende Programmzeilen ein:

@{b}
/* Hello World
   Demo-Programm zum Preview-Tutorial */

#include <stdio.h>

void main( void)
{

printf("Hello World\n");
}@{ub}

Speichern Sie jetzt bitte das eingegebe Programm unter dem Namen 
"Hello World.c" im Verzeichnis "Hello World".

Rufen Sie dann den Menüpunkt @{i}"Projekt/Fenster hinzufügen"@{ui} auf. 
Der Dateiname erscheint nun in der Quelltext-Sektion des Projektfensters. 
Anhand der Dateiendung entscheidet die Projektverwaltung, in welche 
Sektion die Datei abgelegt wird.

Bevor Sie nun den Compiler starten, sollten Sie noch einen Dateinamen 
für das Programm angeben. Andernfalls erzeugt der Linker automatisch 
den Dateinamen "A.Out".

Wählen Sie dazu aus dem Menü @{i}"Projekt"@{ui} den Eintrag 
@{i}"Programmname wählen"@{ui} aus. Achten Sie bitte darauf, daß das 
Projektfenster das aktive Fenster ist.

@EndNode

@Node "ST_Compile" "StormC.guide/ST_Compile"
@Next "ST_PRGStart"
@Prev "ST_Source"
@Toc "Main"

@{b}Quelltext kompilieren@{ub}

Mit Klick auf das Projekt-Piktogramm "Make" wird das Compiler-
Fehlerfenster geöffnet und der Quelltext vom Compiler übersetzt. 
Während der Übersetzung werden vom Compiler Statusmeldungen im 
Fehlerfenster ausgegeben.

Wird vom Compiler ein Fehler entdeckt, erfolgt die Ausgabe des ent-
sprechenden Fehlers in der Anzeige darunter. Sie erhalten hier eine 
sehr detaillierte Fehlerbeschreibung und die Angabe der Zeilennummer 
und des jeweiligen Quellsources.

Im obigen Beispiel wurde absichtlich ein Fehler in der Zeile 8 
eingefügt. Aus dem Funktionsnamen printf wurde das letzte Zeichen 
gelöscht. Zwar läßt sich bereits beim Löschen des Zeichens erkennen, 
daß ein Fehler vorliegen muß, da die farbliche Kennzeichnung weggenommen 
wird aber für die Demonstration des Fehlerfalles soll das Programm so 
kompiliert werden.

Sobald der Compiler auf den Fehler trifft, wird eine entsprechende 
Fehlermeldung im Fenster ausgegeben.

Selbstverständlich genügt ein Doppelklick auf den jeweiligen Fehler und 
die Projektverwaltung lädt den Quelltext und zeigt die Fehlerstelle im 
Editor-Fenster an. Sie können dann die Korrektur vornehmen und den 
Compilerlauf erneut starten.

@EndNode

@Node "ST_PRGStart" "StormC.guide/ST_Start"
@Prev "ST_Compile"
@Next "ST_Debug"
@Toc "Main"

@{b}Übersetztes Programm starten@{ub}

Bei erfolgreichem Compilieren und Linken wird der während des 
Compilierens nicht zugängliche Knopf "Starten" zugänglich und 
anklickbar. Mit Klick auf diesen Knopf oder auf das Projekt-Piktogramm 
"Run" wird das Programm gestartet.

Wird statt des "Make"- das "Run"-Piktogramm angeklickt, prüft die 
Projektverwaltung zuerst, ob bereits alle Module kompiliert sind. Ist 
dies nicht der Fall, wird automatisch der Compiler für alle noch nicht 
übersetzten Projektmodule gestartet. Nach der erfolgreichen Übersetzung, 
wird dann das Programm automatisch gestartet.

@{b}Die RunShell@{ub}

Einen Programmstart aus der Projektverwaltung ist ein sehr komplexer 
Vorgang, auf den ich hier näher eingehen möchte.

Wie Sie sicher bemerken, wird beim Starten ein weiteres Fenster 
geöffnet, die sogenannte "RunShell".

Selbstverständlich ist es auch möglich, das Programm einfach so zu 
starten, aber in einer Entwicklungsumgebung wünscht man sich ja, daß 
das Programm auch nach dem Starten noch beeinflußt und debuggt werden 
kann. So ist es z. B. möglich, auch noch nach dem Starten des Programmes 
den Debugger aufzurufen, um das Programm genauer unter die Lupe zu 
nehmen. Auch wenn ein Programmfehler auftritt, der eine CPU-Exception 
auslöst, wird dieser abgefangen und in den meisten Fällen die Möglichkeit 
geboten, die exakte Fehlerstelle im Quellcode zu begutachten.

Eine weitere wichtige Eigenschaft ist das sogenannte "Resourcen 
Tracking", das von der RunShell vorgenommen wird. Hierbei werden 
die Systemfunktionen dokumentiert, die mit dem "Resourcen-Handling" 
zu tun haben (AllocMem, OpenWindow, Open,...). Beim Beenden des 
Programmes kann so genau festgestellt werden, welche Ressource nicht 
oder welche zuviel freigegeben wurde. Selbstverständlich wird auch 
hierbei direkt die Quelltextstelle angezeigt und der Fehler kann gleich 
geändert werden.

Desweiteren bietet die RunShell die Möglichkeit, die Signale  Ctrl-C, 
Ctrl-D, Ctrl-E, Ctrl-F", die normalerweise nur per Shell (CLI), dem 
von eben dieser aus gestarteten Programm übermittelt werden können,
weiterzuleiten.
Auch die Priorität, mit der das System das Programm bearbeiten soll, 
kann in Schritten zwischen -128 bis +127 eingestellt werden.

Der Knopf "Pause" hält das Programm in dem gerade aktiven Zustand an. 
"Pause" ist ein Toggle-Knopf, das heißt er wechselt bei jedem Klicken 
den Zustand. Ein Klick aktiviert den Knopf und das Programm wird 
angehalten. Ein weitere Klick und das Programm läuft wieder weiter. 
Der Knopf wird dann wieder inaktiv angezeigt.

Mit Klick auf den Knopf "Kill" wird das Programm gleich beendet.
Alle aufgezeichneten Ressourcen werden zuvor freigegeben ( Speicher 
und Signale werden freigegeben, Screens, Fenster, Requester und 
Dateien geschlossen). Auf diese Art und Weise sind Programmleichen 
ausgeschlossen. Durch versehentlich programmierte Endlos-Schleifen 
entstehen leicht solche Programmleichen. Die Methode ist wesentlich 
zeitsparender und damit effizienter als den Amiga neu zu starten.

In unserem Beispiel wird das Programm allerdings so schnell 
abgearbeitet, so daß das Fenster der RunShell nur sehr kurze Zeit auf 
dem Bildschirm zu sehen ist. Im nächsten Beispiel werden Sie länger 
mit der RunShell konfrontiert, da Sie hierbei mit dem Debugger arbeiten 
werden.

Bei dem Ausgabefenster, das immer noch den Inhalt "Hello World" anzeigt, 
handelt es sich um ein normales Console-Fenster, das auch nach dem 
Programmende noch geöffnet bleibt. Console-Fenster werden automatisch 
geöffnet, wenn vom Programm Ausgaben auf die Standard-Ausgabe wie z. B. 
mit der Funktion printf gemacht werden. Klicken Sie einfach auf das 
Schließfeld des Fensters und es wird geschlossen.

@EndNode

@Node "ST_Debug" "StormC.guide/ST_Debug"
@Prev "ST_PRGStart"
@Next "ST_Sektion"
@Toc "Main"

@{b}Debugger@{ub}

Ein Debugger wird zur schnellen Fehlersuche benötigt. Er bietet die 
Möglichkeit, geziehlt Unterbrechungspunkte in Ihren Programmen zu 
definieren und an diesen  Breakpoints" Veränderungen von Variablen, 
Strukturen und Klassen zu beobachten. Auf diese Weise lassen sich Fehler 
einkreisen und können schnell behoben werden.

Um Ihnen das Arbeiten mit dem Debugger zu demonstrieren, laden wir ein 
bereits vorgefertigtes Projekt und kompilieren es.

Im Verzeichnis Beispiele finden Sie den Ordner Colorwheel. Bitte öffnen 
Sie den Ordner auf der Workbench. Das Bild auf Ihrem Monitor sollte so 
aussehen, wie in der unteren Abbildung dargestellt.

Doppelklicken Sie auf das Projekt-Ikon im Workbench-Fenster. Das Projekt
wird geladen und angezeigt. Wählen Sie bitte in "Menü-Einstellungen" den 
Eintrag "Projekt" aus. Wechseln Sie dann mit dem Cycle-Menü oben links 
zu den Einstellungen für die C/C++ Optionen.

Wie Sie erkennen können, ist bereits voreingestellt, daß für alle Module
große Debugger-Dateien (inkl. aller Include-Dateien) gespeichert werden 
sollen.

Starten Sie nun den Compiler mit Klick auf das Debugger-Piktogramm. 
Genau wie beim Klick auf das Run-Piktogramm, wird auch hierbei zuerst 
geprüft, ob für alle oder für einzelne Module bereits Debugger-Dateien 
erstellt wurden, und eventuell neu kompiliert werden müssen. Nach dem 
Linken wird das Programm direkt im Debug-Modus gestartet.

Je nach Voreinstellung wird das Modul-, Aktive-Variablen- und 
Überwachte-Variablen-Fenster geöffnet. 

Desweiteren wird der Quelltext des Moduls, das die main-Funktion 
enthält, geöffnet und der Quelltext ab der main-Funktion angezeigt.

Sie erkennen, daß die Quelltextanzeige leicht verändert dargestellt 
wird. Die erste Textspalte verschiebt sich dabei nach rechts, so daß 
eine weitere Spalte für die Unterbrechungspunkte angezeigt werden kann. 
Jeder Unterbrechungspunkt in der Spalte steht vor einer Quelltextzeile, 
an der das Programm angehalten werden kann. Wenn Sie mit der Maus auf 
einen dieser Punkte klicken, wird dieser mit einem diagonalen Kreuz 
markiert und ist damit ein aktiver Unterbrechungspunkt.

Bitte setzen Sie einen Unterbrechungspunkt direkt nach dem 
OpenScreen-Aufruf.

Sollte das Fenster der aktuellen Variablen nicht geöffnet sein, öffnen 
Sie es bitte durch Auswählen der Menüleiste @{i}"Fenster/Aktuelle Variablen"@{ui}.

Klicken Sie nun in der RunShell auf das Piktogramm "Gehe bis zum 
nächsten Breakpoint".

Da Sie den Unterbrechungspunkt unmittelbar nach dem Funktionsaufruf 
OpenScreen gesetzt haben, wird das Programm bis dorthin ausgeführt und 
ein neutraler Screen geöffnet. Die Programmausführung ist nun wieder 
gestoppt.

Mit dem Ausführen der nächsten Funktion GetRGB32 wird ein Array von 
unsigned long-Typen mit Daten versorgt, was wir uns etwas genauer 
ansehen wollen.

Dazu ist es zunächst notwendig, daß Sie die Array-Variable @{b}colortable @{ub}
in ein Inspektorfenster stellen. 

Wählen Sie einfach im Fenster der aktuellen Variablen die Variable 
colortable mit der Maus an und doppelklicken Sie auf den Eintrag.

Als nächstes führen Sie drei Einzelschritte aus und beobachten 
dabei genau, wie sich der Inhalt des Inspektorfensters verändert. 
Klicken Sie dazu zweimal auf das Symbol "Einen Schritt gehen" in der 
RunShell. Die Funktion GetRGB32 lädt die in der Screen View-Struktur 
vorgegebenen Werte in das Array colortable.

Anhand des Beispiels sehen Sie, wie einfach es ist, Variableninhalte 
mit dem Inspektorfenster anzeigen zu lassen.

Setzen Sie nun weitere Unterbrechungspunkte und spielen Sie etwas mit 
den Debugger-Funktion, um damit vertraut zu werden. Sie werden sehr 
schnell feststellen, wie einfach das System zu bedienen ist.

Um den Debugger zu beenden, genügt es, das im Debugger-Modus gestartete 
Programm zu beenden.

Es werden automatisch alle Debugger-Fenster geschlossen und die RunShell
beendet.

@EndNode

@Node "ST_Sektion" "StormC.guide/ST_Sektion"
@Next "ST_Owns"
@Prev "ST_Debug"
@Toc "Main"

@{b}Projektsektionen@{ub}

Die einzelnen Sektionen eines Projektes werden automatisch durch die 
Dateiendungen und bei Dokumenten zusätzlich durch die Dateinamen erzeugt. 
Wird eine ".c"-Datei zu einem neuen Projekt hinzugefügt, entsteht eine 
neue Sektion Quelltexte mit der entsprechenden Datei. 
Beim weiteren Hinzufügen von Quelltexten wird die Sektion lediglich 
erweitert.

Folgende Sektionen können zur Zeit erzeugt werden:
@{b}Quelltexte@{ub}
        ".c"
        ".cc"
        ".ccp"
        ".c++"
        ".cpp"                                                  °
        

@{b}Headertexte@{ub}
        ".h"
        ".hh"
        ".hhp"
        ".h++"
        ".hpp"

@{b}ASM Quelltexte@{ub}
        ".asm"
        ".ass"
        ".s"

@{b}ASM Headertexte@{ub}
        ".i"

@{b}Dokumentation@{ub}
        ".dok"
        ".doc"
        ".txt"
        ".readme"
        "lies mich"
        "liesmich"
        "readme"
        "read me"
        "read.me"
        "lies.mich"

@{b}ARexx@{ub}
        ".rexx"

@{b}Andere@{ub}
        "*"

@{b}Projekte@{ub}
        ".¶"

@{b}Amiga Guide@{ub}
        ".guide"

@{b}Lokale Dateien@{ub}
        ".ct"

@{b}Programm@{ub}

@EndNode

@Node "ST_Owns" "StormC.guide/ST_Owns"
@Next "ST_Referenz"
@Prev "ST_Sektion"
@Toc "Main"

@{b}Eigenheiten des Compilersystems@{ub}

Trotz der ANSI-Spezifikationen hat jedes Compilersystem so seine 
Eigenheiten. Eingeleitet werden diese Compilerspezifischen Dinge 
mit einem #pragma.

#pragma-Zeilen werden, genau wie #include, vom Preprozessor 
interpretiert und ausgeführt. Mit einem #pragma realisiert man dabei 
compilerspezifische Funktionen, die ausdrücklich nicht standardisiert 
sind.

@{b}Compilermodus@{ub}

#pragma - ist ein nicht standardisiertes Feature und schaltet in StormC 
den Compiler um auf den ANSI-C Modus.

#pragma + bewirkt das der Compiler den Quelltext im C++-Modus übersetzt.

@{b}Daten in Chip- und Fast-Ram@{ub}

Die Architektur des Amiga ist etwas unkonventionell. So gibt zwei, 
manchmal auch mehr verschiedene Klassen von RAM.

In der Praxis interessiert den Programmierer aber nur die Frage 
"Chip- oder Fast-RAM", denn Sie müssen dafür sorgen, daß Grafikdaten 
im Chip-Memory abgelegt werden. In StormC gibt es dafür die Pragmas 
"chip" und "fast".

Alle nach der Zeile

#pragma chip

deklarierten statischen Daten werden ins Chip-RAM geladen,

#pragma fast

schaltet wieder in den normalen Modus, in dem die Daten irgendwo 
abgelegt werden, bevorzugt aber im Fast-RAM.

@{b}Betriebssystemaufrufe@{ub}

Die Amiga Betriebssystem-Funktionen werden mit einem #pragma amicall 
aufgerufen.

Eine solche Deklaration besteht im Wesentlichen aus vier Teilen:
@{b}    -       Dem Namen der Basisvariablen.
        -       Dem Offset als positive Ganzzahl.
        -       Dem Funktionsnamen, der bereits deklariert sein muß. Aus Gründen 
                der Eindeutigkeit darf dieser Funktionsname nicht überladen 
                ein.
        -       Der Parameterliste, vertreten durch eine entsprechende Anzahl von 
                Registernamen in runden Klammern.@{ub}

Ein Beispiel:

#pragma amicall(Sysbase, 0x11a, AddTask(a1,a2,a3))
#pragma amicall(Sysbase, 0x120, RemTask(a1))
#pragma amicall(Sysbase, 0x126, FindTask(a1))

Solche Deklarationen werden Sie normalerweise nie selbst schreiben 
müssen, da alles mit den Amiga-Libraries mitgeliefert wird.

@{b}Zeilen verbinden@{ub}

In C wie in C++ ist es absolut egal wo einzelne Zeilen enden. Beim 
Preprozessor dagegen ist es sehrwohl relevant, denn hier muß jede 
Anweisung genau eine Zeile umfassen. Natürlich kann es dazu kommen, daß 
eine Zeile, z.B. durch eine umfangreiche Makrodefinition, sehr lang und 
unhandlich wird. Für diesen Fall gibt es den Backslash 
(Gegenschrägstrich). Wenn ein "\" am Zeilenende steht, wird dies Zeile 
mit der nachfolgenden verbunden, z.B. so:

#define IRGENDWAS \
47081115

Dies ist eine gültige Makrodefinition, denn "47081115" wird hier in die 
vorhergehende Zeile gezogen.

@{b}Vordefinierte Symbole@{ub}

Der Preprozessor besitzt viele vordefinierte Makros. Dabei handelt es 
sich zum Teil um ANSI C genormte, andere sind Bestandteil von C++ oder 
spezielle Eigenheiten von StormC. Diese Makros können nicht umdefiniert 
werden.

@{b}__COMPMODE__@{ub}

ist in StormC definiert mit der "int"-Konstante 0 im C-Modus und unter 
C++ mit 1.

@{b}__cplusplus@{ub}

In StormC ist das Makro "__STDC__" sowohl im C- als auch im C++-Modus 
definiert. Will manin StormC nun explizit abprüfen, ob im C++-Modus 
kompiliert wird, muß dies mit dem Makro "__cplusplus" gemacht werden.

@{b}__DATE__@{ub}

Das Makro __DATE__ liefert das Datum der Übersetzung. Dies ist sehr 
nützlich, wenn man ein Programm mit einer eindeutigen Versionsnummer 
versehen will:

#include <stream.h>
void main()
{ cout « "Version 1.1 vom " __DATE__", "__TIME__" Uhr\n; }

Das Datum wird dabei in der Form  Monat Tag Jahr", z.B. "Feb 08 1996", 
geliefert, während die Uhrzeit ganz normal in der Form 
"Stunde:Minute:Sekunde" vorliegt.

@{b}__FILE__@{ub}

Dieses Makro enthält den Namen der aktuellen Quelltextdatei in Form eines 
Strings, z.B. so:

#include <stream.h>

void main()
{ cout « "Das steht in Zeile " « __LINE__ « " in der Datei " __FILE__ ".\n";}

Der Wert des Makros __FILE__ ist eine konstante Zeichenkette und kann 
als solche natürlich auch mit davor oder dahinter stehenden 
Zeichenketten verbunden werden.

@{b}__LINE__@{ub}

Das Makro __LINE__ liefert die Zeilennummer, in der es benutzt wird, 
als dezimale "int"-Konstante.

@{b}__STDC__@{ub}

Dieses Makro liefert in alles zu ANSI C kompatiblen Implementationen 
den numerischen Wert 1  und soll ermöglichen, festzustellen, ob ein 
Compiler diesem Standard genügt, denn anderenfalls ist "__STDC__" nicht 
definiert.

@{b}__STORMC__@{ub}

Oft möchte man gerne testen, um welchen Compiler und um welche Compiler-
version es sich handelt. Deshalb definiert StormC zusätzlich ein Makro 
mit dem Namen __STORMC__.

@{b}__TIME__@{ub}

(siehe __DATE__)

@EndNode

@Node "ST_Referenz" "StormC.guide/ST_Referenz"
@Next "ST_Neues1"
@Prev "ST_Owns"
@Toc "Main"

@{b}Menübefehle@{ub}

@{u}Projekt@{uu}

@{i}Neu         A-N@{ui}
Bei aktivem Piktogramm- oder Projektfenster wird ein neues Projekt 
geöffnet und entspricht damit einem Klick auf das Piktogramm 
"Neues Projekt".

Wenn ein Editorfenster bei der Auswahl des Menüpunktes aktiv ist, 
wird ein neues Editfenster geöffnet. Das entspricht einem Klick auf 
das Piktogramm  Neuer Text".

@{i}Öffnen...   A-O@{ui}
Signalisiert durch die drei Punkte am Ende des Menüeintrags "Öffnen..." 
erscheint ein weiterer Dialog, der auf Anwenderreaktionen wartet, 
bevor die Aktion ausgeführt wird. Im Fall von "Öffnen..." wird der 
Standard-Dateiauswahldialog (ASL-Library) zum Einlesen von Dateien 
angezeigt. Die Bedienung der Dialogbox sollte Ihnen bekannt sein, 
da sie in sehr vielen Programmen vorkommt.

Je nach dem, ob das Piktogramm-/Projektfenster oder ein Editorfenster 
aktiv ist, kann entweder ein Projekt oder ein Text geladen werden. 
Die Piktogrammleiste bietet ebenfalls zwei Piktogramme zum Laden von 
Quelltexten und Projekten.

@{i}Sichern     A-S@{ui}
Bei aktivem Projektfenster wird das Projekt gespeichert und entspricht 
damit einem Klick auf das Piktogramm  Projekt speichern".

Wenn ein Editorfenster bei der Auswahl des Menüpunktes aktiv ist, wird 
der Text gespeichert. Das entspricht einem Klick auf das Piktogramm 
"Text speichern".

@{i}Sichern als...@{ui}
Genauso wie bei der Auswahl von "Öffnen..." wird auch bei 
"Speichern als..." der Dateiauswahldialog angezeigt.

Sie haben die Möglichkeit, einen Dateinamen für Ihr Projekt oder 
Ihren Text anzugeben. Die Auswahl per Mausklick in die angezeigte 
Dateiliste ist ebenfalls möglich.

Je nachdem, ob das Projektfenster oder ein Editorfenster aktiv ist, 
kann entweder das Projekt oder der Text gespeichert werden. Die 
Piktogrammleiste bietet ebenfalls zwei Piktogramme zum Speichern von 
Quelltexten und Projekten.

@{i}Sichern als Projektvorlage@{ui}
Dieser Menüpunkt ist nur bei aktivem Projektfenster anwählbar. Die 
Projektvorlage ist die Datei, die geladen wird, wenn Sie ein neues 
Projekt entweder über das Menü  Projekt/Neu" oder über das Piktogramm 
"Neues Projekt" anlegen. Sie haben damit die Möglichkeit, eigene 
Einstellungen vorzugeben, die dann bei jedem Ihrer nächsten Projekte 
verwendet werden.

Gespeichert werden alle Einstellungen, die Sie zum Projekt machen 
können (C/C++ Umgebung, C/C++ Preprozessor, C/C++ Optionen, C/C++ 
Warnungen, Linker Optionen und Programmstart) und selbstverständlich 
auch alle, in dem zum Speichern vorbereiteten Projekt enthaltene 
Sektionen.

@{i}Alles sichern@{ui}
Mit Klick auf den Menüpunkt  Alles sichern" werden alle angezeigten und 
noch nicht gesicherten Quelltexte und Projekte gespeichert. Sind für 
Quelltexte oder Projekte noch keine Dateinamen angegeben, wird für jeden 
fehlenden Dateinamen die Dateiauswahl geöffnet.

@{i}Drucken@{ui}
Druckt den Inhalt des aktiven Editor-Fensters auf dem am Printer.Device
angeschlossenen Drucker aus. Ist kein Editor-Fenster geöffnet, statt dessen
aber ein Projektfenster, werden die Angaben zum Projekt auf dem Drucker
ausgegeben.

@{i}Datei(en) hinzufügen...@{ui}
Dieser Menüpunkt ist nur anwählbar, wenn ein Projektfenster aktiviert 
ist. Aus der angezeigten Dateiauswahl kann eine Datei ausgewählt werden, 
die dann in das Projekt aufgenommen wird. Je nach Dateiendung werden 
verschiedene Sektionen im Projekt erzeugt und die Datei an die 
entsprechende Stelle im Projekt plaziert. Hierbei wird auch eine Mehrfach-
auswahl unterstützt.

@{i}Fenster hinzufügen@{ui}
Bei aktiviertem Editorfenster und angelegtem Projekt wird dieser 
Menüpunkt zugänglich. Mit Klick auf  Fenster hinzufügen" wird die Datei 
im aktiven Editorfenster in die entsprechende Projektsektion aufgenommen. 
Man spart sich dadurch den Umweg über die Dateiauswahl, die erscheint, 
wenn "Datei hinzufügen" gewählt wird.

@{i}Bibliothek(en) hinzufügen@{ui}
Dieser Menüpunkt ist nur anwählbar, wenn ein Projektfenster aktiviert 
ist. Die angezeigte Dateiauswahl zeigt den Pfad für die Linkerbibliotheken,
Es können hierrüber gezielt Dateien mit der Endung ".lib" in das Projekt
aufgenommen werden. Hierbei wird auch eine Mehrfachauswahl unterstützt.
Achten Sie bitte darauf, daß bei einer Mehrfachauswahl die Bibliotheken in
alphabetischer Reihenfolge in das Projekt aufgenommen werden, was unter
Umständen zu Linkerfehlern führen kann, da die Dateireihenfolge auch auch
für den Linker relevant sind.

@{i}Programmname wählen...@{ui}
Selbstverständlich benötigt jedes, aus mehreren Modulen erzeugte Programm 
einen Namen. Da der Programmname nicht anhand der Dateiendung ermittelt 
und somit automatisch in die richtige Sektion eingetragen werden kann, 
muß man ihn manuell angeben. Dazu wählen Sie einfach den Menüeintrag 
"Programmname wählen..." und geben in der angezeigten Dateiauswahl den 
entsprechenden Dateinamen an. Sie haben damit auch die Möglichkeit, das 
aus den Modulen erzeugte Programm an einer anderen Stelle auf Ihrer Fest-
platte speichern zu lassen, als im Projektverzeichnis.

@{i}Schließen   A-K@{ui}
Je nachdem, ob ein Projekt- oder Editorfenster aktiv ist, wird entweder 
das Projekt oder der Text geschlossen. War das Projekt oder der Text 
zuvor noch gespeichert, erscheint eine Sicherheitsabfrage und bietet 
Ihnen die Möglichkeit, dieses noch zu tun.

Das gleiche kann mit Klick auf das Schließfeld des jeweiligen Fensters 
erreicht werden.

@{i}Über@{ui}
In dem angezeigten Dialog finden Sie Informationen zum Produkt-Copyright, 
unsere aktuelle Telefon-, Faxnummer und eine E-Mail-Adresse.

@{i}Beenden     A-Q@{ui}
Ein Klick auf diesen Menüpunkt beendet das Entwicklungssystem. Sind 
noch Quelltexte oder Projekte angezeigt, die noch gespeichert werden 
müssen, erhalten Sie einen entsprechenden Hinweis und die Möglichkeit, 
dies zu erledigen.

@{b}Bearbeiten@{ub}

@{i}Markieren   A-B@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormED) wählbar
und schaltet den Editor-Markierungsmodus an oder ab.

@{i}Ausschneiden        A-X@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormED) wählbar.
Der markierte Textbereich wird dabei in die Zwischenablage kopiert und
aus dem aktiven Text gelöscht. Die Markierung wird ebenfalls aufgehoben.

@{i}Kopieren    A-C@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormEd) wählbar.
Anders als beim Ausschneiden wird mit Kopieren der markierte Textbereich
lediglich in die Zwischenablage kopiert aber nicht aus dem aktiven Text
gelöscht.

@{i}Einfügen    A-V@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormEd) wählbar.
Dabei wird der in der Zwischenablage befindliche Text ab der Stelle
des Textcursors in den aktiven Text eingefügt.

@{i}Löschen@{ui}
Bei aktivem Editorfenster (StormED) wird der markierte Textbereich aus
dem Text entfernt. Der gelöschte Text wird nicht in die Zwischenablage
kopiert. Das Textlöschen kann jedoch mit  "Undo" rückgängig gemacht werden.

Bei aktivem Projektfenster wird das in einer Sektion markierte Modul aus 
dem Projekt entfernt. Ein  Undo" ist hierbei nicht möglich.

@{i}Undo        A-Z@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormED) wählbar.
Mit "Undo" wird die zuletzt ausgeführte Editorfunktion zurückgenommen.

@{i}Redo        A-R@{ui}
Der Menüpunkt ist nur bei aktiviertem Editorfenster (StormED) wählbar.
Mit "Redo" wird das zuletzt ausgeführte "Undo" zurückgenommen.

@{i}Finden & Ersetzen...                A-F@{ui}
Finden & ersetzen ist selbstverständlich nur bei aktivem Editor-Fenster 
(StormED) wählbar. Wie die drei Punkte nach dem Menüeintrag symbolisieren,
wird hierbei ein Dialog angezeigt, in dem der Suchbegriff und das Wort,
durch das ersetzt werden soll, eingegeben werden können.

Die Funktion kann natürlich auch nur zum Suchen verwendet werden. 
Lassen Sie hierzu einfach den Ersetzen-Begriff frei und klicken auf 
das Symbol "Finden".

Zusätzlich kann die Suchrichtung ab der Cursorposition angegeben werden. 
Es besteht aber auch die Möglichkeit immer den kompletten Text 
durchsuchen zu lassen, egal an welcher Stelle gerade der Textcursor 
positioniert ist.

Mit der Auswahl einer Spezifiktaion aus dem Cycle-Menü darunter lassen 
sich die Suchparameter exakter definieren.

Mit den rechts daneben angebrachten Symbolen zum Abhaken, kann 
eingestellt werden, daß die Groß-/Kleinschreibung und eventuell 
enthaltene Akzente nicht beachtet werden sollen.

Mit den drei Symbolen am unteren Rand des Dialogs führen Sie die 
gemachten Anweisungen auf verschiedene Weise aus.

@{u}"Finden"@{uu} sucht lediglich den im Finde-Textsymbol eingegebenen Begriff.
@{u}"Ersetzen"@{uu} ersetzt den Finde-Begriff durch den Ersetze-Begriff einmalig.
@{u}"Alle ersetzen"@{uu} ersetzt alle gefunden Finde-Begriffe durch den Ersetze-Begriff.

@{i}Finde nächstes      A- "."@{ui}
Das Menü kann nur bei aktivem Editor-Fenster (StormED) ausgewählt werden.

"Finde nächstes" führt die zuletzt gemachte Finde -Anweisung aus, ohne 
 zuvor den Dialog zu öffnen. 

@{i}Ersetze nächstes    A- "-"@{ui}
Das Menü kann nur bei aktivem Editor-Fenster (StormED) ausgewählt werden.

"Ersetze nächstes" führt die zuletzt gemachte Ersetze-Anweisung aus, 
ohne zuvor den Dialog zu öffnen. 

@{b}Kompilieren@{ub}

@{i}Kompilieren...@{ui}
Der Menüpunkt "Kompilieren..." ist anwählbar, wenn in der Projektsektion 
Quelltexte ein Eintrag markiert ist. Er kann auch dann angewählt werden, 
wenn der im aktiven Quelltexteditor-Fenster angezeigte Quelltext im 
aktiven Projekt enthalten ist.

Mit dieser Funktion können Sie einzelne Module gezielt kompilieren lassen. 

@{i}Projekt übersetzen...     A-M@{ui}
Der Menüpunkt ist nur bei aktiviertem Projekt- oder Fehlerfenster 
wählbar. Er kann auch dann angewählt werden, wenn der im aktiven Quell-
texteditor-Fenster angezeigte Quelltext im aktiven Projekt enthalten ist.
Mit Make werden alle Module kompiliert, die seit dem letzten Kompilieren 
verändert wurden. Dabei werden auch Abhängigkeiten zwischen Programm- und 
Header-Dateien berücksichtigt.

Ein Klick auf das Piktogramm  "Make" hat dieselbe Auswirkung.

@{i}Alles kompilieren...@{ui}
Durch Anwahl dieses Menüpunktes werden alles dem Projekt angehörenden
Quelltexte übersetzt.

@{i}Hierarchisch Übersetzen...@{ui}
Dieser Befehl ermöglicht das Übersetzen des aktiven Projektes und aller
weiteren im Projekt enthaltenen Projekte. Dabei werden die Abhängigkeiten
berücksichtigt. Das bedeutet, daß nur die tatsächlich zu übersetzenden
Quelltexte übersetzt werden.

Sinnvoll ist diese Vorgehensweise für Programmprojekte, die beispielsweise
für verschiedene Przessortypen kompiliert werden müssen. Sie können mehrere
Projekte für dieses Programm erzeugen, in denen jeweils andere Optionen
und/oder verschiedene Biblitoheken angegeben werden. Mit einem
hierarschischen Make werden dann alle Programmvarianten auf den aktuellen
Stand gebracht.

@{i}Alles Hierarchisch Übersetzen...@{ui}
Es werden alle im Projekt und in allen Unterprojekten enthaltenen Quelltexte
kompiliert.

@{i}Projekt Starten...     A-R@{ui}
Der Menüpunkt ist nur bei aktiviertem Projekt- oder Fehlerfenster 
wählbar. Er kann auch dann angewählt werden, wenn der im aktiven 
Quelltexteditor-Fenster angezeigte Quelltext im aktiven Projekt 
enthalten ist.

Falls für das aktuelle Projekt bereits ein ausführbares Programm 
erzeugt wurde, wird dieses gestartet. Zuvor wird ein "Make" ausgeführt
und damit automatisch alle veränderten Module neu kompiliert und auch 
das Programm neu erzeugt.

Das selbe kann auch mit Klick auf das Piktogramm "Run" erreicht werden.

@{i}Projekt Debuggen      A-D@{ui}
Der Menüpunkt ist nur bei aktiviertem Projekt- oder Fehlerfenster 
wählbar. Er kann auch dann angewählt werden, wenn der im aktiven 
Quelltexteditor-Fenster angezeigte Quelltext im aktiven Projekt 
enthalten ist.

Mit Klick auf "Debug_" wird praktisch ein "Starten..." ausgeführt und 
automatisch der Debugger gestartet. Der Programmzähler wird auf die 
erste Funktion (main) im Programm gesetzt und die Programmausführung 
angehalten.

Das selbe kann auch mit Klick auf das Piktogramm "Debug" erreicht 
werden.

@{i}Berühren (engl. touch)@{ui}
Der Menüpunkt ist nur bei aktiviertem Projektfenster wählbar.

Mit Klick auf den Menüpunkt "Berühren" wird der markierte Eintrag in der 
Quelltext-Sektion als verändert markiert. Bei dem nächsten Starten von 
"Make" wird dieser Quelltext garantiert neu kompiliert.

@{i}Alles berühren (engl. touch all)@{ui}
Der Menüpunkt ist nur bei aktiviertem Projektfenster wählbar.

Hierbei werden alle Module in der Quelltext-Sektion als verändert 
markiert. Bei dem nächsten Starten von  Make" wird jedes Modul des 
Projektes neu kompiliert.

@{i}Alles Hierarchisch berühren (engl. touch all)@{ui}
Der Menüpunkt ist nur bei aktiviertem Projektfenster wählbar.

Hierbei werden alle Module in der Quelltext-Sektion des Projektes und aller
weiteren im Projekt enthaltenen Projekte als verändert
markiert. Bei dem nächsten Starten von  "Make" wird jedes Modul des
Projektes neu kompiliert.

@{b}Debugger@{ub}

Die im folgenden beschriebenen Menüpunkt sind nur bei gestartetem
Debugger aktiv.

@{i}Gehe@{ui}
Das Programm wird mit Maximalgeschwindigkeit ausgeführt und hält erst wieder
am nächsten Unterbrechungspunkt oder am Programmende.

@{i}Einzelschritt@{ui}
Führt einen Debugger-Schritt aus und hält das Programm danach wieder an.

@{i}Schritt Über@{ui}
Ein Funktionsaufruf soll schnell abgearbeitet werden. Der Debugger hält den
Prgrammlauf in der Zeile nach dem Funktionsaufruf an.

@{i}Exit Funktion@{ui}
Bis zum Ende der aktuellen Funktion soll mit Maximalgeschwindigkeit
abgearbeitet werden.

@{i}Zeige PC@{ui}
Die Quelltextanzeige im Editor springt an die Postition des aktuellen
Program Counters.

@{i}Adresse Suchen...@{ui}
In dem daraufhin angezeigten Dialog können Sie eine Speicheradresse angeben, ab
der Quelltext angezeigt werden soll.

@{b}Fenster@{ub}

@{i}Fehlerfenster...@{ui}
Der Menüpunkt ist nur bei aktiviertem Projektfenster wählbar.

Das Fehlerausgabefenster wird geöffnet.

@{i}Programmodule...@{ui}
Der Menüpunkt ist nur bei gestartetem Debugger aktiv und öffnet das 
Fenster der Programmodule, für die Quellinformationen ausgegeben werden 
können. Prinzipiell handelt es sich dabei um die gleiche Liste von 
Einträgen, wie sie im Projektfenster unter Quelltexte erscheint, wenn 
für jeden Quelltext auch eine Debuggerausgabe erzeugt wurde. Es werden 
lediglich statt der Quelltextenamen die Dateinamen der Objektmodule 
angezeigt.

@{i}Variablen...@{ui}
Der Menüpunkt ist nur bei gestartetem Debugger aktiv und öffnet das 
Fenster für die Anzeige aller Variablentypen.

@{i}History...@{ui}
In diesem Fenster werden die letzten Schritte des Programms protkolliert.
Sie können damit den Ablauf Ihres Programms nachvollziehen, z.B. wenn Sie
auf ein unerwartetes Verhalten stoßen und noch einmal wissen wollen,
warum es zu diesem Verhalten kam.

@{i}Unterbrechungspunkte...@{ui}
Im Breakpoint-Fenster werden alle gesetzten Breakpoints angezeigt.

@{i}Stack...@{ui}
Ein sogenanntes "Backtrace" im Programm hilft bei der Fehlersuche enorm.
Die Möglichkeit hierfür bietet die Dokumentation der verschachtelten
Funktionsaufrufe, die im Stackfenster angezeigt werden.

@{i}Profiler Protokoll...@{ui}
Absolut Neues beitet unser in das V2.0 Paket aufgenommene Profiler. Zum
Einsatz kommt diese Werkzeug nach der Entwicklung einer Software, um
gezielt an Stellen zu optimieren, die die meiste Zeit während des
Programmlaufs benötigen.

@{i}Hexadezimal Editor...@{ui}
Der Hexeditor zeigt einen Speicherbereich hexadezimal und als ASCII-
Zeichen an. Die Darstellung kann byte-, wort-, oder langwortweise erfolgen.

@{i}Disassembler...@{ui}
Im Disassembler-Fenster wird der aktuelle Programmquelltext oder
der Programmcode an einer wählbaren Adresse als Disassemblerlisting aus-
gegeben.

@{b}Einstellungen@{ub}

@{i}Projektumgebung...@{ui}
Die Einstellungen zum jeweiligen Projekt werden bei aktiviertem Projekt- 
oder Fehlerfenster zugänglich. Bei Klick auf das Menü  Projektumgebung..."
wird der abgebildete Dialog angezeigt.

Der erste Einsteller in der Liste der Einstellerdialoge ist der für die 
Include-Dateien. Aus den Include-Dateien liest der Preprozessor seine 
Definitionen für z. B. die Standard-Funktionen. In Ihrem Quelltext 
benutzen Sie zum Einbinden solcher Dateien die Preprozessor-Anweisung 
#include. Vielleicht wissen Sie schon, daß man dabei zwei Möglichkeiten 
hat: Schließt man den Dateinamen nach dem #inlcude "so" in Anführungs-
zeichen ein, sucht der Preprozessor (das Programmodul, das vor dem
Compiler die Datei bearbeitet) vom aktuellen Verzeichnis aus, während 
die <so> in spitze Klammern gesetzten Dateinamen Standard-Includedateien
bezeichnen und in vorgegebenen Verzeichnissen gesucht werden. In dem 
Listview können Sie für die Standard-Includedateien mehrere 
Verzeichnisse vorgeben.

Eine weitere Möglichkeit, um Speicher zu sparen und die Compiler-
geschwindigkeit zu erhöhen, haben Sie durch die Erzeugung von 
vorkompilierten Header-Dateien. Damit der Compiler weiß, wo die 
Header aufhören und Ihr eigenes Programm beginnt, muß die Stelle 
mit einer "#pragma header" Zeile markiert sein. Am einfachsten 
schreiben Sie in den Quelltext jedes Moduls zunächst die "#includes" 
aller Header-Dateien, die Sie nicht selbst geschrieben haben oder die 
sowieso nicht geändert werden, wie z. B. die OS-Includes. Dann folgt 
die Zeile "#pragma header". Hiernach können Sie  dann mit Ihren eigenen 
Headerdateien und den Rest des Programmes angeben.

Die Pragma-Anweisung hat solange keine Wirkung, bis Sie im Einsteller 
das Header-Cycle-Menü auf "Headerdatei schreiben" einstellen und die 
veränderten Module neu kompilieren. Sobald der Compiler die Pragma-
Anweisung im Programm erreicht, dauert es eine kurze Zeit und die 
vorkompilierten Header-Dateien werden unter dem angegebenen Namen in das 
entsprechende Verzeichnis geschrieben.

Vor dem nächsten Compilerlauf schalten Sie dann einfach auf "Headerdatei 
lesen". Der Compiler liest dann die vorkompilierte Headerdatei, sucht 
nach der Anweisung "#pragma header" und setzt dort mit seiner Übersetzung 
ein.

@{b}Compileroptionen@{ub}
Das Optionenfenster ist in vier Einsteller unterteilt. Wechseln Sie
zwischen den Einstellern durch Anwählen der jeweiligen Karteikarten-
reiter.

@{i}Preprozessor@{ui}

Mit diesem Dialog können Sie zum einen die Preprozessor-Warnungen 
einstellen und zum zweiten die Preprozessor-Symbole vordefnieren.

Zu den Warnungen muß ich sicher nichts beschreiben wohl aber zu den 
Definitionen. Jeder Eintrag, der in das Listview gemacht wird, wirkt 
beim Compilieren so, als stände er mit einem vorangestellten "#define" 
am Anfang jedes übersetzten Quelltextes. Sie können so global wirkende 
Definitionen angeben wie z. B. Debug und als Token True oder False.

@{i}Codegenerierung und Debugger@{ui}

Dieser Dialog stellt alle Einstellungen zur Verfügung, die für die 
Codegenerierung und den Debugger relevant sind. Angefangen mit der 
Art des Quelltextes (ANSI C oder C++) kann zusätzlich im C++ Modus 
noch die Verarbeitung von Templates und die Benutzung des Exception-
Handlings eingeschaltet werden.

Unter der Quelltextsteuerung befinden sich die Einsteller für die 
Debuggerausgabe.

Zuerst wählen Sie mit dem Cycle-Menü, ob überhaupt Debug-Ausgaben 
erzeugt werden sollen. Der Compiler generiert dann zusätzlich Debug-
Dateien mit der Endung ".debug" und ".link". Diese Dateien werden vom 
Debugger benötigt, um den Bezug zwischen Quelltext und Programmcode 
herstellen zu können.

Sollten Sie lieber mit einem symbolischen Debugger /Disassembler 
arbeiten wollen, haben Sie die Möglichkeit, einen Symbolhunk an das 
Programm anhängen zu lassen.

Für diejenigen unter Ihnen, die lieber manuell kontrollieren möchten, 
was der Compiler so alles generiert, ist die Erzeugung von Assembler-
Quelltexten aus den C/C++-Codes möglich. Der Compiler schreibt dann 
außer der ".o"-Datei noch eine ".s"-Datei, die den Assembler-Quelltext 
wahlweise gemischt mit C-Quelltext enthält.
Mit der Wahl des Symbols  Codegenerierung unterbrechbar" erzeugt der 
Compiler in jeder Schleife eine Abfrage der Tastenkombination <CTRL>+<C>.

Wenn Sie Code für den 68000er erzeugen, sollten Sie den Schalten  32 Bit 
Multiplikation" einschalten, da dann die korrekt funktionierenden 
Bibliotheksfunktionen zur Langwortdivision und -multiplikation genutzt 
werden. Bei der Erzeugung von Code für die höheren Prozessoren ist 
dieser Schalter sowieso bedeutungslos.

Bei eingeschaltetem Schalter  Code optimieren", wird der Programmcode 
kürzer und meist auch schneller.
Mit dem Cycle-Menü darunter sind die verschiedenen Prozessoren 
einstellbar, für die spezieller Code erzeugt werden kann. Hierbei müssen 
Sie die Abwärts-Inkompatibilität beachten. Wenn Sie zum Beispiel Code für 
den 68060 erzeugen lassen, ist das Programm nicht mehr auf einem 
handelsüblichen Amiga 1200 lauffähig, da dieser mit einem 68020 
Prozessor bestückt ist.

Das Cycle-Menü darunter läßt Ihnen die Wahl zwischen FPU-Code oder dem 
Aufruf der Systembibliotheken bei mathematischen Berechnungen in Ihrem 
Programm.

Das letzte Cycle-Menü in dieser Reihe schaltet zwischen großem und 
kleinen Datenmodell um.

@{i}Warnungen@{ui}

In StormC gibt es 8 Warnungen, die man je nach Situation und 
persönlichem Programmierstil einzeln ein- und ausschalten kann.


@{b}Linkeroptionen...@{ub}

Ähnlich wie für Include-Dateien bei den Preprozessor-Einstellungen läßt 
sich auch der Pfad für die Linkerbibliotheken einstellen. 
Ist im Cycle-Menü darunter die Einstellung  Programm linken" gewählt, 
wird das übersetzte Programm ganz normal mit den Bibliotheksroutinen zu 
einem ausführbaren Programm zusammengebunden.

Ist "Nicht linken" eingeschaltet, werden keinerlei Bibliotheks- oder 
sonstige Module hinzugeladen. Der Linker wird überhaupt nicht gestartet.

Bei "Ohne Statup-Code linken", wird das Programm so gelinkt, daß es
beispielsweise als  Shared-Library" oder als  Device-Treiber" eingesetzt 
werden kann. Einen Start solcher Programme von der Workbench oder vom 
CLI aus ist nicht möglich.

Im Fehlerfall kann mit dem Cycle-Menü darunter festgelegt werden, ob 
der Linkvorgang gestartet oder nicht gestartet werden soll.

@{b}Programmstart...@{ub}

Selbstverständlich muß die Möglichkeit bestehen, für den Start aus 
der integrierten Umgebung Argumente anzugeben und die Stackgröße des 
Programmes vorgeben zu können.

Desweiteren kann hier eingestellt werden, ob der Profiler und das Ressource-
Tracking genutzt werden soll.

@EndNode

@Node "ST_Neues1" "StormC.guide/ST_Referenz"
@Next "ST_Lizenz"
@Prev "ST_Referenz"
@Toc "Main"

 @{b}Änderungen in der Version 1.1 und 1.2@{ub}

 @{" Projektverwaltung   " Link "STC1_Sort"}  Sortieren von und innerhalb von Sektionen
 @{" Projektverwaltung   " Link "STC1_Sections"}  Neue Sektionen und Steuerungsmöglichkeiten
 @{" Tooltypes           " Link "STC1_Project"}  GOLDED, SAVEMEM, QUIET
 @{" Optioneneinsteller  " Link "STC1_Options"}  Getrennter Optioneneinsteller
 @{" Objektdateienablage " Link "STC1_Objectcodes"}  Codebedingte Objektdateienablage
 @{" INCBIN              " Link "STC1_Incbin"}  Anbinden von Binärdateien
 @{" __saveds            " Link "STC1_SAVEDS"}  Das Schlüsselwort __saveds
 @{" Inlining            " Link "STC1_Inline"}  Verhindern von Inline-Funktionen
 @{" Exceptions          " Link "STC1_Except"}  Ignorieren von Exceptionspezifizieren
 @{" Rapid Prototyping   " Link "STC1_Proto"}  Ersetzung von nichtvorhandenen Funktionen
 @{" Codefolding         " Link "STC1_Codefold"}  Optimierung beim Linken
 @{" Editor              " Link "STC1_Editor"}  Neue Funktionalität
 @{" StormLibrarian      " Link "STC1_Librarian"}  Einfache Erzeugung von Linker-Bibliotheken
 @{" Debugger            " Link "STC1_Debugger"}  Der in allen Teilen überarbeitete Debugger
 @{" Version 1.2         " Link "STC1_V12"}  Das kostenlose Update von Version 1.1

@EndNode

@Node "STC1_Sort" "StormC.guide/STC_Sort"
@Next "STC1_Sections"
@Toc "Main"

Sortieren in der Projektverwaltung

Einzelne Einträge in Projektsektionen oder auch ganze Sektionen
können in der Reihenfolge schnell geändert (verschoben) werden.

Wie Sie wissen bietet die StormShell beim Hinzufügen von
Bibliotheken wie auch beim Hinzufügen von Dateien die Möglich-
keit, mehrere Dateien im ASL-Dateidialog auszuwählen. Die aus-
gewählten Dateien werden dann immer in alphabetischer Reihenfolge
in das Projekt aufgenommen. Dies kann besonders bei Bibliotheken
eine ärgerliche Folge haben.

Der ein oder andere hat sicher schon mit Linker-Fehlermeldungen
kämpfen müssen, nur weil er aus Unachtsamkeit vergessen hat, die
Bibliothek "Storm.Lib" vor der "Amiga.Lib" im Projekt einzutragen.

Bei der gleichzeitigen Auswahl von "Amiga.Lib" und "Storm.Lib" werden
die beiden in der alphabetischen Reihenfolge in das Projekt einsortiert
und müssen zuerst umsortiert werden, bevor gelinkt werden kann.

In der Version 1.1 der StormShell stehen dazu die beiden neuen
Menüpunkte "Nach oben verschieben" und "Nach unten verschieben" zur
Verfügung. Durch Anwahl eines der genannten Menüpunkte wird der aktuell
ausgewählte Projekteintrag oder die ganze Sektion nach oben oder
nach unten verschoben.

@EndNode

@Node "STC1_Sections" "StormC.guide/STC_Sections"
@Next "STC1_Project"
@Prev "STC1_Sort"
@Toc "Main"

Neue Projektsektionen

In der neuen Version der Projektverwaltung wurde eine eigene
Sektion für StormWIZARD-Dateien ermöglicht. Die Integration von
StormWIZARD ist dabei genau so perfekt, wie die Einbindung
aller anderen Programme. Beim Hinzufügen von durch StormWIZARD
erzeugte  Dateien mit der Endung ".wizard" wird die neue Sektion
"StormWIZARD Schnittstelle" angelegt.

Bei Doppelklick auf den Eintrag wird StormWIZARD automatisch gestartet
und die gewählte Datei geladen. Die Integration aller Entwicklungs-
komponenten garantiert eine optimale Strukturierung und Organisation
Ihrer Projekte.

@{b}Erweiterte Tastaturfunktionalität@{ub}

Die Unterstützung durch zusätzliche Tastaturqualifier in der
Projektverwaltung war bisher nur sehr stiefmütterlich behandelt.
Bei Doppelklick auf den Programmnamen im Projekt und gleichzeitigem
Gedrückthalten der <ALT>-Taste wird das Programm automatisch im
Debug-Modus gestartet.

Hinzu kam nun die Unterstützung von Datatypes. Bei Doppelklick auf
einen Eintrag in der Projektverwaltung und Gedrückthalten der
<ALT>-Taste wird Multiview gestartet und die Datei geladen. Ist nun
ein entsprechender Datatyp in Ihrem System installiert, wird die
Datei angezeigt.

Ein kleines Beispiel verdeutlicht, wie sinnvoll diese Erweiterung ist:
Sie arbeiten an Ihrem Projekt und möchten auch eine AmigaGuide-
Dokumentation erstellen. Am einfachsten fügen Sie hierfür einen neuen
Eintrag in die Guide-Sektion ein. Bislang konnten Sie den Eintrag
zwar doppelklicken, um den Text dann mit dem Editor zu bearbeiten,
wollten Sie aber das Endergebnis sehen, mußte die Originaldatei
gesucht und doppeltgeklickt oder sogar Multiview manuell gestartet
werden.

Mit der neuen Projektverwaltung genügt es, die <ALT>-Taste gedrückt-
zuhalten, und den Eintrag in der AmigaGuide-Sektion doppelt zu
klicken. Daraufhin wird Multiview gestartet und Ihr AmigaGuide-
Dokument in der Anwenderfassung angezeigt. Eine Arbeitserleichterung,
um die wir von vielen Anwendern gebeten wurden!

@EndNode

@Node "STC1_Project" "StormC.guide/STC_Project"
@Next "STC1_Options"
@Prev "STC1_Sections"
@Toc "Main"

@{b}QUIET@{ub}

Das Merkmal QUIET unterdrückt die Ausgabe der Startgrafik. Auch das kleine
Fenster, das bei zu geringer Farbanzahl alternativ erscheint, wird nicht
angezeigt.

@{b}SAVEMEM@{ub}

Bei Speicherknappheit bietet der Einsatz dieses Merkmals die Möglichkeit das
System nur teilweise zu laden, so daß Speicher eingespart wird. SAVEMEM
verhindert das Laden von StormC, StormLINK, StormASM und StormRUN.

Erst bei Bedarf werden die jeweiligen Programmteile geladen und belegen
Speicher. Solange genügend Speicher frei ist, bleiben die Programme
jedoch im Speicher.

@{b}GOLDED@{ub}

Anstelle von StormED wird alternativ der populäre Editor GoldED aus der
Schublade "GOLDED:" geladen. Da GoldED in der gleichen Weise wie StormED
genutzt wird und nicht wie üblich als Schaltzentrale für den Compiler
fungiert, muß der Editor speicherresident geladen werden.

Stellen Sie bitte im GoldED unter "Konfig/Diverses..." die Einstellungen
für "Diverses" auf "resident" und speichern die Einstellung.

@EndNode

@Node "STC1_Options" "StormC.guide/STC_Options"
@Next "STC1_Objectcodes"
@Prev "STC1_Project"
@Toc "Main"

Neuer Optioneneinsteller mit erweiterten Optionen

Der neue Optioneneinsteller wurde aufgeräumt und in seiner Bedienung
wesentlich handlicher gestaltet. Die mit StormWIZARD verfügbaren
Karteikartenreiter verschaffen einen Ueberblick über alle Einstell-
möglichkeiten.

Der Einsteller wurde zudem in vier Gruppen gegliedert:

  1. Projektumgebung

  2. Compileroptionen

  3. Linkeroptionen

  4. Debuggeroptionen

@EndNode

@Node "STC1_Objectcodes" "StormC.guide/STC_Objectcodes"
@Next "STC1_Incbin"
@Prev "STC1_Options"
@Toc "Main"

Codebedingte Objektdateien-Ablage

Viele Anwender der Version 1.0 sind begeistert von unserer Projekt-
verwaltung und der Möglichkeit, alles zum Projekt gehörige
strukturiert und überschaubar verwalten zu können. Selbstverständlich
gibt es auch hierfür viele Erweiterungsmöglichkeiten, die uns genannt
wurden.

Eine wichtige Erweiterung ist die Verwaltung verschiedener Versionen
Ihres Projektes. Gemeint sind z.B. Versionen Ihres Programmes
für verschiedene Prozessortypen. Bislang mußte das komplette Projekt
neu kompiliert werden, was bei umfangreichen Projekten unter Umständen
sehr lange dauern kann.

Die Version 1.1 bietet Ihnen die Möglichkeit, in jedem Projekt eine
Schublade anzugeben, in die die Objektdateien gespeichert werden
sollen. Für verschiedene Versionen genügt es nun, den einzelnen
Projekten unterschiedliche Schubladen für die Objektdateien anzugeben.
Beispielsweise "68K-Code", "020-Code","060-Code", usw...

Da in den Schubladen immer die Objektdateien mit den entsprechenden
Optionen enthalten sind, werden immer nur die Module neu kompiliert,
deren Quellcode tatsächlich geändert wurde!

Den entsprechenden Einsteller hierzu finden Sie im Optioneneinsteller
für die Projektumgebung.

@EndNode

@Node "STC1_Incbin" "StormC.guide/STC_Incbin"
@Next "STC1_SAVEDS"
@Prev "STC1_Objectcodes"
@Toc "Main"

Anbinden von Binärdateien

Die neuen Linkereigenschaft, Binärdateien anbinden zu können, fand
man bisher eigentlich nur bei Assembler-Entwicklungssystemen. In
StormC 1.1 wurde sie zur StormWIZARD-Unterstützung integriert, kann
aber auch für andere Zwecke genutzt werden.

Bei Aktivierung der Option "Binde WIZARD-Datei" wird die in der
Projektverwaltung enthaltene Wizard-Datei an das Programm gelinkt.
Damit die Daten korrekt initialisiert werden können, muss selbst-
verständlich ein Symbolname für den Datenhunk angegeben werden. Die
Initalisierungs-Routine für die Wizard-Daten kann dann die an das
Programm angehängte Datei initialisieren.

@EndNode

@Node "STC1_SAVEDS" "StormC.guide/STC_SAVEDS"
@Next "STC1_Inline"
@Prev "STC1_Incbin"
@Toc "Main"

@{HEADER}Die Nutzung von __saveds@{UHEADER}

Wenn Sie eine Funktion mit dem Schlüsselwort @{MARK}__saveds@{UMARK} definieren
generiert der Compiler zusätzlichen Code am Anfang der Funktion der
die Adresse der LinkerDatabase in das Register @{MARK}a4@{UMARK} lädt.

Beispiel:

    int __saveds function(int a, int b);

Das Laden des Registers @{MARK}a4@{UMARK} mit dem Wert der LinkerDatabase ist dann
sinnvoll, wenn die betreffende Funktion von anderen Programmen genutzt
werden soll. Zum Beispiel in Shared Libraries, bei Hook-Funktionen oder
in Boopsi-Dispatchern.

Das Register @{MARK}a4@{UMARK} wird mit dem Wert des Symbols @{MARK}_LinkerDB@{UMARK} wie folgt
initialisiert:

    LEA    _LinkerDB, a4

Falls die Compileroption @{MARK}"Near Data (a6)"@{UMARK} eingeschaltet
ist, wird der Wert aus @{MARK}_LinkerDB@{UMARK} selbstverständlich in das Register
@{MARK}a6@{UMARK} statt nach @{MARK}a4@{UMARK} geladen.

Das Symbol @{MARK}_LinkerDB@{UMARK} wird von Linker mit der Adresse des ersten Elements
des NearDatahunks geladen.

Residentfähige Programme können nicht auf absolute Adressen verweisen.
Das Schlüsselwort @{MARK}__saveds@{UMARK} kann daher nicht verwendet werden, wenn die
Linkeroption @{MARK}"residentfähiges Programm"@{UMARK} eingeschaltet ist.

Die Angabe des Schlüsselwortes @{MARK}__saveds@{UMARK} bei der Funktionsdefinition
entspricht dem Aufruf der Funktion @{MARK}"GetBasReg()"@{UMARK} oder @{MARK}"geta4()"@{UMARK}. Bedeutet
allerdings keinen Unterfunktionsaufruf, spart daher Programmcode und
wird schneller abgearbeitet.

Das @{MARK}__saveds@{UMARK} Schlüsselwort muß bei Funktionsdefinitionen enthalten sein,
kann aber in der Prototypdeklaration ignoriert werden. Wird @{MARK}__saveds@{UMARK} im
Prototyp nicht aber bei der Definition einer Funktion angegeben, meldet
der Compiler einen Fehler. Bei Angabe des Schlüsselwortes vor Funktions-
pointern oder Funktionsparametern wird eine Fehlermeldung ausgegeben.


@EndNode

@Node "STC1_Inline" "StormC.guide/STC_Inline"
@Next "STC1_Except"
@Prev "STC1_SAVEDS"
@Toc "Main"

Verhindern von Inline-Funktionen

Inline-Funktionen werden wie Makros direkt an der Stelle des Aufrufs
im Quelltext eingefügt. Der Compiler spart damit den Aufruf der
Funktionen und kann daher extrem gut optimieren. Durch die Benutzung
der Inline-Funktionen wird das Programm schneller und wenn man sich
auf kurze Inline-Funktionen beschränkt (z.B. das Auslesen des Wertes
eines Attributs einer Klasse) auch kürzer.

In der Testphase können Inline-Funktion jedoch sehr störend sein, da
es für den Debugger unmöglich ist, den Quelltext zu Inline-Funktionen
anzuzeigen.

Mit dem Schalter kann der Compiler angewiesen werden, die Inline-
Funktionen wie normale Funktionen aufzurufen. Der Debugger kann dann
auch den Quelltext dieser Inline-Funktionen anzeigen und im Einzel-
schrittmodus abarbeiten.
Dabei stört es nicht, dass Inline-Funktionen meistens in den Header-
Dateien der Module zu finden sind.

@EndNode


@Node "STC1_Except" "StormC.guide/STC_Except"
@Next "STC1_Proto"
@Prev "STC1_Inline"
@Toc "Main"

Ignorieren von Exceptionspezifizierern

Für die Testphase oder Sicherheitsfanatiker bietet C++ die Möglich-
keit eine Funktion (auch Memberfunktionen einer Klasse) mit
sogenannten Exceptionspecifier auszustatten: Mit Hilfe des Schlüssel-
worts <throw> hinter dem Funktionsprototyp wird eine Liste von
Exceptions angegeben, die durch diese Funktion höchstens ausgeworfen
werden. Alle anderen Expcetions werden als unerwartete Exception
behandelt.

Dafür muss der Compiler um jede Funktion mit Excpetionspecifier einen
"try-Block" setzen, der alle erlaubten Exception auffängt und wieder
auswirft, aber alle anderen Exceptions abfängt und die Funktion
unexpected() aufruft. Dieser zustäzliche "try- Block" macht das
Programm länger und etwas langsamer.

Es empfiehlt sich deshalb nach ausreichender Testphase den Compiler
anzuweisen diese Exceptionspecifier zu ignorieren. Das Programm wird
dadurch unter Umständen drastisch kürzer.

@EndNode

@Node "STC1_Proto" "StormC.guide/STC_Proto"
@Next "STC1_Codefold"
@Prev "STC1_Except"
@Toc "Main"

Ersetzung von nichtvorhandenen Funktionen

Diese Option wurde zur Unterstützung des sogenannten Rapid Prototyping
implementiert. Generieren Sie einfach eine Funktion mit dem Namen
"_stub", schalten die genannte Option ein und programmieren drauflos.
In der Stub-Funktion sollte vielleicht eine Debugausgabe gemacht oder
ein Dialog mit entsprechendem Hinweis: "Funktion noch nicht implemen-
tiert" ausgegeben werden.

@EndNode

@Node "STC1_Codefold" "StormC.guide/STC_Codefold"
@Next "STC1_Editor"
@Prev "STC1_Proto"
@Toc "Main"

Codefolding (Fold Common Code)

Der StormLink ist in der Lage, einige Optimierungen, die ein Compiler
macht, auch im fertigen Programm durchzuführen. Dazu gehört auch das
Entfernen von mehrfach vorhandenem Code.

Wenn der StormLink zwei Routinen entdeckt, die identisch sind, so
daß es keinen Unterschied macht, ob das Programm die erste oder die
zweite aufruft, ersetzt der StormLink die zweite Routine durch den
Code der ersten. Wer behauptet, daß er ja selber programmiert und
sowas nicht macht, bitteschön. Aber nicht wundern, wenn bei der
Benutzung von Templates das Programm immer länger und länger wird.
Da diese Option einiges an Laufzeit kostet, ist ihre Benutzung auch
nur dann zu empfehlen, wenn der Optimizer des Compilers auf der
höchsten Stufe steht.

@EndNode

@Node "STC1_Editor" "StormC.guide/STC_Editor"
@Next "STC1_Librarian"
@Prev "STC1_Codefold"
@Toc "Main"

StormEd Farbeinsteller

Vielfach gewünscht, ist es nun in der aktuellen Version einfach
möglich, die farbliche Textdarstellung mit der Maus zu verändern.
Die einfache Einstellmöglichkeit löst damit die bislang komplizierte
Angabe der Vorder- und Hintergrundfarbe in der jeweiligen Settings-
Datei ab.

Die globale Editoreinstellungen wurde dafür um den Einsteller
"Farben" (Karteikartenreiter) erweitert.

Mit dem Wechselsymbol direkt unter den Karteikartenreitern wird
die "Syntaxart" gewählt. Es können Eingestellungen für diese Arten
vorgenommen werden:

    Preprozessor -> Dictionary/Preprocessor.dic

    Beispiel: #include


    C/C++ Symbole -> Dictionary/C Symbols.dic

    Beispiel: void


    C/C++ Bibliotheksfunktionen -> Dictionary/C Library.dic

    Beispiel: printf


    AmigaOS Typen -> Dictionary/Amiga Types.dic

    Beispiel: ULONG


    AmigaOS Funktionen -> Dictionary/Amiga Functions.dic

    Beispiel: DisplayBeep()


    ANSI-C Kommentare

    Beispiel: /* ANSI-C Kommentar */


    C++ Kommentare

    Beispiel: // C++ Kommentar


    String Konstanten

    Beispiel: "Hello World"


    Zeichen Konstanten

    Beispiel: 'x'


    Zahlen Konstanten

    Beispiel: 42


    Und selbstverständlich für die drei Benutzer-Bibliotheken!

Mit den Symbolen in der Gruppe "Farbe" kann die zwischen der Einstellung
für die Vordergrund- und für die Hintergrundfarbe gewählt werden.

Mit dem Wechselsymbol darunter wählt man für die jeweilige Art die
"Standard Textfarbe" oder die "Standard Hintergrundfarbe", wie sie
im Palette-Voreinsteller der Workbench eingestellt wurden. Will
man eine eigene Farbeinstellung vornehmen muß das Wechselsymbol die
Auswahl "Eigene Einstellung" enthalten. Dann wird das darunter angeordnete
Palettefeld zugänglich und man kann eine eigene Farbe auswählen.

In der Gruppe "Stil" kann unabhängig von den Farbeinstellungen ein
Textstil für die jeweilige Art gewählt werden.

In der Gruppe "Beispiel" wird ein Codefragment angezeigt, anhand dessen
die gemachten Einstellungen begutachtet werden können.


Klammern-Check und Blockeinrückung

Die automatische Überprüfung der Klammernstruktur ist sehr hilfreich
bei tief geschachtelten Konstruktionen. All zu leicht wird eine
Klammer vergessen und man erhält eine Fehlermeldung, die nicht
unbedingt auf eine fehlende Klammer schließen lässt. Auch bei der
Programmierung von Installer-Skripten ist diese Funktion sehr
hilfreich.

Markierte Textbereiche können ab sofort nach links oder rechts
verschoben werden. Halten Sie dazu die <Ctrl>-Taste gedrückt und
drücken die <Cursor links> bzw. <Cursor rechts>-Taste.

Je nach Tabulatoreinstellung wird dann der markierte Textblock
verschoben.

@EndNode

@Node "STC1_Librarian" "StormC.guide/STC_Librarian"
@Next "STC1_Debugger"
@Prev "STC1_Editor"
@Toc "Main"

Einfache Erzeugung von Linker-Bibliotheken

Nicht nur die Erzeugung von Shared-Libraries ist eine wichtige
Bedingung für ein echtes Entwicklungssystem, sondern auch die
Möglichkeit, Funktionsgruppen in einer Linkerbibliothek zusammen-
fassen zu können. Bei der Erzeugung von Bibliotheken wie beispiels-
weise der Amiga.Lib oder der Storm.Lib muß bereits beim Kompilieren
der Module darauf geachtet werden, dass jede Funktion am Besten in
einem eigenen Hunk abgelegt wird. Der Compiler bietet dazu die Option
"Eigener Hunk für jede Funktion". Nach dem Kompilieren müssen die
einzelnen Module zu einer Library "gejoint" werden, was lästige
Tipparbeit bedeutet.

Unser neuer StormLibrarian hilft Ihnen dabei und bietet die Möglich-
keit Objektmodule zu Library-Projekten zusammenzufassen. Haben Sie
Ihr Projekt erstellt, genügt ein einfacher Klick auf "Erzeugen" und
die Bibliothek wird unter dem angegebenen Namen erzeugt. Bei
Veränderung der Objektmodule muß nun lediglich das Projekt in den
StormLibrarian geladen und die Bibliothek neu erzeugt werden - fertig!

@EndNode

@Node "STC1_Debugger" "StormC.guide/STC_Debugger"
@Next "STC1_V12"
@Prev "STC1_Librarian"
@Toc "Main"

Neues überarbeitetes Kapitel!

@{b}7 Debugger@{ub}

Nach dem ersten erfolgreichen Kompilieren eines Programms
beginnt die Testphase. Natürlich könnte man das Programm
einfach aus einem CLI (bzw. einer Shell) heraus starten,
aber daraus ergeben sich einige, für den Amiga typische
Probleme:
1* Wenn das Programm gravierende Fehler erzeugt und das
   ist in C oder C++ jederzeit möglich, kann der Computer
   abstürzen, denn die CPU kennt sogenannte Exceptions,
   also Ausnahmezustände der Soft- oder Hardware. Diese
   werden durch das Betriebssystem nur sehr allgemein
   behandelt und erlauben häufig keine vernünftige
   Weiterarbeit, ohne einen Neustart des Systems.

2* Wenn das Programm in eine Endlosschleife läuft,
   hilft zumeist nur ein Neustart.

3* Selbst wenn nach einer Exception der Computer nicht
   neugestartet wird, oder wenn das Programm mit der
   Funktion "exit()" oder "abort()" beendet wird,
   bleiben die Betriebssystemressourcen größtenteils
   belegt. Während reservierter Speicher nur ärgerlich
   ist, können eine offengebliebene Datei oder ein
   offengebliebenes Fenster die Weiterarbeit massiv
   behindern oder auch zu einem Absturz des Betriebssystems
   führen.

Die genannten Fehler lassen sich nicht auf die Quelltext-
position im Programm zur ückführen.

@{b}Allgemeines zur Runshell@{ub}

Aus diesen vier Gründen besitzt StormC eine "Runshell".
Diese startet das Programm ebenfalls wie aus dem CLI,
enthält jedoch umfangreiche Möglichkeiten, das Programm
zu kontrollieren und zu steuern.

Ein besonderes Merkmal ist das "Resource-Tracking", das
beispielsweise Problem 3 löst. Beim Abbuch oder Ende
eines Programms werden alle Ressourcen angezeigt, die
durch das Programm reserviert, aber nicht freigegeben
wurden. Die Ressourcen werden dann durch die "Runshell"
freigegeben. Die Quelltextstelle, an der die jeweilige
Ressource reserviert wurde, kann dabei auf einfachste
Weise angesprungen werden.

Angeschlossen an diese "Runshell" ist der "Source-Level-
Debugger". Mit diesem kann man ein Programm schrittweise
abarbeiten, um Fehler zu lokalisieren, oder Variablenwerte
zu kontrollieren. Aber auch, um direkt Einfluß auf das
Programm zu nehmen und jederzeit eine Problemstelle
(im härtesten Fall ein Absturz) im Quelltext zu
lokalisieren.

Ebenso ist ein "harter Abbruch" des Programms möglich
(z.B. in Endlosschleifen), ohne das Programm in einem
speziellen Modus kompilieren zu müssen.

Überhaupt ist dieses eine Maxime in der Testphase unter
StormC: Das Programm ist in der Testphase identisch zum
endgültigen Produkt. Um den "Source-Level-Debugger"
verwenden zu können, muß zwar mit einer entsprechenden
Option kompiliert werden, diese hat aber keinerlei Einfluß
auf das erzeugte Programm. Damit wird vermieden, daß ein
Programm im Normallauf einen Fehler zeigt, den es im
Debugger nicht hat, wie es bei anderen Systemen immer
wieder vorkommt.

Eine weitere Besonderheit ist die Möglichkeit, jederzeit
aus dem normalen Programmlauf in den Debugger wechseln zu
können oder wieder aus dem Debugger in den normalen
Programmlauf zurückzukehren, sofern das Programm mit der
Debug-Option kompiliert wurde.

@{b}Ein Beispiel zum Resource-Tracking@{ub}

Öffnen Sie das Projekt "IllResource.¶" in der Schublade
"StormC:Examples/IllResource". Dieses kleine Programm
reserviert einige Ressourcen, gibt sie aber nur zum Teil
wieder frei.

Starten Sie dieses Programm z.B. mit der Funktionstaste
<F9>. Daraufhin wird das Programm bei Bedarf neu kompiliert
und dann gestartet.

Weitere Möglichkeiten des Programmstarts sind: der Druck
auf den Knopf mit dem laufenden Männchen in der Toolbar,
die Auswahl des Menüpunktes "Starten" aus dem Menü
"Kompilieren", der Doppelklick auf den Programmeintrag
im Projektfenster (dabei wird das Program nie neu
kompiliert) oder direkt nach dem Kompilieren aus dem
Fehlerfenster mit dem Knopf "Starten".

Nach dem Kompilieren und Start des Programms wird das
Kontrollfenster der "RunShell" geöffnet. Dies ist Ihr
"Steuerpult" für das Programm.

Die Statuszeile zeigt Ihnen kurze Hilfetexte zu jedem
Element des Kontrollfensters und außerdem den Status
Ihres Programms, wenn Sie sich auf keinem Oberflächen-
element befinden.

Das Programm "IllResource" zeigt Ihnen jetzt an, daß es
wartet (Funktion "Wait()" der "exec.library") und zusätzlich
die Maske der Signalflags, auf die gewartet wird. Momentan
steht hier ein "0x00001000", das entspricht einem <Ctrl>+<C>.

Die Symbole in der Gruppe "Debugger" werden momentan nicht
benötigt, denn zuerst soll das Programm normal arbeiten.
Mit dem Auswahlsymbol im Rahmen läßt sich der Debugger
einschalten, die darin angebrachten Symbole stehen für
"Gehe", "Gehe einen Schritt", "Gehe einen Schritt, aber
bearbeite Funktionsaufrufe schnell", "Gehe bis zum Ende
der Funktion" und "Zeige die zuletzt ermittelte Programm-
position". Diese Funktionen werden im weiteren Text bei
der Debuggereinführung näher erläutert.

@{b}Programm kurzzeitig anhalten@{ub}

Der Knopf "Pause" erlaubt, das Programm jederzeit anzuhalten,
z.B. wenn Sie den Inhalt eines Fensters näher betrachten
wollen, der sonst zu schnell wieder überschrieben würde.
Dieser Knopf wird wie ein Druckschalter bedient, zuerst
wird der Knopf "eingedrückt", dann bleibt er in diesem
Zustand. Das Programm hält solange an, bis Sie den Knopf
wieder drücken und er "herausspringt". Das Programm läuft
daraufhin weiter. Der Menüpunkt "Pause" im Menü "Debugger"
hält das Programm ebenfalls an.

@{b}Programm hart abbrechen@{ub}

Daneben liegt der Knopf "Kill". Diese martialische Aktion
erlaubt, das Programm jederzeit zu beenden. Der Menüpunkt
"Kill" im Menü "Debugger" hat die gleiche Wirkung.

@{b}Taskpriorität ändern@{ub}

Der Gruppe der Prioritäteneinsteller zeigt die Priorität
des Programms an und erlaubt, diese zu ändern. Obwohl man
die Priorität über den ganzen Bereich von -128 bis 127
einstellen kann, sollte man sie im Bereich von -20 bis 20
lassen, es könnte sonst zu Schwierigkeiten mit anderen
Programmen kommen, oder sogar zur Unbenutzbarkeit des Systems.

Der beim Programmstart eingestellte Wert (im Normalfall -1)
ist insofern vernünftig, daß er um eins kleiner ist als die
Priorität des Debuggers und somit immer ein zügiges Arbeiten
im Debugger möglich ist.

@{i}Hinweis@{ui}
   Insbesondere durch zu hohe Prioritätseinstellungen
   kann das System "lahmgelegt" werden. Bitte seien
   Sie vorsichtig mit der Ver nderung dieser Einstellungen.


@{b}Signale verschicken@{ub}

Die Gruppe der Signalsymbole enthält vier Knöpfe, um die
vier Unterbrechungssignale von AmigaDOS zu setzen:

   <Ctrl>+<C>, <Ctrl>+<D>, <Ctrl>+<E>, <Ctrl>+<F>.

Damit ist es sehr einfach möglich, in der Testphase
zusätzliche "Wait()" Anweisungen einzukompilieren und das
Programm damit zusätzlich zu steuern. Das Programm
"IllResource" wartet eben gerade auf das Signal <Ctrl>+<C>.

Klicken Sie jetzt auf das Symbol "Ctrl-C" in der Gruppe der
Signalsymbole.

Nun hat das Programm einige Ressourcen reserviert, aber
dann nicht wieder freigegeben, das Programm ist beendet.

Obwohl das Resource-Tracking immer funktioniert und
Ressourcen durch die "RunShell" freigegeben werden, kann
die Quelltextstelle nur angezeigt werden, wenn das Programm
mit Debugdateien kompiliert wurde.

Die Protokolliste zeigt einige Informationen bezüglich
Ressourcen, die reserviert und nicht freigegeben wurden.
Das betrifft einige Speicheranforderungen, Bibliotheken und
eine Datei.

Doppelklicken Sie auf eine Zeile in der Protokoll-Liste und
die Stelle im Quelltext, an welcher diese Ressource reserviert
wurde, wird Ihnen angezeigt. Falls der Quelltext des
Programms nicht sowieso schon im Editor angezeigt war,
wird ein neues Editorfenster ge ffnet und der Quelltext
geladen.

In einem "echten" Programm könnten Sie nun die passende
Freigabe programmieren. An welcher Stelle das passieren müßte,
hängt natürlich von ihrem Programm ab.

Um die Quelltextstelle zu einer fehlerhaften Reservierung anzeigen
zu können, muß eine Bedingung erfüllt sein:

   * Die entsprechende Betriebssystemfunktion muß direkt im
     Quelltext aufgerufen werden. Damit sind alle Aufrufe über
     Bibliotheken nicht brauchbar, die Betriebssystemfunktionen
     sollten also nicht über die "amiga.lib" und die darin enthaltenen
     Stub-Funktionen aufgerufen werden, sondern immer über die
     passenden "#pragma amicall" und "#pragma tagcall"-Aufrufe.

Geben Sie nun die Ressourcen mit dem Menüpunkt "Ressourcen freigeben"
aus dem Menü "Debugger" frei, oder schließen Sie das Kontrollfenster.
In beiden Fällen werden Sie noch gefragt ob zuvor die Ressourcen
freigegeben werden sollen.

@{b}Verwendung des Debuggers@{ub}

Laden Sie das Projekt "StormC:Examples/DebuggerTutorial/DebuggerTutorial.¶".
Das Programm besteht aus zwei Modulen mit einer Headerdatei, gerade genug,
um auch nicht ganz triviale Fälle beim Debuggen zu zeigen.

Starten Sie das Programm jetzt normal und machen Sie sich damit
vertraut. Zuerst erscheint ein Eingabemenü mit drei Punkten:

   * Eingabe einer Adresse,
   * Ausgabe aller gespeicherten Adressen und
   * Ende des Programms.

Wenn Sie eine neue Adresse eingeben wollen, so geben Sie 1
(<Return> nicht vergessen) ein. Dann geben Sie Name, Vorname,
Straße und Wohnort einer Person ein. Wiederholen Sie das
zwei- oder dreimal und schauen Sie sich dann durch Menüauswahl
2 die Adressen an. Beenden Sie danach das Programm.

Da man normalerweise nur eigene Programme debuggt sollten Sie sich
jetzt noch den Quelltext anschauen, um die Funktionsnamen kennenzulernen.

Das Hauptprogramm steht im Modul "main.c". Es zeigt das Hauptmenü
an und wertet die Menüauswahl aus. Je nach Eingabe wird eine
Funktion aus dem Modul "address.c" aufgerufen.

Das Modul "address.c" enthält zuerst einige statische Funktionen,
die für die anderen Funktionen benötigt werden. Dann folgen alle
Funktionen zur Adressverwaltung.

Die Headerdatei "address.h" enthält die Datenstruktur "struct Address"
und die Prototypen aller Funktionen, die etwas mit den Adressen
anstellen, also insbesondere Ein- und Ausgabe. Diese Funktionen sind
im Modul "address.c" implementiert und werden durch das Modul
"main.c" aufgerufen.

Wenn Sie soweit Bescheid wissen, starten Sie das Programm erneut, allerdings
diesmal im Debugger, also mit <F10> oder dem passenden Piktogramm
aus der Toolleiste.

Weitere Möglichkeiten, ein Programm zu debuggen sind:

   * der Menüpunkt "Debuggen" im Menü "Kompilieren",
   * der Doppelklick auf den Programmnamen im Projektfenster mit
     gleichzeitig gedrückter <Alt>-Taste oder direkt nach dem
     Kompilieren aus dem Fehlerfenster mit Klick auf den Knopf
     "Debuggen".

Wieder wird zuerst das Kontrollfenster geöffnet, allerdings diesmal
mit eingeschalteter Debugger-Kontrolle. Das Programm läuft
automatisch bis zur ersten Stelle im Programm, für die auch
Quelltext existiert. Wenn Sie den Quelltext des Moduls "main.c"
nicht schon geladen haben, so geschieht das jetzt. Das Editorfenster
sieht dabei etwas anders aus als sonst: Links neben dem Text befindet
sich jetzt eine Spalte mit Unterbrechungspunkten.

Mit Unterbrechungspunkt wird jede Stelle im Quelltext bezeichnet,
an der das Programm anhalten kann, Breakpoint heißen die Stellen an
denen ein Programm wieder anhält, wenn es mit "Gehe" gestartet wurde
und mit voller CPU Geschwindigkeit abläuft.

In dieser Spalte können Sie mit der Maus einen Unterbrechungspunkt
setzen oder löschen. Außerdem zeigt diese Spalte, wie weit ein
einzelner Schritt im Programm führt, denn häufig führt ein Schritt
in C über mehrere Textzeilen hinweg (z.B. über Kommentare, Variablen-
deklarationen, lange Ausdr cke etc).

Die Position des Programms wird im Editor immer durch einen weißen Balken
angezeigt, der horizontal die ganze Zeile markiert.

@{b}Das Variablenfenster@{ub}

Als nächstes wird noch das Fenster der Variablen ge öffnet.
Darin werden immer in drei Seiten alle Variablen angezeigt,
die das Programm zur Zeit ansprechen kann.

In der obersten Zeile des Fensters wird wieder eine kurze Hilfe
ausgegeben, die Ihnen sagt, welche Aufgabe die verschiedenen
Symbolknöpfe im Fenster haben.

Unter dieser Zeile befindet sich eine ganze Leiste von Knöpfen.
Links liegen 3 Kn öpfe mit denen Sie eine der 3 Variablenseiten
auswählen k nnen.

   * Die 1. Seite enthält alle Funktionsparameter und lokale
     Variablen der aktuellen Funktion sowie die globalen Variablen
     des Moduls, das diese Funktion enthält.
   * Die 2. Seite enthält alle globalen Variablen aller Module.
   * Die 3. Seite enthält alle Variablen, die Sie überwachen wollen.
     Das können lokale Variablen jeder Funktion sein oder auch Teile
     einer Struktur, die Sie inspiziert haben.

Wählen Sie die erste Variable der aktuellen Variablen aus (address),
indem Sie den Namen der Variablen anklicken. Daraufhin können Sie
auch die weiteren Elemente im Fenster erreichen. Neben den Knöpfen zur
Seitenauswahl liegen die Knöpfe zur Aktion auf der ausgewählten
Variablen.

Durch Druck auf den 1. Knopf bekommen Sie die Quelltextstelle angezeigt,
an der die Variable definiert ist, indem der Textcursor auf die Stelle
plaziert wird.

Der 2. Knopf ist für C++ Programmierer interessant. Er zeigt eine Liste
aller Member-Funktionen des Typs der Variablen. Im Beispiel existieren
jedoch keine Member-Funktionen, so daß die Liste leer dargestellt wird.

Der 3. Knopf inspiziert die Variable. Dazu wird in der Variablenliste
die Variable "aus der Nähe" betrachtet, z.B. wird jedes Feld einer
Struktur einzeln aufgeführt. Der Doppelklick auf eine Variable hat die
gleichen Auswirkung wie das Anwählen von Knopf 3.

Der 4. Knopf erlaubt wieder die Rückkehr aus der vorherigen Inspektion,
der Inhalt der Variablenliste entspricht danach wieder dem Zustand vor
der Inspektion.

Der 5. Knopf öffnet den Hexeditor und setzt den Cursor an die Adresse
der Variablen.

Der 6. Knopf überträgt die Variable in die Seite der überwachten
Variablen. Damit können Sie sich eine Liste von Variablen zusammenstellen,
die Sie immer sehen wollen, auch wenn das Programm sich gerade nicht
in dem dazugehörigen Modul oder der Funktion befindet.

Der 7. Knopf ist nur auf der Seite der überwachten Variablen aktiv und
entfernt eine überwachte Variable aus dieser Liste.

@[b}Temporäres Casten@{ub}

Das Texteingabefeld "Cast" erlaubt ein einfaches Casting des Typs. In
diesem Feld können Sie jeden Typ angeben, der im Modul irgendwo
definiert wird. Achten Sie jedoch darauf, den Typ so zu schreiben,
wie er in der Variablenliste auch ausgegeben wird. Wird der Typ
gefunden, so wird der Wert der Variablen entsprechend des neuen
Typs interpretiert. Zum Beispiel kann es sinnvoll sein aus einem
ULONG ein LONG zu machen, um den Wert mit Vorzeichen angezeigt zu
bekommen. Die häufigste Anwendung ist jedoch den Zieltyp eines
Pointers zu ändern, z.B. aus "Message *" ein "IntuiMessage *".
Bei der nächsten Inspektion dieser Variablen wird dan natürlich
der neue Typ benutzt.

Der alte Typ wird immer noch in der Variablenliste angezeigt,
der neue Typ nur im Texteingabefeld "Cast". Wollen Sie zum alten
Typ zurückkehren, brauchen Sie nur das Texteingabefeld zu löschen
und <Return> drücken.

Haben Sie sich einmal mit einem Typ vertippt, so blinkt der Bildschirm
und die alte Eingabe bleibt unverändert stehen.

@{b}Wertänderung@{ub}

Wenn Sie eine Zahlvariable ausgewählt haben (hier zum Beispiel die
dritte Variable illegal), können Sie im Texteingabefeld "Wert"
auch den Wert der Variablen direkt ändern, ohne den Hexeditor bemühen
zu m ssen.

Haben sie eine Variable ausgewählt deren Typ ein Pointer auf ein
UBYTE oder BYTE ist (gemeinhin auch "String" genannt), so können
Sie den Strings im Texteingabefeld "Wert" ändern. Achten Sie
jedoch darauf, nicht mehr Zeichen einzugeben, als Speicherbereich
für diesen String zur Verfügung steht.

@{b}Variablensortierung@{ub}

Die Variablenliste wird zu Anfang unsortiert dargestellt. Sie können
mit dem Cyclegadget "Sort" diese Sortierung umstellen. Die
alphabetische Sortierung benutzt den Namen der Variablen zur
Sortierung, damit lassen sich bei vielen Variablen (z.B. der Liste
aller globalen Variablen) schnell bestimmte Variablen finden. Die
Sortierung "Letzte Änderung" stellt immer die Variable an den Anfang
der Liste, die zuletzt geändert wurde. Diese Sortierung wird nicht
nur bei der Auswahl dieses Sortiermodus durchgeführt, sondern nach
jedem Programmschritt. Dadurch sehen Sie immer, welche Variable
zuletzt geändert wurde. Der Debugger erkennt dabei jede Änderung,
also auch Änderungen einzelner Strukturfelder oder Variablen, die über
den Umweg eines Pointers verändert wurden.

Die Sortierung können Sie für die 3 Variablenseiten getrennt einstellen.
Arbeiten Sie nun einige Befehle des Programms ab, indem Sie das
mittlere Symbol in der Gruppe der Debuggersymbole klicken. An Ihrem
Editorfenster sehen Sie, wie das Programm eine "printf" Funktion
nach der anderen abarbeitet, die Ausgabe geschieht passend auf dem
Konsolefenster. Die Statuszeile im Kontrollfeld zeigt Ihnen nach
jedem Schritt "Breakpoint erreicht" an. Während Sie einen Schritt
gehen und dieser Schritt länger dauert z.B. bei einer Eingabe von der
Konsole, können Sie auch die Meldung "Programm wird fortgesetzt" lesen.

Irgendwann erreichen Sie die Funktion "gets(s)" in Zeile 25. Wenn Sie
diese Funktion abarbeiten, müssen Sie natürlich eine passende Eingabe
im Konsolefenster machen.

Bitte geben Sie <1> und <Return> ein. In der switch-Anweisung laufen
Sie nun in den ersten Zweig hinein. In Zeile 29 steht der Funktionsaufruf
der Funktion "readAddressmask()". Diese Funktion steht im Modul
"address.c". Wählen Sie nun nicht den Knopf zum schnellen Bearbeiten
von Funktionen weiter, sondern wählen Sie den zweiten Knopf von links,
um das Programm in einzelnen Schritten abzuarbeiten. Dadurch "betreten"
Sie die Funktion "readAddressmask()".

Der Quelltext des Moduls "address.c" wird geladen und die Quelltext-
position wieder angezeigt. Gehen Sie nun Schritt für Schritt durch die
Funktion. Je nachdem, ob Sie den 2. oder 3. Knopf in der Grupper der
Debugger-Symbole im Kontrollfenster benutzen, werden die weiteren
Unterprogramme schnell abgearbeitet oder Sie durchlaufen auch diese
schrittweise.

Machen Sie bei Bedarf Eingaben für Name, Vorname, Straße und Wohnort
im Konsollfenster. Wählen Sie im Variablenfenster als Sortierung für
die aktuellen Variablen "Letzte Änderung" und sehen Sie, wie immer die
Variable des zuletzt eingegebenen Elements an oberste Stelle rückt.

Bevor Sie die Funktion beendet haben, können Sie den 4. Knopf von
links im Debuggerrahmen ausprobieren. Dieser läßt das Programm
relativ schnell weiterlaufen, bis das Ende der Funktion erreicht
ist und Sie wieder ins Hauptprogramm gelangen.

Dort sollten Sie auf Zeile 30 stehen und die Variable "address" sollte
einen sinnvollen Wert anzeigen. Diese können Sie nun näher betrachten.
Wählen Sie die Variable im Fenster der aktuellen Variablen aus und
drücken Sie den Knopf zum Inspizieren.

Die Variablenliste wird ersetzt durch die Elemente der Struktur "Address".
Sie können die eingegebenen Strings auch jetzt noch ändern. Wählen
Sie dazu z.B. das Feld "name" aus und ändern Sie den Wert dann im
Texteingabefeld "Wert". In diesem Fall sollten Sie einen höchstens
gleich langen String angeben, denn das Programm hat die Strings im
dynamischen Speicher mit "malloc()" reserviert und nur soviel Platz
wie nötig reserviert.

Setzen Sie nun die Fehlersuche fort und probieren Sie ein paar
Möglichkeiten aus, z.B. das Überwachen von Variablen und Struktur-
feldern. Wenn Sie sich einigermaßen "wohl fühlen" im Debugger, beenden
Sie das Programm, wahlweise korrekt oder mit "Kill".

@EndNode

@Node "STC1_V12" "StormC.guide/STC_Debugger"
@Next "STC1_"
@Prev "STC1_Debugger"
@Toc "Main"

@{b}Verbesserungen für Version 1.2:@{ub}

Generell wurde das System beschleunigt und die einzelnen Programmteile sind
deutlich kürzer. Es wird jetzt mindestens eine 68020 CPU vorausgesetzt.


@{b}StormCPP
--------@{ub}

Falls die "wizard.library" oder die "appmanager.library" nicht in der
richtigen Version vorliegen, wird eine Fehlermeldung ausgegeben.

Dem Start der Programme "StormShell" und "StormED" wird nun mehr Zeit
gelassen, bevor die Fehlermeldung ausgegeben wird. Wirkt sich bei langsamen
Rechnern mit noch langsameren Festplatten positiv aus.


@{b}StormED
-------@{ub}

Die Taste F7 ist nun ein Shortcut für den Menüpunkt "Kompilieren".

Kleinere Probleme bei der Texteinfärbung (insbesondere mit C Kommentaren)
beseitigt.


@{b}StormShell
----------@{ub}

Wie im StormED ist F7 auch als Shortcut für den Menüpunkt "Kompilieren"
erlaubt.

Der Menüpunkt "Open" der Toolbar erlaubt nun auch das Laden von Texten,
nicht nur Projekte (obwohl als Pattern des ASL Requesters immer noch "#?.¶"
voreingestellt ist).

Die neue Sektion "Librarian" erlaubt die Aufnahme von Dokumenten des
StormLibrarian mit der Endung ".lb" in das Projekt. Durch einen Doppelklick
auf den Dateieintrag wird StormLibrarian gestartet und das Dokument geladen.
Drücken sie zusätzlich die Taste "Alt" während des Doppelklicks wird die
Bibliothek sofort nach dem Laden durch "StormLibrarian" erzeugt.

Das Nachladen des Compilers, des Linkers oder der RunShell ist nun robuster,
d.h. der "ARexx Protokoll Fehler" beim Beginn eines Makes wird nun auch auf
Rechnern mit sehr langsamer Festplatte vermieden.

Die Berechnung der Abhängigkeiten, d.h. die Feststellung, welche Dateien neu
kompiliert werden müssen, erfolgt nun insbesondere bei großen Projekten mit
vielen Dateieinträgen und vielen Headerdateien deutlich schneller.

Der Linkvorgang ist flexibler geworden: Nach einem Linkerfehler, der kein
Neukompilieren erfordert (z.B. weil eine Bibliothek fehlte) oder falls eine
Linkerbibliothek neu erzeugt wurde, wird automatisch neu gelinkt. Die Abfrage
"Linken oder alls kompilieren" erscheint nur noch, wenn das Programm wirklich
völlig aktuell ist.

Bislang wurden alle Dateien, die nicht im Projektverzeichnis lagen zu ihrem
vollen Pfadnamen expandiert. Gibt man jetzt einen absoluten Pfadnamen bei
"Datei hinzufügen" an, wird dieser Namen nicht nochmal expandiert - dadurch
bleiben Namen, die relativ zu einem Assign sind erhalten. Projekte lassen
sich dadurch erheblich einfacher auf andere Rechner und Festplatten übertragen.

@{b}StormRun
--------@{ub}

Debuginformationen werden nun zwischen mehreren Debuggersitzungen gecasht.
Dadurch wird insbesondere der Start von Programmen mit vielen Modulen deutlich
schneller.

Das Resourcetracking wurde überarbeitet und ist beim Speicherhandling
flexibler geworden. Insbesondere werden auch die Funktionen AllocVec() und
FreeVec() überwacht.

Darstellungsfehler im Hexeditor beseitigt.


@{b}storm.lib
---------@{ub}

Die storm.lib wurde massiv optimiert, sodaß Programme, die sie intensiv
benutzen spürbar schneller und kürzer werden. Neu linken reicht dabei für
bestehende Programme aus.

Diverse kleine Fehlerbereinigungen.


@{b}Mathematikbibliotheken
----------------------@{ub}

Die neue Bibliothek "math020.lib" wird automatisch benutzt, falls als CPU
68020 oder besser eingestellt ist, aber keine FPU benutzt werden soll.

Alle Mathematikbibliotheken wurde überarbeitet und optimiert.


@{b}GoldED Unterstützung
--------------------@{ub}

Falls mit "GoldED" gearbeitet wird, wird nun die Version 4 erwartet (leider
hat sich das Startverhalten von "GoldED" geändert, daher ist Version 3 oder
älter nicht mehr sinnvoll einsetzbar).

Wenn "StormCPP" den Editor nachladen muß, wird nicht mehr automatisch "GoldED"
benutzt, falls er resident vorhanden ist, sondern der Editor, der explizit
gewünscht ist ("StormED" oder "GoldED", je nach Tooltype).

Wird "StormCPP" mit zusätzlichen Texticons gestartet, so werden diese auch
an "GoldED" zum Laden weitergegeben.

Der Filetype STORMC wird grundsätzlich für alle Texte benutzt, die "GoldED"
für "StormC" laden soll.

@EndNode

@Node "ST_Neues2" "StormC.guide/ST_Referenz"
@Next "Presse"
@Prev "ST_Neues1"
@Toc "Main"

 @{b}Änderungen in der Version 2.0@{ub}

 @{" Projektverwaltung   " Link "STC2_Sort"}  Eigene Makescripts

 @{" Der Profiler        " Link "STC2_Sections"}  Neue Kontrollmöglichkeiten mit dem Profiler

Desweiteren wird mit der Version 2.0 von StormC der Profi-Texteditor
GoldED 4 zusätzlich zum StormED 2 geliefert. Sie können nun zwischen den beiden
Editoren auswählen. Die Anbindung von GoldED geschieht dabei genauso harmonisch
wie bereits von StormED gewohnt.

@EndNode

@Node "STC2_Sort" "StormC.guide/STC_Sort"
@Next "STC2_Sections"
@Toc "Main"

@{b}Eigene "Makescripts" in der StormC-Projektverwaltung@{ub}

Ein Make verläuft prinzipiell nach einigen einfachen Regeln. Zuerst werden
alle, im Projekt eingetragenen Dateien daraufhin überprüft, ob sie neu
kompiliert werden müssen.

Bei einem C Quelltext sieht das so aus, daß das Datum der Objektdatei und der
Debugdatei mit dem Datum des Quelltextes und aller Headerdateien, die von dem
Quelltext eingebunden werden, verglichen wird. Ist einer dieser Texte jünger
als die Objekt- oder die Debugdatei, muß der Quelltext neu kompiliert werden.

Der Quelltext muß ebenfalls neu kompiliert werden, wenn eine der Headerdateien
durch eine andere Compileranweisung neu erzeugt wird. Das ist z.B. der Fall,
wenn das Programm "catcomp" aus einer Lokaledatei eine Headerdatei erzeugt.

Stehen die neu zu kompilierenden Dateien fest, werden dann für alle Dateien,
die neu kompiliert werden müssen und für das Programm, das gelinkt werden muß
ARexxanweisungen erzeugt, die den Compiler StormC und den Linker StormLink
steuern. Diese Anweisungen werden nacheinander abgearbeitet.

Um auch andere Dateien als nur C Quelltexte und Assemblerquelltexte übersetzen
zu können, werden Makescripts benutzt:

Der Menüpunkt "Select Makescript..." erlaubt die Angabe eines ARexxskripts
für die ausgewählte Projektdatei oder - falls ein Sektionstitel ausgewählt ist -
für alle Dateien der Sektion. Diese Skripte erlauben den Einsatz externer
Compiler wie z.B. "catcomp", um die Lokaledateien automatisch zu kompilieren.
Sie werden automatisch aufgerufen, wenn die Projektdatei neu kompiliert werden
muß. Diese Makescripts sollten das Suffix ".srx" besitzen. Dateien mit dieser
Endung werden auch in die Sektion ARexx aufgenommen.

Mit dem Menüpunkt "Remove Makescript" wird das Makescript von einem Projekteintrag
oder allen Projekteinträgen einer Sektion entfernt.

Die Regel, ob eine Projektdatei, für die ein Makescript gesetzt ist, neu
kompiliert werden muß, ist prinzipiell mit der Regel der C Quelltexte
identisch.

Beim ersten Make nach der Angabe eines Makescripts wird die Datei immer neu
kompiliert.

Als Beispiel für ein Makescript wird hier das Makescript "catcomp.srx" kommentiert:

@{b}/*

Als Argumente werden der Dateiname (das ist der Pfad des Projekteintrags) und der
Pfad des Projekts übergeben. Die beiden Pfade sind in Hochkommata eingeschlossen, um
auch Leerzeichen zu ermöglichen.

Am Ende der Argumentenliste muß unbedingt ein Punkt stehen, um zusätzliche Argumente, die
in zukünftigen Versionen übergeben werden, zu überlesen.

*/
PARSE ARG '"' filename '"' '"' projectname '"' .

/*

Der Objektname muß vernünftig aus dem Dateinamen entwickelt werden. Objektname ist
dabei nicht nur eine Datei, die auf ".o" endet und gelinkt wird, sondern jeweils die
Datei, die erzeugt wird. Catcomp erzeugt eine Headerdatei.

*/
objectname = LEFT(filename,LASTPOS('.cd',filename)-1)||".h"

/*

Alle Ausgaben werden auf einem Konsolefenster ausgegeben.

*/
SAY ""
SAY "Catcomp Script ©1996 HAAGE & PARTNER GmbH"
SAY "Compile "||filename||" to header "||objectname||"."

/*

Damit die Notwendigkeit einer Neukompilierung ermittelt werden kann, muß der
Objektdateiname mit dem Projekteintrag verknüpft werden. Fehlt diese Anweisung,
wird das Makescript bei jedem Make aufgerufen.

Es können maximal zwei Objektdateinamen angegeben werden, also etwa so:

OBJECTS filename objectname1 objectname2

Diese werden beide der Datei zugeordnet und beim Neukompilieren getestet.

Der Befehl OBJECTS darf nicht verwendet werden, wenn das Makescript für den
Aufruf eines Assemblers der Sektion "Asm Quelltexte" benutzt wird. Diese Sektion
ermittelt den Objektnamen immer selbst. Siehe auch das Makescript
"StormC:rexx/phxass.srx"

*/
OBJECTS filename objectname

/*

Hier erfolgt der Aufruf des Übersetzerprogramms. Fehlermeldungen werden auf der
Konsole ausgegeben.

*/
ADDRESS COMMAND "catcomp "||filename||" CFILE "||objectname

/*

Da catcomp eine Headerdatei erzeugt, ist es sinnvoll diese Headerdatei im Projekt
anzumelden. Der Parameter QUIET unterdrückt dabei die Ausgabe einer Fehlermeldung,
falls die Headerdatei schon Teil des Projekts ist.

*/
ADDFILE objectname QUIET

/* Ende des Makescript */@{ub}

Fast jedes Makescript kann diesem Schema folgen. Unter Umständen ist noch eine
Anweisung praktisch:

@{b}DEPENDENCIES filename file1 file2 file3 ...@{ub}

Mit dieser Anweisung verknüpft man den Projekteintrag mit weiteren Dateien, deren
Datum daraufhin geprüft wird, ob das Makescript aufgerufen werden muß oder nicht. Der
eigentliche Projekteintrag wird dabei immer getestet und muß nicht extra mit diesem
Befehl gesetzt werden. Aber wenn das Skript auch noch andere Dateien mit einbezieht,
ist diese Anweisung sinnvoll (der StormC Compiler setzt zum Beipiel alle
Headerdateien, die mit einer Anweisung #include "abc.h" - aber nicht
#include <abc.h> - geladen werden).

Die Sektion für C Quelltexte beachtet gesetzte Makescripts nicht. C Quelltexte werden immer
mit dem StormC Compiler compiliert. Die Sektion für Assemblerquelltexte hingegen erlaubt
die Benutzung der Makescripts - obwohl hier die eingebaute Regel für das Programm StormASM
benutzt wird (welches seinerseits den Assembler PhxAss aufruft), wenn kein Makescript gesetzt
ist.

@{b}Argumentenübergabe an Makescripts@{ub}

Als Argumente werden der Dateiname (das ist der Pfad des Projekteintrags) und der
Pfad des Projekts übergeben. Die beiden Pfade sind in Hochkommata eingeschlossen, um
auch Leerzeichen zu ermöglichen.

Dann folgt ein Zahlargument, dessen Wert angibt, ob die Objektdateien alle in ein
Verzeichnis geschrieben werden sollen. 0 bedeutet, die Objektdatei gehört in das gleiche
Verzeichnis, wie die Quelltextdatei; 1 bedeutet, die Objektdatei gehört in das Objektverzeichnis.
Der Name des Objektverzeichnisses wird - ebenfalls in Hochkommata eingeschlossen - als nächstes
Argument übergeben (der Name wird immer übergeben, also auch, wenn die vorherige Zahl 0 ist).

Das Objektverzeichnis ist nur interessant für Programme, die Code erzeugen. Makescripts,
die Quelltext erzeugen (z.B. "catcomp.srx"), schreiben ihr Objekt immer in das Verzeichnis,
in dem auch der Projekteintrag steht. Das Objektverzeichnis ist also nur für Assembler und
andere Compiler interessant.

Makescripts für Assembler Quelltexte erhalten als einzige ein zusätzliches Argument an
dritter Stelle: der Name der Objektdatei. Dieser Name sollte unbedingt benutzt werden, um
die Assemblerobjektdatei zu erzeugen. Im Pfad dieser Objektdatei ist dabei das mögliche
Objektverzeichnis schon berücksichtigt.

Am Ende der Argumentenliste muß unbedingt ein Punkt stehen, um zusätzliche Argumente, die
in zukünftigen Versionen übergeben werden, zu überlesen.

Eine vollständige PARSE Anweisung für Makeskripts sieht also so aus (kein Assemblerskript):

@{b}PARSE ARG '"' filename '"' '"' projectname '"' useobjectdir '"' objectdir '"' .@{ub}

Und die Anweisung für Assemblermakescripts:

@{b}PARSE ARG '"' filename '"' '"' projectname '"' '"' objectname  '"' useobjectdir '"' objectdir '"' .@{ub}


@{b}Die fertigen Makescripts@{ub}

Im Verzeichnis "StormC:rexx" liegen einige fertige Makescripts. Diese können auch
an die jeweilige Situation angepaßt werden:

@{i}Die Assemblerskripte:@{ui}

Makescripts für Assembler sind insofern eine Besonderheit, daß die Makescripts nicht
die Anweisung OBJECTS enthalten dürfen.

@{i}"phxass.srx"@{ui}

Dieses Skript übersetzt eine Assemblerdatei mit dem Assembler PhxAss. Eigentlich ein
unnötiges Skript, da dieser Assembler direkt von der StormShell unterstützt wird,
aber vielleicht sollen ja spezielle Assembleroptionen benutzt werden.

@{i}"oma.srx"@{ui}

Dieses Skript übersetzt eine Assemblerdatei mit dem Assembler OMA.

@{i}"masm.srx"@{ui}

Dieses Skript übersetzt eine Assemblerdatei mit dem Assembler MASM.

Weitere Skripte:

@{i}"catcomp.srx"@{ui}

Dieses Skript übersetzt eine Lokale Katalogdatei mit dem Programm catcomp.

@{i}"librarian.srx"@{ui}

Auch der StormLibrarian kann über Makeskripts aufgerufen werden. Ein Projekteintrag
der Sektion "Librarian" kann mit Doppelklick in den StormLibrarian geladen werden
oder mit Alt-Doppelklick kann direkt die Linkerbibliothek erzeugt werden. Wenn jedoch
ein Projekt immer eine Linkerbibliothek erzeugen soll, empfiehlt sich der Einsatz
eines Makescripts. Die Liste der Objektdateien muß wie gewöhnlich im StormLibrarian
erzeugt werden. Das Makescript ruft dann den StormLibrarian auf. Dieser erzeugt nicht
nur die Bibliothek automatisch, sondern setzt auch die Linkerbibliothek als
Objekt (mit OBJECTS) und alle Objektdateien der Liste als abhängige Dateien (mit
DEPENDENCIES). Dadurch wird nach dem ersten Make automatisch die Linkerbibliothek
neu erzeugt, wenn einer der C oder Assemblerquelltexte neu kompiliert wurde.
Ebenso wird die Bibliothek neu erzeugt, wenn an der Liste der Objektdateien mit Hilfe
des StormLibrarian Änderungen gemacht wurden.

@{i}"fd2pragma.srx"@{ui}

Dieses Makescript erzeugt aus einer FD Datei eine Headerdatei mit den notwendigen
"#pragma amicall" Anweisungen für eine shared library. Normalerweise ist dieses
Skript nicht notwendig, denn der Linker erzeugt ebenfalls diese Headerdatei
automatisch, wenn eine shared library gelinkt wird.
@EndNode

@Node "STC2_Sections" "StormC.guide/STC_Sections"
@Next "STC2_Project"
@Prev "STC2_Sort"
@Toc "Main"

@{b}Der Profiler
------------@{ub}

Ein Profiler ist ein unverzichtbares Hilfsmittel, wenn es darum geht, ein Programm
zu optimieren. Alle Optimierungsmöglichkeiten des Compilers können ein Programm
immer nur graduell beschleunigen. Ein Profiler kann jedoch Hinweise geben, welche
Funktionen eines Programms besonders viel Zeit benötigen. Diese Funktionen sollten
dann, falls möglich, mit einem besseren Algorithmus neu geschrieben oder
zumindest mit der Hand so weit wie möglich optimiert werden.

Der StormC Profiler ist dabei besonders leistungsfähig, erlaubt eine exakte
Zeitmessung und gibt viele, statistisch wertvollen Information über das Programm.

Wie immer haben wir uns an unsere Maxime gehalten, daß auch für den Profiler keine
spezielle Programmversion erzeugt werden muß. Die Erzeugung der Debuginformationen
reicht aus, um das Profilerprotokoll zu erstellen. Dies - wie auch die Möglichkeit
den Profiler während des Debuggens laufen lassen zu können - ist wohl einmalig auf
dem Amiga.

Um den Profiler zu aktivieren müssen im Compilereinsteller die Debugoption auf
"Große Debugdateien" oder "Kleine Debugdateien" stehen. Im Starteinsteller
muß die Option "Profiler benutzen" angewählt sein. Dann kann das Programm wie
gewohnt gestartet werden. Das gleichzeitige Debuggen des Programms ist möglich,
kann jedoch geringfügige Fehler in der Zeitmessung zur Folge haben.

Nach dem Start des Programms kann das Profilerprotokollfenster geöffnet werden.
Der Knopf links oben bringt das Protokoll auf den aktuellen Stand, d.h. alle
Prozent- und Zeitwerte werden auf den aktuellen Stand gebracht.

In der Hilfezeile wird die aktuelle CPU Zeit angezeigt. Diese Zeit ist die echte
CPU Zeit, d.h. Zeitspannen, in welchen das Programm wartet (auf Signale, Nachrichten
oder I/O), werden nicht mit eingerechnet, ebensowenig Zeitspannen in denen das
Programm nicht läuft, weil andere Programme im Multitasking an der Reihe sind.

In der Liste unten werden die Funktionen mit folgenden Informationen angezeigt:

@{i}1. Der Funktionsname.@{ui}

Memberfunktionen einer Klasse wird der Klassenname mit zwei Doppelpunkten
vorangestellt.

@{i}2. Der prozentuale Zeitbedarf.@{ui}

Dabei wird nur die Zeit berechnet, die das Programm
in der jeweiligen Funktion oder einer tiefer verschachtelten Betriebssystemfunktion
verbracht hat. Nicht berücksichtigt werden Funktionsaufrufe im eigenen Programm.
Dies ist der wichtigste Wert, um herauszufinden, welche Funktion besonders viel
Zeit benötigt. Die Summe dieser Spalte aller Funktionen beträgt 99 - 100 % (das
fehlende Prozent geht im Startupcode und kleinen Ungenauigkeiten verloren).

@{i}3. Der prozentuale rekursive Zeitbedarf.@{ui}

Hierbei werden alle Unterprogrammaufrufe
mit aufsummiert. Deshalb hat die Funktion main() fast immer 99 %.

@{i}4. Der absolute Zeitbedarf.@{ui}

@{i}5. Der maximale Zeitbedarf.@{ui}

@{i}6. Der minimale Zeitbedarf.@{ui}

Diese drei Spalten erlauben einen Überblick über die Aufrufe dieser Funktion. Wie
eine Funktion optimiert werden kann, hängt oft auch davon ab, ob die Funktion
im allgemeinen für jeden Aufruf ähnlich viel Zeit benötigt (geringer Unterschied
zwischen maximaler und minimaler Zeit) oder für einige Aufrufe deutlich länger als
für andere Aufrufe braucht (hoher Zeitunterschied). Dann lohnt es sich eventuell,
diese Spezialfälle zu optimieren.

@{i}7. Die Anzahl der Aufrufe.@{ui}

Eine Funktion, die relativ viel Zeit benötigt, aber nur dadurch, daß sie sehr häufig
aufgerufen wird, pro Aufruf nur sehr kurze Zeit braucht, ist ein "schwerer
Kandidat" zur Optimierung. Natürlich kann es hier besonders helfen, die Funktion
als Inlinefunktion zu deklarieren ("__inline" in ANSI-C, "inline" in C++).

Über dieser Liste befinden sich einige Elemente zur Arbeit mit dem Protokoll:

Die oberste Zeile ist die Hilfezeile mit kurzen Hilfetexten über die
Bedienungselemente.

Darunter befinden sich links drei Knöpfe. Der erste bringt die Funktionsliste auf
den neusten Stand.

Mit dem zweiten Knopf kann man das Profilerprotokoll als ASCII Datei abspeichern,
dazu öffnet sich ein Dateirequester.

Der dritte Knopf druckt das Protokoll auf dem Drucker (verwendet wird das Gerät
"PRT:") aus.

Rechts in dieser Zeile kann man die Sortierung der Funktionsliste festlegen. Der
erste Eintrag "Prozentual" sortiert die Liste nach der 2. Spalte, der Eintrag
"Rekursiv" sortiert die Liste nach der 3. Spalte, der Eintrag "Alphabetisch"
sortiert die Liste alphabetisch nach den Funktionsnamen der 1. Spalte. Und der
letzte Eintrag "Aufrufe" sortiert die Liste nach der letzten Spalte.

Eine Zeile tiefer befindet sich ein Texteingabefeld für ein DOS Pattern. Dieses
DOS Pattern wird auf die Funktionsnamen angewendet und erlaubt so die Beschränkung
der häufig sehr langen Liste auf ein überschaubares Maß. Zum Beispiel kann man
die Liste sehr einfach auf alle Methoden einer Klasse beschränken, indem man
den Namen der Klasse gefolgt von "#?" eingibt.

Rechts daneben befindet sich ein Zahleingabefeld zur Angabe einer Mindestprozentzahl,
die die Funktionen belegt haben müssen, um angezeigt zu werden. Funktionen mit weniger
als 5 oder 10 % sind häufig nur sehr schwer zu optimieren und selbst eine Halbierung
der Laufzeit würde das Programm nur unwesentlich (eben um 2.5 bis 5 %) beschleunigen.

Neben diesen beiden wählbaren Einschränkungen kommen grundsätzlich nur Funktionen
zur Anzeige, die mindestens einmal aufgerufen wurden.

Eine Funktion kann über einen Doppelklick auch direkt im Quelltext angesprungen
werden.

Das Profilerprotokoll wird am Ende des Programmlaufs auch automatisch geöffnet und
die Anzeige auf den neuesten Stand gebracht. Das Kontrollfenster bleibt dann ebenfalls
geöffnet. Wird das Kontrollfenster geschlossen, so wird auch das Protokollfenster
geschlossen und die Liste gelöscht. Werden die Profilerinformationen noch benötigt,
so müssen sie vorher gespeichert oder gedruckt werden.

@{b}Technische Informationen@{ub}

Beim Funktionseinsprung werden die LINE $A Befehle $A123 und $A124 benutzt.
Diese beiden Maschinenbefehle sind bei allen Motorola 68K CPUs unbenutzt und
lösen eine Exception aus. Diese Expcetion führt die Protokollierung der
Zeiten und Aufrufe durch.

Durch die Nutzung der Exceptions hat man den kleinen Nachteil, daß diese die
maximale Programmgeschwindigkeit dämpfen, d.h. das Programm langsamer abläuft,
als ohne Profilerbetrieb. Besonders bei sehr vielen Aufrufen kurzer Funktionen
kann sich das bemerkbar machen. Allerdings sollte der Profiler immer noch schneller
und vor allen Dingen genauer arbeiten als die meisten bisher unter Amiga OS
bestehenden.Zudem wird dieser Nachteil sicher durch den Vorteil aufgewogen, das
Programm für den Profiler nicht speziell kompilieren zu müssen.

Die Benutzung von Rekursionen ist eingeschränkt: die Minimum- und Maximumwerte
sind meistens nicht korrekt, die Gesamtzeit (und damit auch die prozentualen
Werte) können falsch sein. Eine einfache Rekursion (f() ruft f() auf) zeigt
die richtigen prozentualen Werte an, eine verschachtelte Rekursion (f() ruft
g() ruft f() auf) akkumuliert alle Zeiten auf einer der beiden Funktionen.
Funktionsaufrufe, die aus der Rekursion herausführen, werden allerdings korrekt
behandelt.

Die Wirkung auf Long Jumps ist nicht vorhersehbar, meistens sollte es jedoch
nur zu einer kleinen Ungenauigkeit bei der verlassenen und eingesprungenen
Funktion kommen.

Theoretisch können nicht alle Funktionen gemessen werden: Nur Funktionen, deren
Maschinencode mit einem link oder einem movem Befehl beginnen, stehen dem Profiler
zur Verfügung. Allerdings ist selbst bei hohen Optimierungsstufen des Compilers
fast immer einer der beiden Befehle notwendig. Und Funktionen, die ohne diese
Befehle auskommen, müssen so kurz sein (keine Variablen auf dem Stack, nur die
Register d0, d1, a0 und a1 verändert), daß sie kaum noch optimiert werden können
oder dafür auch nur interessant sind.

Inlinefunktionen können im allgemeinen nicht gemessen werden.

@EndNode

@Node "STC2_Project" "StormC.guide/STC_Project"
@Next "ST_Arexx"
@Prev "STC2_Sections"
@Toc "Main"

@{b}Anmerkungen zur Portierung von SAS/C nach StormC
------------------------------------------------@{ub}

Wir haben uns bemüht, dem StormC Compiler viele wichtige Eigenschaften des SAS/C
Compilers mitzugeben, d.h. diverse Schlüsselwörter und #pragmas, die SAS/C
spezifisch sind. Dennoch wird es - abhängig von Ihrem Programmierstil - zu
mehr oder weniger großen Problemen kommen, wenn Sie Software vom SAS/C Compiler
auf den StormC Compiler portieren.

Bedenken Sie, daß StormC ein ANSI-C und C++ Compiler ist. SAS/C hingegen ist
ein C und ANSI-C Compiler (den C++ Precompiler hat wohl kaum jemand ernsthaft
benutzt), d.h er versteht viele alte Syntax, die StormC nicht akzeptiert. Nur
wenn sie Ihre Programme mit SAS/C grundsätzlich strikt ANSI übersetzt haben
(SAS/C Option ansi), sollten Ihre Programm auch problemlos mit dem StormC
übersetzbar sein.

@{b}Projekteinstellungen
--------------------@{ub}

Zuerst sollten Sie darauf achten, daß in dem Projekt, das Sie aus ihren
SAS/C Quelltexten aufgebaut haben, ANSI-C als Compilermodus eingestellt ist.
Schalten Sie möglichst viele Warnungen an, und versuchen Sie später, Ihre
Programme so zu verändern, daß auch keine Warnungen kommen. Dadurch haben Sie
die größtmögliche Sicherheit, daß das Programm auch das tut, was Sie wollen.

Selbst für reine ANSI-C Projekte empfiehlt sich die spätere Umstellung auf
C++. Dadurch erhalten Sie einige Vorteile: Prototypen werden immer erwartet
und der implizite Cast eines void * in einen anderen Pointer ist verboten.
Dies bedeutet zwar zuerst eine relativ aufwendge Überarbeitung Ihres Programms
(besonders der zweite Fall kann durch malloc() oder AllocMem() sehr häufig
vorkommen), aber dann können Sie viel sicherer sein, daß Ihr Programm auch
wirklich das tut, was es soll.

Ebenso bieten die langen C++ Symbole eine zusätzliche Sicherheit beim Linken:
Wenn Prototyp und Funktionsdefinition aus irgendeinem Grund nicht
übereinstimmen, so wird der Linker einen entsprechenden Fehler ausgeben, daß
ein bestimmtes Symbol nicht gefunden werden konnte.

Außerdem steht Ihnen dann die Möglichkeit offen, Ihr Programm um die modernen
objektorientierten Konzepte zu erweitern und weitere kleinere C++ Features zu
benutzen (z.B. die Variablendeklaration an jeder Stelle in Code und nicht nur
am Anfang eines Klammerblocks).

@{b}Syntax
------@{ub}

Manche SAS/C Keywords versteht der StormC Compiler nicht, andere sehr wohl,
aber nur in der typischen ANSI-C Syntax und nicht so frei wie der SAS/C
Compiler.

Unbenannte unions werden auch von StormC akzeptiert, aber implizite Strukturen
nicht. Ebenso werden equivalente Strukturen unterschieden. Wenn Sie dieses
Feature verwendet haben, müssen Sie an den jeweiligen Stellen Casts einfügen.
Falls Ihnen dieses Feature wichtig ist, so sollten Sie über eine Umstellung
Ihres Projekts auf C++ nachdenken: Äquivalente Strukturen sind nichts anderes
als ein Aspekt der Vererbung.

Typübereinstimmung wird in StormC viel strenger gehandhabt. Das gilt
insbesondere auch für den Funktionsparameterqualifizierer const. Ein Beispiel:

@{b}typedef int (*ftyp)(const int *);
int f(int *);
ftyp p = f; // Fehler@{ub}

Entweder sollten Sie entsprechende Casts einführen, oder aber (was auf alle
Fälle zu bevorzugen ist) Ihre Funktionen passend deklarieren, schließlich
ist der const Qualifizierer ein wichtiges Hilfsmittel zur Sicherung der
Korrektheit Ihres Programms.

Die C++ Kommentare ("//") werden von StormC auch im ANSI Modus akzeptiert,
verschachtelte C Kommentare werden hingegen nicht akzeptiert. Allerdings
können Sie eine entsprechende Warnung aktivieren, die auf diese Gefahr
hinweist.

Umlaute werden in Variablennamen nicht toleriert, ebenso nicht das
Dollarzeichen.

@{b}Keywords
--------@{ub}

Grundsätzlich sollten Sie auf den Einsatz der speziellen Keywords möglichst
verzichten - zumindest für Programme, die Sie vielleicht auch einmal auf
ein anderes Betriebssystem oder einen völlig anderen Compiler portieren wollen.

StormC benutzt stärker die in ANSI-C bevorzugten #pragma Anweisungen zur
Anpassung der Software an die speziellen AmigaOS Bedingungen (z.B. #pragma chip
und #pragma fast).

Für Keywords, die auf anderen Compilersystemen vielleicht nicht existieren,
aber auch nicht notwendigerweise benutzt werden müssen, empfiehlt sich die
Verwendung geeigneter Makros, z.B.:

@{b}#define INLINE __inline

#define REG(x) register __##x

#define CHIP __chip@{ub}

Diese Makros können dann einfach den Compilergegebenheiten angepasst werden.

Manche Keywords, die der StormC Compiler nicht kennt, die aber auch nicht notwendig
sind, können auch als Makro definiert werden:

@{b}#define __asm
#define __stdarg@{ub}

Hier folgen die Keywords des SAS/C Compilers und Ihre Interpretation durch
StormC:

@{b}__aligned@{ub}: ist unbekannt. Es gibt keine einfache Möglichkeit, dieses Keyword
zu ersetzen, aber es wird auch nur sehr selten benötigt.

@{b}__chip@{ub}: Dieses Keyword legt ein Datenelement in die Chip-Memory Sektion des
Objektfiles. Beachten Sie jedoch, daß dieses Keyword wie jede Speicherklasse
und andere Qualifier nur vor dem Typ der Deklaration und nicht dahinter stehen
kann:

__chip UWORD NormalImage[] = { 0x0000, .... }; // korrekt

UWORD __chip NormalImage[] = { 0x0000, .... }; // falsch

Die 2. Syntax wird nicht akzeptiert, da sie nicht ANSI-C typisch ist.

In StormC werden "#pragma chip" und "#pragma fast" bevorzugt. Beachten Sie dabei
jedoch, daß __chip sich nur auf eine Deklaration bezieht, "#pragma chip" jedoch
alle folgenden Datenelemente in die Chip Sektion legt, bis zum nächsten
"#pragma fast"

@{b}__far@{ub} und @{b}__near@{ub}: sind unbekannt. Es gibt keine einfache Möglichkeit, diese
Keywords zu ersetzen, aber sie werden nur sehr selten benötigt.

@{b}__interrupt@{ub}: Ist ebenso unter StormC nutzbar, wie Sie es vom SAS/C her
gewohnt sind.

@{b}__asm, __regargs, __stdarg@{ub}: sind unbekannt und werden nicht benötigt. Wenn Sie
Funktionsparameter in Registern übergeben wollen, so sollten Sie die Funktion
mit dem ANSI Keyword "register" deklarieren, oder die Parametern einzeln mit
dem Keyword "register" oder einer genauen Registerspezifikation (z.B.
"register __a0") versehen. Ansonsten werden die Register auf dem Stack
übergeben.

@{b}__saveds@{ub}: Verhält sich ähnlich wie das SAS/C __saveds. Im großen Datenmodell
erzeugt dieses Keyword keinen Code, im kleinen Datenmodell bzgl a4 wird a4
auf den Stack gesichert und mit dem Symbol __LinkerDB geladen, im kleinen
Datenmodell bzgl a6 wird a6 entsprechend behandelt.

Verwenden Sie __saveds nicht leichtfertig. Es sollte ausschließlich für
Funktionen benutzt werden, die von außerhalb Ihres Programms aufgerufen werden,
z.B. Dispatcher von BOOPSI Klassen.

In der jetzigen Compiler Version empfiehlt sich nur die Verwendung des großen
Datenmodells für die Erstellung von shared libraries. Bedenken Sie dabei auch,
daß im kleinen Datenmodell ein weiteres Register für den Optimierer verloren
geht und somit nur noch die Register a0 bis a3 zur Verfügung stehen - der
Vorteil des kleinen Datenmodells kann so sehr schnell verloren gehen, wenn Sie
nicht sehr viele globale Variablen benutzen.

@{b}__inline@{ub}: Dieses Keyword ist ein Funktionsspezifizierer wie die anderen auch.
D.h. Prototypen und Funktionsdefinitionen müssen darin übereinstimmen.

Wenn mehrere Module eine __inline Funktion benutzen wollen, so muß diese
Funktion mit der Definition (also nicht nur der Prototyp) in einer Headerdatei
stehen.

@{b}__stackext@{ub}: ist unbekannt. Stackcheck oder automatische Vergößerung des
Stacks wird derzeit nicht unterstützt.

@{b}Pragmas
-------@{ub}

#pragma libcall, #pragma tagcall, #pragma flibcall: Obwohl diese SAS/C pragmas
unterstützt sind, werden die StormC Pragmas #pragma amicall und #pragma tagcall
bevorzugt. Deren Syntax ist flexibler und leichter lesbar.

Der Linker erzeugt aus der FD Datei, die die Funktionen einer shared library
beschreibt, automatisch eine passende Headerdatei mit den benötigten
#pragma amicall und #pragma tagcall Anweisungen.

@EndNode


@Node "ST_Q&A" "StormC.guide/STC_Project"
@Next "ST_ARexx"
@Prev "STC2_Project"
@Toc "Main"

Die Häufigsten Fragen und ihre Antworten!
*****************************************

Frage 1:
********
@{b}Warum hat StormC keinen "Global Optimizer"?@{ub}

Antwort:

Ein "Global Optimizer" optimiert ein Programm unter Beachtung der
ganzen Funktion und nicht nur einzelner Anweisungen oder Ausdrücke.
Dadurch kann ein Global Optimizer z.B. Ausdrücke, die in einer
Schleife ausgewertet werden, aber in jedem Scheifendurchlauf immer
das gleiche Ergebnis liefern müssen, aus der Schleife herausziehen
und schon vor der Schleife bearbeiten.

StormC kann diese globale Optimierung bislang nicht, ist allerdings
schon in Version 1 dazu vorbereitet, in einer der nächsten Versionen
auch diese Optimierung zu beherrschen.

Allerdings kann StormC schon jetzt einige Optimierungen, die auch
Aufgaben des Global Optimizers sind. Dazu gehört insbesondere die
globale CPU und FPU Registerverteilung in den höheren Optimierungs-
stufen. Die Register werden in der ganzen Funktion unter Beachtung
aller Variablenzuweisungen  und Funktionsaufrufe in der Funktion
optimal verteilt.

Frage 2:
********

@{b}Warum ist selbst ein kleines Programm wie "Hello World" gleich
mehrere KBytes lang?@{ub}

Antwort:

Die mitgelieferte StormC Bibliothek "storm.lib" ist eine ANSI C
Bibliothek.

Für ein "Hello World" Programm muß aus dieser Bibliothek die "printf"
Funktion gelinkt werden. Dadurch kommen aber auch unbenutzte
Funktionen z.B. für die Ausgabe von Integer und Fließkommazahlen ins
Programm, da aus dem "printf" Befehl nicht ersichtlich ist, welche
der Umwandlungen nötig sind. Außerdem werden alle Ausgaben in Dateien
gepuffert durchgeführt.

Dadurch werden auch kurze Programm relativ groß.

Benutzen Sie bitte für ANSI-C-Programm unsere mitgelieferte
"stormamiga.lib"

Frage 3:
********
@{b}Wie kann ich denn ein "Hello World" Programm unter Nutzung der
Storm.Lib wirklich kurz kompilieren?@{ub}

Antwort:

Kann man auf Fließkommaausgabe verzichten und reicht einem die
Pufferung des AmigaDOS aus, kann man jederzeit zur Ausgabe das
AmigaDOS direkt verwenden. Die Funktionen "VPrintf" und "VFPrintf"
ermöglichen nämlich direkt die Ausgabe ähnlich wie "printf" auf
AmigaDOS Dateien. Allerdings sind diese Funktionen nicht 100% ANSI
kompatibel.

Weitere Möglichkeiten bietet natürlich der Verzicht auf das auto-
matische Öffnen und Schließen der Bibliotheken, denn die dazu
benutzten Funktionen bieten eine komfortable Fehlermeldungsausgabe
mit Unterscheidung zwischen Workbench und CLI Start eines Programms
und Beachtung alter Betriebssystemversionen 1.3 und älter. Dieser
Komfort ist nicht für jedes Programm notwendig.

Man kann einen Minimalstartupcode, den man in Assembler schreibt als
eigenen Startupcode benutzen und darin nur die notwendigsten Arbeiten
erledigen, z.B. das kleine Datenmodell unterstützen ohne gleichzeitig
residente Programme zu erlauben.

Frage 4:
********
@{b}Warum kompiliert der MaxonC++ Compiler schneller als StormC?@{ub}

Antwort:

StormC erzeugt sauberen optimierten Code mit optimaler Registerbe-
nutzung und vielfältigen Optimierungen. Außerdem ist StormC konsequent
auf den PowerPC vorbereitet und verzichtet deshalb auf den Einsatz
schneller aber fehleranfälliger Assemblerroutinen. Leider ist darum
die derzeitige Version des Compilers nicht so schnell wie MaxonC++,
allerdings arbeiten wir an einer speziellen Optimierzerstufe für die
Entwicklungsphase eines Programms mit noch kürzeren Übersetzungszeiten.

Frage 5:
********
@{b}Warum ist die Bibliothek "storm.lib" so groß und warum gibt es im
Gegensatz zu SAS/C nur eine Bibliothek?@{ub}

Antwort:

StormC unterstützt ein weiterentwickeltes Objektformat, das auch bei
Linkerbibliotheken zum Einsatz kommt. Dieses Format ist 100%
kompatibel zum alten (sowohl aufwärts, wie auch abwärts), allerdings
können der StormC Linker und der StormC Compiler mit diesem Format
mehrere Datenmodelle in einer Objektdatei aufnehmen. Damit bleibt
für Sie nicht mehr die fehleranfällige Auswahl der richtigen
Bibliothek zu ihren gewählten Compileroptionen, sondern der Linker
wählt aus der großen Bibliothek "storm.lib" die Teile aus, die für
das gewählte Datenmodell (großes Datenmodell oder eines der beiden
kleinen Datenmodelle) gerade paßt. Deshalb ist die "storm.lib" etwa
so groß, wie drei einzelne Bibliotheken für jedes Datenmodell
zusammen.

In Zukunft wird StormC auch noch verschiedene Codemodelle und CPU
bzw. FPU Modelle in der Bibliothek unterstützen, sodaß die
"storm.lib" und alle weiteren Bibliotheken jeweils optimale
Programmeerzeugung automatisch erlauben.

Frage 6:
********
@{b}Warum kommt es zu der Linker-Fehlermeldung "Symbol _exit nicht
definiert", wenn man als Shared-Library linkt?@{ub}

Antwort:

Die Shared-Library ruft die ANSI-Funktion exit() auf. Das kann sie
zum einen explizit, weil Sie diese Funktion verwenden, oder zum
anderen implitzit durch Linker-Bibliotheken, die diese Funktion
verwenden. Die "Storm.Lib" nutzt diese Funktion beim automatischen
Öffnen der benutzten Shared-Libraries, z.B. der "utility.library".

Grundsätzlich darf aber eine Shared-Library die Funktion exit() nicht
verwenden, da sie nicht einfach so beendet werden kann.

Wie vermeidet man den Aufruf?

Man darf das automatische Öffnen von benutzten Shared-Libraries nicht
verwenden, sondern muß die Bibliotheken wie im Handbuch beschrieben,
öffnen und schließen.

Um herauszufinden, welche Bibliotheken alle benutzt werden, sollte
man zuerst eine Funktion:

void exit() {} in die Shared-Library aufnehmen. Jetzt läßt sich die
Library linken.

Verwenden Sie die Linker-Option "Map-Datei schreiben". Der Linker
erzeugt eine Datei mit der Endung ".map". Suchen Sie alle INIT-
Funktionen, die den Basisnamen einer Shared-Library enthalten,
z.B. INIT_1_UtilityBase.

Öffnen Sie diese Bibliotheken nun alle mit Ihren eigenen Routinen.
Denken Sie auch daran, die entsprechende Basisvariable (z.B.
UtilityBase) selbst zu deklarieren. Vergessen Sie nicht, die eigene
exit()-Funktion wieder aus Ihrem Source zu entfernen.

@EndNode

@Node "ST_ARexx" "StormC.guide/STC_Project"
@Next "ST_Lizenz"
@Prev "ST_Q&A"
@Toc "Main"

@{b}ARexx Befehle der StormC Umgebung
---------------------------------@{ub}

Die ARexx Schnittstelle enthält die Befehle, die auch in StormC selbst
benötigt werden. Eine "Fernsteuerung" oder Erweiterung um neue Features
ist nur bedingt möglich.

@{b}1. StormShell:
--------------@{ub}

Die meisten Befehle beziehen sich auf das aktive Projekt.


@{b}NEW@{ub}

Öffnet ein neues Projekt und lädt das Projekttemplate ("PROGDIR:template.¶").


@{b}OPEN@{ub}

Öffnet einen Filerequester zur Auswahl eines bestehenden Projekts und öffnet
dieses Projekt.


@{b}SAVE@{ub}

Sichert das aktive Projekt.


@{b}ADDFILE FILE@{ub}

Fügt dem aktuellen Projekt eine Datei hinzu. Die Sektion der Datei wird durch
das Suffix der Datei automatisch gewählt. Wird der Parameter FILE nicht
gesetzt, wird ein Filerequester geöffnet.


@{b}COMPILE FILE@{ub}

Kompiliert die Datei FILE des aktuellen Projekts. Wird die Datei nicht
abgegeben, so wird die selektierte Datei kompiliert. Ist die angegebene
Datei im Projekt nicht enthalten, so wird eine Fehlermeldung ausgegeben.


@{b}MAKE FORCE/S@{ub}

Kompiliert das Projekt mit den Abhängigkeiten. Ist der Parameter FORCE gesetzt,
werden alle Dateien neu kompiliert ( = Make All).


@{b}MAKEALL@{ub}

Entspricht MAKE FORCE.


@{b}MAKEHIERARCHICAL@{ub} (seit Version 2.0)

Kompiliert das Projekt mit den Abhängigkeiten und alle im Projekt eingebetteten
Projekte.


@{b}MAKEALLHIERARCHICAL@{ub} (seit Version 2.0)

Kompiliert alle Dateien des Projekts und alle Dateien aller eingebetteten
Projekte.


@{b}RUN@{ub}

Startet das Programm des Projekts in der Runshell.


@{b}DEBUG@{ub}

Debuggt das Program des Projekts in der Runshell.


@{b}ABOUT@{ub}

Öffnet das Aboutfenster.


@{b}QUIT@{ub}

Beendet StormC. Dadurch werden auch alle anderen Programmteile beendet.


@{b}ERRORMESSAGES@{ub}

Öffnet das Fehlerfenster.


@{b}NEXTERROR SAMELINE/S,SAMEFILE/S@{ub} (seit Version 2.0)

Zeigt den nächsten Fehler im Editor an. Mit SAMELINE wird auch ein nächster
Fehler angezeigt, der in der gleichen Quelltextzeile liegt, sonst wird ein
Fehler mit anderer Zeilennummer gesucht. Mit SAMEFILE werden nur die Fehler
aus der gleichen Quelltextdatei angezeigt.


@{b}PREVERROR SAMELINE/S,SAMEFILE/S@{ub} (seit Version 2.0)

Zeigt den vorhergehenden Fehler im Editor an. Mit SAMELINE wird auch ein
vorhergehender Fehler angezeigt, der in der gleichen Quelltextzeile liegt,
sonst wird ein Fehler mit anderer Zeilennummer gesucht. Mit SAMEFILE werden
nur die Fehler aus der gleichen Quelltextdatei angezeigt.


@{b}2. StormRun:
------------@{ub}

@{b}SETBPOINT FILE/A,LINE/N@{ub}

Setzt einen Breakpoint in der angegebenen Datei in der angegebenen Zeile.


@{b}GO@{ub}

Das Programm läuft bis zum nächsten Breakpoint (oder Ende).


@{b}SINGLESTEP@{ub}

Das Programm läuft einen Schritt.


@{b}STEPOVER@{ub}

Das Programm läuft einen Schritt, aber Funktionen werden schnell abgearbeitet.


@{b}GOTORTS@{ub}

Das Programm läuft in einzelnen Schritten bis zum Ende der Funktion, aber
Funktionsaufrufe werden schnell abgearbeitet.


@{b}SHOWPC@{ub}

Der aktuelle PC wird im Editor (und evtl. Disassembler) angezeigt.


@{b}SEARCHADDRESS@{ub}

Öffnet den Requester zur Suche einer Programmadresse im Quelltext.


@{b}MODULESWINDOW@{ub}

Öffnet das Fenster mit der Modulliste.


@{b}VARIABLESWINDOW@{ub}

Öffnet das Variablenfenster.


@{b}HISTORYWINDOW@{ub}

Öffnet das Fenster mit der History.


@{b}BREAKPOINTWINDOW@{ub}

Öffnet das Fenster mit allen gesetzten Breakpoints.


@{b}HEXWINDOW@{ub}

Öffnet den Hexeditor.


@{b}PROFILERWINDOW@{ub} (seit Version 2.0)

Öffnet das Profilerprotokollfenster.


@{b}DISASSEMBLERWINDOW@{ub} (seit Version 2.0)

Öffnet das Disassemblerfenster.


@{b}STACKWINDOW@{ub} (seit Version 2.0)

Öffnet das Stackfenster mit allen geschachtelten Funktionsaufrufen.


@{b}3. StormED:
-----------@{ub}

@{b}NEW@{ub}

Öffnet ein neues Textfenster.


@{b}OPEN@{ub}

Öffnet einen Filerequester zum Öffnen einer neuen Datei.


@{b}SAVE@{ub}

Sichert die aktuelle Datei.


@{b}EDITTEXT FILE/A,LINE/N,COL/N,PROJECT/K@{ub}

Öffnet die angegeben Datei und plaziert den Cursor auf der angegebenen
Position. Der Parameter PROJECT bezeichnet das Projekt aus dem diese Datei
stammt (und vermerkt eine "Projektzugehörogkeit" zu dieser Datei). Beim
Schließen eines Projekts oder autom. Sichern vor dem Kompilieren werden
dadurch nur noch die betroffenen Dateien geschlossen und gesichert.


@{b}CLOSEPROJECT PROJECT/A@{ub} (seit Version 2.0)

Entfernt die Projektzugehörigkeit einer Datei, die mit EDITTEXT geöffnet
wurde. Wird dadurch die letzte Projektzugehörigkeit entfernt, so wirde der
Text geschlossen. Dadurch kann auch ein Text durch mehrere Projekt geöffnet
werden.


@{b}SAVEPROJECT PROJECT/A@{ub} (seit Version 2.0)

Sichert alle Dateien, die eine Projektzugehörigkeit zu dem angegeben Projekt
besitzen.

@EndNode

@Node "Presse" "StormC.guide/STC_Project"
@Next "ST_Lizenz"
@Prev "ST_Neues2"
@Toc "Main"

@{b}Pressestimmen:@{ub}

Bereits zur Computer 95 war eine Vorversion unseres neuen Compiler-
systems erhältlich. Die verwirklichten Konzepte und eingeflossenen neuen
Innovationen haben auch die Presse überzeugt, wie Sie in einigen
Berichten in den Januar- und Februar-Ausgaben der gängigen Amiga-
Zeitschriften nachlesen können.

Hier nur einige Auszüge:

Amiga Plus 1/96

   Neue Konzepte bei Entwicklung und Qualitätssicherung...
   Die erste Besonderheit ist die Projektverwaltung, die zum ersten
   Mal bei einem solchen Paket nicht aufgesetzt wirkt...

Amiga Magazin 1/96

   Die Projektverwaltung: Endlich einmal ein Tool, das nicht wie ein Klotz
   am Bein wirkt, sondern wirklich nützlich ist.

Amiga Special 2/96

   Ein schneller Compiler, der leistungsstarke Debugger und die komfortable
   Entwicklungsumgebung sind eine interessante Mischung, wenn es sich um
   professionelle Softwareentwicklung handelt...

Amiga Magazin 8/96

   Gut war ihnen nicht gut genug. Haage & Partner hat das Compilerpaket
   StormC überarbeitet und kann mit diversen Neuerungen aufwarten.
   ...
   An dem Compiler wird stets intensiv gearbeitet und Fehler sehr schnell
   behoben. Die bestehenden Verbindungen zu ProDAD und Phase5 zeigen, daß
   Haage & Partner bei Erscheinen des ersten PowerPC Amigas sofort einen
   passenden Compiler präsentieren - mit StormC liegt man also auch in
   Zukunft richtig.

@EndNode
