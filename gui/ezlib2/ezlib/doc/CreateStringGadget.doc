FUNCTION    CreateStringGadget()  -  create a fully spec'ed String gadget

struct Gadget *CreateStringGadget(l_edge, t_edge, flags, activation, len,
				  def_string, id)

	       SHORT l_edge, t_edge;
	       USHORT flags, activation;
	       USHORT len;
	       UBYTE  *def_string;
	       USHORT id;

    This function gives you total control for easily creating nice looking
(sunk into the screen) string gadgets for text entry.  The flags and
activation arguments correspond exactly to the Flags and Activation fields
of a Gadget structure (see the RKM's for more info on what values they can
hold).	You specify the flags and the activation bits you would like, a
length (in pixels), a default string if you want, and an ID.  If you give a
default string, it is placed in the gadget automatically.  The gadget is
set to have the ID you give (make sure that inside each window each gadget
has a unique id).

    As usual, you can specify any flags you want.  Only minimal error
checking is done, so be careful of non-sensical combinations.  The gadget
is entirely dynamically allocated, and sized for the current system font
(GfxBase->DefaultFont to be exact).

    The gadget is limited to 255 characters in length.	The default string
you supply should not exceed this lenth.  If it does, it will be truncated.
If you need to input something longer than 255 characters, it is best to
look for another input method.

    If you want the gadget to be activated automatically when you open your
window this gadget is attatched to, you should set the ACTIVEWINDOW flag on
your window, and then whenever you receive and ACTIVEWINDOW idcmp message,
you can call ActivateGadget() with a pointer to the gadget you get back
from this function (phew, that was one of the longer sentences I have ever
typed! :).

    The string buffer for this gadget is dynamically allocated.  If you
want to save the contents of the buffer, you should allocate space for
another copy, and strcpy() it.  Here is what you would essentially have
to do (assuming buff and save are UBYTE *'s, and gadg was just created) :


 buff = (UBYTE *)( ((struct StringInfo *)gadg->SpecialInfo)->Buffer);
 save = strdup(buff);
 if (save == NULL)
   error_no_mem();


     After you call KillGadget() with a gadget created by this function,
the contents of the string gadget buffer are GONE!

    This function will not add the created gadget to your window.  You must
specifically do that with AddGadget() or if you have already created the
window, look into MakeStringGadget(). See the RKM's for more info on
string gadgets.


    The following example will set up a string gadget at 50,50 and 100
pixels in width (height is automatically figured based on the current
sytem font.  It has an id of 10.  There is no default string in the gadget.


     struct Window *win;      /* assume it was opened earlier */
     struct Gadget *gadg;

     gadg = CreateStringGadget(50,50, GADGHCOMP, RELVERIFY, 100, NULL, 10);
     if (gadg == NULL)
       ackk_no_gadget();

     AddGadget(gadg, win, NULL)
     RefreshGList(gadg, win, NULL, 1);


TODO : not much I don't think....

BUGS : Bugs? In my code -- ha! never. :^)

SEE ALSO : MakeStringGadget(), KillGadget(), MakeBoolGadget(),
	   MakeWindow(), GetString(), GetYN()

