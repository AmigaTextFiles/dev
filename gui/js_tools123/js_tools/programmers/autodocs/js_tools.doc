TABLE OF CONTENTS

js_tools.library/JS_LibInfo
js_tools.library/JS_Sort
js_tools.library/LV_AskListViewAttrs
js_tools.library/LV_CreateExtraListViewA
js_tools.library/LV_CreateListViewA
js_tools.library/LV_FreeListView
js_tools.library/LV_FreeListViews
js_tools.library/LV_GetIMsg
js_tools.library/LV_GetListViewAttrsA
js_tools.library/LV_KeyHandler
js_tools.library/LV_RefreshWindow
js_tools.library/LV_ReplyIMsg
js_tools.library/LV_SetListViewAttrsA
js_tools.library/Xtra: listview tag item overview
js_tools.library/JS_LibInfo			  js_tools.library/JS_LibInfo

   NAME
	JS_LibInfo -- Get some information (strings and numbers) of the
	library

   SYNOPSIS
	information = JS_LibInfo(type);
	D0			 D1

	STRPTR JS_LibInfo ( ULONG type );

   FUNCTION
	Get some information (copyright note, version, etc.) of the library
	e.g.  for an info window of a program (would be nice).
	JSINFO_BOX	   (STRPTR) - a short text for info windows,
				      it may change!
	JSINFO_VERSION	   (STRPTR) - version string of the library,
				      may change in size
	JSINFO_LIBVERSION  (ULONG)  - version
	JSINFO_LIBREVISION (ULONG)  - revision
	JSINFO_DATE	   (STRPTR) - date of compilation

   INPUTS
	type - type of information

   RESULT
	information (D0) - string or simple a ULONG - depents on type

js_tools.library/JS_Sort			     js_tools.library/JS_Sort

   NAME
	JS_Sort -- sorts a node list with quicksort

   SYNOPSIS
	JS_Sort(list, number);
		A0    D0

	void JS_Sort ( struct List *list, LONG number );

   FUNCTION
	Sorts a node list alphabetically case insensitiv and can handle
	locale characters (e.g.  german umlauts) with locale.library.  If
	number is set to 0 the function will count the number of nodes
	itself.  But if you already know them why take this extra time?

   INPUTS
	list - list to sort

	number - number of nodes, if set to 0 JS_Sort() will count itself

js_tools.library/LV_AskListViewAttrs	 js_tools.library/LV_AskListViewAttrs

   NAME
	LV_AskListViewAttrs -- a short way for AskTags

   SYNOPSIS
	data = LV_AskListViewAttrs(gad, win, tag, data);
	D0			   A0	A1   D0   D1

	ULONG LV_AskListViewAttrs ( struct Gadget *gad, struct Window *win,
	    Tag tag, ULONG data );

   FUNCTION
	If you want to get only one parameter from a gadget this is a short
	way to do it.

   INPUTS
	gad - Gadget to get information from

	win - Window of gadget

	tag - AskTag

	data - if required some additional parameter

   RESULT
	data (D0) - result of AskTag

   TAGS
	lv_AskTop (WORD) returns lv_Top in ti_Data field

	lv_AskLines (WORD) number of visible lines in ti_Data

	lv_AskNumber (WORD) number of lines in current list

	lv_AskNode (struct Node*) Selected Node

	lv_IsShown (BOOL) is selected item shown ?

	lv_IsMarked (BOOL) is (struct Node*) in data marked ?

	lv_IsMarkedNr (BOOL) is line in data marked ? Like lv_IsMarked

	lv_MarkedCount (WORD) number of marked lines

	lv_AskHoriz (LONG) get horizontal position of SuperLV - this is the
		only way to get this information (exept you use
		LV_GetListViewAttrsA() with lv_HorizSelected)

	lv_AskHorizMax (LONG) maximal position for lv_AskHoriz, is changed by
		every lv_Lables call

js_tools.library/LV_CreateExtraListViewA

   NAME
	LV_CreateExtraListViewA -- Creates a new extra listview
	(lvExtraWindow)

   SYNOPSIS
	gadget = LV_CreateExtraListViewA(exw, tags);
	D0				 A0   A1

	struct Gadget *LV_CreateExtraListViewA ( struct lvExtraWindow *exw,
	    struct TagItem *tags );

   FUNCTION
	Creates an extra listview gadget.  A ListView will be put in an own
	window.  You may use the return parameter with all js_tools listview
	functions.  It is impossible to add a string gadget with
	lv_ShowSelected.  All results of this listview (selected, etc.) will
	be send to the messageport of the window given in the struct
	lvExtraWindow.	This window has to be opened the hole time the
	lvExtraWindow is open! So if you want to close this window you first
	must close the lvExtraWindows.	The IntuiMessage contains in IAddress
	a pointer to the gadget (as always).  Attention! This is no intuition
	gadget structure! Only the GadgetID and UserData fields have the same
	offset like intuition gadgets! Please look in C includes for struct
	lvExtraWindow.	You must not reply an IntuiMessage of a lvExtraWindow
	after it has been closed (with LV_FreeListView()).

   INPUTS
	exw - lvExtraWindow that contains all required data

	tags - tagitems

   RESULT
	gadget (D0) - gadget pointer to use with other functions, NULL for
		error

   EXAMPLE
	/* Handling IDCMP messages (one way): */
	myMSG=LV_GetIMsg(myWin->UserPort);
	if (myMSG) /* maybe we got a NULL pointer! Use this way ALWAYS. */
	{
	  if (myMSG->IDCMPWindow==myWin)
	  {
	     /* this are IDCMP events for our window */
	     /* put your code here */
	    LV_ReplyIMsg(myMSG);
	  }
	  else
	  {
	    /* this are IDCMP events of the lvExtraWindow */
	    /* look in IAddress for a struct gadget to find out */
	    /* the right lvExtraWindow */
	    /* possibel events: */
	    /*	 IDCMP_CLOSEWINDOW - use LV_FreeListView() to close the */
	    /*			     lvExtraWindow */
	    /*			     after LV_FreeListView() you must not */
	    /*			     use this pointer again, its gone! */
	    /*	 IDCMP_GADGETUP    - same as normal, look in Code field */
	    /*			     for selected item */
	    /*	 IDCMP_RAWKEY	   - pressed key in this window, */
	    /*			     do want you want to do with it */
	    /*	 IDCMP_VANILLAKEY  - do the same as RAWKEY */
	    LV_ReplyIMsg(myMSG);
	    /* reply message before you close the lvExtraWindow ! */
	  }
	}

   SEE ALSO
	CreateListViewA()

   TAGS
	see LV_CreateListViewA()

js_tools.library/LV_CreateListViewA	  js_tools.library/LV_CreateListViewA

   NAME
	LV_CreateListViewA -- Creates a new listview

   SYNOPSIS
	gadget = LV_CreateListViewA(kind, prev, newg, tags);
	D0			    D0	  A0	A1    A2

	struct Gadget *LV_CreateListViewA ( LONG kind, struct Gadget *prev,
	    struct NewGadget *newg, struct TagItem *tags );

   FUNCTION
	Creates a new listview gadget and adds to the prev gadget list.  The
	fields ng_GadgetText and ng_Flags are currently ignored, set to NULL.
	If you want to add a text above, below, left or right of the listview
	use a gadtools TEXT_KIND gadget (you can use the same left & top edge
	and the same width & height, but the TEXT_KIND gadget should have no
	border and no text inside).  If this function was successfull you get
	a pointer to the listview gadget.  The NewGadget.ng_Height field has
	been changed to the real listview height (which could be smaller).
	This height includes an added string gadget (like gadtools).

   INPUTS
	kind - kind of listviews

	prev - previous gadget

	newg - gadtools NewGadget

	tags - tagitems for additional infos

   RESULT
	gadget (D0) - gadget pointer to use with other functions, NULL if
		error

   NOTE
	Requesters are currently not supported

   SEE ALSO
	gadtools/CreateGadgetA()

   TAGS
	lv_Labels (struct List*) like GTLV_Labels - Text to show in struct
		List* or MinList*

	lv_Disabled (BOOL) like GA_Disabled - disables listview - scrolling
		is still possible so the hook could be started!

	lv_ScrollWidth (LONG) like GTLV_ScrollWidth - width of scroller,
		default: 16

	lv_ShowSelected (struct Gadget*) like GTLV_ShowSelected - 0 show
		selected or a pointer to a stringgadget to show it there if
		you use multi columns the struct Node->ln_Name field is still
		used!

	lv_ReadOnly (BOOL) like GTLV_ReadOnly - ListView is readonly

	lv_Spacing (LONG) like LAYOUTA_Spacing - additional free pixel lines
		between each text line (default 0)

	lv_Top (LONG) like GTLV_Top - sets first show line - the real top
		line is returned in ti_Data field

	lv_Selected (LONG) like GTLV_Selected - sets selected line - the real
		selected line is returned in ti_Data

	lv_NewSelected much better select function - selected line is
		automatically shown by as less as possible scrolling the
		listview - the real selected line is returned in ti_Data

	lv_SetMark (LONG) mark a line (0-...)

	lv_ClearMark (LONG) unmark line (0-...) - use "ask tags" to get
		current state of a line

	lv_BlockStart (LONG) mark lines in a block - upper line here

	lv_BlockStop (LONG) mark lines in a block - last line here

	lv_MarkBlock (BOOL) if TRUE block is marked, if FALSE block is
		unmarked

	lv_MarkIsIn (ULONG) mark offset (to struct Node start), BYTE field
		the hole list will be marked/unmarked as set in this offset -
		==1==TRUE means set mark e.g.  OFFSETOF(struct
		myNode,markfield)

	lv_OnlyRead (LONG) number of lines at the end of the list that are
		read only

	lv_Colour (LONG) colour of text in the listview - don't use this
		other or you will confuse user

	lv_Color (LONG) other name for lv_Colour (first is british english)

	lv_NewSelectMode (LONG) set NSM mode for lv_NewSelected:
		NSM_ExtraLine: one line at the listview border is always
			       visible (DEFAULT)
		NSM_Center   : selected is centered
			       (exept at start/end of the list)
		NSM_NoLine   : like good old gadtools ListView
		NSM_FreeLine : like NSM_ExtraLine, but the number of visible
			       lines is set by lv_NewSelectLines tag.
			       If you use this tag it is possible that there
			       are less lines visible this is to minimize
			       scrolling and not confuse the user.

	lv_NewSelectLines (LONG) lines in NSM_FreeLines mode

	lv_OffIsIn (ULONG) offset to lock byte (see lv_MarkIsIn) If byte is
		==1 the current node is locked and can't be selected.  The
		field must exist as long as you use the list, if you change
		it use lv_Redraw to update output.  Tag must be used every
		time lv_Lables is used or locking will be turned of.

	lv_ElseSelected (LONG) if (New)Selected points to a locked line this
		tag specifies what to do: >=0 -> select next line, <= ->
		select prev line (Default: 0) usefull if you program a
		keyboard interface for a listview

	lv_OffColour (LONG) colour of locked text

	lv_OffColor (LONG) other name for lv_OffColour

	lv_xFrontColour (LONG) text colour of marked text if LISTVIEW2_KIND
		is used

	lv_xFrontColor (LONG) other name for lv_xFrontColour

	lv_xBackColour (LONG) background colour of marked text if
		LISTVIEW2_KIND is used

	lv_xBackColor (LONG) right, other name for lv_xBackColour

	lv_Hook (struct Hook*) pointer to Hook.  The Hook will get a struct
		lvData in A2.  Please look in C includes for description of
		struct lvData.

	lv_Notick (BOOL) do not send IDCMP_INTUITICKS if they are already
		used by listview (Default: TRUE)

	lv_AlwaysMark (BOOL) the default way to mark a line is to press SHIFT
		key while selecting if this tag is TRUE lines are always
		marked - also if SHIFT isn't pressed - lv_MarkOn tag must be
		TRUE, too!

	lv_MarkOn (BOOL) turns on mark mode, so the user can mark lines if
		not turned on only the program may mark a line (so SHIFT is
		ignored) - default: FALSE

	lv_SuperListView (BOOL) make Super ListView (TRUE) - i.e.  it may
		scroll horizontal - default: FALSE It has some things in
		common with intuitions Super Bitmap Windows.  ATTENTION! This
		kind of listview isn't that fast - so use it only for small
		listviews.  If there is less chip ram it falls back to a
		normal listview! Currently it is impossible to use a Super
		Listview in lvExtraWindows!

	lv_ScrollHeight (LONG) Height of horizontal scroller (see
		lv_ScrollWidth), Default: lv_ScrollWidth-(lv_ScrollWidth/3)

	lv_HorizSelected (LONG) Horizontal position in pixel (first is 0)

	lv_HorizScroll (LONG) pixels to scroll if mouse if moved left or
		right out of the listview (Default: 4).

	lv_Private1 (LONG) private tagitem, do not use

	lv_ColumnData (struct ColumnData*) pointer to a ColumnData array.
		Listviews may have more than one column.  Each column is
		represented by one struct ColumnData that contains its width,
		where is starts, Text adjustment and an offset to the text in
		each Node (see lv_MarkIsIn).  Field ln_Name of the struct
		Node is not shown so you must add a ColumnData for it, too.
		But it is shown in an added string gadget.  To end the array
		simply add a ColumnData with all fields set to 0 (NULL).  The
		array has to be sorted by size of start - smallest first.
		Please look in C includes for details of struct ColumnData.

	lv_FormatText (STRPTR) Text (+0 byte) that will be fit optimal in the
		listview - replacement for lv_Labels.  Column mode will be
		deactivated, this tag should be used in readonly listviews.
		You can start a new paragraph with ASCII#10 (Linefeed, \n).
		lvExtraWindow update text form every time it is resized.  In
		lvExtraWindow the text string must be available the hole time
		it is applied to the listview!! In normal listviews the text
		string has to be available until LV_RefreshWindow() is called
		because graphics/TextFit() needs a RastPort which is not
		before this call set.  This may change.

	lv_AfterHook (struct Hook*) pointer to Hook.  The hook will get a
		struct lvData in A2.  This hook will be started after a line
		has been print out.  Please look in C includes for
		description of struct lvData.

js_tools.library/LV_FreeListView	     js_tools.library/LV_FreeListView

   NAME
	LV_FreeListView -- frees a listview

   SYNOPSIS
	LV_FreeListView(gadget, prev);
			D0	A0

	void LV_FreeListView ( LONG gadget, struct Gadget *prev );

   FUNCTION
	Frees all required memory of a listview gadget (and closes
	lvExtraWindows).  If you have only 1 or 2 litsviews in your window
	use this function - it is a little bit faster than LV_FreeListViews()
	because it doesn't go through the hole gadget list.

   INPUTS
	gadget - kind of listviews

	prev - listview gadget to free

   WARNING
	Use only if the complete gadget list is removed from your window
	(after closing or so).

js_tools.library/LV_FreeListViews	    js_tools.library/LV_FreeListViews

   NAME
	LV_FreeListViews -- frees all listviews in a gadget list

   SYNOPSIS
	LV_FreeListViews(gadgetlist);
			 A0

	void LV_FreeListViews ( struct Gadget *gadgetlist );

   FUNCTION
	Frees all listview gadgets in the list of gadgets, does not close
	lvExtraWindows.  You have to use LV_FreeListView() to do this.

   INPUTS
	gadgetlist - gadgets

   NOTE
	use this BEFORE gadtools/FreeGadgets

   EXAMPLE
	CloseWindow(mywin);
	LV_FreeListView(glp);
	FreeGadgets(glp);

   SEE ALSO
	LV_FreeListView(),gadtools/FreeGadgets()

js_tools.library/LV_GetIMsg			  js_tools.library/LV_GetIMsg

   NAME
	LV_GetIMsg -- get IntuiMessage

   SYNOPSIS
	intuimessage = LV_GetIMsg(msgport);
	D0			  A0

	struct IntuiMessage *LV_GetIMsg ( struct MsgPort *msgport );

   FUNCTION
	Gets a manipulated IntuiMessage of the given message port.  If this
	message is only for the listview or gadtools the result is NULL.  Use
	LV_ReplyIMsg() to reply! If multiselection (marking by user) is
	enabled and the user used it the Qualifier field contains
	MARK_QUALIFIER_SET or MARK_QUALIFIER_CLEAR, MouseX the top and MouseY
	the bottom of the selected area.

   INPUTS
	msgport - Message Port of a window

   RESULT
	intuimessage (D0) - IntuiMessage with IDCMP or NULL if no message to
		get

   NOTE
	Simply replace GT_GetIMsg() in your programs.  You needn't have any
	listview in this window if you use LV_GetIMsg().

   SEE ALSO
	gadtools/GT_GetIMsg()

   WARNING
	You MUST reply a message you got with LV_GetIMsg() with
	LV_ReplyIMSG()!

js_tools.library/LV_GetListViewAttrsA	js_tools.library/LV_GetListViewAttrsA

   NAME
	LV_GetListViewAttrsA -- get listview gadget attributes

   SYNOPSIS
	count = LV_GetListViewAttrsA(gad, win, req);
	D0			     A0   A1   A2

	LONG LV_GetListViewAttrsA ( struct Gadget *gad, struct Window *win,
	    struct Requester *req );

   FUNCTION
	gets listview gadget attributes.  Put in the ti_Data field a pointer
	to ULONG variables in which the information will be written.

   INPUTS
	gad - listview gadget to manipulate

	win - window of listview gadget

	req - requester of listview gadget (NULL)

   RESULT
	count (D0) - number of information put into the variables

   NOTE
	Requesters are currently not supported

   TAGS
	please look in LV_CreateListViewA, LV_SetListViewAttrsA(),
		lv_AskListViewAttrs() and in tagitems overview at the end.

   SEE ALSO
	gadtools/GT_GetGadgetAttrsA()

js_tools.library/LV_KeyHandler		       js_tools.library/LV_KeyHandler

   NAME
	LV_KeyHandler -- handles keys from user for listview

   SYNOPSIS
	char = LV_KeyHandler(gad, im, key, tags);
	D0		     A0   A1  D0   A2

	WORD LV_KeyHandler ( struct Gadget *gad, struct IntuiMessage *im,
	    char key, struct TagItem *tags );

   FUNCTION
	Handles keys in IntuiMessages in an optimal way for a listview
	gadget.  Specify in "key" the character for the listview (the
	underlined one in the gadget text) in lower case (important if you
	use local characters like umlauts!) or 0 if you allow cursor keys.
	If you only have one listview in a window then the cursor keys are
	the better choice because the user may use them more intuitiv.	The
	IntuiMessage must be of IDCMP class RAWKEY, if the character isn't
	used for the listview you will get the ASCII value of the key as
	result (0 if no ASCII conversion if possible) or -1 if the key has
	been used for the listview.  Don't use such keys again to avoid
	caonfusion of the user.  Simply put item "lv_Selected" in the taglist
	to get the news selected item.	It's save to call this function with
	a NULL gadget pointer simply to get the ASCII code of a RAWKEY.

	Keys work this way (if key==some character):
	 without qualifier: down
	 with SHIFT	  : up
	 with ALT	  : last item
	 with ALT + SHIFT : first item
	 with CONTROL	  : mark/unmark selected item (if marking allowed)
	  (pressed SHIFT allowed)

	If cursor key mode if selected (key==0):
	 cursor_down	  : down
	 cursor_up	  : up
	 with SHIFT	  : one page up/down
	 with ALT	  : first/last item
	 with CONTROL	  : -nothing-
	 SPACE		  : mark/unmark selected item (if marking allowed)

	These keys may be user selectable in later versions.  The AlwaysMark
	mode is ignored if you move around by keyboard.

   INPUTS
	gad - listview gadget

	im - IntuiMessage wih the key

	key - listview's key or 0 if cursor keys

	tags - tagitems given to LV_GetListViewAttrsA()

   RESULT
	char (D0) - ASCII character of the press or released (!) key, 0 if no
		ASCII key, negative if used for listview

   TAGS
	see LV_GetListViewAttrsA()

   SEE ALSO
	LV_GetListViewAttrsA()

   NOTE
	Currently the only way to see if the selected item has been marked is
	to use an AskTag after calling this function.

   WARNING
	Result is negative if key is used for listview, this is not equal
	(-1)!

   BUGS
	Before library release 236 chars > 127 were returned negative.

	Before library release 233 key release was handled wrong.

	Before library release 229 tagitems were not updated because
	LV_GetListViewAttrsA() was not called by LV_KeyHandler().

	Before library release 224 pragma file in C includes were wrong
	(tagitems were missing).

   EXAMPLE
	/*
	 * a short part how to use this function
	 */
	 my_MSG=LV_GetIMsg(mywin->UserPort);
	 if (my_MSG)
	 {
	   WORD key;
	   if (my_MSG->Class==IDCMP_RAWKEY)
	   {
	     struct TagItem ti[2]={
			    {lv_Selected,0},
			    {TAG_DONE,}};
	     key=LV_HandleKey(mylvgg,my_MSG,0,&ti);
	     if (key<0) /* see! (key<0) */
	     {
	       BOOL marked;
	       marked=(BOOL)
		 AskListViewAttrs(mylvgg,lv_IsMarkedNr,ti[0].ti_Data);
	       /*
		* now your code to handle a new selected item
		* (could be found in ti[0].ti_Data) and/or marking
		* a line (marked==TRUE)
		*/
	     }
	     else
	     {
	       /* other code to handle pressed keys */
	     }
	   }
	   /* more code for other IDCMP classes */
	   LV_ReplyIMsg(my_MSG);
	 }

js_tools.library/LV_RefreshWindow	    js_tools.library/LV_RefreshWindow

   NAME
	LV_RefreshWindow -- Refresh Listview gadgets

   SYNOPSIS
	LV_RefreshWindow(Window, Requester);
			 A0	 A1

	void LV_RefreshWindow ( struct Window *Window, struct Requester
	    *Requester );

   FUNCTION
	Updates Listviews (e.g.  in simple refresh windows) and calls
	GT_RefreshWindow().

   INPUTS
	Window - window of listviews to refresh

	Requester - requester of listviews (NULL)

   NOTE
	Requesters are currently not supported - set to NULL

   SEE ALSO
	gadtools/GT_RefreshWindow()

js_tools.library/LV_ReplyIMsg			js_tools.library/LV_ReplyIMsg

   NAME
	LV_ReplyIMsg -- replys IntuiMessage of LV_GetIMsg()

   SYNOPSIS
	LV_ReplyIMsg(msg);
		     A1

	void LV_ReplyIMsg ( struct IntuiMessage *msg );

   FUNCTION
	Replys a message of LV_GetIMsg().  Do not use some different way!

   INPUTS
	msg - IntuiMessage to reply

   NOTE
	It is save to give a NULL pointer as IntuiMessage!

	Simply replace GT_ReplyIMsg() in your programs.  You needn't have any
	listview in this window.

   SEE ALSO
	gadtools/GT_ReplyIMsg()

   WARNING
	Do not try to reply a message you didn't get with LV_GetIMsg() with
	this.

js_tools.library/LV_SetListViewAttrsA	js_tools.library/LV_SetListViewAttrsA

   NAME
	LV_SetListViewAttrsA -- set listview gadget attributes

   SYNOPSIS
	LV_SetListViewAttrsA(gad, win, req, tags);
			     A0   A1   A2   A3

	void LV_SetListViewAttrsA ( struct Gadget *gad, struct Window *win,
	    struct Requester *req, struct TagItem *tags );

   FUNCTION
	sets listview gadgets attributes with the given tagitems and refreshs
	it

   INPUTS
	gad - listview gadget to manipulate

	win - window of listview gadget

	req - requester of listview gadget (NULL)

	tags - tagitems for additional infos

   NOTE
	Requesters are currently not supported

   TAGS
	lv_Labels (struct List*) like GTLV_Labels - Text to show in struct
		List* or MinList*

	lv_Disabled (BOOL) like GA_Disabled - disables listview - scrolling
		is still possible so the hook could be started!

	lv_Top (LONG) like GTLV_Top - sets first show line - the real top
		line is returned in ti_Data field

	lv_Selected (LONG) like GTLV_Selected - sets selected line - the real
		selected line is returned in ti_Data

	lv_NewSelected (LONG) much better select function - selected line is
		automatically shown by as less as possible scrolling the
		listview - the real selected line is returned in ti_Data

	lv_SetMark (LONG) mark a line (0-...)

	lv_ClearMark (LONG) unmark line (0-...) - use "ask tags" to get
		current state of a line

	lv_BlockStart (LONG) mark lines in a block - upper line here

	lv_BlockStop (LONG) mark lines in a block - last line here

	lv_MarkBlock (BOOL) if TRUE block is marked, if FALSE block is
		unmarked

	lv_MarkIsIn (ULONG) mark offset (to struct Node start), BYTE field
		the hole list will be marked/unmarked as set in this offset -
		==1==TRUE means set mark e.g.  OFFSETOF(struct
		myNode,markfield)

	lv_OnlyRead (LONG) number of lines at the end of the list that are
		read only

	lv_Colour (LONG) colour of text in the listview - don't use this
		other or you will confuse user

	lv_Color (LONG) other name for lv_Colour (first is british english)

	lv_NewSelectMode (LONG) set NSM mode for lv_NewSelected:
		NSM_ExtraLine: one line at the listview border is always
			       visible (DEFAULT)
		NSM_Center   : selected is centered
			       (exept at start/end of the list)
		NSM_NoLine   : like good old gadtools ListView
		NSM_FreeLine : like NSM_ExtraLine, but the number of visible
			       lines is set by lv_NewSelectLines tag.
			       If you use this tag it is possible that there
			       are less lines visible this is to minimize
			       scrolling and not confuse the user.

	lv_NewSelectLines (LONG) lines in NSM_FreeLines mode

	lv_SetFont (struct TextAttr*) change font of listview ATTENTION!
		ta_YSize must be the same! lv_Redraw (or lv_Labels) must be
		in tag list!

	lv_Redraw (BOOL) redraw text of listview it is allowed to change
		ln_Name field, so use this tag to update the output

	lv_OffIsIn (ULONG) offset to lock byte (see lv_MarkIsIn) If byte is
		==1 the current node is locked and can't be selected.  The
		field must exist as long as you use the list, if you change
		it use lv_Redraw to update output.  Tag must be used every
		time lv_Lables is used or locking will be turned of.

	lv_ElseSelected (LONG) if (New)Selected points to a locked line this
		tag specifies what to do: >=0 -> select next line, <= ->
		select prev line (Default: 0) usefull if you program a
		keyboard interface for a listview

	lv_OffColour (LONG) colour of locked text

	lv_OffColor (LONG) other name for lv_OffColour

	lv_NewKind (LONG) change listview kind (for different mark colours)

	lv_xFrontColour (LONG) text colour of marked text if LISTVIEW2_KIND
		is used

	lv_xFrontColor (LONG) other name for lv_xFrontColour

	lv_xBackColour (LONG) background colour of marked text if
		LISTVIEW2_KIND is used

	lv_xBackColor (LONG) right, other name for lv_xBackColour

	lv_Hook (struct Hook*) pointer to Hook.  The Hook will get a struct
		lvData in A2.  Please look in C includes for description of
		struct lvData.

	lv_AlwaysMark (BOOL) the default way to mark a line is to press SHIFT
		key while selecting if this tag is TRUE lines are always
		marked - also if SHIFT isn't pressed - lv_MarkOn tag must be
		TRUE, too!

	lv_MarkOn (BOOL) turns on mark mode, so the user can mark lines if
		not turned on only the program may mark a line (so SHIFT is
		ignored) - default: FALSE

	lv_HorizSelected (LONG) Horizontal position in pixel (first is 0)

	lv_HorizScroll (LONG) pixels to scroll if mouse if moved left or
		right out of the listview (Default: 4).

	lv_FormatText (STRPTR) Text (+0 byte) that will be fit optimal in the
		listview - replacement for lv_Labels.  Column mode will be
		deactivated, this tag should be used in readonly listviews.
		You can start a new paragraph with ASCII#10 (Linefeed, \n).
		lvExtraWindow update text form every time it is resized.  In
		lvExtraWindow the text string must be available the hole time
		it is applied to the listview!! In normal listviews the text
		string has to be available until LV_RefreshWindow() is called
		because graphics/TextFit() needs a RastPort which is not
		before this call set.  This may change.

	lv_AfterHook (struct Hook*) pointer to Hook.  The hook will get a
		struct lvData in A2.  This hook will be started after a line
		has been print out.  Please look in C includes for
		description of struct lvData.

	lv_AskTop (WORD) returns lv_Top in ti_Data field

	lv_AskLines (WORD) number of visible lines in ti_Data

	lv_AskNumber (WORD) number of lines in current list in ti_Data

	lv_AskNode (struct Node*) Selected Node in ti_Data

	lv_IsShown (BOOL) is selected item shown ? in ti_Data

	lv_IsMarked (struct Node* -> BOOL) is (struct Node*) in ti_Data
		marked ? in ti_Data Set ti_Data to the node you want to known
		this, call the library and look in ti_Data for result.

	lv_IsMarkedNr (LONG -> BOOL) is line in ti_Data marked ? Like
		lv_IsMarked

	lv_MarkedCount (WORD) number of marked lines in ti_Data

	lv_AskHoriz (LONG) get horizontal position of SuperLV in ti_Data -
		this is the only way to get this information (exept you use
		LV_GetListViewAttrsA() with lv_HorizSelected)

	lv_AskHorizMax (LONG) maximal position for lv_AskHoriz, is changed by
		every lv_Lables call

   SEE ALSO
	gadtools/GT_SetGadgetAttrsA()

js_tools.library/Xtra: listview tag item overview

   NAME
	Xtra: listview tag item overview -- listview tag item overview

   SYNOPSIS
	Xtra: listview tag item overview();


	void Xtra: listview tag item overview (void);

   FUNCTION
	All tags for the listview.  Tags may be used in [C]reate, [S]et,
	[G]et, e[X]clusiv if tag lv_Redraw also has to be used, or in
	[A]skListViewAttrs().  These [A]sk tags can also be used in [S]et or
	[G]et and return their results in ti_Data field.  Some of them must
	have a start parameter in ti_Data set!

   TAGS
	lv_Labels (struct List*) [CSG] like GTLV_Labels - Text to show in
		struct List* or MinList*

	lv_Disabled (BOOL) [CSG] like GA_Disabled - disables listview -
		scrolling is still possible so the hook could be started!

	lv_ScrollWidth (LONG) [C..] like GTLV_ScrollWidth - width of
		scroller, default: 16

	lv_ShowSelected (struct Gadget*) [C..] like GTLV_ShowSelected - 0
		show selected or a pointer to a stringgadget to show it there
		if you use multi columns the struct Node->ln_Name field is
		still used!

	lv_ReadOnly (BOOL) [C..] like GTLV_ReadOnly - ListView is readonly

	lv_Spacing (LONG) [C..] like LAYOUTA_Spacing - additional free pixel
		lines between each text line (default 0)

	lv_Top (LONG) [CSG] like GTLV_Top - sets first show line - the real
		top line is returned in ti_Data field

	lv_Selected (LONG) [CSG] like GTLV_Selected - sets selected line -
		the real selected line is returned in ti_Data

	lv_NewSelected (LONG) [CSG] much better select function - selected
		line is automatically shown by as less as possible scrolling
		the listview - the real selected line is returned in ti_Data

	lv_Obsolete1 (LONG) [...] obsolete do not use!

	lv_SetMark (LONG) [CS.] mark a line (0-...)

	lv_ClearMark (LONG) [CS.] unmark line (0-...) - use "ask tags" to get
		current state of a line

	lv_BlockStart (LONG) [CS.] mark lines in a block - upper line here

	lv_BlockStop (LONG) [CS.] mark lines in a block - last line here

	lv_MarkBlock (BOOL) [CS.] if TRUE block is marked, if FALSE block is
		unmarked

	lv_MarkIsIn (ULONG) [CS.] mark offset (to struct Node start), BYTE
		field the hole list will be marked/unmarked as set in this
		offset - ==1==TRUE means set mark e.g.	OFFSETOF(struct
		myNode,markfield)

	lv_OnlyRead (LONG) [CS.] number of lines at the end of the list that
		are read only

	lv_Colour (LONG) [CSG] colour of text in the listview - don't use
		this other or you will confuse user

	lv_Color (LONG) [CSG] other name for lv_Colour (first is british
		english)

	lv_NewSelectMode (LONG) [CSG] set NSM mode for lv_NewSelected:
		NSM_ExtraLine: one line at the listview border is always
			       visible (DEFAULT)
		NSM_Center   : selected is centered
			       (exept at start/end of the list)
		NSM_NoLine   : like good old gadtools ListView
		NSM_FreeLine : like NSM_ExtraLine, but the number of visible
			       lines is set by lv_NewSelectLines tag.
			       If you use this tag it is possible that there
			       are less lines visible this is to minimize
			       scrolling and not confuse the user.

	lv_NewSelectLines (LONG) [CSG] lines in NSM_FreeLines mode

	lv_SetFont (struct TextAttr*) [.X.] change font of listview
		ATTENTION! ta_YSize must be the same! lv_Redraw (or
		lv_Labels) must be in tag list!

	lv_Redraw (BOOL) [.S.] redraw text of listview it is allowed to
		change ln_Name field, so use this tag to update the output

	lv_OffIsIn (ULONG) [CSG] offset to lock byte (see lv_MarkIsIn) If
		byte is ==1 the current node is locked and can't be selected.
		The field must exist as long as you use the list, if you
		change it use lv_Redraw to update output.  Tag must be used
		every time lv_Lables is used or locking will be turned of.

	lv_ElseSelected (LONG) [CS.] if (New)Selected points to a locked line
		this tag specifies what to do: >=0 -> select next line, <= ->
		select prev line (Default: 0) usefull if you program a
		keyboard interface for a listview

	lv_OffColour (LONG) [CSG] colour of locked text

	lv_OffColor (LONG) [CSG] other name for lv_OffColour

	lv_NewKind (LONG) [.SG] change listview kind (for different mark
		colours)

	lv_xFrontColour (LONG) [CSG] text colour of marked text if
		LISTVIEW2_KIND is used

	lv_xFrontColor (LONG) [CSG] other name for lv_xFrontColour

	lv_xBackColour (LONG) [CSG] background colour of marked text if
		LISTVIEW2_KIND is used

	lv_xBackColor (LONG) [CSG] right, other name for lv_xBackColour

	lv_Hook (struct Hook*) [CX.] pointer to Hook.  The Hook will get a
		struct lvData in A2.  Please look in C includes for
		description of struct lvData.

	lv_Notick (BOOL) [C..] do not send IDCMP_INTUITICKS if they are
		already used by listview (Default: TRUE)

	lv_AlwaysMark (BOOL) [CSG] the default way to mark a line is to press
		SHIFT key while selecting if this tag is TRUE lines are
		always marked - also if SHIFT isn't pressed - lv_MarkOn tag
		must be TRUE, too!

	lv_MarkOn (BOOL) [CSG] turns on mark mode, so the user can mark lines
		if not turned on only the program may mark a line (so SHIFT
		is ignored) - default: FALSE

	lv_SuperListView (BOOL) [C..] make Super ListView (TRUE) - i.e.  it
		may scroll horizontal - default: FALSE It has some things in
		common with intuitions Super Bitmap Windows.  ATTENTION! This
		kind of listview isn't that fast - so use it only for small
		listviews.  If there is less chip ram it falls back to a
		normal listview! Currently it is impossible to use a Super
		Listview in lvExtraWindows!

	lv_ScrollHeight (LONG) [C..] Height of horizontal scroller (see
		lv_ScrollWidth), Default: lv_ScrollWidth-(lv_ScrollWidth/3)

	lv_HorizSelected (LONG) [CSG] Horizontal position in pixel (first is
		0)

	lv_HorizScroll (LONG) [CSG] pixels to scroll if mouse if moved left
		or right out of the listview (Default: 4).

	lv_Private1 (LONG) [C..] private tagitem, do not use

	lv_ColumnData (struct ColumnData*)[] [C..] pointer to a ColumnData
		array.	Listviews may have more than one column.  Each column
		is represented by one struct ColumnData that contains its
		width, where is starts, Text adjustment and an offset to the
		text in each Node (see lv_MarkIsIn).  Field ln_Name of the
		struct Node is not shown so you must add a ColumnData for it,
		too.  But it is shown in an added string gadget.  To end the
		array simply add a ColumnData with all fields set to 0
		(NULL).  The array has to be sorted by size of start -
		smallest first.  Please look in C includes for details of
		struct ColumnData.

	lv_FormatText (STRPTR) [CS.] Text (+0 byte) that will be fit optimal
		in the listview - replacement for lv_Labels.  Column mode
		will be deactivated, this tag should be used in readonly
		listviews.  You can start a new paragraph with ASCII#10
		(Linefeed, \n).  lvExtraWindow update text form every time it
		is resized.  In lvExtraWindow the text string must be
		available the hole time it is applied to the listview!! In
		normal listviews the text string has to be available until
		LV_RefreshWindow() is called because graphics/TextFit() needs
		a RastPort which is not before this call set.  This may
		change.

	lv_AfterHook (struct Hook*) [CX.] pointer to Hook.  The hook will get
		a struct lvData in A2.	This hook will be started after a
		line has been print out.  Please look in C includes for
		description of struct lvData.

	lv_AskTop (WORD) [A] returns lv_Top in ti_Data field

	lv_AskLines (WORD) [A] number of visible lines in ti_Data

	lv_AskNumber (WORD) [A] number of lines in current list

	lv_AskNode (struct Node*) [A] Selected Node

	lv_IsShown (BOOL) [A] is selected item shown ?

	lv_IsMarked (struct Node* -> BOOL) [A] is (struct Node*) in ti_Data
		marked ? Set ti_Data to the node you want to known this, call
		the library and look in ti_Data for result.

	lv_IsMarkedNr (LONG -> BOOL) [A] is line in ti_Data marked ? Like
		lv_IsMarked

	lv_MarkedCount (WORD) [A] number of marked lines

	lv_AskHoriz (LONG) [A] get horizontal position of SuperLV - this is
		the only way to get this information (exept you use
		LV_GetListViewAttrsA() with lv_HorizSelected)

	lv_AskHorizMax (LONG) [A] maximal position for lv_AskHoriz, is
		changed by every lv_Lables call

