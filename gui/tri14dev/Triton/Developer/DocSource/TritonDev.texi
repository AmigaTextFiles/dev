\input amigatexinfo @c -*-texinfo-*-
\input texinfo
@comment %**start of header
@setfilename TritonDev.info
@settitle TritonDev
@iftex
@afourpaper
@end iftex
@finalout
@comment %**end of header

@c @setchapternewpage odd

@titlepage
@sp 5
@center @titlefont{Triton}
@sp 4
@center Release 1.4
@sp 4
@center @titlefont{Developer Documentation}
@sp 4
@center @copyright{} 1993-1995 by Stefan Zeiger.
@center All rights reserved.
@end titlepage

@node Top, INT_OVE, (dir), (dir)
@ifinfo

@center **********************************************

@center Triton

@center Release 1.4

@center Developer Documentation

@center (c) 1993-1995 Stefan Zeiger

@center **********************************************

@end ifinfo

@menu

Introduction

* Overview        :INT_OVE.       Programming with Triton
* OOP Internals   :INT_OOP.       The internal working of Triton
* Class Tree      :INT_CLA.       Available classes
* Autodocs        :INT_AUT.       Notes on the autodocs

Tutorial - Step by Step

* Applications    :TUT_APP.       The key to Triton
* Projects        :TUT_PRO.       Triton GUI windows
* Menus           :TUT_MEN.       Menus
* Objects         :TUT_OBJ.       Triton objects
* Layout          :TUT_LAY.       The layout engine
* Macros          :TUT_MAC.       Using the Triton GUI macros
* Polling Loop    :TUT_POL.       Handling GUI events
* Messages        :TUT_MES.       Sending messages
* Help            :TUT_HEL.       Providing help
* Requesters      :TUT_REQ.       Triton requesters

Style Guide

* Guidelines      :STY_OVE.       Guidelines for Triton GUIs

Odds & Ends

* FAQ             :ODD_FAQ.       Frequently Asked Questions

* Index           :Index.

@end menu

@example
@*
@end example

@ifinfo
Note that all pages can be reached directly from this menu,
so that you may conveniently browse through all items in this
main menu in order to read the entire documentation.
@end ifinfo

@node INT_OVE, INT_OOP, Top, Top
@chapter Introduction
@cindex Introduction
@section Overview
@cindex Overview

The Triton GUI creation system offers an easy way to create good looking
GUIs for your applications. It can be used with a variety of
programming languages. Currently supported are the following languages
and development systems:

@itemize @bullet
@item
C (SAS/C 6.50+, GCC (tested with 2.5.8 and 2.6.0), DICE)
@item
Oberon (AmigaOberon)
@item
Modula-2 (M2Amiga)
@item
E (AmigaE)
@item
Assembler
@item
Basic (BlitzBasic)
@item
Pascal (KickPascal, MaxonPascal)

Note that the Pascal interfaces
are not yet included in this release of the Triton developer
package. Please contact the author (Sotirios Pappas <sotto@@trkpool.rhein-ruhr.de>) directly.
@end itemize

(If you create a Triton support system for any other language or
development system and are willing to maintain it for future
updates, please contact me for inclusion into the main Triton
Developer distribution.)

This document describes how to use Triton in your own applications
by providing you with some overview topics and a step by step
introduction. It does @strong{not} describe in detail the functions,
structures, tags, etc@. which are used, so you should always look
them up in the autodocs file (see @ref{INT_AUT, Autodocs, Introduction - Autodocs})
and the C header file @file{Developer/Include/libraries/triton.h}.

The examples in this document assume that you're using the C support
files with the SAS/C compiler. There may be differences in other
languages or even with other C development systems.

@node INT_OOP, INT_CLA, INT_OVE, Top
@section OOP Internals
@cindex OOP Internals

Although Triton offers a mostly procedural API, it is based on an
object-oriented system. As a Triton user you will never see Triton
objects directly, but instead reference them through IDs.

@node INT_CLA, INT_AUT, INT_OOP, Top
@section Class Tree
@cindex Class Tree

The following classes are available in Triton:

@example
    Object                  Abstract root class
    `-- DisplayObject       Abstract class for window contents
        +-- Button          BOOPSI button gadget
        +-- CheckBox        GadTools CheckBox
        +-- Cycle           GadTools Cycle and MX gadget
        +-- DropBox         AppIcon dropping box
        +-- FrameBox        Framing or grouping box
        +-- Group           Triton's layout engine
        +-- Image           Image
        +-- Line            3D line
        +-- Listview        GadTools Listview
        +-- Palette         GadTools Palette gadget
        +-- Progress        Progress indicator
        +-- Scroller        GadTools Scroller
        +-- Slider          GadTools Slider
        +-- Space           Empty space
        +-- String          GadTools String gadget
        `-- Text            Text
@end example

Descriptions for all classes can be found in the Triton autodocs
(see @ref{INT_AUT, Autodocs, Introduction - Autodocs})
under @code{triton.library/class_<classname>}.

@node INT_AUT, TUT_APP, INT_CLA, Top
@section Autodocs
@cindex Autodocs

Documentation on all Triton classes and @file{triton.library} functions can be
found in the Triton autodocs file @file{Developer/Autodocs/triton.doc}. The
function descriptions follow the usual syntax as used in the AmigaOS autodocs.
The Triton classes are listed with the prefix @code{triton.library/class_} and
are described using the following keywords:

@itemize @bullet
@item @code{NAME}

The name of the class and a short description.
@item @code{SUPERCLASS}

The superclass. If the comment @code{(no attributes inherited)} is added,
all attributes (see below) are described in this autodoc clip. Otherwise
all attributes of the superclass are inherited.
@item @code{SYNOPSIS}

The tags which invoke the creation of an instance of the class.
@item @code{ATTRIBUTES}

The attributes which are created for every instance of the class. All
attributes are listed with their tag names, except for the default
attribute which is listed as @code{<Default>}. See above for superclass
attributes.
@item @code{MESSAGES}

This section describes all messages which objects of this class are currently
able to send. If no messages are described, this doesn't mean that none are
sent. Not all class descriptions have this section yet.
@end itemize

@node TUT_APP, TUT_PRO, INT_AUT, Top
@chapter Tutorial
@cindex Tutorial
@section Applications
@cindex Applications

In order to use @file{triton.library} you must first of all open it, like any other
shared library, as described in the @code{Amiga ROM Kernel Reference Manual},
volume @code{Libraries}. Before quitting, you have to close it again. Since
release 1.1 @file{triton.library} is a single-base library, so you can share one
instance of @file{triton.library} between several tasks. The following code makes sure
that you can use functions from @file{triton.library} release 1.2 or higher:

@example
    #include <libraries/triton.h>
    #include <clib/triton_protos.h>
    #include <pragmas/triton_pragmas.h>

    struct Library *TritonBase;

    int main(void)
    @{
      if(TritonBase=OpenLibrary(TRITONNAME,TRITON12VERSION))
      @{
        /* Use functions from triton.library... */
        CloseLibrary(TritonBase);
      @}
      else
      @{
        /* React on the error... */
      @}
      return 0;
    @}
@end example

All Triton programs are based on a Triton application structure (struct TR_App).
This structure is the connection which keeps all Triton parts of your application
together. Before using any other Triton functions, you have to create a Triton
application, and you must delete it again before your program quits (and before
you close @file{triton.library} of course). Any Triton application must have at
least a short name, which is used by Triton to identify the application. All other
tags are optional. A typical code segment could look like this:

@example
    struct TR_App *myApp;

    if(myApp=TR_CreateAppTags(
      TRCA_Name,    "MyApp",
      TRCA_Release, "1.0",
      TRCA_Version, "42.113",
      TRCA_Date,    "3.11.94",
      TAG_END))
    @{
      /* Use myApp for other Triton functions... */
      TR_DeleteApp(myApp);
    @}
    else
    @{
      /* React on the error... */
    @}
@end example

The linker library @file{triton.lib} offers an easier way to open @file{triton.library}
and create a Triton application structure. The two examples from above can be combined
into the following short version:

@example
    #include <libraries/triton.h>
    #include <proto/triton.h>

    int main(void)
    @{
      if(TR_OpenTriton(TRITON12VERSION,
        TRCA_Name,    "MyApp",
        TRCA_Release, "1.0",
        TRCA_Version, "42.113",
        TRCA_Date,    "3.11.94",
        TAG_END))
      @{
        /* The opened application is called 'Application' */
        TR_CloseTriton();
      @}
      else
      @{
        /* React on the error... */
      @}
      return 0;
    @}
@end example

@node TUT_PRO, TUT_MEN, TUT_APP, Top
@section Projects
@cindex Projects

A Triton Project is the next smaller entity of a Triton GUI. Currently
a project contains exactly one Intuition window, but in future versions
of Triton it could be possible to attach more windows to a project.
Upon opening a project, you have to specify all objects which are to
be displayed in the window, the window's menu and some tags describing
window properties.

At first you have to specify the window properties, then the menus and
finally one (!) object. Normally this object will be a group which contains
other objects or groups.

Note that all tags are optional. You may just as well
open a window without any tags. This will result in a small window, consisting
only of the close and depth gadget and a small dragging bar, being opened
on the default public screen's title bar.

As with naming Triton applications,
you should give each project at least a unique ID which is used by Triton
e.g. for remembering the window dimensions.

Opening and closing a
project without any objects and menus could look like this:

@example
    struct TagItem dummyTags=
    @{
      TRWI_Title, (ULONG) "A dummy window",
      TRWI_ID,            42,
      TAG_END
    @};

    void dummyFunction(void)
    @{
      struct TR_Project *dummyProject;

      if(dummyProject=TR_OpenProject(Application,dummyTags))
      @{
        /* Opened successfully */
        TR_CloseProject(dummyProject);
      @}
      else
      @{
        /* React on the error... */
      @}
    @}
@end example

Of course this way of opening a project via a static TagItem list doesn't
allow to insert object parameters or localized strings. Since you need these
features most times, you should instead use a dynamical TagList which is built
on the stack at runtime. Be sure to set a large enough stack! Some development
systems offer an automatic stack setting in their startup code, which comes
handy in those situations. Please do not rely on the user to set the stack!

And now back to our code, this time with a dynamic list. Imagine a function
@code{STRPTR GetLocStr(int num)} which gives you a localized string.

@example
    void dummyFunction(void)
    @{
      struct TR_Project *dummyProject;

      if(dummyProject=TR_OpenProjectTags(Application,
        TRWI_Title, (ULONG) GetLocStr(MSG_WINTITLE_DUMMY),
        TRWI_ID,            42,
        TAG_END))
      @{
        /* Opened successfully */
        TR_CloseProject(dummyProject);
      @}
      else
      @{
        /* React on the error... */
      @}
    @}
@end example

The ID 42 in the above examples has been chosen randomly. This is no
problem as long as you stick to this ID in future updates of your application.
Otherwise the window dimensions would be wrong and the user would have to
adjust them again.

In order to not use IDs twice, it can be useful to enumerate them:

@example
    enum windowIDs @{WINID_DUMMY=1, WINID_FOO, WINID_BAR@};
@end example

Note that window IDs must be different from 0. 0 is equal to
no ID at all.

See the autodoc clip @code{triton.library/TR_OpenProject()} for details
about the supported tags.

@node TUT_MEN, TUT_OBJ, TUT_PRO, Top
@section Menus
@cindex Menus

Any project definiton may contain menus. The menu tags must follow
the window tags immediately, before the object tags. If a menu has
got an object ID, the TRAT_ID tag must be the last one in the menu
definition. Object IDs are more than Project IDs. Project IDs are
used only internally by Triton. As an application programmer, you
have to reference Projects by a pointer to their @code{struct TR_Project}.
Objects instead are not referenced through pointers, but only through
object IDs. The same is true for menus, which use ordinary object IDs.

A typical menu defintion could look like this:

@example
    TR_OpenProjectTags(...
      TRMN_Title,   (ULONG) "Project",
        TRMN_Item,  (ULONG) "?_About",       TRAT_ID, 1,
        TRMN_Item,  (ULONG) TRMN_BARLABEL,   TRAT_ID, 2,
        TRMN_Item,  (ULONG) "Q_Quit",        TRAT_ID, 3,
      ...);
@end example

The title of a menu item or sub-item can be @code{TRMS_BARLABEL}
to insert a standard separator bar. Keyboard shortcuts can be
specified by beginning the menu label with the shortcut key
followed by an underscore character and the real menu label.
These simple shortcuts (with the right Amiga key) are processed
automatically. You can create a so-called 'extended shortcut'
by starting a label with an underscore character, then the
text for the shortcut, another underscore and the menu label.
These extended shortcuts are only displayed with AmigaOS 3.0
or higher and they are not managed automatically. You have to
listen to incoming keyboard events in order to handle
these shortcuts yourself.

See the @code{Menus} window of the Triton demo application for a
more detailed example on menus.

@node TUT_OBJ, TUT_LAY, TUT_MEN, Top
@section Objects
@cindex Objects

The heart of every Triton GUI are the objects. Currently only instances
of subclasses of the @code{DisplayObject} class can be created.
@xref{INT_CLA, Class Tree, Introduction - Class Tree}, for a short list
of all classes. Detailed descriptions can be found in the autodocs.

Objects are created by inserting an object tag into a project definition.
For example, a checked CheckBox object with an ID of 99 can be created
the following way:

@example
    TROB_CheckBox,   NULL,
      TRAT_Value,    (ULONG) TRUE,
      TRAT_ID,       99,
@end example

All available tags are listed in the autodocs. The @code{<Default>} tag's
value has to be inserted directly in the @code{TROB_<Class>} tag as its
data. All other tags are inserted normally after the initial class tag.

@cindex Notification
@cindex Linking
@strong{Note:} It is useful to @code{enum}erate object IDs just like
project IDs. But in contrast to project IDs, object IDs may be used
more than once. If you use an object ID several times within the same
project, the objects with that ID will be linked together and whenever
an attribute (only selected attributes, notably @code{TRAT_Value}!) of
one object changes, this change will be broadcast to all other objects
with that ID as if you had notified them yourself with
@code{TR_SetAttribute()}. This is particularly useful to link a
CheckBox gadget and a checkable menu item together.

See the @code{Connections} window of the Triton demo application for a
more detailed example on attribute broadcasting.

@node TUT_LAY, TUT_MAC, TUT_OBJ, Top
@section Layout
@cindex Layout

One of the most important classes is @code{Group}. It implements Triton's
layout engine.

@code{Group} objects offer two kinds of directions:

@enumerate
@item
Horizontal (primary direction; secondary direction is vertical).
Created with @code{TRGR_Horiz}.
@item
Vertical (primary direction; secondary direction is horizontal)
Created with @code{TRGR_Vert}.
@end enumerate

3 different layout types are available for each instance
of @code{Group} (adjustable with the group flags). They affect
the primary direction only:

@enumerate
@item
@code{TRGR_PROPSHARE}: Divides all objects proportionally to their
minimum size. All spaces retain their minimum size and are not resizable.
Non-resizable non-space objects do also stick to their minimum sizes
(well, they don't really have a choice, do they? ;).
@item
@code{TRGR_EQUALSHARE}: Same as @code{TRGR_PROPSHARE} except that all non-space
objects have the same size. Their minimum size equals the biggest minimum size
of the individual objects.
@item
@code{TRGR_PROPSPACES}: All non-space objects retain their minimum sizes all
the time and do not get stretched. Instead the spaces are stretched
proportionally to their minimum sizes.
@item
@code{TRGR_ARRAY}: This group builds the top group of an array. In order
to create an array, you have to set up an outer @code{TRGR_ARRAY} group
(horizontal for a column array, vertical for a line array) and fill it
with single objects (notably spaces) or @code{TRGR_PROPSHARE} groups in
the opposite direction. All elements of the inner groups will be aligned
to build an array. Inner groups which have the flag @code{TRGR_INDEP} set
will not be aligned. They are mainly used to insert named separator bars
(created with @code{TROB_Line} and @code{TROB_Text}) into an array.
@end enumerate

Currently the only objects which are treated as spaces in the above scheme
are instances of class @code{Space}.

The behaviour of the group in its secondary direction can be changed, too.
Two additional flags are available for that purpose. In most cases you may
want to set both of them:

@enumerate
@item
@code{TRGR_ALIGN}: All resizable objects (i.e. resizable in the secondary
dimension of the group) are strechted to fit the full space occupied by
the group.
@item
@code{TRGR_CENTER}: All non-resizable objects are centered in the group.
Without this flag they get aligned to the left or top border.
@end enumerate

It is also possible to keep a group at its minimum size and don't allow
it to be stretched in either or both directions. This can be accomplished
with the @code{TRGR_FIXHORIZ} and @code{TRGR_FIXVERT} flags.

A group can be created like any other object. It takes other objects
as its arguments. Every group has to be terminated with a @code{TRGR_End}
tag. A typical horizontal group, which contains a CheckBox, a space and
again a CheckBox, would look like this:

@example
    TRGR_Horiz,      TRGR_PROPSHARE|TRGR_ALIGN|TRGR_CENTER,

      TROB_CheckBox, 0,
        TRAT_ID,     1,

      TROB_Space,    TRST_NORMAL,

      TROB_CheckBox, 0,
        TRAT_Value,  TRUE,
        TRAT_ID,     2,

      TRGR_End,      0
@end example

See the @code{Groups} window of the Triton demo application for a
more detailed example on groups and arrays.

@node TUT_MAC, TUT_POL, TUT_LAY, Top
@section Macros
@cindex Macros

The C header file @file{Developer/Include/libraries/triton.h} contains
quite a lot of macro definitions which make creating a Triton GUI much
easier. With the help of the preprocessor @code{Mac2E} these macros
are also available in @code{AmigaE}. Other languages or compilers may
support similar or different macros or none at all. If no macros are
available in your development system, you have to do it the traditional
way. If you can use macros, use them.

The static taglist definition can be written a bit simpler with macros:

@example
    ProjectDefinition(dummyTags)
    @{
      /* Insert project tags here */
    @};
@end example

But the main use for macros are the tags themselves. For example, the tags
from the dummy window example (see @ref{TUT_PRO, Projects, Tutorial - Projects})
would look like this:

@example
      WindowTitle("A dummy window"),
      WindowID(42),
      EndProject
@end example

Have a look at the macro definitions and the supplied demo applications
for more detailed information about the macros.

@node TUT_POL, TUT_MES, TUT_MAC, Top
@section Polling Loop
@cindex Polling Loop
@cindex Loop, Polling

After creating a GUI you have to handle user input. In order to accomplish
this task, Triton offers a polling system which resembles the Intuition
IDCMP polling system very much. A basic polling loop looks like this:

@example
    void handleDummyWindow(void)
    @{
      BOOL closeMe=FALSE;
      struct TR_Message *trMsg;

      /* Open the window... */

      while(!closeMe)
      @{
        TR_Wait(Application,NULL);
        while(trMsg=TR_GetMsg(Application))
        @{
          switch(trMsg->trm_Class)
          @{
            case TRMS_CLOSEWINDOW:
              closeMe=TRUE;
              break;

            case TRMS_ACTION:
              switch(trmsg->trm_ID)
              @{
                case ID_FOO:
                  /* Do something... */
                  break;
                case ID_BAR:
                  /* Do something... */
                  break;
              @}
              break;

            case TRMS_NEWVALUE:
              switch(trMsg->trm_ID)
              @{
                /* New value is in trMsg->trm_Data */

                case ID_MYCHECKBOX:
                  /* Do something... */
                  break;
                case ID_MYSLIDER:
                  /* Do something... */
                  break;
              @}
              break;

            case TRMS_ERROR:
              puts(TR_GetErrorString(trMsg->trm_Data));
              break;
          @}
          TR_ReplyMsg(trMsg);
        @}
      @}

      /* Close the window... */
    @}
@end example

@strong{Note:} Don't forget to reply all messages!

You could add a @code{switch()} for the project which sent the message if
you have more than one project opened, but a better way is to use unique
object IDs. This does also yield the advantage that moving an object from
one window to another does not require any change in the message handling.

It is currently not very well documented which messages are sent by the
different objects. As a general rule, activatable objects send @code{TRMS_ACTION}
and objects which have a @code{TRAT_Value} or a similar modifiable tag,
send @code{TRMS_NEWVALUE}.

Here is a more detailed description of the message types:

@itemize @bullet
@item
@code{TRMS_CLOSEWINDOW}: The user has pressed the close gadget or the @code{Esc} key
(if it hasn't been disabled with @code{TRWF_NOESCCLOSE}).
@item
@code{TRMS_ERROR}: An error occured. @code{TR_Message.trm_Data} contains the error
code. You can use @code{TR_GetErrorString()} to generate a user-readable error
message from this error code.
@item
@code{TRMS_NEWVALUE}: An object's attribute has changed. @code{TR_Message.trm_Data} contains
the new value for the attribute.
@item
@code{TRMS_ACTION}: An object has been activated somehow (e.g. a button has been pressed
or its keyboard shortcut was used instead).
@item
@code{TRMS_ICONDROPPED}: An icon has been dropped over a window.
You will get this message only if an object in your
window reacts on dropped icons or you ask directly for it by
specifying the project flag @code{TRWF_APPWINDOW}. Otherwise
Workbench will not allow you to drop icons over a Triton window.
@code{TR_Message.trm_ID} contains the ID of the object over which the
icon was dropped or 0 if it was dropped over an object without an ID.
@code{TR_Message.trm_Data} contains a pointer to the @code{struct AppMessage}
which was sent by Workbench.
@item
@code{TRMS_KEYPRESSED}: A key has been pressed and Triton was not able to
identify it (e.g. as a keyboard shortcut).
@code{TR_Message.trm_Data} contains the ASCII code (if available,
otherwise 0),
@code{TR_Message.trm_Code} contains the RawKey code and @code{TR_Message.trm_Qualifier}
the qualifier bits.
@item
@code{TRMS_HELP}: The user requests help for the object specified by @code{TR_Message.trm_ID}
or for the whole window if the ID is 0.
@end itemize

A description of all fields of the @code{TR_Message} structure can be found in
the C header file @file{Developer/Include/libraries/triton.h}.

@node TUT_MES, TUT_HEL, TUT_POL, Top
@section Messages
@cindex Set
@cindex Get
@cindex Message
@cindex Attribute
@cindex Query
@cindex Modify

Sometimes you may wish to query an object's attribute directly
without waiting in a polling loop and then putting it down somewhere
else. This is especially useful for string gadgets. You should
@emph{not} read their contents when you receive a @code{TRMS_NEWVALUE}
message, because it is possible to exit a string gadget without
triggering such a message. Instead you have to read the contents
directly before you need them.

Attributes can be read with the @code{TR_GetAttribute()} function,
which will return the value of an object's or project's attribute.
Specify the object's ID or 0 for a project attribute. You can get
the default attribute of an object by setting @code{Attribute} to
0. Otherwise set it to an attribute tag.

Setting a new attribute works just the same way with the function
@code{TR_SetAttribute()}. Again you may also modify project attributes.
See the autodoc clip for a list of them. After setting a new attribute
the on-screen representation of it will be updated if necessary.

If you want to send custom object messages (@code{TR_SetAttribute()} and
@code{TR_GetAttribute()} invoke the messages @code{TRDM_SETATTRIBUTE} and
@code{TRDM_GETATTRIBUTE}), you have to use @code{TR_SendMessage()}. The autodocs
will tell you which classes accept which messages.

@emph{Note:} Do not confuse @code{Object Messages} (@code{TROM_...}) which are sent
to Triton objects with @code{Triton messages} (@code{TRMS_...}) which you receive in your
polling loop.

@node TUT_HEL, TUT_REQ, TUT_MES, Top
@section Help
@cindex Help
@cindex QuickHelp

Triton offers two ways of providing help for the user of a Triton application:

@itemize @bullet
@item
QuickHelp

@code{QuickHelp} creates and handles requester bubbles (actually they are
implemented as rectangular boxes at the moment). All you have to do is
provide a @code{TRDO_QuickHelpString} attribute for every object which
should have QuickHelp available. Then switch on QuickHelp with @code{TRWI_QuickHelp}
(can be set when opening a project or modified later with @code{TR_SetAttribute()}).
When the user moves the mouse pointer over an object which has a QuickHelp string
attached, a small window will pop up near the object where the mouse pointer is
located. This window contains the specified QuickHelp string. As soon as the mouse
pointer leaves the borders of the object, the help window will disappear.
@item
Manual help

If you set @code{TRWF_HELP} when opening a project, you will receive a @code{TRMS_HELP}
message whenever the user presses the @code{Help} key. As usual @code{TR_Message.trm_ID}
contains the ID of the object for which the user requested help or 0 if no object could
be assigned to the help request (you should normally provide help for the whole window
in that case). The most common way to react on @code{TRMS_HELP} is to pop up an AmigaGuide
document describing the object for which the user requested help. If you do not want to
provide more extensive help than you do with the QuickHelp feature (see above), you can
also pop up a requester containing the QuickHelp string for the specified object. The main
window of the main Triton demo application shows how to do that.
@end itemize

@node TUT_REQ, STY_OVE, TUT_HEL, Top
@section Requesters
@cindex Requesters

Triton offers two requester functions:

@itemize @bullet
@item
@code{TR_EasyRequest()} creates and handles a simple requester
with some lines of text (different text styles are possible) and
a row of buttons at the lower end. You should use this function
whenever possible. Not only is it easier to use than @code{TR_AutoRequest()},
but it could be made user-configurable in future Triton releases.
@item
@code{TR_AutoRequest()} is a simple message polling loop which opens
a Triton window, waits until a @code{TRMS_ACTION} message comes in and
returns the ID of the object which triggered the message. This function
is often used in combination with the requester macros
(@code{BeginRequester()}, @code{BeginRequesterGads} and @code{EndRequester}).
@end itemize

Please consult the autodocs for more detailed information about these
functions. The main demo application contains examples for both types
of requesters.

If you need a more sophisticated requester (e.g. a string requester),
you have to use your own message polling loop
(see @ref{TUT_POL, Polling Loop, Tutorial - Polling Loop}).
You may still use the requester macros though.

@node STY_OVE, ODD_FAQ, TUT_REQ, Top
@chapter Style Guide
@section Guidelines
@cindex Guidelines
@cindex Style Guide
@cindex Guide, Style

Please keep the following general rules in mind when designing
and implementing a GUI with Triton:

@itemize @bullet
@item
Window size

Please make sure that all windows of your GUI fit on a standard
@code{PAL Hires} screen (640*256) with @file{topaz.font} in size 8.
@item
Keyboard shortcuts

Please add keyboard shortcuts to as many gadgets and menus as possible.
It is very annoying for a user who works without a mouse most of the
time to grab his mouse just because you forgot to add keyboard shortcuts.
@item
Test your GUI

You should always test your GUI with different font sizes (especially
fixed-width and proportional fonts with different heights) and a
non-standard window background to avoid making assumptions about
the layout and coloring of your GUI resulting from observed behaviour,
which is quite often wrong. Take special care not to use text spaces
for spacing in your GUI (e.g. in array labels).
@item
Stack size

If your application requires a stack size above 4096 bytes (e.g. because
of a huge TagList with a Triton project definition, which is created on the
stack during runtime), make sure that the stack does indeed have that size.
Some development systems offer an automatic stack setting in their startup
code, which comes handy in those situations. Please do not rely on the user
to set the stack!
@item
And finally:

Don't forget the @code{Amiga User Interface Style Guide}...
@end itemize

@node ODD_FAQ, Index, STY_OVE, Top
@chapter Odds & Ends
@section FAQ
@cindex FAQ
@cindex Frequently Asked Questions
@cindex Questions
@cindex Answers

Here are some frequesntly asked questions and their answers:

@enumerate
@item
Q: Why shouldn't I use a simple @code{TR_Wait()} for dummy windows?

A: Triton has to process inputs from Intuition. This is done in
@code{TR_GetMsg()}. But of course you have to call this functions
so that Triton can process its input. After @code{TR_Wait()}
returns, you have to run though a @code{while(TR_GetMsg())} loop
as usual. An easier way to create a dummy window is using
@code{TR_AutoRequest()}.
@item
Q: How do I handle a progress indicator?

A: As already explained in answer 1, you have to call @code{TR_GetMsg()}
regularly. When a progress indicator is displayed, you should update
it regularly and run through a @code{while(TR_GetMsg())} loop every time.
See the supplied Progress Indicator demo application for details.
@item
Q: How do I activate a string gadget?

A: Beginning with Triton 1.3 (V4) you can use @code{TR_SendMessage(Project,ID,TROM_ACTIVATE,NULL)}.
@end enumerate

@node Index, , ODD_FAQ, Top
@unnumbered Index
@printindex cp
@contents
@bye
