«FILE:ARexx.j»
/*
 * «APPNAME» ARexx  (C) «YEAR» «APPOWNER»
 *                  All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 */

#include "common.h"

extern struct MyGlobals        MG;
«FOREACH:WINDOW»
extern struct «WSN»            «WSI»;
«ENDEACH»
extern char                    GL_szFault[256];


/*
 * AREXX HOOKS --------------------------------------
 */
SAVEDS ASM LONG RX_1ClearFunc      ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   ULONG ulForce;


   ulForce = *((ULONG *)arg);
   if ( ulForce )
   {
      return( RETURN_OK );
   }
   else if ( MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                          "Are you sure you wish to clear all data?", NULL ) == 1 )
   {
      return( RETURN_OK );
   }

   return( RETURN_ERROR );
}
SAVEDS ASM LONG RX_1OpenFunc       ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   ULONG  ulForce;
   BOOL   fLoad = FALSE;
   char  *pszFile;


   pszFile =  ((char *)*arg);
   ulForce = *((ULONG *)(arg+1));

   if ( ulForce )
   {
      fLoad = TRUE;
   }
   else if ( MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                          "Data has been modified.\nAre you sure you wish to continue?", NULL ) == 1 )
   {
      fLoad = TRUE;
   }

   if ( fLoad == TRUE )
   {
      if ( fnOpen( pszFile, TRUE ) )
      {
         return( RETURN_ERROR );
      }
      else
      {
         return( RETURN_OK );
      }
   }
   return( RETURN_ERROR );
}
SAVEDS ASM LONG RX_1SaveasFunc     ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszFile;


   pszFile =  ((char *)*arg);

   if ( fnSave( pszFile, TRUE ) )
   {
      return( RETURN_ERROR );
   }
   else
   {
      return( RETURN_OK );
   }
}
SAVEDS ASM LONG RX_1QuitFunc       ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   ULONG  ulForce;


   ulForce = *((ULONG *)arg);

   if ( !ulForce )
   {
      if ( MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                        "Are you sure you want to quit?", NULL ) == 1 )
      {
         MG.running = FALSE;
      }
   }
   else
   {
      MG.running = FALSE;
   }
   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4MoveWdwFunc    ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   LONG   lX, lY;
   char  *pszWindow;


   pszWindow =  ((char *)*arg);
   lX        = *((ULONG *)(arg+1));
   lY        = *((ULONG *)(arg+2));

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  MoveWindow( MG.WIN_«WSI», lX, lY );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4SizeWdwFunc    ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   LONG   lW, lH;
   char  *pszWindow;


   pszWindow =  ((char *)*arg);
   lW        = *((ULONG *)(arg+1));
   lH        = *((ULONG *)(arg+2));

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  SizeWindow( MG.WIN_«WSI», lW, lH );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4ChangeWdwFunc  ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   LONG   lX, lY, lW, lH;
   char  *pszWindow;


   pszWindow =  ((char *)*arg);
   lX        = *((ULONG *)(arg+1));
   lY        = *((ULONG *)(arg+2));
   lW        = *((ULONG *)(arg+3));
   lH        = *((ULONG *)(arg+4));

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  ChangeWindowBox( MG.WIN_«WSI», lX, lY, lW, lH );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4Wdw2FrontFunc  ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszWindow;


   pszWindow =  ((char *)*arg);

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  WindowToFront( MG.WIN_«WSI» );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4Wdw2BackFunc   ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszWindow;


   pszWindow =  ((char *)*arg);

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  WindowToBack( MG.WIN_«WSI» );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4ActivateWdwFunc( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszWindow;


   pszWindow =  ((char *)*arg);

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  ActivateWindow( MG.WIN_«WSI» );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4ZoomWdwFunc    ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszWindow;


   pszWindow =  ((char *)*arg);

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  ZipWindow( MG.WIN_«WSI» );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_4UnzoomWdwFunc  ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   char  *pszWindow;


   pszWindow =  ((char *)*arg);

«FOREACH:WINDOW»
   if      ( strcmp( pszWindow, "«WSI»" ) == 0 ) {  ZipWindow( MG.WIN_«WSI» );  }
«ENDEACH»

   return( RETURN_OK );
}
SAVEDS ASM LONG RX_6LockGUIFunc    ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   set( MG.App, MUIA_Application_Sleep, TRUE );
   return( RETURN_OK );
}
SAVEDS ASM LONG RX_6UnlockGUIFunc  ( REG(a0) struct Hook *hook, REG(a2) Object *appl, REG(a1) ULONG *arg )
{
   set( MG.App, MUIA_Application_Sleep, FALSE );
   return( RETURN_OK );
}


/*
 * AREXX PROTOS -------------------------------------
 */
static const struct Hook RX_1ClearHook       = { {NULL, NULL}, (void *)RX_1ClearFunc      , NULL, NULL };
static const struct Hook RX_1OpenHook        = { {NULL, NULL}, (void *)RX_1OpenFunc       , NULL, NULL };
static const struct Hook RX_1SaveasHook      = { {NULL, NULL}, (void *)RX_1SaveasFunc     , NULL, NULL };
static const struct Hook RX_1QuitHook        = { {NULL, NULL}, (void *)RX_1QuitFunc       , NULL, NULL };
static const struct Hook RX_4MoveWdwHook     = { {NULL, NULL}, (void *)RX_4MoveWdwFunc    , NULL, NULL };
static const struct Hook RX_4SizeWdwHook     = { {NULL, NULL}, (void *)RX_4SizeWdwFunc    , NULL, NULL };
static const struct Hook RX_4ChangeWdwHook   = { {NULL, NULL}, (void *)RX_4ChangeWdwFunc  , NULL, NULL };
static const struct Hook RX_4Wdw2FrontHook   = { {NULL, NULL}, (void *)RX_4Wdw2FrontFunc  , NULL, NULL };
static const struct Hook RX_4Wdw2BackHook    = { {NULL, NULL}, (void *)RX_4Wdw2BackFunc   , NULL, NULL };
static const struct Hook RX_4ActivateWdwHook = { {NULL, NULL}, (void *)RX_4ActivateWdwFunc, NULL, NULL };
static const struct Hook RX_4ZoomWdwHook     = { {NULL, NULL}, (void *)RX_4ZoomWdwFunc    , NULL, NULL };
static const struct Hook RX_4UnzoomWdwHook   = { {NULL, NULL}, (void *)RX_4UnzoomWdwFunc  , NULL, NULL };
static const struct Hook RX_6LockGUIHook     = { {NULL, NULL}, (void *)RX_6LockGUIFunc    , NULL, NULL };
static const struct Hook RX_6UnlockGUIHook   = { {NULL, NULL}, (void *)RX_6UnlockGUIFunc  , NULL, NULL };


/*
 * AREXX --------------------------------------------
 */
static struct MUI_Command rxcommands[] =
{
   // PROJECT-RELATED COMMANDS
   { "NEW",    MC_TEMPLATE_ID,         ID_MENU_PROJECT_NEW,   NULL            },
   { "CLEAR",  "FORCE/S",              1,                     &RX_1ClearHook  },
   { "OPEN",   "FILENAME/A,FORCE/S",   2,                     &RX_1OpenHook   },
   { "SAVE",   MC_TEMPLATE_ID,         ID_MENU_PROJECT_SAVE,  NULL            },
   { "SAVEAS", "NAME/A",               1,                     &RX_1SaveasHook },
   { "CLOSE",  MC_TEMPLATE_ID,         ID_MENU_PROJECT_QUIT,  NULL            },
   { "QUIT",   "FORCE/S",              1,                     &RX_1QuitHook   },

   // WINDOW-RELATED COMMANDS
   { "MOVEWINDOW",      "WINDOW/A,LEFTEDGE/N,TOPEDGE/N", 3, &RX_4MoveWdwHook     },
   { "SIZEWINDOW",      "WINDOW/A,WIDTH/N,HEIGHT/N",     3, &RX_4SizeWdwHook     },
   { "CHANGEWINDOW",    "WINDOW/A,LEFTEDGE/N,TOPEDGE/N,WIDTH/N,HEIGHT/N",
                                                         5, &RX_4ChangeWdwHook   },
   { "WINDOWTOFRONT",   "WINDOW/A",                      1, &RX_4Wdw2FrontHook   },
   { "WINDOWTOBACK",    "WINDOW/A",                      1, &RX_4Wdw2BackHook    },
   { "ACTIVATEWINDOW",  "WINDOW/A",                      1, &RX_4ActivateWdwHook },
   { "ZOOMWINDOW",      "WINDOW/A",                      1, &RX_4ZoomWdwHook     },
   { "UNZOOMWINDOW",    "WINDOW/A",                      1, &RX_4UnzoomWdwHook   },

   // APPLICATION-SPECIFIC COMMANDS

   // INTERFACE COMMANDS
   { "LOCKGUI",   "", 0, &RX_6LockGUIHook    },
   { "UNLOCKGUI", "", 0, &RX_6UnlockGUIHook  },

   { NULL, NULL, NULL, NULL }
};

struct MUI_Command *RXCommands = (struct MUI_Command *)rxcommands;
«ENDFILE»


«FILE:common.hj»
/*
 * «APPNAME» Common Headers   (C) «YEAR» «APPOWNER»
 *                            All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 */

#include <exec/libraries.h>
#include <exec/types.h>
#include <exec/memory.h>
#include <exec/nodes.h>
#include <exec/lists.h>

#include <devices/keymap.h>

#include <graphics/gfxbase.h>
#include <graphics/displayinfo.h>

#include <intuition/intuitionbase.h>
#include <intuition/intuition.h>

#include <dos/dos.h>
#include <dos/datetime.h>
#include <dos/rdargs.h>
#include <dos/dostags.h>

#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>

#include <libraries/asl.h>
#include <libraries/dos.h>
#include <libraries/dosextens.h>
#include <libraries/gadtools.h>
#include <libraries/locale.h>
#include <libraries/mui.h>

#include <rexx/storage.h>

#include <workbench/startup.h>
#include <workbench/workbench.h>
#include <workbench/icon.h>

#include <clib/alib_protos.h>

#include <proto/asl.h>
#include <proto/diskfont.h>
#include <proto/dos.h>
#include <proto/exec.h>
#include <proto/gadtools.h>
#include <proto/graphics.h>
#include <proto/icon.h>
#include <proto/intuition.h>
#include <proto/locale.h>
#include <proto/muimaster.h>
#include <proto/utility.h>
#include <proto/wb.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <dos.h>
#include <math.h>


/*
 * GENERAL DEFINES ----------------------------------
 */
#define FILEID_HEADER      "«APPBASE» «APPVERS»"

#define MAX( a,b )   ( ( (a) > (b) ) ? (a) : (b) )
#define MIN( a,b )   ( ( (a) < (b) ) ? (a) : (b) )
#define MAKE_ID(a,b,c,d) ((ULONG) (a)<<24 | (ULONG) (b)<<16 | (ULONG) (c)<<8 | (ULONG) (d))


#define REG(x) register __ ## x
#define ASM    __asm
#define SAVEDS __saveds


/*
 * OBJECT IDs ------------------------------
 */
/***** MENUS *****/
#define ID_MENU_PROJECT_NEW              1010
#define ID_MENU_PROJECT_OPEN             1020
#define ID_MENU_PROJECT_SAVE             1030
#define ID_MENU_PROJECT_SAVEAS           1040
#define ID_MENU_PROJECT_PRINT            1050
#define ID_MENU_PROJECT_PRINTAS          1060
#define ID_MENU_PROJECT_HIDE             1070
#define ID_MENU_PROJECT_REVEAL           1080
#define ID_MENU_PROJECT_CLOSE            1090
#define ID_MENU_PROJECT_ABOUT            1100
#define ID_MENU_PROJECT_ABOUTMUI         1110
#define ID_MENU_PROJECT_EXITLEVEL        1120
#define ID_MENU_PROJECT_QUIT             1130

#define ID_MENU_EDIT_CUT                 2010
#define ID_MENU_EDIT_COPY                2020
#define ID_MENU_EDIT_PASTE               2030
#define ID_MENU_EDIT_ERASE               2040
#define ID_MENU_EDIT_UNDO                2050
#define ID_MENU_EDIT_REDO                2060

#define ID_MENU_MACROS_STARTLEARNING     3010
#define ID_MENU_MACROS_STOPLEARNING      3020
#define ID_MENU_MACROS_ASSIGNMACRO       3030
#define ID_MENU_MACROS_LOAD              3040
#define ID_MENU_MACROS_SAVE              3050

#define ID_MENU_SETTINGS_MUI             4010
#define ID_MENU_SETTINGS_CREATEICONS     4020
#define ID_MENU_SETTINGS_LOAD            4030
#define ID_MENU_SETTINGS_SAVE            4040
#define ID_MENU_SETTINGS_SAVEAS          4050

#define ID_MENU_USER_MACRO1              5010
#define ID_MENU_USER_MACRO2              5020
#define ID_MENU_USER_MACRO3              5030
#define ID_MENU_USER_MACRO4              5040
#define ID_MENU_USER_MACRO5              5050
#define ID_MENU_USER_MACRO6              5060
#define ID_MENU_USER_MACRO7              5070
#define ID_MENU_USER_MACRO8              5080
#define ID_MENU_USER_MACRO9              5090
#define ID_MENU_USER_MACRO10             5100


/*
 * MESSAGE IDs -----------------------------
 */
«FOREACH:WINDOW»
/***** WINDOW: «WSI» *****/
#define ID_BUT_«WSI»_OK              «GADGETID:998»
#define ID_BUT_«WSI»_CANCEL          «GADGETID:999»
«ENDEACH»


/*
 * JMH-APP-TEMPLATE FUNCTION PROTOTYPES ----
 */
void    JMH_About          ( void );
LONG    JMH_Error          ( char *, APTR, BOOL, char *, char *, LONG );
BOOL    JMH_FileReq        ( APTR, UBYTE *, BOOL, BOOL, UBYTE *, UWORD );
VOID    JMH_InitVars       ( void );
ULONG   JMH_LaunchProgram  ( BOOL, UBYTE *, BOOL );
void    JMH_Quit           ( char * );
void    JMH_Startup        ( int, char *[] );
void    JMH_WindowTitle    ( APTR );

APTR    JMH_ShowWaitBox    ( APTR, UBYTE *, UBYTE * );
BOOL    JMH_HideWaitBox    ( APTR, APTR );
USHORT  JMH_Strip          ( UBYTE *, UBYTE * );
USHORT  JMH_CStrip         ( UBYTE *, UBYTE * );
UBYTE  *JMH_PadStr         ( UBYTE *, UBYTE, BYTE, USHORT );
double  JMH_Round          ( double, BYTE );
BOOL    JMH_IsNumberValid  ( UBYTE *, BYTE );
BOOL    JMH_VerifyLegitDate( UBYTE * );


/*
 * STRUCTURE DEFINITIONS -------------------
 */
struct MyGlobals {
   APTR  App;
«FOREACH:WINDOW»
   APTR  WIN_«WSI»;
«ENDEACH»

   struct DiskObject *dobj_App, *dobj_Proj;
   UBYTE  szProjectSpec[ FMSIZE+1 ];

   BOOL   running;
};

«FOREACH:WINDOW»
struct «WSN» {
   APTR  BUT_OK,
         BUT_Cancel;
};
«ENDEACH»


/*
 * APPLICATION FUNCTION PROTOTYPES ------------------
 */
BOOL fnOpen( UBYTE *, BOOL );
BOOL fnSave( UBYTE *, BOOL );

«FOREACH:WINDOW»
BOOL fnConstruct«WSN»( void );
BOOL fnInit«WSN»( void );
BOOL fnDestruct«WSN»( BOOL );
void fnClear«WSN»( void );
«ENDEACH»
«ENDFILE»


«FILE:jmh.j»
/*
 * JMH App Template  (C) «YEAR» «APPOWNER»
 *                   All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 */

#include "common.h"

/**
 **   G L O B A L   V A R I A B L E S  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 **/
extern struct MyGlobals  MG;
extern UBYTE             GL_szFault[256];
extern struct DosBase   *DosBase;


#ifdef DEBUG_REXX
/**
 **   D E B U G   H O O K S  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 **/
SAVEDS ASM APTR fnRexxDebug(REG(a0) struct Hook *hook, REG(a2) APTR app, REG(a1) struct RexxMsg *pRexxMsg )
{
   UBYTE *pszAppTitle;
   SHORT  i;


   get( app, MUIA_Application_Title, &pszAppTitle );
   printf( "***** MUI REXX DEBUG HOOK FOR %s *****\n", pszAppTitle );
   printf( "   rm_Action  = %ld\n", pRexxMsg->rm_Action );
   printf( "   rm_Result1 = %ld\n", pRexxMsg->rm_Result1 );
   printf( "   rm_Result2 = %ld\n", pRexxMsg->rm_Result2 );
   for ( i = 0; i < 15; i++ )
   {
      printf( "   rm_Args[%d] = '%s'\n", i, pRexxMsg->rm_Args[i] );
   }
   printf( "\n" );
   return(0);
}
static struct Hook hRexxDebugHook =
{
   {NULL, NULL},
   (void *)fnRexxDebug,
   NULL, NULL
};
#endif /* DEBUG_REXX */


/**
 **   S U B R O U T I N E S  -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 **/
//
// JMH_About(): show program info, basename, author, free memory, etc...
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void JMH_About( void )
{
   char  *pszVersion, *pszAuth, *pszCopyright, *pszBase, *pszDescrip;
   char   szAbout[1024];
   ULONG  ulChipFree, ulFastFree;


   get( MG.App, MUIA_Application_Version,     &pszVersion );
   get( MG.App, MUIA_Application_Author,      &pszAuth );
   get( MG.App, MUIA_Application_Copyright,   &pszCopyright );
   get( MG.App, MUIA_Application_Base,        &pszBase );
   get( MG.App, MUIA_Application_Description, &pszDescrip );

   ulChipFree = AvailMem( MEMF_CHIP );
   ulFastFree = AvailMem( MEMF_FAST );

   sprintf( szAbout, "\33c\33b%s\n\33c%s\n\33c%s\n\n\33c%s %s\n\n%s\n\n\
Graphics memory: %lu\nOther memory: %lu\n\nUsing Magic User Interface (MUI) by Stefan Stuntz",
                     pszVersion+6,
                     pszAuth,
                     pszCopyright,
                     "BASENAME:",
                     pszBase,
                     pszDescrip,
                     ulChipFree,
                     ulFastFree
          );

   MUI_Request( MG.App, NULL, 0, NULL, "*OK", szAbout, NULL );
}

//
// JMH_Error(): error routine that also provides help
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LONG JMH_Error( char *pszMsg, APTR pWindowObj, BOOL fARexx,
                char *pszHelpFile, char *pszHelpNode, LONG lHelpLine )
{
   LONG l;
   char *pszResponses;
   char *pszHelp   = "*OK|Help";
   char *pszNoHelp = "*OK";


   if ( fARexx )
   {
      set( MG.App, MUIA_Application_RexxMsg, pszMsg );
   }
   else
   {
      if ( pszHelpFile )   pszResponses = pszHelp;
      else                 pszResponses = pszNoHelp;

redisplay:
      l = MUI_Request( MG.App, pWindowObj, 0, NULL, "*OK|Help", pszMsg, NULL );
      if ( l == 0 )
      {
         if ( pszHelpFile && pszHelpNode )
         {
            DoMethod( MG.App, MUIM_Application_ShowHelp, pWindowObj,
                      pszHelpFile, pszHelpNode, lHelpLine );
         }
         else
         {
            MUI_Request( MG.App, pWindowObj, 0, NULL, "*OK", "No help is available for this topic.", NULL );
         }
         goto redisplay;
      }
   }
   return( l );
}

//
// JMH_FileReq(): Pop up a file requester...
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL JMH_FileReq( APTR pWindowObj, UBYTE *pszFreqHail, BOOL fSaveMode, BOOL fDirMode, UBYTE *pszSaveBuf, UWORD uwSaveBufSize )
{
   char  *psz;
   static char  szPathPart[ FMSIZE+1 ], szFilePart[ FMSIZE+1 ];

   struct Window        *pWindow = NULL;
   struct FileRequester *pFReq   = NULL;


   get( pWindowObj, MUIA_Window, &pWindow );
   if ( pFReq = MUI_AllocAslRequestTags( ASL_FileRequest, TAG_DONE ) )
   {
      strcpy( szPathPart, pszSaveBuf );
      psz = FilePart( szPathPart );
      if ( psz )
      {
         strcpy( szFilePart, psz );
         *psz = 0;
      }
      else
      {
         strcpy( szFilePart, "" );
      }

      if ( MUI_AslRequestTags( pFReq,
                               ASLFR_Window        , pWindow,
                               ASLFR_PrivateIDCMP  , TRUE,
                               ASLFR_TitleText     , pszFreqHail,
                               ASLFR_InitialDrawer , szPathPart,
                               ASLFR_InitialFile   , szFilePart,
                               ASLFR_DoSaveMode    , fSaveMode,
                               ASLFR_DrawersOnly   , fDirMode,
                               TAG_DONE ) )
      {
         // set the new contents for our string gadget
         *pszSaveBuf = 0;
         strncpy( pszSaveBuf, pFReq->fr_Drawer, uwSaveBufSize-1 );
         AddPart( pszSaveBuf, pFReq->fr_File,   uwSaveBufSize-1 );
      }
      else
      {
         MUI_FreeAslRequest( pFReq );
         return( FALSE );
      }

      MUI_FreeAslRequest( pFReq );
   }
   else
   {
      return( FALSE );
   }

   return( TRUE );
}

//
// JMH_InitVars(): initialize variables to default values
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
VOID JMH_InitVars()
{
   //
   // initialize variables...
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   GL_szFault[0] = 0;

   //
   // init window objects to NULL
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
«FOREACH:WINDOW»
   MG.WIN_«WSI» = NULL;
«ENDEACH»

   //
   // open libraries
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   MUIMasterBase = OpenLibrary(MUIMASTER_NAME, «MUIMASTER_VERSION»);
   if (!MUIMasterBase) JMH_Quit("Cannot open muimaster.library" );

«IF:ASL_INCL»
   AslBase = OpenLibrary("asl.library",«ASL_VERSION»);
   if (!AslBase) JMH_Quit("Cannot open asl.library «ASL_VERSION»+");

«ENDIF»
«IF:DATATYPES_INCL»
   DataTypesBase = (struct Library *)OpenLibrary("datatypes.library",«DATATYPES_VERSION»);
   if (!DataTypesBase) JMH_Quit("Cannot open datatypes.library «DATATYPES_VERSION»+" );

«ENDIF»
«IF:DISKFONT_INCL»
   DiskfontBase = (struct Library *)OpenLibrary("diskfont.library", «DISKFONT_VERSION»);
   if (!DiskfontBase) JMH_Quit("Cannot open diskfont.library «DISKFONT_VERSION»+");

«ENDIF»
   DosBase = (struct DosBase *)OpenLibrary( "dos.library", «DOS_VERSION» );
   if ( !DosBase ) JMH_Quit("Cannot open dos.library «DOS_VERSION»+");

«IF:GADTOOLS_INCL»
   GadToolsBase = (struct Library *)OpenLibrary("gadtools.library", «GADTOOLS_VERSION»);
   if (!GadToolsBase) JMH_Quit("Cannot open gadtools.library «GADTOOLS_VERSION»+");

«ENDIF»
   GfxBase = (struct GfxBase *)OpenLibrary("graphics.library",«GFX_VERSION»);
   if (!GfxBase) JMH_Quit("Cannot open graphics.library «GFX_VERSION»+");

   IconBase = (struct Library *)OpenLibrary("icon.library",«ICON_VERSION»);
   if (!IconBase) JMH_Quit("Cannot open icon.library «ICON_VERSION»+");

«IF:IFFPARSE_INCL»
   IFFParseBase = (struct Library *)OpenLibrary("iffparse.library",«IFFPARSE_VERSION»);
   if (!IFFParseBase) JMH_Quit("Cannot open iffparse.library «IFFPARSE_VERSION»+");

«ENDIF»
   IntuitionBase = (struct IntuitionBase *)OpenLibrary("intuition.library",«INTUITION_VERSION»);
   if (!IntuitionBase) JMH_Quit("Cannot open intuition.library «INTUITION_VERSION»+");

«IF:LOCALE_INCL»
   LocaleBase = OpenLibrary("locale.library",«LOCALE_VERSION»);
   if (!LocaleBase) JMH_Quit("Cannot open locale.library «LOCALE_VERSION»+");

«ENDIF»
«IF:REALTIME_INCL»
   RealTimeBase = OpenLibrary("realtime.library", «REALTIME_VERSION»);
   if (!RealTimeBase) JMH_Quit("Cannot open realtime.library «REALTIME_VERSION»+" );

«ENDIF»
   UtilityBase = (struct Library *)OpenLibrary("utility.library",«UTILITY_VERSION»);
   if (!UtilityBase) JMH_Quit("Cannot open utility.library «UTILITY_VERSION»+" );

«IF:WORKBENCH_INCL»
   WorkbenchBase = (struct Library *)OpenLibrary("workbench.library",«WORKBENCH_VERSION»);
   if (!WorkbenchBase) JMH_Quit("Cannot open workbench.library «WORKBENCH_VERSION»+");
«ENDIF»
}

//
// JMH_LaunchProgram(): launch a system program
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ULONG JMH_LaunchProgram( BOOL fARexx, UBYTE *pszProgram, BOOL fAsync )
{
   ULONG  rc = RETURN_OK;     // assume ARexx success...
   LONG   lStat;
   UBYTE  szBuf[512];


   if ( !fAsync )    set( MG.App, MUIA_Application_Sleep, TRUE );

   lStat = SystemTags( pszProgram, SYS_Asynch, fAsync, TAG_DONE, TAG_DONE );
   if ( lStat != 0 )
   {
      if ( lStat > 0 )
      {
         sprintf( szBuf, "Unable to launch %s because", pszProgram );
         Fault( IoErr(),
                szBuf,
                GL_szFault,
                sizeof( GL_szFault ) );
      }
      else
      {
         sprintf( GL_szFault, "Unable to launch %s!", pszProgram );
      }

      JMH_Error( GL_szFault, NULL, fARexx, "«HELPFILE»", "errors", 0 );
      rc = RETURN_ERROR;
   }

   if ( !fAsync )    set( MG.App, MUIA_Application_Sleep, FALSE );

   return( rc );
}

//
// JMH_Quit(): close down everything we've opened and JMH_Quit
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void JMH_Quit( char *t )
{
   char  szQuitBuf[256+20];


   if (t)
   {
      sprintf( szQuitBuf, "%s\nExiting...", t );
      MUI_Request( MG.App, NULL, 0, NULL, "*OK", szQuitBuf, NULL );
   }

   // free app object
   if ( MG.App )        MUI_DisposeObject( MG.App );

   // free disk object (project icon)
   if ( MG.dobj_Proj )  FreeDiskObject( MG.dobj_Proj );

   // free disk object (icon)
   if ( MG.dobj_App )   FreeDiskObject( MG.dobj_App );

   // close libraries
«IF:WORKBENCH_INCL»
   if (WorkbenchBase)   CloseLibrary(WorkbenchBase);
«ENDIF»
   if (UtilityBase)     CloseLibrary(UtilityBase);
«IF:REALTIME_INCL»
   if (RealTimeBase)    CloseLibrary(RealTimeBase);
«ENDIF»
«IF:LOCALE_INCL»
   if (LocaleBase)      CloseLibrary(LocaleBase);
«ENDIF»
   if (IntuitionBase)   CloseLibrary((struct Library *)IntuitionBase);
«IF:IFFPARSE_INCL»
   if (IFFParseBase)    CloseLibrary(IFFParseBase);
«ENDIF»
   if (IconBase)        CloseLibrary(IconBase);
   if (GfxBase)         CloseLibrary((struct Library *)GfxBase);
«IF:GADTOOLS_INCL»
   if (GadToolsBase)    CloseLibrary(GadToolsBase);
«ENDIF»
   if (DosBase)         CloseLibrary((struct Library *)DosBase);
«IF:DISKFONT_INCL»
   if (DiskfontBase)    CloseLibrary(DiskfontBase);
«ENDIF»
«IF:DATATYPES_INCL»
   if (DataTypesBase)   CloseLibrary(DataTypesBase);
«ENDIF»
«IF:ASL_INCL»
   if (AslBase)         CloseLibrary(AslBase);
«ENDIF»
   if (MUIMasterBase)   CloseLibrary(MUIMasterBase);

   exit(0);
}

//
// JMH_Startup(): handle arguments, setup environment, init vars/GUI...
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void JMH_Startup( int argc, char *argv[] )
{
   static char       *programname;
   static char        programpath[ FMSIZE+2 ];
   BPTR               tmplock;
   struct WBStartup  *WBenchMsg   = NULL;
//   char              *psz;
   struct CLIArgs
   {
      UBYTE *pszProject;
//    LONG   moreparamshere;
//    LONG   moreparamshere;
//    LONG   moreparamshere;
   } argarray = { 0 };
   struct RDArgs     *rda, *rdas;
   static UBYTE      *pszCLITemplate = "PROJECTFILE";
   static UBYTE      *pszCLIHelp     = "«APPNAME» «APPVERS»  (C) «YEAR»  «APPAUTH»\n";
   UBYTE            **ttypes;


   JMH_InitVars();

   // run from Workbench or CLI/Shell?
   if ( argc > 0 )
   {
      // set defaults
      strcpy( MG.szProjectSpec  , "" );

      // get opts from command line
      if ( rdas = AllocDosObject( DOS_RDARGS, NULL ) )
      {
         rdas->RDA_ExtHelp = pszCLIHelp;

         if ( rda = ReadArgs( pszCLITemplate, (LONG *)&argarray, rdas ) )
         {
            if ( argarray.pszProject )
            {
               strcpy( MG.szProjectSpec, argarray.pszProject );
            }
            FreeArgs( rda );
         }
         FreeDosObject( DOS_RDARGS, rdas );
      }

      //
      // get program name so we can lock icon...
      // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      GetProgramName( programpath, FMSIZE );
      programname = FilePart( programpath );
   }
   else
   {
      // get opts from TOOLTYPES in icon
      strcpy( MG.szProjectSpec, "" );   // passed as param under WB

      ttypes = ArgArrayInit( argc, argv );

      // parse tooltypes here...
//      psz = ArgString( ttypes, "CONFIGFILE", "" );
//      strcpy( MG.szProjectSpec, psz );

//      psz = ArgString( ttypes, "NOGUI", "FALSE" );
//      if ( strcmpi( psz, "TRUE" ) == 0 )
//      {
//         MG.fBeQuiet = TRUE;
//      }
//      else
//      {
//         MG.fBeQuiet = FALSE;
//      }

      ArgArrayDone();

      //
      // get program name so we can lock icon...
      // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      WBenchMsg   = (struct WBStartup *)argv;
      programname = WBenchMsg->sm_ArgList->wa_Name;

      tmplock  = Lock( programname, ACCESS_READ );
      NameFromLock( tmplock, programpath, FMSIZE );
      UnLock( tmplock );
   }

   // try to get disk object (application icon)
   MG.dobj_App = GetDiskObject( programname );

   // try to get disk object (project icon)
   MG.dobj_Proj = GetDiskObjectNew( "PROGDIR:icons/def_project" );

   //
   // set up the MUI application object
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   MG.App = ApplicationObject,
      MUIA_Application_Title      , "«APPTITLE»",
      MUIA_Application_Version    , "«APPVERS»",
      MUIA_Application_Copyright  , "«APPCOPYR»",
      MUIA_Application_Author     , "«APPAUTH»",
      MUIA_Application_Description, "«APPDESC»",
      MUIA_Application_Base       , "«APPBASE»",
      MUIA_Application_DiskObject , MG.dobj_App,
#ifdef DEBUG_REXX
      MUIA_Application_RexxHook   , &hRexxDebugHook,
#endif
      MUIA_Application_HelpFile   , "«HELPFILE»",
      End;

   if ( !MG.App )
      JMH_Quit( "Failed to create Application." );
}

//
// JMH_VerifyLegitDate()
// RETURNS:       BOOL - TRUE if legitimate
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL JMH_VerifyLegitDate( UBYTE pszDate[] )
{
   USHORT  usYear, usMonth, usDay;
   UBYTE   szYear[5], szMonth[3], szDay[3];
   BOOL    rc;                               // return code

   static USHORT usDaysPerMo[] = {
      31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
   };


   sprintf( szYear,  "%-4.4s", &pszDate[6] );
   sprintf( szMonth, "%-2.2s", &pszDate[0] );
   sprintf( szDay,   "%-2.2s", &pszDate[3] );
   usYear  = atoi( szYear );
   usMonth = atoi( szMonth );
   usDay   = atoi( szDay );

   if ( ( usYear % 4 ) == 0 )
   {
      usDaysPerMo[1] = 29;
   }
   else
   {
      usDaysPerMo[1] = 28;
   }

   if ( ( usMonth < 1 ) || ( usMonth > 12 ) )
   {
      rc = FALSE;
   }
   else
   {
      if ( ( usDay < 1 ) || ( usDay > usDaysPerMo[usMonth-1] ) )
      {
         rc = FALSE;
      }
      else
      {
         rc = TRUE;
      }
   }
   return( rc );
}

//
// JMH_WindowTitle(): set window title as PROGNAME: current-filespec
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
void JMH_WindowTitle( APTR win )
{
   static char  szWindowTitle[256];
   char        *pszTitle;


   get( MG.App, MUIA_Application_Title, &pszTitle );
   sprintf( szWindowTitle, "%s: ", pszTitle );
   strncat( szWindowTitle, MG.szProjectSpec, 256-32-1 );
   szWindowTitle[255] = 0;
   set( win, MUIA_Window_Title, szWindowTitle );
}

//
// JMH_ShowWaitBox(): show wait box
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
APTR JMH_ShowWaitBox( APTR app, UBYTE *title, UBYTE *text )
{
   Object *pWaitBox;


   pWaitBox = WindowObject,
      MUIA_Window_Title, title,
      MUIA_Window_Menu, MUIV_Window_Menu_NoMenu,
      WindowContents, VGroup,
         Child, FloattextObject,
            MUIA_Floattext_Text, text,
            End,
         End,
      End;
   if ( pWaitBox )
   {
      // add window to Application object
      DoMethod( app, OM_ADDMEMBER, pWaitBox );

      set( pWaitBox, MUIA_Window_Open, TRUE );
   }

   return( pWaitBox );
}

//
// JMH_HideWaitBox(): hide wait box
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL JMH_HideWaitBox( APTR app, APTR pWaitBox )
{
   BOOL  fOpen;


   get( pWaitBox, MUIA_Window_Open, &fOpen );
   if ( fOpen )
   {
      set( pWaitBox, MUIA_Window_Open, FALSE );
      DoMethod( app, OM_REMMEMBER, pWaitBox );
   }

   return( fOpen );
}

//
// JMH_Strip(): strip chars from string
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
USHORT JMH_Strip( UBYTE *pszStrip, UBYTE *pszStripChars )
{
  UBYTE *pszOrig,  // used to access each character in the given string.
        *pszPack;  // used to place (pack) characters not being stripped
                   // back into given string.

  for ( pszOrig = pszPack = pszStrip; *pszOrig; pszOrig++ )
  {
    //
    // When current character of the original string is one of the characters
    // in the strip string do not place it in the stripped (packed) string.
    //
    if ( strchr( pszStripChars, *pszOrig ) == NULL )
    {
      *( pszPack++ ) = *pszOrig;
    }
  }
  *pszPack = 0;

  return( (USHORT)strlen( pszStrip ) );
}

//
// JMH_CStrip(): strip chars not in KeepString
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
USHORT JMH_CStrip( UBYTE *pszStrip, UBYTE *pszKeepChars )
{
  UBYTE *pszOrig,  // used to access each character in the given string.
        *pszPack;  // used to place (pack) characters not being stripped
                   // back into given string.

  for ( pszOrig = pszPack = pszStrip; *pszOrig; pszOrig++ )
  {
    //
    // When current character of the original string is not one of the chars
    // in the keep string do not place it in the stripped (packed) string.
    //
    if ( strchr( pszKeepChars, *pszOrig ) != NULL )
    {
      *( pszPack++ ) = *pszOrig;
    }
  }
  *pszPack = 0;

  return( (USHORT)strlen( pszStrip ) );
}

//
// JMH_PadStr(): pads a string from left or right with given character
// PARAMETERS:  UCHAR *szPad   - String to be padded
//              UCHAR  chPad   - character to pad string with
//              BYTE   bPadDir - Specifies where to pad string
//                               Valid values are:
//                                  -1: left side
//                                  +1: right side
//              USHORT usSize  - desired size of the padded string
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UBYTE *JMH_PadStr( UBYTE *pszPad, UBYTE chPad, BYTE bPadDir, USHORT usSize )
{
  USHORT usStrLen,    // Length of the given string before padding
         usPadChars;  // Number of Pad characters that need to be added to
                      // the given string

  if ( (usStrLen = strlen( pszPad )) < usSize )
  {
    usPadChars = usSize - usStrLen;
    if ( bPadDir == -1 )
    {
      //
      // Pad from the left
      //
      memmove( (pszPad + usPadChars), pszPad, usStrLen + 1);
      memset( pszPad, chPad, usPadChars );
    }
    else
    {
      //
      // Pad from the right
      //
      memset( (pszPad + usStrLen), chPad, usPadChars );
      *(pszPad + usSize) = 0;
    }
  }

  return( pszPad );
}

//
// JMH_Round(): round a double to a given number of decimals
// PARAMETERS:  double dblValue  - Value to be rounded.
//              BYTE   bDecimals - Number of decimal places to round
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
double JMH_Round( double dblValue, BYTE bDecimals )
{
  SHORT  sSign;
  double dblFactor,
         dblInt;

  sSign     = ( dblValue >= 0.0 ) ? 1 : -1;
  dblFactor = pow( (double)10, (double)bDecimals );
  dblInt    = floor( dblValue * (double)sSign );

  return( ( dblInt + floor( ( dblValue * sSign - dblInt ) * dblFactor + 0.51 )
            / dblFactor) * sSign );
}

//
// JMH_IsNumberValid(): does string contain only numeric chars?
// PARAMETERS:  UBYTE *pszNum    - Numeric string to be verified
//               BYTE  bType:  1 = Positive-Only Integer
//                             2 = Positive-Only Float
//                            -1 = Positive or Negative Integer
//                            -2 = Positive or Negative Float
//                             0 = Positive or Negative Float (default)
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BOOL JMH_IsNumberValid( UBYTE *pszNum, BYTE bType )
{
   USHORT  us = 0;

   static UBYTE *pszValids[] = {
      "0123456789-.",
      "0123456789-",
      "0123456789-.",
      "0123456789",
      "0123456789.",
      NULL
   };


   if ( ( bType >= -2 ) && ( bType <= 2 ) )
   {
      us = strspn( pszNum, pszValids[ bType+2 ] );
   }

   return( (BOOL)( ( us == strlen( pszNum ) ) ? TRUE : FALSE ) );
}
«ENDFILE»


«FILE:main.j»
/*
 * «APPNAME» Main   (C) «YEAR» «APPOWNER»
 *                  All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 */

#include "common.h"
«IF:REXX»
extern struct MUI_Command *RXCommands;
«ENDIF»

/*
 * GLOBAL VARIABLES ---------------------------------
 */
struct MyGlobals  MG;
char              GL_szFault[256];

«FOREACH:WINDOW»
struct «WSN»   «WSI»;
«ENDEACH»


/*
 * DEFINES ------------------------------------------
 */


/*
 * LIBRARY VARIABLES ---------------------------------
 */
«IF:ASL_INCL»
struct Library       *AslBase       = NULL;
«ENDIF»
«IF:DATATYPES_INCL»
struct Library       *DataTypesBase = NULL;
«ENDIF»
«IF:DISKFONT_INCL»
struct Library       *DiskfontBase  = NULL;
«ENDIF»
struct DosBase       *DosBase       = NULL;
«IF:GADTOOLS_INCL»
struct Library       *GadToolsBase  = NULL;
«ENDIF»
struct GfxBase       *GfxBase       = NULL;
struct Library       *IconBase      = NULL;
«IF:IFFPARSE_INCL»
struct Library       *IFFParseBase  = NULL;
«ENDIF»
struct IntuitionBase *IntuitionBase = NULL;
«IF:LOCALE_INCL»
struct Library       *LocaleBase    = NULL;
«ENDIF»
struct Library       *MUIMasterBase = NULL;
«IF:REALTIME_INCL»
struct Library       *RealTimeBase  = NULL;
«ENDIF»
struct Library       *UtilityBase   = NULL;
«IF:WORKBENCH_INCL»
struct Library       *WorkbenchBase = NULL;
«ENDIF»


/**
 ** M A I N   P R O G R A M -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
 **/
void main(int argc, char *argv[])
{
   ULONG   signals;
   ULONG   ulInputEvent;
«MENUIF:42»   UBYTE   szPrefsSpec[ FMSIZE+2 ];«ENDIF»
   Object *aboutwin = NULL;

   // generic status vars
   LONG    lStat;
//   ULONG   ulStat;
//   char   *pszStat;

   BPTR               tmplock;
   struct WBStartup  *WBenchMsg   = NULL;
   struct WBArg      *pWBArg      = NULL;

   char               szProgramSpec[ FMSIZE+1 ];


   MG.running = TRUE;

   //
   // setup variables, read startup params, etc...
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   JMH_Startup( argc, argv );

   //
   // attempt to create window objects and attach to application parent
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
«FOREACH:WINDOW»
   if ( fnConstruct«WSN»() == FALSE )   {  JMH_Quit( "Failed to create «WSI» window." );  }
«ENDEACH»

   //
   // Load application settings; populate global vars
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   DoMethod( MG.App, MUIM_Application_Load, MUIV_Application_Load_ENV );

   //
   // open main window
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
«FOREACH:WINDOW»
   fnInit«WSN»();
«ENDEACH»

   //
   // if we're passed a data file, load it
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   if ( argc > 1 )
   {
      if ( fnOpen( argv[1], FALSE ) == FALSE )
      {
         strcpy( MG.szProjectSpec, argv[1] );
      }
   }
   else
   {
      WBenchMsg   = (struct WBStartup *)argv;
      pWBArg      = WBenchMsg->sm_ArgList;

      pWBArg++;   // get first parameter

      if ( pWBArg )
      {
         if ( ( pWBArg->wa_Lock ) && ( *pWBArg->wa_Name ) )
         {
            tmplock  = Lock( pWBArg->wa_Name, ACCESS_READ );
            NameFromLock( tmplock, szProgramSpec, FMSIZE );
            if ( fnOpen( szProgramSpec, FALSE ) == FALSE )
            {
               strcpy( MG.szProjectSpec, szProgramSpec );
            }
            UnLock( tmplock );
         }
      }
   }

   //
   // show 'em what it's all 'About'
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   JMH_About();

   //
   //   MAIN LOOP          MAIN LOOP         MAIN LOOP         MAIN LOOP
   // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   while ( MG.running )
   {
      ulInputEvent = DoMethod( MG.App, MUIM_Application_Input, &signals );
      switch ( ulInputEvent )
      {
         case MUIV_Application_ReturnID_Quit:
         case ID_MENU_PROJECT_QUIT:
            get( MG.App, MUIA_Application_ForceQuit, &lStat );
            if ( lStat == TRUE )
            {
               MG.running = FALSE;
            }
            else if ( MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                                   "Are you sure you want to quit?", NULL ) == 1 )
            {
               MG.running = FALSE;
            }
            break;

         // MENUS ---------------------------------------------
«MENUIF:01»         case ID_MENU_PROJECT_NEW:
            if ( MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                              "Are you sure you wish to clear all data?", NULL ) == 1 )
            {
//               fnNew( FALSE );
            }
            break;
«ENDIF»«MENUIF:03»         case ID_MENU_PROJECT_OPEN:
            if ( JMH_FileReq( MG.WIN_«WSI», "Open issue file", FALSE, FALSE, MG.szProjectSpec, sizeof( MG.szProjectSpec ) ) )
            {
               fnOpen( MG.szProjectSpec, FALSE );
            }
            break;
«ENDIF»«MENUIF:04»         case ID_MENU_PROJECT_SAVE:
            if ( strcmp( MG.szProjectSpec, "" ) == 0 )
            {
               JMH_FileReq( MG.WIN_«WSI», "Save issue file", TRUE, FALSE, MG.szProjectSpec, sizeof( MG.szProjectSpec ) );
            }

            if ( strcmp( MG.szProjectSpec, "" ) != 0 )
            {
               fnSave( MG.szProjectSpec, FALSE );
            }
            break;
«ENDIF»«MENUIF:05»         case ID_MENU_PROJECT_SAVEAS:
            if ( JMH_FileReq( MG.WIN_«WSI», "Save issue file", TRUE, FALSE, MG.szProjectSpec, sizeof( MG.szProjectSpec ) ) )
            {
               fnSave( MG.szProjectSpec, FALSE );
            }
            break;
«ENDIF»«MENUIF:07»         case ID_MENU_PROJECT_PRINT:
            break;
«ENDIF»«MENUIF:08»         case ID_MENU_PROJECT_PRINTAS:
            JMH_LaunchProgram( FALSE, "SYS:Prefs/Printer", TRUE );
            break;
«ENDIF»«MENUIF:10»         case ID_MENU_PROJECT_HIDE:
            break;
«ENDIF»«MENUIF:11»         case ID_MENU_PROJECT_REVEAL:
            break;
«ENDIF»«MENUIF:12»         case ID_MENU_PROJECT_CLOSE:
            break;
«ENDIF»«MENUIF:14»         case ID_MENU_PROJECT_ABOUT:
            JMH_About();
            break;
«ENDIF»«MENUIF:15»         case ID_MENU_PROJECT_ABOUTMUI:
            if ( !aboutwin )
            {
               aboutwin = AboutmuiObject,
                  MUIA_Window_RefWindow    , MG.WIN_«WSI»,
                  MUIA_Aboutmui_Application, MG.App,
                  End;
            }
            if ( aboutwin )
               set( aboutwin, MUIA_Window_Open, TRUE );
            else
               DisplayBeep(0);
            break;
«ENDIF»«MENUIF:17»         case ID_MENU_PROJECT_EXITLEVEL:
            break;
«ENDIF»
«MENUIF:21»         case ID_MENU_EDIT_CUT:
            break;
«ENDIF»«MENUIF:22»         case ID_MENU_EDIT_COPY:
            break;
«ENDIF»«MENUIF:23»         case ID_MENU_EDIT_PASTE:
            break;
«ENDIF»«MENUIF:25»         case ID_MENU_EDIT_ERASE:
            break;
«ENDIF»«MENUIF:27»         case ID_MENU_EDIT_UNDO:
            break;
«ENDIF»«MENUIF:28»         case ID_MENU_EDIT_REDO:
            break;
«ENDIF»
«MENUIF:30»         case ID_MENU_MACROS_STARTLEARNING:
            break;
«ENDIF»«MENUIF:31»         case ID_MENU_MACROS_STOPLEARNING:
            break;
«ENDIF»«MENUIF:32»         case ID_MENU_MACROS_ASSIGNMACRO:
            break;
«ENDIF»«MENUIF:33»         case ID_MENU_MACROS_LOAD:
            break;
«ENDIF»«MENUIF:34»         case ID_MENU_MACROS_SAVE:
            break;
«ENDIF»
«MENUIF:36»         case ID_MENU_SETTINGS_MUI:
            DoMethod( MG.App, MUIM_Application_OpenConfigWindow, 0L );
            break;
«ENDIF»«MENUIF:38»         case ID_MENU_SETTINGS_CREATEICONS:
            break;
«ENDIF»«MENUIF:40»         case ID_MENU_SETTINGS_LOAD:
            DoMethod( MG.App, MUIM_Application_Load, MUIV_Application_Load_ENV );
            break;
«ENDIF»«MENUIF:41»         case ID_MENU_SETTINGS_SAVE:
            DoMethod( MG.App, MUIM_Application_Save, MUIV_Application_Save_ENVARC );
            break;
«ENDIF»«MENUIF:42»         case ID_MENU_SETTINGS_SAVEAS:
            if ( JMH_FileReq( MG.WIN_«WSI», "Save issue file", TRUE, FALSE, szPrefsSpec, sizeof( szPrefsSpec ) ) )
            {
               DoMethod( MG.App, MUIM_Application_Save, szPrefsSpec );
            }
            break;
«ENDIF»
«MENUIF:44»         case ID_MENU_USER_MACRO1:
            break;
«ENDIF»«MENUIF:45»         case ID_MENU_USER_MACRO2:
            break;
«ENDIF»«MENUIF:46»         case ID_MENU_USER_MACRO3:
            break;
«ENDIF»«MENUIF:47»         case ID_MENU_USER_MACRO4:
            break;
«ENDIF»«MENUIF:48»         case ID_MENU_USER_MACRO5:
            break;
«ENDIF»«MENUIF:49»         case ID_MENU_USER_MACRO6:
            break;
«ENDIF»«MENUIF:50»         case ID_MENU_USER_MACRO7:
            break;
«ENDIF»«MENUIF:51»         case ID_MENU_USER_MACRO8:
            break;
«ENDIF»«MENUIF:52»         case ID_MENU_USER_MACRO9:
            break;
«ENDIF»«MENUIF:53»         case ID_MENU_USER_MACRO10:
            break;
«ENDIF»

         // GADGETS -------------------------------------------
«FOREACH:WINDOW»
         /***** WINDOW: «WSI»        *****/
         case ID_BUT_«WSI»_OK:
            fnDestruct«WSN»( TRUE );
            break;
         case ID_BUT_«WSI»_CANCEL:
            fnDestruct«WSN»( FALSE );
            break;
«ENDEACH»
      }
      if ( MG.running && signals ) Wait(signals);
   }

   set( MG.WIN_«WSI», MUIA_Window_Open, FALSE );
   JMH_Quit( NULL );
}
«ENDFILE»


«FILE:subs.j»
/*
 * «APPNAME» Windows   (C) «YEAR» «APPOWNER»
 *                     All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 */

#include "common.h"


extern struct MyGlobals   MG;
extern UBYTE              GL_szFault[];

extern struct «WSN»  «WSI»;


BOOL fnOpen( UBYTE *pszFile, BOOL fARexx )
{
   BOOL   fError = TRUE;   // assume failure
   BPTR   fhFile;
   UBYTE  szBuf[512];


   fhFile = Open( pszFile, MODE_OLDFILE );
   if ( fhFile )
   {
      //
      // Check FILEID_HEADER
      // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      if ( FGets( fhFile, szBuf, 511 ) != 0 )
      {
         szBuf[ strlen(szBuf)-1 ] = 0;
         if ( strcmp( szBuf, FILEID_HEADER ) == 0 )
         {
            //
            // Header checks out... let's read some data...
            // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
            fnClearMAIN();

            // load data here ****

            Close( fhFile );

            strcpy( MG.szProjectSpec, pszFile );
            JMH_WindowTitle( MG.WIN_«WSI» );
            fError = FALSE;
         }
         else
         {
            JMH_Error( "This is not an «APPNAME» file!", MG.WIN_«WSI», fARexx, "«HELPFILE»", "errors", 0 );
            fError = FALSE;
         }
      }
   }

   if ( fError )
   {
      strcpy( GL_szFault, "" );
      Fault( IoErr(), "File error!\n", GL_szFault, 255 );
      if ( strcmp( GL_szFault, "" ) == 0 )
      {
         strcpy( GL_szFault, "File Error!\n" );
      }
      sprintf( szBuf, "\nFile: %s", pszFile );
      strcat( GL_szFault, szBuf );
      JMH_Error( GL_szFault, MG.WIN_«WSI», fARexx, "«HELPFILE»", "errors", 0 );
   }

   return( fError );
}

BOOL fnSave( UBYTE *pszFile, BOOL fARexx )
{
   BOOL   fError;
   BPTR   fhFile;
   UBYTE  szBuf[512];

   struct DiskObject *pDObj = NULL;


   fhFile = Open( pszFile, MODE_READWRITE );
   for ( fError = TRUE; fhFile; )     // assume error; reset at end of context
   {
      if ( FPrintf( fhFile, "%s\n", FILEID_HEADER ) == -1 )       break;
      Flush( fhFile );
// **** SAVE HERE...      fError = DoMethod( MAIN.DLIS_List, MUIM_DataList_Save, fhFile );
      break;
   }
   if ( fError )
   {
      strcpy( GL_szFault, "" );
      Fault( IoErr(), "File error!\n", GL_szFault, 255 );
      if ( strcmp( GL_szFault, "" ) == 0 )
      {
         strcpy( GL_szFault, "File Error!\n" );
      }
      sprintf( szBuf, "\nFile: %s", pszFile );
      strcat( GL_szFault, szBuf );
      JMH_Error( GL_szFault, MG.WIN_«WSI», fARexx, "«HELPFILE»", "errors", 0 );
   }
   else
   {
      pDObj = GetDiskObject( MG.szProjectSpec );
      if ( !pDObj )
      {
         // don't write an icon if one already exists...
         pDObj = GetDiskObject( "env:icons/def_«APPBASE»" );
         if ( pDObj )
         {
            PutDiskObject( MG.szProjectSpec, pDObj );
            FreeDiskObject( pDObj );
         }
      }
      else
      {
         FreeDiskObject( pDObj );
      }
   }

   if ( fhFile )
   {
      Close( fhFile );
      JMH_WindowTitle( MG.WIN_«WSI» );
   }

   return( fError );
}
«ENDFILE»


«FILE:windows.j»
/*
 * «APPNAME» Windows   (C) «YEAR» «APPOWNER»
 *                     All Rights Under Copyright Reserved
 *
 * Version «VERSNUM»
 *
 * Written using «COMPILER»
 * Using Magic User Interface (MUI) by Stefan Stuntz
 *
 * By «APPAUTH»
 *
 *
 * Version~ Date~~~~~~~ Comments~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 * -------  ----        --------
 *             ;
 *
 *
 * Yeah, I know, icky title!
 */

#include "common.h"


struct NewMenu Menu_MAINMenu[] = {
«MENULINE:00»   NM_TITLE, (STRPTR)"Project", NULL, 0, NULL, NULL,
«MENULINE:01»   NM_ITEM, (STRPTR)"New"                , (STRPTR)"N", 0, 0L, (APTR)ID_MENU_PROJECT_NEW,
«MENULINE:02»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:03»   NM_ITEM, (STRPTR)"Open"               , (STRPTR)"O", 0, 0L, (APTR)ID_MENU_PROJECT_OPEN,
«MENULINE:04»   NM_ITEM, (STRPTR)"Save"               , (STRPTR)"S", 0, 0L, (APTR)ID_MENU_PROJECT_SAVE,
«MENULINE:05»   NM_ITEM, (STRPTR)"Save As..."         , (STRPTR)"A", 0, 0L, (APTR)ID_MENU_PROJECT_SAVEAS,
«MENULINE:06»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:07»   NM_ITEM, (STRPTR)"Print"              , (STRPTR)"P", 0, 0L, (APTR)ID_MENU_PROJECT_PRINT,
«MENULINE:08»   NM_ITEM, (STRPTR)"Print As..."        ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_PRINTAS,
«MENULINE:09»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:10»   NM_ITEM, (STRPTR)"Hide"               ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_HIDE,
«MENULINE:11»   NM_ITEM, (STRPTR)"Reveal..."          ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_REVEAL,
«MENULINE:12»   NM_ITEM, (STRPTR)"Close"              ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_CLOSE,
«MENULINE:13»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:14»   NM_ITEM, (STRPTR)"About..."           ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_ABOUT,
«MENULINE:15»   NM_ITEM, (STRPTR)"About MUI..."       ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_ABOUTMUI,
«MENULINE:16»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:17»   NM_ITEM, (STRPTR)"Exit Level"         ,        NULL, 0, 0L, (APTR)ID_MENU_PROJECT_EXITLEVEL,
«MENULINE:18»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:19»   NM_ITEM, (STRPTR)"Quit Program..."    , (STRPTR)"Q", 0, 0L, (APTR)ID_MENU_PROJECT_QUIT,
«MENULINE:20»   NM_TITLE, (STRPTR)"Edit", NULL, 0,  NULL, NULL,
«MENULINE:21»   NM_ITEM, (STRPTR)"Cut"                , (STRPTR)"X", 0, 0L, (APTR)ID_MENU_EDIT_CUT,
«MENULINE:22»   NM_ITEM, (STRPTR)"Copy"               , (STRPTR)"C", 0, 0L, (APTR)ID_MENU_EDIT_COPY,
«MENULINE:23»   NM_ITEM, (STRPTR)"Paste"              , (STRPTR)"V", 0, 0L, (APTR)ID_MENU_EDIT_PASTE,
«MENULINE:24»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:25»   NM_ITEM, (STRPTR)"Erase"              ,        NULL, 0, 0L, (APTR)ID_MENU_EDIT_ERASE,
«MENULINE:26»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:27»   NM_ITEM, (STRPTR)"Undo"               , (STRPTR)"Z", 0, 0L, (APTR)ID_MENU_EDIT_UNDO,
«MENULINE:28»   NM_ITEM, (STRPTR)"Redo"               ,        NULL, 0, 0L, (APTR)ID_MENU_EDIT_REDO,
«MENULINE:29»   NM_TITLE, (STRPTR)"Macros", NULL, 0, NULL, NULL,
«MENULINE:30»   NM_ITEM, (STRPTR)"Start Learning"     ,        NULL, 0, 0L, (APTR)ID_MENU_MACROS_STARTLEARNING,
«MENULINE:31»   NM_ITEM, (STRPTR)"Stop Learning"      ,        NULL, 0, 0L, (APTR)ID_MENU_MACROS_STOPLEARNING,
«MENULINE:32»   NM_ITEM, (STRPTR)"Assign Macro..."    ,        NULL, 0, 0L, (APTR)ID_MENU_MACROS_ASSIGNMACRO,
«MENULINE:33»   NM_ITEM, (STRPTR)"Load..."            ,        NULL, 0, 0L, (APTR)ID_MENU_MACROS_LOAD,
«MENULINE:34»   NM_ITEM, (STRPTR)"Save..."            ,        NULL, 0, 0L, (APTR)ID_MENU_MACROS_SAVE,
«MENULINE:35»   NM_TITLE, (STRPTR)"Settings", NULL, 0, NULL, NULL,
«MENULINE:36»   NM_ITEM, (STRPTR)"MUI..."             ,        NULL, 0, 0L, (APTR)ID_MENU_SETTINGS_MUI,
«MENULINE:37»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:38»   NM_ITEM, (STRPTR)"Create Icons?"      ,        NULL, 0, 0L, (APTR)ID_MENU_SETTINGS_CREATEICONS,
«MENULINE:39»   NM_ITEM, (STRPTR)NM_BARLABEL          ,        NULL, 0, 0L, NULL,
«MENULINE:40»   NM_ITEM, (STRPTR)"Load Settings..."   ,        NULL, 0, 0L, (APTR)ID_MENU_SETTINGS_LOAD,
«MENULINE:41»   NM_ITEM, (STRPTR)"Save Settings"      ,        NULL, 0, 0L, (APTR)ID_MENU_SETTINGS_SAVE,
«MENULINE:42»   NM_ITEM, (STRPTR)"Save Settings As...",        NULL, 0, 0L, (APTR)ID_MENU_SETTINGS_SAVEAS,
«MENULINE:43»   NM_TITLE, (STRPTR)"User", NULL, 0, NULL, NULL,
«MENULINE:44»   NM_ITEM, (STRPTR)"Macro 1"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO1,
«MENULINE:45»   NM_ITEM, (STRPTR)"Macro 2"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO2,
«MENULINE:46»   NM_ITEM, (STRPTR)"Macro 3"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO3,
«MENULINE:47»   NM_ITEM, (STRPTR)"Macro 4"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO4,
«MENULINE:48»   NM_ITEM, (STRPTR)"Macro 5"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO5,
«MENULINE:49»   NM_ITEM, (STRPTR)"Macro 6"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO6,
«MENULINE:50»   NM_ITEM, (STRPTR)"Macro 7"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO7,
«MENULINE:51»   NM_ITEM, (STRPTR)"Macro 8"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO8,
«MENULINE:52»   NM_ITEM, (STRPTR)"Macro 9"            ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO9,
«MENULINE:53»   NM_ITEM, (STRPTR)"Macro 10"           ,        NULL, 0, 0L, (APTR)ID_MENU_USER_MACRO10,
   NM_END, NULL, NULL, 0, 0L, NULL
};

extern struct MyGlobals  MG;
extern char              GL_szFault[256];

«FOREACH:WINDOW»
extern struct «WSN»           «WSI»;
«ENDEACH»


«FOREACH:WINDOW»
//
// WINDOW: «WSI»       ---------------------------------------------------
//
/*
 * APP MESSAGE HOOK FUNCTIONS -----------------------
 */
SAVEDS ASM LONG «WSI»_AppMsgFunc( REG(a2)APTR obj, REG(a1)struct AppMessage **appmsg )
{
   struct WBArg      *ap;
   struct AppMessage *amsg = *appmsg;
   static char        buf[256];
   BOOL               fSure = TRUE;    // sure you want to load this?


   ap = amsg->am_ArgList;
   NameFromLock( ap->wa_Lock, buf, sizeof( buf ) );
   AddPart( buf, ap->wa_Name, sizeof( buf ) );

// add condition here to choose whether or not to put up an "Are You Sure" message
   if ( 1 )
   {
      fSure = MUI_Request( MG.App, MG.WIN_«WSI», 0, NULL, "OK|*Cancel",
                           "Data is currently loaded.\nAre you sure you want to load the new file?", NULL );
   }
   if ( fSure == TRUE )
   {
      // load data file
      if ( fnOpen( buf, FALSE ) == FALSE )
      {
         strcpy( MG.szProjectSpec, buf );
      }
   }

   return( 0 );
}

static const struct Hook «WSI»_AppMsgHook = { { NULL,NULL }, (VOID *)«WSI»_AppMsgFunc, NULL, NULL };

BOOL fnConstruct«WSN»( void )
{
   MG.WIN_«WSI» = WindowObject,
      MUIA_Window_ID, MAKE_ID( «WID» ),
      MUIA_Window_Title, "«WTITLE»",
      MUIA_Window_Menu, «MENUPTR»,
      MUIA_Window_AppWindow, «APPWDW»,
      MUIA_HelpNode, "«WHELP»",
      WindowContents, VGroup,
         Child, SimpleButton("---      Dummy      ---"),
//                ...
         End,
      End;

   if ( !MG.WIN_«WSI» )
   {
      return( FALSE );
   }
   else
   {
      // make gadget connections
      DoMethod( MG.WIN_«WSI», MUIM_Notify, MUIA_AppMessage, MUIV_EveryTime,
                MG.App, 3, MUIM_CallHook, &«WSI»_AppMsgHook, MUIV_TriggerValue );

      DoMethod( MG.WIN_«WSI», MUIM_Notify, MUIA_Window_CloseRequest, TRUE,
                MG.App, 2, MUIM_Application_ReturnID, MUIV_Application_ReturnID_Quit );

      DoMethod( «WSI».BUT_OK    , MUIM_Notify, MUIA_Pressed, FALSE, MG.App, 2, MUIM_Application_ReturnID, ID_BUT_«WSI»_OK     );
      DoMethod( «WSI».BUT_Cancel, MUIM_Notify, MUIA_Pressed, FALSE, MG.App, 2, MUIM_Application_ReturnID, ID_BUT_«WSI»_CANCEL );

      // set up help for menus
      DoMethod( MG.App, MUIM_Notify, MUIA_Application_MenuHelp, MUIV_EveryTime,
                MG.App, 5, MUIM_Application_ShowHelp, MG.WIN_«WSI», "«HELPFILE»", "«MHELP»", 0 );

      // set tab cycle chain
      set( «WSI».BUT_OK    , MUIA_CycleChain, TRUE );
      set( «WSI».BUT_Cancel, MUIA_CycleChain, TRUE );

//      set( MG.WIN_«WSI», MUIA_Window_DefaultObject, «WSI».****OBJECT**** );

      // add window to Application object
      DoMethod( MG.App, OM_ADDMEMBER, MG.WIN_«WSI» );

      return( TRUE );
   }
}      

BOOL fnInit«WSN»( void )
{
//   set( MG.WIN_«WSI», MUIA_Window_ActiveObject, «WSI». );
   set( MG.WIN_«WSI», MUIA_Window_Open, TRUE );

   return( TRUE );
}

void fnClear«WSN»( void )
{
}

BOOL fnDestruct«WSN»( BOOL fOKorCANCEL )
{
   switch( fOKorCANCEL )
   {
      case TRUE:     // OK
// verify data here
         set( MG.WIN_«WSI», MUIA_Window_Open, FALSE );
         break;
      case FALSE:    // CANCEL
         set( MG.WIN_«WSI», MUIA_Window_Open, FALSE );
         break;
   }

   return( fOKorCANCEL );
}
«ENDEACH»
«ENDFILE»
