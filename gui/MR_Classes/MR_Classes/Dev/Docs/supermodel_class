@database "supermodel_class"
@master "Ram_Disk:supermodel_class.doc"

@Node Main "supermodel_class.doc"
    @{" --datasheet--() " Link "--datasheet--()"}
    @{" --datasheet-GlueFunc--() " Link "--datasheet-GlueFunc--()"}
    @{" --datasheet-supericclass--() " Link "--datasheet-supericclass--()"}
    @{" --History--() " Link "--History--()"}
    @{" ProcessTagList() " Link "ProcessTagList()"}
    @{" SM_IsMemberOf() " Link "SM_IsMemberOf()"}
    @{" SM_NewSuperIC() " Link "SM_NewSuperIC()"}
    @{" SM_NewSuperModel() " Link "SM_NewSuperModel()"}
    @{" SM_SendGlueAttrs() " Link "SM_SendGlueAttrs()"}
    @{" SM_SICMAP " Link "SM_SICMAP"}
    @{" SMTAG_AddTag() " Link "SMTAG_AddTag()"}
    @{" SMTAG_AddTags() " Link "SMTAG_AddTags()"}
    @{" SMTAG_AllocTags() " Link "SMTAG_AllocTags()"}
    @{" SMTAG_ClearNumTags() " Link "SMTAG_ClearNumTags()"}
    @{" SMTAG_ClearTags() " Link "SMTAG_ClearTags()"}
    @{" SMTAG_FreeTags() " Link "SMTAG_FreeTags()"}
    @{" SMTAG_RemTag() " Link "SMTAG_RemTag()"}
    @{" SMTAG_TagDone() " Link "SMTAG_TagDone()"}
    @{" SMTAG_TagMore() " Link "SMTAG_TagMore()"}
@EndNode

@Node "--datasheet--()" "supermodel.class/--datasheet--"

@{b}   NAME@{ub}
       supermodel.class -- Model and IC class

@{b}   SUPERCLASS@{ub}
       modelclass

@{b}   DESCRIPTION@{ub}
       

@{b}   METHODS@{ub}
       

@{b}   ATTRIBUTES@{ub}
       SMA_AddMember - calls OM_ADDMEMBER

       SMA_RemMember - calls OM_REMMEMBER

       SMA_GlueFunc - Glue code, does tag mapping/conversion, etc.  
           See example.
           see --datasheet-GlueFunc--

       SMA_GlueFuncA6 - If your glue code is in a library, set this to
           your Library base.

       SMA_GlueFuncUserData - 

       SMA_CacheStringTag - cache string data

       icclass Tags supported also

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
       Doesn't fail if SMA_AddMember is NULL during OM_NEW.
       It will in the future.

@{b}   SEE ALSO@{ub}

@EndNode

@Node "--datasheet-GlueFunc--()" "supermodel.class/--datasheet-GlueFunc--upermodel.class/--datasheet-GlueFunc--"

@{b}   NAME@{ub}
       GlueFunc

@{b}   SYNOPSIS@{ub}
       rv GlueFunc(GlueData, TagList, [userdata], [a6])
       d0          a0        a1       a2          a6
       
       ULONG GlueFunc(struct smGlueData *, struct TagItem *, APTR, APTR);

@{b}   FUNCTION@{ub}
       GlueFunc is a function you provide to modify a tag list before
       being sent to the members and ICA_TARGET of the modelclass.

       You may modify TagList and use the SMTAG_functions to modify 
       TagList, however, don't free TagList.
       
       Call SM_SendGlueAttrsA() to send your new attributes back to the
       model class for notifiaction.

@{b}   NOTES@{ub}
       There is room for 50 tags in TagList

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "--datasheet-supericclass--()" "supermodel.class/--datasheet-supericclass--l.class/--datasheet-supericclass--"

@{b}   NAME@{ub}
       supermodel.class -- IC class

@{b}   SUPERCLASS@{ub}
       icclass

@{b}   DESCRIPTION@{ub}
       An interconnect object, creates a data path between a supermodel
       object and other objects (usually gadgets)

@{b}   METHODS@{ub}

@{b}   ATTRIBUTES@{ub}
         SICA_Model - set by model class when addmembered.

         ICA_TARGET - target object

         You may set either ICA_MAP or SICA_TargetMap or 
           (SICA_ToTargetMap and SICA_FromTargetMap)

         ICA_MAP - map tags
           The supplied taglist is cloned and applied to the ic object.
           Another taglist is built by reversing the tags and applied to 
             the targeted object.

         SICA_TargetMap -
           The supplied taglist is cloned and applied to the targeted object.
           Another taglist is built by reversing the tags and applied to 
             the ic object.

         SICA_ToTargetMap - Applied to tags sent from the
                            ic object to the targeted object.

         SICA_FromTargetMap - Applied to tags sent from the
                   targeted object to, likely, the modelobject


@{b}   NOTES@{ub}
       if ICA_TARGET is valid,
       the ic object will set the Target's ICA_TARGET and ICA_MAP.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "--History--()" "supermodel.class/--History--"

@{b}   To Do@{ub}

   44.1 -
       * GlueCode was freeing memory twice.
       * Added SMA_CacheStringTag - Anytime this tag is passed through
         the model class, the string supplied is cached, and ti_Data
         is updated to point to the cache.
   44.2 - 
       * Included version string
   44.3 -
       * Now failes during OM_NEW if any SMA_AddMember is null.
       * Documentation update.
       * ICA_MAP support in superic was changed

@EndNode

@Node "ProcessTagList()" "supermodel.class/ProcessTagList"

@{b}   NAME@{ub}
       ProcessTagList -- Macro to process a taglist

@{b}   SYNOPSIS@{ub}
       ProcessTagList(TagList, Tag, TState)

       TState=TagList; 
       while(Tag=NextTagItem(&TState))

@{b}   EXAMPLE@{ub}
       void SomeFunc(struct TagItem *TagList)
       {
         struct TagItem *tag, *tstate;

         ProcessTagList(TagList,tag,tstate)
         {
           seitch(tag->ti_Tag)
           {
             case GA_Left:
               ...
               break;
             etc...
           }
         }
       }

@EndNode

@Node "SM_IsMemberOf()" "supermodel.class/SM_IsMemberOf"

@{b}   NAME@{ub}
       SM_IsMemberOf -- Check if Object belongs to a Class

@{b}   SYNOPSIS@{ub}
       memberof = SM_IsMemberOf(Object, ClassPtr, ClassID)

       BOOL SM_IsMemberOf(Object *, Class *, STRPTR);

@{b}   FUNCTION@{ub}
       Determines if the Object is a member of the Class
       specified.

@{b}   INPUTS@{ub}
       Object   - Object to check.
       ClassPtr - (Class) May be NULL.
       ClassID  - (STRPTR) May be NULL. 

@{b}   RESULT@{ub}
       BOOL, non-zero on succes.

@{b}   NOTES@{ub}
       Stolen from someone on the BOOPSI mailing list...
          
       Here's some IsMemberOf() code I whipped up quickly.  Might be nice if 
we all
       posted useful little BOOPSI snippets like this... maybe even collected
 them
       together on a web site.  (I volunteer NOT to maintain this site :)

@EndNode

@Node "SM_NewSuperIC()" "supermodel.class/SM_NewSuperIC"

@{b}   NAME@{ub}
       SM_NewSuperIC -- @{"Allocate" Link "exec/Allocate()"} SuperIC object

@{b}   SYNOPSIS@{ub}
       icobject=SM_NewSuperICA(TagList)
       a0                      a0

       Object *SM_NewSuperICA(struct TagItem *);

       icobject=SM_NewSuperIC(Tags, ...)
       a0                     a0

       Object *SM_NewSuperIC(Tag, ...);

@{b}   FUNCTION@{ub}
       Allocates an SuperIC class object

@{b}   INPUTS@{ub}
       TagList - see --datasheet-supericclass--

@{b}   RESULT@{ub}
       Pointer to an ic object on success, if ICA_TARGET is valid,
       the ic object will set the Target's ICA_TARGET and ICA_MAP.

@EndNode

@Node "SM_NewSuperModel()" "supermodel.class/SM_NewSuperModel"

@{b}   NAME@{ub}
       SM_NewSuperModel -- @{"Allocate" Link "exec/Allocate()"} SuperModel object

@{b}   SYNOPSIS@{ub}
       model = SM_NewSuperModel( Tag1, Data1, TAg2, ...)

       Object *SM_NewSuperModel(Tag Tags, ...);

@{b}   FUNCTION@{ub}
       @{"Allocate" Link "exec/Allocate()"} model object.

@{b}   INPUTS@{ub}
       Tags

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}
       @{"DisposeObject()" Link "intuition/DisposeObject()"} returned model when done.

       Before targeted objects (ie gadgets) are freed you must either:
       1. Dispose() the SuperModel object, which also Dispose()s all
           SuperIC objects.
       2. SetAttr() ICA_TARGET to NULL on every SuperIC object.
       SuperIC objects need to clear the ICA_MAP and ICA_TARGET settings 
       of it's targetted object.  If the target object nolonger exists,
       expect bad things to happen.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "SM_SendGlueAttrs()" "supermodel.class/SM_SendGlueAttrs"

@{b}   NAME@{ub}
       SM_SendGlueAttrs -- Send attributes from GlueFunc (SMA_GlueFunc)

@{b}   SYNOPSIS@{ub}
       unknown = SM_SendGlueAttrs(GlueData, TagList)
       d0                         a0        a1

       ULONG SM_SendGlueAttrs(struct smGlueData *, struct TagItem *);

@{b}   FUNCTION@{ub}
       This function sends TagList back to the modelclass for notification
       of other objects.

       ONLY to be called from inside a GlueFunction.

@{b}   INPUTS@{ub}
       GlueData - 
       TagList -

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "SM_SICMAP" "supermodel.class/SM_SICMAP"

@{b}   NAME@{ub}
       SM_SICMAP -- Builds and super ic class object

@{b}   SYNOPSIS@{ub}
       icobject SM_SICMAPA(Target, MapTags)
       a0                  a0      a1

       Object *SM_SICMAPA(Object *, struct TagItem *);

       icobject=SM_SICMAP(Target, @{"MapTags" Link "utility/MapTags()"}, ...)
       a0                 a0      a1

       Object *SM_SICMAP(Object *, Tag, ...);

@{b}   FUNCTION@{ub}
       Simplfied way to create and SuperIC object.
       Target is targeted object of the ic object.
       @{"MapTags" Link "utility/MapTags()"}, target map tags.

@{b}   INPUTS@{ub}

@{b}   RESULT@{ub}

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "SMTAG_AddTag()" "supermodel.class/SMTAG_AddTag"

@{b}   NAME@{ub}
       SMTAG_AddTag -- Add a tag toa taglist.

@{b}   SYNOPSIS@{ub}
       ok = SMTAG_AddTag(TagList, Tag, Data)

       BOOL SMTAG_AddTag(struct TagItem *, ULONG, ULONG);

@{b}   FUNCTION@{ub}
       Add a tag pair to a taglist created with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}
       Tag - ti_Tag value
       Data - ti_Data value

@{b}   RESULT@{ub}
       non zero if the tag was added.
       failure can be due to under sized taglist.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   NOTES@{ub}
       Don't SMTAG_AddTag TAG_IGNORE, TAG_DONE, TAG_MORE, TAG_SKIP.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.
       This function overwrites existing same tags.

@{b}   SEE ALSO@{ub}
       @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_AddTags()" "supermodel.class/SMTAG_AddTags"

@{b}   NAME@{ub}
       SMTAG_AddTags -- Add a taglist to a taglist.

@{b}   SYNOPSIS@{ub}
       ok = SMTAG_AddTags(TagList, Tag, Data)

       BOOL SMTAG_AddTags(struct TagItem *, ULONG, ULONG);

@{b}   FUNCTION@{ub}
       Add a taglist to a taglist created with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}
       NewTags - Tags to add to TagList

@{b}   RESULT@{ub}
       non zero if the tag was added.
       failure can be due to under sized taglist.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   NOTES@{ub}
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.
       This function overwrites existing same tags.

@{b}   SEE ALSO@{ub}
       @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_AllocTags()" "supermodel.class/SMTAG_AllocTags"

@{b}   NAME@{ub}
       SMTAG_AllocTags -- @{"Allocate" Link "exec/Allocate()"} blank Tag List

@{b}   SYNOPSIS@{ub}
       taglist = SMTAG_AllocTags(TagCount)

       struct TagItem *SMTAG_AllocTags(ULONG);

@{b}   FUNCTION@{ub}
       @{"Allocate" Link "exec/Allocate()"} tag space for use with other SMTAG_? functions.

@{b}   INPUTS@{ub}
       TagCount - Number of blank tags to allocate.

@{b}   RESULT@{ub}
       An empty tag space ending with TAG_DONE, or NULL.

@{b}   EXAMPLE@{ub}

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}

@EndNode

@Node "SMTAG_ClearNumTags()" "supermodel.class/SMTAG_ClearNumTags"

@{b}   NAME@{ub}
       SMTAG_ClearTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void SMTAG_ClearTags(TagList, TagCount)

       SMTAG_ClearTags(struct TagItem *, ULONG);

@{b}   FUNCTION@{ub}
       Clears the TagList of all data.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}
       TagCount - Number of blank tags to allocate.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   NOTES@{ub}
       This function is called by @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}, so
       the taglist is cleared when allocated.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_ClearTags()" "supermodel.class/SMTAG_ClearTags"

@{b}   NAME@{ub}
       SMTAG_ClearTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void SMTAG_ClearTags(TagList)

       SMTAG_ClearTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Clears the TagList of all data.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   NOTES@{ub}
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   BUGS@{ub}

@{b}   SEE ALSO@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_FreeTags()" "supermodel.class/SMTAG_FreeTags"

@{b}   NAME@{ub}
       SMTAG_FreeTags -- Clear a TagList

@{b}   SYNOPSIS@{ub}
       void SMTAG_FreeTags(TagList)

       SMTAG_FreeTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Frees the TagList.

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_RemTag()" "supermodel.class/SMTAG_RemTag"

@{b}   NAME@{ub}
       SMTAG_RemTag -- Removea a tag to a taglist.

@{b}   SYNOPSIS@{ub}
       ok = SMTAG_RemTag(TagList, Tag)

       BOOL SMTAG_RemTag(struct TagItem *, ULONG);

@{b}   FUNCTION@{ub}
       Find and remove a tag from a taglist.

@{b}   INPUTS@{ub}
       TagList - TagList created with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}
       Tag - ti_Tag value

@{b}   RESULT@{ub}
       non zero if the tag was found and removed.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   NOTES@{ub}
       Don't SMTAG_AddTag TAG_IGNORE, TAG_DONE, TAG_MORE, TAG_SKIP.
       This function will only effect the specified TagList, and 
       not any other lists referenced by TAG_MORE.

@{b}   SEE ALSO@{ub}
       @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_TagDone()" "supermodel.class/SMTAG_TagDone"

@{b}   NAME@{ub}
       SMTAG_TagDone -- End the TagList with TagDone

@{b}   SYNOPSIS@{ub}
       void SMTAG_FreeTags(TagList)

       SMTAG_FreeTags(struct TagItem *);

@{b}   FUNCTION@{ub}
       Ends the taglist with TAG_MORE and link the list to MoreTags

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}.

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

@Node "SMTAG_TagMore()" "supermodel.class/SMTAG_TagMore"

@{b}   NAME@{ub}
       SMTAG_TagMore -- End the TagList with TagMore

@{b}   SYNOPSIS@{ub}
       void SMTAG_FreeTags(TagList, MoreTags)

       SMTAG_FreeTags(struct TagItem *, struct TagItem *);

@{b}   FUNCTION@{ub}
       Ends the taglist with TAG_MORE and link the list to MoreTags

@{b}   INPUTS@{ub}
       TagList - Allocated with @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}.
       MoreTags - Tags to link

@{b}   EXAMPLE@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@{b}   SEE ALSO@{ub}
       see @{"SMTAG_AllocTags()" Link "SMTAG_AllocTags()"}

@EndNode

