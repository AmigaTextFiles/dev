@database "pagegadget.guide"
@author "Jens Tröger"
@(c) "1996 by Jens Tröger"
@font topaz.font 8

@node "main" "Something I want to say   ;)"


        This world is crying to be free
        This world is dying can`t you see
        We need a turn to do it right
        We need a mind-revolution
        To get away from this selfishness
        Stop playing blind - break free



                                 © 1991 by Helloween,
                                 taken from the genious song "Your turn"








        @{"Go on" link "start" 0}

@endnode

@node "start" "And go...."


                     @{b}@{u}BOOPSI custom Class "page.gadget"@{ub}@{uu}

           (c) 1996 by Jens Tröger. All rights reserved.


Since this is a beta version, the doc may not be complete. So if there
are any questions, bugs or any other please write @{"me" link "me" 0}

Usage of the whole package is YOUR OWN RISK. The author takes NO warranty
for anything happens.



  @{"Introduction" link "intro" 0}
  @{"Installation" link "install" 0}
  @{"How to use" link "usage" 0}
  @{"Tags, flags, structs" link "include" 0}

  @{"Author" link "me" 0}

  @{"History" link "history" 0}

@endnode

@node "intro" "Introduction"

@{b}page.gadget@{ub} is a custom class of Amigas BOOPSI concept. You may
know the pages offered by MUI or bgui.library. Well, if you need such
pages it was a little difficult to create some if you do not want to use
MUI or another library. Thus I wrote the page.gadget. It has a loz of
useful (really great !!!) features like:

   - "unlimited" page numbers
   - link ITexts, Gadgets, BevelBoxes (a flexible, custom structure),
     Images with a page and the page.gadget does the layout
   - dynamic add/remove pages

   etc...

@endnode

@node "install" "Installation"

  Simply copy the file "page.gadget" to your libs:gadgets drawer

@endnode

@node "usage" "How to use"

First of all: YOU as the programmer have to care for font-sensitivity;
the page.gadget uses the data YOU give it. And page.gadget @{b}MUST@{ub} be the
last gadget of your window (it will link the gadgets given to the pages
itself)

Since page.gadget is a exec-shared-library simply call:

    @{i}
    struct Library *myPageBase = OpenLibrary("gadgets/page.gadget", 0L);
    @{ui}

Well, page.gadget is a really useful thing. So if you need one or more
of the libraries "intuition.library", "graphics.library", "utility.library",
"dos.library", "gadtools.library" or "exec.library" you can do this:

    @{i}
    struct Library *IntuitionBase,
                   *DOSBase;

    struct PageBase *myPageBase = (struct PageBase *)
                                  OpenLibrary("gadgets/page.gadget", 0L);

    if (myPageBase)
      {
        IntuitionBase = myPageBase -> page_IntuitionBase;
        DOSBase = myPageBase -> page_DOSBase;

        ....



        CloseLibrary(myPageBase);
      }
     @{ui}

You see, the page.gadget opens some libs. So if the page.gadget is open
be shure these libraries are too. Do not forget to close the library at
the end!!

Lez go on... Of course you need a pointer to the Class structure to create
a page gadget, so here it is:

    @{i}
    APTR myPageClass = PAGE_GetClass();
    @{ui}

If the page.gadget is open, you dont have to care for the result of
PAGE_GetClass - it is valid.

Now you can start to create your gadgets...   page.gadget understands loz
of @{"tags, flags and structures" link "include" 0}. Refer to the C-Include file and the
demo-source. But note: your page gadget must be the last of your list and
it will link the "private" gadgets (which you link to the page-structure)
itself.
Create a gadget like this:

    @{i}
    struct Gadget *myPageGadget;

    myPageGadget = NewObject( myPageClass,
                              NULL,

                              /* page.gadget understands all the
                                 gadgetclass tags */

                              GA_Left, 20,
                              GA_Top, 30,
                              GA_Width, 400,
                              GA_Height, 15,
                              GA_GadgetID, 3,

                              /* private tags */

                              PAGE_Pages, &firstPage,
                              PAGE_Layout, PGLYT_MUISTYLE,
                              PAGE_Underscore, 95,

                              TAG_DONE);

    if (myPageGadget)
      {
        ...

        /* IMPORTANT NOTE:
           your page gadget MUST be the last gadget of your
           gadget list !!!! */

        AddGadget(window, myPageGadget, -1);
        RefreshGList(myPageGadget, window, NULL, 1);


        ...


        DisposeObject(myPageGadget);
      }
    @{ui}

If the gadget was created this way you can handle it the way you do with
any other gadget. Click for the tags, flags and structures. Never forget
to dispose the object before closing the page.gadget.

@{b}NOTE@{ub}
You MUST specify the PAGE_Pages tag; otherwise the gadget creation will
fail.

If you are done with all the initialisation you can link the page gadget
(and the others of course) using AddGList() and after this call
RefreshGList() to let the gadgets become visible. As already said you,
as an user of the page.gadget, you dont have to care for the layout.
This means: link gadgets, itext etc to you page gadget and simply add
the page gadget - then the page gadget draws the itext, bboxes, adds
the gadgets etc. It will do this in the following order:

  BevelBoxes
  ITexts
  Images
  Gadgets

Now the page.gadget renders itelsf.

@{b}IMPORTANT@{ub}
If you link gadtools gadgets to the pages, you MUST call GT_RefreshWindow()
by your own, the page.gadget does this NOT for you.

If the page.gadget receives a click, it will look at the click-coordinates
and then it deceides whether it will change (if the click was at an
inactive page) or not (click at the active page). If it finds out the
click was at a new page, it will clear the page area (set with the
PAGE_ClearRect tag), then render all bevels, itexts etc, then re-renders
it itself and send a IDCMP_GADGETUP to the users-window.

The user receives an IDCMP_GADGETUP which means the gadget changed the
pages. Now the user asks the gadget for the the page.

    @{i}
    struct IntuiMessage *myIMsg;

    ...

    WaitPort(myWindow -> UserPort);
    myIMsg = GetMsg(myWindow -> UserPort);

    if (myIMsg -> Class == IDCMP_GADGETUP)
      {
        switch (((struct Gadget *) (myIMsg -> IAddress)) -> GadgetID)
          {
            case PAGE_GADGET_ID:
              {
                ULONG activePage = 0;
                GetAttr(PAGE_Active, myPageGadget, &activePage);

                printf("active: %ld\n", activePage);
              }

            case OTHER_GADGET_ID:
              {
                ...
              }
          }
      }

    ReplyMsg(myIMsg);
    @{ui}

Of course you can set attributes of your gadgets using intuitions
SetGadgetAttrs() or SetGadgetAttrsA():

    @{i}
    SetGadgetAttrs(myPageGadget, PAGE_Active, newActive, TAG_DONE);

    ...

    SetGadgetAttrs(myPageGadget, GA_Width, newWidth, TAG_DONE);
    @{ui}

At last I will explain a nice feature which is for the advanced Amiga-
Programmers of you. As you may noticed the Page structure includes a field
called ThisPageHook which is a pointer to a Hook structure. This makes
you able to set up a hook (see utility/hooks.h) for every page. If you
switch to a page with a hook entry the page.gadget will execute this
hook BEFORE any other rendering. This can be used to (maybe) play
several sounds for any page.
Your hook functions will get these params from the page.gadget:

    @{i}
    void myHookFunction(struct Hook *hook,
                        struct Gadget *pageGad,
                        struct PageHookObject *pho)
    @{ui}

As you see, hook points to your hook structure, pageGad points to the
page gadget which calls the hook and pho is a pointer to a structure
called PageHookObject. Link to @{"Tags, Flags and Structures" link "include" 0} to see the
entries. Use these entries in your hook function and you can do
anything ;)
Now a little example of how to make such a hook (see the demo source):

    @{i}
    /* flash all screens */
    void myHookFunction(struct Hook *hook,
                        struct Gadget *pageGad,
                        struct PageHookObject *pho)
      {
        DisplayBeep(NULL);
      }

    void main(void)
      {
        struct Hook hook = { NULL, NULL, NULL, NULL, NULL };
        extern ULONG HookEntry();

        /* init the hook */
        hook.h_Entry = HookEntry;
        hook.h_SubEntry = (APTR) myHookFunction;
        hook.h_Data = NULL;

        /* lets think we already have a valid page structure and
           myPage points to it... */
        myPage -> ThisPageHook = &hook;


        ....

      }
    @{ui}

Thats about these genious hook.

Well, thats all at first...  have fun with the gadget.
@endnode

@node "include" "The Tags, Flags and Structures"

This is the definition of the structure returned by the OpenLibrary()
call:

    @{i}
    struct PageBase
      {
        struct Library  page_LibNode;
        UBYTE           page_Flags;
        UBYTE           page_PadByte;
        APTR            page_SegList;
        struct Library  *page_SysBase;
        struct Library  *page_DOSBase;
        struct Library  *page_IntuitionBase;
        struct Library  *page_GfxBase;
        struct Library  *page_GadtoolsBase;
        struct Library  *page_UtilityBase;
        struct Library  *page_DiskfontBase;

        /* PRIVATE... lots of data will follow: hands off */

      };
    @{ui}

The tags you may pass to NewObject() -CREATE- or SetGadgetAttrsA() -SET-
or GetAttrsA() -GET- .

    @{i}
    #define PAGE_Pages        (TAG_USER + 0)

            /* CREATE
               ti_Data holds pointer to the first Page-structure
               see below */

    #define PAGE_Layout       (TAG_USER + 1)

            /* CREATE
               defines the look of the pages (see PGLYT flags) */

    #define PAGE_Underscore   (TAG_USER + 2)

            /* CREATE
               same as the GT_Underscore */

    #define PAGE_Active       (TAG_USER + 3)

            /* CREATE SET GET
               the active page (starts with 0 !!) */

    #define PAGE_TextFont     (TAG_USER + 4)

            /* CREATE
               ptr to TextFont of the page-gadget */

    #define PAGE_TextAttr     (TAG_USER + 5)

            /* CREATE
               ptr to TextAttr of the page-gadget */

    #define PAGE_ActiveStyle  (TAG_USER + 6)

            /* CREATE
               defines the look of the selected page (see PGAST flags) */

    #define PAGE_ClearRect    (TAG_USER + 7)
            /* CREATE
               ptr to Rectange... defines the to-be-cleared-rect */
    @{ui}

Now you find a structure called "BevelBox". This struct is used to
draw bevel boxes. Link the first struct of a linked list to your page
and the page.gadget does the layout for you.

    @{i}
    struct BevelBox
      {
        struct  BevelBox *NextBBox;    /* ptr to next BevelBox or NULL */
        UWORD   Left;                  /* ... */
        UWORD   Top;
        UWORD   Width;
        UWORD   Height;
        ULONG   Flags;                 /* see BBFLG below */
        UWORD   PtrnAPen;              /* pattern/background colors (see below) */
        UWORD   PtrnBPen;
        UWORD   BoxShine;              /* colors of the box */
        UWORD   BoxShadow;
      };
    @{ui}

These flags are known by the page.gadget. You can specify the look of any
BevelBox using this tags. So you can fill a BevelBox with a color or a
pattern. And you have several border styles...  try it out

    @{i}
    #define BBFLG_BACKFILL          (1L<<0)

            /* fill bevel-box with PtrnAPen color */

    #define BBFLG_PATTERNFILL       (1L<<1)

            /* if BBFLG_BACKFILL then draw pattern and use
               the PtrnAPen and PtrnBPen */

    #define BBFLG_RECESSED          (1L<<2)

            /* recessed-look of bevel-box */

    #define BBFLG_FRAMENONE         (1L<<3)

            /* bevel-box without any borders */

    #define BBFLG_FRAMEBUTTON       (1L<<4)

            /* simple button-look */

    #define BBFLG_FRAMERIDGE        (1L<<5)

            /* looks like a string-gadget */
    @{ui}

This is the most important structure: build a linked list of these will
define the complete page gadget.
Not testet but should work: add/remove page-structs and call RefreshGList()
and you should be able to dynamic add/remove pages to/from the gadget.

    @{i}
    struct Page
      {
        struct   Page *NextPage;        /* pointer to next or NULL */
        UBYTE    *Name;                 /* ptr to the name */
        ULONG    NameStyle;             /* same as TextAttr ta_Style */
        struct   Gadget *FirstGadget;   /* first gadget of this page or NULL */
        struct   IntuiText *FirstIText; /* first intui-text of this page or NULL */
        struct   BevelBox *FirstBBox;   /* first bevel-box of this page or NULL */
        struct   Image *FirstImage;     /* first image or NULL */
        struct   Hook *thisPageHook;    /* NOT IMPLEMENTED YET */
      };
    @{ui}

Flags known by the page.gadget:

    @{i}
    #define PGLYT_SIMPLE     0      /* PAGE_Layout */
    #define PGLYT_MUISTYLE   1
    #define PGLYT_GADTOOLS   2      /* NOT IMPLEMENTED YET
                                       suggestions for the layout ??? */

    #define PGAST_NORMAL     0      /* PAGE_ActiveStyle */
    #define PGAST_HILIGHT    1
    #define PGAST_SHADOW     2
    @{ui}

The following structure will be passed as a third argument to you
hook function:

    @{i}
    struct PageHookObject
      {
        struct GadgetInfo *pho_GInfo;     /* ptr to the GadgetInfo of you gadget */
        struct Page *pho_ActivePage;      /* ptr to the Page struct of the NOW active page */
      };
    @{ui}

I hope this is enough for you so you can now create your own pages.
For suggestions, bugs and questions click @{"here" link "me" 0}

@endnode

@node "me" "Author"

Bugs, suggestions etc send to the following address:

    e-mail:   jt18@irz.inf.tu-dresden.de
              troeger@rmhs2.urz.tu-dresden.de

    snail:    Jens Tröger
              Hochschulstr. 48, 11-4
              01069 Dresden
              GERMANY

Greez fly to the following:

    Knuddel
    Falk (goil, ne?)
    Matthias (Oooooomph)
    Jochen (JochenW) and Kai (ZZA)...   (thanx a lot)
    Marcus, JVIR, DOSen Looooser and all I forgot
    J. Haage for good support (maybe...)

If you application uses the page.gadget I want to please you to use
the PAGE_GetCopyright() call to get a pointer to the copyright string.
Run the demo to see the look of this string. Thanx a lot.

@endnode

@node "history" "The History"

  v1.0    (20.09.96)  First beta release in Aminet

  v1.0    (23.09.96)  Second beta release in Aminet; PAGE_Underscore
                      and Hooks implemented. Now SetGadgetAttrs() worx.

@endnode

