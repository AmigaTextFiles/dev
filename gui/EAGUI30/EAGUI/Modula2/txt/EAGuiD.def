(* REVISION HEADER ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× *
   
 | $VER: EAGuiD.def 3.00 (23.11.94) by Stefan Schulz [sts]
 
 | Desc: Interface to EAGUI.library
 
 | Dist: This Module is © Copyright 1994 by Stefan Schulz
 
 | Rqrs: Amiga OS 2.0 or higher
 |       EAGUI.library V3
 |       EAGUI - Environment Adaptive Graphic User Interface
 |       Copyright © 1993, 1994 by Marcel Offermans and Frank Groen
 
 | Lang: M2Amiga
 | Trns: M2Amiga Modula 2 Software Development System
 |       © Copyright by A+L AG, CH-2540 Grenchen
 
 | Hist: Version \date\
 |
 |       3.00   \23.11.94\
 |              interface adapted to EAGUI.library V3
 |              names changed to M2-Standard
 |
 |       1.00   \01.05.94\
 |              initial Version
 
 * ×××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××××× *)

DEFINITION MODULE EAGuiD; (*$ Implementation:= FALSE *)

(* IMPORTS ********************************************************************** *)

IMPORT  ed      : ExecD,
        gd      : GraphicsD,
        S       : SYSTEM,
        ud      : UtilityD;

(* ****************************************************************************** *)

(* ------------------------------------------------------------------------------ *)
(* library name and version                                                       *)
(* ------------------------------------------------------------------------------ *)

CONST   eaguiName               = "EAGUI.library";
        eaguiVersion            = 3;

(* ------------------------------------------------------------------------------ *)
(* Object.type definitions                                                        *)
(* ------------------------------------------------------------------------------ *)

CONST   typeHGroup            = 1;
        typeVGroup            = 2;
        typeGTGadget          = 3;
        typeBoopsiGadget      = 4;
        typeCustomImage       = 5;
        typeBoopsiImage       = 6;

(* ------------------------------------------------------------------------------ *)
(* various LONG attributes can have an unknown value at some point                *)
(* ------------------------------------------------------------------------------ *)

CONST   unknown               = -1;

(* ------------------------------------------------------------------------------ *)
(* error return codes                                                             *)
(* ------------------------------------------------------------------------------ *)

CONST   errorOK               = 0;
        errorOutOfMemory      = 100;
        errorBadObject        = 101;

(* ------------------------------------------------------------------------------ *)
(* flags for standard methods                                                     *)
(* ------------------------------------------------------------------------------ *)

CONST   smNone                = 00000000H;
        smMinSize             = 00000001H;
        smBorder              = 00000002H;

(* ------------------------------------------------------------------------------ *)
(* tags                                                                           *)
(* ------------------------------------------------------------------------------ *)

CONST   tagBase               = ud.tagUser;


(* ------------------------------------------------------------------------------ *
 * These tags can be used under different circumstances. The characters in the    *
 * comments behind the tags indicate the allowed use:                             *
 *                                                                                *
 * I = Initialize: NewObjectA()                                                   *
 * S = Set:        SetAttrsA()                                                    *
 * G = Get:        GetAttrsA()                                                    *
 *                                                                                *
 * Most functions ignore tags they don't recognize, but don't count on that,      *
 * or side effects may occur in future versions.                                  *
 * ------------------------------------------------------------------------------ *)

CONST   (* EaTags *)
        dummy           = tagBase;
        parent          = tagBase + 1;       (* I.G *)
        type            = tagBase + 2;       (* ..G *)
        disabled        = tagBase + 3;       (* ISG *)
        id              = tagBase + 4;       (* ISG *)
        minWidth        = tagBase + 5;       (* ISG *)
        minHeight       = tagBase + 6;       (* ISG *)
        borderLeft      = tagBase + 7;       (* ISG *)
        borderRight     = tagBase + 8;       (* ISG *)
        borderTop       = tagBase + 9;       (* ISG *)
        borderBottom    = tagBase + 10;      (* ISG *)
        left            = tagBase + 11;      (* .SG *)
        top             = tagBase + 12;      (* .SG *)
        width           = tagBase + 13;      (* ISG *)
        height          = tagBase + 14;      (* ISG *)
        weight          = tagBase + 15;      (* ISG *)
        instance        = tagBase + 17;      (* ..G *)
        instanceAddress = tagBase + 18;      (* ISG *)

        minSizeMethod   = tagBase + 19;      (* ISG *)
        borderMethod    = tagBase + 20;      (* ISG *)
        renderMethod    = tagBase + 21;      (* ISG *)
        getStateMethod  = tagBase + 22;      (* ISG *)
        setStateMethod  = tagBase + 23;      (* ISG *)

        object          = tagBase + 24;      (* I.. *)

        gtType          = tagBase + 25;      (* ISG *)
        gtTagList       = tagBase + 26;      (* ISG *)
        gtText          = tagBase + 27;      (* ISG *)
        gtTextAttr      = tagBase + 28;      (* ISG *)
        gtFlags         = tagBase + 29;      (* ISG *)

        boopsiPrivClass = tagBase+ 30;      (* ISG *)
        boopsiPubClass  = tagBase + 31;      (* ISG *)
        boopsiTagList   = tagBase + 32;      (* ISG *)

        child           = tagBase + 33;      (* I.. *)

        firstChild      = tagBase + 34;      (* ..G *)
        nextObject      = tagBase + 35;      (* ..G *)

        standardMethod  = tagBase + 36;      (* IS. *)
        userData        = tagBase + 37;      (* ISG *)

        defDisabled        = tagBase + 38;    (* .SG *)
        defWeight          = tagBase + 39;    (* .SG *)
        defMinSizeMethod   = tagBase + 40;    (* .SG *)
        defBorderMethod    = tagBase + 41;    (* .SG *)
        defRenderMethod    = tagBase + 42;    (* .SG *)
        defGetStateMethod  = tagBase + 43;    (* .SG *)
        defSetStateMethod  = tagBase + 44;    (* .SG *)
        defGTType          = tagBase + 45;    (* .SG *)
        defGTTagList       = tagBase + 46;    (* .SG *)
        defGTText          = tagBase + 47;    (* .SG *)
        defGTTextAttr      = tagBase + 48;    (* .SG *)
        defGTFlags         = tagBase + 49;    (* .SG *)
        defBoopsiPrivClass = tagBase + 50;    (* .SG *)
        defBoopsiPubClass  = tagBase + 51;    (* .SG *)
        defBoopsiTagList   = tagBase + 52;    (* .SG *)
        defStandardMethod  = tagBase + 53;    (* .SG *)
        defBorderLeft      = tagBase + 54;    (* .SG *)
        defBorderRight     = tagBase + 55;    (* .SG *)
        defBorderTop       = tagBase + 56;    (* .SG *)
        defBorderBottom    = tagBase + 57;    (* .SG *)

(* ------------------------------------------------------------------------------ *
 * Pointer to an object, which is used as a `handle' by a lot of functions.       *
 * The actual data structure of the object is hidden from the application         *
 * programmer.                                                                    *
 * ------------------------------------------------------------------------------ *)

TYPE    OPTR               = S.ADDRESS;

TYPE    StrPtr             = S.ADDRESS; (* for readability *)

(* ------------------------------------------------------------------------------ *)
(* This structure is READ-ONLY!                                                   *)
(* ------------------------------------------------------------------------------ *)

TYPE    RelationObjectPtr  = POINTER TO RelationObject;
        RelationObject     = RECORD

                             (* private *)
                             node          : ed.Node;

                             (* attributes *)
                             objectPtr     : OPTR;

                             END; (* RelationObject *)


(* ------------------------------------------------------------------------------ *
 * Message structure as used by the Render hook. A pointer to this structure is   *
 * passed in the message parameter of the callback hook. For more information on  *
 * hooks, take a look at amiga.lib/CallHook() or utility.library/CallHookPkt().   *
 * ------------------------------------------------------------------------------ *)

TYPE    RenderMessagePtr = POINTER TO RenderMessage;
        RenderMessage    = RECORD
                           rootPtr       : OPTR;
                           rastportPtr   : gd.RastPortPtr;
                           END; (* RenderMessage *)


END EAGuiD.def

