
                   --- ReadMe for Skew v1.28 ---


Sorry, this is no AmigaGuide file. This is too humble a program for such
luxuries (while I'm too lazy...).

I wrote (the first version of) this program back in 1991 because:

    1. I wanted to learn something about the new Amiga gadgetry (and
       request'ry).

    2. Nobody else did. (Now, i.e. in 1993, the GadToolsBox can generate
       IDCMP-handling stuff, which, in all probability is much smarter
	   (though I have never tried it myself).

Current version of Skew, namely 1.28, dates from July 1993. This long life,
does not mean that I worked with this proggy very much. But it seems to be
O.K. at last, and useful to me if nobody else...

"Skew" (the name stands for "SKEleton Writer") is a tool for generating C
code for various Intuition based applications on the Amiga. You click the
mouse and the code gets written. There are already a couple of such programs
-- Jan van den Baard's "PowerSource" and "GadToolsBox" (this latter was, by
the way, intensively used by myself while writing Skew), Matt Dillon's
"TplEdit" etc. They generate code for screens, windows, gadgets, menues and
so on; being even capable of creating (with some your help) a wholly runnable
program. If so -- why would I need this stuff, you're asking?

Skew's domain is slightly different: it WON'T create any runnable program by
itself, but for a cost of twenty or fifty mouse clicks, it CAN save you
typing some hundred lines of C code. More -- in most cases you would be
typing with only one finger holding some interesting but not very handy book
like the "Amiga ROM Kernel Reference Manual" with other hand...

All the great programs I mentioned earlier WILL write you a complete code you
can compile and run; the resulting programs WILL have beautiful gadgets,
menues etc. but -- if you want to have a prrogram that really DOES something
non-trivial -- you will still have to write the code for the IDCMP handling
yourself and merge it with the (machine-generated or not) code. Much typing
is involved here if your application is more or less sophisticated.

Enter "Skew" and what it does? Well, it generates a function (named by
default) GetIDCMP() with the pertaining switch and cases for the various
Class'es in IntuiMessage; as well as some other related stuff. If one
consideres that there is 26 such classes now and they all have long, all-
uppercase names it might seem strange that nobody got the idea of any
automatization here...

When you start the program you see a screen with a couple of gadgets and a
logo. The purpose of the gadgets in the lowest row should be rather obvious.
In the string gadget you can place the name of the IDCMPWindow (which can be
a requester).

Then you have a check-button which you check if you are going to use
GadTools.library.

The other gadgets: the check-buttons with "Class", "Code", "Qualifier" etc.
written by them are the names of the fields in IntuiMessage you are
interested in. "Class" is pre-set because: firstly -- it is so often needed,
secondly -- you would not get much of this program if you do not want them.
However, even if you turn "Class" off, you will get this variable read by the
resulting code, if any of the flag values on the next 'screen' (backdrop
window actually) is set, and "Skew" sees that you will need it after all. So
wise it is -- sheer IA!! And you always will be able, of course, to return
whenever you wish to change the settings or just see them.

Then you will go to the second 'screen' with the groups of check-button
gadgets in groups of two, in addition to the big (and obvious) ones at the
bottom. One of such pair has i.e. "MOUSEBUTTONS" inscribed to its left, while
the other has "F". Now -- if you set ANY of them ON, you will get a case for
MOUSEBUTTONS in the generated switch, if you set this with "F" ON (no matter
what is the state of the other one!) -- you will get a function call in this
case. It is something like that:

    without "F":

            switch ( class ) {

                ...                     <--- previous case's (if any)

                case MOUSEBUTTONS:
                                        <--- place for your code
                    break;

                ...                     <--- more cases

    with "F":

            switch ( class ) {

                ...                     <--- previous case's (if any)

                case MOUSEBUTTONS:
                    MouseButtons();
                    break;

                ...                     <--- more cases


Now, the MouseButtons() might be called something like
HandleMouseButtons123(); and you may even get its prototype (ANSI-style), as
well as a 'skeleton' -- see below.

When (if?) you reach the third 'screen' we can set some general options like:

    1. The name for the GetIDCMP() function in case you do not like this
       name, or, for example, need stuff like GetIDCMP1(), GetIDCMP2(), ...
       GetIDCMP25(). A string gadget.

    2. Prefix and suffix for the generated 'child functions' so that, for
       instance, MouseButtons() becomes my_new_MouseButtons_turbo(). Two
       string gadgets for that.

    3. Whether you will want function prototypes. A cycle gadget.

    4. If you will want function 'skeletons' in the form more or less like:

VOID MouseButtons( VOID )
{

}

or

MouseButtons()
{

}

    5. A cycle-gadget with which you decide if you want to passively
       wait for the messages, or maybe you will need to spin and do something
       like i.e. printing a banner (or something much more ambitious) in the
       meantime. The place the code for that should be placed will be marked
       if you set the "comments" and/or "fill-ins" flag on.

    6. A cycle-gadget with which you decide if the variables should be local
       or global. It might be much easier to use globals, but you know,
       globals are 'impure' they say...

    7. Do you want verbose comments, some comments or none at all? The
       comments are really not very enlighting, and the difference between
       "verbose" and "sparse" in not great. I simply got tired of inventing
       them...

    8. Fill-ins, also a cycle-gadget. You decide whether you want the
       places where you will have to put something marked with '@@',
       '/* @@ */', '@@@@@@@@@@', or not marked at all. The idea is here that
       should be easy to find the '@@' from an editor, but you might want
       them commented-out if you are trying to compile an un-finished code.
       The '@@@@@@@@@@' shoud be easy to spot with bare eye, if you for
       instance want to see how much you will need to type yourself. Most of
       the places to fill in will be marked, but not necessarily all -- if
       you do something more with a function than only call it there WILL be
       slightly more.

    9. The test-variable ('Done' or so) can be either global or local. A
       cycle-gadget for that.

    10. The 'top-level' GetIDCMP() function can return LONG, as well as take
        pointer to the IDCMP window as parameter. Two cycle-gadgets for that.

There may still be some gadget I forgot, but id should not be hard to figure
out what it will do...

Since version 1.26, Skew can be 'iconified'; it uses a UEdit-style 'tiny
window' pseudo-icon; it can be shifted around, remembers when you left it
lately. To return from the 'iconification' you click on the tiny window below
the bar.


SOME FINAL REMARKS:

"Skew" is for 2.0 and up only. It's 'pure'. It is writted on and for PAL
monitor and such display it will try to use, but if your chips are not up to
that -- will try open on an interlaced NTSC screen.

"Skew" likes every 'arp-and-asl-to-a-much-fancier-filerequestor' program I
ever found, with the one exception: a program called 'fr_Bypass'.

"Skew" will let you type stupid names in the string gadgets and do many other
things like that; you will be able to correct all this later, in your editor.
The code generated is in extremely loose format that you might hate, but
which I like more and more...

"Skew" is Public Domain, the source is included. It compiles cleanly with
DICE 2.6 (registered version); much of the code for the screen, window &
gadgets was generated by GadToolsBox (but it was back in 1991, since then it
has been being re-written by hand).

By the way -- the source has tab-stops every 4 spaces.


                                    Piotr Obminski

                                    Flogstavägen 43C:323

                                    752 63 UPPSALA

                                        SWEDEN

                                    tel. 018 - 46 38 32
