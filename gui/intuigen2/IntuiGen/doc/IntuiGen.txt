IntuiGen.txt doc

(C) Copyright 1993 Justin Miller, P.O. Box 17, Imbler, OR  97841.
      This file may be freely distributed with IntuiGen 2.0.
      All Other Rights Reserved.
      The Author makes no warranties, express or implied, as to
	the accuracy or suitability of the material contained herein.


IntuiGen is (C) Copyright 1993 Justin Miller.  It is being offered as
Shareware.  If you make use of this program or its included libraries,
please send a check or money order for $15 payable to Justin Miller.
Note that if you want to distribute programs which make use of
the GTRequest or IGRequest libraries, you must register!
For a complete licensing agreement for IntuiGen and its accompanying source,
documentation, and example files, see COPYRIGHT.txt included in this archive.

The IntuiGen package is freely distributable, providing all the files are
included, and no unreasonably large distribution fees are charged.  For
details, see COPYRIGHT.txt.

Email comments, suggestions, and bug reports to:  jcmiller@mit.edu
If you don't have access to the internet, you can mail me at the
above US Mail address also.


Objects
An object is any visual user interface element that you place in the Object
Window. Objects are created with tools in the ToolBox, and may be moved
freely, deleted, and depending on the type of object, assigned a keyboard
command, linked to a structure field, or linked to a user-defined function.
Examples of Objects include Boolean Gadgets, CheckBox_Kind controls,
ListView_Kind controls, and Images.


Object Window
The Object Window is the window in which Objects you create with the tools
from the ToolBox appear.  Its title is "Object Window."  Code is generated
(at your option) for this window and everything in it.


ToolBox
The ToolBox is the small window that appears in the upper right corner of
the screen.  Its title is "Tools."  It contains the tools that you can use
to create Objects to be placed in the Object Window.


Clips Window
The Clips Window is a small window that appears in the lower left corner of
the screen.  You can place objects in this window to get them out of the
way, or to save them for later use.  No code is generated for the Clips
Window or any object in it. When an Object is deleted from the Object
Window, it appears in the Clips Window. When it is deleted from the Clips
Window, it is deleted permanently.  At any time you may move an object from
the Clips Window to the Object Window using the standard technique for
moving Objects.


PseudoKinds
A Pseudokind is a type of User Interface element (Object) that can be used
under GTRequest, but is not a real GadTools kind; instead GTRequest makes
this kind appear to the programmer as if it were a GadTools kind.
Pseudokinds include:

			ToggleSelect Pseudokind
			ImageButton Pseudokind
			EditList Pseudokind



GTControl
A GTControl is a User Interface element that is displayed and used by
GTRequest.  GTControls are usually based on GadTools kinds, although they
may also be based on Pseudokinds.  A GTControl is represented in memory by
a GTControl structure, and also requires a NewGadget structure, a TagList,
and optionally one or more MessageHandlers.


MessageHandlers
A Message Handler is a structure that contains information about how to
handle a certain message reaching a GTControl or a GTRequest.  Message
Handlers exist in a linked list, and are attached to the Object
(GTControl or GTRequest) that they are to handle the message for.  They
contain information on the message type, a pointer to a function to call to
verify that a message is of this type (not required for standard message
types), and a pointer to a function to call if a message is indeed of the
required type (this function is usually user-defined).  The MessageHandler
structure is the interface that links events in a requester to user-defined
code.


Button_Kind
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

To create a Button_Kind, Boolean Gadget (pre-2.0), or a Toggleselect Gadget
(pre-2.0 or a "ToggleSelect" pseudokind), use the Button Tool.  The button
tool is the tool in the upper left corner of the Tools Window.	Its
keyboard equivalent is "b." You then must specify a structure name for this
button in the Struct Name field, and GadgetText for the button in the Text
field.	Default width and height values will be selected for you, but you
may override them in the Width and Height fields.  You can also assign a
GadgetID, and control the color registers used for the GadgetText, left and
top sides of the border, and bottom and right sides of the border using the
Text Color, Border1 Color, and Border2 Color field respectively. To create
a Toggleselect gadget, click on the ToggleSelect button in the bank of
Toggle buttons in the lower left of the requester.  You can also specify
other Gadget flags using similarly named buttons in this bank of Toggle
buttons.  Under GadTools and GTRequest, all buttons and ToggleSelects are
GadgHComp buttons.  Under IGRequest, or Intuition (not GadTools), by
default, the borders colors will be reversed when the gadget is selected,
but the background and text colors will be unaffected.	If you wish to make
the entire button GadgHComp under IGRequest, you should select the
GadgHComp option.  See the section on linking object events to functions,
assigning keyboard commands, Changing an Objects font, and making a button
end the requester for more information on these topics.


Image Gadgets
Requires 2.0 or above to Generate.

Can run under Intuition or GadTools

An Image Gadget is a boolean gadget or Button Kind with an image instead of
text as a label.  The Image comes from any IFF brush.  The Image Gadgets
tool is the third one down in the left column in the ToolBox.  You will
have to assign the Image Gadget a structure name in the Struct Name field.
You may specify the GadgetID in the GadgetID field.  You may turn off and
on any of several options and Gadget Flags in the bank of Toggle gadgets in
the lower left of the requester.  To specify the GadgetRender and
SelectRender images click in the left and right blank boxes in the upper
right area of the requester respectively.  A ASL file requester will appear
allowing you to select an IFF brush.  You must specify a GadgetRender
image, but a SelectRender image is optional; if none is specified, the
gadget will be GadgHComp.  See also Button_Kind gadgets, linking object
events to functions, assigning keyboard commands, and making a button end
the requester for more information on these topics.


String Gadgets
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

To generate String Gadgets, Integer gadgets, or String_Kind or Integer_Kind
gadgets, use the String Gadget Tool, the second one down in the first
column, or type "s."  You must specify a structure name for the gadget in
the Struct Name field. The Label for this String Gadget is specified in the
Label field.  You can also specify the width of the String Gadget in the
Field Width field, its Gadget ID in the GadgetID field, the maximum
allowable characters in the Max Chars. field, and the colors to be used for
its labels and inner and outer borders in the Label Color, Border1 Color
field, and Border2 Color field respectively.  The Label OffSet field
specifies how far to the left of the String Gadgets field (editable area)
the left edge of the Label appears. This will automatically be set for you
when you specify the Label, but you may override it.  To create a Integer
Gadget or an Integer_Kind Gadget, click the LongInt button in the bank of
Toggle buttons at the left of the requester.  You can also turn on or off
miscellaneous gadget flags here using their similarly named Toggle buttons.
See controlling cursor movement between String Gadgets, specifying keyboard
commands for objects, linking events to functions, and linking objects to
structure fields for more information.


Scroll Bars
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

To create a scroll bar, proportional gadget, or Scroller_Kind gadget use
the Scroll bars tool, the fourth down in the first column.  The keyboard
equivalent for this tool is "L."  A Scroll bar consists of a proportional
gadget, an up arrow and a down arrow.  Under IGRequest all of these will be
generated for you.  Under GTRequest, a Scroller_Kind Gadget which already
includes all of these will be generated.  In the Scroll Bars Requester, you
must specify the structure name to use in the Struct Name field.  The
function to call when the scroll bar's position changes is in the Scroll
Func field.  Under IGRequest its argument template is:

	void ScrollFunc (struct IGRequest *,struct Gadget *PropGadget,
		LONG XPos,LONG YPos);

Under GTRequest its argument template is:

	void ScrollFunct(struct GTRequest *,struct IntuiMessage *,
		struct GTControl *, struct MessageHandler *);

Under GTRequest, the IntuiMessage will be a duplicate of the MouseMove
IntuiMessage received from GadTools, and its code field will contain the
position for the XPos or YPos for the displayed area, depending on whether
the Scroll bar is horizontal or vertical.

You can also specify the number of items that will be scrolled through and
the number that can be displayed at once in the No. Items and No. Displayed
fields if this information is known at this time.  By default, Scroll bars
are vertical, however you can create a horizontal Scroll Bar by clicking on
the Horizontal button in the upper right corner of the requester.  To
specify the size of the Scroll Bar you can either type in the number of
pixels high, or wide if you have selected horizontal, you wish the Scroll
Bar to be in the Height/Width field, or you can use the Define button in
the upper right corner.  For more information on using the define button
see Defining sizes with the Define Button.  To specify GadgetID's for the
Proportional gadget, the Up/Left Arrow Gadget, and the Down/Right Arrow
Gadget, use the accordingly labeled fields.  Under IGRequest, all of these
ID's are used.  Under GTRequest, only the GadgetID for the Proportional
gadget is used.  Currently you cannot link keyboard commands to Scroll bars
from within IntuiGen (although you can manually edit the code to do this).


IntuiTexts
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

The IntuiTexts tools is the fifth one down in the first column in the
ToolBox.  Its keyboard equivalent is "T."  In the IntuiText requester, you
specify the structure name to be used in the Struct Name field, the text to
be generated in the Text field, and the color registers to be used for the
foreground and background colors in the FgPen and BgPen fields
respectively.  If the Linked button is selected, the Text will be linked
with all other texts whose link buttons were selected, and linked to any
IG/GTRequest structure generated, causing them to be automatically drawn
when the requester is opened.  If Linked is not selected, the IntuiText is
not linked to anything, and will only be displayed if your code explicitly
calls PrintIText on it.  For information on specifying the TextAttr's to be
used, see Changing an Object's Font.


Images
Requires 2.0 or above to generate

Can run under Intuition or GadTools

To create an Intuition Image structure and Image data from an IFF Brush,
use the Image tool, the sixth one down in the first column.  The Image
requester requires only that you specify a structure name in the Struct
Name field, and click in the empty box at the right to bring up a file
requester in which you can specify the IFF brush to be used.  All Images
are linked together and to the Requester of which they are a part and will
automatically be displayed when that requester is opened.


Boxes
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

A box is a pair of Border structures, one drawn in a light color, the other
in a darker color, which create a highlighted box.  Optionally, the box may
be in a single color. To create a box, use the box tool, the seventh one
down in the first column in the ToolBox.  The keyboard equivalent for this
tool is "x."  In the Box Requester you must specify the structure name in
the Struct Name field, and the colors for the top and left, and bottom and
right sides of the box in the Color1 and Color2 fields respectively.  To
specify the size of the box, you may either enter a width and height in the
Width and Height fields, or you may use the Define button.  See Defining
sizes with the Define Button.  Note that if both Color1 and Color2 are the
same, only one border structure will be generated as two are no longer
necessary.


Borders
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

Border structures can specify lines or polygons to be drawn in a requester.
To create Border structures, use the Border tool, the eighth one down in
the first column, or type its keyboard equivalent, "d."  This requester has
only two field, the Struct Name field in which you must specify a structure
name, and the Color1 field in which you specify the color of the line to
draw.  You must then Define the Border by clicking on the Define Button.
The procedure for doing this is slightly different than for Defining sizes
for other Objects, so it will be documented here.  First click on the
Define button.	The Object window is activated and brought to the front.
Click in it at the beginning point for your border.  A line will begin to
follow your pointer from this point to wherever you move it to.  Click the
mouse button at each additional point you wish to establish.  On the last
point, double-click.


CheckBox_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Checkbox tool is the first tool down in the second column.	In the
CheckBox_KInd requester, you must specify a structure name in the Struct
Name field, and a label in the label field.  You can determine the Objects
PlaceText attributes using the Cycle gadget in the middle left hand side of
the requester.	You can turn on or off the Objects Disabled and Checked
attributes using the Toggle buttons of the same name in the middle of the
requester.  See also Changing an Object's Font, Assigning Keyboard Commands
to Objects, Linking Events to Functions Under IG/GTRequest, and Linking
Structure Fields to Objects for more information on these topics.


MX_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Radio Button (MX_Kind) tool is the second tool down in the second
column.  In the MX_Kind requester, you must specify a structure name in the
Struct Name field, and a label in the Label field.  You can determine the
Object's PlaceText attributes using the Cycle gadget in the middle left hand
side of the requester.	To set up a list of Radio Button options for this
Object, use the Editable list at the right of the requester.  To add a new
entry, click on the New button, and enter the label in the text field
beneath the Listview gadget.  To Change an entry, select it, then change
its text in the text field beneath the Listview gadget, pressing return
when done.  To delete an entry, select it, then click the Delete button.
To determine which radio button is initially selected, enter its ordinal
number in the Selected field.  See also Changing an Object's Font, Linking
Events to Functions Under IG/GTRequest, and Linking Structure Fields to
Objects for more information on these topics.


Cycle_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Cycle_Kind tool is the third tool down in the second column.  In the
Cycle_KInd requester, you must specify a structure name in the Struct Name
field, and optionally specify a label in the Label field.  You can
determine the Object's PlaceText attributes using the Cycle gadget in the
middle left hand side of the requester.  To set up a list of cycle labels
for this Object, use the Editable list at the right of the requester.  To
add a new entry, click on the New button, and enter the label in the text
field beneath the Listview gadget.  To Change an entry, select it, then
change its text in the text field beneath the Listview gadget, pressing
return when done.  To delete an entry, select it, then click the Delete
button.  To determine which cycle options is initially selected, enter its
ordinal number in the Selected field.  To disable the Cycle_Kind object,
click the Disabled Toggle Button. Defaults for the Cycle_Kind's width and
height will be set for you, however you may override them in the Width
field and Height field. See also Changing an Object's Font, Linking Events
to Functions Under IG/GTRequest, and Linking Structure Fields to Objects
for more information on these topics.


ListView_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The ListView_Kind tool is the fourth tool down in the second column.  In
the ListView_KInd requester, you must specify a structure name in the
Struct Name field, and an optional label in the label field.  You can
determine the Object's PlaceText attributes using the Cycle gadget in the
middle left hand side of the requester.  You can make the Object read only
by clicking the Read Only Toggle Button, or you can select the ShowSelected
option you want in the cycle gadget below the PlaceText cycle gadget from
one of the following:  No Display, View Only, or Editable.  To set the
Object's width and height, change the numbers in the Width field and Height
field, or use the Define button.  See also Defining Sizes with the Define
Button, Changing an Object's Font, Linking Events to Functions Under
IG/GTRequest, and Linking Structure Fields to Objects for more information
on these topics.


EditList Pseudokind
Requires 2.0 or above to run

IntuiGen has no direct support for generating code for EditList pseudokinds
(which are supported under GTRequest).  You should generate code for a
ListView_Kind, and then change the first few lines of the corresponding
GTControl structure to read as follows:
		struct GTControl MyControl =
		{
				&PreviousControlHere,
				"EditList",
				INITFROMDATA | STOREDATA | GTC_PSEUDOKIND,
			...
		};


Palette_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Palette_Kind tool is the fifth tool down in the second column.  In the
Palette_KInd requester, you must specify a structure name in the Struct
Name field, and an optional label in the label field.  You can determine
the Object's PlaceText attributes using the Cycle gadget in the middle left
hand side of the requester.  You can select the Indicator placement option
you want in the cycle gadget below the PlaceText cycle gadget from one of
the following:	Indicator (Ind.) Left, Ind. Above, or No Ind.  To set the
Indicator's width or height, enter it in pixels in the Ind. W/H field.  To
disable the Palette_Kind Object click on the Disable Toggle Button.  To set
the Objects width and height, change the numbers in the Width field and
Height field, or use the Define button.  See also Defining Sizes with the
Define Button, Changing an Object's Font, Linking Events to Functions Under
IG/GTRequest, and Linking Structure Fields to Objects for more information
on these topics.


Text_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Text_Kind tool is the sixth tool down in the second column.  In the
Text_Kind requester, you must specify a structure name in the Struct Name
field, and an optional label in the label field.  You can determine the
Object's PlaceText attributes using the Cycle gadget in the middle left
hand side of the requester.  To set the text to be displayed in the
Text_Kind gadget, enter it in the Text field.  The Border Toggle Button
determines whether this Object will have a border or not.  To set the
Object's width and height, change the numbers in the Width and Height
fields.  See also Changing an Object's Font for more information on this
topics.


Number_Kind
Requires 2.0 or above to generate

Requires 2.0 or above to run

The Number_Kind tool is the seventh tool down in the second column.  In the
Number_Kind requester, you must specify a structure name in the Struct Name
field, and an optional label in the label field.  You can determine the
Object's PlaceText attributes using the Cycle gadget in the middle left
hand side of the requester.  To set the number to be displayed in the
Number_Kind gadget, enter it in the Number field.  The Border Toggle Button
determines whether this Object will have a border or not.  To set the
Object's width and height, change the numbers in the Width and Height
fields.  See also Changing an Object's Font for more information on this
topics.


Menus
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

To open the Menus requester, click on the Menus tool, the eighth down in
the second column in the Tool Box, or press "m."  The Menu Window will
open, and, after a short initialization delay, your cursor will appear in
the upper left corner. This first String Gadget is the title of the
left-most menu.  The Gadget to its right is the title of the second menu,
and so on.  Beneath each menu title, are fifteen Gadgets representing that
menu's items.  Only items for which there is text will be generated.  If
there is a blank item between two filled items,  the TopEdge value of the
second filled item will be adjusted accordingly, leaving it in its same
position relative to the first.  Fill in the menus and menu items as you
would have them generated.

To call up an information requester for any menu title or menu item, shift
click on it. Note that the item upon which you are shift clicking cannot
already be selected (the cursor can't be in that Gadget) when you do this,
or no message will be sent to IntuiGen, and consequently, the requester
will not appear.  If this happens, simply select another item, and then
shift click on the desired one.

If you called up an information requester on a menu title, a Menu Info
Requester with two String Gadgets and an "OK" Gadget will appear.  The
"Struct Name:" Gadget contains the struct name of this menu.  If you
entered the menu title before you added any of this menu's items, the
struct name will be synonymous with the first title that you typed in,
otherwise it will be "MenuX" where X is the number of the menu.  By
automatically generating the structure name in this manner, you do not have
to be bothered with assigning everything a struct name.  For future
reference, the struct names as generated by IntuiGen will all be listed in
the accompanying Summary (see summaries in the Generate Code Requester).
The second Gadget, "Title:", reflects the title of this menu.  Click "OK"
or hit return when you are finished.

If you called up an information requester on a menu item, a Menu Item Info
Requester will appear with five String Gadgets, a bank of three
Toggleselect Gadgets at the bottom, a box in which the subitems will go,
and an "OK" and "Cancel" Gadget.  The "Struct Name:" field contains the
structure name that will be used in generating the code.  This will
automatically contain the structure name of the menu of which this item is
a part as taken at the time of the item's creation, followed by the word
"Item" and then the item's number, where the first item in a menu is zero
and the last is fourteen.  The "Text:" field contains the text for that
item, and the "Select Text:" field contains the SelectText for that item.
The "Command:" field contains the single letter command that will activate
that item when pressed in conjunction with the right Amiga key.  The
"Function:" field contains the name of the function that is to be called
when this menu item is chosen under GTRequest or IGRequest.  This function will be
passed the address of the IG/GTRequest structure and the address of a copy of
the IntuiMessage structure.  The "ITEMENABLED," "CHECKIT," and "CHECKED"
Gadgets turn on and off their corresponding flags in the MenuItem
structure.  To add subitems, click in the box in the upper middle of the
requester, and enter the subitem's text.  You may bring up an information
requester on a subitem in the same manner in which you brought up the Menu
Item Info Requester.  The SubItem Info Requester operates exactly like the
Menu Item Info Requester, except that it has no provisions for subitems.

When you are finished with the Menus Requester, click the close Gadget in
the upper left corner of the Window.  If you wish to change these entries
later in a session, click on the Menus tool again, or press "m."  The Menus
Requester will appear with your entries, allowing further editing.


Preferences
Can be set under 1.2 and above

Code generation Not Applicable

To open the Preferences Requester, click on the Preferences Gadget in the
Tool Box, the or press "p."  The preferences requester allows you to set
the IntuiGen colors to match those of the program you are developing, and
set the IntuiGen screen to interlaced or non-interlaced.  Setting the
IntuiGen colors to match those of your program allows you to see how your
layout will look in your program, and helps you in setting Border colors
for various Gadgets and such.  Also, IntuiGen will generate a Color Table,
with which you can set your program's screen's colors, using its current
colors when you are ready to generate code. You are, of course, limited to
four colors, as IntuiGen sets itself up on a four color Screen.  You can
work around this though by limiting your User-Interface items to the first
four colors of your screen, reserving the rest for other items.

To set a given color register, click on its representative color square, so
that it is surrounded by a pink (or whatever color register three happens
to be defined as) box.	Below the color select squares are three
Proportional Gadgets.  Each of these is labeled with one of the primary
colors, and next to the label is written that color's numerical value.  By
adjusting the proportional Gadget, either directly or with the arrows, you
can change that primary color's value in the chosen color register. When
the color registers tone suits you, you can repeat the process with the
remaining registers.

The "Laced" Gadget in the lower left corner sets the Screen to interlaced
or non-interlaced.  If no Objects (includes everything but menus, and
IGRequest information) have been created, leaving the Object Window and
Clips Window empty, the Screen will be changed when you press "Use," or
"Save."  Otherwise, this Gadget can only be used in setting the saved
preferences.

When all the registers have been properly adjusted, you can end the
requester in one of three ways.  You can click on "Use," which will use the
selected colors for the current session, "Save," which will save the
selected colors for use in future sessions, or "Cancel," which will return
the color registers to their state prior to your calling up the Preferences
Requester.

Preferences are also automatically saved as part of the IntuiGen file.
Clicking "Save" in the Preferences Requester saves global preferences which
will be used each time you load IntuiGen without also opening a project
file.  When you load a project file, however, the current preferences will
be overridden by those in the file.

All global preferences data is saved as a ToolType in the IntuiGen.info
file.  If this file is missing, global preferences cannot be saved.  They
still can, however, be saved on a file by file basis.  See Saving and
Loading.


Color Tables
Can be generated under 1.2 or above.

Can run under Intuition or GadTools

To instruct IntuiGen to include a Color Table with your code listing,
select the "Color Table" Gadget in the Generate Code Requester.  Your Color
Table will automatically be given the structure name of "ColorMap." (That's
excluding the period).	To set the colors of a given Screen "Screen" to
those specified by the Color Table, use the following command (Note that
the Graphics Library must be open):

LoadRGB4 (&(Screen->ViewPort),ColorMap,4);


The following is a sample Color Table:

USHORT ColorMap[] =
{
	3822,
	273,
	3549,
	3980,
};


Changing Objects
To change any Object in the Object Window, double click on it. This will
bring up the original requester used to create the Object, with the
original information.  Make any changes you would like, and click "OK."  If
you change your mind and decide to abandon your changes, click "Cancel."


Positioning Objects
To move an Object, click on it with the select button.	      It will be
highlighted.  Position the mouse where you would like the upper left corner
of the Object to be, and click the select button again.  The Object will be
moved to the chosen location.  You can also move an Object one pixel at a
time, using the arrow keys.  Please note that String Gadgets are positioned
by the upper left corner of their text entry box, not by the upper left
corner of their label.	At the bottom of the Tool Box will be two sets of
coordinates. The bottom one, in color one (defaults to black), are the
current coordinates of the mouse pointer relative to the active Window
(which should, at this point, be the Object Window).  The second one, in
color three (defaults to pink), are the coordinates of the selected Object.

To move a group of Objects, click on the first Object in the group, and the
shift-click on the rest of the Objects.  They will all be highlighted.	The
Object coordinates (color three, pink) will reflect the topmost, left-most
Object, which is the handle.  Move the pointer to where you would like the
handle positioned, and click the select button.  The handle will be
positioned under your pointer, and all the other selected Objects will be
moved to retain their same positions relative to the handle.  To de-select
the group, click on any Object, and then it alone will be selected.  After
a short pause (don't double click on it), click on it again, and it will be
de-selected, leaving your Window as it will look when created from the
generated code.  Again, you can move the group a single pixel at a time
using the arrow keys.

One of the most useful features of IntuiGen is Automatic Positioning.  This
can be made to work in several ways.  The first way is to select "Object
Position" from the "Windows" menu, or press "Enter" (on the numeric keypad)
when no Object or group is selected.  This brings up a small requester that
allows you to choose whether newly created Objects will be placed in the
Object Window in Rows (across the screen) or in Columns (up and down).  Two
String Gadgets allow you to set the Horizontal Offset or the Vertical
Offset between the Objects.  This reflects the number of pixels in between
each Object.  If you invoke this requester, either through the menu or from
the keyboard, when a single Object is selected, it allows you to set the
coordinates of the LeftEdge and TopEdge numerically.  This can be useful
when trying to move an Object to specific coordinates.	If you invoke this
requester when a group of Objects is selected, you have the option to move
the group to a specific set of coordinates as above, but you can also
re-arrange the group so that it is in a row or column.	To do this, simply
select the Gadget representing the desired arrangement (row or column), and
set the offset.  When you click "OK" the group of Objects will be
re-arranged, with the topmost left-most Object in either the top or left
position (depending upon whether you selected "Row" or "Column"), the
second topmost left-most Object in the second position, and so on.

A few other things should be noted.  The first of these is unique handling
when Boxes and Borders are involved.  A Box or Border can be quite large,
and will often have other Objects inside of it.  But clicking inside of it
to position an Object or a group of Objects would de-select the Object or
group, and select the Box or Border.  For this reason, when an Object or
group is selected, clicking on a Box or Border is treated like clicking on
an unoccupied space in the Window, that is, the selected Object or group is
moved, and the Box or Border is not selected.  To select a Box or Border,
you must first de-select everything, and then click on them.  Then they can
be moved or included in a group like anything else.

Another feature is the ability to change the way the Objects are layered.
When two Objects are on top of one another, and the mouse is clicked over
both of them, the topmost one will be selected.  To change which one is the
topmost one use the "8" and "2" keys on the numeric keypad.  You can
remember these keys, because on their side, the have an up arrow and a down
arrow painted on them respectively.  They work as Bring to Front, and Send
to Back for the selected Object.  When using them, remember, Boxes and
Borders are automatically kept behind everything else.	Sending a Boolean
Gadget to the back would send it behind everything but Boxes and Borders.
Likewise, bringing a Box to the front would bring it in front of all other
Boxes and Borders, but it would still be behind all other Objects.

You can move Objects or groups into the Clips Window in the same way that
you would move them within the Object Window.  You can later move them back
using the same procedure.  No code is generated for Objects left in the
Clips Window, but they are saved when you use the save command, and will be
restored when you later re-load the saved file (see Saving and Loading).


Deleting Objects
When you press the Delete key, the selected Object or group will first be
removed to the Clips Window.  If they are already in the Clips Window when
you press Delete, they will be truly deleted.  Hence, pressing delete twice
will completely eradicate the current Object or group.


Auto Struct Names
In certain circumstance, where you are creating a large series of Objects,
it would be advantageous to have numbered struct names that would be
automatically carried through for each new Object of that type.  To do
this, when you create your first Object just type something similar to
"StructNameHere1" or "MyGadget23" for the struct name.  The next time you
call that requester, the "Struct Name:" field will already be filled in
with "StructNameHere2" and "MyGadget24" respectively.  Also, the GadgetID's
for the different Gadget tools will automatically increment by one.


IntuiGen Key Commands
Pressing the Help key will open a Window containing a list of all the
keyboard commands, including Load, Save, Send to Front, Send to Back, and
Delete.


Object Fonts
The label font of any Object whose requester has a Font/Style button may be
changed.  Clicking on this button will bring up a Text Attributes Requester
listing various text attributes.  Use the mouse to turn off and on the
desired features and then click "OK."


Defining Sizes
The "Define" Gadget is an easy way to set the height or width of an Object.
When you click on it the open requester will temporarily be cleared and the
message "Define Height/Width" will be displayed.  To define the height and
width, place the pointer where you would like the upper left corner of the
Object to appear in the Object Window, then press and hold the left button.
Notice that the current mouse coordinates are displayed in the bottom part
of the Tool Box.  While continuing to hold the mouse button, move the
pointer to where you would like the lower right corner of the Object to be.
As you move the mouse, a box should be drawn and updated reflecting the
size and position of the Object.  When the box is adequately sized, let go
of the mouse button.  The open requester will reappear, and the appropriate
height or width will be entered into the Height and Width fields.


Saving/Loading IGen
The Saving and Loading Requesters can be invoked by selecting "Save Igen"
and "Load Igen" from the "Project" menu or hitting control-S and control-L,
respectively. Under Release 2 and above, an ASL file requester will appear.
On pre-2.0 machines, a requester with a single String Gadget into which you
can enter the path and file name of the file you are trying to load or save
will appear.  It is recommended that you append the file extension ".IGen"
on to all IntuiGen files to make them easy to identify. Also note that when
saving, any file existing under the given path and file name will be
renamed with the extension .BAK.  Any existing .BAK file will be deleted.

All Objects, Menus, Preferences settings, and Window sizes and positions
are saved to the file and restored when it is loaded.  If you have created
or loaded Objects in IntuiGen, and then load another .IGen file, the Menus,
Preferences, and Window settings of the loaded file will override and
replace the current parameters.  However, Objects in memory will not be
affected; the Objects in the loaded file will simply be added to the
current Object list.  This provides a mechanism for combining files or
inserting one file into another.


End Buttons
You can cause a Button Object or an Image Button Object to end the
requester when they are clicked on.  In the lower middle-right of each
requester are a set of Toggleselect Gadgets labeled IGEndGadget, and
FillStruct.  If you want your GTRequest or and IGRequest to end when this
Gadget is selected, or its keyboard command is typed, select IGEndGadget.
If this Gadget is an IGEndGadget, if your data structure is to be filled
(an OK-type Gadget) when this Gadget is chosen, choose FillStruct.  If the
data structure should be left as is (a Cancel-type Gadget), do not select
FillStruct.  Above these two Toggleselect Gadgets is a String Gadget
labeled End Func.  If this is an IGEndGadget, and a function name is given
in this field, this function will be called before IGRequest terminates.
Note that the object's GadgetUp and GadgetDown functions, if applicable,
will be called first.


Limiting String Gadgets
You can enter any  characters that should not be allowed in a String Gadget
in the Invalid Chars field in the String Gadgets requester.  If a user
types any character found in this field under IGRequest or GTRequest, they
will be automatically removed by GT/IGRequest on the next message from that
requester (GadgetDown, GadgetUp, MouseButtons, etcetera).

Many times String Gadgets will be used for numerical quantities rather than
text. IGRequest supports floating point String Gadgets (can be defined as
float or double in IGRequest.c or GTRequest.c, in the Source directory on
the IntuiGen disk), SHORT String Gadgets, and LONG String Gadgets.  These
are chosen by selecting the "Float," "Long," and "Short" Toggleselect
Gadgets, respectively.	If one of these types is chosen, the Struct Field
is assumed to be of the same type, not a string, and whatever value is
entered into the String Gadget will be converted to a number of the
appropriate type before it is entered into your structure field.  (See
linking Objects to Structure fields).  For types of SHORT and LONG, select
the "LONGINT" Gadget to limit the characters that can be typed into the
Gadget.  Do not select "LONGINT" for floating point Gadgets, as this will
prevent the user from entering a decimal point. Regardless of type (Long,
Short, Float), or whether or not "LONGINT" is selected, IG/GTRequest will
automatically assume that all characters save the digits 0-9, the minus
sign, and the period, are "Invalid" and will treat them in a identically to
Invalid Characters.  You need not enter anything into the "Invalid Chars:"
field.	To set limits on these on numerical String Gadgets, fill in the
"High:" and "Low:" fields.  If these are left blank, it is assumed there
are no limits.	Otherwise the numbers entered will automatically be forced
to be between or equal to these numbers.  Note that it is legal to enter
just one limit, i.e. enter 0 in the Low field and leave the high field
blank.	In this case there would be no high limit.


String Gadget Cursor GadgetUp Movement
One of the most convenient features for a user entering data into a
requester is hitting Return and having the next String Gadget automatically
activated.  The "Next String:" field in the String Gadget requester
contains the structure name of the String Gadget to be activated when a
GadgetUp message is received from the requester.  If the Toggleselect
Gadget "Next," located to the right of the "Next String:" Gadget, is
selected when you create a String Gadget (which it is by default), then the
next String Gadget you create will automatically be entered into this
field.	In the event that this is the last String Gadget you create, having
"Next" selected will have no effect.


Window Size Position
The Window Size/Position Requester is brought up by clicking on the Object
Window resizing Gadget, resizing the Object Window, or choosing "Window
Size/Position" from the "Windows" Menu.  It consists of four String
Gadgets, "To Window" and "From Window" boolean Gadgets, and "OK" and
"Cancel" Gadgets.

In the four String Gadgets you will find the Object Window's LeftEdge,
TopEdge, Width, and Height values.  You may change these to anything you
like.  Clicking on the "To Window" Gadget will resize and reposition the
Object Window to match the numbers in these four String Gadgets.  You can
also resize and reposition the Object Window itself, and then click the
"From Window" Gadget, which will update the String Gadgets to match the new
Window coordinates.

When you are satisfied with the Object Window's position, you can close the
requester in one of three ways.  The first way is to click on the close
Gadget on the Window Size/Position Window.  When you do this, the Object
Window will retain whatever size and position it currently has, regardless
of coordinates the LeftEdge, TopEdge, Width, and Height Gadgets contain.
The second way is to click "OK" in the Window Size/Position requester.  The
Object Window will be resized and repositioned to match the String Gadget
coordinates.  The third way is to hit return.  This will have the same
effect as choosing "OK."

To cancel the changes that you have made to the Object Window's size and
position, click "Cancel" or hit escape.  The Object Window will return to
its previous size and position.


Card File Tutorial
Type IntuiGen on the command line and press return.  We will be using
IntuiGen and GTRequest to create a simple card file to hold names and
addresses.  If you would prefer to read a saved version of the tutorial
from disk, the IGen file (that can be loaded into IntuiGen via the Load
command), complete source file, and executable file are all in the Examples
directory on the IntuiGen disk.  First we will look at the data structure
that we will be using:

struct Person {
	struct Person	*Next,*Prev;
	UBYTE	Name[100],
			Address[100],
			CityStateZip[100];
	SHORT	Age;
};

We will have our Window simulate one card, with Gadgets to change the card
we are looking at.  We will also have a Gadget for adding new cards.  We
will have one menu, called Project, with items "Load," "Save," and "Quit."
The user will also be able to type control-c to quit.  Global variables
will be the pointer to the currently displayed card, OnScreen, the base of
the list, CardBase, a Remember key upon which new cards will be allocated,
CardKey, and a flag to be set when the program is to terminate, QuitFlag.
Functions we will have to write will be main, NewCard, Quit, LoadStuff, and
SaveStuff, although for the purposes of this tutorial, we will not be
expanding LoadStuff and SaveStuff; they will simply print their names to
the console indicating that they were called.

The first set of Gadgets that we will generate will be the String Gadgets
"Name:," "Address:," "City, State, Zip:," and "Age:."  They will be
arranged into a column.  To facilitate this, select "Object Position" from
the "Windows" menu.  Select Column, and leave the vertical offset at zero.
(See Positioning Objects). Then press "OK."  Next hit "s" on the keyboard
to bring up the String Gadgets Requester.  For the Struct Name, enter
"NameGad".  For the label enter "Name:".  For Gadget Activation Flags
select "RELVERIFY," and "GADGIMMEDIATE."  Activate the "Struct Field:"
field and enter "Name".  For maximum characters enter 100.  Then click
"OK."  Notice that we are leaving the "Next" Gadget selected so that the
next Gadget we create will automatically be entered as the Gadget to
activate on a GadgetUp message from this one.  (See Cursor movement between
String Gadgets).  Move the "Name:" Gadget to
the center of the Window.

Press "s" again.  This time enter "AddressGad" for the struct name,
"Address:" for the label, and "Address" for the Struct Field.  The Gadget
Activation and maximum characters will remain the same from the previous
Gadget.  Click "OK."  Your second String Gadget will appear immediately
below the first, in a perfect column.  Create the "City, State, Zip:"
Gadgets using an identical procedure.

Press "s" one last time.  Enter "AgeGad" for the struct name, "Age:" for
the label, and "Age" for the struct field.  Select "LONGINT" as a Gadget
Type, and Short down below, as the struct field type.  Click "OK."

Next we will create a series of Boolean Gadgets that are to be arranged in
a row. With no Objects selected, hit enter on the numeric keypad to bring
up the Auto Positioning Requester.  Select "Row."  Leave the XOffSet zero.
Click "OK."  Press "b" to call up the Button Gadgets Requester.  For a
struct name, enter "PreviousGad". For the Gadget Text, enter "Previous".
Next click on the keyboard command String Gadget.  Enter "p".  Select
"IGEndGadget" and "FillStruct."  We will have the requester end, change
OnScreen to point to the new card, and call GTRequest again.  To prevent
the Window from re-opening and closing, we will open in our main routine,
and set the NewWindow pointer in the GTRequest structure to NULL.

Create another Button Gadget.  Set its struct name to NextGad, its text to
"Next", and its keyboard command to "n".  Leave "IGEndGadget" and
"FillStruct" selected. Create a third labeled "New".  Make sure it has a
unique keyboard command, don't use "n" again.  Click on the "Previous"
Gadget and shift-click on the "Next" and "New" Gadgets.  Move your pointer
down below the String Gadgets and click.

Press "t" to invoke the IntuiTexts requester.  For the struct name type
"Title".  For the text, type "IntuiGen Generated Card File".  Select
"Linked."  Click on "Font/Style."  In the Text Attributes Requester, select
bold, underlined, italic, extended, and Topaz_Sixty.  (See Object Fonts).
Click "OK." in both requesters.  Your IntuiText will likely appear next to
your "New" Gadget, possibly with some outside of the Window, and thus not
visible. Click on the visible portion of it and move it up above the String
Gadgets.

Next, press "x" to bring up the Boxes Requester.  For the struct name type
"Box". Then click define.  Draw a box around all of the other Objects in
the Window.  Then click "OK" in the Boxes Requester.

Click on the box, and then shift-click on all the other Objects.  Move them
to the top left corner of the Window.  Then click on any Object besides the
box to de-select the group.  Resize the Window so it just fits your
requester.  Click "OK" in the Window Size Position Requester that will then
appear.

Click "m" to bring up the Menus Requester.  Type "Project" into the first
Menu field. Press return to move to the first MenuItem field.  Type "Load".
Press return and type "Save", and then for the third MenuItem enter "Quit".
Shift-click on the "Load" item. Enter "LoadStuff" into the "Function:"
field.	Click "OK" in the Menu Item Info Requester.  Bring up the info
requester on the "Save" item.  For its function enter "SaveStuff".  For the
Quit item's function, enter "Quit".  Then close the Menu Window.

Click "r" to bring up the IG/GTRequest Info Requester.  For struct name, enter
"CardRequest".  For struct type, enter "Person".  Enter "c" into the Ending
keyboard command String Gadget, select "Ctrl" as the Qualifying key, and
select "FillStruct" to have GTRequest fill our structure for us.  Then
click "OK."

Click "Write Code" in the Tool Box.  (See Generating Code).  Type in
convenient code and summary names. Select "Window Listing," "IG/GTRequest
Code," "GadTools Code," and "Summary."  Click "OK."  For the Window struct
name type "CardFileWindow".  For the title, enter "IG Card File".  Click
"OK."  Click "OK" in the Window Size/Position Requester for both the
minimum and maximum sizes.  Select GadgetDown, GadgetUp, MenuPick, and
RawKey for IDCMP flags. Select DragBar, DepthGadget, Smart_Refresh, and
Activate for Window Flags. In the Save Igen Data Requester enter a
convenient file name, and press return to save your Igen data file.  The
program will then terminate.

Load the generated code file into your text editor.  Notice that IntuiGen
generated over 700 lines of structure definitions just for this project.
At the top of the file, include stddef.h, stdlib.h, Exec/Exec.h,
Intuition/Intuition.h, IntuiGen/IntuiGen.h, and IntuiGen/GTRequest.h.
Define IntuitionBase, GadToolsBase, and GfxBase.  Declare struct Person,
CardBase, OnScreen, and CardKey and QuitFlag, which should both be
initialized to zero.  Declare the functions (as returning void) LoadStuff,
SaveStuff, and Quit.  Move to the bottom of the file.  Change the NewWindow
field in the CardRequest structure to NULL.  Type a LoadStuff function that
takes as arguments a pointer to a GTRequest structure, and a pointer to an
IntuiMessage structure.  Have it print "LoadStuff" to the console.  Type a
SaveStuff function that has identical arguments to the LoadStuff function.
Have it write "SaveStuff" to the console.  Write a Quit function, taking
the same arguments, that calls GTEndRequest with a termination value of 1.
Then type in the following functions:

BOOL NewCard ()
{
    struct Person *new;

    new=AllocRemember (&CardKey,sizeof (struct Person),MEMF_PUBLIC |
MEMF_CLEAR);
    if (!new) return (1);
    if (OnScreen->Next) OnScreen->Next->Prev=new;
    new->Next=OnScreen->Next;
    new->Prev=OnScreen;
    OnScreen->Next=new;
    OnScreen=new;
    return (0);
}

main ()
{
    IntuitionBase=OpenLibrary ("intuition.library",0);
    GfxBase=OpenLibrary ("graphics.library",0);
    GadToolsBase=OpenLibrary ("gadtools.library",0);

    if (!IntuitionBase || !GfxBase || !GadToolsBase) goto done;

    CardRequest.Window=OpenWindowTagList (NULL,NewCardFileWindowTags);
    if (!(CardRequest.Window)) goto done;

    OnScreen=&CardBase;
    NewCard ();
    while (!QuitFlag) {
	CardRequest.DataStruct=(APTR)OnScreen;
	if (!GTRequest (&CardRequest)) break;
	if (GetEndControl(&CardRequest)==&NewGad) NewCard ();
	else if (GetEndControl(&CardRequest)==&NextGad && OnScreen->Next)
	    OnScreen=OnScreen->Next;
	else if (GetEndControl(&CardRequest)==&PreviousGad &&
OnScreen->Prev!=&CardBase)
	    OnScreen=OnScreen->Prev;
    }

done:  if (IntuitionBase) {
	   FreeRemember (&CardRequest.ReqKey,1);
	   FreeRemember (&CardKey,1);
	   if (CardRequest.Window) CloseWindow (CardRequest.Window);
	   CloseLibrary (IntuitionBase);
	}
	CloseLibrary(GadToolBase);
	if (GfxBase) CloseLibrary (GfxBase);
}

Save and compile this program, and then link it with GTRequest.c, found in
the Source directory on your IntuiGen disk.


Generating Code
To bring up the Generate Code Requester, click on the "Write Code" Gadget
in the ToolBox (the bottom Gadget on the right side), select "Generate
Code" from the "Project" menu, or press "c," or "q."  Under Release 2 or
higher, two ASL file requesters will appear, in sequence, immediately after
you click the Write Code gadget.  The first one allows you to enter the
filename to save the generated C Source code under.  The second allows you
to enter the filename, if any, to save a summary under.  Summaries are
explained in detail below.  Once you have responded or Canceled both of
these requesters, the Generate Code requester will appear.  If you are
working on a pre-Release 2 machine, the Generate Code requester will appear
immediately.  In the Generate Code Requester, we find two String Gadgets,
several Toggleselect Gadgets, an "OK" Gadget, "Cancel" Gadget, and a "Quit"
Gadget.  The "Write Code To:" String Gadget should contain the pathname and
filename to which you would like the C source code for your Objects and
Requester written.  If you used the ASL file requester to select a
path/filename to write code to, that path/filename will appear here.  Note
that any previous file existing in the given directory under the given
filename will be renamed with the extension .BAK.  Any existing .BAK file
will be deleted.  The "Write Summary To:" String Gadget should contain the
pathname and filename to which you would like the summary for set of
Objects written.  The summary will only be written if the "Summary" Gadget
at the bottom of the requester is selected. Again, note that any previous
file existing in the given directory under the given filename will be
renamed with a .BAK extension and any .BAK file will be deleted.

A summary consists of a list of the Objects written, their types, structure
names, coordinates, and GadgetIDs.  This can be extremely useful when
integrating the IntuiGen generated code into your program, or when making
changes at a later date. To have a Summary written, specify a Summary
filename, and click the Summary Toggle Button in the Generate Code
Requester.

For a Window Listing, Screen Listing, or Color Table Listing, select the
appropriate Gadgets at the bottom of the requester before choosing "OK."
These options will be discussed in their own sections shortly.	To have
IGInfo code and an IGReques structure generated, select "IG/GTRequest
Code."

To have GadTools Code written, select GadTools Code.  If GadTools Code and
IG/GTRequest Code are selected, GTRequest code will be written instead of
IGRequest code, and the system structures written will be for the GadTools
library, and not Intuition.

To write the source code, and summary, and end the current IntuiGen
session, click "OK."  To return to the program, click "Cancel."  To exit
IntuiGen without writing any code or summary, click "Quit."  After you have
generated code, or if you have chosen "Quit," the Save IGen Data Requester
will appear, allowing you to save your work as a proprietary file that can
later be retrieved into IntuiGen.  No String Gadgets in this requester will
be activated, however, providing an easy means to either save the file
under any previous filename by pressing return, or exit by pressing escape.
For more information see Saving and Loading.


Window Listings
To Generate a Window Listing, select the "Window Listing" Gadget in the
Generate Code Requester before selecting "OK."  This will cause the Get
Window Info Requester to be invoked when you select "OK" in the Generate
Code Requester.  In this Requester are two text fields, the "Struct Name:"
field, and the "Title:" field.  The "Struct Name:" field contains the
structure name that is to be used to generate the Window structure.  The
"Title:" field contains the title of the Window to be generated. Once these
are filled in, click "OK," or if you no longer wish to create a Window
structure, click "Cancel."

After you have clicked "OK" in the Get Window Info Requester, a message
will appear telling you to size the Object Window to the minimum dimensions
which you wish it to have.  The Window Size/Position Requester will appear
to help facilitate this (see Window Size/Position Requester).  After you
have set the minimum limits, the message will change, now instructing you
to size the Object Window to its maximum allowable dimensions.	Again the
Window Size/Position Requester will appear to help facilitate this.

After the maximum and minimum limits have been set, the IDCMP Flags
Requester will appear.	Select the appropriate IDCMP flags for your Window,
then click "OK." Next the Window Flags Requester will appear.  Select the
appropriate Window Flags and click "OK."  The Get Window Info Requester
will then terminate, and your code will be written to the chosen file. Note
that if GadTools Code is selected in the Generate Code requester, a taglist
will be written for OpenWindowTagList.	Otherwise, a NewWindow structure
will be written.


Screen Listings
To open the Get Screen Info Requester, select the "Screen Listing" Gadget
in the Generate Code Requester before clicking "OK."  The "Struct Name:"
field represents the structure name that will be used in writing the code
for the Screen.  The "Title:" field represents the title for this Screen.
The "Depth:" field contains the number of bitplanes to be allocated for
this Screen.  After you have filled in these fields, click "OK," or
"Cancel."

After clicking on "OK," the View Modes Requester will appear.  Select the
appropriate View Modes, then click "OK."  Your Screen will now be written
into the code file.  Note that if GadTools Code is selected in the Generate
Code requester, a taglist will be written for OpenScreenTagList. Otherwise,
a NewScreen structure will be written.


Object Key Commands
You can assign keyboard commands to Button Objects, Image Button Objects,
String Gadget Objects, and CheckBox_Kind Objects in IntuiGen.  If you
generate IGRequest or GTRequest code, (see Generating Code) these commands
will automatically be implemented.  If you do not generate IG/GTRequest
code, it is up to you to implement these commands, and entering them into
IntuiGen is superfluous.

To assign a keyboard command to an Object, find in its requester a bank of
Toggleselect Gadgets labeled "Ctrl," "Alt," "Amiga," and "Shift."  Next to
these is a small String Gadget.  The String Gadget contains the main letter
on the key cap for the keyboard command for this Gadget under IGRequest.
Special characters, such as Control-A, should not be typed into this
Gadget.  To have special characters recognized by your program under
IGRequest, select the accompanying Toggleselect Gadget.  For instance, if
you wanted the keyboard command for this Gadget to be Control-A, you would
type "a" into the String Gadget, and select the "Ctrl" Toggle Gadget.
Under GT/IGRequest, typing the Keyboard Command will have the same effect
as a GadgetDown and then a GadgetUp Message from the Gadget.


Requester Key Commands
To establish requester-wide keyboard commands to end the requester under
IGRequest or GTRequest use the IG/GTRequest Info Requester.  Currently,
keyboard commands that do not end the requester, but merely call a
user-defined function are not supported from within IntuiGen, and there
have been no special provisions made for them under IG/GTRequest.  The only
way to implement such commands would be to set up a routine to process
RawKey or VanillaKey messages and call the appropriate routines on given
key presses.

However, if you would like to establish key commands that end the
requester, in the lower left side of the IG/GTRequest Info requester is a
group of Gadgets used to set requester-ending keyboard commands.  They work
similarly to the keyboard command areas of certain Object Information
Requester (i.e. Button Objects, Image Button Objects, etc.).  Type the
letter, with no Shift, Alt, Control, or Amiga keys held down, into the
little String Gadget next to the bank of Toggleselect Gadgets labeled
"Control," "Alt," "Amiga," and "Shift."  Then, if any special keys are to
be used with this key to make the keyboard command, select them from the
bank of Toggleselect Gadgets.  Below these Gadgets are the "End Func:"
String Gadget and the "FillStruct" Toggleselect Gadget.  When the requester
is ended by pressing this key, if IGRequest should call a particular
function, type it into the "End Func:" field.  If IGRequest should fill the
data structure, select "FillStruct."  If more than one keyboard command is
to be used to end the requester, click on the down arrow next to the little
String Gadget containing the ending key.  The ending key Gadgets will all
be reset, and you can enter new parameters for a second ending key.  Repeat
this procedure for additional ending keys.  To scroll back through the
list, use the up arrow key.  You may make changes to any item in the list.


Object Events
If, when your requester is running, an Object is clicked on, or the text it
contains is changed, or the user manipulates it in any way, an event is
said to have happened to it.  Events usually correspond to IntuiMessages
relating to the given object.  Under IG/GTRequest, you can specify
user-defined functions to be called on a given event.  If you see fields
labeled GUp Func, GDown Func, or DSel Func in any Object Requester, that
Object can be linked to a user-defined function which will be called on a
given event.  The "GUp Func:" field contains the name of the function to be
called by GT/IGRequest when a GadgetUp message is received for this Gadget.
The "GDown Func:" field contains the name of the function to be called when
a GadgetDown message is received.

In the String Gadgets requester is a field labeled "DSel Func."  It is
nearly identical to "GUp Func:" but will always be called.  GadgetUp
messages are received from String Gadgets only when the user presses
Return.  The De-selected Function will be called on any subsequent
messages.  For instance, if the user uses the mouse to select your String
Gadget, types something into it, and then clicks on another String Gadget,
you would not normally receive a GadgetUp message, however, as soon as the
GadgetDown message is received from the second String Gadget, the
De-selected Function will be called.  In order for this to work, the String
Gadget for which you have a De-selected Function needs to have
"GADGIMMEDIATE" selected as one of its Activation types, and the Window
needs to be equipped to receive GadgetDown messages.  For this to work
well, all String Gadgets in the requester need to have "GADGIMMEDIATE"
selected as an Activation type.

Under IGRequest, the argument template for calls to user-defined functions are:

	void Function (struct IGRequest *,struct IntuiMessage *);

Under GTRequest, the argument template is:

	void Function (struct GTRequest *,struct IntuiMessage *,
			      struct GTControl *,struct MessageHandler *);


IG/GTRequest Info
To open the IG/GTRequest Info Requester select IG/GTRequest from the menu,
or type "r."

The "Struct Name:" field reflects the name to be used for the IG/GTRequest
structure when generating the code.  The remaining String Gadgets, but for
the last two in the right bank, reflect the function to be called when a
IntuiMessage whose class reflects the String Gadget's name is received by
IG/GTRequest.  If you enter a function name in one of these, when a message
of the corresponding class is received under IGRequest, your function will
be called using the following argument template:

	void Function (struct IGRequest *,struct IntuiMessage *);

Under GTRequest, the argument template is:

	void Function (struct GTRequest *,struct IntuiMessage *,
			      struct GTControl *,struct MessageHandler *);

The last two String Gadgets in the right bank relate to the data structure
that IG/GTRequest will fill with data on exit and read data from on
entrance.  The "Data Struct:" field contains the name of the structure that
is to be filled by IG/GTRequest. The "Struct Type:" field reflects the type
of the structure that is to be filled.	Let us use the example from the
CardFile tutorial, where you have a declaration that reads:

struct Person {
	UBYTE Name[100];
	UBYTE Address[100];
	UBYTE CityStateZip[100];
	USHORT Age;
} People[100];

In this case, the "Struct Type:" field would contain "Person" and the "Data
Struct:" field would contain something like "People[1]" or "People[2]."


Linking To Struct Fields
To link any Gadgets to a structure field, you must at some point establish
the type of structure in which the field you are linking to exists.  This
is done globally in the IG/GTRequest Info Requester.

To link a String Gadget to a structure field from within IntuiGen is
simple; in the String Gadgets requester, simply enter the name of the
structure field from which and to which you want the contents of this
String Gadget copied.

Toggle Button Gadgets can also be linked to structure fields, however you
cannot do this from within IntuiGen.  See the appropriate documentation in
the IGRequest.guide file and the GTRequest.guide file.

Most GadTools kinds can be linked to structure fields from within IntuiGen.
The following table lists each eligible GadTools kind, and the attribute
which is copied to and from its corresponding structure field.	Following
the table is an explanation of how to link a GadTools kind to a structure
field from within IntuiGen.

	CHECKBOX_KIND	GTCB_Checked
	MX_KIND 	GTMX_Active
	CYCLE_KIND	GTCY_Active
	LISTVIEW_KIND	GTLV_Selected
	PALETTE_KIND	GTPA_Color

To link one of the above GadTools kinds to a structure field from within
IntuiGen, open the corresponding Object's requester (see Changing an
Object).  There will be a field labeled "Field."  Enter the structure
field's name here.  On the middle left side of the requester will be a
cycle gadget whose contents default to SHORT.  The options that it cycles
through correspond to a field type in the GTControl structure.	These
labels, their corresponding field types, and explanation, is presented
below.

SHORT
	Corresponds to FLD_SHORT
	The structure field is a signed integral type two bytes wide
LONG
	Corresponds to FLD_LONG
	The structure field is a signed integral type four bytes wide
FLOAT
	Corresponds to FLD_FLOAT
	The structure field is a signed floating point type four bytes wide
	You must define the GTFLOAT typedef, and the functions
	StringToFloat and FloatToString in GTRequest.h and recompile
	GTRequest.c to set this up.  By default GTFLOAT is defined as a ULONG
BYTE
	Corresponds to FLD_BYTE
	The structure field is a signed integral type one byte wide
POINTER
	Corresponds to FLD_POINTER The structure field is an unsigned
	integral type (pointer) four bytes wide This is functionally
	identical to LONG
BOOLBIT
	This corresponds to FLD_BOOLBIT The structure field is an unsigned
	integral type four bytes wide This causes 1<<control->Bit in the
	field to be set if control->Attribute is true, otherwise it causes
	it to be cleared.  It allows for Boolean Bitfield storage.  You
	must manually set the Bit field in the generated GTControl
	structure; IntuiGen provides no means to do this. NOTE: This field
	type is most frequently used when manually linking Toggle buttons
	to structure fields in the generated code
ATTRBIT
	Corresponds to FLD_ATTRBIT
	Executes the following statement:
		field= 1<<control->Attribute
	Not especially useful
SINSTRUCT
	Corresponds to FLD_STRINGINSTRUCT
	if your structure looks like this:
				    struct mystruct {
					type1 field1;
					type2 field2;
					...
					UBYTE TheField[X];
					type3 field4;
					type4 field5;
					...
				    };
				  Then use this flag to store data as a
				  string in TheField
SPINSTRUCT
	Corresponds to FLD_STRINGPOINTEDTOINSTRUCT
	if your structure looks like this:
			      struct mystruct {
				  type1 field1;
				  ...
				  UBYTE *TheField;
				  typeX FieldX;
				  ...
			      };
			   Then use this flag to copy the
			   string to the buffer pointed to
			   by TheField
STRPTR
	Corresponds to FLD_STRINGPTR
	if your structure looks like the one above
	(for STRINGPOINTEDTOINSTRUCT) and you
	want to set TheField=control->Attribute
	(without performing a strcpy)
	use this.  (Assumes control->Attribute is a
	char *, functionally identical to FLD_LONG)


