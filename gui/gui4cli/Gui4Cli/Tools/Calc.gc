G4C

; Calc.gc - by dck
; ----------------------------------------------------------------------------
; A calculator, which uses Gui4Cli's mathematical abilities to calculate
; complex math expression, including functions such as Log, Sin, Tan etc.
; This used to be based on ARexx - changed for Gui4Cli V3.5
; The code to convert between Dec<->Hex, Dec<->Bin and Hex<->Bin
; is by Björn X Öqvist, 1998-03-25
; ----------------------------------------------------------------------------

WINBIG 390 25 237 118 "FPCalc"    ; Our window.
WinType 11110001                  ; It has all standard gadgets & bottom resize
; WINBACKGROUND PATTERN 0 2       ; Uncomment to add a flashy background..
resinfo 8 640 256

BOX 0 0 0 0 out button ; A window sized box, taking us way beyond mere "cool"

; ----------------------------------------------------------------------------
;       Startup/Ending events
; ----------------------------------------------------------------------------

xONLOAD                     ; Upon loading of the GUI
	ifexists port ~AREXX        ; check for & start rexxmast
	   run rexxmast
	endif
	calcvar = ""               ; This is our main variable
	GUIOPEN calc.gc
	mem  = mem1                ; These are the Memory variables
	mem1 = 0
	mem2 = 0
	mem3 = 0
	mem4 = 0
	mem5 = 0
	membuff = ""
	calcmode = SMALL      ; small/big window

xonclose
	guiquit calc.gc
	guiquit calc.hist

xOnQuit               ; On quitting we delete the env variables, 
	delvar .result

; ----------------------------------------------------------------------------
;       BUTTONS
;       All the buttons do the same thing. They AppVar their number or letter
;       to our main variable "calcvar" and redisplay it
; ----------------------------------------------------------------------------

;============ The Buttons for the plain numbers

XBUTTON 6 21 25 15 1
	gadkey 1                       ; Keyboard shortcut
	AppVar calcvar 1               ; AppVar the number to "calcvar"
	update calc.gc  1 $calcvar     ; and re-display it.

XBUTTON 33 21 25 15 2          ; same as above
	gadkey  2
	AppVar calcvar 2
	update calc.gc  1 $calcvar

XBUTTON 60 21 25 15 3
	gadkey  3
	AppVar calcvar 3
	update calc.gc  1 $calcvar

XBUTTON 6 36 25 15 4
	gadkey  4
	AppVar calcvar 4
	update calc.gc  1 $calcvar

XBUTTON 33 36 25 15 5
	gadkey  5
	AppVar calcvar 5
	update calc.gc  1 $calcvar

XBUTTON 60 36 25 15 6
	gadkey  6
	AppVar calcvar 6
	update calc.gc  1 $calcvar

XBUTTON 6 51 25 15 7
	gadkey  7
	AppVar calcvar 7
	update calc.gc  1 $calcvar

XBUTTON 33 51 25 15 8
	gadkey  8
	AppVar calcvar 8
	update calc.gc  1 $calcvar

XBUTTON 60 51 25 15 9
	gadkey  9
	AppVar calcvar 9
	update calc.gc  1 $calcvar

XBUTTON 6 66 25 15 0
	gadkey  0
	AppVar calcvar 0
	update calc.gc  1 $calcvar

XBUTTON 33 66 25 15 .
	gadkey  .
	AppVar calcvar .
	update calc.gc  1 $calcvar

XBUTTON 60 66 25 15 <        ; backspace
	gadkey #8
	cutvar calcvar CUT CHAR -1 ""   ; It will delete the last character of
	update calc.gc  1 $calcvar     ; "calcvar" and re-display it

;=============== The operators

XBUTTON 87 21 25 15 /
	gadkey  /
	AppVar calcvar /
	update calc.gc  1 $calcvar

XBUTTON 87 36 25 15 *       ; hit twice for square
	gadkey  *
	AppVar calcvar *
	update calc.gc  1 $calcvar

XBUTTON 87 51 25 15 -
	gadkey  -
	AppVar calcvar -
	update calc.gc  1 $calcvar

XBUTTON 87 66 25 15 +
	gadkey  +
	AppVar calcvar +
	update calc.gc  1 $calcvar

;------------- right most bank

XBUTTON 114 21 25 15 (
	gadkey  (
	AppVar calcvar (
	update calc.gc  1 $calcvar

XBUTTON 114 36 25 15 )
	gadkey  )
	AppVar calcvar )
	update calc.gc  1 $calcvar

XBUTTON 195 66 37 15 CLR       ; Clear
	gadkey #127
	update calc.gc  1 0
	setvar calcvar ""
	if $calcmode = BIG                ; update ticker tape
	   lvuse calc.hist 1
	   LVAdd '** Clear **'
	endif

XBUTTON 114 51 25 30 =
	gadkey #13
	gosub calc.gc calculate        ; GoSub the routine which does the calculation

; =============== The function buttons

XBUTTON 141 66 25 15 "^"
	gadkey ^
	AppVar calcvar ^
	update calc.gc  1 $calcvar

XBUTTON 168 66 25 15 "_Pi"
	gadkey p
	AppVar calcvar pi
	update calc.gc  1 $calcvar

XBUTTON 141 21 44 15 "_Sin"
	AppVar calcvar sin(
	update calc.gc  1 $calcvar

XBUTTON 186 21 45 15 "_Cos"
	AppVar calcvar cos(
	update calc.gc  1 $calcvar

XBUTTON 186 36 45 15 "_Tan"
	AppVar calcvar tan(
	update calc.gc  1 $calcvar

XBUTTON 141 36 44 15 "_Log"
	AppVar calcvar log(
	update calc.gc  1 $calcvar

XBUTTON 141 51 44 15 "L_n"
	AppVar calcvar ln(
	update calc.gc  1 $calcvar

XBUTTON 186 51 45 15 "_Exp"
	AppVar calcvar exp(
	update calc.gc  1 $calcvar

; ----------------------------------------------------------------------------
;       Display Panel
;       It's a xTEXTin gadget, so we can enter a calculation directly into it.
; ----------------------------------------------------------------------------

XTEXTIN 5 5 227 15 "" calcvar 0 512
	GADID 1
	gosub calc.gc calculate        ; GoSub the routine which does the calculation


; ----------------------------------------------------------------------------
;       Routine to calculate & display result
; ----------------------------------------------------------------------------

xROUTINE calculate
	if $calcvar > ""                ; If there is an entry
	   if $calcmode = BIG
	      lvuse calc.hist 1         ; update history window if open
	      LVAdd '$calcvar'
	   endif
	   calcvar = $($calcvar)        ; do calculation
	   update calc.gc 1 $calcvar    ; display answer
	   if $calcmode = BIG           ; update ticker tape
	      LVAdd "-> $calcvar"
	   endif
	   if $calcvar = 0 
	      calcvar = ""              ; and if it's 0, we empty it (looks nicer)
	   endif
	endif 

; ----------------------------------------------------------------------------
;       MEMORIES
;       If you look at the following code carefully, you will see that we
;       need a variable within a variable. We use "membuff" to construct it.
; ----------------------------------------------------------------------------

;============ Memories display panel

XTEXTIN 6 84 123 14 "" $mem 0 30
	GadID 5

;============ Memories cycler

XCYCLER 6 99 62 15 "" mem
	Cstr "M1" mem1
	Cstr "M2" mem2
	Cstr "M3" mem3
	Cstr "M4" mem4
	Cstr "M5" mem5
	membuff = "\$$mem"         ; This means set membuff to $ + whatever is in "mem"
	update calc.gc 5 $membuff  ; so that it points to the correct variable

;============ Memory IN/OUT

XBUTTON 69 99 15 15 I          ; These buttons do the usual MEM in/out/+/-
	$mem = $calcvar                 ; stuff that calculators do.
	membuff = "\$$mem"
	update calc.gc 5 $membuff

XBUTTON 84 99 15 15 O
	membuff = "\$$mem"
	AppVar calcvar $membuff
	update calc.gc 1 $calcvar

XBUTTON 99 99 15 15 +
	membuff = "\$$mem"
	$mem = $($calcvar + $membuff)
	membuff = "\$$mem"
	update calc.gc 5 $membuff

XBUTTON 114 99 15 15 -
	membuff = "\$$mem"
	$mem = $($membuff - $calcvar)
	membuff = "\$$mem"
	update calc.gc 5 $membuff

; ----------------------------------------------------------------------------
;       Hex/Binary conversion
; ----------------------------------------------------------------------------

XTEXTIN 132 84 100 14 "" BinHex 0 30
GadID 4

XCYCLER 132 99 68 15 "" BinHexMode
	Cstr "Hex" hex
	Cstr "Bin" bin
	IF $BinHexMode = "bin"
		CLI "rx 'say >env:.result C2B(X2C($BinHex\))'"
	ELSE
	   CLI "rx 'say >env:.result C2X(B2C($BinHex\))'"
	ENDIF
	SetVar BinHex $.result
	update calc.gc 4 $BinHex


XBUTTON 201 99 15 15 I		; input from main display
	local res
	; calculate main display
	res = $($calcvar)
	; convert into whole number (floats not allowed)
	searchvar res '.' CS first
	if $$search.pos != ""
	   pos = $$search.pos
	   res = $res[0][$pos]
	endif
	IF $BinHexMode = "bin"
		CLI "rx 'say >env:.result C2B(D2C($res\))'"
	ELSE
	   CLI "rx 'say >env:.result C2X(D2C($res\))'"
	ENDIF
	BinHex = $.result
	update calc.gc 4 $BinHex


XBUTTON 216 99 15 15 O		; output to main display
	IF $BinHexMode = "bin"
		CLI "rx 'say >env:.result C2D(B2C($BinHex\))'"
	ELSE
	   CLI "rx 'say >env:.result C2D(X2C($BinHex\))'"
	ENDIF
	AppVar calcvar $.result    ; appvar instead of setvar ?
	update calc.gc 1 $calcvar


; ----------------------------------------------------------------------------
;       History ListView (on RMB)
;       Here we open the 2nd gui which has a listview displaying a history
;       of the actions we've taken. When clicked upon, it will restore the
;       line clicked on into the main panel
; ----------------------------------------------------------------------------

xOnRMB
	GuiOpen calc.hist

; ================= NEWFILE ==================

NewFile calc.hist

WINBIG 170 25 205 156 'Calc History'
wintype 11110001
varpath calc.gc

xOnOpen
	calc.gc/calcmode = BIG

xOnClose
	calc.gc/calcmode = SMALL

;---- This is the listview that will show the results
;     update main calc pannel according to lv line clicked

XLISTVIEW 0 0 0 0 "" lv "" 10 TXT
	gadid 1
	if $lv[0][3] == '** '       ; line cleared
	   calcvar = 0
	elseif $lv[0][3] = '-> '    ; a result
	   calcvar = $lv[3]
	else
	   calcvar = $lv            ; a calculation
	endif
	update calc.gc 1 $calcvar
	if $calcvar = 0
	   calcvar = ''
	endif



