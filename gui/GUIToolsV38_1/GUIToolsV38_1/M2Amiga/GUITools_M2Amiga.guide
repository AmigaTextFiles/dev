@DATABASE "guitools_m2amiga.guide"

@REMARK "$VER: GUITools_M2Amiga_guide 38.1 (11.05.94)"

@NODE Main "GUITools_M2Amiga.guide"


                                   GUITools

                                 Version 38.1

                               M2Amiga Document

 =========================================================================

                       Mar 1994   Carsten Ziegeler
                                  Augustin-Wibbelt-Str.7
                                  D-33106 Paderborn
                                  Germany

 =========================================================================


                               Table of Contents
                               =================

@{" Function descriptions " LINK MCHAP-1}

   @{" Function overview " LINK MCHAP-1-1}
   @{" Screens and windows " LINK MCHAP-1-2}
   @{" Fonts " LINK MCHAP-1-3}
   @{" Creating GUIs " LINK MCHAP-1-4}
   @{" Checking GUIs " LINK MCHAP-1-5}
   @{" Modifying GUIs " LINK MCHAP-1-6}
   @{" Refreshing " LINK MCHAP-1-7}
   @{" Requesters " LINK MCHAP-1-8}
   @{" Macros " LINK MCHAP-1-9}

@{" Working with GUITools " LINK MCHAP-2}

   @{" Guidelines " LINK MCHAP-Guidelines}
   @{" Freeing resources (V38.0)" LINK MCHAP-FreeingResources}
   @{" Creating gadgets " LINK MCHAP-CreatingGadgets}
   @{" Creating menus " LINK MCHAP-CreatingMenus}
   @{" Dealing with fonts " LINK MCHAP-DealingFonts}
   @{" Key equivalents (V38.0)" LINK MCHAP-KeyEquivalents}
   @{" Resizable gadgets (V38.0)" LINK MCHAP-ResizableGadgets}
   @{" Using requesters (V38.0)" LINK MCHAP-UsingRequesters}

@{" Bugs / Problems " LINK MCHAP-3}

   @{" Problems under V37.3 " LINK MCHAP-3-1}
   @{" Known Bugs " LINK MCHAP-KnownBugs}
   @{" Author / Final Words " LINK MCHAP-Author}

@ENDNODE

@NODE MCHAP-1 "Function descriptions"

If a version number is specified together with any function, constant,
structure etc, this feature is only available if you are using the
given version of GUITools or a higher one ! Don't use them under older
versions !
It is a good thing to test in your programs which version of the
library you are using and if this version is sufficient.

For more information see the chapter @{" Working with GUITools " LINK MCHAP-2}.

Only the most important parameters are descripted. The meaning of most of
them is similar to their name !


   @{" Function overview " LINK MCHAP-1-1}

   @{" Screens and windows " LINK MCHAP-1-2}

   @{" Fonts " LINK MCHAP-1-3}

   @{" Creating GUIs " LINK MCHAP-1-4}

   @{" Checking GUIs " LINK MCHAP-1-5}

   @{" Modifying GUIs " LINK MCHAP-1-6}

   @{" Refreshing " LINK MCHAP-1-7}

   @{" Requesters " LINK MCHAP-1-8}

   @{" Macros " LINK MCHAP-1-9}

@ENDNODE

@NODE MCHAP-1-1 "Function overview"

Listed below are all functions of the guitools.library version 38.1.

   @{" AllVarsToGad " LINK MFCT-AllVarsToGad}           V38.0
   @{" BeginRefresh " LINK MFCT-BeginRefresh}           V38.0
   @{" ClearWindow "  LINK MFCT-ClearWindow}            V38.0
   @{" CloseIntScreen " LINK MFCT-CloseIntScreen}
   @{" CloseIntWindow " LINK MFCT-CloseIntWindow}
   @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg}         V38.0
   @{" CreateGadget " LINK MFCT-CreateGadget}
   @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull}
   @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}        V38.1
   @{" CreateGadgetText " LINK MFCT-CreateGadgetText}
   @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo}
   @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}      V38.0
   @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget}    V38.0
   @{" DoResizing " LINK MFCT-DoRezsizing}             V38.1
   @{" DrawBox " LINK MFCT-DrawBox}                V38.0
   @{" EmptyIntMsgPort " LINK MFCT-EmptyIntMsgPort}
   @{" EndRefresh " LINK MFCT-EndRefresh}             V38.0
   @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}
   @{" GADDESC macro " LINK MFCT-GADDESC}          V38.1 / GUIToolsMacros
   @{" GADOBJS macro " LINK MFCT-GADOBJS}          V38.1 / GUIToolsMacros
   @{" GadgetStatus " LINK MFCT-GadgetStatus}
   @{" GadWithKey " LINK MFCT-GadWithKey}             V38.0
   @{" GetIntMsg " LINK MFCT-GetIntMsg}
   @{" GetOwnFont " LINK MFCT-GetOwnFont}
   @{" HandleIntMsg " LINK MFCT-HandleIntMsg}
   @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry}
   @{" ModifyGadget " LINK MFCT-ModifyGadget}
   @{" NewFontAllGadgets " LINK MFCT-NewFontAllGadgets}      V38.0
   @{" NewGadgetFont " LINK MFCT-NewGadgetFont}          V38.0
   @{" NewGadgetText " LINK MFCT-NewGadgetText}          V38.0
   @{" OpenIntScreen " LINK MFCT-OpenIntScreen}
   @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}      V38.0
   @{" OpenIntWindow " LINK MFCT-OpenIntWindow}
   @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags}      V38.0
   @{" RedrawGadgets " LINK MFCT-RedrawGadgets}          V38.0
   @{" RedrawMenu " LINK MFCT-RedrawMenu}             V38.0
   @{" RemoveGadgets " LINK MFCT-RemoveGadgets}          V38.0
   @{" RemoveMenu " LINK MFCT-RemoveMenu}             V38.0
   @{" RemOwnFont " LINK MFCT-RemOwnFont}
   @{" ResizeGadget " LINK MFCT-ResizeGagdet}           V38.0
   @{" SetGUI " LINK MFCT-SetGUI}
   @{" SetProcessWindow " LINK MFCT-SetProcessWindow}       V38.0
   @{" ShowRequester " LINK MFCT-ShowRequester}          V38.0
   @{" ShowRequesterP " LINK MFCT-ShowRequester}         V38.0
   @{" SimpleReq " LINK MFCT-SimpleReq}              V38.0
   @{" SimpleReqP " LINK MFCT-SimpleReq}             V38.0
   @{" TopazAttr " LINK MFCT-TopazAttr}
   @{" UpdateEGad " LINK MFCT-UpdateEGad}
   @{" UpdateEntryGadgets " LINK MFCT-UpdateEntryGadgets}
   @{" VarToGad " LINK MFCT-VarToGad}               V38.0
   @{" WaitIntMsg " LINK MFCT-WaitIntMsg}

@ENDNODE

@NODE MCHAP-1-2 "Screens and windows"

   @{" OpenIntScreen " LINK MFCT-OpenIntScreen}
   @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}      V38.0
   @{" OpenIntWindow " LINK MFCT-OpenIntWindow}
   @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags}      V38.0
   @{" CloseIntWindow " LINK MFCT-CloseIntWindow}
   @{" CloseIntScreen " LINK MFCT-CloseIntScreen}
   @{" ClearWindow "  LINK MFCT-ClearWindow}            V38.0

@ENDNODE

@NODE MCHAP-1-3 "Fonts"

   @{" GetOwnFont " LINK MFCT-GetOwnFont}
   @{" RemOwnFont " LINK MFCT-RemOwnFont}
   @{" TopazAttr " LINK MFCT-TopazAttr}

@ENDNODE

@NODE MCHAP-1-4 "Creating GUIs"

   @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo}
   @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}      V38.0
   @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}
   @{" SetGUI " LINK MFCT-SetGUI}
   @{" CreateGadget " LINK MFCT-CreateGadget}
   @{" CreateGadgetText " LINK MFCT-CreateGadgetText}
   @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull}
   @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}        V38.1
   @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget}    V38.0
   @{" RemoveGadgets " LINK MFCT-RemoveGadgets}          V38.0
   @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry}
   @{" RemoveMenu " LINK MFCT-RemoveMenu}             V38.0

@ENDNODE

@NODE MCHAP-1-5 "Checking GUIs"

   @{" WaitIntMsg " LINK MFCT-WaitIntMsg}
   @{" GetIntMsg " LINK MFCT-GetIntMsg}
   @{" EmptyIntMsgPort " LINK MFCT-EmptyIntMsgPort}
   @{" HandleIntMsg " LINK MFCT-HandleIntMsg}
   @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg}         V38.0
   @{" GadWithKey " LINK MFCT-GadWithKey}             V38.0
   @{" DoResizing " LINK MFCT-DoRezsizing}             V38.1

@ENDNODE

@NODE MCHAP-1-6 "Modifying GUIs"

   @{" GadgetStatus " LINK MFCT-GadgetStatus}
   @{" ModifyGadget " LINK MFCT-ModifyGadget}
   @{" UpdateEGad " LINK MFCT-UpdateEGad}
   @{" UpdateEntryGadgets " LINK MFCT-UpdateEntryGadgets}
   @{" VarToGad " LINK MFCT-VarToGad}               V38.0
   @{" AllVarsToGad " LINK MFCT-AllVarsToGad}           V38.0
   @{" RedrawMenu " LINK MFCT-RedrawMenu}             V38.0
   @{" RedrawGadgets " LINK MFCT-RedrawGadgets}          V38.0
   @{" ResizeGadget " LINK MFCT-ResizeGagdet}           V38.0
   @{" NewGadgetText " LINK MFCT-NewGadgetText}          V38.0
   @{" NewGadgetFont " LINK MFCT-NewGadgetFont}          V38.0
   @{" NewFontAllGadgets " LINK MFCT-NewFontAllGadgets}      V38.0
   @{" DrawBox " LINK MFCT-DrawBox}                V38.0

@ENDNODE

@NODE MCHAP-1-7 "Refreshing"

   @{" BeginRefresh " LINK MFCT-BeginRefresh}           V38.0
   @{" EndRefresh " LINK MFCT-EndRefresh}             V38.0

@ENDNODE

@NODE MCHAP-1-8 "Requesters"

   @{" SetProcessWindow " LINK MFCT-SetProcessWindow}       V38.0
   @{" ShowRequester " LINK MFCT-ShowRequester}          V38.0
   @{" ShowRequesterP " LINK MFCT-ShowRequester}         V38.0
   @{" SimpleReq " LINK MFCT-SimpleReq}              V38.0
   @{" SimpleReqP " LINK MFCT-SimpleReq}             V38.0

@ENDNODE

@NODE MCHAP-1-9 "Macros"

   @{" GADDESC macro " LINK MFCT-GADDESC}          V38.1 / GUIToolsMacros
   @{" GADOBJS macro " LINK MFCT-GADOBJS}          V38.1 / GUIToolsMacros

@ENDNODE

@NODE MFCT-AllVarsToGad "AllVarsToGad (V38.0)"

Set the gadgets to the values of the belonging variables

      PROCEDURE AllVarsToGad(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

All gadgets for which a notify was set during the creation, gets
the value of the belonging variable using @{" VarToGad " LINK MFCT-VarToGad}.
This is useful e.g. for a configuration editor if you have loaded a
new configuration and want to display it. Instead to modify each
gadget after gadget simply call AllVarsToGad.

See also: @{" GUIInfoFlagSet " LINK MSTRUCT-GUIInfoFlagSet}, @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MFCT-BeginRefresh "BeginRefresh (V38.0)"

Replacement for GadTools.GTBeginRefresh

      PROCEDURE BeginRefresh(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

You must call this function instead of GadTools.GTBeginRefresh, because
GUITools does some extra refreshing, e.g. for the GUITools gadgets.
Use this function together with @{" EndRefresh " LINK MFCT-EndRefresh}.

See also: @{" doRefresh flag " LINK MSTRUCT-GUIInfoFlagSet}

@ENDNODE

@NODE MFCT-ClearWindow "ClearWindow (V38.0)"

Clear the window contents of the GUI window

      PROCEDURE ClearWindow(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

@ENDNODE

@NODE MFCT-CloseIntScreen "CloseIntScreen"

Close a screen "safely"

      PROCEDURE CloseIntScreen(screen{A0} : ScreenPtr);

Before the screen is closed, GUITools closes all not yet closed windows
on this screen using @{" CloseIntWindow " LINK MFCT-CloseIntWindow}.
So when using an own screen, there is no need to call CloseIntWindow,
it is sufficient to call CloseIntScreen.
Starting with version 38.0 you also don't need the calls to @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo},
because @{" CloseIntWindow " LINK MFCT-CloseIntWindow} does this for you.

See also: @{" Freeing resources " LINK MCHAP-FreeingResources}, @{" OpenIntScreen " LINK MFCT-OpenIntScreen}, @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}

@ENDNODE

@NODE MFCT-CloseIntWindow "CloseIntWindow"

Close a window "safely"

      PROCEDURE CloseIntWindow(window{A0} : WindowPtr);

All outstanding messages will be replied before the window is closed.
Starting with version 38.0 CloseIntWindow checks if there are still
some not freed @{" GUIInfo structures " LINK MSTRUCT-GUIInfo} for this window. CloseIntWindow
will remove them all using @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}.

See also: @{" Freeing resources " LINK MCHAP-FreeingResources}, @{" OpenIntWindow " LINK MFCT-OpenIntWindow}, @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags},
          @{" CloseIntScreen " LINK MFCT-CloseIntScreen}

@ENDNODE

@NODE MFCT-ConvKMsgToGMsg "ConvKMsgToGMsg (V38.0)"

Converts key messages into gadget messages

      PROCEDURE ConvKMsgToGMsg(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

ConvKMsgToGMsg uses the @{" im.code field " LINK MSTRUCT-GUIInfo-im} to get the key and then calls
@{" GadWithKey " LINK MFCT-GadWithKey} with the belonging gadget.
The majority of applications will not call this function by hand. It
can be useful if the @{" noHandleIntMsgCall flag " LINK MSTRUCT-GUIInfoFlagSet} is set and you want to
control the conversion or if you want to handle rawkeys.
Pass this function the vanillaKey code in the @{" im.code field " LINK MSTRUCT-GUIInfo-im} and
vanillaKey in the @{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass}.

The gadget creating functions save all key equivalents which are letters
if the @{" vanillaKeysNotify flag " LINK MSTRUCT-GUIInfoFlagSet} was set. If you want to use alternative
keys, you have to write a @{" VanKeyFct " LINK MSTRUCT-VanKeyFct}.

See also: @{" Key equivalents " LINK MCHAP-KeyEquivalents}

@ENDNODE

@NODE MFCT-CreateGadget "CreateGadget"

Create a new gadget

      PROCEDURE CreateGadget(gui{A0}   : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                            left{D0}   : INTEGER;
                            top{D1}    : INTEGER;
                            width{D2}  : INTEGER;
                            height{D3} : INTEGER;
                            kind{D4}   : LONGCARD;
                            tags{A1}   : TagItemPtr);

This is a replacement for GadToolsL.CreateGadgetA. The basic differences
are the easier handling and the position and size must be specified
directly and not using a NewGadget structure.
CreateGadget uses the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad} to create the gadget. Usually
the gadget created with CreateGadget has no text. But you can pass
a text to it together with some other information using the newgad
field of the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}.
Because CreateGadget has no return value, there is no possibility
to check if the gadget could be created or not. A appropriate error
code is given when calling @{" SetGUI " LINK MFCT-SetGUI}.
The gadget creating functions of GUITools do some extra work which is
explained in the chapter @{" Creating gadgets " LINK MCHAP-CreatingGadgets}.
Before version 38.1 CreateGadget can only deal with gadtools gadget
kinds. All other gadget kinds must be created using @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget}.
Starting with version 38.1 this exception is removed.

See also: @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull}, @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew},

@ENDNODE

@NODE MFCT-CreateGadgetFull "CreateGadgetFull"

Create a new gadget

      PROCEDURE CreateGadgetFull(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                 left{D0}   : INTEGER;
                                 top{D1}    : INTEGER;
                                 width{D2}  : INTEGER;
                                 height{D3} : INTEGER;
                                 kind{D4}   : LONGCARD;
                                 text{A1}   : ADDRESS;
                                 place{D5}  : NewGadgetFlagSet;
                                 tags{A2}   : TagItemPtr);

This function does the same as @{" CreateGadget " LINK MFCT-CreateGadget}, but you can also specify a
gadget text and the flags for the gadget. For more information refer to
@{" CreateGadget " LINK MFCT-CreateGadget}.

See also: @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget},
          @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MFCT-CreateGadgetNew "CreateGadgetNew (V38.1)"

Create a new gadget

      PROCEDURE CreateGadgetNew(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                left{D0}   : INTEGER;
                                top{D1}    : INTEGER;
                                width{D2}  : INTEGER;
                                height{D3} : INTEGER;
                                kind{D4}   : LONGCARD;
                                tags{A1}   : TagItemPtr);

Starting with version 38.1 this is only a new name for the
@{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget} function.
This was done because under older versions there was a very confusing
gadget handling. It required calling @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget} to create
GUITools gadgets and for gadtools gadgets you had to use some other
functions.
Beginning with version 38.1 you can create every gadget kind with
every gadget creating function. Another reason for CreateGadgetNew
was to replace the @{" CreateGadget " LINK MFCT-CreateGadget}, @{" CreateGadgetText " LINK MFCT-CreateGadgetText} and the
@{" CreateGadgetFull " LINK MFCT-CreateGadgetFull} functions.
If you want to define the gadget a little bit more then use
the @{" SgTags " LINK MSTRUCT-SgTags}.

See also: @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MFCT-CreateGadgetText "CreateGadgetText"

Create a new gadget

      PROCEDURE CreateGadgetText(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                 left{D0}   : INTEGER;
                                 top{D1}    : INTEGER;
                                 width{D2}  : INTEGER;
                                 height{D3} : INTEGER;
                                 kind{D4}   : LONGCARD;
                                 text{A1}   : ADDRESS;
                                 tags{A2}   : TagItemPtr);

This function does the same as @{" CreateGadget " LINK MFCT-CreateGadget}, but you can also specify a
gadget text. For more information refer to @{" CreateGadget " LINK MFCT-CreateGadget}.

See also: @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull}, @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget},
          @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MFCT-CreateGUIInfo "CreateGUIInfo"

A new @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} will be allocated and all important
fields will be set

      PROCEDURE CreateGUIInfo(window{A0}  : WindowPtr;
                              maxGads{D0} : INTEGER;
                              maxMenus{D1}: INTEGER) : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};

      window    For this window is the GUI
      maxGads   Maximal amount of gadgets or @{" noGadgets " LINK MSTRUCT-Constants}
      maxMenus  Maximal amount of menu items or @{" noMenu " LINK MSTRUCT-Constants}

CreateGUIInfo requires maxGads and maxMenus to allocate enough memory to
hold pointers to all gadgets and for the NewMenu structures.
Unfortunately, after defining here, these values can't be changed later on,
so choose a huge enough number. If you use @{" noGadgets " LINK MSTRUCT-Constants} resp @{" noMenu " LINK MSTRUCT-Constants}, you
can't create any gadgets resp menus for this window.
There are currently no more than 256 gadgets or menu items allowed !

When using version 38.0 you should use @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} instead,
because CreateGUIInfo has some @{" minor bugs " LINK MCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE MFCT-CreateGUIInfoTags "CreateGUIInfoTags (V38.0)"

A new @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} will be allocated and all important
fields will be set

      PROCEDURE CreateGUIInfoTags(window{A0}  : WindowPtr;
                                  maxGads{D0} : INTEGER;
                                  maxMenus{D1}: INTEGER;
                                  tags{A1}    : TagItemPtr) : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};

      window    For this window is the GUI
      maxGads   Maximal amount of gadgets or @{" noGadgets " LINK MSTRUCT-Constants}
      maxMenus  Maximal amount of menu items or @{" noMenu " LINK MSTRUCT-Constants}

CreateGUIInfoTags requires maxGads and maxMenus to allocate enough memory
to hold pointers to all gadgets and for the NewMenu structures.
Unfortunately, after defining here, these values can't be changed later on,
so choose a huge enough number. If you use @{" noGadgets " LINK MSTRUCT-Constants} resp @{" noMenu " LINK MSTRUCT-Constants}, you
can't create any gadgets resp menus for this window.
There are currently no more than 256 gadgets or menu items allowed !

Replaces @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} under version 38.0 with the extention
of some useful @{" special tags " LINK MSTRUCT-GUITags}.
Furthermore the @{" menuFont field " LINK MSTRUCT-GUIInfo-menuFont} will be set to the font of the
screen. If you now change the TextAttr structure of the @{" font field " LINK MSTRUCT-GUIInfo-font}
this then only concerns the gadgets but not the menus !
When using version 38.0 you should use this instead of @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo},
because CreateGUIInfo has some @{" minor bugs " LINK MCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE MFCT-CreateSpecialGadget "CreateSpecialGadget (V38.0)"

Create a new gadget

      PROCEDURE CreateSpecialGadget(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                    left{D0}   : INTEGER;
                                    top{D1}    : INTEGER;
                                    width{D2}  : INTEGER;
                                    height{D3} : INTEGER;
                                    kind{D4}   : LONGCARD;
                                    tags{A1}   : TagItemPtr);

CreateSpecialGadget is also a replacement for GadToolsL.CreateGadgetA
as @{" CreateGadget " LINK MFCT-CreateGadget} or @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull}.
But before version 38.1 CreateSpecialGadget can only create GUITools
gadgets. All other gadget kinds must be created using the other
gadget creating functions.
Starting with version 38.1 this exception is removed.
CreateSpecialGadget uses the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad} to create the gadget.
Usually the gadget created with CreateSpecialGadget has no text. But
you can pass a text to it together with some other information using the
@{" newgad field " LINK MSTRUCT-GUIInfo-newgad} of the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}. It is also possible
to use the @{" SgTags " LINK MSTRUCT-SgTags} to do.
Because CreateSpecialGadget has no return value, there is no possibility
to check if the gadget could be created or not. A appropriate error
code is given when calling @{" SetGUI " LINK MFCT-SetGUI}.
The gadget creating functions of GUITools do some extra work which is
explained in the chapter @{" Creating gadgets " LINK MCHAP-CreatingGadgets}.
In this chapter you will also find some information about the GUITools
gadgets and how to use them.

See also: @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}

@ENDNODE

@NODE MFCT-DoResizing "DoResizing (V38.1)"

Resize all gadgets using the gadget description flags

      PROCEDURE DoResizing(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

The new sizes and positions will be calculated and can now be displayed
using @{" RedrawGadgets " LINK MFCT-RedrawGadgets}.

See also: @{" Creating gadgets " LINK MCHAP-CreatingGadgets}, @{" Resizable gadgets " LINK MCHAP-ResizableGadgets}

@ENDNODE

@NODE MFCT-DrawBox "DrawBox (V38.0)"

Draws a bevelled box which can be recessed or raised

       PROCEDURE DrawBox(gui{A0}      : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                         left{D0}     : INTEGER;
                         top{D1}      : INTEGER;
                         width{D2}    : INTEGER;
                         height{D3}   : INTEGER;
                         recessed{D4} : BOOLEAN);

@ENDNODE

@NODE MFCT-EmptyIntMsgPort "EmptyIntMsgPort"

Removes all outstanding messages

      PROCEDURE EmptyIntMsgPort(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

@ENDNODE

@NODE MFCT-EndRefresh "EndRefresh (V38.0)"

Replacement for GadTools.GTEndRefresh

      PROCEDURE EndRefresh(gui{A0}      : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                           complete{D0} : BOOLEAN);

You must use this function instead of GadTools.GTEndRefresh together
with @{" BeginRefresh " LINK MFCT-BeginRefresh}, because GUITools does some extra refreshing
e.g. for the GUITools gadgets.
If you have set the @{" guiRefreshWindow tag " LINK MSTRUCT-GUITags} or the
@{" guiResizableGads tag" LINK MSTRUCT-GUITags} with @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} the window
frame will also be refreshed using the RefreshWindowFrame function of
the intuition.library.

See also: @{" doRefresh flag " LINK MSTRUCT-GUIInfoFlagSet}

@ENDNODE

@NODE MFCT-FreeGUIInfo "FreeGUIInfo"

Free a GUIInfo structure, remove all gadgets, menus and resources

      PROCEDURE FreeGUIInfo(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

This function removes first all gadgets and the menu and then frees
the GUIInfo structure.
If you allocated the structure using @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} and you set the
@{" guiRestoreProcessWindow tag " LINK MSTRUCT-GUITags} to a value of TRUE, the windowPtr field of
the process structure will be restored.

See also: @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo}

@ENDNODE

@NODE MFCT-GADDESC "GADDESC macro (V38.1) / GUIToolsMacros"

  PROCEDURE GADDESC(left, top, width, height : SHORTCARD) : LONGCARD;

This macro builds the data for the @{" sgGadgetDesc tag " LINK MSTRUCT-SgTags}. It does the
following calculation:

  RETURN @{" shiftLeft " LINK MSTRUCT-Constants}*left + @{" shiftTop " LINK MSTRUCT-Constants}*top + @{" shiftWidth " LINK MSTRUCT-Constants}*width + height;

See also: @{" Resizable Gadgets " LINK MCHAP-ResizableGadgets}

@ENDNODE

@NODE MFCT-GADOBJS "GADOBJS macro (V38.1) / GUIToolsMacros"

  PROCEDURE GADOBJS(left, top, width, height : SHORTCARD) : LONGCARD;

This macro builds the data for the @{" sgGadgetObjects tag " LINK MSTRUCT-SgTags}. It does the
following calculation:

  RETURN @{" shiftLeft " LINK MSTRUCT-Constants}*left + @{" shiftTop " LINK MSTRUCT-Constants}*top + @{" shiftWidth " LINK MSTRUCT-Constants}*width + height;

See also: @{" Resizable Gadgets " LINK MCHAP-ResizableGadgets}

@ENDNODE

@NODE MFCT-GadgetStatus "GadgetStatus"

Disables or enables a gadget

      PROCEDURE GadgetStatus(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                             nbr{D0}    : INTEGER;
                             status{D1} : BOOLEAN);

      nbr     the gadget number of the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets}
      status  TRUE : gadget enabled
              FALSE: gadget disabled

Gadtools gadgets will be switched using the gaDisabled tag. For
genericKind gadgets the intuition.library functions OnGadget resp
OffGadget are used.

@ENDNODE

@NODE MFCT-GadWithKey "GadWithKey  (V38.0)"

Pretends if the gadget was activated using a key equivalent

      PROCEDURE GadWithKey(gui{A0}   : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                           nbr{D0}   : INTEGER;
                           shift{D1} : BOOLEAN);

      nbr    gadget number in the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets}
      shift  was the shift key pressed ?

The majority of applications don't need to call this function, because
it will be automatically called from @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg}.
But it can be used to process some rawkeys, like the F-keys.
If you set a notify for this gadget, GadWithKey does the same functions
@{" HandleIntMsg " LINK MFCT-HandleIntMsg} does for them (except for integerKind and stringKind).
The @{" gadNbr field " LINK MSTRUCT-GUIInfo-gadNbr} and the @{" gadID field " LINK MSTRUCT-GUIInfo-gadID} will contain the appropriate
values. If the gadget is disabled, no action will happen and the
@{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass} contains IDCMPFlagSet{}. The changes will be made
automatically visible using ModifyGadget !

  gadget kind                action
-------------------------------------------------------------------------

  buttonKind         msgClass := gadgetUp
                     cardCode := 0

  stringKind,        activates the gadget for input
  integerKind        msgClass := gagdetDown
                     cardCode := 0

  checkboxKind       changes the state
                     msgClass := gadgetUp
                     boolCode contains the new state

  mxKind             choose the next value without shift and with shift
                     the previous one
                     msgClass := gadgetDown
                     cardCode := new entry number

  cycleKind          choose the next value without shift and with shift
                     the previous one
                     msgClass := gadgetUp
                     cardCode := new entry number

  sliderKind,        without shift one position forward, with shift
  scrollerKind       one backwards
                     msgClass := gadgetUp
                     intCode  := new position (new level resp new top)


  listviewKind       without shift next entry, with shift the previous
                     one. If no entry wasn't selected yet, without
                     shift the first and with shift the last one is
                     selected.
                     msgClass := gadgetUp
                     cardCode := new entry number

                     If the lvKeyClearTime was set during the creation
                     the sec field of the IntuiMessage will be set to
                     zero. This is to avoid problems using DoubleClick,
                     because you only have to check the entry for zero.

  paletteKind        without shift the next colour will be selected,
                     without shift the previous
                     msgClass := gadgetUp
                     cardCode := new colour number

@ENDNODE

@NODE MFCT-GetIntMsg "GetIntMsg"

Get an IDCMP message

      PROCEDURE GetIntMsg(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo}) : BOOLEAN;

GetIntMsg tries to get a message from the port specified in the @{" port field " LINK MSTRUCT-GUIInfo-port}.
If there is an outstanding message, it gets them, replies it and copies
it to the @{" im field " LINK MSTRUCT-GUIInfo-im} and then returns TRUE. Otherwise if there is no
message FALSE will be returned !
If the @{" noHandleIntMsgCall flag " LINK MSTRUCT-GUIInfoFlagSet} isn't set @{" HandleIntMsg " LINK MFCT-HandleIntMsg} will be called.
If the @{" internMsgHandling flag " LINK MSTRUCT-GUIInfoFlagSet} is set, and @{" HandleIntMsg " LINK MFCT-HandleIntMsg} could process
the message internal, the return value will also be FALSE !
Notice, without a call to @{" HandleIntMsg " LINK MFCT-HandleIntMsg} it is not allowed to check the
extra message information fields of the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} !

See also: @{" WaitIntMsg " LINK MFCT-WaitIntMsg}

@ENDNODE

@NODE MFCT-GetOwnFont "GetOwnFont"

Opens a font

      PROCEDURE GetOwnFont(name{A0} : ADDRESS;
                           size{D0} : CARDINAL;
                           font{A1} : TextAttrPtr) : TextFontPtr;

      font   pointer to a TextAttr structure which will be filled by
             GetOwnFont. This pointer can be used to set a screen's
             font using @{" OpenIntScreen " LINK MFCT-OpenIntScreen} / @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}.
             If you don't need this TextAttr structure set font to
             NIL.

See also: @{" RemOwnFont " LINK MFCT-RemOwnFont}, @{" TopazAttr() " LINK MFCT-TopazAttr}, @{" Dealing with fonts " LINK MCHAP-DealingFonts}

@ENDNODE

@NODE MFCT-HandleIntMsg "HandleIntMsg"

Process an IDCMP message

      PROCEDURE HandleIntMsg(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

This function is automatically called by @{" GetIntMsg " LINK MFCT-GetIntMsg} or @{" WaitIntMsg " LINK MFCT-WaitIntMsg} if
the @{" noHandleIntMsgCall " LINK MSTRUCT-GUIInfoFlagSet} flag isn't set.
The majority of applications will no call this function by themselve. It
is only important if you get your message from shared ports, where it
is not possible to use @{" GetIntMsg " LINK MFCT-GetIntMsg} or @{" WaitIntMsg " LINK MFCT-WaitIntMsg}. In this case you have
to copy the message to the @{" im field " LINK MSTRUCT-GUIInfo-im}!


HandleIntMsg processes the IntuiMessages as follows:

The @{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass} gets a copy of the im.class field. And the
cardCode, intCode ... fields get a copy of the @{" im.code field " LINK MSTRUCT-GUIInfo-im}.
If GUITools could process the message internal, e.g. for
@{" key equivalents " LINK MCHAP-KeyEquivalents}, the msgClass and the code fields will contain
different values from the fields in the @{" im structure " LINK MSTRUCT-GUIInfo-im} , because
GUITools will change them for easier handling. The @{" im field " LINK MSTRUCT-GUIInfo-im}
will always contain the unchanged message !
So please always use the @{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass} for easier handling !


HandleIntMsg does the following actions

    IDCMP message                     action
-------------------------------------------------------------------------

  gadgetUp,          The @{" gadget field " LINK MSTRUCT-GUIInfo-gadget} contains the event gadget and the
  gadgetDown,        @{" gadID field " LINK MSTRUCT-GUIInfo-gadID} the gadget ID. Starting with version
  mouseMove          38.0 the @{" gadNbr field " LINK MSTRUCT-GUIInfo-gadNbr} contains the gadget number
                     for use with the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets} !

                     integerKind,   If the @{" linkEntryGads flag " LINK MSTRUCT-GUIInfoFlagSet} was set
                     stringKind     during the creation, the next entry
                                    gadget will be activated.

                     All the other actions will only take place if a
                     notify was set for this gadget:

                     integerKind,   If the @{" autoUpdateEGads flag " LINK MSTRUCT-GUIInfoFlagSet} is set
                     stringKind     the belonging variables get the
                                    new value.

                     checkboxKind   Updates the belonging variable. If
                                    running under version 38.0 or higher
                                    the boolCode field will contain the
                                    new state.

                     cycleKind,     Update the belonging variable. Usually
                     sliderKind,    there will be no need to check these
                     scrollerKind,  messages. It is sufficient to check
                     listviewKind,  the values of the variables when they
                     paletteKind    are required.

  gadgetdown         All these actions will only take place if a notify
                     was set for this gadget:

                     mxKind,        Update the belonging variable. Usually
                     sliderKind,    there will be no need to check these
                     scrollerKind   messages. It is sufficient to check
                                    the values of the variables when they
                                    are required.

  mouseMove          All these actions will only take place if a notify
                     was set for this gadget:

                     scrollerKind,  Update the belonging variable. Usually
                     sliderKind     there will be no need to check these
                                    messages. It is sufficient to check
                                    the values of the variables when they
                                    are required.

  menuPick           GUITools calculates the menu number and starting
                     with version 38.0 the @{" itemAdr field " LINK MSTRUCT-GUIInfo-itemAdr} contains a
                     pointer to the MenuItem structure.
                     If @{" callMenuData " LINK MSTRUCT-GUIInfoFlagSet} is set, the function given in the
                     userData field will be automatically called.
                     This function should return TRUE resp 1, if more
                     messages should be processed, or FALSE resp 0, if
                     the message loop should be exited.

                     All menuNull messages will be ignored and the
                     @{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass} will contain IDCMPFlagSet{} !

                     See also: @{" Creating menus " LINK MCHAP-CreatingMenus}

  menuHelp           GUITools calculates the menu number and starting
                     with version 38.0 the @{" itemAdr field " LINK MSTRUCT-GUIInfo-itemAdr} contains a
                     pointer to the MenuItem structure if possible.

  vanillaKey         If the @{" convertKeys flag " LINK MSTRUCT-GUIInfoFlagSet} is set, @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg} is
                     now called to handle @{" key equivalents " LINK MCHAP-KeyEquivalents}.

  refreshWindow      If the @{" doRefresh flag " LINK MSTRUCT-GUIInfoFlagSet} is set, @{" BeginRefresh " LINK MFCT-BeginRefresh}
                     followed by @{" EndRefresh(TRUE) " LINK MFCT-EndRefresh} is called to do the
                     refreshing.
                     The application doesn't get the refreshWindow message.

  newSize            If the @{" doResizing flag " LINK MSTRUCT-GUIInfoFlagSet} is set and the gadget
                     descriptions are used, @{" DoResizing " LINK MFCT-DoResizing} followed by
                     @{" RedrawGadgets " LINK MFCT-RedrawGadgets} will be called.
                     If the call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets} fails the user gets
                     the newSize message, otherwise not !
                     In addition the @{" guiResizableGads tag " LINK MSTRUCT-GUITags} must be set !

@ENDNODE

@NODE MFCT-MakeMenuEntry "MakeMenuEntry"

Creates a menu item

      PROCEDURE MakeMenuEntry(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                              type{D0} : SHORTCARD;
                              text{A1} : ADDRESS;
                              key{A2}  : ADDRESS);

      type     nmTitle, nmItem, nmSub  etc
      text     pointer to the menu text
      key      pointer to the key short cut or NIL. Notice, this is a
               pointer to a string and not to a char !

It is possible to specify the menu item more using the @{" newMenus field " LINK MSTRUCT-GUIInfo-newMenus}
or the @{" menuAdr field " LINK MSTRUCT-GUIInfo-menuAdr}.

See also: @{" Creating menus " LINK MCHAP-CreatingMenus}, @{" actmenu field " LINK MSTRUCT-GUIInfo-actmenu}

@ENDNODE

@NODE MFCT-ModifyGadget "ModifyGadget"

Replacement for GadToolsL.GTSetGadgetAttrs - Modifies gadget attributes

      PROCEDURE ModifyGadget(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                             nbr{D0}  : INTEGER;
                             tags{A1} : TagItemPtr);

      nbr     the gadget number in the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets}
      tags    a tag list with the new attributes

@ENDNODE

@NODE MFCT-NewFontAllGadgets "NewFontAllGadgets (V38.0)"

Changes the font for all gadgets

       PROCEDURE NewFontAllGadgets(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                   font{A1}: TextAttrPtr);

This change will only be visible after a call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets}.

See also: @{" NewGadgetFont " LINK MFCT-NewGadgetFont}

@ENDNODE

@NODE MFCT-NewGadgetFont "NewGadgetFont (V38.0)"

Changes the font of one gadget

       PROCEDURE NewGadgetFont(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                               nbr{D0}  : INTEGER;
                               font{A1} : TextAttrPtr);

This change will only be visible after a call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets}.

See also: @{" NewFontAllGadgets " LINK MFCT-NewFontAllGadgets}

@ENDNODE

@NODE MFCT-NewGadgetText "NewGadgetText (V38.0)"

A new text for one gadget

       PROCEDURE NewGadgetText(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                               nbr{D0}  : INTEGER;
                               text{A1} : ADDRESS);

This change will only be visible after a call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets}.

@ENDNODE

@NODE MFCT-OpenIntScreen "OpenIntScreen"

Opens the defined screen

      PROCEDURE OpenIntScreen(id{D0}    : LONGCARD;
                              depth{D1} : INTEGER;
                              name{A0}  : ADDRESS;
                              font{A1}  : TextAttrPtr) : ScreenPtr;

      id     screen display ID as defined in GraphicsD or one of the
             following predefined ones:
             @{" hiresPalID " LINK MSTRUCT-Constants}    a hires screen using pal monitor
             @{" hiresID " LINK MSTRUCT-Constants}       a hires screen using default monitor
             @{" loresPalID " LINK MSTRUCT-Constants}    a lores screen using pal monitor
             @{" loresID " LINK MSTRUCT-Constants}       a lores screen using default monitor
      font   NIL for default font or an own TextAttr structure

The following tag list will be created and then passed to OpenScreenTags
of the intuition.library:

       saPens      := -1
       saDepth     := depth
       saDisplayID := id
       saTitle     := name
       saFont      := font

See also: @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}, @{" CloseIntScreen " LINK MFCT-CloseIntScreen}

@ENDNODE

@NODE MFCT-OpenIntScreenTags "OpenIntScreenTags (V38.0)"

Opens the defined screen

      PROCEDURE OpenIntScreenTags(id{D0}    : LONGCARD;
                                  depth{D1} : INTEGER;
                                  name{A0}  : ADDRESS;
                                  font{A1}  : TextAttrPtr;
                                  tags{A2}  : TagItemPtr) : ScreenPtr;

      id     screen display ID as defined in GraphicsD or one of the
             following predefined ones:
             @{" hiresPalID " LINK MSTRUCT-Constants}    a hires screen using pal monitor
             @{" hiresID " LINK MSTRUCT-Constants}       a hires screen using default monitor
             @{" loresPalID " LINK MSTRUCT-Constants}    a lores screen using pal monitor
             @{" loresID " LINK MSTRUCT-Constants}       a lores screen using default monitor
      font   NIL for default font or an own TextAttr structure
      tags   pointer to an own tag list (or NIL) to specify the screen
             more precise

The following tag list will be created and your own tag list will be
chained to it and then passed to OpenScreenTags of the intuition.library:

       saPens      := -1
       saDepth     := depth
       saDisplayID := id
       saTitle     := name
       saFont      := font

See also: @{" OpenIntScreen " LINK MFCT-OpenIntScreen}, @{" CloseIntScreen " LINK MFCT-CloseIntScreen}

@ENDNODE

@NODE MFCT-OpenIntWindow "OpenIntWindow"

Opens a window on the specified screen

      PROCEDURE OpenIntWindow(left{D0}        : INTEGER;
                              top{D1}         : INTEGER;
                              width{D2}       : INTEGER;
                              height{D3}      : INTEGER;
                              name{A0}        : ADDRESS;
                              idcmpFlags{D4}  : IDCMPFlagSet;
                              windowFlags{D5} : WindowFlagSet;
                              screen{A1}      : ScreenPtr) : WindowPtr;

      width       width or @{" asScreen " LINK MSTRUCT-Constants} to make the window as wide as the
                  screen border
      height      height or @{" asScreen " LINK MSTRUCT-Constants} to make the window as tall as
                  the screen border
      screen      pointer to your own screen or NIL to open the window on
                  the default public screen

The following tag list will be created and then passed to OpenWindowTags
of the intuition.library:

      waTitle       := name
      waScreenTitle := name
      waLeft     := left
      waTop      := top
      waWidth    := width   (resp screen^.width  -left with @{" asScreen " LINK MSTRUCT-Constants})
      waHeight   := height  (resp screen^.height -top  with @{" asScreen " LINK MSTRUCT-Constants})
      waIDCMP    := idcmpFlags
      waFlags    := windowFlags

      Using an own screen:

      waCustomScreen := screen

      Using NIL for the defaul public screen:

      waPubScreen         := default public screen
      waBubScreenFallBack := TRUE

See also: @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags}, @{" Problems with OpenIntWindow " LINK MCHAP-Problems-OpenIntWindow},
          @{" CloseIntWindow " LINK MFCT-CloseIntWindow}

@ENDNODE

@NODE MFCT-OpenIntWindowTags "OpenIntWindowTags (V38.0)"

      Versucht ein Fenster auf dem angegebenen Screen zu öffnen.

      PROCEDURE OpenIntWindowTags(left{D0}        : INTEGER;
                                  top{D1}         : INTEGER;
                                  width{D2}       : INTEGER;
                                  height{D3}      : INTEGER;
                                  name{A0}        : ADDRESS;
                                  idcmpFlags{D4}  : IDCMPFlagSet;
                                  windowFlags{D5} : WindowFlagSet;
                                  screen{A1}      : ScreenPtr
                                  tags{A2}        : TagItemPtr):WindowPtr;

      width       width or @{" asScreen " LINK MSTRUCT-Constants} to make the window as wide as the
                  screen border
      height      height or @{" asScreen " LINK MSTRUCT-Constants} to make the window as tall as
                  the screen border
      screen      pointer to your own screen or NIL to open the window on
                  the default public screen
      tags        pointer to an own tag list (or NIL) to specify the window
                  more precise

The following tag list will be created and your own tag list will be
chained to it and then passed to OpenWindowTags of the intuition.library:

      waTitle  := name
      waLeft   := left
      waTop    := top
      waWidth  := width   (resp screen^.width  -left with @{" asScreen " LINK MSTRUCT-Constants})
      waHeight := height  (resp screen^.height -top  with @{" asScreen " LINK MSTRUCT-Constants})
      waIDCMP  := idcmpFlags
      waFlags  := windowFlags

      Using an own screen:

      waCustomScreen := screen

      Using NIL for the defaul public screen:

      waPubScreen         := default public screen
      waBubScreenFallBack := TRUE

ATTENTION: In opposite to @{" OpenIntWindow " LINK MFCT-OpenIntWindow} OpenIntWindowTags does not
           use the waScreenTitle tag anymore !

See also: @{" CloseIntWindow " LINK MFCT-CloseIntWindow}, @{" Problems with OpenIntWindow " LINK MCHAP-Problems-OpenIntWindow}

@ENDNODE

@NODE MFCT-RedrawGadgets "RedrawGadgets (V38.0)"

Remove all gadgets, calculate them new and redraw them

      PROCEDURE RedrawGadgets(gui{A0}     : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                              setGads{D0} : BOOLEAN) : INTEGER;

All gadgets will be removed and then created totally new using the
new values set by ResizeGadget, NewGadgetFont, NewFontAllGadgets
and NewGadgetText.
If setGads is not set, you can make some changes to the gadget list,
which is required e.g. for genericKind. Then you have to call @{" SetGUI " LINK MFCT-SetGUI}
to make the changes visible. Otherwise RedrawGadgets calls @{" SetGUI " LINK MFCT-SetGUI}.
Notice, this function only works if the @{" guiResizableGads tag " LINK MSTRUCT-GUITags} is set
to the value of TRUE using @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.
The return value is the same as by @{" SetGUI " LINK MFCT-SetGUI}. But notice, if setGads
is FALSE, you get also @{" guiSet " LINK MSTRUCT-Constants} although the GUI isn't set yet.
In addition RedrawGadgets can return @{" rdGUIContextError " LINK MSTRUCT-Constants}.
This means a call to CreateContext failt !
If you don't get @{" guiSet " LINK MSTRUCT-Constants}, it isn't possible to create the GUI anymore.
Exit your program then safely and free the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} !

BUGS

- The RedrawGadgets function of version 38.0 is not able to resize a list-
  view gadget which uses a custom string kind gadget to display the selected
  entry ! Set RedrawGadgets function will usually return an error when
  trying to resize !
  This bug is fixed in version 38.1.
- When resizing a listview gadget with RedrawGadgets always the last entry
  in the list will be always displayed as selected !
  This bug is fixed in version 38.1.
- The contents of entry gadgets will disappear resp set to the default
  when they are resized with RedrawGadgets.
  This is also fixed in version 38.1.

- There is still a problem with RedrawGadgets and listview gadgets. If the
  listview gadget has a custom string gadget to display the contents, and
  the user has first selected an entry, and then changed this in the
  string gadget and now resizes, the contents in the string gadget is set
  to the first choosen entry !

@ENDNODE

@NODE MFCT-RedrawMenu "RedrawMenu (V38.0)"

Remove menu and redraw then it

      PROCEDURE RedrawMenu(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo}) : INTEGER;

First the old menu will be removed and then set again using the old
structure, but perhaps with a new @{" menuFont entry " LINK MSTRUCT-GUIInfo-menuFont} to make the menu fit
to another font or to display the menu with new text perhaps in a
different language.
To achieve this you have to change the according @{" newMenus fields " LINK MSTRUCT-GUIInfo-newMenus}!
The return value is the same as for @{" SetGUI " LINK MFCT-SetGUI} !
Notice, it is not possible to change the menu structure ! In this case
you have to remove the menu and define a new one !

@ENDNODE

@NODE MFCT-RemoveGadgets "RemoveGadgets (V38.0)"

Remove all gadgets

      PROCEDURE RemoveGadgets(gui{A0}   : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                              erase{D0} : BOOLEAN);

The gadgets are still visible, because they are only removed from the
gadget list of the window ! But you can call @{" ClearWindow " LINK MFCT-ClearWindow} to remove
them.
If you set erase to TRUE, the gadgets are removed forever. You can
now define new gadgets using the creating functions.
But if you set it to FALSE it is possible to redraw the gadgets using
@{" SetGUI " LINK MFCT-SetGUI}. But in the meantime you can't create/add new gadgets !
Notice, all information about the old gadgets is gone when set erase to
TRUE !

@ENDNODE

@NODE MFCT-RemoveMenu "RemoveMenu (V38.0)"

Remove the menu

       PROCEDURE RemoveMenu(gui{A0}   : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                            erase{D0} : BOOLEAN);

If you set erase to TRUE the menu is removed completely and the used
memory is freed. Now you can define a totaly new menu and then show
it with @{" SetGUI " LINK MFCT-SetGUI}.
If you set erase to FALSE, the menu is only removed from the window.
You can set it again using @{" SetGUI " LINK MFCT-SetGUI} anytime. But is not allowed to call
@{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} in the meantime to change the menu structure !
Notice, all information about the old menu is gone when set erase to
TRUE !

@ENDNODE

@NODE MFCT-RemOwnFont "RemOwnFont"

Closes a font opened with @{" GetOwnFont " LINK MFCT-GetOwnFont}

      PROCEDURE RemOwnFont(font{A0} : TextFontPtr);

See also: @{" TopazAttr() " LINK MFCT-TopazAttr}, @{" Dealing with fonts " LINK MCHAP-DealingFonts}

@ENDNODE

@NODE MFCT-ResizeGadget "ResizeGadget (V38.0)"

Define new position and size of a gadget

      PROCEDURE ResizeGadget(gui{A0}    : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                             nbr{D0}    : INTEGER;
                             left{D1}   : INTEGER;
                             top{D2}    : INTEGER;
                             width{D3}  : INTEGER;
                             height{D4} : INTEGER);

This change is only visible after a call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets}. If you want
some values not to change use @{" preserve " LINK MSTRUCT-Constants}.

Starting with version 38.1 the @{" gadget field " LINK MSTRUCT-GUIInfo-gadget} contains a pointer to the
changed gadget.

@ENDNODE

@NODE MFCT-SetGUI "SetGUI"

Set gadgets and menu

      PROCEDURE SetGUI(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo}) : INTEGER;

Possible return values:

         @{" guiSet " LINK MSTRUCT-Constants}             Everything alright, go on
         @{" gadgetError " LINK MSTRUCT-Constants}        Error creating the gadgets
         @{" menuError " LINK MSTRUCT-Constants}          Error creating the menu
         @{" memError " LINK MSTRUCT-Constants}           Not enough memory

(*38.0*) @{" gadKeyDefTwice " LINK MSTRUCT-Constants}     Same key equivalent for two gadgets
(*38.0*) @{" menuSetError " LINK MSTRUCT-Constants}       Error calling SetMenuStrip
(*38.0*) @{" menuLayoutError " LINK MSTRUCT-Constants}    Error calling LayoutMenusA
(*38.0*) @{" gadKeyNotAllowed " LINK MSTRUCT-Constants}   Key equivalent is not a letter
(*38.0*) @{" tooManyGadsError " LINK MSTRUCT-Constants}   More gadgets than specified when creating the
                             @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}
(*38.0*) @{" tooManyMenusError " LINK MSTRUCT-Constants}  More menu items than specified when creating
                              the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}
(*38.0*) @{" gadKeyNotFound " LINK MSTRUCT-Constants}     gaUnderscore-Tag exists, but the character
                              is missing in the text and the
                              @{" vanillaKeysNotify flag " LINK MSTRUCT-GUIInfoFlagSet} is set
(*38.0*) @{" noGadToolsGadKind " LINK MSTRUCT-Constants}  The gadget kind is no gadtools gadget
(*38.0*) @{" noGUIToolsGadKind " LINK MSTRUCT-Constants}  The gadget kind is no GUITools gadget

Only if you get @{" guiSet " LINK MSTRUCT-Constants}, you can go on using the GUI, otherwise you can't
use the GUI.
Now calls to the gadget creating functions or @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} have no
effect. If an error occured don't forget to call @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo} !
Don't call SetGUI again. After the GUI is set it is not possible to
add further gadgets or menu items !
Starting with version 38.0 it is allowed to call SetGUI more than one
time, e.g. to install first only a menu and then later when required
some gadgets. For this, first create the menu using @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} and
call SetGUI. Then later create the gadgets and call SetGUI again.

@ENDNODE

@NODE MFCT-SetProcessWindow "SetProcessWindow (V38.0)"

Redirect the requesters

       PROCEDURE SetProcessWindow(window{A0} : WindowPtr) : WindowPtr;

The windowPtr field of the process structure will be set to window and
the old value is returned. You should save the return value to restore
it before exiting your program !

See also: @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}, @{" GUITags " LINK MSTRUCT-GUITags}, @{" Using requesters " LINK MCHAP-UsingRequesters}, @{" SimpleReq " LINK MFCT-SimpleReq},
          @{" ShowRequester " LINK MFCT-ShowRequester}

@ENDNODE

@NODE MFCT-ShowRequester "ShowRequester / ShowRequesterP (V38.0)"

Show a requester

       PROCEDURE ShowRequester(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                               text{A1} : ADDRESS;
                               kind{D0} : LONGCARD;
                               tags{A2} : TagItemPtr) : LONGINT;

         or

       PROCEDURE ShowRequesterP(gui{A0}  : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                                text{A1} : ADDRESS;
                                kind{D0} : LONGCARD;
                                tags{A2} : TagItemPtr);

       text    The requester text. This can be multiple lines divided by
               '\n' !
       kind    @{" requester kind " LINK MSTRUCT-Constants}
       tags    Pointer to a tag list. See @{" SrTags " LINK MSTRUCT-SrTags}

Usually the requester appears on the window specified by the GUIInfo
structure. But it is also possible to set the gui parameter to NIL.
Then the requester will appear on the window specified by the
windowPtr field in the process structure.
In addition you can change the window by using the @{" srReqWindow tag " LINK MSTRUCT-SrTags}.


See also: @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}, @{" Using requesters " LINK MCHAP-UsingRequesters}, @{" SimpleReq " LINK MFCT-SimpleReq}

@ENDNODE

@NODE MFCT-SimpleReq "SimpleReq / SimpleReqP (V38.0)"

Show a requester

       PROCEDURE SimpleReq(text{A0} : ADDRESS;
                           kind{D0} : LONGCARD) : LONGINT;

         or

       PROCEDURE SimpleReqP(text{A0} : ADDRESS;
                            kind{D0} : LONGCARD) : LONGINT;

SimpleReq calls @{" ShowRequester " LINK MFCT-ShowRequester}(NIL, text, kind, NIL) to simplify
handling requesters.

See also: @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}, @{" Using requesters " LINK MCHAP-UsingRequesters}

@ENDNODE

@NODE MFCT-TopazAttr "TopazAttr"

Returns a pointer to a valid TextAttr structure for the topaz/8 font

      PROCEDURE TopazAttr() : TextAttrPtr;

See also: @{" GetOwnFont " LINK MFCT-GetOwnFont}, @{" RemOwnFont " LINK MFCT-RemOwnFont}, @{" Dealing with fonts " LINK MCHAP-DealingFonts}

@ENDNODE

@NODE MFCT-UpdateEGad "UpdateEGad"

Copy the contents of an entry gadget into the variable

      PROCEDURE UpdateEGad(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                           nbr{D0} : INTEGER);

      nbr     the gadget number in the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets}

A notify must be set for this gadget !

See also: @{" UpdateEntryGadgets " LINK MFCT-UpdateEntryGadgets}

@ENDNODE

@NODE MFCT-UpdateEntryGadgets "UpdateEntryGadgets"

Copy the contents all entry gadgets into the variables

      PROCEDURE UpdateEntryGadgets(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

This uses @{" UpdateEGad " LINK MFCT-UpdateEGad} for each entry gadget !
Using this function you can solve the problem when a user makes input
to an entry gadget and then e.g. clicks a button gadget without pressing
RETURN before. In this case intuition doesn't send a gadgetUp message,
so the value of an entry gadget changed without getting any message !
So it is important to verify all entry gadgets when doing any action !
Using this function together with the notify concept, you have nothing
to do, but calling this function when the actual values are required.

See also: @{" UpdateEGad " LINK MFCT-UpdateEGad}

@ENDNODE

@NODE MFCT-VarToGad "VarToGad (V38.0)"

Set the gadget to the value of the belonging variable

      PROCEDURE VarToGad(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo};
                         nbr{D0} : INTEGER);

      nbr    gadget number in the @{"gadgets field " LINK MSTRUCT-GUIInfo-gadgets}

If you set a notify during the creation for this gadget, you can simply
change the value of the corresponding variable and then tell the GUI
by using VarToGad to display it using the appropriate gadget.
GUITools takes the value of the variable and then modifies the gadget.

See also: @{" AllVarsToGad " LINK MFCT-AllVarsToGad}, @{" GUIInfoFlagSet " LINK MSTRUCT-GUIInfoFlagSet}, @{" Creating gadgets " LINK MCHAP-CreatingGadgets}


@ENDNODE

@NODE MFCT-WaitIntMsg "WaitIntMsg"

Wait for an IDCMP message

      PROCEDURE WaitIntMsg(gui{A0} : @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo});

WaitIntMsg waits for an IntuiMessage, replies this and copies it into
the @{" im field " LINK MSTRUCT-GUIInfo-im}. WaitIntMsg uses the @{" port field " LINK MSTRUCT-GUIInfo-port} to get the message.
If the @{" noHandleIntMsgCall " LINK MSTRUCT-GUIInfoFlagSet} flag isn't set, @{" HandleIntMsg " LINK MFCT-HandleIntMsg} will be called
automatically.
Starting with version 38.0 if the @{" internMsgHandling flag " LINK MSTRUCT-GUIInfoFlagSet} is set, it
might be possible that WaitIntMsg handles some events internal without
returning them !
Notice, without a call to @{" HandleIntMsg " LINK MFCT-HandleIntMsg} it is not allowed to use the
extra message information fields of the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}!

See also: @{" GetIntMsg " LINK MFCT-GetIntMsg}

BUGS

- The WaitIntMsg function isn't able to handle several events which will
  appear at the same point of time ! Usually this doesn't happen with
  gadtools, but nevertheless this bug is fixed in version 38.1.

@ENDNODE

@NODE MSTRUCT-GUIInfo "The GUIInfo structure (V38.1)"

In version 38.1 of the guitools.library the GUIInfo structure has the
following entries:

      GUIInfoPtr = POINTER TO GUIInfo;
      GUIInfo = RECORD
        @{" window " LINK MSTRUCT-GUIInfo-window}  : WindowPtr;         (* read only  *)
        @{" screen " LINK MSTRUCT-GUIInfo-screen}  : ScreenPtr;         (* read only  *)
        @{" font " LINK MSTRUCT-GUIInfo-font}    : TextAttr;          (* read/write *)
        @{" visual " LINK MSTRUCT-GUIInfo-visual}  : ADDRESS;           (* read only  *)
        @{" port " LINK MSTRUCT-GUIInfo-port}    : MsgPortPtr;        (* read/write *)
        @{" gadlist " LINK MSTRUCT-GUIInfo-gadlist} : GadgetPtr;         (* read only  *)
(*38.0*)@{" drawinfo " LINK MSTRUCT-GUIInfo-drawinfo}: DrawInfoPtr;       (* read only  *)
        @{" newgad " LINK MSTRUCT-GUIInfo-newgad}  : NewGadget;         (* read/write *)
        @{" actgad " LINK MSTRUCT-GUIInfo-actgad}  : INTEGER;           (* read only  *)
(*38.1*)@{" winIWidth " LINK MSTRUCT-GUIInfo-winISize}: INTEGER;          (* read/write *)
        @{" gadgets " LINK MSTRUCT-GUIInfo-gadgets} : POINTER TO ARRAY[0..255] OF GadgetPtr; (* read only *)

        @{" menus " LINK MSTRUCT-GUIInfo-menus}   : MenuPtr;           (* read only  *)
        @{" actmenu " LINK MSTRUCT-GUIInfo-actmenu} : INTEGER;           (* read only  *)
(*38.1*)@{" winIHeight " LINK MSTRUCT-GUIInfo-winISize}: INTEGER;         (* read/write *)
        @{" newMenus " LINK MSTRUCT-GUIInfo-newMenus}: POINTER TO ARRAY[0..255] OF NewMenu;   (* read/write *)

        @{" im " LINK MSTRUCT-GUIInfo-im}      : IntuiMessage;      (* read only  *)
         CASE : SHORTINT OF
           0 : @{" gadID " LINK MSTRUCT-GUIInfo-gadID}   : INTEGER;    (* read only  *)
               @{" gadget " LINK MSTRUCT-GUIInfo-gadget}  : GadgetPtr;  (* read only  *)
         | 1 : @{" menuNum " LINK MSTRUCT-GUIInfo-MenuNums} : INTEGER;    (* read only  *)
               @{" itemNum " LINK MSTRUCT-GUIInfo-MenuNums} : INTEGER;    (* read only  *)
               @{" subNum " LINK MSTRUCT-GUIInfo-MenuNums}  : INTEGER;    (* read only  *)
         END;
        @{" flags " LINK MSTRUCT-GUIInfo-flags}   : @{" GUIInfoFlagSet "LINK MSTRUCT-GUIInfoFlagSet};  (* read/write *)
         CASE : SHORTINT OF            (* read only  *)
(*38.0*)   0 : @{" cardCode " LINK MSTRUCT-GUIInfo-CodeEntries} : CARDINAL;
(*38.0*) | 1 : @{" intCode " LINK MSTRUCT-GUIInfo-CodeEntries}  : INTEGER;
(*38.0*) | 2 : @{" boolCode " LINK MSTRUCT-GUIInfo-CodeEntries} : BOOLEAN;
               @{" charCode " LINK MSTRUCT-GUIInfo-CodeEntries} : CHAR;
         END;
(*38.0*)@{" gadNbr " LINK MSTRUCT-GUIInfo-gadNbr}    : INTEGER;         (* read only  *)
(*38.0*)@{" menuFont " LINK MSTRUCT-GUIInfo-menuFont}  : TextAttrPtr;     (* read/write *)
         CASE :SHORTINT OF
(*38.0*)   0 : @{" vanKeyHook " LINK MSTRUCT-GUIInfo-vanKeyHook}   : @{" VanKeyFct " LINK MSTRUCT-VanKeyFct};     (* read/write *)
(*38.1*) | 1 : @{" newVanKeyHook " LINK MSTRUCT-GUIInfo-vanKeyHook}: @{" NewVanKeyFct " LINK MSTRUCT-VanKeyFct};  (* read/write *)
         END;
(*38.0*)@{" msgClass " LINK MSTRUCT-GUIInfo-msgClass}  : IDCMPFlagSet;    (* read only  *)
         CASE : SHORTINT OF
(*38.0*)   0 : @{" itemAdr " LINK MSTRUCT-GUIInfo-itemAdr} : MenuItemPtr; (* read only  *)
(*38.0*) | 1 : @{" menuAdr " LINK MSTRUCT-GUIInfo-menuAdr} : NewMenuPtr;  (* read only  *)
         END;
(*38.1*)@{" vanKeyFctData " LINK MSTRUCT-GUIInfo-vanKeyFctData}: ADDRESS;       (* read/write *)
(*38.1*)@{" menuFctData " LINK MSTRUCT-GUIInfo-menuFctData}  : ADDRESS;       (* read/write *)
(*38.1*)@{" userData " LINK MSTRUCT-GUIInfo-userData}     : ADDRESS;       (* read/write *)
(*38.1*)@{" compilerReg " LINK MSTRUCT-GUIInfo-compilerReg}  : ADDRESS;       (* read/write *)
      END;

With "read only" marked entries are (yes believe me) only for reading.
Don't write any data to them !
Please remember that not all entries are available in older versions
of the library. Don't touch these entries under older versions or
make any assumptions about its contents !
Please ever check the version of the library your program is using !

@ENDNODE

@NODE MSTRUCT-GUIInfo-flags "GUIInfo.flags"

Type  : @{" GUIInfoFlagSet " LINK MSTRUCT-GUIInfoFlagSet}

Access: read / write

Value after creation : All flags cleared

With these flags you tell GUITools how to behave when creating gadgets
or menus and when checking intuition messages.
Set them after creating the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} with @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo}
or direct using @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} with the @{" guiFlags tag " LINK MSTRUCT-GUITags}.
It it also allowed to change the flags during the creation of the GUI to
use them only with some gadgets.

@ENDNODE

@NODE MSTRUCT-GUIInfo-screen "GUIInfo.screen"

Type  : ScreenPtr

Access: read only

Value after creation : the screen of the specified window

This is only a pointer to the window's screen for easier handling.

@ENDNODE

@NODE MSTRUCT-GUIInfo-visual "GUIInfo.visual"

Type  : ADDRESS  (VisualInfoPtr)

Access: read only

Value after creation : pointer to the screen's visualinfo

This is a pointer to the screen's visualinfo for easier handling. Some
functions (e.g. for BOOPSI gadgets or images) require this pointer.

@ENDNODE

@NODE MSTRUCT-GUIInfo-drawinfo "GUIInfo.drawinfo"

Type  : DrawInfoPtr

Access: read only

Value after creation : pointer to the screens's drawinfo

Available starting with version 38.0

This points to a copy of the screen's drawinfo structure. This structure
is helpful for BOOPSI gadgets or images or for some drawing routines.

@ENDNODE

@NODE MSTRUCT-GUIInfo-font "GUIInfo.font"

Type  : TextAttr

Access: read / write

Value after creation : Copy of the window's font TextAttr structure

This font is used for the gadgets. To change the font of the gadgets
change this structure or the textattr field in the @{" newgad " LINK MSTRUCT-GUIInfo-newgad}
NewGadget structure.
After the creation the textattr field of the newgad structure pointers
to this structure. If you used @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} you change also
the font for the menu with this structure, because then the
@{" menuFont field " LINK MSTRUCT-GUIInfo-menuFont} points also to this structure !

@ENDNODE

@NODE MSTRUCT-GUIInfo-menuFont "GUIInfo.menuFont"

Type  : TextAttrPtr

Access: read / write

Value after creation : - points to the @{" font field " LINK MSTRUCT-GUIInfo-font} with
                         @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo}
                       - points to the screen's font when using
                         @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}

Available starting with version 38.0

This pointer defines which font is used for the menu. See also the chapter
about the @{" menu font problem" LINK MCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE MSTRUCT-GUIInfo-window "GUIInfo.window"

Type  : WindowPtr

Access: read only

Value after creation : The given window

This is the window which will get the new GUI.

@ENDNODE

@NODE MSTRUCT-GUIInfo-port "GUIInfo.port"

Type  : MsgPortPtr

Access: read / write

Value after creation : window's IDCMP message port

This field points to the window's IDCMP message port. Using this port
all intuition message handling is done. If you change this pointer
indirect e.g. by using ModifyIDCMP, you have to update this field,
either !

@ENDNODE

@NODE MSTRUCT-GUIInfo-newgad "GUIInfo.newgad"

Type  : NewGadget

Access: read / write

Value after creation : A valid NewGadget structure

This structure is needed for the creation of the gadgets. It can be
changed. After creation the textAttr is set to the @{" font field " LINK MSTRUCT-GUIInfo-font} and
the visualInfo is set to the screen's visualinfo.
The most important entries are filled by the gadget creating routines,
(The leftEdge, topEdge, width, height, gadgetText, gadgetId and flags
elements !) but you can overwrite them, although there will probably
no need for it.
If you want another font for one or all gadgets, simply change the
textAttr field.

See also: @{" CreateGadget " LINK MFCT-CreateGadget}, @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull},
          @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget}

@ENDNODE

@NODE MSTRUCT-GUIInfo-actgad "GUIInfo.actgad"

Type  : INTEGER

Access: read only

Value after creation : 0

This field contains the gadget number of the gadget that will be created
next. After a call to @{" SetGUI " LINK MFCT-SetGUI} you find here the amount of gadgets.
NOTICE: The first gadget has the number 0 !

@ENDNODE

@NODE MSTRUCT-GUIInfo-gadgets "GUIInfo.gadgets"

Type  : POINTER TO ARRAY[0..255] OF GadgetPtr

Access: read only

Value after creation : Valid pointer to an array of gadget pointers
                       which are all set to NIL

This field points to an array of gadget pointers. Every field of this
array points to a created gadget in the order of creation. The array
ranges from zero to (@{" actgad " LINK MSTRUCT-GUIInfo-actgad} - 1).

@ENDNODE

@NODE MSTRUCT-GUIInfo-gadlist "GUIInfo.gadlist"

Type  : GadgetPtr

Access: read only

Value after creation : A valid pointer to a initialized gadget list

This field points to the list of the with GUITools created gadgets.
This pointer is only valid during a call to @{" SetGUI " LINK MFCT-SetGUI} and @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}.
Usually you will never need this pointer, perhaps only for refreshing
functions or something where the whole gadget list is needed and
GUITools has no function for.
But notice: This field contains only the gadtools gadgets, but not
GUITools gadgets. This will not change in future, but there will be
more gadget kinds (e.g. BOOPSI gadgets). The consequence is when
you use this entry, e.g. with RemoveGList or AddGList you only work with
the gadtools gadgets. All other kinds of gadgets still remain in the state
they were before !
To avoid any problems, please do not use this entry. Use whenever possible
the functions GUITools provides. (@{" RemoveGadgets " LINK MFCT-RemoveGadgets}, @{" SetGUI " LINK MFCT-SetGUI} etc)

@ENDNODE

@NODE MSTRUCT-GUIInfo-actmenu "GUIInfo.actmenu"

Type  : INTEGER

Access: read only

Value after creation : 0

This field contains the number of the menu item which will be created
next. Remember, the first number is zero !

See also: @{" Creating menus " LINK MCHAP-CreatingMenus}, @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry}, @{" menuAdr field " LINK MSTRUCT-GUIInfo-menuAdr},
          @{" newMenus field " LINK MSTRUCT-GUIInfo-newMenus}

@ENDNODE

@NODE MSTRUCT-GUIInfo-newMenus "GUIInfo.newMenus"

Type  : POINTER TO ARRAY[0..255] OF NewMenu

Access: read / write

Value after creation : A valid pointer to an array of NewMenu
                       structures

If you want to specify more values than is possible using the
@{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} function, then first call MakeMenuEntry
and then add the data using the methods mentioned in the chapter
about @{" Creating menus " LINK MCHAP-CreatingMenus}.

See also: @{" actmenu field " LINK MSTRUCT-GUIInfo-actmenu}, @{" menuAdr field " LINK MSTRUCT-GUIInfo-menuAdr}

@ENDNODE

@NODE MSTRUCT-GUIInfo-menus "GUIInfo.menus"

Type  : MenuPtr

Access: read only

Value after creation : NIL

After a call to @{" SetGUI " LINK MFCT-SetGUI} this field contains a pointer to the
new menu.

@ENDNODE

@NODE MSTRUCT-GUIInfo-im "GUIInfo.im"

Type  : IntuiMessage

Access: read only

Value after creation : A valid IntuiMessage structure

If you call @{" GetIntMsg " LINK MFCT-GetIntMsg} or @{" WaitIntMsg " LINK MFCT-WaitIntMsg} the received
IntuiMessage is copied into this field.

@ENDNODE

@NODE MSTRUCT-GUIInfo-msgClass "GUIInfo.msgClass"

Type  : IDCMPFlagSet

Access: read only

Value after creation : IDCMPFlagSet{}

Available starting with version 38.0

Usually this field contains a copy of the class field of the @{" im field " LINK MSTRUCT-GUIInfo-im}.

See also: @{" HandleIntMsg " LINK MFCT-HandleIntMsg}

@ENDNODE

@NODE MSTRUCT-GUIInfo-gadID "GUIInfo.gadID"

Type  : INTEGER

Access: read only

Value after creation : 0

If a message for gadgets arrives this field contains the gadgets ID.

@ENDNODE

@NODE MSTRUCT-GUIInfo-gadget "GUIInfo.gadget"

Type  : GadgetPtr

Access: read only

Value after creation : NIL

If a message for gadgets arrives this field points to the event
gadget.
Starting with V38.0 this pointer contains the address of the
just created gadget after called a gadget creating function.

@ENDNODE

@NODE MSTRUCT-GUIInfo-MenuNums "GUIInfo.menuNum / GUIInfo.itemNum / GUIInfo.subNum"

Type  : INTEGER

Access: read only

Value after creation : 0

When a menuPick or beginning with V38.0 a menuHelp message arrives
these fields contain then appropriate numbers of the chosen menu.

@ENDNODE

@NODE MSTRUCT-GUIInfo-CodeEntries "GUIInfo.cardCode / GUIInfo.intCode / GUIInfo.boolCode / GUIInfo.charCode"

Type : cardCode : CARDINAL
       intCode  : INTEGER
       boolCode : BOOLEAN
       charCode : CHAR

Access: read only

Value after creation : 0 resp FALSE resp 0C

Available starting with version 38.0

These fields contain usually a copy of the code field of the @{" im field " LINK MSTRUCT-GUIInfo-im}.
Using this field it might be much easier to handle the code.

See also: @{" HandleIntMsg " LINK MFCT-HandleIntMsg}

@ENDNODE

@NODE MSTRUCT-GUIInfo-gadNbr "GUIInfo.gadNbr"

Type  : INTEGER

Access: read only

Value after creation : 0

Available starting with version 38.0

This field contains the gadget number of the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets}
when a gadget message arrived. So it is much easier to handle the gadget,
when the gadget's ID and number are not the same !

@ENDNODE

@NODE MSTRUCT-GUIInfo-itemAdr "GUIInfo.itemAdr"

Type  : MenuItemPtr

Access: read only

Value after creation : NIL

Available starting with version 38.0

This field points to the menu item which was selected within the
arrived menuPick resp menuHelp message.

@ENDNODE

@NODE MSTRUCT-GUIInfo-menuAdr "GUIInfo.menuAdr"

Type  : NewMenuPtr

Access: read only

Value after creation : NIL

Available starting with version 38.0

After a call to @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} this field points to the appropriate
NewMenu structure.

See also: @{" Creating menus " LINK MCHAP-CreatingMenus}, @{" actmenu field " LINK MSTRUCT-GUIInfo-actmenu}, @{" newMenus field " LINK MSTRUCT-GUIInfo-newMenus}

@ENDNODE

@NODE MSTRUCT-GUIInfo-vanKeyHook "GUIInfo.vanKeyHook / GUIInfo.newVanKeyHook"

Type  : @{" VanKeyFct " LINK MSTRUCT-VanKeyFct} / @{" NewVanKeyFct " LINK MSTRUCT-NewVanKeyFct}

Access: read / write

Value after creation : NIL

Available starting with version 38.0

This is the @{" VanKeyFct " LINK MSTRUCT-VanKeyFct}  @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg} uses for user defined
@{" key equivalents " LINK MCHAP-KeyEquivalents}.
Starting with version 38.1 this can also be a @{" NewVanKeyFct " LINK MSTRUCT-VanKeyFct}.

@ENDNODE

@NODE MSTRUCT-GUIInfo-vanKeyFctData "GUIInfo.vanKeyFctData"

Type  : ADDRESS

Access: read / write

Value after creation : pointer to the GUIInfo structure

Available starting with version 38.1

When the @{" NewVanKeyFct " LINK MSTRUCT-VanKeyFct} is called this pointer will arrive in A2.
This pointer can be set during creation using the @{" guiVanKeyFctData tag " LINK MSTRUCT-GUITags}.

See also: @{" Key equivalents " LINK MCHAP-KeyEquivalents}

@ENDNODE

@NODE MSTRUCT-GUIInfo-menuFctData "GUIInfo.menuFctData"

Type  : ADDRESS

Access: read / write

Value after creation : pointer to the GUIInfo structure

Available starting with version 38.1

This pointer is passed in A0, when a @{" NewMenuFct " LINK MSTRUCT-MenuFct} is used to call the
menu functions.
This pointer can be set during creation using the @{" guiMenuFctData tag " LINK MSTRUCT-GUITags}.

See also: @{" Creating menus " LINK MCHAP-CreatingMenus}

@ENDNODE

@NODE MSTRUCT-GUIInfo-userData "GUIInfo.userData"

Type  : ADDRESS

Access: read / write

Value after creation : NIL

Available starting with version 38.1

This pointer can be used for special user data. This use is left to the
applications.
This pointer can be set during creation using the @{" guiUserData tag " LINK MSTRUCT-GUITags}.

@ENDNODE

@NODE MSTRUCT-GUIInfo-compilerReg "GUIInfo.compilerReg"

Type  : ADDRESS

Access: read / write

Value after creation : NIL

Available starting with version 38.1

This pointer can be used for the hook functions to set the global data
register for the compiler.
When a hook function is called, it is mostly required to set the
global data register (the majority of compilers use A4 for this).
The compilers offer different functions for this problem. But using
this the code can't be reentrant !
To achieve this you can pass the GUIInfo structure to the hook
function as user data and then set the global data register to this
pointer. But don't forget to save the old value of the global data
register !

This pointer can be set during creation using the @{" guiCompilerReg tag " LINK MSTRUCT-GUITags}.

@ENDNODE

@NODE MSTRUCT-GUIInfo-winISize "GUIInfo.winIWidth / GUIInfo.winIHeight"

Type  : INTEGER

Access: read / write

Value after creation : window inner width and window inner height

Available starting with version 38.1

GUITools uses these values for @{" resizable gadgets " LINK MCHAP-ResizableGadgets} inside the @{" DoResizing " LINK MFCT-DoResizing}
function !

@ENDNODE

@NODE MSTRUCT-GUIInfoFlagSet "GUIInfoFlagSet / GUIInfoFlags"

  GUIInfoFlags = (stringNotify, integerNotify, linkEntryGads,
                  cycleEntryGads, activateFirstEGad, cycleNotify,
                  checkboxNotify, autoUpdateEGads, mxNotify,
                  vanillaKeysNotify, convertKeys, noHandleIntMsgCall,
                  sliderNotify, scrollerNotify, listviewNotify,
                  internMsgHandling, lvKeyClearTime, allowAllVanillaKeys,
                  addBorderDims, callVanillaKeyFct, callMenuData,
                  doRefresh, addStdUnderscore, paletteNotify,
                  doResizing);

  GUIInfoFlagSet = SET OF GUIInfoFlags;  (* 32 Bits ! *)


Complete descriptions of all flags:

         stringNotify        : When creating a stringKind gadget,
                               the gtstString tag contains a pointer
                               to a string variable. GUITools keeps
                               in mind this pointer and can copy
                               automatically an entered string to
                               this variable.

         integerNotify       : Does the same as stringNotify only for
                               integerKind gadgets and gtinNumber now
                               contains a pointer to a LONGINT
                               variable.

         cycleNotify         : When creating a cycleKind gadget the
                               gtcyActive gadget must contain the
                               address of a CARDINAL variable.
                               If now the cycleKind gadget is hit,
                               the variable will get automatically
                               the state of the gadget.

         mxNotify            : Does the same for mxKind gadgets as
                               cycleNotify, but now the gtmxActive
                               tag must contain the address.

         checkboxNotify      : Does the same for checkboxKind gadgets
                               as cycleNotify, but now the gtcbChecked
                               tag must contain the address of a
                               BOOLEAN variable !

(*38.0*) sliderNotify        : Does the same for sliderKind gadgets
                               as cycleNotify, but now the gtslLevel
                               tag must contain the Address of an
                               INTEGER variable.

(*38.0*) scrollerNotify      : Does the same for scrollerKind gadgets
                               as cycleNotify, but now the gtscTop
                               tag must contain the Address of an
                               INTEGER variable.

(*38.0*) listviewNotify      : Does the same for listviewKind gadgets
                               as cycleNotify, but now the gtlvSelected
                               tag must contain the Address of an
                               CARDINAL variable.

(*38.0*) paletteNotify       : Does the same for paletteKind gadgets
                               as cycleNotify, but now the gtpaColor
                               tag must contain the Address of an
                               CARDINAL variable.

         linkEntryGads       : If the user leaves an entry gadget
                               pressing RETURN, the next entry gadget
                               will be activated. This flag is only
                               valid during the gadget creation.

         cycleEntryGads      : If the user leaves the last entry
                               gadget and linkEntryGads is set, the
                               first entry gadget will be activated.
                               This flag is only valid during the
                               gadget creation.

         activateFirstEGad   : Activates the first entry gadget after
                               the creation of the GUI with @{" SetGUI " LINK MFCT-SetGUI}.

         autoUpdateEGads     : If the user presses RETURN in an entry
                               gadget, the new value will be copied in
                               the variable which was specified using
                               stringNotify resp integerNotify. This
                               is only interesting while checking gadgets
                               and works only together with stringNotify
                               and integerNotify.

(*38.0*) addStdUnderscore    : Adds to the gadgets taglist automatically
                               the gtUnderscore tag with data of '_'.
                               So you don't have to specify this. This
                               is very useful with buttonKind gadgets
                               which usually have no other tags.

(*38.0*) vanillaKeysNotify   : During the creation of a gadget GUITools
                               checks, if a key equivalent exists for
                               this gadget and then keeps it in mind.

(*38.0*) allowAllVanillaKeys : Usually GUITools can only handle key
                               equivalents which are letters. If you
                               want to have alternative ones, e.g.
                               numbers or the function keys, @{" SetGUI " LINK MFCT-SetGUI}
                               will return an error !
                               If you set this flag GUITools will
                               ignore them and you must handle these
                               ones, e.g. using callVanillaKeyFct.

(*38.0*) callVanillaKeyFct   : If this flag is set GUITools calls the
                               @{" VanKeyFct " LINK MSTRUCT-VanKeyFct} found in the @{" vanKeyHook field " LINK MSTRUCT-GUIInfo-vanKeyHook}
                               if the user presses a vanilla key.
                               See @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg}

(*38.0*) convertKeys         : If vanillaKeysNotify is set, the IDCMP
                               message from a vanilla key is automatical-
                               ly converted into a gadget message. This
                               flag is only valid during the checking of
                               IDCMP message.

(*38.0*) noHandleIntMsgCall  : Disables the call of @{" HandleIntMsg " LINK MFCT-HandleIntMsg} from
                               @{" WaitIntMsg " LINK MFCT-WaitIntMsg} resp @{" GetIntMsg " LINK MFCT-GetIntMsg}. This flag is
                               only valid during the checking of the GUI.

(*38.0*) internMsgHandling   : All IDCMP messages which can be handled
                               by GUITools itself will be handled
                               internal. This message will then never
                               arrive at the application ! This flag is
                               only valid during the creation of the GUI.

(*38.0*) lvKeyClearTime      : If the key equivalent for a listview
                               kind gadget was hit, the seks field of
                               the IntuiMessage is set to zero to avoid
                               any trouble checking for double clicks.
                               This flag is only valid during creation.

(*38.0*) callMenuData        : When a menuPick message arrives, GUITools
                               calls the function which is specified
                               using the userData field of the menu item.
                               This is done by @{" HandleIntMsg " LINK MFCT-HandleIntMsg}.

(*38.0*) doRefresh           : @{" HandleIntMsg " LINK MFCT-HandleIntmsg} automatically calls
                               @{" BeginRefresh " LINK MFCT-BeginRefresh} followed by @{" EndRefresh " LINK MFCT-EndRefresh}
                               when a refreshWindow message arrives.

(*38.0*) addBorderDims       : During the creation of a gadget the leftEdge
                               will be incremented by window^.borderLeft
                               and the topEdge by window^.borderTop.
                               Due to this the gadgets are always inside
                               the window regardless of the window's font.

(*38.1*) doResizing          : @{" DoResizing " LINK MFCT-DoResizing} and @{" RedrawGadgets " LINK MFCT-RedrawGadgets} are
                               automatically called by @{" HandleIntMsg " LINK MFCT-HandleIntMsg} when
                               a newSize message arrives.
                               For this the @{" guiResizableGads tag " LINK MSTRUCT-GUITags}
                               must set !

@ENDNODE

@NODE MSTRUCT-GUIGadgetInfo "GUIGadgetInfo (V38.0)"

GUIGadgetInfoPtr = POINTER TO GUIGadgetInfo;

GUIGadgetInfo = RECORD
    userData : ADDRESS;
    kind     : LONGCARD;
END;

GUITools uses the userData field of each gadget to store some extra
information which are very important for GUITools to work.
GUITools sets the userData field to this structure.

userData   a pointer to your own user data
kind       the gadget kind

See also: @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MSTRUCT-VanKeyFct "VanKeyFct - The vanilla key hook function / NewVanKeyFct"

    VanKeyFct = PROCEDURE( CHAR{D0}, ADDRESS{A0}, ADDRESS{A1}) : BOOLEAN;

This function is for alternative @{" key equivalents " LINK MCHAP-KeyEquivalents}. It returns for a key
the belonging gadget number.

The function gets in D0 the character. If this character belongs to a
gadget, the function puts in the INTEGER variable, A0 points to, the
number of the gadget and in the INTEGER variable, A1 points to, if the
key should be treated as a shifted key. Use 1 for yes and 0 for no.
Then you must return TRUE, otherwise if the key does not belong to
any gadget just return 0.

With this function you can give every key a belonging gadget and then
you don't have to worry, if the key was pressed or if the gadget was
activated using the mouse, because GUITools always sends gadget
messages and no key messages using @{" ConvKMsgToGMsg " LINK MFCT-ConvKMsgToGMsg}.

This hook function is only available when running under version 38.0 or
above !

Beginning with version 38.1 it is also possible to use the NewVanKeyFct
to achieve this. This function does the same as the VanKeyFct, but it
also gets in A2 a pointer to user defined data. This pointer can be
specified using the @{" vanKeyFctData field " LINK MSTRUCT-GUIInfo-vanKeyFctData}.

    NewVanKeyFct = PROCEDURE( CHAR{D0}, ADDRESS{A0},
                              ADDRESS{A1}, ADDRESS{A2}) : BOOLEAN;

Internal GUITools V38.1 calls always a NewVanKeyFct, so it is left to
the user to use the additional register or not.

@ENDNODE

@NODE MSTRUCT-MenuFct "MenuFct / NewMenuFct "

    MenuFct = PROCEDURE() : BOOLEAN;

This function is available starting with function. It is called
whenever a menuPick message arrives and the @{" callMenuData flag " LINK MSTRUCT-GUIInfoFlagSet} is
set and the userData field of this menu item contains a pointer
to this function.
If you want to wait for the next message, return TRUE, otherwise
return FALSE to end the message loop.
Starting with version 38.1 you can use also this definiton:

    NewMenuFct   = PROCEDURE(ADDRESS{A2}) : BOOLEAN;

This function does the same, but it also get a pointer to some user
defined data in A0 which can be set using the @{" menuFctData field " LINK MSTRUCT-GUIInfo-menuFctData}.

Internal GUITools V38.1 calls always a NewMenuFct, so it is left to the
user to use the additional register or not.

See also: @{" Creating menus " LINK MCHAP-CreatingMenus}, @{" HandleIntMsg " LINK MFCT-HandleIntMsg}

@ENDNODE

@NODE MSTRUCT-GUITags "GuiTags"

You can specify these tags with @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.
All tags require at least version 38.0, the same does @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.

  GuiTags=(guiDummy:=tagUser+015000H,
           guiResizableGads, guiFlags, guiGadFont, guiMenuFont,
           guiVanKeyFct, guiCreateError, guiSetProcessWindow,
           guiRestoreProcessWindow, guiRefreshWindowFrame,
           guiVanKeyFctData, guiMenuFctData, guiUserData,
           guiCompilerReg, guiUseGadDesc);


Tags for @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} V38.0
--------------------------------

 guiCreateError   : (POINTER TO LONGINT, set to NIL)
                    This is a pointer to a LONGINT which will contain the
                    error on return if @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} returns NIL.

                    Possile error codes:

                      @{" cgiNoError " LINK MSTRUCT-constants}       No error, CreateGUIinfoTags has
                                         done its work, the result
                                         wasn't NIL , so go on !
                      @{" cgiNoWindow " LINK MSTRUCT-constants}      window pointer was NIL
                      @{" cgiNoVisualInfo " LINK MSTRUCT-constants}  Unable to create the VisualInfo
                      @{" cgiNoMemory " LINK MSTRUCT-constants}      Not enough memory
                      @{" cgiNoDrawInfo " LINK MSTRUCT-constants}    Unable to create DrawInfo
                      @{" cgiCreateContext " LINK MSTRUCT-constants} The call to CreateContext failt


  guiFlags         : (@{" GUIInfoFlagSet " LINK MSTRUCT-GUIInfoFlagSet}, set to GUIInfoFlagSet{})
                     With this tag you can set all the flags you want,
                     the setting will be copied into the @{" flags field " LINK MSTRUCT-GUIInfo-flags}.

  guiGadFont       : (TextAttrPtr, set to window's font)
                     With this tag you can choose the gadgets's font.
                     This font will be placed in the textAttr field
                     of @{" newgad " LINK MSTRUCT-GUIInfo-newgad} NewGadget structure.

  guiMenuFont      : (TextAttrPtr, set to screen's font)
                     With this tag you can choose the font for the menu.
                     This font will be placed in the @{" menuFont field " LINK MSTRUCT-GUIInfo-menuFont}.

  guiVanKeyFct     : (@{" VanKeyFct " LINK MSTRUCT-VanKeyFct}, set to NIL)
                     The @{" vanKeyHook field " LINK MSTRUCT-GUIInfo-vanKeyHook} will be filled with this hook
                     function for alternative @{" key equivalents " LINK MCHAP-KeyEquivalents}.

  guiResizableGads : (boolean tag, set to FALSE)
                     If this tag is set to TRUE, GUITools will notify
                     the appearance, size and position of all gadgets.
                     In this way GUITools is able to resize gadgets.
                     Because the notify of the appearance requires
                     some resources, this flag is usually turned off.
                     Set it only, if necessary !

  guiRefreshWindowFrame  : (boolean tag, set to guiResizableGads)
                           If you use this tag AFTER the guiResizableGads
                           tag, you can change its value.
                           If this flag is set, the window frame will be
                           refreshed using RefreshWindowFrams of the
                           intuition.library, either, when @{" EndRefresh " LINK MFCT-EndRefresh}
                           is called.

  guiSetProcessWindow     : (boolean tag, set to FALSE)
                            If this flag is set to TRUE, the windowPtr
                            field of the process structure is set to
                            the window.

  guiRestoreProcessWindow : (boolean tag, set to FALSE)

                            If this flag is set to TRUE, the windowPtr
                            field of the process structure will be
                            restored when @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo} is
                            called. This means the field is set to the
                            value it had before the call to
                            @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.

Additional Tags for @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} V38.1
-------------------------------------------

  guiVanKeyFctData        : (address, set to gui)
                            This pointer will be saved in the
                            @{" vanKeyFctData field " LINK MSTRUCT-GUIInfo-vanKeyFctData}. It is for use with the
                            @{" NewVanKeyFct " LINK MSTRUCT-VanKeyFct}.
                            See also: @{" Key equivalents " LINK MCHAP-KeyEquivalents}

  guiMenuFctData          : (address, set to gui)
                            This pointer will be saved in the
                            @{" menuFctData field " LINK MSTRUCT-GUIInfo-menuFctData}. It is for use with the
                            @{" NewMenuFct " LINK MSTRUCT-MenuFct}.
                            See also: @{" Creating menus " LINK MCHAP-CreatingMenus}

  guiUserData             : (address, set to NIL)
                            Value for the @{" userData field " LINK MSTRUCT-GUIInfo-userData}.

  guiCompilerReg          : (address, set to NIL)
                            Value for the @{" compilerReg field " LINK MSTRUCT-GUIInfo-compilerReg}.

  guiUseGadDesc           : (boolean tag, set to FALSE)
                            If set to TRUE, GUITools uses now the gadget
                            description flags for their sizes and positions
                            when creating and resizing them !
                            Usually this description flags are used to
                            resize the GUI, so for this use also the
                            guiResizableGads tag !
                            See also: @{" Resizable gadgets " LINK MCHAP-ResizableGadgets}

@ENDNODE

@NODE MSTRUCT-SgTags "SgTags"

Starting with version 38.0 you can use these tags to specify GUITools
gadgets and starting with version 38.1 you can use them for every
gadget kind.

  SgTags=(sgDummy:=tagUser+016000H,
          sgGadgetText, sgGadgetFlags,
          sgpiMaxValue, sgpiCurrentValue, sgbbRecessed,
          sgGadgetFont, sgGadgetID, sgVisualInfo, sgUserData,
          sgGadgetDesc, sgGadgetObjects);

Tags for V38.0
--------------

  sgGadgetText  : (ADDRESS, set to NIL)
                  Using this tag you can specify the gadget's text.

  sgGadgetFlags : (NewGadgetFlagSet)
                  With this tag you set the flags for the gadget. If
                  you don't use this tag the flags of the last created
                  gadget will be used also for this gadget.

  sgpiMaxValue  : (CARDINAL, set to 100)
                  The maximum value of a @{" progressIndicatorKind " LINK MSTRUCT-Constants}.

  sgpiCurrentValue : (CARDINAL, set to 0)
                     The current value of a @{" progressIndicatorKind " LINK MSTRUCT-Constants}.

  sgbbRecessed : (boolean tag, set to FALSE)
                 Should the bevelled box be recessed or not.


Tags for V38.1
--------------

  sgGadgetFont : (TextAttrPtr)
                 This sets the textAttr field of the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad}.
                 All gadgets which are from now one created use this new
                 font unless another is defined.

  sgGadgetID   : (CARDINAL)
                 This gives a new ID to the gadget. The next gadget will
                 get this ID plus one and so on. Usually GUITools gives
                 the first gadget the ID 0, the second the ID 1 and so
                 on.

  sgVisualInfo : (ADDRESS)
                 Set the visualInfo field of the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad}.
                 Usually this tag is not of any use. But for complete-
                 ness it is specified if you want to use another Visual-
                 Info than that of the used screen !

  sgUserData   : (ADDRESS)
                 Set the userData field of the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad}.
                 This sets the userData field of the @{" GUIGadgetInfo " LINK MSTRUCT-GUIGadgetInfo}
                 structure which is stored in the userData field of
                 the created gadget.

  sgGadgetDesc : (LONGCARD)
                 This gadget description flag is only for use with the
                 resizable gadget function if the @{" guiUseGadDesc tag " LINK MSTRUCT-GUITags} is
                 set.
                 See chapter @{" Resizable gadgets " LINK MCHAP-ResizableGadgets} for more information

  sgGadgetObjects : (LONGCARD)
                 This gadget description flag is only for use with the
                 resizable gadget function if the @{" guiUseGadDesc tag " LINK MSTRUCT-GUITags} is
                 set.
                 See chapter @{" Resizable gadgets " LINK MCHAP-ResizableGadgets} for more information

See also: @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

@ENDNODE

@NODE MSTRUCT-SrTags "SrTags"

Starting with version 38.0 you can use these tags to descripe your
own requesters.

  SrTags=(srDummy:=tagUser+017000H,
          srGadgets, srArgs, srFlags, srTitle, srIDCMP, srReqWindow,
          srAslPattern, srAslNameBuffer, srAslFileBuffer, srAslDirBuffer,
          srAslSave);

Don't use the flags which are for the asl requester of version 38.1
for other @{" requester kinds " LINK MSTRUCT-Constants} and vice versa !

  srGadgets      Pointer to gadgets' texts which are separated by '|'.
                 This pointer is only required for your own
                 requester kind or to localize the requester.
                 This flag is unused for asl requesters.
  srArgs         Pointer to an array of argument pointers if required
                 This flag is ignored by asl requesters.
  srTitle        Pointer to the title string. Usually this pointer is
                 NIL, so the requester gets the title of the reference
                 window.
                 Using asl requesters this flag has the same meaning
                 as the requester text !
  srIDCMP        Pointer to an IDCMPFlagSet. If you are specifying
                 this the requester will disappear if one of these
                 events occur. Then the requester function will
                 return -1 and the IDCMPFlagSet this tag points to
                 contains the event !
                 This flag is unused by asl requesters by now.
  srReqWindow    Using this flag you can specify the window the requester
                 should appear one.

Starting with version 38.1 you can also use these tags which are
currently only for the asl.library requesters:

  srAslPattern     a pointer to a pattern

  srAslNameBuffer  pointer to a buffer to save the full file name
                   Don't use this tag together with srAslFileBuffer
                   or srAslDirBuffer

  srAslFileBuffer  pointer to a buffer to save only the file name
                   Don't use this tag together with srAslNameBuffer,
                   but it is advised to use srAslDirBuffer together
                   with it.

  srAslDirBuffer   pointer to a buffer to save only the path
                   Don't use this tag together with srAslNameBuffer,
                   but it is advised to use srAslFileBuffer together
                   with it.

  srAslSave        (boolean tag, set to FALSE)
                   save requester or not

See also: @{" Using requesters " LINK MCHAP-UsingRequesters}

@ENDNODE

@NODE MSTRUCT-Constants "Constants"

Result from @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} in @{" guiCreateError " LINK MSTRUCT-GUITags}

(*38.0*)   cgiNoError        = 0;
(*38.0*)   cgiNoWindow       = 1;
(*38.0*)   cgiNoVisualInfo   = 2;
(*38.0*)   cgiNoMemory       = 3;
(*38.0*)   cgiNoDrawInfo     = 4;
(*38.0*)   cgiCreateContext  = 5;


Result from @{" SetGUI " LINK MFCT-SetGUI} and @{" RedrawGadgets " LINK MFCT-RedrawGadgets}

           guiSet       = 0;
           gadgetError  = 1;
           menuError    = 2;
           memError     = 3;
(*38.0*)   gadKeyDefTwice     =  4;
(*38.0*)   menuSetError       =  5;
(*38.0*)   menuLayoutError    =  6;
(*38.0*)   gadKeyNotAllowed   =  7;
(*38.0*)   tooManyGadsError   =  8;
(*38.0*)   tooManyMenusError  =  9;
(*38.0*)   gadKeyNotFound     = 10;
(*38.0*)   noGadToolsGadKind  = 11;
(*38.0*)   noGUIToolsGadKind  = 12;
(*38.0*)   rdGUIContextError  = 13;


Value for @{" OpenIntWindow " LINK MFCT-OpenIntWindow} and @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags} width and height

           asScreen    = -1;


Value for @{" ResizeGadget " LINK MFCT-ResizeGadget}

(*38.0*)   preserve    = -1;


Predefined displayIDs for @{" OpenIntScreen " LINK MFCT-OpenIntScreen} and @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}

           hiresPalID  = hiresKey + palMonitorID;
           hiresID     = hiresKey + defaultMonitorID;
           loresPalID  = loresKey + palMonitorID;
           loresID     = loresKey + defaultMonitorID;


Values for @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} and @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}

(*38.0*)   noGadgets  = 0;
(*38.0*)   noMenu     = 0;


Gadget kinds for @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget}

(*38.0*)   guiToolsKinds          = 65535;
(*38.0*)   progressIndicatorKind  = 65536;
(*38.0*)   bevelboxKind           = 65537;

Beginning with version 38.1 these kinds can also be used with all other
gadget creating functions !


Requester kinds for @{" ShowRequester " LINK MFCT-ShowRequester} and @{" SimpleReq " LINK MFCT-SimpleReq}

(*38.0*)   generalReqKind  = 0;
(*38.0*)   okReqKind       = 1;
(*38.0*)   doitReqKind     = 2;
(*38.0*)   yncReqKind      = 3;
(*38.1*)   fileReqKind     = 4;
(*38.1*)   dirReqKind      = 5;


Results from @{" ShowRequester " LINK MFCT-ShowRequester}

(*38.0*)   reqYes        = 1;
(*38.0*)   reqNo         = 2;
(*38.0*)   reqCancel     = 0;
(*38.0*)   reqOK         = 0;
(*38.0*)   reqDo         = 1;
(*38.0*)   reqLeave      = 0;
(*38.1*)   reqAslCancel  = 0;
(*38.1*)   reqAslOK      = 1;

gadget size and position description flags for the @{" sgGadgetDesc tag " LINK MSTRUCT-SgTags}

(*38.1*)   distNorm    = 0;
(*38.1*)   distAbs     = 1;
(*38.1*)   distRel     = 2;
(*38.1*)   distPercent = 3;

(*38.1*)   objBorder= 0;
(*38.1*)   objGadget= 4;

(*38.1*)   objRight  = 0;
(*38.1*)   objBottom = 0;
(*38.1*)   objLeft   = 32;
(*38.1*)   objTop    = 32;

(*38.1*)   shiftLeft   = 256*256*256;
(*38.1*)   shiftTop    = 256*256;
(*38.1*)   shiftWidth  = 256;
(*38.1*)   shiftHeight = 1;

@ENDNODE

@NODE MCHAP-2 "Working with GUITools"

These chapters contain some additional information about GUITools. They
give hints and some interesting tips how to use GUITools.

   @{" Guidelines " LINK MCHAP-Guidelines}

   @{" Freeing resources (V38.0)" LINK MCHAP-FreeingResources}

   @{" Creating gadgets " LINK MCHAP-CreatingGadgets}

   @{" Creating menus " LINK MCHAP-CreatingMenus}

   @{" Dealing with fonts " LINK MCHAP-DealingFonts}

   @{" Key equivalents (V38.0)" LINK MCHAP-KeyEquivalents}

   @{" Resizable gadgets (V38.0)" LINK MCHAP-ResizableGadgets}

   @{" Using requesters (V38.0)" LINK MCHAP-UsingRequesters}

@ENDNODE

@NODE MCHAP-Guidelines "Guidelines"

The @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} which nearly all procedures require, contains
all important data.
Furthermore, the real structure contains a lot of hidden data at the end,
so create this structure only with @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} or under at least
version 38.0 with @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} and NEVER by hand.
In further versions this structure will contain additional data.
Set only the flags which are commented, set all others to zero for upward
compatibility.

Even if a call to @{" SetGUI " LINK MFCT-SetGUI} wasn't successful, you must ALWAYS use
@{" FreeGUIInfo " LINK MFCT-FreeGUIInfo} to free the structure.

Don't use any functions of the gadtools.library together with GUITools !
GUITools replaces the whole gadtools.library (except the message filter
functions and the GTGetGadgetAttrsA function of version 39), so there is
no need to use gadtools.library ! (It is possible to use the message
filter functions together with GUITools, if you use them carefully !)

ATTENTION: Except @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}, no procedure which get a @{" GUIInfoPtr " LINK MSTRUCT-GUIInfo}
           does a NIL check. You must check this after the call to
           @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} resp @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.
           Furthermore, there is no range checking in functions which get
           a gadget number (like @{" ModifyGadget " LINK MFCT-ModifyGadget} or @{" GadgetStatus " LINK MFCT-GadgetStatus}) !

GUITools uses for some internal functions and values the userData
entry of the gadgets. This means you can't use it to store some
own gadget specific data in this field or some VERY STRANGE THINGS
will happen. (Usually then nothing more will happen, because the
computer has hung itself !)
But don't worry you stil have the possibility to store own user
data. See the chapter @{" Creating gadgets " LINK MCHAP-CreatingGadgets}.

Although it is possible to give the IDs you want to the gadgets, it
makes a lot more sense to give this IDs in the usual orders. This
means the first gadget gets the ID 0, the second the ID 1 and so on.
Because some functions for manipulation gadgets expect as an
argument not the ID but the gadget number (e.g @{" ModifyGadget " LINK MFCT-ModifyGadget}
or @{" GadgetStatus " LINK MFCT-GadgetStatus}.)
If these figures don't correspond, you have to convert these numbers
by hand. Starting with version 38.0 you don't only get the gadget ID
but the gadget number, so this conversion can be neglected.

If you demand something (screens, windows, fonts etc) with GUITools you
have to free it with GUITools again !

@ENDNODE

@NODE MCHAP-FreeingResources "Freeing resources (V38.0)"

In generall you have to free everything with GUITools you demanded with
GUITools.
But there are two little useful exceptions:

 1. If you requested a window using @{" OpenIntWindow " LINK MFCT-OpenIntWindow} resp
    @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags} it is sufficient to call @{" CloseIntWindow " LINK MFCT-CloseIntWindow}.
    You don't need a call to @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo}.

 2. If you opened a screen using @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags} resp
    @{" OpenIntScreen" LINK MFCT-OpenIntScreen} it is sufficient to call @{" CloseIntScreen " LINK MFCT-CloseIntScreen}.
    All not yet closed windows will be closed using @{" CloseIntWindow " LINK MFCT-CloseIntWindow}.

Due to this, you don't need when exiting to check if all of the opening
was succesful or not. You only have to check if the screen resp the
window, when no own screen is used, is open and then close it.

@ENDNODE

@NODE MCHAP-CreatingGadgets "Creating gadgets"

Gadget creating functions
-------------------------

To create a gadget GUITools uses the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad}. When creating a
gadget you must specify its size and position. These values will be
saved in the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad} and then the gadget will be created using this
structure.
Due to this it is possible to change some attributes of the gadgets
although GUITools has no function or tag to change these values. This
can be simply done by changing the @{" newgad structure " LINK MSTRUCT-GUIInfo-newgad} ! (E.g. to add own
userData, to use another font etc)
Beginning with version 38.1 it is possible to change all fields of this
structure using the @{" SgTags " LINK MSTRUCT-SgTags}.
The gadget creating functions behave different under the different
releases of GUITools:
V37.3: Use @{" CreateGadget " LINK MFCT-CreateGadget}, @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull} to create
       gadtools gadgets
V38.0: Use @{" CreateGadget " LINK MFCT-CreateGadget}, @{" CreateGadgetText " LINK MFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK MFCT-CreateGadgetFull} to create
       gadtools gadgets and @{" CreateSpecialGadget " LINK MFCT-CreateSpecialGadget} to create GUITools
       gadgets
V38.1: Use any of the functions to create gadtools or GUITools gadgets.
       In addition you can also use @{" CreateGadgetNew " LINK MFCT-CreateGadgetNew}.
       It is advised to use this name instead of the others to avoid
       any confusion !


Additional information about creating gadgets
---------------------------------------------

Beginning with version 38.0 GUITools does the following replacements
during the creation of a gadget:

  checkboxKind : if width  = 0, then width  := GadToolsBoxD.checkboxWidth
               : if height = 0, then height := GadToolsBoxD.checkboxHeight
  mxKind       : if width  = 0, then width  := GadToolsBoxD.mxWidth
                 if height = 0, then height := GadToolsBoxD.mxHeight
  stringKind   : if height = 0, then height := gadget font^.ySize + 4
  integerKind  : the same as stringKind

If you set the @{" addBorderDims flag " LINK MSTRUCT-GUIInfoFlagSet}, the gadget creating functions add
to the gadget left the window^.borderLeft value and to the gadget top
the window^.borderTop value, so that every gadget will be inside the
window regardless of the used font. (Take care that the window is big
enough !)

After a call to a gadget creating function you have access to the
created gadget structure using the following possibilities:

     gui^.gadgets^[gui^.actgad - 1]

or when running at least under version 38.0

     gui^.gadget

But you have to check before using these methods if the @{" actgad field " LINK MSTRUCT-GUIInfo-actgad}
is greater than 0 and if the used pointer isn't NIL !.

GUITools uses the userData field of each gadget to store some extra
information which are very important for GUITools to work. Due to
this you can't use this userData entry for your own data. But there
is still the possibility to save your user data for each gadget.
GUITools sets the userData field to a @{" GUIGadgetInfo structure " LINK MSTRUCT-GUIGadgetInfo}.
Don't change this pointer. To store your own user data use the
@{" userData field " LINK MSTRUCT-GUIGadgetInfo} of the @{" GUIGadgetInfo structure " LINK MSTRUCT-GUIGadgetInfo}.
GUITools sets this pointer to the value when creating a gadget of
the userData field of the @{" newgad structure " LINK MSTRUCT-GUIInfo-newgad}.
Using the @{" kind field " LINK MSTRUCT-GUIGadgetInfo} you can check the gadget kind. This could be
a gadtools gadget or a guitools gadget as well !

When the GUI is set you can use the @{" gadgets field " LINK MSTRUCT-GUIInfo-gadgets} to get a pointer
to one of your created gadgets.
But don't call any function for gadgets before the GUI is set or after
the GUI has been removed or disabled !

Beginning with version 38.1 the gtUnderscore tag is ignored for textKind,
numberKind, progressIndicatorKind and bevelboxKind gadgets if the
@{" vanillaKeysNotify flag " LINK MSTRUCT-GUIInfoFlagSet} is set, so there is no need to clear and
set the @{" addStdUnderscore flag " LINK MSTRUCT-GUIInfoFlagSet} all the time.


GUITools gadgets
----------------

Starting with version 38.0 you can not only use the gadtools gadgets,
but also two GUITools gadgets !
(In real they are actually no gadgets, they are only treated as some
gadgets and are simulated by GUITools !)
After setting the GUI you have the same access to GUITools gadgets
as to gadtools gadgets. That means you can modify or resize them and
you can check the position and size fields of the gadget structure
as well as the userData field. But remember don't use other fields of
this gadget structure and don't take this structure as a real gadget
structure, e.g. to link gadgets or to modify them directly using a
pointer to this structure ! This structure is read only and can only
be used with functions of GUITools !!

And now the description of the GUITools gadgets:

  The progress indicator kind

    This gadget offers a beam, e.g. to show howfar the progress has
    come.
    Use the @{" progressIndicatorKind " LINK MSTRUCT-Constants} constant to create.

    With this gadget you can use the following @{" SgTags " LINK MSTRUCT-SgTags}:

      sgpiMaxValue  : (CARDINAL, set to 100)
                      The maximum value of a progressIndicatorKind. The
                      value of 100 is very useful, because then it is
                      easier to specify the progress in per cent.

      sgpiCurrentValue : (CARDINAL, set to 0)
                         The current value of a progressIndicatorKind.
                         This is the percentage of the progress. It shows
                         how much is done yet.

    These tags can be used for creation and modification.
    This gadget also provides a gadget text, but it is not allowed to
    write the text inside the gadget. Because this gadget never sends
    messages, there is no need of having a key equivalent and so there
    should not be an underscore in the gadget text !


  The bevelbox kind

    This gadget shows a bevelled box, which can either be raised or
    recessed.

    Use the @{" bevelboxKind " LINK MSTRUCT-Constants} constant to create.

    When creating you can specify the following tag:

      sgbbRecessed : (boolean tag, set to FALSE)
                     Should the bevelled box be recessed or not.

    Don't use gadget text together with bevelled box gadgets. Because
    this is not a real gadget as mentioned above, it is possible to
    show gadgets inside this gadget ! So you can draw a border around
    other gadgets !
    Using this gadget instead of a real bevelled box, simplifies such
    things as resizing GUIs and refreshing !
    This gadget never causes a message !

See also: @{" Resizable gadgets " LINK MCHAP-ResizableGadgets}

@ENDNODE

@NODE MCHAP-CreatingMenus "Creating menus"

If you want to create the following menu, you have to do the below
mentioned calls, after you have created a pointer to @{" GUIInfo " LINK MSTRUCT-GUIInfo}
named GUI using @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} or @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}.

        Project     Edit
      -------------------------------------------------
        Load        Cut
        Save        Paste
        QUIT

      MakeMenuEntry(GUI, nmTitle, ADR('Project'), NIL);
      MakeMenuEntry(GUI, nmItem,  ADR('Load'), ADR('L\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('Save'), ADR('S\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('QUIT'), ADR('Q\o'));
      MakeMenuEntry(GUI, nmTitle, ADR('Edit'), NIL);
      MakeMenuEntry(GUI, nmItem,  ADR('Cut'), ADR('C\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('Paste'), ADR('V\o'));


If you are using version 37.3 you have to take care of a multi selection
when checking the menus. The same you have to do when you are NOT using
@{" GetIntMsg " LINK MFCT-GetIntMsg} or @{" WaitIntMsg " LINK MFCT-WaitIntMsg}.
If you are using at least version 38.0 together with @{" GetIntMsg " LINK MFCT-GetIntMsg} resp
@{" WaitIntMsg " LINK MFCT-WaitIntMsg} you will get automatically by each call of them the next
choice of the multi selection. So there is no difference if the items
are chosen together or each after each !

After a call to @{" MakeMenuEntry " LINK MFCT-MakeMenuEntry} you can reach the
NewMenu structure of the created menu item using the following expressions,
e.g. to set the userData field:

    GUI^.newMenus^[GUI^.actmenu-1]^.userData := MyData    or

    GUI^.menuAdr^.userData := MyData   when using at least version 38.0.

This userData field can be used together with the @{" callMenuData flag " LINK MSTRUCT-GUIInfoFlagSet}
to call a function which is run by @{" HandleIntMsg " LINK MFCT-HandleIntMsg} if the menu item is
selected.
You can use the @{" MenuFct " LINK MSTRUCT-MenuFct} or the @{" NewMenuFct " LINK MSTRUCT-MenuFct} declaration for you function.
For example if you want a function to quit your program, which asks
the user if he really wants to quit, you can do this in the following
way: (For this version 38.1 is required !)

- Create the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} using @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}
- Specify the @{" guiCompilerReg tag " LINK MSTRUCT-GUITags} and set the value to SYSTEM.REG(A4)
- Set the @{" callMenuData flag " LINK MSTRUCT-GUIInfoFlagSet}
- Create a menu with a quit menu item and set it's userData field to
  the address of the following function:

  PROCEDURE menuQuit(gui{A0} : GUIInfoPtr):BOOLEAN;
  (*$ SaveA4:=TRUE *) (* This is required because we have to set A4 ! *)
  BEGIN
    SYSTEM.SETREG(A4, gui^.compilerReg); (* Without this we can't use
                                            any global data or call any
                                            library function ! *)
    IF ShowRequester(gui, ADR('Do you really want to quit ?'),
                     doitReqKind, NIL) = reqDo THEN
      RETURN FALSE;   (* end the message loop ! *)
    ELSE
      RETURN TRUE;    (* Wait for the next message *)
    END;
  END menuQuit;


See also: @{" newMenus " LINK MSTRUCT-GUIInfo-newmenus}, @{" actmenu " LINK MSTRUCT-GUIInfo-actmenu}, @{" menuAdr " LINK MSTRUCT-GUIInfo-menuAdr}

@ENDNODE

@NODE MCHAP-DealingFonts "Dealing with fonts"

The returned TextAttr pointer by @{" TopazAttr() " LINK MFCT-TopazAttr} to the topaz/8 font
can be used together with @{" OpenIntScreen " LINK MFCT-OpenIntScreen} / @{" OpenIntScreenTags " LINK MFCT-OpenIntScreenTags}
to make sure which font the screen uses.
This pointer is also very useful for the gadget creation on a window
which is opened on a public screen. You can set the textAttr field
of the @{" newgad field " LINK MSTRUCT-GUIInfo-newgad} to the returned pointer and then the problem
to adjust the GUI to an unknown font is solved.
You only have to adapt to the font of the window title. This can be
easily done setting the @{" addBorderDims flag " LINK MSTRUCT-GUIInfoFlagSet} in the @{" flags field " LINK MSTRUCT-GUIInfo-flags}.
Due to this all gadgets will appear inside the font regardless of the
used font.
If you then also set the gadget font to @{" TopazAttr() " LINK MFCT-TopazAttr} and use the
waInnerWidth, waInnerHeight and waAutoAdjust tags together with
@{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags} you have a ever nice looking GUI,
regardless of the default fonts for the public screen.

@ENDNODE

@NODE MCHAP-KeyEquivalents "Key equivalents (V38.0)"

It is a pitty that gadtools only supports key equivalents by underlining
the belonging character.
GUITools does a lot of extra work:
When creating a gadget set the @{" vanillaKeysNotify flag " LINK MSTRUCT-GUIInfoFlagSet} and now GUITools
saves all key equivalents which are letters.
If you also set the @{" convertKeys flag " LINK MSTRUCT-GUIInfoFlagSet} you will automatically get
a gadget message instead of a key message when using @{" WaitIntMsg " LINK MFCT-WaitIntMsg}
or @{" GetIntMsg " LINK MFCT-GetIntMsg}. GUITools converts these messages.
Notice that GUITools only changes the extra fields in the GUIInfo structure
but not the @{" im field " LINK MSTRUCT-GUIInfo-im}. This field reminds unchanged !
The consequence is, when receiving a message you have to use the extra
fields of the GUIInfo structure and not the @{" im field " LINK MSTRUCT-GUIInfo-im} ! (@{" msgClass field " LINK MSTRUCT-GUIInfo-msgClass},
@{" cardCode field " LINK MSTRUCT-GUIInfo-CodeEntries} etc)

But what, if you want to use key equivalents which aren't letters ?
For example the AmigaGuide does so for browsing through the text (< and >).
IF you haven't set the @{" allowAllVanillaKeys flag " LINK MSTRUCT-GUIInfoFlagSet}, GUITools refuses to
create such a gadget. But if this flag is set, you can create these
gadgets, but they are not handled automatically.
For this reason the @{" VanKeyFct " LINK MSTRUCT-VanKeyFct} was created. This function is called
if the @{" callVanillaKeyFct flag " LINK MSTRUCT-GUIInfoFlagSet} is set and if the @{" vanKeyHook field " LINK MSTRUCT-GUIInfo-vanKeyHook}
contains a pointer to such a function.

Example: Imagine, you want to program your own hypertext tool. Despite of
         a lot of other gadgets and menus you have a 'Browse _>' and a
         'Browse _<' gadget. The first one has the ID 5 and the second
         one the ID 6.

         Your @{" VanKeyFct " LINK MSTRUCT-VanKeyFct} could look like this:

      TYPE INTPTR = POINTER TO INTEGER;
      PROCEDURE KeyFctDemo(key {D0} : CHAR;
                           nbr {A0} : INTPTR;
                           shift{A1}: INTPTR) : BOOLEAN;
      (* LoadA4:=TRUE isn't necessary, because no global data is used *)
      BEGIN
        IF    key = '<' THEN
          nbr^ := 5;
          shift:= 0;
          RETURN TRUE;
        ELSIF key = '>' THEN
          nbr^ := 6;
          shift:= 0;
          RETURN TRUE;
        ELSE   (* Sorry, this key wasn't for me *)
          RETURN FALSE;
        END;
      END KeyFctDemo;

@ENDNODE

@NODE MCHAP-ResizableGadgets "Resizable gadgets (V38.0)"

Introduction

  More and more it is becoming more popular to make the GUI font
  sensitive and resizable.
  For this reasion GUITools provides some functions which support
  this behaviour and which make it possible to adapt the GUI
  starting with version 38.0.

Font sensitive

  First you have to calcute the size of the window regarding the
  used font. Then call @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags} together with the
  waInnerWidth, waInnerHeight tags. Also use the waAutoAdjust tag with a
  value of TRUE.
  To have the gadgets inside the window use the @{" addBorderDims flag " LINK MSTRUCT-GUIInfoFlagSet}.
  Use @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} instead of @{" CreateGUIInfo " LINK MFCT-CreateGUIInfo} and a lot of problems
  have disappeared. See chapter @{" Creating gadgets " LINK MCHAP-CreatingGadgets}.

Resizable gadgets

  When running under version 38.0 or higher you can use the following
  method to resize gadgets. Using this method you have do to the cal-
  culation of the new sizes and positions for yourself:

  When creating the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} you must use @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}
  along with the @{" guiResizableGads tag " LINK MSTRUCT-GUITags} set to TRUE.
  If you get a newSize message, calculate the new size for each gadget
  and call @{" ResizeGadget " LINK MFCT-ResizeGadget} with the new values.
  Then simply call @{" RedrawGadgets " LINK MFCT-RedrawGadgets} and your GUI will fit into the window.

  Starting with version 38.1 there is another possibility of resizing
  gadgets. GUITools does the calculations for you, but this requires
  another way of defining the gadgets' positions and sizes:

  When creating the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} you must use @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}
  along with the @{" guiResizableGads tag " LINK MSTRUCT-GUITags} set to TRUE and the
  @{" guiUseGadDesc tag " LINK MSTRUCT-GUITags} set to TRUE !
  From now on when defining a gadget the gadget creating functions search
  for the @{" sgGadgetDesc " LINK MSTRUCT-SgTags} and @{" sgGadgetObjects " LINK MSTRUCT-SgTags} tags to find out the
  gadget's position and size !
  These tags allow it to specify the position and size in an object
  orientated way. This means, you say this gadget has a distance to that
  gadget of 10. In the current version you can specify the distance to
  other gadgets or to the window borders.
  To make the calculation easier you have to define the GUI for a certain
  window size ! The GUI for other window sizes is calculated out of the
  new window size in proportion to the certain one !
  Because the GUI is always inside the window, which means inside the
  window borders, you have to open the window using the waInnerWidth and
  waInnerHeight tags ! When creating the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} GUITools
  saves these values in the @{" winIWidth " LINK MSTRUCT-GUIInfo-winISize} and the @{" winIHeight field " LINK MSTRUCT-GUIInfo-winISize}.
  When now the size of the window changes, GUITools can determine using
  these fields how far the size has changed and recalculate the gadgets
  If you want to open your window in a size the user can define, this can
  easily done in the following way:
  - Open the window with the user defined size
  - Create the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo}
  - Set the @{" winIWidth " LINK MSTRUCT-GUIInfo-winISize} and the @{" winIHeight field " LINK MSTRUCT-GUIInfo-winISize} to the inner size of the
    window for which the GUI definition is for
  - Create the GUI for the window size the @{" winIWidth " LINK MSTRUCT-GUIInfo-winISize} and @{" winIHeight " LINK MSTRUCT-GUIInfo-winISize}
    fields are set to
  The resizing for the user defined window size is then done by GUITools.

  But now the hardest part, the defining of the gadget's positions and
  sizes ! (If you don't understand this reading the first time, don't
  give up, because my explanations are not as clearly as I wanted them
  to be, but take also a look at the demos for resizable gadgets and
  perhaps you will know what GUITools can do !)
  For every gadget attribute (left edge, top edge, width and height)
  GUITools uses a description byte. This byte consists of three parts:
  1.) The distance kind:
      @{" distNorm " LINK MSTRUCT-Constants}   This is the normal distance, that means the attribute
                   is handled in the same way as without this byte. This
                   distance is for constant positions and sizes. The
                   @{" addBorderDims flag " LINK MSTRUCT-GUIInfoFlagSet} can be used together with this.
      @{" distAbs " LINK MSTRUCT-Constants}    This specifies the distance to a given object. The size
                   of the window is not regarded. The distance will always
                   be the same.
      @{" distRel " LINK MSTRUCT-Constants}    This distance is also a distance from a given object.
                   But if the window size changes, the distance will change
                   in the same way.
      @{" distPercent " LINK MSTRUCT-Constants} In the first way this does the same as distNorm,
                   but if now the window size changes, the distance will
                   change in the same way. The @{" addBorderDims flag " LINK MSTRUCT-GUIInfoFlagSet} is
                   supported.
  2.) The object kind:
      If you use @{" distAbs " LINK MSTRUCT-Constants} or @{" distRel " LINK MSTRUCT-Constants} GUITools needs also the kind of the
      object the distance is to.
      @{" objBorder " LINK MSTRUCT-Constants}    this is the window border
      @{" objGadget " LINK MSTRUCT-Constants}    the distance to another gadget
  3.) The object part
      If you specify the distance to another object, you also have to say
      to which part of the object.
      This can be @{" objRight, objLeft, objBottom or objTop " LINK MSTRUCT-Constants}
  And that's all ! Really simple, isn't it. But how can you tell GUITools
  these descriptions. For this reason there is the @{" sgGadgetDesc tag " LINK MSTRUCT-SgTags}.
  Because every tag has a data value of 32 Bits, it is possible to store
  the information for all four attributes into one tag !
  The highest byte contains the left edge, the next byte the top edge,
  the next byte the width and the lowest byte the height of the gadget !
  To build this information data, you can use the @{" GADDESC " LINK MFCT-GADDESC} macro or you
  can shift the information with the @{" shift constants " LINK MSTRUCT-Constants}.
  If you specify an attribute's distance to another gadget, normally the
  previous created gadget is used. If you want to define the distance to
  a different one, you have to use the @{" sgGadgetObjects tag " LINK MSTRUCT-SgTags}.
  It has the same structure as the @{" sgGadgetDesc tag " LINK MSTRUCT-SgTags} except that
  every byte represents a gadget number. But you can only use gadgets
  which are already created !
  For more information refer to the included demo source files !
  Here follows a short example: You want to create a gadget, which is
  10 points from the left and the top border and which right border is 20
  away from the left border of the first created gadget (gadget number 0)
  and the top border has a distance of 10 points to the second created
  gadget (with gadget number 2):

    CreateGadgetNew(GUI, 10, 10, -20, -10, ANYKIND,
                    sgGadgetDesc, GADDESC(distAbs + objBorder + objLeft,
                                          distAbs + objBorder + objTop,
                                          distAbs + objGadget + objLeft,
                                          distAbs + objGadget + objTop),
                    sgGadgetObjects, GADOBJS( 0, 0, 0, 1), tagEnd);
  @{" GADOBJS " LINK MFCT-GADOBJS} is a macro to build the data for the @{" sgGadgetObjects tag " LINK MSTRUCT-SgTags}.

  When the @{" doResizing flag " LINK MSTRUCT-GUIInfoFlagSet} is set and the internal call to @{" RedrawGadgets " LINK MFCT-RedrawGadgets}
  failt, you will get the newSize message, otherwise you won't !


  If you use gadgets like genericKind or such where you have to add some
  important values after the creation (usually are these genericKind
  gadgets), you have to use @{" RedrawGadgets " LINK MFCT-RedrawGadgets}(GUI, FALSE), because GUITools
  can't save the adds you make for these gadgets ! Now you have to
  make this adds again and then call @{" SetGUI " LINK MFCT-SetGUI}.
  For this reason it is not possible for those gadgets to use the
  @{" doResizing flag " LINK MSTRUCT-GUIInfoFlagSet} ! Call first @{" DoResizing " LINK MFCT-DoResizing} and then @{" RedrawGadgets " LINK MFCT-RedrawGadgets},
  make the adds and then call @{" SetGUI " LINK MFCT-SetGUI} when a newSize message arrives !

@ENDNODE

@NODE MCHAP-UsingRequesters "Using requesters (V38.0)"

All requester features are only available starting with version 38.0 !


Redirection requesters

Using @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags} you are able to change the windowPtr field
of the process structure to your window which forces the requesters to
appear on this window.
It is also possible to tell @{" FreeGUIInfo " LINK MFCT-FreeGUIInfo} to restore the old value of
the windowPtr field.
This can be done by using the @{" guiSetProcessWindow tag " LINK MSTRUCT-GUITags} and the
@{" guiRestoreProcessWindow tag " LINK MSTRUCT-GUITags}.
If you are using only one window there will be no problems, but if you
are having multiple windows opened and you are using the above mentioned
tags you should have in mind this:
You open the first window, the field in the process structure will be
changed and the old value is saved. You open the next window and now
the field in the process structure is again changed and the old value
is saved, but this is the pointer to the first opened window !
If you are now closing the windows resp freeing the @{" GUIInfo " LINK MSTRUCT-GUIInfo} using
@{" FreeGUIInfo " LINK MFCT-FreeGUIInfo} (which is automatically called by @{" CloseIntWindow " LINK MFCT-CloseIntWindow}) it is
required that the windows are closed in reverse order to have the
correct value restored in the windowPtr field of the process structure.
But if you are clever and read this documentation, you will use
@{" CloseIntScreen " LINK MFCT-CloseIntScreen} which does the closing of the windows for you ! But now
you have no chance to controll the order of closing windows !
So if you are using multiple windows use the tags only for one window !
Your own created requesters can appear on your own window using
@{" ShowRequester " LINK MFCT-ShowRequester} without modifying the process structure ! This is only
necessary for system requester !
You can also change the windowPtr field of the process structure
by using @{" SetProcessWindow " LINK MFCT-SetProcessWindow} !


Own standard requesters

Using the @{" ShowRequester " LINK MFCT-ShowRequester} functions it is very simple to create your
own requesters:

There are some tags to descripe the requester. See the @{" SrTags " LINK MSTRUCT-SrTags}
GUITools still knows some requester kinds:

  @{" okReqKind " LINK MSTRUCT-Constants}   : This requester only contains one "OK" gadget.
                  The return value is always @{" reqOK "LINK MSTRUCT-Constants}.

  @{" doitReqKind " LINK MSTRUCT-Constants} : This requester has a "NO" and a "YES" gadget.
                  The return value will be @{" reqDo " LINK MSTRUCT-Constants} for "YES"
                  and otherwise @{" reqLeave " LINK MSTRUCT-Constants}.

  @{" yncReqKind " LINK MSTRUCT-Constants}  : Yes/No/Cancel requester. It has a "YES", a "NO"
                  and a "CANCEL" gadget and returns @{" reqYes " LINK MSTRUCT-Constants},
                  @{" reqNo " LINK MSTRUCT-Constants} or @{" reqCancel " LINK MSTRUCT-Constants}.

With this predefined requesters you don't have to use the @{" srGadgets tag " LINK MSTRUCT-SrTags},
but you can use it e.g. to display the text in a different language.
If you want to create a totally different requester, create a
@{" generalReqKind " LINK MSTRUCT-Constants} requester. Now you must specify the @{" srGadgets tag " LINK MSTRUCT-SrTags}.
For these requesters GUITools uses the EasyRequestArgs function. With the
@{" SrTags " LINK MSTRUCT-SrTags} you can reach every field of the EasyStruct structure !
@{" ShowRequester " LINK MFCT-ShowRequester} returns the value of EasyRequestArgs. For requesters like
@{" okReqKind " LINK MSTRUCT-Constants} you can also use @{" ShowRequesterP " LINK MFCT-ShowRequester} which has no return value.
IF you specify a @{" GUIInfo pointer " LINK MSTRUCT-GUIInfo} the requester appears on the window this
pointer is for. If you set it to NIL the windowPtr field of the process
structure is used. But you can override these values by using the
@{" srReqWindow tag " LINK MSTRUCT-SrTags} !
The @{" SimpleReq " LINK MFCT-SimpleReq} function provides an easier interface to the requesters,
because you only have to specify the text and the kind.


Using asl requesters

Starting with version 38.1 GUITools can display also a file and a
directory requester using the asl.library.
Pass @{" ShowRequester " LINK MFCT-ShowRequester} @{" fileReqKind " LINK MSTRUCT-Constants} or @{" dirReqKind " LINK MSTRUCT-Constants}.
The text parameter contains the title, which can be also specified
using the @{" srTitle tag " LINK MSTRUCT-SrTags}. The requester returns @{" reqAslOK " LINK MSTRUCT-Constants} or
@{" reqAslCancel " LINK MSTRUCT-Constants}.
The redirection of asl requesters follows the rules mentioned above.
In addition you can use the following @{" SrTags " LINK MSTRUCT-SrTags}. Don't use any other
tags as mentioned below !

 @{" srAslNameBuffer " LINK MSTRUCT-SrTags} This is a pointer to a buffer, which will contain
                   the complete filename after the user selection.
                   You can specify here a complete filename which
                   will be displayed when the requester opens.
                   Keep this buffer big enough. A value of 512 bytes
                   or even more is advised. GUITools doesn't check
                   this size !
                   Don't use this tag together with @{" srAslDirBuffer " LINK MSTRUCT-SrTags}
                   or @{" srAslFileBuffer " LINK MSTRUCT-SrTags}.

 @{" srAslFileBuffer " LINK MSTRUCT-SrTags} Points to a buffer which will contain only the
                   filename without the path. Don't use this tag
                   together with @{" srAslNameBuffer " LINK MSTRUCT-SrTags}.

 @{" srAslDirBuffer " LINK MSTRUCT-SrTags}  Points to a buffer which will contain only the
                   path without the filename. Don't use this tag
                   together with @{" srAslNameBuffer " LINK MSTRUCT-SrTags}.

 @{" srAslPattern " LINK MSTRUCT-SrTags}    Pointer to a file pattern. If you don't want a
                   file pattern gadget to be displayed set this
                   tag to NIL.

 @{" srAslSave " LINK MSTRUCT-SrTags}       This boolean tag says if the requester is for
                   saving something or not. The default is FALSE:

GUITools uses automatically a new IDCMP port for the requester. You
can also define all tags (defined in AslD) for asl requesters.
But notice, @{" ShowRequester " LINK MFCT-ShowRequester} uses the following tags, which you should
not use, use the @{" SrTags " LINK MSTRUCT-SrTags} instead:

  tfrWindow, tfrTitleText, tftInitialFile, tfrInitialDrawer
  and tfrInitialPattern.

GUITools uses also the tfrFlags1 and tfrFlags2 tags. If you need these
tags, please notice that you have to specify again the frDoPatterns,
frDoSaveMode, frDrawersOnly and frPrivateIDCMP flags which are usually
set by using the @{" SrTags " LINK MSTRUCT-SrTags} !
Don't use the @{" srAslFileBuffer tag " LINK MSTRUCT-SrTags} together with the @{" dirReqKind " LINK MSTRUCT-Constants}
requester, because this requester is only for directories.

If you want to display a requester, where the user should choose
the best shared library, you could do this:
To help the user choosing, you use the pattern '#?.library' and
you make of course the suggestion of 'sys:libs/guitools.library'. But
the silly user chooses 'sys:libs/asl.library' !
You have generally these two possibilities:

   - First possibility :

       VAR file, dir : ARRAY[0..255] OF CHAR; (* two different variables
                                                 one for the path and
                                                 one for the filename *)
         ...

       file := 'guitools.library';
       dir  := 'sys:libs';

       ShowRequester(NIL, fileReqKind, ADR('Choose the best Library'),
                     TAG(TAGBUFFER, srAslFileBuffer, ADR(file),
                                    srAslDirBuffer, ADR(dir),
                                    srAslPattern, ADR('#?.library'),
                                    tagEnd));

     The result is :

       file = 'asl.library';
       dir  = 'sys:libs';

   - Second possibility :

       VAR buffer : ARRAY[0..511] OF CHAR; (* the full filename with
                                              the whole path *)
         ...

       name := 'sys:libs/guitools.library';

       ShowRequester(NIL, fileReqKind, ADR('Choose the best library'),
                     TAG(TAGBUFFER, srAslPattern, ADR('#?.library'),
                                    srAslNameBuffer, ADR(name), tagEnd));

     The result is:

       name = 'sys:libs/asl.library';


In the current version it is NOT (yet) possible to use the multiselect
function ! If you need this, please use the asl.library instead.

@ENDNODE

@NODE MCHAP-3 "Bugs / Problems"

   @{" Problems under V37.3 " LINK MCHAP-3-1}

   @{" Known Bugs " LINK MCHAP-KnownBugs}

   @{" Author / Final Words " LINK MCHAP-Author}

@ENDNODE

@NODE MCHAP-3-1 "Problems under V37.3"

   @{" Menu font handling (CreateGUIInfo vs CreateGUIInfoTags " LINK MCHAP-Problems-CreateGUIInfo}

   @{" Screen title (OpenIntWindow vs OpenIntWindowTags " LINK MCHAP-Problems-OpenIntWindow}

   @{" IDCMP_MenuPick messages " LINK MCHAP-Problems-IDCMP_MenuPick}

@ENDNODE

@NODE MCHAP-Problems-CreateGUIInfo "Menu font handling (CreateGUIInfo vs CreateGUIInfoTags)"

Too late, after the release of version 37.3, I recognized that it makes
no sense to use the window's font for the menu. As long as you open an
own screen - as I often do - there are no problems because screen and
window have the same font.
But if you want to open your window on a public screen (e.g. Workbench),
the menu might look a little bit foreign.
The solution is to use the screen's font for the menu. But this is easy
to say and not easy to do ! Due to the @{" GUIInfo structure " LINK MSTRUCT-GUIInfo} under V37.3
it was not possible to do this in an upward compatible way under V38.0.
The consequence is you have this problem stil when using @{" CreateGUIInfo " LINK MFCT-CreateGuiInfo}.
Then you have do set the menu font by hand !
Running under V38.0 or higher you only have to use @{" CreateGUIInfoTags " LINK MFCT-CreateGUIInfoTags}
instead and the menu uses the screen's font.

@ENDNODE

@NODE MCHAP-Problems-OpenIntWindow "Screen title (OpenIntWindow vs OpenIntWindowTags)"

After the release of version 37.3 I noticed that it is not always useful
to set the screen's title to the window title when opening a window on
a public screen (Workbench). But this is done by @{" OpenIntWindow " LINK MFCT-OpenIntWindow}.
To be upward compatible OpenIntWindow still use the waScreenTitle tag,
but when running under V38.0 or higher you can use @{" OpenIntWindowTags " LINK MFCT-OpenIntWindowTags}
instead. This function doesn't use the tag, although you can specify it.

@ENDNODE

@NODE MCHAP-Problems-IDCMP_MenuPick "IDCMP_MenuPick messages"

Under version 37.3 there was no check if a IDCMP_MenuPick message had
a multi selection. It was treated as a usual single selection. So you
had to check this by yourselft !
Running under V38.0 (or higher) you don't need to worry about multi
selection if you use @{" GetIntMsg " LINK MFCT-GetIntMsg} or @{" WaitIntMsg " LINK MFCT-WaitIntMsg}.
Because with every call to @{" GetIntMsg " LINK MFCT-GetIntMsg} resp @{" WaitIntMsg " LINK MFCT-WaitIntMsg} you get one
selection of the multi selection like the items very selected separa-
tely.
If you don't use them and you call @{" HandleIntMsg " LINK MFCT-HandleIntMsg} by hand, you have to
check for multi selection by yourself again ! You only get the first
selection !

@ENDNODE

@NODE MCHAP-KnownBugs "Known Bugs"

The known bugs are descriped in the functions' explanations they are
bound to.


Unkown Bugs

I am using GUITools every day in a lot of different programs without
complaining.
Of course this does not mean, that there are no more bugs, but I hope
that I have found all of the REAL BIG BUGS.
If you stick to the guidelines and read the manual very closely, every-
thing should be alright.
But if you have nevertheless a problem or found a bug, please, do the
following steps:

 1.  Locate the bug as precise as possible.
 2.  Please leave the @{" author " LINK MCHAP-Author} a not with a precise bug description and
     perhaps if possible mention the cause or a solution !

If I get to know a bug, I will try to correct it as soon as possible !

@ENDNODE

@NODE MCHAP-Author "Author / Final Words"

Before you are delivered from this boring documentation, I have to do
some apologies:
The whole documentation is not entitled to be complete, without any
mistakes or at least understandable, although I worked really very
hard on it.
If you don't know how to program an Amiga, you can throw the documenta-
tion away. In many cases a left some explanations you can find in the
RKRMs. If you are familar with them, you will probably have no problems.

To reach a "wider audience" I tried to translate the definitions and
the documentation into the english language. I hope you can understand
it and that there will noone who died by laughing at these texts !

Suggestions, bug reports, improvements, extensions and of course
appreciation, too, can be send to the following address:

    Carsten Ziegeler
    Augustin-Wibbelt-Str. 7
    D-33106 Paderborn
    Germany


ATTENTION: There will be no warranty or responsibility for posted goods.
           If you want to have your work back, you must include enough
           return postage I can use here in germany (e.g. german money
           or german stamps, but not e.g. english stamps or french food).
           All posting will be at your own risk and of your own free will.

You can reach me also under the following EMail-Address:

         tarot@uni-paderborn.de

So please, if possible use electronic mail to avoid any problems !


    Enjoy it !

@ENDNODE
