@DATABASE "guitools_sasc.guide"

@REMARK "$VER: GUITools_SASC_guide 38.1 (11.05.94)"

@NODE Main "GUITools_SASC.guide"


                                   GUITools

                                 Version 38.1

                                 SASC Document

 =========================================================================

                       Mar 1994   Carsten Ziegeler
                                  Augustin-Wibbelt-Str.7
                                  D-33106 Paderborn
                                  Germany

 =========================================================================


                               Table of Contents
                               =================

@{" Function descriptions " LINK SCHAP-1}

   @{" Function overview " LINK SCHAP-1-1}
   @{" Screens and windows " LINK SCHAP-1-2}
   @{" Fonts " LINK SCHAP-1-3}
   @{" Creating GUIs " LINK SCHAP-1-4}
   @{" Checking GUIs " LINK SCHAP-1-5}
   @{" Modifying GUIs " LINK SCHAP-1-6}
   @{" Refreshing " LINK SCHAP-1-7}
   @{" Requesters " LINK SCHAP-1-8}
   @{" Macros " LINK SCHAP-1-9}

@{" Working with GUITools " LINK SCHAP-2}

   @{" Guidelines " LINK SCHAP-Guidelines}
   @{" Freeing resources (V38.0)" LINK SCHAP-FreeingResources}
   @{" Creating gadgets " LINK SCHAP-CreatingGadgets}
   @{" Creating menus " LINK SCHAP-CreatingMenus}
   @{" Dealing with fonts " LINK SCHAP-DealingFonts}
   @{" Key equivalents (V38.0)" LINK SCHAP-KeyEquivalents}
   @{" Resizable gadgets (V38.0)" LINK SCHAP-ResizableGadgets}
   @{" Using requesters (V38.0)" LINK SCHAP-UsingRequesters}

@{" Bugs / Problems " LINK SCHAP-3}

   @{" Problems under V37.3 " LINK SCHAP-3-1}
   @{" Known Bugs " LINK SCHAP-KnownBugs}
   @{" Author / Final Words " LINK SCHAP-Author}

@ENDNODE

@NODE SCHAP-1 "Function descriptions"

If a version number is specified together with any function, constant,
structure etc, this feature is only available if you are using the
given version of GUITools or a higher one ! Don't use them under older
versions !
It is a good thing to test in your programs which version of the
library you are using and if this version is sufficient.

For more information see the chapter @{" Working with GUITools " LINK SCHAP-2}.

Only the most important parameters are descripted. The meaning of most of
them is similar to their name !


   @{" Function overview " LINK SCHAP-1-1}

   @{" Screens and windows " LINK SCHAP-1-2}

   @{" Fonts " LINK SCHAP-1-3}

   @{" Creating GUIs " LINK SCHAP-1-4}

   @{" Checking GUIs " LINK SCHAP-1-5}

   @{" Modifying GUIs " LINK SCHAP-1-6}

   @{" Refreshing " LINK SCHAP-1-7}

   @{" Requesters " LINK SCHAP-1-8}

   @{" Macros " LINK SCHAP-1-9}

@ENDNODE

@NODE SCHAP-1-1 "Function overview"

Listed below are all functions of the guitools.library version 38.1.

   @{" AllVarsToGad " LINK SFCT-AllVarsToGad}           V38.0
   @{" BeginRefresh " LINK SFCT-BeginRefresh}           V38.0
   @{" ClearWindow "  LINK SFCT-ClearWindow}            V38.0
   @{" CloseIntScreen " LINK SFCT-CloseIntScreen}
   @{" CloseIntWindow " LINK SFCT-CloseIntWindow}
   @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg}         V38.0
   @{" CreateGadget " LINK SFCT-CreateGadget}                 / CreateGadgetA
   @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull}             / CreateGadgetFullA
   @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}        V38.1 / CreateGadgetNewA
   @{" CreateGadgetText " LINK SFCT-CreateGadgetText}             / CreateGadgetTextA
   @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo}
   @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}      V38.0 / CreateGUIInfoTagList
   @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget}    V38.0 / CreateSpecialGadgetA
   @{" DoResizing " LINK SFCT-DoRezsizing}             V38.1
   @{" DrawBox " LINK SFCT-DrawBox}                V38.0
   @{" EmptyIntMsgPort " LINK SFCT-EmptyIntMsgPort}
   @{" EndRefresh " LINK SFCT-EndRefresh}             V38.0
   @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}
   @{" GADDESC macro " LINK SFCT-GADDESC}          V38.1
   @{" GADOBJS macro " LINK SFCT-GADOBJS}          V38.1
   @{" GadgetStatus " LINK SFCT-GadgetStatus}
   @{" GadWithKey " LINK SFCT-GadWithKey}             V38.0
   @{" GetIntMsg " LINK SFCT-GetIntMsg}
   @{" GetOwnFont " LINK SFCT-GetOwnFont}
   @{" HandleIntMsg " LINK SFCT-HandleIntMsg}
   @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry}
   @{" ModifyGadget " LINK SFCT-ModifyGadget}                 / ModifyGadgetA
   @{" NewFontAllGadgets " LINK SFCT-NewFontAllGadgets}      V38.0
   @{" NewGadgetFont " LINK SFCT-NewGadgetFont}          V38.0
   @{" NewGadgetText " LINK SFCT-NewGadgetText}          V38.0
   @{" OpenIntScreen " LINK SFCT-OpenIntScreen}
   @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}      V38.0 / OpenIntScreenTagList
   @{" OpenIntWindow " LINK SFCT-OpenIntWindow}
   @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags}      V38.0 / OpenIntWindowTagList
   @{" RedrawGadgets " LINK SFCT-RedrawGadgets}          V38.0
   @{" RedrawMenu " LINK SFCT-RedrawMenu}             V38.0
   @{" RemoveGadgets " LINK SFCT-RemoveGadgets}          V38.0
   @{" RemoveMenu " LINK SFCT-RemoveMenu}             V38.0
   @{" RemOwnFont " LINK SFCT-RemOwnFont}
   @{" ResizeGadget " LINK SFCT-ResizeGagdet}           V38.0
   @{" SetGUI " LINK SFCT-SetGUI}
   @{" SetProcessWindow " LINK SFCT-SetProcessWindow}       V38.0
   @{" ShowRequester " LINK SFCT-ShowRequester}          V38.0 / ShowRequesterA
   @{" SimpleReq " LINK SFCT-SimpleReq}              V38.0
   @{" TopazAttr " LINK SFCT-TopazAttr}
   @{" UpdateEGad " LINK SFCT-UpdateEGad}
   @{" UpdateEntryGadgets " LINK SFCT-UpdateEntryGadgets}
   @{" VarToGad " LINK SFCT-VarToGad}               V38.0
   @{" WaitIntMsg " LINK SFCT-WaitIntMsg}

@ENDNODE

@NODE SCHAP-1-2 "Screens and windows"

   @{" OpenIntScreen " LINK SFCT-OpenIntScreen}
   @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}      V38.0 / OpenIntScreenTagList
   @{" OpenIntWindow " LINK SFCT-OpenIntWindow}
   @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags}      V38.0 / OpenIntWindowTagList
   @{" CloseIntWindow " LINK SFCT-CloseIntWindow}
   @{" CloseIntScreen " LINK SFCT-CloseIntScreen}
   @{" ClearWindow "  LINK SFCT-ClearWindow}            V38.0

@ENDNODE

@NODE SCHAP-1-3 "Fonts"

   @{" GetOwnFont " LINK SFCT-GetOwnFont}
   @{" RemOwnFont " LINK SFCT-RemOwnFont}
   @{" TopazAttr " LINK SFCT-TopazAttr}

@ENDNODE

@NODE SCHAP-1-4 "Creating GUIs"

   @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo}
   @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}      V38.0 / CreateGUIInfoTagList
   @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}
   @{" SetGUI " LINK SFCT-SetGUI}
   @{" CreateGadget " LINK SFCT-CreateGadget}                 / CreateGadgetA
   @{" CreateGadgetText " LINK SFCT-CreateGadgetText}             / CreateGadgetTextA
   @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull}             / CreateGadgetFullA
   @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}        V38.1 / CreateGadgetNewA
   @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget}    V38.0 / CreateSpecialGadgetA
   @{" RemoveGadgets " LINK SFCT-RemoveGadgets}          V38.0
   @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry}
   @{" RemoveMenu " LINK SFCT-RemoveMenu}             V38.0

@ENDNODE

@NODE SCHAP-1-5 "Checking GUIs"

   @{" WaitIntMsg " LINK SFCT-WaitIntMsg}
   @{" GetIntMsg " LINK SFCT-GetIntMsg}
   @{" EmptyIntMsgPort " LINK SFCT-EmptyIntMsgPort}
   @{" HandleIntMsg " LINK SFCT-HandleIntMsg}
   @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg}         V38.0
   @{" GadWithKey " LINK SFCT-GadWithKey}             V38.0
   @{" DoResizing " LINK SFCT-DoRezsizing}             V38.1

@ENDNODE

@NODE SCHAP-1-6 "Modifying GUIs"

   @{" GadgetStatus " LINK SFCT-GadgetStatus}
   @{" ModifyGadget " LINK SFCT-ModifyGadget}                 / ModifyGadgetA
   @{" UpdateEGad " LINK SFCT-UpdateEGad}
   @{" UpdateEntryGadgets " LINK SFCT-UpdateEntryGadgets}
   @{" VarToGad " LINK SFCT-VarToGad}               V38.0
   @{" AllVarsToGad " LINK SFCT-AllVarsToGad}           V38.0
   @{" RedrawMenu " LINK SFCT-RedrawMenu}             V38.0
   @{" RedrawGadgets " LINK SFCT-RedrawGadgets}          V38.0
   @{" ResizeGadget " LINK SFCT-ResizeGagdet}           V38.0
   @{" NewGadgetText " LINK SFCT-NewGadgetText}          V38.0
   @{" NewGadgetFont " LINK SFCT-NewGadgetFont}          V38.0
   @{" NewFontAllGadgets " LINK SFCT-NewFontAllGadgets}      V38.0
   @{" DrawBox " LINK SFCT-DrawBox}                V38.0

@ENDNODE

@NODE SCHAP-1-7 "Refreshing"

   @{" BeginRefresh " LINK SFCT-BeginRefresh}           V38.0
   @{" EndRefresh " LINK SFCT-EndRefresh}             V38.0

@ENDNODE

@NODE SCHAP-1-8 "Requesters"

   @{" SetProcessWindow " LINK SFCT-SetProcessWindow}       V38.0
   @{" ShowRequester " LINK SFCT-ShowRequester}          V38.0 / ShowRequesterA
   @{" SimpleReq " LINK SFCT-SimpleReq}              V38.0

@ENDNODE

@NODE SCHAP-1-9 "Macros"

   @{" GADDESC macro " LINK SFCT-GADDESC}          V38.1 / GUIToolsMacros
   @{" GADOBJS macro " LINK SFCT-GADOBJS}          V38.1 / GUIToolsMacros

@ENDNODE

@NODE SFCT-AllVarsToGad "AllVarsToGad (V38.0)"

Set the gadgets to the values of the belonging variables

      void AllVarsToGad(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

All gadgets for which a notify was set during the creation, gets
the value of the belonging variable using @{" VarToGad " LINK SFCT-VarToGad}.
This is useful e.g. for a configuration editor if you have loaded a
new configuration and want to display it. Instead to modify each
gadget after gadget simply call AllVarsToGad.

See also: @{" GUIInfoFlagSet " LINK SSTRUCT-GUIInfoFlagSet}, @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

@ENDNODE

@NODE SFCT-BeginRefresh "BeginRefresh (V38.0)"

Replacement for GadTools.GTBeginRefresh

      void BeginRefresh(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

You must call this function instead of GadTools.GTBeginRefresh, because
GUITools does some extra refreshing, e.g. for the GUITools gadgets.
Use this function together with @{" EndRefresh " LINK SFCT-EndRefresh}.

See also: @{" GFLG_DoRefresh flag " LINK SSTRUCT-GUIInfoFlagSet}

@ENDNODE

@NODE SFCT-ClearWindow "ClearWindow (V38.0)"

Clear the window contents of the GUI window

      void ClearWindow(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

@ENDNODE

@NODE SFCT-CloseIntScreen "CloseIntScreen"

Close a screen "safely"

      void CloseIntScreen(struct Screen *screen{A0});

Before the screen is closed, GUITools closes all not yet closed windows
on this screen using @{" CloseIntWindow " LINK SFCT-CloseIntWindow}.
So when using an own screen, there is no need to call CloseIntWindow,
it is sufficient to call CloseIntScreen.
Starting with version 38.0 you also don't need the calls to @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo},
because @{" CloseIntWindow " LINK SFCT-CloseIntWindow} does this for you.

See also: @{" Freeing resources " LINK SCHAP-FreeingResources}, @{" OpenIntScreen " LINK SFCT-OpenIntScreen}, @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}

@ENDNODE

@NODE SFCT-CloseIntWindow "CloseIntWindow"

Close a window "safely"

      void CloseIntWindow(struct Window *window{A0});

All outstanding messages will be replied before the window is closed.
Starting with version 38.0 CloseIntWindow checks if there are still
some not freed @{" GUIInfo structures " LINK SSTRUCT-GUIInfo} for this window. CloseIntWindow
will remove them all using @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}.

See also: @{" Freeing resources " LINK SCHAP-FreeingResources}, @{" OpenIntWindow " LINK SFCT-OpenIntWindow}, @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags},
          @{" CloseIntScreen " LINK SFCT-CloseIntScreen}

@ENDNODE

@NODE SFCT-ConvKMsgToGMsg "ConvKMsgToGMsg (V38.0)"

Converts key messages into gadget messages

      void ConvKMsgToGMsg(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

ConvKMsgToGMsg uses the @{" im.Code field " LINK SSTRUCT-GUIInfo-im} to get the key and then calls
@{" GadWithKey " LINK SFCT-GadWithKey} with the belonging gadget.
The majority of applications will not call this function by hand. It
can be useful if the @{" GFLG_NoHandleIntMsgCall flag " LINK SSTRUCT-GUIInfoFlagSet} is set and you want to
control the conversion or if you want to handle rawkeys.
Pass this function the vanillaKey code in the @{" im.Code field " LINK SSTRUCT-GUIInfo-im} and
IDCMP_VANILLAKEY in the @{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass}.

The gadget creating functions save all key equivalents which are letters
if the @{" GFLG_VanillaKeysNotify flag " LINK SSTRUCT-GUIInfoFlagSet} was set. If you want to use
alternative keys, you have to write a @{" VanKeyFct " LINK SSTRUCT-VanKeyFct}.

See also: @{" Key equivalents " LINK SCHAP-KeyEquivalents}

@ENDNODE

@NODE SFCT-CreateGadget "CreateGadget / CreateGadgetA"

Create a new gadget

      void CreateGadget(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                        WORD   left{D0},
                        WORD   top{D1},
                        WORD   width{D2},
                        WORD   height{D3},
                        ULONG  kind{D4},
                        ULONG  tagitem, tagdata, ...{A1});


      void CreateGadgetA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                         WORD   left{D0},
                         WORD   top{D1},
                         WORD   width{D2},
                         WORD   height{D3},
                         ULONG  kind{D4},
                         struct TagItem *tags{A1});

This is a replacement for GadToolsL.CreateGadgetA. The basic differences
are the easier handling and the position and size must be specified
directly and not using a NewGadget structure.
CreateGadget uses the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad} to create the gadget. Usually
the gadget created with CreateGadget has no text. But you can pass
a text to it together with some other information using the newgad
field of the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}.
Because CreateGadget has no return value, there is no possibility
to check if the gadget could be created or not. A appropriate error
code is given when calling @{" SetGUI " LINK SFCT-SetGUI}.
The gadget creating functions of GUITools do some extra work which is
explained in the chapter @{" Creating gadgets " LINK SCHAP-CreatingGadgets}.
Before version 38.1 CreateGadget can only deal with gadtools gadget
kinds. All other gadget kinds must be created using @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget}.
Starting with version 38.1 this exception is removed.

See also: @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull}, @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew},

Notice: CreateGadgetA is the new name for the obsolete CreateGadgetTag !

@ENDNODE

@NODE SFCT-CreateGadgetFull "CreateGadgetFull / CreateGadgetFullA"

Create a new gadget

      void CreateGadgetFull(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                            WORD   left{D0},
                            WORD   top{D1},
                            WORD   width{D2},
                            WORD   height{D3},
                            ULONG  kind{D4},
                            STRPTR text{A1},
                            ULONG  place{D5},
                            ULONG  tagitem, tagdata, ...{A2});


      void CreateGadgetFullA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                             WORD   left{D0},
                             WORD   top{D1},
                             WORD   width{D2},
                             WORD   height{D3},
                             ULONG  kind{D4},
                             STRPTR text{A1},
                             ULONG  place{D5},
                             struct TagItem *tags{A2});

This function does the same as @{" CreateGadget " LINK SFCT-CreateGadget}, but you can also specify a
gadget text and the flags for the gadget. For more information refer to
@{" CreateGadget " LINK SFCT-CreateGadget}.

See also: @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget},
          @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

Notice: CreateGadgetFullA is the new name for the obsolete
        CreateGadgetFullTag !

@ENDNODE

@NODE SFCT-CreateGadgetNew "CreateGadgetNew (V38.1) / CreateGadgetNewA (V38.1)"

Create a new gadget

      void CreateGadgetNew(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                           WORD   left{D0},
                           WORD   top{D1},
                           WORD   width{D2},
                           WORD   height{D3},
                           ULONG  kind{D4},
                           ULONG  tagitem, tagdata, ...{A1});


      void CreateGadgetNewA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                            WORD   left{D0},
                            WORD   top{D1},
                            WORD   width{D2},
                            WORD   height{D3},
                            ULONG  kind{D4},
                            struct TagItem tags{A1});

Starting with version 38.1 this is only a new name for the
@{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget} function.
This was done because under older versions there was a very confusing
gadget handling. It required calling @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget} to create
GUITools gadgets and for gadtools gadgets you had to use some other
functions.
Beginning with version 38.1 you can create every gadget kind with
every gadget creating function. Another reason for CreateGadgetNew
was to replace the @{" CreateGadget " LINK SFCT-CreateGadget}, @{" CreateGadgetText " LINK SFCT-CreateGadgetText} and the
@{" CreateGadgetFull " LINK SFCT-CreateGadgetFull} functions.
If you want to define the gadget a little bit more then use
the @{" SgTags " LINK SSTRUCT-SgTags}.

See also: @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

@ENDNODE

@NODE SFCT-CreateGadgetText "CreateGadgetText / CreateGadgetTextA"

Create a new gadget

      void CreateGadgetText(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                            WORD   left{D0},
                            WORD   top{D1},
                            WORD   width{D2},
                            WORD   height{D3},
                            ULONG  kind{D4},
                            STRPTR text{A1},
                            ULONG  tagitem, tagdata, ...{A2});


      void CreateGadgetTextA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                             WORD   left{D0},
                             WORD   top{D1},
                             WORD   width{D2},
                             WORD   height{D3},
                             ULONG  kind{D4},
                             STRPTR text{A1},
                             struct TagItem *tags{A2});

This function does the same as @{" CreateGadget " LINK SFCT-CreateGadget}, but you can also specify a
gadget text. For more information refer to @{" CreateGadget " LINK SFCT-CreateGadget}.

See also: @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull}, @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget},
          @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

Notice: CreateGadgetTextA is the new name for the obsolete
        CreateGadgetTextTag !

@ENDNODE

@NODE SFCT-CreateGUIInfo "CreateGUIInfo"

A new @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} will be allocated and all important
fields will be set

      @{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *CreateGUIInfo(struct Window *window{A0},
                                      WORD          maxGads{D0},
                                      WORD          maxMenus{D1});

      window    For this window is the GUI
      maxGads   Maximal amount of gadgets or @{" noGadgets " LINK SSTRUCT-Constants}
      maxMenus  Maximal amount of menu items or @{" noMenu " LINK SSTRUCT-Constants}

CreateGUIInfo requires maxGads and maxMenus to allocate enough memory to
hold pointers to all gadgets and for the NewMenu structures.
Unfortunately, after defining here, these values can't be changed later on,
so choose a huge enough number. If you use @{" noGadgets " LINK SSTRUCT-Constants} resp @{" noMenu " LINK SSTRUCT-Constants}, you
can't create any gadgets resp menus for this window.
There are currently no more than 256 gadgets or menu items allowed !

When using version 38.0 you should use @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} instead,
because CreateGUIInfo has some @{" minor bugs " LINK SCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE SFCT-CreateGUIInfoTags "CreateGUIInfoTags (V38.0) / CreateGUIInfoTagList (V38.1)"

A new @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} will be allocated and all important
fields will be set

      @{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *CreateGUIInfoTags(struct Window *window{A0},
                                          WORD   maxGads{D0},
                                          WORD   maxMenus{D1},
                                          ULONG  tagitem, tagdata,...{A1});

      @{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *CreateGUIInfoTagList(struct Window *window{A0},
                                             WORD   maxGads{D0},
                                             WORD   maxMenus{D1},
                                             struct TagItem *tags{A1});


      window    For this window is the GUI
      maxGads   Maximal amount of gadgets or @{" noGadgets " LINK SSTRUCT-Constants}
      maxMenus  Maximal amount of menu items or @{" noMenu " LINK SSTRUCT-Constants}

CreateGUIInfoTags requires maxGads and maxMenus to allocate enough memory
to hold pointers to all gadgets and for the NewMenu structures.
Unfortunately, after defining here, these values can't be changed later on,
so choose a huge enough number. If you use @{" noGadgets " LINK SSTRUCT-Constants} resp @{" noMenu " LINK SSTRUCT-Constants}, you
can't create any gadgets resp menus for this window.
There are currently no more than 256 gadgets or menu items allowed !

Replaces @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} under version 38.0 with the extention
of some useful @{" special tags " LINK SSTRUCT-GUITags}.
Furthermore the @{" menuFont field " LINK SSTRUCT-GUIInfo-menuFont} will be set to the font of the
screen. If you now change the TextAttr structure of the @{" font field " LINK SSTRUCT-GUIInfo-font}
this then only concerns the gadgets but not the menus !
When using version 38.0 you should use this instead of @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo},
because CreateGUIInfo has some @{" minor bugs " LINK SCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE SFCT-CreateSpecialGadget "CreateSpecialGadget (V38.0) / CreateSpecialGadgetA (V38.0)"

Create a new gadget

      void CreateSpecialGadget(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                               WORD   left{D0},
                               WORD   top{D1},
                               WORD   width{D2},
                               WORD   height{D3},
                               ULONG  kind{D4},
                               ULONG  tagitem, tagdata, ...{A1});


      void CreateSpecialGadgetA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                                WORD   left{D0},
                                WORD   top{D1},
                                WORD   width{D2},
                                WORD   height{D3},
                                ULONG  kind{D4},
                                struct TagItem tags{A1});

CreateSpecialGadget is also a replacement for GadToolsL.CreateGadgetA
as @{" CreateGadget " LINK SFCT-CreateGadget} or @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull}.
But before version 38.1 CreateSpecialGadget can only create GUITools
gadgets. All other gadget kinds must be created using the other
gadget creating functions.
Starting with version 38.1 this exception is removed.
CreateSpecialGadget uses the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad} to create the gadget.
Usually the gadget created with CreateSpecialGadget has no text. But
you can pass a text to it together with some other information using the
@{" newgad field " LINK SSTRUCT-GUIInfo-newgad} of the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}. It is also possible
to use the @{" SgTags " LINK SSTRUCT-SgTags} to do.
Because CreateSpecialGadget has no return value, there is no possibility
to check if the gadget could be created or not. A appropriate error
code is given when calling @{" SetGUI " LINK SFCT-SetGUI}.
The gadget creating functions of GUITools do some extra work which is
explained in the chapter @{" Creating gadgets " LINK SCHAP-CreatingGadgets}.
In this chapter you will also find some information about the GUITools
gadgets and how to use them.

See also: @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}

Notice: CreateSpecialGadgetA is the new name for the obsolete
        CreateSpecialGadgetTag !

@ENDNODE

@NODE SFCT-DoResizing "DoResizing (V38.1)"

Resize all gadgets using the gadget description flags

      void DoResizing(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

The new sizes and positions will be calculated and can now be displayed
using @{" RedrawGadgets " LINK SFCT-RedrawGadgets}.

See also: @{" Creating gadgets " LINK SCHAP-CreatingGadgets}, @{" Resizable gadgets " LINK SCHAP-ResizableGadgets}

@ENDNODE

@NODE SFCT-DrawBox "DrawBox (V38.0)"

Draws a bevelled box which can be recessed or raised

       void DrawBox(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                    WORD   left{D0},
                    WORD   top{D1},
                    WORD   width{D2},
                    WORD   height{D3},
                    UBYTE  recessed{D4});

@ENDNODE

@NODE SFCT-EmptyIntMsgPort "EmptyIntMsgPort"

Removes all outstanding messages

      void EmptyIntMsgPort(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

@ENDNODE

@NODE SFCT-EndRefresh "EndRefresh (V38.0)"

Replacement for GadTools.GTEndRefresh

      void EndRefresh(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                      UBYTE  complete{D0});

You must use this function instead of GadTools.GTEndRefresh together
with @{" BeginRefresh " LINK SFCT-BeginRefresh}, because GUITools does some extra refreshing
e.g. for the GUITools gadgets.
If you have set the @{" GUI_RefreshWindow tag " LINK SSTRUCT-GUITags} or the
@{" GUI_ResizableGads tag" LINK SSTRUCT-GUITags} with @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} the window
frame will also be refreshed using the RefreshWindowFrame function of
the intuition.library.

See also: @{" GFLG_DoRefresh flag " LINK SSTRUCT-GUIInfoFlagSet}

@ENDNODE

@NODE SFCT-FreeGUIInfo "FreeGUIInfo"

Free a GUIInfo structure, remove all gadgets, menus and resources

      void FreeGUIInfo(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

This function removes first all gadgets and the menu and then frees
the GUIInfo structure.
If you allocated the structure using @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} and you set the
@{" GUI_RestoreProcessWindow tag " LINK SSTRUCT-GUITags} to a value of TRUE, the pr_WindowPtr field
of the process structure will be restored.

See also: @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo}

@ENDNODE

@NODE SFCT-GADDESC "GADDESC macro (V38.1) / GUIToolsMacros"

  ULONG GADDESC(UBYTE left, top, width, height);

This macro builds the data for the @{" SG_GadgetDesc tag " LINK SSTRUCT-SgTags}. It does the
following calculation:

  return (@{" shiftLeft " LINK SSTRUCT-Constants}*left + @{" shiftTop " LINK SSTRUCT-Constants}*top + @{" shiftWidth " LINK SSTRUCT-Constants}*width + height);

See also: @{" Resizable Gadgets " LINK SCHAP-ResizableGadgets}

@ENDNODE

@NODE SFCT-GADOBJS "GADOBJS macro (V38.1) / GUIToolsMacros"

  ULONG GADOBJS(UBYTE left, top, width, height);

This macro builds the data for the @{" SG_GadgetObjects tag " LINK SSTRUCT-SgTags}. It does the
following calculation:

  return (@{" shiftLeft " LINK SSTRUCT-Constants}*left + @{" shiftTop " LINK SSTRUCT-Constants}*top + @{" shiftWidth " LINK SSTRUCT-Constants}*width + height);

See also: @{" Resizable Gadgets " LINK SCHAP-ResizableGadgets}

@ENDNODE

@NODE SFCT-GadgetStatus "GadgetStatus"

Disables or enables a gadget

      void GadgetStatus(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                        WORD   nbr{D0},
                        UBYTE  status{D1});

      nbr     the gadget number of the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets}
      status  TRUE : gadget enabled
              FALSE: gadget disabled

Gadtools gadgets will be switched using the GA_Disabled tag. For
GENERIC_KIND gadgets the intuition.library functions OnGadget resp
OffGadget are used.

@ENDNODE

@NODE SFCT-GadWithKey "GadWithKey  (V38.0)"

Pretends if the gadget was activated using a key equivalent

      void GadWithKey(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                      WORD   nbr{D0},
                      UBYTE  shift{D1});

      nbr    gadget number in the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets}
      shift  was the shift key pressed ?

The majority of applications don't need to call this function, because
it will be automatically called from @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg}.
But it can be used to process some rawkeys, like the F-keys.
If you set a notify for this gadget, GadWithKey does the same functions
@{" HandleIntMsg " LINK SFCT-HandleIntMsg} does for them (except for INTEGER_KIND and STRING_KIND).
The @{" gadNbr field " LINK SSTRUCT-GUIInfo-gadNbr} and the @{" gadID field " LINK SSTRUCT-GUIInfo-gadID} will contain the appropriate
values. If the gadget is disabled, no action will happen and the
@{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass} contains IDCMPFlagSet{}. The changes will be made
automatically visible using ModifyGadget !

  gadget kind                action
-------------------------------------------------------------------------

  BUTTON_KIND        msgClass := IDCMP_GADGETUP
                     cardCode := 0

  STRING_KIND,       activates the gadget for input
  INTEGER_KIND       msgClass := gagdetDown
                     cardCode := 0

  CHECKBOX_KIND      changes the state
                     msgClass := IDCMP_GADGETUP
                     boolCode contains the new state

  MX_KIND            choose the next value without shift and with shift
                     the previous one
                     msgClass := IDCMP_GADGETDOWN
                     cardCode := new entry number

  CYCLE_KIND         choose the next value without shift and with shift
                     the previous one
                     msgClass := IDCMP_GADGETUP
                     cardCode := new entry number

  SLIDER_KIND,       without shift one position forward, with shift
  SCROLLER_KIND      one backwards
                     msgClass := IDCMP_GADGETUP
                     intCode  := new position (new level resp new top)


  LISTVIEW_KIND      without shift next entry, with shift the previous
                     one. If no entry wasn't selected yet, without
                     shift the first and with shift the last one is
                     selected.
                     msgClass := IDCMP_GADGETUP
                     cardCode := new entry number

                     If the GFLG_LVKeyClearTime was set during the creation
                     the sec field of the IntuiMessage will be set to
                     zero. This is to avoid problems using DoubleClick,
                     because you only have to check the entry for zero.

  PALETTE_KIND       without shift the next colour will be selected,
                     with shift the previous one.
                     msgClass := IDCMP_GADGETUP
                     cardCode := new colour number

@ENDNODE

@NODE SFCT-GetIntMsg "GetIntMsg"

Get an IDCMP message

      UBYTE GetIntMsg(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

GetIntMsg tries to get a message from the port specified in the
@{" port field " LINK SSTRUCT-GUIInfo-port}.
If there is an outstanding message, it gets them, replies it and copies
it to the @{" im field " LINK SSTRUCT-GUIInfo-im} and then returns TRUE. Otherwise if there is no
message FALSE will be returned !
If the @{" GFLG_NoHandleIntMsgCall flag " LINK SSTRUCT-GUIInfoFlagSet} isn't set @{" HandleIntMsg " LINK SFCT-HandleIntMsg} will be
called.
If the @{" GFLG_InternMsgHandling flag " LINK SSTRUCT-GUIInfoFlagSet} is set, and @{" HandleIntMsg " LINK SFCT-HandleIntMsg} could
process the message internal, the return value will also be FALSE !
Notice, without a call to @{" HandleIntMsg " LINK SFCT-HandleIntMsg} it is not allowed to check the
extra message information fields of the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} !

See also: @{" WaitIntMsg " LINK SFCT-WaitIntMsg}

@ENDNODE

@NODE SFCT-GetOwnFont "GetOwnFont"

Opens a font

      struct TextFont *GetOwnFont(STRPTR name{A0},
                                  UWORD  size{D0},
                                  struct TextAttr *font{A1});

      font   pointer to a TextAttr structure which will be filled by
             GetOwnFont. This pointer can be used to set a screen's
             font using @{" OpenIntScreen " LINK SFCT-OpenIntScreen} / @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}.
             If you don't need this TextAttr structure set font to
             NULL.

See also: @{" RemOwnFont " LINK SFCT-RemOwnFont}, @{" TopazAttr() " LINK SFCT-TopazAttr}, @{" Dealing with fonts " LINK SCHAP-DealingFonts}

@ENDNODE

@NODE SFCT-HandleIntMsg "HandleIntMsg"

Process an IDCMP message

      void HandleIntMsg(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

This function is automatically called by @{" GetIntMsg " LINK SFCT-GetIntMsg} or @{" WaitIntMsg " LINK SFCT-WaitIntMsg} if
the @{" GFLG_NoHandleIntMsgCall " LINK SSTRUCT-GUIInfoFlagSet} flag isn't set.
The majority of applications will no call this function by themselve. It
is only important if you get your message from shared ports, where it
is not possible to use @{" GetIntMsg " LINK SFCT-GetIntMsg} or @{" WaitIntMsg " LINK SFCT-WaitIntMsg}. In this case you have
to copy the message to the @{" im field " LINK SSTRUCT-GUIInfo-im}!


HandleIntMsg processes the IntuiMessages as follows:

The @{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass} gets a copy of the im.class field. And the
cardCode, intCode ... fields get a copy of the @{" im.Code field " LINK SSTRUCT-GUIInfo-im}.
If GUITools could process the message internal, e.g. for
@{" key equivalents " LINK SCHAP-KeyEquivalents}, the msgClass and the code fields will contain
different values from the fields in the @{" im structure " LINK SSTRUCT-GUIInfo-im} , because
GUITools will change them for easier handling. The @{" im field " LINK SSTRUCT-GUIInfo-im}
will always contain the unchanged message !
So please always use the @{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass} for easier handling !


HandleIntMsg does the following actions

    IDCMP message                     action
-------------------------------------------------------------------------

  IDCMP_GADGETUP,    The @{" gadget field " LINK SSTRUCT-GUIInfo-gadget} contains the event gadget and the
  IDCMP_GADGETDOWN,  @{" gadID field " LINK SSTRUCT-GUIInfo-gadID} the gadget ID. Starting with version
  IDCMP_MOUSEMOVE    38.0 the @{" gadNbr field " LINK SSTRUCT-GUIInfo-gadNbr} contains the gadget number
                     for use with the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets} !

                     INTEGER_KIND,  If the @{" GFLG_LinkEntryGads flag " LINK SSTRUCT-GUIInfoFlagSet} was
                     STRING_KIND    set during the creation, the next entry
                                    gadget will be activated.

                     All the other actions will only take place if a
                     notify was set for this gadget:

                     INTEGER_KIND,  If the @{" GFLG_AutoUpdateEGads flag " LINK SSTRUCT-GUIInfoFlagSet} is
                     STRING_KIND    set the belonging variables get the
                                    new value.

                     CHECKBOX_KIND  Updates the belonging variable. If
                                    running under version 38.0 or higher
                                    the boolCode field will contain the
                                    new state.

                     CYCLE_KIND,    Update the belonging variable. Usually
                     SLIDER_KIND,   there will be no need to check these
                     SCROLLER_KIND, messages. It is sufficient to check
                     LISTVIEW_KIND, the values of the variables when they
                     PALETTE_KIND   are required.

  IDCMP_GADGETDOWN   All these actions will only take place if a notify
                     was set for this gadget:

                     MX_KIND,       Update the belonging variable. Usually
                     SLIDER_KIND,   there will be no need to check these
                     SCROLLER_KIND  messages. It is sufficient to check
                                    the values of the variables when they
                                    are required.

  IDCMP_MOUSEMOVE    All these actions will only take place if a notify
                     was set for this gadget:

                     SCROLLER_KIND, Update the belonging variable. Usually
                     SLIDER_KIND    there will be no need to check these
                                    messages. It is sufficient to check
                                    the values of the variables when they
                                    are required.

  IDCMP_MENUPICK     GUITools calculates the menu number and starting
                     with version 38.0 the @{" itemAdr field " LINK SSTRUCT-GUIInfo-itemAdr} contains a
                     pointer to the MenuItem structure.
                     If @{" GFLG_CallMenuData " LINK SSTRUCT-GUIInfoFlagSet} is set, the function given in
                     the userData field will be automatically called.
                     This function should return TRUE resp 1, if more
                     messages should be processed, or FALSE resp 0, if
                     the message loop should be exited.

                     All menuNull messages will be ignored and the
                     @{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass} will contain the value 0 !

                     See also: @{" Creating menus " LINK SCHAP-CreatingMenus}

  IDCMP_MENUHELP     GUITools calculates the menu number and starting
                     with version 38.0 the @{" itemAdr field " LINK SSTRUCT-GUIInfo-itemAdr} contains a
                     pointer to the MenuItem structure if possible.

  IDCMP_VANILLAKEY   If the @{" GFLG_ConvertKeys flag " LINK SSTRUCT-GUIInfoFlagSet} is set,
                     @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg} is now called to
                     handle @{" key equivalents " LINK SCHAP-KeyEquivalents}.

  IDCMP_REFRESHWINDOW If the @{" GFLG_DoRefresh flag " LINK SSTRUCT-GUIInfoFlagSet} is set, @{" BeginRefresh " LINK SFCT-BeginRefresh}
                      followed by @{" EndRefresh(TRUE) " LINK SFCT-EndRefresh} is called to do the
                      refreshing.
                      The application doesn't get the IDCMP_REFRESHWINDOW
                      message.

  IDCMP_NEWSIZE      If the @{" GFLG_DoResizing flag " LINK SSTRUCT-GUIInfoFlagSet} is set and the gadget
                     descriptions are used, @{" DoResizing " LINK SFCT-DoResizing} followed by
                     @{" RedrawGadgets " LINK SFCT-RedrawGadgets} will be called.
                     If the call to @{" RedrawGadgets " LINK SFCT-RedrawGadgets} fails the user gets
                     the IDCMP_NEWSIZE message, otherwise not !
                     In addition the @{" GUI_ResizableGads tag " LINK SSTRUCT-GUITags} must be set !

@ENDNODE

@NODE SFCT-MakeMenuEntry "MakeMenuEntry"

Creates a menu item

      void MakeMenuEntry(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                         UBYTE  type{D0},
                         STRPTR text{A1},
                         STRPTR key{A2});

      type     nmTitle, nmItem, nmSub  etc
      text     pointer to the menu text
      key      pointer to the key short cut or NULL. Notice, this is a
               pointer to a string and not to a char !

It is possible to specify the menu item more using the @{" newMenus field " LINK SSTRUCT-GUIInfo-newMenus}
or the @{" menuAdr field " LINK SSTRUCT-GUIInfo-menuAdr}.

See also: @{" Creating menus " LINK SCHAP-CreatingMenus}, @{" actmenu field " LINK SSTRUCT-GUIInfo-actmenu}

@ENDNODE

@NODE SFCT-ModifyGadget "ModifyGadget / ModifyGadgetA"

Replacement for GadToolsL.GTSetGadgetAttrs - Modifies gadget attributes

      void ModifyGadget(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                        WORD   nbr{D0},
                        ULONG  tagitem, tagdata, ...{A1});


      void ModifyGadgetA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                         WORD   nbr{D0},
                         struct TagItem *tags{A1});

      nbr     the gadget number in the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets}
      tags    a tag list with the new attributes

Notice: ModifyGadgetA is the new name for the obsolete ModifyGadgetTag !

@ENDNODE

@NODE SFCT-NewFontAllGadgets "NewFontAllGadgets (V38.0)"

Changes the font for all gadgets

       void NewFontAllGadgets(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                              struct TextAttr *font{A1});

This change will only be visible after a call to @{" RedrawGadgets " LINK SFCT-RedrawGadgets}.

See also: @{" NewGadgetFont " LINK SFCT-NewGadgetFont}

@ENDNODE

@NODE SFCT-NewGadgetFont "NewGadgetFont (V38.0)"

Change the font of one gadget

       void NewGadgetFont(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                          WORD   nbr{D0},
                          struct TextAttr *font{A1});

This change will only be visible after a call to @{" RedrawGadgets " LINK SFCT-RedrawGadgets}.

See also: @{" NewFontAllGadgets " LINK SFCT-NewFontAllGadgets}

@ENDNODE

@NODE SFCT-NewGadgetText "NewGadgetText (V38.0)"

A new text for one gadget

       void NewGadgetText(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} gui{A0},
                          WORD   nbr{D0},
                          STRPTR text{A1});

This change will only be visible after a call to @{" RedrawGadgets " LINK SFCT-RedrawGadgets}.

@ENDNODE

@NODE SFCT-OpenIntScreen "OpenIntScreen"

Open the defined screen

      struct Screen *OpenIntScreen(ULONG  id{D0},
                                   WORD   depth{D1},
                                   STRPTR name{A0},
                                   struct TextAttr * font{A1});

      id     screen display ID as defined in graphics/displayinfo.h or one
             of the following predefined ones:
             @{" hiresPalID " LINK SSTRUCT-Constants}    a hires screen using pal monitor
             @{" hiresID " LINK SSTRUCT-Constants}       a hires screen using default monitor
             @{" loresPalID " LINK SSTRUCT-Constants}    a lores screen using pal monitor
             @{" loresID " LINK SSTRUCT-Constants}       a lores screen using default monitor
      font   NULL for default font or an own TextAttr structure

The following tag list will be created and then passed to OpenScreenTags
of the intuition.library:

       SA_Pens      := -1
       SA_Depth     := depth
       SA_DisplayID := id
       SA_Title     := name
       SA_Font      := font

See also: @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}, @{" CloseIntScreen " LINK SFCT-CloseIntScreen}

@ENDNODE

@NODE SFCT-OpenIntScreenTags "OpenIntScreenTags (V38.0) / OpenIntScreenTagList (V38.0)"

Open the defined screen

      struct Screen *OpenIntScreenTags(ULONG  id{D0},
                                       WORD   depth{D1},
                                       STRPTR name{A0},
                                       struct TextAttr * font{A1},
                                       ULONG  tagitem, tagdata, ...{A2});


      struct Screen *OpenIntScreenTagList(ULONG  id{D0},
                                          WORD   depth{D1},
                                          STRPTR name{A0},
                                          struct TextAttr * font{A1},
                                          strcut TagItem  * tags{A2});

      id     screen display ID as defined in graphics/displayinfo.h or
             one of the following predefined ones:
             @{" hiresPalID " LINK SSTRUCT-Constants}    a hires screen using pal monitor
             @{" hiresID " LINK SSTRUCT-Constants}       a hires screen using default monitor
             @{" loresPalID " LINK SSTRUCT-Constants}    a lores screen using pal monitor
             @{" loresID " LINK SSTRUCT-Constants}       a lores screen using default monitor
      font   NULL for default font or an own TextAttr structure
      tags   pointer to an own tag list (or NULL) to specify the screen
             more precise

The following tag list will be created and your own tag list will be
chained to it and then passed to OpenScreenTags of the intuition.library:

       SA_Pens      := -1
       SA_Depth     := depth
       SA_DisplayID := id
       SA_Title     := name
       SA_Font      := font

See also: @{" OpenIntScreen " LINK SFCT-OpenIntScreen}, @{" CloseIntScreen " LINK SFCT-CloseIntScreen}

@ENDNODE

@NODE SFCT-OpenIntWindow "OpenIntWindow"

Open a window on the specified screen

      struct Window *OpenIntWindow(WORD   left{D0},
                                   WORD   top{D1},
                                   WORD   width{D2},
                                   WORD   height{D3},
                                   STRPTR name{A0},
                                   ULONG  idcmpFlags{D4},
                                   ULONG  windowFlags{D5},
                                   struct Screen *screen{A1});

      width       width or @{" asScreen " LINK SSTRUCT-Constants} to make the window as wide as the
                  screen border
      height      height or @{" asScreen " LINK SSTRUCT-Constants} to make the window as tall as
                  the screen border
      screen      pointer to your own screen or NULL to open the window on
                  the default public screen

The following tag list will be created and then passed to OpenWindowTags
of the intuition.library:

      WA_Title       := name
      WA_ScreenTitle := name
      WA_Left     := left
      WA_Top      := top
      WA_Width    := width   (resp screen->Width  -left with @{" asScreen " LINK SSTRUCT-Constants})
      WA_Height   := height  (resp screen->Height -top  with @{" asScreen " LINK SSTRUCT-Constants})
      WA_IDCMP    := idcmpFlags
      WA_Flags    := windowFlags

      Using an own screen:

      WA_CustomScreen := screen

      Using NULL for the defaul public screen:

      WA_PubScreen         := default public screen
      WA_BubScreenFallBack := TRUE

See also: @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags}, @{" Problems with OpenIntWindow " LINK SCHAP-Problems-OpenIntWindow},
          @{" CloseIntWindow " LINK SFCT-CloseIntWindow}

@ENDNODE

@NODE SFCT-OpenIntWindowTags "OpenIntWindowTags (V38.0) / OpenIntWindowTagList (V38.0)"

Open a window on the specified screen

      struct Window *OpenIntWindowTagList(WORD   left{D0},
                                          WORD   top{D1},
                                          WORD   width{D2},
                                          WORD   height{D3},
                                          STRPTR name{A0},
                                          ULONG  idcmpFlags{D4},
                                          ULONG  windowFlags{D5},
                                          struct Screen *screen{A1},
                                          struct TagItem *tags{A2});


      struct Window *OpenIntWindowTags(WORD   left{D0},
                                       WORD   top{D1},
                                       WORD   width{D2},
                                       WORD   height{D3},
                                       STRPTR name{A0},
                                       ULONG  idcmpFlags{D4},
                                       ULONG  windowFlags{D5},
                                       struct Screen *screen{A1},
                                       ULONG  tagitem, tagdata,...{A2});

      width       width or @{" asScreen " LINK SSTRUCT-Constants} to make the window as wide as the
                  screen border
      height      height or @{" asScreen " LINK SSTRUCT-Constants} to make the window as tall as
                  the screen border
      screen      pointer to your own screen or NULL to open the window on
                  the default public screen
      tags        pointer to an own tag list (or NULL) to specify the window
                  more precise

The following tag list will be created and your own tag list will be
chained to it and then passed to OpenWindowTags of the intuition.library:

      WA_Title  := name
      WA_Left   := left
      WA_Top    := top
      WA_Width  := width   (resp screen->Width  -left with @{" asScreen " LINK SSTRUCT-Constants})
      WA_Height := height  (resp screen->Height -top  with @{" asScreen " LINK SSTRUCT-Constants})
      WA_IDCMP  := idcmpFlags
      WA_Flags  := windowFlags

      Using an own screen:

      WA_CustomScreen := screen

      Using NULL for the defaul public screen:

      WA_PubScreen         := default public screen
      WA_BubScreenFallBack := TRUE

ATTENTION: In opposite to @{" OpenIntWindow " LINK SFCT-OpenIntWindow} OpenIntWindowTags does not
           use the WA_ScreenTitle tag anymore !

See also: @{" CloseIntWindow " LINK SFCT-CloseIntWindow}, @{" Problems with OpenIntWindow " LINK SCHAP-Problems-OpenIntWindow}

@ENDNODE

@NODE SFCT-RedrawGadgets "RedrawGadgets (V38.0)"

Remove all gadgets, calculate them new and redraw them

      void RedrawGadgets(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                         UBYTE  setGads{D0});

All gadgets will be removed and then created totally new using the
new values set by ResizeGadget, NewGadgetFont, NewFontAllGadgets
and NewGadgetText.
If setGads is not set, you can make some changes to the gadget list,
which is required e.g. for GENERIC_KIND. Then you have to call @{" SetGUI " LINK SFCT-SetGUI}
to make the changes visible. Otherwise RedrawGadgets calls @{" SetGUI " LINK SFCT-SetGUI}.
Notice, this function only works if the @{" GUI_ResizableGads tag " LINK SSTRUCT-GUITags} is set
to the value of TRUE using @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.
The return value is the same as by @{" SetGUI " LINK SFCT-SetGUI}. But notice, if setGads
is FALSE, you get also @{" guiSet " LINK SSTRUCT-Constants} although the GUI isn't set yet.
In addition RedrawGadgets can return @{" rdGUIContextError " LINK SSTRUCT-Constants}.
This means a call to CreateContext failt !
If you don't get @{" guiSet " LINK SSTRUCT-Constants}, it isn't possible to create the GUI anymore.
Exit your program then safely and free the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} !

BUGS

- The RedrawGadgets function of version 38.0 is not able to resize a list-
  view gadget which uses a custom string kind gadget to display the selected
  entry ! Set RedrawGadgets function will usually return an error when
  trying to resize !
  This bug is fixed in version 38.1.
- When resizing a listview gadget with RedrawGadgets always the last entry
  in the list will be always displayed as selected !
  This bug is fixed in version 38.1.
- The contents of entry gadgets will disappear resp set to the default
  when they are resized with RedrawGadgets.
  This is also fixed in version 38.1.

- There is still a problem with RedrawGadgets and listview gadgets. If the
  listview gadget has a custom string gadget to display the contents, and
  the user has first selected an entry, and then changed this in the
  string gadget and now resizes, the contents in the string gadget is set
  to the first choosen entry !

@ENDNODE

@NODE SFCT-RedrawMenu "RedrawMenu (V38.0)"

Remove menu and redraw then it

      WORD RedrawMenu(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

First the old menu will be removed and then set again using the old
structure, but perhaps with a new @{" menuFont entry " LINK SSTRUCT-GUIInfo-menuFont} to make the menu fit
to another font or to display the menu with new text perhaps in a
different language.
To achieve this you have to change the according @{" newMenus fields " LINK SSTRUCT-GUIInfo-newMenus}!
The return value is the same as for @{" SetGUI " LINK SFCT-SetGUI} !
Notice, it is not possible to change the menu structure ! In this case
you have to remove the menu and define a new one !

@ENDNODE

@NODE SFCT-RemoveGadgets "RemoveGadgets (V38.0)"

Remove all gadgets

      void RemoveGadgets(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                         UBYE   erase{D0});

The gadgets are still visible, because they are only removed from the
gadget list of the window ! But you can call @{" ClearWindow " LINK SFCT-ClearWindow} to remove
them.
If you set erase to TRUE, the gadgets are removed forever. You can
now define new gadgets using the creating functions.
But if you set it to FALSE it is possible to redraw the gadgets using
@{" SetGUI " LINK SFCT-SetGUI}. But in the meantime you can't create/add new gadgets !
Notice, all information about the old gadgets is gone when set erase to
TRUE !

@ENDNODE

@NODE SFCT-RemoveMenu "RemoveMenu (V38.0)"

Remove the menu

       void RemoveMenu(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                       UBYTE  erase{D0});

If you set erase to TRUE the menu is removed completely and the used
memory is freed. Now you can define a totaly new menu and then show
it with @{" SetGUI " LINK SFCT-SetGUI}.
If you set erase to FALSE, the menu is only removed from the window.
You can set it again using @{" SetGUI " LINK SFCT-SetGUI} anytime. But is not allowed to call
@{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} in the meantime to change the menu structure !
Notice, all information about the old menu is gone when set erase to
TRUE !

@ENDNODE

@NODE SFCT-RemOwnFont "RemOwnFont"

Closes a font opened with @{" GetOwnFont " LINK SFCT-GetOwnFont}

      void RemOwnFont(struct TextFont *font{A0});

See also: @{" TopazAttr() " LINK SFCT-TopazAttr}, @{" Dealing with fonts " LINK SCHAP-DealingFonts}

@ENDNODE

@NODE SFCT-ResizeGadget "ResizeGadget (V38.0)"

Define new position and size of a gadget

      void ResizeGadget(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                        WORD   nbr{D0},
                        WORD   left{D1},
                        WORD   top{D2},
                        WORD   width{D3},
                        WORD   height{D4});

This change is only visible after a call to @{" RedrawGadgets " LINK SFCT-RedrawGadgets}. If you want
some values not to change use @{" preserve " LINK SSTRUCT-Constants}.

Starting with version 38.1 the @{" gadget field " LINK SSTRUCT-GUIInfo-gadget} contains a pointer to the
changed gadget.

@ENDNODE

@NODE SFCT-SetGUI "SetGUI"

Set gadgets and menu

      WORD SetGUI(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

Possible return values:

         @{" guiSet " LINK SSTRUCT-Constants}             Everything alright, go on
         @{" gadgetError " LINK SSTRUCT-Constants}        Error creating the gadgets
         @{" menuError " LINK SSTRUCT-Constants}          Error creating the menu
         @{" memError " LINK SSTRUCT-Constants}           Not enough memory

/*38.0*/ @{" gadKeyDefTwice " LINK SSTRUCT-Constants}     Same key equivalent for two gadgets
/*38.0*/ @{" menuSetError " LINK SSTRUCT-Constants}       Error calling SetMenuStrip
/*38.0*/ @{" menuLayoutError " LINK SSTRUCT-Constants}    Error calling LayoutMenusA
/*38.0*/ @{" gadKeyNotAllowed " LINK SSTRUCT-Constants}   Key equivalent is not a letter
/*38.0*/ @{" tooManyGadsError " LINK SSTRUCT-Constants}   More gadgets than specified when creating the
                             @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}
/*38.0*/ @{" tooManyMenusError " LINK SSTRUCT-Constants}  More menu items than specified when creating
                              the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}
/*38.0*/ @{" gadKeyNotFound " LINK SSTRUCT-Constants}     gaUnderscore-Tag exists, but the character
                              is missing in the text and the
                              @{" GFLG_VanillaKeysNotify flag " LINK SSTRUCT-GUIInfoFlagSet} is set
/*38.0*/ @{" noGadToolsGadKind " LINK SSTRUCT-Constants}  The gadget kind is no gadtools gadget
/*38.0*/ @{" noGUIToolsGadKind " LINK SSTRUCT-Constants}  The gadget kind is no GUITools gadget

Only if you get @{" guiSet " LINK SSTRUCT-Constants}, you can go on using the GUI, otherwise you can't
use the GUI.
Now calls to the gadget creating functions or @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} have no
effect. If an error occured don't forget to call @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo} !
Don't call SetGUI again. After the GUI is set it is not possible to
add further gadgets or menu items !
Starting with version 38.0 it is allowed to call SetGUI more than one
time, e.g. to install first only a menu and then later when required
some gadgets. For this, first create the menu using @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} and
call SetGUI. Then later create the gadgets and call SetGUI again.

@ENDNODE

@NODE SFCT-SetProcessWindow "SetProcessWindow (V38.0)"

Redirect the requesters

       struct Window *SetProcessWindow(struct Window *window{A0});

The pr_WindowPtr field of the process structure will be set to window and
the old value is returned. You should save the return value to restore
it before exiting your program !

See also: @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}, @{" GUITags " LINK SSTRUCT-GUITags}, @{" Using requesters " LINK SCHAP-UsingRequesters}, @{" SimpleReq " LINK SFCT-SimpleReq},
          @{" ShowRequester " LINK SFCT-ShowRequester}

@ENDNODE

@NODE SFCT-ShowRequester "ShowRequester (V38.0) / ShowRequesterA (V38.0)"

Show a requester

       LONG ShowRequester(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                          STRPTR text{A1},
                          ULONG  kind{D0},
                          ULONG  tagitem, tagdata, ...{A2});


       LONG ShowRequesterA(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                           STRPTR text{A1},
                           ULONG  kind{D0},
                           struct TagItem *tags{A2});


       text    The requester text. This can be multiple lines divided by
               '\n' !
       kind    @{" requester kind " LINK SSTRUCT-Constants}
       tags    Pointer to a tag list. See @{" SrTags " LINK SSTRUCT-SrTags}

Usually the requester appears on the window specified by the GUIInfo
structure. But it is also possible to set the gui parameter to NULL.
Then the requester will appear on the window specified by the
pr_WindowPtr field in the process structure.
In addition you can change the window by using the @{" SR_ReqWindow tag " LINK SSTRUCT-SrTags}.


See also: @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}, @{" Using requesters " LINK SCHAP-UsingRequesters}, @{" SimpleReq " LINK SFCT-SimpleReq}

Notice: ShowRequesterA is the new name for the obsolete
        ShowRequesterTag !

@ENDNODE

@NODE SFCT-SimpleReq "SimpleReq (V38.0)"

Show a requester

       LONG SimpleReq(STRPTR text{A0},
                      ULONG  kind{D0});

SimpleReq calls @{" ShowRequester " LINK SFCT-ShowRequester}(NULL, text, kind, NULL) to simplify
handling requesters.

See also: @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}, @{" Using requesters " LINK SCHAP-UsingRequesters}

@ENDNODE

@NODE SFCT-TopazAttr "TopazAttr"

Returns a pointer to a valid TextAttr structure for the topaz/8 font

      struct TextAttr *TopazAttr(void);

See also: @{" GetOwnFont " LINK SFCT-GetOwnFont}, @{" RemOwnFont " LINK SFCT-RemOwnFont}, @{" Dealing with fonts " LINK SCHAP-DealingFonts}

@ENDNODE

@NODE SFCT-UpdateEGad "UpdateEGad"

Copy the contents of an entry gadget into the variable

      void UpdateEGad(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                      WORD   nbr{D0});

      nbr     the gadget number in the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets}

A notify must be set for this gadget !

See also: @{" UpdateEntryGadgets " LINK SFCT-UpdateEntryGadgets}

@ENDNODE

@NODE SFCT-UpdateEntryGadgets "UpdateEntryGadgets"

Copy the contents all entry gadgets into the variables

      void UpdateEntryGadgets(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

This uses @{" UpdateEGad " LINK SFCT-UpdateEGad} for each entry gadget !
Using this function you can solve the problem when a user makes input
to an entry gadget and then e.g. clicks a button gadget without pressing
RETURN before. In this case intuition doesn't send a IDCMP_GADGETUP message,
so the value of an entry gadget changed without getting any message !
So it is important to verify all entry gadgets when doing any action !
Using this function together with the notify concept, you have nothing
to do, but calling this function when the actual values are required.

See also: @{" UpdateEGad " LINK SFCT-UpdateEGad}

@ENDNODE

@NODE SFCT-VarToGad "VarToGad (V38.0)"

Set the gadget to the value of the belonging variable

      void VarToGad(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0},
                    WORD   nbr{D0});

      nbr    gadget number in the @{"gadgets field " LINK SSTRUCT-GUIInfo-gadgets}

If you set a notify during the creation for this gadget, you can simply
change the value of the corresponding variable and then tell the GUI
by using VarToGad to display it using the appropriate gadget.
GUITools takes the value of the variable and then modifies the gadget.

See also: @{" AllVarsToGad " LINK SFCT-AllVarsToGad}, @{" GUIInfoFlagSet " LINK SSTRUCT-GUIInfoFlagSet}, @{" Creating gadgets " LINK SCHAP-CreatingGadgets}


@ENDNODE

@NODE SFCT-WaitIntMsg "WaitIntMsg"

Wait for an IDCMP message

      void WaitIntMsg(@{" struct GUIInfo " LINK SSTRUCT-GUIInfo} *gui{A0});

WaitIntMsg waits for an IntuiMessage, replies this and copies it into
the @{" im field " LINK SSTRUCT-GUIInfo-im}. WaitIntMsg uses the @{" port field " LINK SSTRUCT-GUIInfo-port} to get the message.
If the @{" GFLG_NoHandleIntMsgCall " LINK SSTRUCT-GUIInfoFlagSet} flag isn't set, @{" HandleIntMsg " LINK SFCT-HandleIntMsg} will be
called automatically.
Starting with version 38.0 if the @{" GFLG_InternMsgHandling flag " LINK SSTRUCT-GUIInfoFlagSet} is set, it
might be possible that WaitIntMsg handles some events internal without
returning them !
Notice, without a call to @{" HandleIntMsg " LINK SFCT-HandleIntMsg} it is not allowed to use the
extra message information fields of the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}!

See also: @{" GetIntMsg " LINK SFCT-GetIntMsg}

BUGS

- The WaitIntMsg function isn't able to handle several events which will
  appear at the same point of time ! Usually this doesn't happen with
  gadtools, but nevertheless this bug is fixed in version 38.1.

@ENDNODE

@NODE SSTRUCT-GUIInfo "The GUIInfo structure (V38.1)"

In version 38.1 of the guitools.library the GUIInfo structure has the
following entries:

      struct GUIInfo {
        struct Window   *@{" window " LINK SSTRUCT-GUIInfo-window};         /* read only  */
        struct Screen   *@{" screen " LINK SSTRUCT-GUIInfo-screen};         /* read only  */
        struct TextAttr  @{" font " LINK SSTRUCT-GUIInfo-font};           /* read/write */
        APTR             @{" visual " LINK SSTRUCT-GUIInfo-visual};         /* read only  */
        struct MsgPort  *@{" port " LINK SSTRUCT-GUIInfo-port};           /* read/write */
        struct Gadget   *@{" gadlist " LINK SSTRUCT-GUIInfo-gadlist};        /* read only  */
/*38.0*/struct DrawInfo *@{" drawinfo " LINK SSTRUCT-GUIInfo-drawinfo};       /* read only  */
        struct NewGadget @{" newgad " LINK SSTRUCT-GUIInfo-newgad};         /* read/write */
        WORD             @{" actgad " LINK SSTRUCT-GUIInfo-actgad};         /* read only  */
/*38.1*/WORD             @{" winIWidth " LINK SSTRUCT-GUIInfo-winISize};      /* read/write */
        struct GUIGadList  *@{" gadgets " LINK SSTRUCT-GUIInfo-gadgets};     /* read only  */

        struct Menu     *@{" menus " LINK SSTRUCT-GUIInfo-menus};          /* read only  */
        WORD             @{" actmenu " LINK SSTRUCT-GUIInfo-actmenu};        /* read only  */
/*38.1*/WORD             @{" winIHeight " LINK SSTRUCT-GUIInfo-winISize};     /* read/write */
        struct GUIMenuList *@{" newMenus " LINK SSTRUCT-GUIInfo-newMenus};    /* read/write */

        struct IntuiMessage @{" im " LINK SSTRUCT-GUIInfo-im};          /* read only  */
        union{
           struct gadmsg  gm;              /* read only  */
           struct menumsg mm;              /* read only */
        } im_un;
        ULONG            @{" flags " LINK SSTRUCT-GUIInfo-flags};          /* read/write */
        union {                            /* read only  */
/*38.0*/   UWORD @{" cardCode " LINK SSTRUCT-GUIInfo-CodeEntries};
/*38.0*/   WORD  @{" intCode " LINK SSTRUCT-GUIInfo-CodeEntries};
/*38.0*/   struct oc {
              UBYTE @{" boolCode " LINK SSTRUCT-GUIInfo-CodeEntries};
              char  @{" charCode " LINK SSTRUCT-GUIInfo-CodeEntries};
           };
        } mc_un;

/*38.0*/WORD             @{" gadNbr " LINK SSTRUCT-GUIInfo-gadNbr};       /* read only  */
/*38.0*/struct TextAttr *@{" menuFont " LINK SSTRUCT-GUIInfo-menuFont};     /* read/write */
/*38.0*/APTR             @{" vanKeyHook " LINK SSTRUCT-GUIInfo-vanKeyHook};   /* read/write */
/*38.0*/ULONG            @{" msgClass " LINK SSTRUCT-GUIInfo-msgClass};     /* read only  */

        union {
/*38.0*/   struct MenuItem *@{" itemAdr " LINK SSTRUCT-GUIInfo-itemAdr};   /* read only  */
/*38.0*/   struct NewMenu  *@{" menuAdr " LINK SSTRUCT-GUIInfo-menuAdr};   /* read only  */
        } ma_un;

/*38.1*/APTR             @{" vanKeyFctData " LINK SSTRUCT-GUIInfo-vanKeyFctData};  /* read/write */
/*38.1*/APTR             @{" menuFctData " LINK SSTRUCT-GUIInfo-menuFctData};    /* read/write */
/*38.1*/APTR             @{" userData " LINK SSTRUCT-GUIInfo-userData};       /* read/write */
/*38.1*/APTR             @{" compilerReg " LINK SSTRUCT-GUIInfo-compilerReg};    /* read/write */
      };

With "read only" marked entries are (yes believe me) only for reading.
Don't write any data to them !
Please remember that not all entries are available in older versions
of the library. Don't touch these entries under older versions or
make any assumptions about its contents !
Please ever check the version of the library your program is using !

And now the structs with are used inside the GUITools structure:

      struct gadmsg {
        WORD   @{" gadID " LINK SSTRUCT-GUIInfo-gadID};                    /* read only */
        struct Gadget *@{" gadget " LINK SSTRUCT-GUIInfo-gadget};           /* read only */
      };

      struct menumsg {
        WORD   @{" menuNum " LINK SSTRUCT-GUIInfo-MenuNums};                  /* read only */
        WORD   @{" itemNum " LINK SSTRUCT-GUIInfo-MenuNums};                  /* read only */
        WORD   @{" subNum " LINK SSTRUCT-GUIInfo-MenuNums};                   /* read only */
       };

       struct GUIGadlist {
         struct Gadget *allGadgets[256]; /* read only */
       };

       struct GUIMenulist {
         struct NewMenu allMenus[256];   /* read only */
       };

@ENDNODE

@NODE SSTRUCT-GUIInfo-flags "GUIInfo.flags"

Type  : ULONG / @{" GUIInfo flags " LINK SSTRUCT-GUIInfoFlagSet}

Access: read / write

Value after creation : All flags cleared

With these flags you tell GUITools how to behave when creating gadgets
or menus and when checking intuition messages.
Set them after creating the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} with @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo}
or direct using @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} with the @{" GUI_Flags tag " LINK SSTRUCT-GUITags}.
It it also allowed to change the flags during the creation of the GUI to
use them only with some gadgets.

@ENDNODE

@NODE SSTRUCT-GUIInfo-screen "GUIInfo.screen"

Type  : struct screen*

Access: read only

Value after creation : the screen of the specified window

This is only a pointer to the window's screen for easier handling.

@ENDNODE

@NODE SSTRUCT-GUIInfo-visual "GUIInfo.visual"

Type  : APTR

Access: read only

Value after creation : pointer to the screen's visualinfo

This is a pointer to the screen's visualinfo for easier handling. Some
functions (e.g. for BOOPSI gadgets or images) require this pointer.

@ENDNODE

@NODE SSTRUCT-GUIInfo-drawinfo "GUIInfo.drawinfo"

Type  : struct DrawInfo*

Access: read only

Value after creation : pointer to the screens's drawinfo

Available starting with version 38.0

This points to a copy of the screen's drawinfo structure. This structure
is helpful for BOOPSI gadgets or images or for some drawing routines.

@ENDNODE

@NODE SSTRUCT-GUIInfo-font "GUIInfo.font"

Type  : struct TextAttr

Access: read / write

Value after creation : Copy of the window's font TextAttr structure

This font is used for the gadgets. To change the font of the gadgets
change this structure or the ng_TextAttr field in the @{" newgad " LINK SSTRUCT-GUIInfo-newgad}
NewGadget structure.
After the creation the textattr field of the newgad structure pointers
to this structure. If you used @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} you change also
the font for the menu with this structure, because then the
@{" menuFont field " LINK SSTRUCT-GUIInfo-menuFont} points also to this structure !

@ENDNODE

@NODE SSTRUCT-GUIInfo-menuFont "GUIInfo.menuFont"

Type  : struct TextAttr*

Access: read / write

Value after creation : - points to the @{" font field " LINK SSTRUCT-GUIInfo-font} with
                         @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo}
                       - points to the screen's font when using
                         @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}

Available starting with version 38.0

This pointer defines which font is used for the menu. See also the chapter
about the @{" menu font problem" LINK SCHAP-Problems-CreateGUIInfo}.

@ENDNODE

@NODE SSTRUCT-GUIInfo-window "GUIInfo.window"

Type  : struct Window*

Access: read only

Value after creation : The given window

This is the window which will get the new GUI.

@ENDNODE

@NODE SSTRUCT-GUIInfo-port "GUIInfo.port"

Type  : struct MsgPort*

Access: read / write

Value after creation : window's IDCMP message port

This field points to the window's IDCMP message port. Using this port
all intuition message handling is done. If you change this pointer
indirect e.g. by using ModifyIDCMP, you have to update this field,
either !

@ENDNODE

@NODE SSTRUCT-GUIInfo-newgad "GUIInfo.newgad"

Type  : struct NewGadget

Access: read / write

Value after creation : A valid NewGadget structure

This structure is needed for the creation of the gadgets. It can be
changed. After creation the ng_TextAttr is set to the @{" font field " LINK SSTRUCT-GUIInfo-font} and
the ng_VisualInfo is set to the screen's visualinfo.
The most important entries are filled by the gadget creating routines,
(The ng_LeftEdge, ng_TopEdge, ng_Width, ng_Height, ng_GadgetText,
ng_GadgetId and ng_Flags elements !) but you can overwrite them, although
there will probably no need for it.
If you want another font for one or all gadgets, simply change the
ng_TextAttr field.

See also: @{" CreateGadget " LINK SFCT-CreateGadget}, @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull},
          @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}, @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget}

@ENDNODE

@NODE SSTRUCT-GUIInfo-actgad "GUIInfo.actgad"

Type  : WORD

Access: read only

Value after creation : 0

This field contains the gadget number of the gadget that will be created
next. After a call to @{" SetGUI " LINK SFCT-SetGUI} you find here the amount of gadgets.
NOTICE: The first gadget has the number 0 !

@ENDNODE

@NODE SSTRUCT-GUIInfo-gadgets "GUIInfo.gadgets"

Type  : pointer to an array of 256 gadget pointers

Access: read only

Value after creation : Valid pointer to an array of gadget pointers
                       which are all set to NULL

This field points to an array of gadget pointers. Every field of this
array points to a created gadget in the order of creation. The array
ranges from zero to (@{" actgad " LINK SSTRUCT-GUIInfo-actgad} - 1).

@ENDNODE

@NODE SSTRUCT-GUIInfo-gadlist "GUIInfo.gadlist"

Type  : struct Gadget*

Access: read only

Value after creation : A valid pointer to a initialized gadget list

This field points to the list of the with GUITools created gadgets.
This pointer is only valid during a call to @{" SetGUI " LINK SFCT-SetGUI} and @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}.
Usually you will never need this pointer, perhaps only for refreshing
functions or something where the whole gadget list is needed and
GUITools has no function for.
But notice: This field contains only the gadtools gadgets, but not
GUITools gadgets. This will not change in future, but there will be
more gadget kinds (e.g. BOOPSI gadgets). The consequence is when
you use this entry, e.g. with RemoveGList or AddGList you only work with
the gadtools gadgets. All other kinds of gadgets still remain in the state
they were before !
To avoid any problems, please do not use this entry. Use whenever possible
the functions GUITools provides. (@{" RemoveGadgets " LINK SFCT-RemoveGadgets}, @{" SetGUI " LINK SFCT-SetGUI} etc)

@ENDNODE

@NODE SSTRUCT-GUIInfo-actmenu "GUIInfo.actmenu"

Type  : WORD

Access: read only

Value after creation : 0

This field contains the number of the menu item which will be created
next. Remember, the first number is zero !

See also: @{" Creating menus " LINK SCHAP-CreatingMenus}, @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry}, @{" menuAdr field " LINK SSTRUCT-GUIInfo-menuAdr},
          @{" newMenus field " LINK SSTRUCT-GUIInfo-newMenus}

@ENDNODE

@NODE SSTRUCT-GUIInfo-newMenus "GUIInfo.newMenus"

Type  : pointer to an array of 256 NewMenu structures

Access: read / write

Value after creation : A valid pointer to an array of NewMenu
                       structures

If you want to specify more values than is possible using the
@{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} function, then first call MakeMenuEntry
and then add the data using the methods mentioned in the chapter
about @{" Creating menus " LINK SCHAP-CreatingMenus}.

See also: @{" actmenu field " LINK SSTRUCT-GUIInfo-actmenu}, @{" menuAdr field " LINK SSTRUCT-GUIInfo-menuAdr}

@ENDNODE

@NODE SSTRUCT-GUIInfo-menus "GUIInfo.menus"

Type  : struct Menu*

Access: read only

Value after creation : NULL

After a call to @{" SetGUI " LINK SFCT-SetGUI} this field contains a pointer to the
new menu.

@ENDNODE

@NODE SSTRUCT-GUIInfo-im "GUIInfo.im"

Type  : struct IntuiMessage

Access: read only

Value after creation : A valid IntuiMessage structure

If you call @{" GetIntMsg " LINK SFCT-GetIntMsg} or @{" WaitIntMsg " LINK SFCT-WaitIntMsg} the received
IntuiMessage is copied into this field.

@ENDNODE

@NODE SSTRUCT-GUIInfo-msgClass "GUIInfo.msgClass"

Type  : ULONG / IDCMPFlags

Access: read only

Value after creation : 0

Available starting with version 38.0

Usually this field contains a copy of the class field of the @{" im field " LINK SSTRUCT-GUIInfo-im}.

See also: @{" HandleIntMsg " LINK SFCT-HandleIntMsg}

@ENDNODE

@NODE SSTRUCT-GUIInfo-gadID "GUIInfo.gadID"

Type  : WORD

Access: read only

Value after creation : 0

If a message for gadgets arrives this field contains the gadgets ID.

@ENDNODE

@NODE SSTRUCT-GUIInfo-gadget "GUIInfo.gadget"

Type  : struct Gadget*

Access: read only

Value after creation : NULL

If a message for gadgets arrives this field points to the event
gadget.
Starting with V38.0 this pointer contains the address of the
just created gadget after called a gadget creating function.

@ENDNODE

@NODE SSTRUCT-GUIInfo-MenuNums "GUIInfo.menuNum / GUIInfo.itemNum / GUIInfo.subNum"

Type  : WORD

Access: read only

Value after creation : 0

When a IDCMP_MENUPICK or beginning with V38.0 a IDCMP_MENUHELP message
arrives these fields contain then appropriate numbers of the chosen menu.

@ENDNODE

@NODE SSTRUCT-GUIInfo-CodeEntries "GUIInfo.cardCode / GUIInfo.intCode / GUIInfo.boolCode / GUIInfo.charCode"

Type : cardCode : UWORD
       intCode  : WORD
       boolCode : UBYTE
       charCode : char

Access: read only

Value after creation : 0 resp FALSE resp 0C

Available starting with version 38.0

These fields contain usually a copy of the code field of the @{" im field " LINK SSTRUCT-GUIInfo-im}.
Using this field it might be much easier to handle the code.

See also: @{" HandleIntMsg " LINK SFCT-HandleIntMsg}

@ENDNODE

@NODE SSTRUCT-GUIInfo-gadNbr "GUIInfo.gadNbr"

Type  : WORD

Access: read only

Value after creation : 0

Available starting with version 38.0

This field contains the gadget number of the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets}
when a gadget message arrived. So it is much easier to handle the gadget,
when the gadget's ID and number are not the same !

@ENDNODE

@NODE SSTRUCT-GUIInfo-itemAdr "GUIInfo.itemAdr"

Type  : struct MenuItem*

Access: read only

Value after creation : NULL

Available starting with version 38.0

This field points to the menu item which was selected within the
arrived IDCMP_MENUPICK resp IDCMP_MENUHELP message.

@ENDNODE

@NODE SSTRUCT-GUIInfo-menuAdr "GUIInfo.menuAdr"

Type  : struct NewMenu*

Access: read only

Value after creation : NULL

Available starting with version 38.0

After a call to @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} this field points to the appropriate
NewMenu structure.

See also: @{" Creating menus " LINK SCHAP-CreatingMenus}, @{" actmenu field " LINK SSTRUCT-GUIInfo-actmenu}, @{" newMenus field " LINK SSTRUCT-GUIInfo-newMenus}

@ENDNODE

@NODE SSTRUCT-GUIInfo-vanKeyHook "GUIInfo.vanKeyHook / GUIInfo.newVanKeyHook"

Type  : APTR / @{" VanKeyFct " LINK SSTRUCT-VanKeyFct} / @{" NewVanKeyFct " LINK SSTRUCT-NewVanKeyFct}

Access: read / write

Value after creation : NULL

Available starting with version 38.0

This is the @{" VanKeyFct " LINK SSTRUCT-VanKeyFct}  @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg} uses for user defined
@{" key equivalents " LINK SCHAP-KeyEquivalents}.
Starting with version 38.1 this can also be a @{" NewVanKeyFct " LINK SSTRUCT-VanKeyFct}.

@ENDNODE

@NODE SSTRUCT-GUIInfo-vanKeyFctData "GUIInfo.vanKeyFctData"

Type  : APTR

Access: read / write

Value after creation : pointer to the GUIInfo structure

Available starting with version 38.1

When the @{" NewVanKeyFct " LINK SSTRUCT-VanKeyFct} is called this pointer will arrive in A2.
This pointer can be set during creation using the @{" GUI_VanKeyFctData tag " LINK SSTRUCT-GUITags}.

See also: @{" Key equivalents " LINK SCHAP-KeyEquivalents}

@ENDNODE

@NODE SSTRUCT-GUIInfo-menuFctData "GUIInfo.menuFctData"

Type  : APTR

Access: read / write

Value after creation : pointer to the GUIInfo structure

Available starting with version 38.1

This pointer is passed in A0, when a @{" NewMenuFct " LINK SSTRUCT-MenuFct} is used to call the
menu functions.
This pointer can be set during creation using the @{" GUI_MenuFctData tag " LINK SSTRUCT-GUITags}.

See also: @{" Creating menus " LINK SCHAP-CreatingMenus}

@ENDNODE

@NODE SSTRUCT-GUIInfo-userData "GUIInfo.userData"

Type  : APTR

Access: read / write

Value after creation : NULL

Available starting with version 38.1

This pointer can be used for special user data. This use is left to the
applications.
This pointer can be set during creation using the @{" GUI_UserData tag " LINK SSTRUCT-GUITags}.

@ENDNODE

@NODE SSTRUCT-GUIInfo-compilerReg "GUIInfo.compilerReg"

Type  : APTR

Access: read / write

Value after creation : NULL

Available starting with version 38.1

This pointer can be used for the hook functions to set the global data
register for the compiler.
When a hook function is called, it is mostly required to set the
global data register (the majority of compilers use A4 for this).
The compilers offer different functions for this problem. But using
this the code can't be reentrant !
To achieve this you can pass the GUIInfo structure to the hook
function as user data and then set the global data register to this
pointer. But don't forget to save the old value of the global data
register !

This pointer can be set during creation using the @{" GUI_CompilerReg tag " LINK SSTRUCT-GUITags}.

@ENDNODE

@NODE SSTRUCT-GUIInfo-winISize "GUIInfo.winIWidth / GUIInfo.winIHeight"

Type  : WORD

Access: read / write

Value after creation : window inner width and window inner height

Available starting with version 38.1

GUITools uses these values for @{" resizable gadgets " LINK SCHAP-ResizableGadgets} inside the @{" DoResizing " LINK SFCT-DoResizing}
function !

@ENDNODE

@NODE SSTRUCT-GUIInfoFlagSet "GUIInfo flags"

Complete descriptions of all flags:

         GFLG_StringNotify     When creating a STRING_KIND gadget,
                               the GTST_String tag contains a pointer
                               to a string variable. GUITools keeps
                               in mind this pointer and can copy
                               automatically an entered string to
                               this variable.

         GFLG_integerNotify    Does the same as GFLG_StringNotify only for
                               INTEGER_KIND gadgets and GTIN_Number now
                               contains a pointer to a LONGINT
                               variable.

         GFLG_CycleNotify      When creating a CYCLE_KIND gadget the
                               GTCY_Active gadget must contain the
                               address of a UWORD variable.
                               If now the CYCLE_KIND gadget is hit,
                               the variable will get automatically
                               the state of the gadget.

         GFLG_MXNotify         Does the same for MX_KIND gadgets as
                               GFLG_CycleNotify, but now the GTMX_Active
                               tag must contain the address.

         GFLG_CheckboxNotify   Does the same for CHECKBOX_KIND gadgets
                               as GFLG_CycleNotify, but now the
                               GTCB_Checked tag must contain the address
                               of a UBYTE (BOOLEAN) variable !

/*38.0*/ GFLG_SliderNotify     Does the same for SLIDER_KIND gadgets
                               as GFLG_CycleNotify, but now the GTSL_Level
                               tag must contain the address of an
                               WORD variable.

/*38.0*/ GFLG_ScrollerNotify   Does the same for SCROLLER_KIND gadgets
                               as GFLG_CycleNotify, but now the GTSC_Top
                               tag must contain the Address of an
                               WORD variable.

/*38.0*/ GFLG_ListviewNotify   Does the same for LISTVIEW_KIND gadgets
                               as GFLG_CycleNotify, but now the
                               GTLV_Selected tag must contain the address
                               of an UWORD variable.

/*38.0*/ GFLG_PaletteNotify    Does the same for PALETTE_KIND gadgets
                               as GFLG_CycleNotify, but now the GTPA_Color
                               tag must contain the Address of an
                               UWORD variable.

         GFLG_LinkEntryGads    If the user leaves an entry gadget
                               pressing RETURN, the next entry gadget
                               will be activated. This flag is only
                               valid during the gadget creation.

         GFLG_CycleEntryGads   If the user leaves the last entry
                               gadget and GFLG_LinkEntryGads is set, the
                               first entry gadget will be activated.
                               This flag is only valid during the
                               gadget creation.

         GFLG_ActivateFirstEGad Activates the first entry gadget after
                                the creation of the GUI with @{" SetGUI " LINK SFCT-SetGUI}.

         GFLG_AutoUpdateEGads  If the user presses RETURN in an entry
                               gadget, the new value will be copied in
                               the variable which was specified using
                               GFLG_StringNotify resp GFLG_integerNotify.
                               This is only interesting while checking
                               gadgets and works only together with
                               GFLG_StringNotify and GFLG_integerNotify.

/*38.0*/ GFLG_AddStdUnderscore Adds to the gadgets taglist automatically
                               the GT_Underscore tag with data of '_'.
                               So you don't have to specify this. This
                               is very useful with BUTTON_KIND gadgets
                               which usually have no other tags.

/*38.0*/ GFLG_VanillaKeysNotify During the creation of a gadget GUITools
                                checks, if a key equivalent exists for
                                this gadget and then keeps it in mind.

/*38.0*/ GFLG_AllowAllVanillaKeys Usually GUITools can only handle key
                                  equivalents which are letters. If you
                                  want to have alternative ones, e.g.
                                  numbers or the function keys, @{" SetGUI " LINK SFCT-SetGUI}
                                  will return an error !
                                  If you set this flag GUITools will
                                  ignore them and you must handle these
                                  ones, e.g. using GFLG_CallVanillaKeyFct.

/*38.0*/ GFLG_CallVanillaKeyFct If this flag is set GUITools calls the
                                @{" VanKeyFct " LINK SSTRUCT-VanKeyFct} found in the @{" vanKeyHook field " LINK SSTRUCT-GUIInfo-vanKeyHook}
                                if the user presses a vanilla key.
                                See @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg}

/*38.0*/ GFLG_ConvertKeys      If GFLG_VanillaKeysNotify is set, the IDCMP
                               message from a vanilla key is automatical-
                               ly converted into a gadget message. This
                               flag is only valid during the checking of
                               IDCMP message.

/*38.0*/ GFLG_NoHandleIntMsgCall  Disables the call of @{" HandleIntMsg " LINK SFCT-HandleIntMsg} from
                                  @{" WaitIntMsg " LINK SFCT-WaitIntMsg} resp @{" GetIntMsg " LINK SFCT-GetIntMsg}. This flag
                                  is only valid during the checking of
                                  the GUI.

/*38.0*/ GFLG_InternMsgHandling   All IDCMP messages which can be handled
                                  by GUITools itself will be handled
                                  internal. This message will then never
                                  arrive at the application ! This flag is
                                  only valid during the creation of
                                  the GUI.

/*38.0*/ GFLG_LVKeyClearTime   If the key equivalent for a listview
                               kind gadget was hit, the seks field of
                               the IntuiMessage is set to zero to avoid
                               any trouble checking for double clicks.
                               This flag is only valid during creation.

/*38.0*/ GFLG_CallMenuData     When a IDCMP_MENUPICK message arrives,
                               GUITools calls the function which is
                               specified using the userData field of the
                               menu item.
                               This is done by @{" HandleIntMsg " LINK SFCT-HandleIntMsg}.

/*38.0*/ GFLG_DoRefresh        @{" HandleIntMsg " LINK SFCT-HandleIntmsg} automatically calls
                               @{" BeginRefresh " LINK SFCT-BeginRefresh} followed by @{" EndRefresh " LINK SFCT-EndRefresh}
                               when a IDCMP_REFRESHWINDOW message arrives.

/*38.0*/ GFLG_AddBorderDims    During the creation of a gadget the leftEdge
                               will be incremented by window->BorderLeft
                               and the topEdge by window->BorderTop.
                               Due to this the gadgets are always inside
                               the window regardless of the window's font.

/*38.1*/ GFLG_DoResizing       @{" DoResizing " LINK SFCT-DoResizing} and @{" RedrawGadgets " LINK SFCT-RedrawGadgets} are
                               automatically called by @{" HandleIntMsg " LINK SFCT-HandleIntMsg} when
                               a IDCMP_NEWSIZE message arrives.
                               For this the @{" GUI_ResizableGads tag " LINK SSTRUCT-GUITags}
                               must set !

@ENDNODE

@NODE SSTRUCT-GUIGadgetInfo "GUIGadgetInfo (V38.0)"


struct GUIGadgetInfo
    APTR  userData;
    ULONG kind;
END;

GUITools uses the UserData field of each gadget to store some extra
information which are very important for GUITools to work.
GUITools sets the UserData field to this structure.

userData   a pointer to your own user data
kind       the gadget kind

See also: @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

@ENDNODE

@NODE SSTRUCT-VanKeyFct "VanKeyFct - The vanilla key hook function / NewVanKeyFct"

     ULONG vk_Function(register __d0 char key,
                       register __a0 WORD  *nbr,
                       register __a1 WORD  *shift);

This function is for alternative @{" key equivalents " LINK SCHAP-KeyEquivalents}. It returns for a key
the belonging gadget number.

The function gets in D0 the character. If this character belongs to a
gadget, the function puts in the WORD variable, A0 points to, the
number of the gadget and in the WORD variable, A1 points to, if the
key should be treated as a shifted key. Use 1 for yes and 0 for no.
Then you must return TRUE, otherwise if the key does not belong to
any gadget just return 0.

With this function you can give every key a belonging gadget and then
you don't have to worry, if the key was pressed or if the gadget was
activated using the mouse, because GUITools always sends gadget
messages and no key messages using @{" ConvKMsgToGMsg " LINK SFCT-ConvKMsgToGMsg}.

This hook function is only available when running under version 38.0 or
above !

Beginning with version 38.1 it is also possible to use the NewVanKeyFct
to achieve this. This function does the same as the VanKeyFct, but it
also gets in A2 a pointer to user defined data. This pointer can be
specified using the @{" vanKeyFctData field " LINK SSTRUCT-GUIInfo-vanKeyFctData}.

     ULONG vk_Function(register __d0 char key,
                       register __a0 WORD *nbr,
                       register __a1 WORD *shift,
                       register __a2 APTR userData);

Internal GUITools V38.1 calls always a NewVanKeyFct, so it is left to
the user to use the additional register or not.

@ENDNODE

@NODE SSTRUCT-MenuFct "MenuFct / NewMenuFct "

     ULONG menu_Function(void)

This function is available starting with function. It is called
whenever a IDCMP_MENUPICK message arrives and the @{" GFLG_CallMenuData flag " LINK SSTRUCT-GUIInfoFlagSet}
is set and the userData field of this menu item contains a pointer
to this function.
If you want to wait for the next message, return TRUE, otherwise
return FALSE to end the message loop.
Starting with version 38.1 you can use also this definiton:

     ULONG menu_Function(register __a0 APTR userData)

This function does the same, but it also get a pointer to some user
defined data in A0 which can be set using the @{" menuFctData field " LINK SSTRUCT-GUIInfo-menuFctData}.

Internal GUITools V38.1 calls always a NewMenuFct, so it is left to the
user to use the additional register or not.

See also: @{" Creating menus " LINK SCHAP-CreatingMenus}, @{" HandleIntMsg " LINK SFCT-HandleIntMsg}

@ENDNODE

@NODE SSTRUCT-GUITags "GuiTags"

You can specify these tags with @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.
All tags require at least version 38.0, the same does @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.


Tags for @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} V38.0
--------------------------------

 GUI_CreateError   : (*LONG, set to NULL)
                     This is a pointer to a LONG which will contain the
                     error on return if @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} returns NULL.

                     Possile error codes:

                       @{" cgiNoError " LINK SSTRUCT-constants}       No error, CreateGUIinfoTags has
                                          done its work, the result
                                          wasn't NULL , so go on !
                       @{" cgiNoWindow " LINK SSTRUCT-constants}      window pointer was NULL
                       @{" cgiNoVisualInfo " LINK SSTRUCT-constants}  Unable to create the VisualInfo
                       @{" cgiNoMemory " LINK SSTRUCT-constants}      Not enough memory
                       @{" cgiNoDrawInfo " LINK SSTRUCT-constants}    Unable to create DrawInfo
                       @{" cgiCreateContext " LINK SSTRUCT-constants} The call to CreateContext failt


  GUI_Flags         : (ULONG / @{" GUIInfoFlagSet " LINK SSTRUCT-GUIInfoFlagSet}, set to 0)
                      With this tag you can set all the flags you want,
                      the setting will be copied into the @{" flags field " LINK SSTRUCT-GUIInfo-flags}.

  GUI_GadFont       : (struct TextAttr*, set to window's font)
                      With this tag you can choose the gadgets's font.
                      This font will be placed in the ng_TextAttr field
                      of @{" newgad " LINK SSTRUCT-GUIInfo-newgad} NewGadget structure.

  GUI_MenuFont      : (struct TextAttr*, set to screen's font)
                      With this tag you can choose the font for the menu.
                      This font will be placed in the @{" menuFont field " LINK SSTRUCT-GUIInfo-menuFont}.

  GUI_VanKeyFct     : (@{" VanKeyFct " LINK SSTRUCT-VanKeyFct}, set to NULL)
                      The @{" vanKeyHook field " LINK SSTRUCT-GUIInfo-vanKeyHook} will be filled with this hook
                      function for alternative @{" key equivalents " LINK SCHAP-KeyEquivalents}.

  GUI_ResizableGads : (UBYTE / boolean tag, set to 0)
                      If this tag is set to 1, GUITools will notify
                      the appearance, size and position of all gadgets.
                      In this way GUITools is able to resize gadgets.
                      Because the notify of the appearance requires
                      some resources, this flag is usually turned off.
                      Set it only, if necessary !

  GUI_RefreshWindowFrame  : (UBYTE / boolean tag, set to GUI_ResizableGads)
                            If you use this tag AFTER the GUI_ResizableGads
                            tag, you can change its value.
                            If this flag is set, the window frame will be
                            refreshed using RefreshWindowFrams of the
                            intuition.library, either, when @{" EndRefresh " LINK SFCT-EndRefresh}
                            is called.

  GUI_SetProcessWindow     : (UBYTE / boolean tag, set to 0)
                             If this flag is set to 1, the pr_WindowPtr
                             field of the process structure is set to
                             the window.

  GUI_RestoreProcessWindow : (UBYTE / boolean tag, set to 0)
                             If this flag is set to 1, the pr_WindowPtr
                             field of the process structure will be
                             restored when @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo} is
                             called. This means the field is set to the
                             value it had before the call to
                             @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.

Additional Tags for @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} V38.1
-------------------------------------------

  GUI_VanKeyFctData        : (APTR, set to gui)
                             This pointer will be saved in the
                             @{" vanKeyFctData field " LINK SSTRUCT-GUIInfo-vanKeyFctData}. It is for use with the
                             @{" NewVanKeyFct " LINK SSTRUCT-VanKeyFct}.
                             See also: @{" Key equivalents " LINK SCHAP-KeyEquivalents}

  GUI_MenuFctData          : (APTR, set to gui)
                             This pointer will be saved in the
                             @{" menuFctData field " LINK SSTRUCT-GUIInfo-menuFctData}. It is for use with the
                             @{" NewMenuFct " LINK SSTRUCT-MenuFct}.
                             See also: @{" Creating menus " LINK SCHAP-CreatingMenus}

  GUI_UserData             : (APTR, set to NULL)
                             Value for the @{" userData field " LINK SSTRUCT-GUIInfo-userData}.

  GUI_CompilerReg          : (APTR, set to NULL)
                             Value for the @{" compilerReg field " LINK SSTRUCT-GUIInfo-compilerReg}.

  GUI_UseGadDesc           : (UBYTE boolean tag, set to 0)
                             If set to 1, GUITools uses now the gadget
                             description flags for their sizes and positi-
                             ons when creating and resizing them !
                             Usually this description flags are used to
                             resize the GUI, so for this use also the
                             GUI_ResizableGads tag !
                             See also: @{" Resizable gadgets " LINK SCHAP-ResizableGadgets}

@ENDNODE

@NODE SSTRUCT-SgTags "SgTags"

Starting with version 38.0 you can use these tags to specify GUITools
gadgets and starting with version 38.1 you can use them for every
gadget kind.


Tags for V38.0
--------------

  SG_GadgetText  : (APTR, set to NULL)
                   Using this tag you can specify the gadget's text.

  SG_GadgetFlags : (ULONG / NewGadgetFlags)
                   With this tag you set the flags for the gadget. If
                   you don't use this tag the flags of the last created
                   gadget will be used also for this gadget.

  SGPI_MaxValue  : (UWORD, set to 100)
                   The maximum value of a @{" progressIndicatorKind " LINK SSTRUCT-Constants}.

  SGPI_CurrentValue : (UWORD, set to 0)
                      The current value of a @{" progressIndicatorKind " LINK SSTRUCT-Constants}.

  SGBB_Recessed : (UBYTE / boolean tag, set to 0)
                  Should the bevelled box be recessed or not.


Tags for V38.1
--------------

  SG_GadgetFont : (struct TextAttr*)
                  This sets the ng_TextAttr field of the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad}.
                  All gadgets which are from now one created use this new
                  font unless another is defined.

  SG_GadgetID   : (UWORD)
                  This gives a new ID to the gadget. The next gadget will
                  get this ID plus one and so on. Usually GUITools gives
                  the first gadget the ID 0, the second the ID 1 and so
                  on.

  SG_VisualInfo : (APTR)
                  Set the ng_VisualInfo field of the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad}.
                  Usually this tag is not of any use. But for complete-
                  ness it is specified if you want to use another Visual-
                  Info than that of the used screen !

  SG_UserData   : (APTR)
                  Set the ng_UserData field of the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad}.
                  This sets the userData field of the @{" GUIGadgetInfo " LINK SSTRUCT-GUIGadgetInfo}
                  structure which is stored in the userData field of
                  the created gadget.

  SG_GadgetDesc : (ULONG)
                  This gadget description flag is only for use with the
                  resizable gadget function if the @{" GUI_UseGadDesc tag " LINK SSTRUCT-GUITags} is
                  set.
                  See chapter @{" Resizable gadgets " LINK SCHAP-ResizableGadgets} for more information

  SG_GadgetObjects : (ULONG)
                  This gadget description flag is only for use with the
                  resizable gadget function if the @{" GUI_UseGadDesc tag " LINK SSTRUCT-GUITags} is
                  set.
                  See chapter @{" Resizable gadgets " LINK SCHAP-ResizableGadgets} for more information

See also: @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

@ENDNODE

@NODE SSTRUCT-SrTags "SrTags"

Starting with version 38.0 you can use these tags to descripe your
own requesters.

Don't use the flags which are for the asl requester of version 38.1
for other @{" requester kinds " LINK SSTRUCT-Constants} and vice versa !

  SR_Gadgets      Pointer to gadgets' texts which are separated by '|'.
                  This pointer is only required for your own
                  requester kind or to localize the requester.
                  This flag is unused for asl requesters.
  SR_Args         Pointer to an array of argument pointers if required
                  This flag is ignored by asl requesters.
  SR_Title        Pointer to the title string. Usually this pointer is
                  NULL, so the requester gets the title of the reference
                  window.
                  Using asl requesters this flag has the same meaning
                  as the requester text !
  SR_IDCMP        Pointer to an IDCMPFlagSet. If you are specifying
                  this the requester will disappear if one of these
                  events occur. Then the requester function will
                  return -1 and the IDCMPFlagSet this tag points to
                  contains the event !
                  This flag is unused by asl requesters by now.
  SR_ReqWindow    Using this flag you can specify the window the requester
                  should appear one.

Starting with version 38.1 you can also use these tags which are
currently only for the asl.library requesters:

  SR_AslPattern     a pointer to a pattern

  SR_AslNameBuffer  pointer to a buffer to save the full file name
                    Don't use this tag together with SR_AslFileBuffer
                    or SR_AslDirBuffer

  SR_AslFileBuffer  pointer to a buffer to save only the file name
                    Don't use this tag together with SR_AslNameBuffer,
                    but it is advised to use SR_AslDirBuffer together
                    with it.

  SR_AslDirBuffer   pointer to a buffer to save only the path
                    Don't use this tag together with SR_AslNameBuffer,
                    but it is advised to use SR_AslFileBuffer together
                    with it.

  SR_AslSave        (UBYTE / boolean tag, set to 0)
                    save requester or not

See also: @{" Using requesters " LINK SCHAP-UsingRequesters}

@ENDNODE

@NODE SSTRUCT-Constants "Constants"

Result from @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} in @{" GUI_CreateError " LINK SSTRUCT-GUITags}

/*38.0*/   cgiNoError        = 0;
/*38.0*/   cgiNoWindow       = 1;
/*38.0*/   cgiNoVisualInfo   = 2;
/*38.0*/   cgiNoMemory       = 3;
/*38.0*/   cgiNoDrawInfo     = 4;
/*38.0*/   cgiCreateContext  = 5;


Result from @{" SetGUI " LINK SFCT-SetGUI} and @{" RedrawGadgets " LINK SFCT-RedrawGadgets}

           guiSet       = 0;
           gadgetError  = 1;
           menuError    = 2;
           memError     = 3;
/*38.0*/   gadKeyDefTwice     =  4;
/*38.0*/   menuSetError       =  5;
/*38.0*/   menuLayoutError    =  6;
/*38.0*/   gadKeyNotAllowed   =  7;
/*38.0*/   tooManyGadsError   =  8;
/*38.0*/   tooManyMenusError  =  9;
/*38.0*/   gadKeyNotFound     = 10;
/*38.0*/   noGadToolsGadKind  = 11;
/*38.0*/   noGUIToolsGadKind  = 12;
/*38.0*/   rdGUIContextError  = 13;


Value for @{" OpenIntWindow " LINK SFCT-OpenIntWindow} and @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags} width and height

           asScreen    = -1;


Value for @{" ResizeGadget " LINK SFCT-ResizeGadget}

/*38.0*/   preserve    = -1;


Predefined displayIDs for @{" OpenIntScreen " LINK SFCT-OpenIntScreen} and @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}

           hiresPalID  = hiresKey + palMonitorID;
           hiresID     = hiresKey + defaultMonitorID;
           loresPalID  = loresKey + palMonitorID;
           loresID     = loresKey + defaultMonitorID;


Values for @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} and @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}

/*38.0*/   noGadgets  = 0;
/*38.0*/   noMenu     = 0;


Gadget kinds for @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget}

/*38.0*/   guiToolsKinds          = 65535;
/*38.0*/   progressIndicatorKind  = 65536;
/*38.0*/   bevelboxKind           = 65537;

Beginning with version 38.1 these kinds can also be used with all other
gadget creating functions !


Requester kinds for @{" ShowRequester " LINK SFCT-ShowRequester} and @{" SimpleReq " LINK SFCT-SimpleReq}

/*38.0*/   generalReqKind  = 0;
/*38.0*/   okReqKind       = 1;
/*38.0*/   doitReqKind     = 2;
/*38.0*/   yncReqKind      = 3;
/*38.1*/   fileReqKind     = 4;
/*38.1*/   dirReqKind      = 5;


Results from @{" ShowRequester " LINK SFCT-ShowRequester}

/*38.0*/   reqYes        = 1;
/*38.0*/   reqNo         = 2;
/*38.0*/   reqCancel     = 0;
/*38.0*/   reqOK         = 0;
/*38.0*/   reqDo         = 1;
/*38.0*/   reqLeave      = 0;
/*38.1*/   reqAslCancel  = 0;
/*38.1*/   reqAslOK      = 1;

gadget size and position description flags for the @{" SG_GadgetDesc tag " LINK SSTRUCT-SgTags}

/*38.1*/   distNorm    = 0;
/*38.1*/   distAbs     = 1;
/*38.1*/   distRel     = 2;
/*38.1*/   distPercent = 3;

/*38.1*/   objBorder= 0;
/*38.1*/   objGadget= 4;

/*38.1*/   objRight  = 0;
/*38.1*/   objBottom = 0;
/*38.1*/   objLeft   = 32;
/*38.1*/   objTop    = 32;

/*38.1*/   shiftLeft   = 256*256*256;
/*38.1*/   shiftTop    = 256*256;
/*38.1*/   shiftWidth  = 256;
/*38.1*/   shiftHeight = 1;

@ENDNODE

@NODE SCHAP-2 "Working with GUITools"

These chapters contain some additional information about GUITools. They
give hints and some interesting tips how to use GUITools.

   @{" Guidelines " LINK SCHAP-Guidelines}

   @{" Freeing resources (V38.0)" LINK SCHAP-FreeingResources}

   @{" Creating gadgets " LINK SCHAP-CreatingGadgets}

   @{" Creating menus " LINK SCHAP-CreatingMenus}

   @{" Dealing with fonts " LINK SCHAP-DealingFonts}

   @{" Key equivalents (V38.0)" LINK SCHAP-KeyEquivalents}

   @{" Resizable gadgets (V38.0)" LINK SCHAP-ResizableGadgets}

   @{" Using requesters (V38.0)" LINK SCHAP-UsingRequesters}

@ENDNODE

@NODE SCHAP-Guidelines "Guidelines"

The @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} which nearly all procedures require, contains
all important data.
Furthermore, the real structure contains a lot of hidden data at the end,
so create this structure only with @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} or under at least
version 38.0 with @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} and NEVER by hand.
In further versions this structure will contain additional data.
Set only the flags which are commented, set all others to zero for upward
compatibility.

Even if a call to @{" SetGUI " LINK SFCT-SetGUI} wasn't successful, you must ALWAYS use
@{" FreeGUIInfo " LINK SFCT-FreeGUIInfo} to free the structure.

Don't use any functions of the gadtools.library together with GUITools !
GUITools replaces the whole gadtools.library (except the message filter
functions and the GTGetGadgetAttrsA function of version 39), so there is
no need to use gadtools.library ! (It is possible to use the message
filter functions together with GUITools, if you use them carefully !)

ATTENTION: Except @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}, no procedure which get a @{" GUIInfoPtr " LINK SSTRUCT-GUIInfo}
           does a NULL check. You must check this after the call to
           @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} resp @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.
           Furthermore, there is no range checking in functions which get
           a gadget number (like @{" ModifyGadget " LINK SFCT-ModifyGadget} or @{" GadgetStatus " LINK SFCT-GadgetStatus}) !

GUITools uses for some internal functions and values the userData
entry of the gadgets. This means you can't use it to store some
own gadget specific data in this field or some VERY STRANGE THINGS
will happen. (Usually then nothing more will happen, because the
computer has hung itself !)
But don't worry you stil have the possibility to store own user
data. See the chapter @{" Creating gadgets " LINK SCHAP-CreatingGadgets}.

Although it is possible to give the IDs you want to the gadgets, it
makes a lot more sense to give this IDs in the usual orders. This
means the first gadget gets the ID 0, the second the ID 1 and so on.
Because some functions for manipulation gadgets expect as an
argument not the ID but the gadget number (e.g @{" ModifyGadget " LINK SFCT-ModifyGadget}
or @{" GadgetStatus " LINK SFCT-GadgetStatus}.)
If these figures don't correspond, you have to convert these numbers
by hand. Starting with version 38.0 you don't only get the gadget ID
but the gadget number, so this conversion can be neglected.

If you demand something (screens, windows, fonts etc) with GUITools you
have to free it with GUITools again !

Under version 38.1 some of the identifiers in the header file are declared
as obsolete. Please, don't use them anymore !
See the file guitools.h for these identifiers. Replace them by the new
ones which now follow the name conventions.

@ENDNODE

@NODE SCHAP-FreeingResources "Freeing resources (V38.0)"

In generall you have to free everything with GUITools you demanded with
GUITools.
But there are two little useful exceptions:

 1. If you requested a window using @{" OpenIntWindow " LINK SFCT-OpenIntWindow} resp
    @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags} it is sufficient to call @{" CloseIntWindow " LINK SFCT-CloseIntWindow}.
    You don't need a call to @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo}.

 2. If you opened a screen using @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags} resp
    @{" OpenIntScreen" LINK SFCT-OpenIntScreen} it is sufficient to call @{" CloseIntScreen " LINK SFCT-CloseIntScreen}.
    All not yet closed windows will be closed using @{" CloseIntWindow " LINK SFCT-CloseIntWindow}.

Due to this, you don't need when exiting to check if all of the opening
was succesful or not. You only have to check if the screen resp the
window, when no own screen is used, is open and then close it.

@ENDNODE

@NODE SCHAP-CreatingGadgets "Creating gadgets"

Gadget creating functions
-------------------------

To create a gadget GUITools uses the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad}. When creating a
gadget you must specify its size and position. These values will be
saved in the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad} and then the gadget will be created using this
structure.
Due to this it is possible to change some attributes of the gadgets
although GUITools has no function or tag to change these values. This
can be simply done by changing the @{" newgad structure " LINK SSTRUCT-GUIInfo-newgad} ! (E.g. to add own
userData, to use another font etc)
Beginning with version 38.1 it is possible to change all fields of this
structure using the @{" SgTags " LINK SSTRUCT-SgTags}.
The gadget creating functions behave different under the different
releases of GUITools:
V37.3: Use @{" CreateGadget " LINK SFCT-CreateGadget}, @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull} to create
       gadtools gadgets
V38.0: Use @{" CreateGadget " LINK SFCT-CreateGadget}, @{" CreateGadgetText " LINK SFCT-CreateGadgetText}, @{" CreateGadgetFull " LINK SFCT-CreateGadgetFull} to create
       gadtools gadgets and @{" CreateSpecialGadget " LINK SFCT-CreateSpecialGadget} to create GUITools
       gadgets
V38.1: Use any of the functions to create gadtools or GUITools gadgets.
       In addition you can also use @{" CreateGadgetNew " LINK SFCT-CreateGadgetNew}.
       It is advised to use this name instead of the others to avoid
       any confusion !


Additional information about creating gadgets
---------------------------------------------

Beginning with version 38.0 GUITools does the following replacements
during the creation of a gadget:

  CHECKBOX_KIND : if width  = 0, then width  := GadToolsBoxD.checkboxWidth
               : if height = 0, then height := GadToolsBoxD.checkboxHeight
  MX_KIND       : if width  = 0, then width  := GadToolsBoxD.mxWidth
                 if height = 0, then height := GadToolsBoxD.mxHeight
  STRING_KIND   : if height = 0, then height := gadget font^.ySize + 4
  INTEGER_KIND  : the same as STRING_KIND

If you set the @{" GFLG_AddBorderDims flag " LINK SSTRUCT-GUIInfoFlagSet}, the gadget creating functions add
to the gadget left the window^.borderLeft value and to the gadget top
the window^.borderTop value, so that every gadget will be inside the
window regardless of the used font. (Take care that the window is big
enough !)

After a call to a gadget creating function you have access to the
created gadget structure using the following possibilities:

     gui^.gadgets^[gui^.actgad - 1]

or when running at least under version 38.0

     gui^.gadget

But you have to check before using these methods if the @{" actgad field " LINK SSTRUCT-GUIInfo-actgad}
is greater than 0 and if the used pointer isn't NULL !.

GUITools uses the userData field of each gadget to store some extra
information which are very important for GUITools to work. Due to
this you can't use this userData entry for your own data. But there
is still the possibility to save your user data for each gadget.
GUITools sets the userData field to a @{" GUIGadgetInfo structure " LINK SSTRUCT-GUIGadgetInfo}.
Don't change this pointer. To store your own user data use the
@{" userData field " LINK SSTRUCT-GUIGadgetInfo} of the @{" GUIGadgetInfo structure " LINK SSTRUCT-GUIGadgetInfo}.
GUITools sets this pointer to the value when creating a gadget of
the userData field of the @{" newgad structure " LINK SSTRUCT-GUIInfo-newgad}.
Using the @{" kind field " LINK SSTRUCT-GUIGadgetInfo} you can check the gadget kind. This could be
a gadtools gadget or a guitools gadget as well !

When the GUI is set you can use the @{" gadgets field " LINK SSTRUCT-GUIInfo-gadgets} to get a pointer
to one of your created gadgets.
But don't call any function for gadgets before the GUI is set or after
the GUI has been removed or disabled !

Beginning with version 38.1 the GT_Underscore tag is ignored for TEXT_KIND,
NUMBER_KIND, progressIndicatorKind and bevelboxKind gadgets if the
@{" GFLG_VanillaKeysNotify flag " LINK SSTRUCT-GUIInfoFlagSet} is set, so there is no need to clear and
set the @{" GFLG_AddStdUnderscore flag " LINK SSTRUCT-GUIInfoFlagSet} all the time.


GUITools gadgets
----------------

Starting with version 38.0 you can not only use the gadtools gadgets,
but also two GUITools gadgets !
(In real they are actually no gadgets, they are only treated as some
gadgets and are simulated by GUITools !)
After setting the GUI you have the same access to GUITools gadgets
as to gadtools gadgets. That means you can modify or resize them and
you can check the position and size fields of the gadget structure
as well as the userData field. But remember don't use other fields of
this gadget structure and don't take this structure as a real gadget
structure, e.g. to link gadgets or to modify them directly using a
pointer to this structure ! This structure is read only and can only
be used with functions of GUITools !!

And now the description of the GUITools gadgets:

  The progress indicator kind

    This gadget offers a beam, e.g. to show howfar the progress has
    come.
    Use the @{" progressIndicatorKind " LINK SSTRUCT-Constants} constant to create.

    With this gadget you can use the following @{" SgTags " LINK SSTRUCT-SgTags}:

      SGPI_MaxValue  : (UWORD, set to 100)
                      The maximum value of a progressIndicatorKind. The
                      value of 100 is very useful, because then it is
                      easier to specify the progress in per cent.

      SGPI_CurrentValue : (UWORD, set to 0)
                         The current value of a progressIndicatorKind.
                         This is the percentage of the progress. It shows
                         how much is done yet.

    These tags can be used for creation and modification.
    This gadget also provides a gadget text, but it is not allowed to
    write the text inside the gadget. Because this gadget never sends
    messages, there is no need of having a key equivalent and so there
    should not be an underscore in the gadget text !


  The bevelbox kind

    This gadget shows a bevelled box, which can either be raised or
    recessed.

    Use the @{" bevelboxKind " LINK SSTRUCT-Constants} constant to create.

    When creating you can specify the following tag:

      SGBB_Recessed : (boolean tag, set to FALSE)
                     Should the bevelled box be recessed or not.

    Don't use gadget text together with bevelled box gadgets. Because
    this is not a real gadget as mentioned above, it is possible to
    show gadgets inside this gadget ! So you can draw a border around
    other gadgets !
    Using this gadget instead of a real bevelled box, simplifies such
    things as resizing GUIs and refreshing !
    This gadget never causes a message !

See also: @{" Resizable gadgets " LINK SCHAP-ResizableGadgets}

@ENDNODE

@NODE SCHAP-CreatingMenus "Creating menus"

If you want to create the following menu, you have to do the below
mentioned calls, after you have created a pointer to @{" GUIInfo " LINK SSTRUCT-GUIInfo}
named GUI using @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} or @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}.

        Project     Edit
      -------------------------------------------------
        Load        Cut
        Save        Paste
        QUIT

      MakeMenuEntry(GUI, nmTitle, ADR('Project'), NULL);
      MakeMenuEntry(GUI, nmItem,  ADR('Load'), ADR('L\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('Save'), ADR('S\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('QUIT'), ADR('Q\o'));
      MakeMenuEntry(GUI, nmTitle, ADR('Edit'), NULL);
      MakeMenuEntry(GUI, nmItem,  ADR('Cut'), ADR('C\o'));
      MakeMenuEntry(GUI, nmItem,  ADR('Paste'), ADR('V\o'));


If you are using version 37.3 you have to take care of a multi selection
when checking the menus. The same you have to do when you are NOT using
@{" GetIntMsg " LINK SFCT-GetIntMsg} or @{" WaitIntMsg " LINK SFCT-WaitIntMsg}.
If you are using at least version 38.0 together with @{" GetIntMsg " LINK SFCT-GetIntMsg} resp
@{" WaitIntMsg " LINK SFCT-WaitIntMsg} you will get automatically by each call of them the next
choice of the multi selection. So there is no difference if the items
are chosen together or each after each !

After a call to @{" MakeMenuEntry " LINK SFCT-MakeMenuEntry} you can reach the
NewMenu structure of the created menu item using the following expressions,
e.g. to set the userData field:

    GUI^.newMenus^[GUI^.actmenu-1]^.userData := MyData    or

    GUI^.menuAdr^.userData := MyData   when using at least version 38.0.

This userData field can be used together with the @{" GFLG_CallMenuData flag " LINK SSTRUCT-GUIInfoFlagSet}
to call a function which is run by @{" HandleIntMsg " LINK SFCT-HandleIntMsg} if the menu item is
selected.
You can use the @{" MenuFct " LINK SSTRUCT-MenuFct} or the @{" NewMenuFct " LINK SSTRUCT-MenuFct} declaration for you function.
For example if you want a function to quit your program, which asks
the user if he really wants to quit, you can do this in the following
way: (For this version 38.1 is required !)

- Create the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} using @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}
- Specify the @{" GUI_CompilerReg tag " LINK SSTRUCT-GUITags} and set the value to SYSTEM.REG(A4)
- Set the @{" GFLG_CallMenuData flag " LINK SSTRUCT-GUIInfoFlagSet}
- Create a menu with a quit menu item and set it's userData field to
  the address of the following function:

  ULONG menuQuit(register __a0 GUIInfo *gui)

  {
    long oldA4;
    oldA4 = getreg(A4);
    putreg(A4, gui->compilerReg);           /* Without this we can't use
                                            any global data or call any
                                            library function ! */
    if (ShowRequesterA(gui, "Do you really want to quit ?",
                       doitReqKind, NULL) == reqDo)
      putreg(A4, oldA4);  /* restore A4 */
      return (0);   (* end the message loop ! *)
    else
      putreg(A4, oldA4);  /* restore A4 */
      return (1);   (* Wait for the next message *)
  }


See also: @{" newMenus " LINK SSTRUCT-GUIInfo-newmenus}, @{" actmenu " LINK SSTRUCT-GUIInfo-actmenu}, @{" menuAdr " LINK SSTRUCT-GUIInfo-menuAdr}

@ENDNODE

@NODE SCHAP-DealingFonts "Dealing with fonts"

The returned TextAttr pointer by @{" TopazAttr() " LINK SFCT-TopazAttr} to the topaz/8 font
can be used together with @{" OpenIntScreen " LINK SFCT-OpenIntScreen} / @{" OpenIntScreenTags " LINK SFCT-OpenIntScreenTags}
to make sure which font the screen uses.
This pointer is also very useful for the gadget creation on a window
which is opened on a public screen. You can set the textAttr field
of the @{" newgad field " LINK SSTRUCT-GUIInfo-newgad} to the returned pointer and then the problem
to adjust the GUI to an unknown font is solved.
You only have to adapt to the font of the window title. This can be
easily done setting the @{" GFLG_AddBorderDims flag " LINK SSTRUCT-GUIInfoFlagSet} in the @{" flags field " LINK SSTRUCT-GUIInfo-flags}.
Due to this all gadgets will appear inside the font regardless of the
used font.
If you then also set the gadget font to @{" TopazAttr() " LINK SFCT-TopazAttr} and use the
waInnerWidth, waInnerHeight and waAutoAdjust tags together with
@{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags} you have a ever nice looking GUI,
regardless of the default fonts for the public screen.

@ENDNODE

@NODE SCHAP-KeyEquivalents "Key equivalents (V38.0)"

It is a pitty that gadtools only supports key equivalents by underlining
the belonging character.
GUITools does a lot of extra work:
When creating a gadget set the @{" GFLG_VanillaKeysNotify flag " LINK SSTRUCT-GUIInfoFlagSet} and now
GUITools saves all key equivalents which are letters.
If you also set the @{" GFLG_ConvertKeys flag " LINK SSTRUCT-GUIInfoFlagSet} you will automatically get
a gadget message instead of a key message when using @{" WaitIntMsg " LINK SFCT-WaitIntMsg}
or @{" GetIntMsg " LINK SFCT-GetIntMsg}. GUITools converts these messages.
Notice that GUITools only changes the extra fields in the GUIInfo structure
but not the @{" im field " LINK SSTRUCT-GUIInfo-im}. This field reminds unchanged !
The consequence is, when receiving a message you have to use the extra
fields of the GUIInfo structure and not the @{" im field " LINK SSTRUCT-GUIInfo-im} ! (@{" msgClass field " LINK SSTRUCT-GUIInfo-msgClass},
@{" cardCode field " LINK SSTRUCT-GUIInfo-CodeEntries} etc)

But what, if you want to use key equivalents which aren't letters ?
For example the AmigaGuide does so for browsing through the text (< and >).
IF you haven't set the @{" GFLG_AllowAllVanillaKeys flag " LINK SSTRUCT-GUIInfoFlagSet}, GUITools refuses to
create such a gadget. But if this flag is set, you can create these
gadgets, but they are not handled automatically.
For this reason the @{" VanKeyFct " LINK SSTRUCT-VanKeyFct} was created. This function is called
if the @{" GFLG_CallVanillaKeyFct flag " LINK SSTRUCT-GUIInfoFlagSet} is set and if the @{" vanKeyHook field " LINK SSTRUCT-GUIInfo-vanKeyHook}
contains a pointer to such a function.

Example: Imagine, you want to program your own hypertext tool. Despite of
         a lot of other gadgets and menus you have a 'Browse _>' and a
         'Browse _<' gadget. The first one has the ID 5 and the second
         one the ID 6.

         Your @{" VanKeyFct " LINK SSTRUCT-VanKeyFct} could look like this:

      ULONG KeyFctDemo(register __d0 char key,
                       register __a0 WORD *nbr,
                       register __a1 WORD *shift)
      (* We don't need __saveds , because no global data is used *)
      {
        if (key == '<')
        {
          nbr   = 5;
          shift = 0;
          return (1);
        }
        if (key == '>')
        {
          nbr   = 6;
          shift = 0;
          return (1);
        }
        (* Sorry, this key wasn't for me *)
        return (0);
      }

@ENDNODE

@NODE SCHAP-ResizableGadgets "Resizable gadgets (V38.0)"

Introduction

  More and more it is becoming more popular to make the GUI font
  sensitive and resizable.
  For this reasion GUITools provides some functions which support
  this behaviour and which make it possible to adapt the GUI
  starting with version 38.0.

Font sensitive

  First you have to calcute the size of the window regarding the
  used font. Then call @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags} together with the
  waInnerWidth, waInnerHeight tags. Also use the waAutoAdjust tag with a
  value of TRUE.
  To have the gadgets inside the window use the @{" GFLG_AddBorderDims flag " LINK SSTRUCT-GUIInfoFlagSet}.
  Use @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} instead of @{" CreateGUIInfo " LINK SFCT-CreateGUIInfo} and a lot of problems
  have disappeared. See chapter @{" Creating gadgets " LINK SCHAP-CreatingGadgets}.

Resizable gadgets

  When running under version 38.0 or higher you can use the following
  method to resize gadgets. Using this method you have do to the cal-
  culation of the new sizes and positions for yourself:

  When creating the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} you must use @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}
  along with the @{" GUI_ResizableGads tag " LINK SSTRUCT-GUITags} set to TRUE.
  If you get a IDCMP_NEWSIZE message, calculate the new size for each
  gadget and call @{" ResizeGadget " LINK SFCT-ResizeGadget} with the new values.
  Then simply call @{" RedrawGadgets " LINK SFCT-RedrawGadgets} and your GUI will fit into the window.

  Starting with version 38.1 there is another possibility of resizing
  gadgets. GUITools does the calculations for you, but this requires
  another way of defining the gadgets' positions and sizes:

  When creating the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} you must use @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}
  along with the @{" GUI_ResizableGads tag " LINK SSTRUCT-GUITags} set to TRUE and the
  @{" GUI_UseGadDesc tag " LINK SSTRUCT-GUITags} set to TRUE !
  From now on when defining a gadget the gadget creating functions search
  for the @{" SG_GadgetDesc " LINK SSTRUCT-SgTags} and @{" SG_GadgetObjects " LINK SSTRUCT-SgTags} tags to find out the
  gadget's position and size !
  These tags allow it to specify the position and size in an object
  orientated way. This means, you say this gadget has a distance to that
  gadget of 10. In the current version you can specify the distance to
  other gadgets or to the window borders.
  To make the calculation easier you have to define the GUI for a certain
  window size ! The GUI for other window sizes is calculated out of the
  new window size in proportion to the certain one !
  Because the GUI is always inside the window, which means inside the
  window borders, you have to open the window using the waInnerWidth and
  waInnerHeight tags ! When creating the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} GUITools
  saves these values in the @{" winIWidth " LINK SSTRUCT-GUIInfo-winISize} and the @{" winIHeight field " LINK SSTRUCT-GUIInfo-winISize}.
  When now the size of the window changes, GUITools can determine using
  these fields how far the size has changed and recalculate the gadgets
  If you want to open your window in a size the user can define, this can
  easily done in the following way:
  - Open the window with the user defined size
  - Create the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo}
  - Set the @{" winIWidth " LINK SSTRUCT-GUIInfo-winISize} and the @{" winIHeight field " LINK SSTRUCT-GUIInfo-winISize} to the inner size of the
    window for which the GUI definition is for
  - Create the GUI for the window size the @{" winIWidth " LINK SSTRUCT-GUIInfo-winISize} and @{" winIHeight " LINK SSTRUCT-GUIInfo-winISize}
    fields are set to
  The resizing for the user defined window size is then done by GUITools.

  But now the hardest part, the defining of the gadget's positions and
  sizes ! (If you don't understand this reading the first time, don't
  give up, because my explanations are not as clearly as I wanted them
  to be, but take also a look at the demos for resizable gadgets and
  perhaps you will know what GUITools can do !)
  For every gadget attribute (left edge, top edge, width and height)
  GUITools uses a description byte. This byte consists of three parts:
  1.) The distance kind:
      @{" distNorm " LINK SSTRUCT-Constants}   This is the normal distance, that means the attribute
                   is handled in the same way as without this byte. This
                   distance is for constant positions and sizes. The
                   @{" GFLG_AddBorderDims flag " LINK SSTRUCT-GUIInfoFlagSet} can be used together with
                   this.
      @{" distAbs " LINK SSTRUCT-Constants}    This specifies the distance to a given object. The size
                   of the window is not regarded. The distance will always
                   be the same.
      @{" distRel " LINK SSTRUCT-Constants}    This distance is also a distance from a given object.
                   But if the window size changes, the distance will change
                   in the same way.
      @{" distPercent " LINK SSTRUCT-Constants} In the first way this does the same as distNorm,
                   but if now the window size changes, the distance will
                   change in the same way. The @{" GFLG_AddBorderDims flag " LINK SSTRUCT-GUIInfoFlagSet} is
                   supported.
  2.) The object kind:
      If you use @{" distAbs " LINK SSTRUCT-Constants} or @{" distRel " LINK SSTRUCT-Constants} GUITools needs also the kind of the
      object the distance is to.
      @{" objBorder " LINK SSTRUCT-Constants}    this is the window border
      @{" objGadget " LINK SSTRUCT-Constants}    the distance to another gadget
  3.) The object part
      If you specify the distance to another object, you also have to say
      to which part of the object.
      This can be @{" objRight, objLeft, objBottom or objTop " LINK SSTRUCT-Constants}
  And that's all ! Really simple, isn't it. But how can you tell GUITools
  these descriptions. For this reason there is the @{" SG_GadgetDesc tag " LINK SSTRUCT-SgTags}.
  Because every tag has a data value of 32 Bits, it is possible to store
  the information for all four attributes into one tag !
  The highest byte contains the left edge, the next byte the top edge,
  the next byte the width and the lowest byte the height of the gadget !
  To build this information data, you can use the @{" GADDESC " LINK SFCT-GADDESC} macro or you
  can shift the information with the @{" shift constants " LINK SSTRUCT-Constants}.
  If you specify an attribute's distance to another gadget, normally the
  previous created gadget is used. If you want to define the distance to
  a different one, you have to use the @{" SG_GadgetObjects tag " LINK SSTRUCT-SgTags}.
  It has the same structure as the @{" SG_GadgetDesc tag " LINK SSTRUCT-SgTags} except that
  every byte represents a gadget number. But you can only use gadgets
  which are already created !
  For more information refer to the included demo source files !
  Here follows a short example: You want to create a gadget, which is
  10 points from the left and the top border and which right border is 20
  away from the left border of the first created gadget (gadget number 0)
  and the top border has a distance of 10 points to the second created
  gadget (with gadget number 2):

    CreateGadgetNew(GUI, 10, 10, -20, -10, ANYKIND,
                    SG_GadgetDesc, GADDESC(distAbs + objBorder + objLeft,
                                          distAbs + objBorder + objTop,
                                          distAbs + objGadget + objLeft,
                                          distAbs + objGadget + objTop),
                    SG_GadgetObjects, GADOBJS( 0, 0, 0, 1), NULL);
  @{" GADOBJS " LINK SFCT-GADOBJS} is a macro to build the data for the @{" SG_GadgetObjects tag " LINK SSTRUCT-SgTags}.

  When the @{" GFLG_DoResizing flag " LINK SSTRUCT-GUIInfoFlagSet} is set and the internal call to
  @{" RedrawGadgets " LINK SFCT-RedrawGadgets} failt, you will get the IDCMP_NEWSIZE message,
  otherwise you won't !


  If you use gadgets like GENERIC_KIND or such where you have to add some
  important values after the creation (usually these are GENERIC_KIND
  gadgets), you have to use @{" RedrawGadgets " LINK SFCT-RedrawGadgets}(GUI, FALSE), because GUITools
  can't save the adds you make for these gadgets ! Now you have to
  make this adds again and then call @{" SetGUI " LINK SFCT-SetGUI}.
  For this reason it is not possible for those gadgets to use the
  @{" GFLG_DoResizing flag " LINK SSTRUCT-GUIInfoFlagSet} ! Call first @{" DoResizing " LINK SFCT-DoResizing} and then @{" RedrawGadgets " LINK SFCT-RedrawGadgets},
  make the adds and then call @{" SetGUI " LINK SFCT-SetGUI} when a IDCMP_NEWSIZE message
  arrives !

@ENDNODE

@NODE SCHAP-UsingRequesters "Using requesters (V38.0)"

All requester features are only available starting with version 38.0 !


Redirection requesters

Using @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags} you are able to change the pr_WindowPtr field
of the process structure to your window which forces the requesters to
appear on this window.
It is also possible to tell @{" FreeGUIInfo " LINK SFCT-FreeGUIInfo} to restore the old value of
the pr_WindowPtr field.
This can be done by using the @{" GUI_SetProcessWindow tag " LINK SSTRUCT-GUITags} and the
@{" GUI_RestoreProcessWindow tag " LINK SSTRUCT-GUITags}.
If you are using only one window there will be no problems, but if you
are having multiple windows opened and you are using the above mentioned
tags you should have in mind this:
You open the first window, the field in the process structure will be
changed and the old value is saved. You open the next window and now
the field in the process structure is again changed and the old value
is saved, but this is the pointer to the first opened window !
If you are now closing the windows resp freeing the @{" GUIInfo " LINK SSTRUCT-GUIInfo} using
@{" FreeGUIInfo " LINK SFCT-FreeGUIInfo} (which is automatically called by @{" CloseIntWindow " LINK SFCT-CloseIntWindow}) it is
required that the windows are closed in reverse order to have the
correct value restored in the pr_WindowPtr field of the process structure.
But if you are clever and read this documentation, you will use
@{" CloseIntScreen " LINK SFCT-CloseIntScreen} which does the closing of the windows for you ! But now
you have no chance to controll the order of closing windows !
So if you are using multiple windows use the tags only for one window !
Your own created requesters can appear on your own window using
@{" ShowRequester " LINK SFCT-ShowRequester} without modifying the process structure ! This is only
necessary for system requester !
You can also change the pr_WindowPtr field of the process structure
by using @{" SetProcessWindow " LINK SFCT-SetProcessWindow} !


Own standard requesters

Using the @{" ShowRequester " LINK SFCT-ShowRequester} functions it is very simple to create your
own requesters:

There are some tags to descripe the requester. See the @{" SrTags " LINK SSTRUCT-SrTags}
GUITools still knows some requester kinds:

  @{" okReqKind " LINK SSTRUCT-Constants}   : This requester only contains one "OK" gadget.
                  The return value is always @{" reqOK "LINK SSTRUCT-Constants}.

  @{" doitReqKind " LINK SSTRUCT-Constants} : This requester has a "NO" and a "YES" gadget.
                  The return value will be @{" reqDo " LINK SSTRUCT-Constants} for "YES"
                  and otherwise @{" reqLeave " LINK SSTRUCT-Constants}.

  @{" yncReqKind " LINK SSTRUCT-Constants}  : Yes/No/Cancel requester. It has a "YES", a "NO"
                  and a "CANCEL" gadget and returns @{" reqYes " LINK SSTRUCT-Constants},
                  @{" reqNo " LINK SSTRUCT-Constants} or @{" reqCancel " LINK SSTRUCT-Constants}.

With this predefined requesters you don't have to use the @{" SR_Gadgets tag " LINK SSTRUCT-SrTags},
but you can use it e.g. to display the text in a different language.
If you want to create a totally different requester, create a
@{" generalReqKind " LINK SSTRUCT-Constants} requester. Now you must specify the @{" SR_Gadgets tag " LINK SSTRUCT-SrTags}.
For these requesters GUITools uses the EasyRequestArgs function. With the
@{" SrTags " LINK SSTRUCT-SrTags} you can reach every field of the EasyStruct structure !
@{" ShowRequester " LINK SFCT-ShowRequester} returns the value of EasyRequestArgs.
IF you specify a @{" GUIInfo pointer " LINK SSTRUCT-GUIInfo} the requester appears on the window this
pointer is for. If you set it to NULL the pr_WindowPtr field of the process
structure is used. But you can override these values by using the
@{" SR_ReqWindow tag " LINK SSTRUCT-SrTags} !
The @{" SimpleReq " LINK SFCT-SimpleReq} function provides an easier interface to the requesters,
because you only have to specify the text and the kind.


Using asl requesters

Starting with version 38.1 GUITools can display also a file and a
directory requester using the asl.library.
Pass @{" ShowRequester " LINK SFCT-ShowRequester} @{" fileReqKind " LINK SSTRUCT-Constants} or @{" dirReqKind " LINK SSTRUCT-Constants}.
The text parameter contains the title, which can be also specified
using the @{" SR_Title tag " LINK SSTRUCT-SrTags}. The requester returns @{" reqAslOK " LINK SSTRUCT-Constants} or
@{" reqAslCancel " LINK SSTRUCT-Constants}.
The redirection of asl requesters follows the rules mentioned above.
In addition you can use the following @{" SrTags " LINK SSTRUCT-SrTags}. Don't use any other
tags as mentioned below !

 @{" SR_AslNameBuffer " LINK SSTRUCT-SrTags} This is a pointer to a buffer, which will contain
                   the complete filename after the user selection.
                   You can specify here a complete filename which
                   will be displayed when the requester opens.
                   Keep this buffer big enough. A value of 512 bytes
                   or even more is advised. GUITools doesn't check
                   this size !
                   Don't use this tag together with @{" SR_AslDirBuffer " LINK SSTRUCT-SrTags}
                   or @{" SR_AslFileBuffer " LINK SSTRUCT-SrTags}.

 @{" SR_AslFileBuffer " LINK SSTRUCT-SrTags} Points to a buffer which will contain only the
                   filename without the path. Don't use this tag
                   together with @{" SR_AslNameBuffer " LINK SSTRUCT-SrTags}.

 @{" SR_AslDirBuffer " LINK SSTRUCT-SrTags}  Points to a buffer which will contain only the
                   path without the filename. Don't use this tag
                   together with @{" SR_AslNameBuffer " LINK SSTRUCT-SrTags}.

 @{" SR_AslPattern " LINK SSTRUCT-SrTags}    Pointer to a file pattern. If you don't want a
                   file pattern gadget to be displayed set this
                   tag to NULL.

 @{" SR_AslSave " LINK SSTRUCT-SrTags}       This boolean tag says if the requester is for
                   saving something or not. The default is FALSE:

GUITools uses automatically a new IDCMP port for the requester. You
can also define all tags (defined in AslD) for asl requesters.
But notice, @{" ShowRequester " LINK SFCT-ShowRequester} uses the following tags, which you should
not use, use the @{" SrTags " LINK SSTRUCT-SrTags} instead:

  ASLFR_Window, ASLFR_TitleText, ASLFR_InitialFile, ASLFT_InitialDrawer
  and ASLFR_InitialPattern.

GUITools uses also the ASLFR_Flags1 and ASLFR_Flags2 tags. If you need these
tags, please notice that you have to specify again the FRF_DOPATTERNS,
FRF_DOSAVEMODE, FRF_DRAWERSONLY and FRF_PRIVATEIDCMP flags which are usually
set by using the @{" SrTags " LINK SSTRUCT-SrTags} !
Don't use the @{" SR_AslFileBuffer tag " LINK SSTRUCT-SrTags} together with the @{" dirReqKind " LINK SSTRUCT-Constants}
requester, because this requester is only for directories.

If you want to display a requester, where the user should choose
the best shared library, you could do this:
To help the user choosing, you use the pattern '#?.library' and
you make of course the suggestion of 'sys:libs/guitools.library'. But
the silly user chooses 'sys:libs/asl.library' !
You have generally these two possibilities:

   - First possibility :

       char file[256], dir[256]; /* two different variables
                                    one for the path and
                                    one for the filename */
         ...

       file = "guitools.library";
       dir  = "sys:libs";

       ShowRequester(NULL, fileReqKind, "Choose the best Library",
                     SR_AslFileBuffer, &file,
                     SR_AslDirBuffer, &dir,
                     SR_AslPattern, "'#?.library",
                     NULL);

     The result is :

       file == "asl.library";
       dir  == "sys:libs";

   - Second possibility :

       char buffer[512]; /* the full filename with the whole path */
         ...

       name = "sys:libs/guitools.library";

       ShowRequester(NULL, fileReqKind, "Choose the best library",
                     SR_AslPattern, "#?.library",
                     SR_AslNameBuffer, &name, NULL);

     The result is:

       name == "sys:libs/asl.library";


In the current version it is NOT (yet) possible to use the multiselect
function ! If you need this, please use the asl.library instead.

@ENDNODE

@NODE SCHAP-3 "Bugs / Problems"

   @{" Problems under V37.3 " LINK SCHAP-3-1}

   @{" Known Bugs " LINK SCHAP-KnownBugs}

   @{" Author / Final Words " LINK SCHAP-Author}

@ENDNODE

@NODE SCHAP-3-1 "Problems under V37.3"

   @{" Menu font handling (CreateGUIInfo vs CreateGUIInfoTags) " LINK SCHAP-Problems-CreateGUIInfo}

   @{" Screen title (OpenIntWindow vs OpenIntWindowTags) " LINK SCHAP-Problems-OpenIntWindow}

   @{" IDCMP_MenuPick messages " LINK SCHAP-Problems-IDCMP_MenuPick}

@ENDNODE

@NODE SCHAP-Problems-CreateGUIInfo "Menu font handling (CreateGUIInfo vs CreateGUIInfoTags)"

Too late, after the release of version 37.3, I recognized that it makes
no sense to use the window's font for the menu. As long as you open an
own screen - as I often do - there are no problems because screen and
window have the same font.
But if you want to open your window on a public screen (e.g. Workbench),
the menu might look a little bit foreign.
The solution is to use the screen's font for the menu. But this is easy
to say and not easy to do ! Due to the @{" GUIInfo structure " LINK SSTRUCT-GUIInfo} under V37.3
it was not possible to do this in an upward compatible way under V38.0.
The consequence is you have this problem stil when using @{" CreateGUIInfo " LINK SFCT-CreateGuiInfo}.
Then you have do set the menu font by hand !
Running under V38.0 or higher you only have to use @{" CreateGUIInfoTags " LINK SFCT-CreateGUIInfoTags}
instead and the menu uses the screen's font.

@ENDNODE

@NODE SCHAP-Problems-OpenIntWindow "Screen title (OpenIntWindow vs OpenIntWindowTags)"

After the release of version 37.3 I noticed that it is not always useful
to set the screen's title to the window title when opening a window on
a public screen (Workbench). But this is done by @{" OpenIntWindow " LINK SFCT-OpenIntWindow}.
To be upward compatible OpenIntWindow still use the waScreenTitle tag,
but when running under V38.0 or higher you can use @{" OpenIntWindowTags " LINK SFCT-OpenIntWindowTags}
instead. This function doesn't use the tag, although you can specify it.

@ENDNODE

@NODE SCHAP-Problems-IDCMP_MenuPick "IDCMP_MenuPick messages"

Under version 37.3 there was no check if a IDCMP_MenuPick message had
a multi selection. It was treated as a usual single selection. So you
had to check this by yourself !
Running under V38.0 (or higher) you don't need to worry about multi
selection if you use @{" GetIntMsg " LINK SFCT-GetIntMsg} or @{" WaitIntMsg " LINK SFCT-WaitIntMsg}.
Because with every call to @{" GetIntMsg " LINK SFCT-GetIntMsg} resp @{" WaitIntMsg " LINK SFCT-WaitIntMsg} you get one
selection of the multi selection like the items were selected separa-
tely.
If you don't use them and you call @{" HandleIntMsg " LINK SFCT-HandleIntMsg} by hand, you have to
check for multi selection by yourself again ! You only get the first
selection !

@ENDNODE

@NODE SCHAP-KnownBugs "Known Bugs"

The known bugs are descriped in the functions' explanations they are
bound to.


Unkown Bugs

I am using GUITools every day in a lot of different programs without
complaining.
Of course this does not mean, that there are no more bugs, but I hope
that I have found all of the REAL BIG BUGS.
If you stick to the guidelines and read the manual very closely, every-
thing should be alright.
But if you have nevertheless a problem or found a bug, please, do the
following steps:

 1.  Locate the bug as precise as possible.
 2.  Please leave the @{" author " LINK SCHAP-Author} a not with a precise bug description and
     perhaps if possible mention the cause or a solution !

If I get to know a bug, I will try to correct it as soon as possible !

@ENDNODE

@NODE SCHAP-Author "Author / Final Words"

Before you are delivered from this boring documentation, I have to do
some apologies:
The whole documentation is not entitled to be complete, without any
mistakes or at least understandable, although I worked really very
hard on it.
If you don't know how to program an Amiga, you can throw the documenta-
tion away. In many cases a left some explanations you can find in the
RKRMs. If you are familar with them, you will probably have no problems.

To reach a "wider audience" I tried to translate the definitions and
the documentation into the english language. I hope you can understand
it and that there will noone who died by laughing at these texts !

Suggestions, bug reports, improvements, extensions and of course
appreciation, too, can be send to the following address:

    Carsten Ziegeler
    Augustin-Wibbelt-Str. 7
    D-33106 Paderborn
    Germany


ATTENTION: There will be no warranty or responsibility for posted goods.
           If you want to have your work back, you must include enough
           return postage I can use here in germany (e.g. german money
           or german stamps, but not e.g. english stamps or french food).
           All posting will be at your own risk and of your own free will.

You can reach me also under the following EMail-Address:

         tarot@uni-paderborn.de

So please, if possible use electronic mail to avoid any problems !


    Enjoy it !

@ENDNODE
