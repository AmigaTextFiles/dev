%---------------- Functions ------------

\chapter{Notify.mui/Notify.mui}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf FUNCTION]
Notify class is superclass of all other MUI classes.
It's main purpose is to handle MUI's notification
mechanism, but it also contains some other methods
and attributes useful for every object.

\end{deflist}


\subsection{Notify.mui/MUIA\_AppMessage}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_AppMessage]  -- (V5 ) [..G], struct AppMessage *
\end{description}

\item[\bf FUNCTION]
When your window is an AppWindow, i.e. you have set the
MUIA\_Window\_AppWindow attribute to TRUE, you will be able
to get AppMessages by listening to MUIA\_AppMessage.
Whenever an AppMessage arrives, this attribute will
be set to a pointer to that message.

MUIA\_AppMessage is object specific. You can e.g. set up
different notifications for different objects in your window,
they will only get exectued when icons are dropped over the
specific object.

If you wait on MUIA\_AppMessage with a window object, your
notify will always get executed when icons are dropped on
the window.

Notes:

- You should use the MUIM\_CallHook method to call a
  hook function when an AppMessage arrives (see below).
  The pointer to the AppMessage is valid only as long as
  the notification method is executed.

- AppWindows are only possible on the workench screen.


\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
/* Call the AppMsgHook when an icon is dropped on a listview */

DoMethod(lvobj,MUIM_Notify,MUIA_AppMessage,MUIV_EveryTime,
         lvobj,3,MUIM_CallHook,&AppMsgHook,MUIV_TriggerValue);

/* Call the AppMsgHook when an icon is dropped on the window */

DoMethod(winobj,MUIM_Notify,MUIA_AppMessage,MUIV_EveryTime,
         winobj,3,MUIM_CallHook,&AppMsgHook,MUIV_TriggerValue);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_AppWindow, MUIA\_Application\_DropObject, MUIM\_CallHook
\end{deflist}


\subsection{Notify.mui/MUIA\_ApplicationObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_ApplicationObject]  -- (V4 ) [..G], Object *
\end{description}

\item[\bf FUNCTION]
You can obtain a pointer to the application object
that some gadget belongs to by using this attribute.
Useful mainly within callback hooks if you do not want
to deal with global variables.

If your object is not currently attached to an application,
you will receive NULL.

\item[\bf SEE ALSO]
MUIA\_WindowObject
\end{deflist}


\subsection{Notify.mui/MUIA\_HelpLine}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_HelpLine]  -- (V4 ) [ISG], LONG
\end{description}

\item[\bf FUNCTION]
Define a line in a help file specified with
MUIA\_Application\_HelpFile.

\item[\bf SEE ALSO]
MUIA\_Application\_HelpFile, MUIA\_HelpNode
\end{deflist}


\subsection{Notify.mui/MUIA\_HelpNode}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_HelpNode]  -- (V4 ) [ISG], STRPTR
\end{description}

\item[\bf FUNCTION]
Define a node in a help file specified with
MUIA\_Application\_HelpFile.

\item[\bf SEE ALSO]
MUIA\_Application\_HelpFile, MUIA\_HelpLine
\end{deflist}


\subsection{Notify.mui/MUIA\_NoNotify}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_NoNotify]  -- (V7 ) [.S.], BOOL
\end{description}

\item[\bf FUNCTION]
If you set up a notify on an attibute to react on user input,
you will also recognize events when you change this attribute
under program control with SetAttrs(). Setting MUIA\_NoNotify
together with your attribute will prevent this notification
from being triggered.

\item[\bf NOTE]
MUIA\_NoNotify is a "'one time"' attribute. Its only valid during
the current SetAttrs() call!

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
SetAttrs(slider,MUIA_NoNotify,TRUE,MUIA_Slider_Level,26,TAG_DONE);
\end{verbatim}
\end{flushleft}
\end{deflist}


\subsection{Notify.mui/MUIA\_Parent}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Parent]  -- (V11) [..G], Object *
\end{description}

\item[\bf FUNCTION]
Get a pointer to the parent object of the current object.
The parent obect is always the group/family object which
contains the current object. If an object has no parent
group, this attribute will be NULL.

\item[\bf SEE ALSO]
group.mui/MUIA\_Group\_Child
\end{deflist}


\subsection{Notify.mui/MUIA\_Revision}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Revision]  -- (V4 ) [..G], LONG
\end{description}

\item[\bf FUNCTION]
Get the revision number of an objects class. Although
MUIA\_Revision is documented at notify class, you will
of course receive the revision number of the objects true
class.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
strobj = MUI_NewObject(MUIC_String,...,TAG_DONE);
 ...
get(strobj,MUIA_Version ,&v);
get(strobj,MUIA_Revision,&r);
printf("String class version %ld.%ld\n",v,r);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Version
\end{deflist}


\subsection{Notify.mui/MUIA\_UserData}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_UserData]  -- (V4 ) [ISG], ULONG
\end{description}

\item[\bf FUNCTION]
A general purpose value to fill in any kind of information.
\end{deflist}


\subsection{Notify.mui/MUIA\_Version}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Version]  -- (V4 ) [..G], LONG
\end{description}

\item[\bf FUNCTION]
Get the version number of an objects class. Although
MUIA\_Version is documented at notify class, you will
of course receive the version number of the objects true
class.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
strobj = MUI_NewObject(MUIC_String,...,TAG_DONE);
 ...
get(strobj,MUIA_Version ,&v);
get(strobj,MUIA_Revision,&r);
printf("String class version %ld.%ld\n",v,r);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Revision
\end{deflist}


\subsection{Notify.mui/MUIM\_CallHook}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_CallHook (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_CallHook,struct Hook *Hook, ULONG param1, /* ... */);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Call a standard amiga callback hook, defined by a Hook
structure. Together with MUIM\_Notify, you can easily
bind hooks to buttons, your hook will be called when
the button is pressed.

The hook will be called with a pointer to the hook
structure in a0, a pointer to the calling object in a2
and a pointer to the first parameter in a1.

\item[\bf INPUTS]
Hook       pointer to a struct Hook.
param1,... zero or more parameters. The hook function will
           receive a pointer to the first parameter in
           register a1.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
standalone:

DoMethod(obj,MUIM_CallHook,&hookstruct,13,42,"foobar","barfoo");

within a notification statement:

DoMethod(propobj,MUIM_Notify,MUIA_Prop_First,MUIV_EveryTime,
         propobj,3,MUIM_CallHook,&prophook,MUIV_TriggerValue);

prophook will be called every time the knob is moving and gets
a pointer to the knobs current level in a1.
\end{verbatim}
\end{flushleft}
\end{deflist}


\subsection{Notify.mui/MUIM\_FindUData}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_FindUData (V8 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_FindUData,ULONG udata);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method tests if the MUIA\_UserData of the object
contains the given $<$udata$>$ and returns the object
pointer in this case.

Although this is not very useful for single objects,
performing this method on objects that handle children
can become very handy. In this case, all the children
(any maybe their children) are tested against $<$udata$>$
and the first matching object is returned.

This method is especially useful if you created your
menu tree with a NewMenu structure and you want to
find the object pointer for a single menu item.

\item[\bf INPUTS]
\begin{description}
\item[udata]  - userdata to look for.
\end{description}

\item[\bf RESULT]
A pointer to the first object with the specified user data
or NULL if no object is found.

\item[\bf NOTES]
If you have many objects in your application, MUIM\_FindUData
may take quite long. You can limit the amount of time
by performing the method not on the application but on the
window or even on the group/family your object is placed in.

\item[\bf SEE ALSO]
MUIM\_GetUData, MUIM\_SetUData
\end{deflist}


\subsection{Notify.mui/MUIM\_GetUData}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_GetUData (V8 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_GetUData,ULONG udata, ULONG attr, ULONG *storage);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method tests if the MUIA\_UserData of the object
contains the given $<$udata$>$ and gets $<$attr$>$ to
$<$storage$>$ for itself in this case.

Although this is not very useful for single objects,
performing this method on objects that handle children
can become very handy. In this case, all the children
(any maybe their children) are searched against $<$udata$>$
and the first matching objects will be asked for the
specified attribute.

\item[\bf INPUTS]
\begin{description}
\item[udata  ]  - userdata to look for.
attr    - attribute to get.
\item[storage]  - place to store the attribute.
\end{description}

\item[\bf NOTES]
If you have many objects in your application, MUIM\_GetUData
may take quite long. You can limit the amount of time
by performing the method not on the application but on the
window or even on the group/family your objects are place in.

\item[\bf SEE ALSO]
MUIM\_SetUData, MUIM\_FindUData
\end{deflist}


\subsection{Notify.mui/MUIM\_KillNotify}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_KillNotify (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_KillNotify,ULONG TrigAttr);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
MUIM\_KillNotify kills previously given notifications on specific
attributes.

\item[\bf INPUTS]
\begin{description}
\item[TrigAttr]  - Attribute for which the notify was specified. If you
           set up more than one notify for an attribute, only
           the first one will be killed.
\end{description}

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
DoMethod(button,MUIM_KillNotify,MUIA_Pressed);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_Notify
\end{deflist}


\subsection{Notify.mui/MUIM\_MultiSet}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_MultiSet (V7 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_MultiSet,ULONG attr, ULONG val, APTR obj, /* ... */);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set an attribute for multiple objects.
Receiving an attribute/value pair and a list of objects,
this method sets the new value for all the objects in the list.
This is especially useful for disabling/enabling lots of
objects with one singe function call.

The object that executes this method isn't affected!

Note: This method was implemented in version 7 of notify class.

\item[\bf INPUTS]
attr     attribute to set.
value    new value for the attribute.
obj, ... list of MUI objects, terminated with a NULL pointer.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
/* disable all the address related gadgets... */

DoMethod(xxx, MUIM_MultiSet, MUIA_Disabled, TRUE,
   ST_Name, ST_Street, ST_City, ST_Country, ST_Phone, NULL);

/* note that the xxx object doesn't get disabled! */
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_Set, MUIM\_Notify
\end{deflist}


\subsection{Notify.mui/MUIM\_NoNotifySet}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_NoNotifySet (V9 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_NoNotifySet,ULONG attr, char *format, ULONG val, /* ... */);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Acts like MUIM\_Set but doesn't trigger any notification.
This can become useful to avoid deadlocks with bi-directional
connections.

\item[\bf INPUTS]
attr  attribute you want to set.
val   value to set the attribute to.

\item[\bf EXMAPLE]
\begin{flushleft}
\begin{verbatim}
DoMethod(editor,MUIM_Notify,EDIT_Top,MUIV_EveryTime,
   sbar,3,MUIM_NoNotifySet,MUIA_Prop_First,MUIV_TriggerValue);

DoMethod(sbar,MUIM_Notify,MUIA_Prop_First,MUIV_EveryTime,
   editor,3,MUIM_NoNotifySet,EDIT_Top,MUIV_TriggerValue);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_Set
\end{deflist}


\subsection{Notify.mui/MUIM\_Notify}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Notify (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Notify,ULONG TrigAttr, ULONG TrigVal, APTR DestObj, ULONG FollowParams, /* ... */);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Add a notification event handler to an object. Notification
is essential for every MUI application.

A notification statement consists of a source object,
an attribute/value pair, a destination object and a
notification method. The attribute/value pair belongs
to the source object and determines when the notification
method will be executed on the destination object.

Whenever the source object gets the given attribute set to
the given value (this can happen because of the user
pressing some gadgets or because of your program explicitly
setting the attribute with SetAttrs()), the destination
object will execute the notification method.

With some special values, you can trigger the notification
every time the attribute is changing. In this case, you
can include the triggering attributes value within the
notification method. See below.

One big problem with notification are endless loops.
Imagine you have a prop gadget and want to show its
state with a gauge object. You connect MUIA\_Prop\_First
with MUIA\_Gauge\_Max and everything is fine, the gauge
gets updated when the user drags around the gadget. On
the other hand, if your program sets the gauge to a new
value, you might want your prop gadget to immediately
show this change and connect MUIA\_Gauge\_Max width
MUIA\_Prop\_First. Voila, a perfect endless loop.

To avoid these conditions, MUI always checks new
attribute values against the current state and
cancels notification when both values are equal.
Thus, setting MUIA\_Prop\_First to 42 if the prop
gadgets first position is already 42 won't trigger
any notification event.

\item[\bf INPUTS]
TrigAttr     attribute that triggers the notification.

TrigValue    value that triggers the notification. The
             special value MUIV\_EveryTime makes MUI execute
             the notification method every time when
             TrigAttr changes. In this case, the special
             value MUIV\_TriggerValue in the notification
             method will be replaced with the value
             that TrigAttr has been set to. You can use
             MUIV\_TriggerValue up to four times in one
             notification method. Since version 8 of
             muimaster.library, you can also use
             MUIV\_NotTriggerValue here. In this case,
             MUI will replace TRUE values with FALSE
             and FALSE values with TRUE. This
             can become quite useful when you try to set
             "'negative"' attributes like MUIA\_Disabled.

DestObj      object on which to perform the notification
             method. Either supply a valid object pointer or
             one of the following special values (V10) which
             will be resolved at the time the event occurs:
             MUIV\_Notify\_Self        - notifies the object
                                       itself.
             MUIV\_Notify\_Window      - notifies the object's
                                       parent window.
\begin{description}
\item[             MUIV\_Notify\_Application]  - notifies the object's
                                       application.
\end{description}

FollowParams number of following parameters. If you e.g.
             have a notification method with three parts
             (maybe MUIM\_Set,attr,val), you have to set
             FollowParams to 3. This allows MUI to copy
             the complete notification method into a
             private buffer for later use.

...          following is the notification method.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
/*
** Every time when the user releases a button
** (and the mouse is still over it), the button object
** gets its MUIA_Pressed attribute set to FALSE.
** Thats what a program can react on with notification,
** e.g. by openening another window.
*/

DoMethod(buttonobj,MUIM_Notify,
   MUIA_Pressed, FALSE,                /* attribute/value pair */
   windowobj,                          /* destination object   */
   3,                                  /* 3 following words    */
   MUIM_Set, MUIA_Window_Open, TRUE);  /* notification method  */

/*
** Lets say we want to show the current value of a
** prop gadget somewhere in a text field:
*/

DoMethod(propobj,MUIM_Notify,      /* notification is triggered   */
   MUIA_Prop_First, MUIV_EveryTime /* every time the attr changes */
   textobj                         /* destination object */
   4,                              /* 4 following words  */
   MUIM_SetAsString, MUIA_Text_Contents,
   "value is %ld !", MUIV_TriggerValue);
   /* MUIV_TriggerValue will be replaced with the
      current value of MUIA_Prop_First */

/*
** Inform our application when the user hits return
** in a string gadget:
*/

DoMethod(stringobj,MUIM_Notify,
   MUIA_String_Acknowledge, MUIV_EveryTime,
   MUIV_Notify_Application, 2, MUIM_Application_ReturnID, ID_FOOBAR);
\end{verbatim}
\end{flushleft}
\end{deflist}


\subsection{Notify.mui/MUIM\_Set}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Set (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Set,ULONG attr, ULONG val);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set an attribute to a value. Normally, you would set
attributes with intuition.library SetAttrs() or with
the OM\_SET method as with any other boopsi objects.
But since these calls need a complete tag list, not
just a single attribute/value pair, they are not
useful within a MUIM\_Notify method.

\item[\bf INPUTS]
attr  attribute you want to set.
val   value to set the attribute to.

\item[\bf EXMAPLE]
\begin{flushleft}
\begin{verbatim}
DoMethod(strobj,MUIM_Set,MUIA_String_Contents,"foobar");
and
SetAttrs(strobj,MUIA_String_Contents,"foobar",TAG_DONE);
are equal.
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_SetAsString, MUIM\_Notify, MUIM\_NoNotifySet
\end{deflist}


\subsection{Notify.mui/MUIM\_SetAsString}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_SetAsString (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_SetAsString,ULONG attr, char *format, ULONG val, /* ... */);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set a (text kind) attribute to a string. This can be useful
if you want to connect a numeric attribute of an object with
a text attribute of another object.

\item[\bf INPUTS]
attr    attribute to set.
format  C like formatting string, remember to use "'\%ld"' !
val,... one or more paremeters for the format string.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
stand alone:

DoMethod(txobj,MUIM_SetAsString,MUIA_Text_Contents,
         "My name is %s and I am %ld years old.",name,age);

within a notification statement:

DoMethod(propobj,MUIM_Notify,MUIA_Prop_First,MUIV_EveryTime,
         txobj,4,MUIM_SetAsString,MUIA_Text_Contents,
         "prop gadget shows %ld.",MUIV_TriggerValue);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_Set, MUIM\_Notify
\end{deflist}


\subsection{Notify.mui/MUIM\_SetUData}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_SetUData (V8 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_SetUData,ULONG udata, ULONG attr, ULONG val);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method tests if the MUIA\_UserData of the object
contains the given $<$udata$>$ and sets $<$attr$>$ to
$<$val$>$ for itself in this case.

Altough this is not very useful for single objects,
performing this method on objects that handle children
can become very handy. In this case, all the children
(any maybe their children) are tested against $<$udata$>$
and all matching objects will get the attribute set.

If you e.g. want to clear several string gadgets in
your applciation at once, you simply give them the
same MUIA\_UserData and use

DoMethod(app,MUIM\_SetUData,MyUDATA,MUIA\_String\_Contents,NULL);

\item[\bf INPUTS]
\begin{description}
\item[udata]  - userdata to look for.
attr  - attribute to set.
\item[val  ]  - value to set attribute to.
\end{description}

\item[\bf NOTES]
If you have many objects in your application, MUIM\_SetUData
may take quite long. You can limit the amount of time
by performing the method not on the application but on the
window or even on the group your gadgets are place in.

\item[\bf SEE ALSO]
MUIM\_GetUData, MUIM\_FindUData, MUIM\_SetUDataOnce
\end{deflist}


\subsection{Notify.mui/MUIM\_SetUDataOnce}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_SetUDataOnce (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_SetUDataOnce,ULONG udata, ULONG attr, ULONG val);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method performs like MUIM\_SetUData, but stops when it has
found an object with the given user data. If you don't have
objects with equal user datas and don't rely on setting all
of them, MUIM\_SetUDataOnce is preferrable because it's more
efficient.

\item[\bf SEE ALSO]
MUIM\_SetUData, MUIM\_GetUData

\end{deflist}


\subsection{Notify.mui/MUIM\_WriteLong}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_WriteLong (V6 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_WriteLong,ULONG val, ULONG *memory);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method simply writes a longword somewhere to memory.
Although this seems quite useless, it might become handy
if used within a notify statement. For instance, you could
easily connect the current level of a slider with some
member of your programs data structures.

\item[\bf INPUTS]
val    - value to write
\begin{description}
\item[memory]  - location to write the value to
\end{description}

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
/* Let the slider automagically write its level to a variable */

static LONG level;

DoMethod(slider,MUIM_Notify,MUIA_Slider_Level,MUIV_EveryTime,
   slider,3,MUIM_WriteLong,MUIV_TriggerValue,&level);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_WriteString, MUIM\_Notify
\end{deflist}


\subsection{Notify.mui/MUIM\_WriteString}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_WriteString (V6 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_WriteString,char *str, char *memory);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method simply copies a string somewhere to memory.
Although this seems quite useless, it might become handy
if used within a notify statement. For instance, you could
easily connect the current contents of a string gadget
with some member of your programs data structures.

Note: The string is copied with strcpy(), you must assure
       that the destination points to enough memory.

\item[\bf INPUTS]
str    - string to copy
\begin{description}
\item[memory]  - location to write the value to
\end{description}

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
static char buffer[256];

DoMethod(string,MUIM_Notify,MUIA_String_Contents,MUIV_EveryTime,
   string,3,MUIM_WriteString,MUIV_TriggerValue,buffer);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_WriteLong, MUIM\_Notify

\end{deflist}


%---------------- End of File ----------
