%---------------- Functions ------------

\chapter{Dataspace.mui/Dataspace.mui}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf FUNCTION]
The Dataspace class serves as a very simple container for
all kinds of data. You can add data items and reference them
later through an ID. Furthermore, Dataspace class features
methods to import/export a complete Dataspace from/to an IFF
file handle.

MUI uses subclasses of dataspace class to handle all its
configuration data and thats probably the main purpose of a
dataspace.
\end{deflist}


\subsection{Dataspace.mui/MUIA\_Dataspace\_Pool}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Dataspace\_Pool]  -- (V11) [I..], APTR
\end{description}

\item[\bf FUNCTION]
If you specify a memory pool from exec.library/CreatePool()
here, the dataspace object will use this pool for all its
entries.

If you omit this tag or pass NULL, the dataspace object
will create its own memory pool instead.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_Add, exec.library/CreatePool
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_Add}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_Add (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_Add,APTR data, LONG len, ULONG id);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method adds a new entry to the dataspace. If an entry
with the same ID already exists, it will be replaced with
the new entry.

\item[\bf INPUTS]
\begin{description}
\item[data]  - pointer to a data
len  - length of data
\item[id  ]  - reference id
\end{description}

\item[\bf RESULT]
Returns NULL on failure (probably because of a memory
shortage) or some non NULL value on success.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_Remove, MUIM\_Dataspace\_Find
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_Clear}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_Clear (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_Clear,);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method clears all the contents of a dataspace. Depending
on the state of the memory pool that the dataspace object uses,
this may or may not result in more free memory.

\item[\bf INPUTS]
none

\item[\bf RESULT]
All entries will be removed from the dataspace.
The return value of this method is currently undefined.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_Add, MUIM\_Dataspace\_Remove,
MUIM\_Dataspace\_Merge
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_Merge}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_Merge (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_Merge,Object *dataspace);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method adds all the contents of the merge dataspace
specified as parameter to the objects dataspace.
As with MUIM\_Dataspace\_Add, entries with equal IDs
 will be replaced.

\item[\bf INPUTS]
\begin{description}
\item[dataspace]  - dataspace objects whichs contents should
            be merged.
\end{description}

\item[\bf RESULT]
Returns the number of entries that have been
added/replaced in the objects dataspace. If this
number doesnt match the number of entries in the
merge dataspace, something probably went wrong.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_Add, MUIM\_Dataspace\_Remove
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_ReadIFF}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_ReadIFF (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_ReadIFF,struct IFFHandle *handle);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Adds the contents of an IFF handle from iffparse.library to
the dataspace. As always, objects with the same ID that
are already in the dataspace will be replaced.

This method does not look for any chunk types and chunk ids
itself. Instead, it expects that you have already located
the chunk which contains your data and does nothing
but ReadChunkBytes() until all dataspace entries of
the current chunk are read.

\item[\bf NOTES]
Do not call MUIM\_Dataspace\_ReadIFF if your handle is
positioned on chunks that were not written with
MUIM\_Dataspace\_WriteIFF or strange things may happen!

\item[\bf INPUTS]
\begin{description}
\item[handle]  - pointer to a struct IFFHandle from
         iffparse.library/AllocIFF(). The handle must
         already be open, initialized for reading and
         positioned on a chunk that was created with
         MUIM\_Dataspace\_WriteIFF.
\end{description}

\item[\bf RESULT]
Returns 0 on success or some IFFERR\_xxx on failure.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_ReadIFF, iffparse.library/AllocIFF
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_Remove}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_Remove (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_Remove,ULONG id);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
This method removes an entry from the dataspace.

\item[\bf INPUTS]
\begin{description}
\item[id]  - reference id
\end{description}

\item[\bf RESULT]
Returns NULL if no entry with the given ID was found
in the dataspace or some non NULL value on success.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_Add, MUIM\_Dataspace\_Find
\end{deflist}


\subsection{Dataspace.mui/MUIM\_Dataspace\_WriteIFF}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Dataspace\_WriteIFF (V11)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Dataspace_WriteIFF,struct IFFHandle *handle, ULONG type, ULONG id);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Writes the contents of a dataspace to an IFF handle of
iffparse.library.

In detail, a chunk with the specified type and id is created
with PushChunk(), the contents of the dataspace are written
with WriteChunkBytes() and the chunk is terminated with
PopChunk().

\item[\bf INPUTS]
\begin{description}
\item[handle]  - pointer to a struct IFFHandle from
         iffparse.library/AllocIFF(). The handle must
         already be open and initialized for writing.
\end{description}

\begin{description}
\item[type  ]  - type of chunk to create
\item[id    ]  - id of chunk to create
\end{description}

\item[\bf RESULT]
Returns 0 on success or some IFFERR\_xxx on failure.

\item[\bf SEE ALSO]
MUIM\_Dataspace\_ReadIFF, iffparse.library/AllocIFF
\end{deflist}


%---------------- End of File ----------
