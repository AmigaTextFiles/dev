%---------------- Functions ------------

\chapter{Window.mui/Window.mui}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf FUNCTION]
Objects of window class are used to generate windows and
supply a place where MUI gadgets feel well. It handles
the complicated task of window resizing fully automatic,
you don't need to worry about that.

Windows are children of an application, you cannot use
a window object without having a parent application
object. On the other side, the gadgets in a window
are children of the window, you cannot use MUI gadgets
without having a parent MUI window.

Creating a window object does not mean to open it
instantly. This is done later by setting the window's
MUIA\_Window\_Open attribute. If your application has
several windows, the usual way is to create them all
at once at startup time and open/close it later
just by setting MUIA\_Window\_Open.

There is no difference in talking to gadgets whether
their parent window is open or not. If you e.g. set
the contents of a string gadget in an open window,
the gadget will refresh immediately. If the window is
closed, the gadget just remembers its new setting
and displays it later.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Activate}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Activate]  -- (V4 ) [ISG], BOOL
\end{description}

\item[\bf FUNCTION]
Setting this to TRUE will activate the window.
Setting this to FALSE has no effect.
The attribute will change whenever the user
activates/deactivates the window.

Specifying FALSE at object creation time will make
the window open in an inactive state.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_ActiveObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_ActiveObject]  -- (V4 ) [.SG], Object *
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_ActiveObject_None
MUIV_Window_ActiveObject_Next
MUIV_Window_ActiveObject_Prev
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set the active object in a window as if the user
would have activated it with the tab key. The
object has to be in the cycle chain for this
command to work.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
set(window,MUIA_Window_ActiveObject,okaybutton);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIM\_Window\_SetCycleChain
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_AltHeight}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_AltHeight]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_AltHeight_MinMax(p)
MUIV_Window_AltHeight_Visible(p)
MUIV_Window_AltHeight_Screen(p)
MUIV_Window_AltHeight_Scaled
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the alternate (zoomed) height of a window.
If not present, the alternate height will be the
minimum height.

\item[\bf SEE ALSO]
MUIA\_Window\_Height, MUIA\_Window\_AltWidth
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_AltLeftEdge}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_AltLeftEdge]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_AltLeftEdge_Centered
MUIV_Window_AltLeftEdge_Moused
MUIV_Window_AltLeftEdge_NoChange
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the alternate (zoomed) left position of
a window. This defaults to the standard left
position.

\item[\bf SEE ALSO]
MUIA\_Window\_LeftEdge, MUIA\_Window\_AltTopEdge
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_AltTopEdge}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_AltTopEdge]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_AltTopEdge_Centered
MUIV_Window_AltTopEdge_Moused
MUIV_Window_AltTopEdge_Delta(p)
MUIV_Window_AltTopEdge_NoChange
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the alternate (zoomed) top position of
a window. This defaults to the standard top
position.

\item[\bf SEE ALSO]
MUIA\_Window\_TopEdge, MUIA\_Window\_AltLeftEdge
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_AltWidth}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_AltWidth]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_AltWidth_MinMax(p)
MUIV_Window_AltWidth_Visible(p)
MUIV_Window_AltWidth_Screen(p)
MUIV_Window_AltWidth_Scaled
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the alternate (zoomed) width of a window.
If not present, the alternate width will be the
minimum width.

\item[\bf SEE ALSO]
MUIA\_Window\_Width, MUIA\_Window\_AltHeight
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_AppWindow}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_AppWindow]  -- (V5 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Setting this attribute to TRUE will make this window an
AppWindow, the user will be able to drop icons on it.
You can hear about these events by listening to the
MUIA\_AppMessage attribute.

\item[\bf SEE ALSO]
MUIA\_AppMessage, MUIA\_Application\_DropObject
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Backdrop}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Backdrop]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Make the window a backdrop window.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Borderless}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Borderless]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Make the window borderless.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_CloseGadget}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_CloseGadget]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Set this to FALSE and your window will not
have a close gadget.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_CloseRequest}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_CloseRequest]  -- (V4 ) [..G], BOOL
\end{description}

\item[\bf FUNCTION]
When the user hits a windows close gadget, the
window isn't closed immediately. Instead MUI only
sets this attribute to TRUE to allow your application
to react.

Usually, you will setup a notification that automatically
closes the window when a close request appears, but you
could e.g. pop up a confirmation requester or do some
other things first.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
/* automagically close a window     */
/* when the close gadget is pressed */

DoMethod(window,MUIM_Notify,
   MUIA_Window_CloseRequest, TRUE,
   window,3,MUIM_Set,MUIA_Window_Open,0);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_Open
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_DefaultObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_DefaultObject]  -- (V4 ) [ISG], Object *
\end{description}

\item[\bf FUNCTION]
The default object in a window receives keyboard input
as long as no other object is active. Good candidates
for default objects are e.g. lonely listviews. Making
such a listview the default object will allow the user
to control it immediately without the need of several
tab strokes for activation.

\item[\bf SEE ALSO]
MUIA\_Window\_ActiveObject
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_DepthGadget}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_DepthGadget]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Enable or disable the depth gadget. Defaults to TRUE.
There is no good reason to use this tag.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_DragBar}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_DragBar]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Tell MUI to give your window a dragbar.

Defaults to TRUE.

There is no good reason to disable the dragbar!
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_FancyDrawing}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_FancyDrawing]  -- (V8 ) [ISG], BOOL
\end{description}

\item[\bf FUNCTION]
Usually, the only possible place to do some rendering is
during a MUIM\_Draw method. However, if you have a class
that really requires very high graphical output speed
(e.g. a module players scope or a game class), you can
set MUIA\_Window\_FancyDrawing to TRUE.

This allows your class to render anywhere between
MUIM\_Show and MUIM\_Hide, e.g. directly after an
attribute change with OM\_SET or from a seperate
task.

Note that your rastport etc. is only valid between
MUIM\_Show and MUIM\_Hide. Keep that in mind!

When drawing from a seperate task, you have to clone
the RastPort and use the copy for your rendering!

\item[\bf NOTES]
Please use this attribute sparingly. It might prevent
MUI from doing nice things with your window, e.g.
building an automatic virtual group when the screen
is too small.

MUIA\_Window\_FancyDrawing is really only necessary for
very few types of applications. You should use the
traditional way (MUIM\_Draw and MUI\_Redraw()) whenever
and wherever possible!
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Height}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Height]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_Height_MinMax(p)
MUIV_Window_Height_Visible(p)
MUIV_Window_Height_Screen(p)
MUIV_Window_Height_Scaled
MUIV_Window_Height_Default
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the height of a window. Usually, you won't give
a pixel value here but instead use one of the following
magic macros:

MUIV\_Window\_Height\_Default:
   calculated from objects default sizes.

MUIV\_Window\_Height\_MinMax(0..100):
   somewhere between the minimum height (0) and the
   maximum height (100) of your window.

MUIV\_Window\_Height\_Visible(1..100):
   percentage of the screens visible height.

MUIV\_Window\_Height\_Screen(1..100):
   percentage of the screens total height.

MUIV\_Window\_Height\_Scaled:
   height will be adjusted so that
   width : height == minimum width : minimum height.
   Note that a windows width and height may not
   both be scaled.

Default for this tag is MUIV\_Window\_Height\_Default.

As long as your window has a window id (MUIA\_Window\_ID),
choosing a size is not that important. MUI will always
remember a windows last position and size and these
values will simply override your settings. Positioning
and sizing should be completely under user control,
a programmer doesn't need to worry about it.

\item[\bf SEE ALSO]
MUIA\_Window\_Width, MUIA\_Window\_ID
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_ID}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_ID]  -- (V4 ) [ISG], ULONG
\end{description}

\item[\bf FUNCTIONS]
\begin{flushleft}
\begin{verbatim}
For most of your windows, you should define a longword
as id value. Only a window with an id is able to
remember its size and position.

Additionally, when you use an ascii id (e.g. 'MAIN'),
your window can be controlled from ARexx.

Of course all windows of your application must have
unique ids.
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_LeftEdge
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_InputEvent}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_InputEvent]  -- (V4 ) [..G], struct InputEvent *
\end{description}

\item[\bf FUNCTION]
This attribute gets set whenever your window receives
an input event. You can react on this by creating
a notification event containing a standard
commodities.library input description string.

Due to performance reasons, only IDCMP\_RAWKEY,
IDCMP\_DISKINSERTED and IDCMP\_DISKREMOVED events
are translated to a MUIA\_Window\_InputEvent
notification.

Prior to MUI 3.0, the input description string needed
to remain valid as long as the notification lasts. MUI 3.0
converts the string to a struct IX immediately, speeding
up the comparision and eliminating the need to keep
the description strings allocated.

\item[\bf NOTE]
Notification on MUIA\_Window\_InputEvent is inefficient.
You should only use this notification for a few keyboard events
that are "'general"' to the window, e.g. F-Keys for certain
program actions. Keyboard control for single user interface
elements should be implemented by using subclasses and
requesting rawkey input events from there.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
DoMethod(window, MUIM_Notify,
   MUIA_Window_InputEvent, "-repeat f1",
   txobj, 3,
   MUIM_Set, MUIA_Text_Contents, "f1 pressed/repeated");
\end{verbatim}
\end{flushleft}
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_LeftEdge}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_LeftEdge]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_LeftEdge_Centered
MUIV_Window_LeftEdge_Moused
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the left edge of a window. Usually, you shouldn't
define a pixel value here but instead use one of the
following macros:

MUIV\_Window\_LeftEdge\_Centered:
   window appears centered on the visible area of screen.

MUIV\_Window\_LeftEdge\_Moused
   window appears centered under the mouse pointer.

Default for this tag is MUIV\_Window\_LeftEdge\_Centered.

As long as your window has a window id (MUIA\_Window\_ID),
choosing a position is not that important. MUI will always
remember a windows last position and size and these
values will simply override your settings. Positioning
and sizing should be completely under user control,
a programmer doesn't need to worry about it.

\item[\bf SEE ALSO]
MUIA\_Window\_TopEdge, MUIA\_Window\_ID
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Menu}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Menu]  -- (V4 ) [I..], struct NewMenu * (OBSOLETE)
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_Menu_NoMenu
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Obsolete, use MUIA\_Window\_Menustrip instead.

\item[\bf SEE ALSO]
MUIA\_Window\_Menustrip
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_MenuAction}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_MenuAction]  -- (V8 ) [ISG], ULONG
\end{description}

\item[\bf FUNCTION]
Whenever a menu item is selected, this attribute will be
set to the corresponding UserData field of the gadtools
NewMenu structure. This allows reacting on menu items
via broadcasting.

\item[\bf SEE ALSO]
MUIA\_Window\_Menu
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Menustrip}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Menustrip]  -- (V8 ) [I.G], Object *
\end{description}

\item[\bf FUNCTION]
Specify a menu strip object for this window. The object
is treated as a child of the window and will be disposed
when the window is disposed.

Menustrip objects defined for a window will override an
applications Menustrip object.

MUIA\_Window\_Menustrip replaces the old and obsolete
MUIA\_Window\_Menu tag.

Usually, you will create the menu object with MUI's builtin
object library from a gadtools NewMenu structure, but its
also OK to define the menu tree "'by hand"' using the
Family class.

If you have a global menu for all your applications windows
but you want some windows to have no menu, use the
MUIA\_Window\_NoMenus tag.

\item[\bf SEE ALSO]
MUIA\_Window\_NoMenus
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_MouseObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_MouseObject]  -- (V10) [..G], Object *
\end{description}

\item[\bf FUNCTION]
When MUIA\_Window\_NeedsMouseObject is enabled for this window,
you can setup notificationns on MUIA\_Window\_MouseObject to
find out on which object the mouse pointer is located.

\item[\bf SEE ALSO]
MUIA\_Window\_NeedsMouseObject
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_NeedsMouseObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_NeedsMouseObject]  -- (V10) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
If you want to react on changes of the MUIA\_Window\_MouseObject
attribute, you have to set this to TRUE when creating your
window.

\item[\bf SEE ALSO]
MUIA\_Window\_MouseObject
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_NoMenus}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_NoMenus]  -- (V4 ) [IS.], BOOL
\end{description}

\item[\bf FUNCTION]
Temporarily disable the menu strip of a window.

\item[\bf SEE ALSO]
MUIA\_Window\_Menu
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Open}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Open]  -- (V4 ) [.SG], BOOL
\end{description}

\item[\bf FUNCTION]
This little attribute can be used to open and close
a window. When opening a window, MUI does lots of
stuff to calculate sizes and positions of all
gadgets. Minimum and maximum window sizes will be
adjusted automatically.

When the minimum size of a window is too big to fit
on the screen, MUI tries to reduce font sizes and
does a new calculation. You should always design
your windows to fit on a 640*200 screen with
all fonts set to topaz/8.

When a window is closed (and you specified a
MUIA\_Window\_ID), MUI remembers its position
and size and uses these values during the next
opening.

After setting MUIA\_Window\_Open to TRUE, you should
test if MUI was able to open the window by getting
the attribute again. If you don't and if this was
the only window of your application, the user won't
be able to do any input and your application will
seem to hang.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
set(window,MUIA_Window_Open,TRUE);
get(window,MUIA_Window_Open,&open);
if (!open)
{
   MUI_Request(app,0,0,0,"Ok","Failed to open window.");
   exit(20);
}
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_RootObject
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_PublicScreen}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_PublicScreen]  -- (V6 ) [ISG], STRPTR
\end{description}

\item[\bf FUNCTION]
Force the window to appear on the public screen who's name
is specified by this attribute. This tag overrides the
user preferences setting and is overridden by
MUIA\_Window\_Screen.

Please use this tag sparely, overriding user prefs is
not a good idea!

\item[\bf SEE ALSO]
MUIA\_Window\_Screen
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_RefWindow}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_RefWindow]  -- (V4 ) [IS.], Object *
\end{description}

\item[\bf FUNCTION]
Setting MUIA\_Window\_RefWindow to another MUI window
object will make the left and top position relative
to this reference window. Using the
MUIA\_Window\_Left(Top)Edge\_Centered tag, you can easily
open one window within another.

Note that if your window has an id, the window will
remember its last position and reopen there. Thus,
this tag is only useful if you omit MUIA\_Window\_ID,
maybe for some small requester windows.

\item[\bf SEE ALSO]
MUIA\_Window\_ID, MUIA\_Window\_LeftEdge
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_RootObject}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_RootObject]  -- (V4 ) [ISG], Object *
\end{description}

\item[\bf FUNCTION]
This is a pointer to a MUI object and defines the
contents of your window. Usually, this root object
will be of class MUIC\_Group since you surely want to
have more than one gadget.

The root object is treated as child of a window
and will be disposed when the window is disposed.
Note that windows can only have one child.

\item[\bf NOTES]
Although you may create a window without root object,
you have to set one before the window is openend!

You can *only* use MUIA\_Window\_RootObject in a SetAttrs()
call if your window is not open yet!

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
win = WindowObject, MUIA_Window_RootObject,
   VGroup,
      Child, ...,
      Child, ...,
      End,
   End;
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_Open
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Screen}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Screen]  -- (V4 ) [ISG], struct Screen *
\end{description}

\item[\bf FUNCTION]
You can get a pointer to the parent screen of a window by
getting this attribute. The result will be NULL when the
window is currently closed.

Specifying MUIA\_Window\_Screen at object creation time or
with a SetAttrs() call allows you to explicitly tell MUI
on which screen the window should be opened. You normally
won't need this feature and leave the decision about
screens to the users preferences setting.

\item[\bf SEE ALSO]
MUIA\_Window\_PublicScreen, MUIA\_Window\_Window
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_ScreenTitle}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_ScreenTitle]  -- (V5 ) [ISG], STRPTR
\end{description}

\item[\bf FUNCTION]
This text will appear in the screens title bar
when the window is active.

\item[\bf SEE ALSO]
MUIA\_Window\_Title
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_SizeGadget}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_SizeGadget]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
Tell MUI if you want a sizing gadget for this window.
Usually you won't need this attribute since MUI
will automatically disable the sizing gadget when
your window is not sizeable because of your gadget
layout.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_SizeRight}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_SizeRight]  -- (V4 ) [I..], BOOL
\end{description}

\item[\bf FUNCTION]
When set to TRUE, the size gadget will reside
in the right window border.
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Sleep}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Sleep]  -- (V4 ) [.SG], BOOL
\end{description}

\item[\bf FUNCTION]
This attribute can be used to put a window to sleep.
The window gets disabled and a busy pointer appears.

The attribute contains a nesting count, if you tell
your window to sleep twice, you will have to tell
it to wake up twice too.

A sleeping window cannot be resized.

\item[\bf SEE ALSO]
MUIA\_Application\_Sleep
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Title}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Title]  -- (V4 ) [ISG], STRPTR
\end{description}

\item[\bf FUNCTION]
Specify the title of a window.

\item[\bf SEE ALSO]
MUIA\_Window\_ScreenTitle
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_TopEdge}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_TopEdge]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_TopEdge_Centered
MUIV_Window_TopEdge_Moused
MUIV_Window_TopEdge_Delta(p)
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the top edge of a window. Usually, you shouldn't
define a pixel value here but instead use one of the
following macros:

MUIV\_Window\_TopEdge\_Centered:
   window appears centered on the visible area of screen.

MUIV\_Window\_TopEdge\_Moused
   window appears centered under the mouse pointer.

MUIV\_Window\_TopEdge\_Delta(p)
   window appears p pixels below the screens title bar.

Default for this tag is MUIV\_Window\_TopEdge\_Centered.

As long as your window has a window id (MUIA\_Window\_ID),
choosing a position is not that important. MUI will always
remember a windows last position and size and these
values will simply override your settings. Positioning
and sizing should be completely under user control,
a programmer doesn't need to worry about it.

\item[\bf SEE ALSO]
MUIA\_Window\_LeftEdge, MUIA\_Window\_ID
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Width}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Width]  -- (V4 ) [I.G], LONG
\end{description}

\item[\bf SPECIAL INPUTS]
\begin{flushleft}
\begin{verbatim}
MUIV_Window_Width_MinMax(p)
MUIV_Window_Width_Visible(p)
MUIV_Window_Width_Screen(p)
MUIV_Window_Width_Scaled
MUIV_Window_Width_Default
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Specify the width of a window. Usually, you won't give
a pixel value here but instead use one of the following
magic macros:

MUIV\_Window\_Width\_Default:
   calculated from objects default sizes.

MUIV\_Window\_Width\_MinMax(0..100):
   somewhere between the minimum width (0) and the
   maximum width (100) of your window.

MUIV\_Window\_Width\_Visible(1..100):
   percentage of the screens visible width.

MUIV\_Window\_Width\_Screen(1..100):
   percentage of the screens total width.

MUIV\_Window\_Width\_Scaled:
   width will be adjusted so that
   width : height == minimum width : minimum height.
   Note that a windows width and height may not
   both be scaled.

Default for this tag is MUIV\_Window\_Width\_Default.

As long as your window has a window id (MUIA\_Window\_ID),
choosing a size is not that important. MUI will always
remember a windows last position and size and these
values will simply override your settings. Positioning
and sizing should be completely under user control,
a programmer doesn't need to worry about it.

\item[\bf SEE ALSO]
MUIA\_Window\_Height, MUIA\_Window\_ID
\end{deflist}


\subsection{Window.mui/MUIA\_Window\_Window}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
\begin{description}
\item[MUIA\_Window\_Window]  -- (V4 ) [..G], struct Window *
\end{description}

\item[\bf FUNCTION]
When your window is open, you can obtain a pointer
to the intuition Window structure with this tag
and use it e.g. in an asl.library requester call.

Since the user can close your window any time
(e.g. iconification), you must be prepared to
receive a NULL pointer as result.

\item[\bf SEE ALSO]
MUIA\_Window\_Screen
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_GetMenuCheck}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_GetMenuCheck (V4 ) (OBSOLETE)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_GetMenuCheck,ULONG MenuID);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Ask whether a checkmark menu item has its
checkmark set or cleared.

\item[\bf INPUTS]
\begin{description}
\item[MenuID]  - the value you wrote into the
          UserData field of struct NewMenu.
\end{description}

\item[\bf SEE ALSO]
MUIM\_Window\_SetMenuCheck, MUIA\_Window\_Menu
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_GetMenuState}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_GetMenuState (V4 ) (OBSOLETE)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_GetMenuState,ULONG MenuID);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Ask whether a menu item is enabled or disabled.

\item[\bf INPUTS]
\begin{description}
\item[MenuID]  - the value you wrote into the
          UserData field of struct NewMenu.
\end{description}

\item[\bf SEE ALSO]
MUIM\_Window\_SetMenuState, MUIA\_Window\_Menu
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_ScreenToBack}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_ScreenToBack (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_ScreenToBack,);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Put the window's screen to back. This command is
only valid when the window is opened.

\item[\bf SEE ALSO]
MUIM\_Window\_ScreenToFront, MUIM\_Window\_ToFront,
MUIM\_Window\_ToBack
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_ScreenToFront}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_ScreenToFront (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_ScreenToFront,);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Put the window's screen to font. This command is
only valid when the window is opened.

\item[\bf SEE ALSO]
MUIM\_Window\_ScreenToBack, MUIM\_Window\_ToFront,
MUIM\_Window\_ToBack
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_SetCycleChain}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_SetCycleChain (V4 ) (OBSOLETE)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_SetCycleChain,Object *obj[1]);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set the cycle chain for a window. To make MUI's keyboard
control work, you need to setup a chain of objects that
should be activatable with the tab key. This can be
any objects you wish, MUI supports complete keyboard
handling even for sliders or listviews.

If you forget to set a cycle chain because you
are a mouse-man, you certainly will annoy some
users of your application!

\item[\bf INPUTS]
One or more objects, terminated with a NULL.

\item[\bf EXAMPLE]
\begin{flushleft}
\begin{verbatim}
DoMethod(window,MUIM_Window_SetCycleChain,
   str1,str2,slide1,list,radio,cycle1,cycle2,NULL);
\end{verbatim}
\end{flushleft}
\item[\bf SEE ALSO]
MUIA\_Window\_ActiveObject, Area.mui/MUIA\_CycleChain
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_SetMenuCheck}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_SetMenuCheck (V4 ) (OBSOLETE)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_SetMenuCheck,ULONG MenuID, LONG stat);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Set or clear the checkmark of a menu item.

\item[\bf INPUTS]
\begin{description}
\item[MenuID]  - the value you wrote into the
          UserData field of struct NewMenu.
\end{description}

set    - TRUE to set checkmark, FALSE to clear

\item[\bf SEE ALSO]
MUIM\_Window\_GetMenuCheck, MUIA\_Window\_Menu,
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_SetMenuState}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_SetMenuState (V4 ) (OBSOLETE)

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_SetMenuState,ULONG MenuID, LONG stat);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Enable or disable a menu item.

\item[\bf INPUTS]
\begin{description}
\item[MenuID]  - the value you wrote into the
          UserData field of struct NewMenu.
\end{description}

set    - TRUE to enable item, FALSE to disable.

\item[\bf SEE ALSO]
MUIM\_Window\_GetMenuState, MUIA\_Window\_Menu,
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_ToBack}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_ToBack (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_ToBack,);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Put the window to back. When the window is not currently open,
this command does simply nothing.

\item[\bf SEE ALSO]
MUIM\_Window\_ToFront, MUIM\_Window\_ScreenToFront,
MUIM\_Window\_ScreenToBack
\end{deflist}


\subsection{Window.mui/MUIM\_Window\_ToFront}
\rule{\textwidth}{1mm}
\vspace{0.5cm}
\begin{deflist}{MMMMMMMM}
\item[\bf NAME]
MUIM\_Window\_ToFront (V4 )

\item[\bf SYNOPSIS]
\begin{flushleft}
\begin{verbatim}
DoMethod(obj,MUIM_Window_ToFront,);
\end{verbatim}
\end{flushleft}
\item[\bf FUNCTION]
Put the window to front. When the window is not currently open,
this command does simply nothing.

\item[\bf SEE ALSO]
MUIM\_Window\_ToBack, MUIM\_Window\_ScreenToFront,
MUIM\_Window\_ScreenToBack
\end{deflist}


%---------------- End of File ----------
