@DATABASE Emperor.guide
@$VER:Emperor.guide 4.5 (7.10.2002)
@(C) Copyright 2000-2002 by Matthias Gietzelt
@AUTHOR Matthias Gietzelt

@MACRO SHINE "@{b}@{FG Shine}"
@MACRO ENDSHINE "@{FG Text}@{ub}"

@NODE  MAIN "Die Dokumentation zu Emperor"



        _______   __   __          ___        _______   ___      ___          ___   
       /******/  /**| /**|        /***\\      /******/  /***\\    /***\\        /***\\  
      /**____/  /***|/***|       /*__**\\    /**____/  /*__**\\  /*___*\\      /*__**\\ 
     /**/___   /*/ |**/|*|      /*/__/*|   /**/___   /*/__/*| |*/   \\*|    /*/__/*| 
    /******/  /*/  |_/ |*|     /*******/  /******/  /*******/ |*|   |*|   /*******/ 
   /**____/  /*/       |*|    /*______/  /**____/  /*__**__/  |*|   |*|  /*__**__/  
  /**/___   /*/        |*|   /*/        /**/___   /*/  \\*\\    \\*\\___/*/ /*/  \\*\\    
 /******/  /*/         |*|  /*/        /******/  /*/    \\*\\    \\*****/ /*/    \\*\\   
/______/  /_/          |_| /_/        /______/  /_/      \\_\\    \\___/ /_/      \\_\\  


                         The object-oriented programming language

                      Available at www.aminet.de ! (Drawer: dev/c)




@{SHINE} Emperor - eine Objekt-orientierte Programmiersprache @{ENDSHINE}

      @{"Einführung           " link Intro}          Was macht Emperor ?

      @{"Registration         " link Registration}          Wie bekomme ich die Vollversion ?

      @{"Systemanforderung    " link System}          Was braucht Emperor ?

      @{"Installation         " link Install}          Wie muss ich Emperor installieren ?

      @{"Programmstart        " link Start}          Wie bekomme ich Emperor zum Laufen ?

      @{"Bedienung            " link Bedien}          Wie bediene ich Emperor ?

      @{"definierte Variablen " link Vars}          Welche Variablen kann ich nutzen ?

      @{"Makrofunktionen      " link Funcs}          Wie erleichtert Emperor meine Arbeit ?

      @{"Geschichte           " link History}          Welche Geschichte hat das Programm ?

      @{"FAQ                  " link Faq}          Welche Fragen kommen häufig ?

      @{"Bekannte Fehler      " link Bugs}          Welche Fehler gibt's ?

      @{"Danksagungen         " link Thanx}          Wem möchte der Programmierer danken ?

      @{"Autor                " link Autor}          Wer hat's verbrochen ?
@{PAR}
@ENDNODE
@NODE Intro "Die Einführung"


@{SHINE} Bitte unterstützen Sie die Weiterentwicklung dieser Software und mailen Sie @{"mir" link Autor} @{ENDSHINE}
@{SHINE} Ihre Meinung, Probleme und Kritik, denn die Programmierung hat mich viiieeelll @{ENDSHINE}
@{SHINE} Zeit gekostet (aber ich hab's gern getan !). @{ENDSHINE}


Vielen Dank, dass Sie dieses Programm entpackt haben und ausprobieren möchten !
Dieses Programm soll die Software-Entwicklung auf dem Amiga "revolutionieren".


Tjaaa, nun ist's vollbracht, das Meisterwerk !

Objekt-orientierte Programmiersprache (OOP) ist vielleicht ein wenig
zu hoch gegriffen, da weiterhin "echte" C/C++-Quelltexte generiert und
durch einen externen C/C++-Compiler übersetzt werden müssen. Im Amiga-Bereich
gibt's nur wenige Ausnahmen wie CanDo, Storm-Wizard u.a., aber irgendwann habe
ich das Programm "Delphi" auf dem PC :( kennengelernt ! Diese OOP ist
ausschließlich in Pascal gehalten (was mich arg störte) und erschlägt einen
mit den Millionen Konfigurations-möglichkeiten. Ich kannte soetwas in der Art
bisher auf dem Amiga nicht, und kurzentschlossen setzte ich mich selbst daran.

Ich wollte die Parametrierung der Oberfläche und der Makro-Elemente so einfach wie
möglich machen. Folgende Standard-Oberflächenelemente sind implementiert:
 * Screens
 * Fenster
 * OS2.0 Gadgets (GadTools)
 * OS3.5 Gadgets (Reaction)
 * Menüs
 * PopupMenüs
 * Requester
 * ASL-Requester
 * Locale-Katalog

Folgende Nicht-Oberflächenelemente sind implementiert:
 * vorgefertigte Funktionsmakros, die das Programmieren unter OS3.5 wesentlich erleichtern.
 * Install-Skripts
 * ToolTypes
 * Includes
 * deklarieren von Variablen
 * definierbare Einbindung von Funktions-Bibliotheken
 * InterConnection Maps zwischen Gadgets
 * Datenfelder für Listen von Gadgets

Man generiert mit Emperor einen komplett fertigen C/C++-Quelltext, der nur noch
durch einen externen Compiler (z.B. StormC auf der Developer CD2.1) übersetzt werden
muss. Dabei gibt es verschiedene Dateien, in denen folgendes gespeichert wird:

PROJEKTNAME.c           Programmquelltext ansich (mit Verwaltung etc.)
PROJEKTNAME.cd          Katalog-Roh-Daten (meist in Englisch)
PROJEKTNAME.h           Eigener geschriebener Code
PROJEKTNAME.install     generiertes Install-Skript
PROJEKTNAME.project     Projektdatei für Emperor ansich
PROJEKTNAME.¶           Storm-Projektdatei
PROJEKTNAME_SPRACHE.ct  übersetzter Katalog in Form von Rohdaten


Ziel dieses Programms soll sein, Softwareentwickler zu überzeugen mit Emperor ihre
Programme (deren Quelltext) zu erstellen, da die Verfahrensweise bei der Erstellung
von Software (Öffnen von Fenstern, Datei- und Schriftauswahlrequestern, Menüs etc.)
oft gleich ist und nicht weiter durch den Programmierer selbst mühsam aus anderen
Quelltexten herausgefischt werden muss. Emperor verfügt für jedes Element schon
ein oder mehrere vorgefertigte, aber veränderbare, Makros. So z.B. bei den Menüs:
hier muss für das Projekt-Menü (Öffnen, Speichern, Drucken etc.) und dessen
Übersetzung (für Locale - ".catalog"-Datei) nur der entsprechende Eintrag
gewählt werden. Dies gilt auch für Requester z.B. für das QuitRequest. Diese müssen
nur noch im eigenen Quelltext als Funktion "REQUESTERNAME();" aufgerufen werden.

Das Programm soll aber auch für Amiganer sein, die noch nie programmiert haben,
und so einen einfachen Einstieg in die Programmierung der AmigaOS-Oberfläche bieten.

@ENDNODE
@NODE Registration "Das Registrieren"


Emperor Version 4.5 ist Copyright © 2000-2002 by Matthias Gietzelt
Emperor Version 4.5 ist Shareware
Alle Rechte vorbehalten.

@{SHINE}
Der @{"Autor" link Autor} übernimmt keinerlei Verantwortung für den Gebrauch des
Programmes und eventuell auftretenden Schäden, die damit in Verbindung stehen können.

Für die Vollversion "Emperor 4.5" muss eine Shareware-Gebühr von 15,-Euro an den
@{"Autor" link Autor} entrichtet werden. Möchten Sie Emperor auf einer CD oder Diskette,
dann lesen Sie bitte den Abschnitt "Wie komme ich an die Vollversion ?"
@{ENDSHINE}

Registrierte User bekommen kleine Updates, Fehlerbeseitigungen etc. kostenlos und für
große Neuerungen Sonderkonditionen !


@{b}Was ist Shareware ?@{ub}

Shareware ist kommerzielle Software, d.h. Programme, für deren Gebrauch i.A. eine
Gebühr fällig wird, die Sie dem Autor schicken können. Häufig sind in Demo-Versionen
von Shareware-Programmen Programmteile deaktiviert, oder sie haben eine begrenzte
Laufzeit, Nervrequester u.a.
Emperor kann in der Demoversion keine Quelltexte generieren.

Ich habe sehr viel Energie und Arbeit in die Entwicklung des Projektes gesteckt,
doch muss auch ich an meine eigene Ökonomie denken, die Spenden finanzieller Art
gut gebrauchen kann.


@{b}Wie komme ich an die Vollversion ?@{ub}

Gegen den Erhalt der Gebühr, in Zusammenhang mit Ihrer Adresse (oder Email) und einer
Angabe, ob Sie Emperor per Post erhalten möchten, bekommen Sie die uneingeschränkt
nutzbare Version.

@{SHINE}
Sharewaregebühr:                                        15,00 Euro (oder den gleichen Betrag in anderen Währungen)

Zahlungsart:
Barzahlung                                            (+ -,-- Euro)
Scheck                                                (+ 3,00 Euro)

falls Sie Emperor per Post haben möchten:
Material + Verpackung                                 (+ 3,00 Euro)
Postgebühr                                            (+ 1,53 Euro) (innerhalb Deutschlands)
Postgebühr                                            (+ 4,09 Euro) (außerhalb Deutschlands)
(als Postgebühren werden auch Briefmarken akzeptiert)
                                                       -----------

Summe (EMail-Empfänger, bar)                            15,00 Euro

Summe (EMail-Empfänger, Scheck)                         18,00 Euro

Summe (Post-Empfänger in Deutschland, bar)              19,53 Euro

Summe (Post-Empfänger in Deutschland, Scheck)           22,53 Euro

Summe (Post-Empfänger ausserhalb Deutschlands, bar)     22,09 Euro

Summe (Post-Empfänger ausserhalb Deutschlands, Scheck)  25,09 Euro
@{ENDSHINE}

Geben Sie bitte an, ob Sie Emperor via EMail, auf CD oder auf Diskette haben möchten.
Die Ihnen gesandte EMail umfasst 350 kByte und beinhaltet lediglich die LhA-gepackte
Vollversion des Programms.


Das Emperor-Programmpaket in Aminet oder auf Heft-CDs muss folgende Dinge enthalten:

  - das Programm                "Emperor"
  - das Startbild               "Emperor.pic"
  - die Prefs-Datei             "Emperor.prefs"
  - das Install-Skript          "Emperor.install"
  - diese Anleitung             "Emperor.guide" (englisch und deutsch)
  - das template-Projekt        "template.project"
  - den deutschen Katalog       "Catalogs/deutsch/Emperor.catalog"
  - den französischen Katalog   "Catalogs/français/Emperor.catalog"
  - die rohe Katalog-Datei      "Catalogs/Emperor.cd"
  - das Projekt-Verzeichnis     "Projects/" mit bereits vorgefertigten Beispiel-Projekten
  - das Scripts-Verzeichnis     "Scripts/" für die interaktive StormC-Anbindung per ARexx

Sollten Sie eine dieser Dateien nicht im Archiv vorfinden, kontaktieren
Sie @{"mich" link Autor} bitte umgehend !

@ENDNODE
@NODE System "Die Systemanforderungen"


  - einen Amiga ;-)
  - Speicher mindestens 4 MByte; empfohlen 16 MByte oder mehr
  - Workbench Version 3.5 oder höher
  - Prozessor mindestens 68020; empfohlen 68040
@{SHINE}  - Amiga Developer CD 2.1 von der HAAGE & Partner GmbH @{ENDSHINE}
  - C/C++-Compiler (von der Developer CD "ADCD_2.1:Contributions/Haage_&_Partner/StormC/")
  - CatComp (von der Developer CD "ADCD_2.1:NDK/NDK_3.5/Tools/CatComp")
  - xen.font in der Größe 8 im "Fonts:"-Verzeichnis des Bootlaufwerks, :-)
    da einige Listen so viele Informationen enthalten, dass ein normaler Screenfont
    viiieeelll zu groß wäre, um alles auf den Bildschirm zu bringen (z.B. Programmierhilfe).


  Ausreichend getestet mit folgenden Konfigurationen:

@{b}  - A 1200@{ub}
           * 68060/50MHz (BlizzardPPC-Karte)
           * 603e+/240MHz
           * 100 MB Speicher
           * BlizzardVisionPPC - Grafikkarte
           * AmigaOS 3.9 mit BoingBag1

@{b}  - A 4000@{ub}
           * 68040/25MHz
           * 64 MB Speicher
           * CyberVision 64/3D - Grafikkarte
           * FastLane Z3
           * AmigaOS 3.5

@{b}  - A 2000@{ub}
           * 68040/30MHz
           * 18 MB Speicher
           * GVP Series-II SCSI Filecard
           * AmigaOS 3.5

@{b}  - A 2000@{ub}
           * 68040/40MHz
           * 1 MB Speicher Chip
           * 58 MB Speicher Fast
           * Delfina Lite Soundkarte
           * CyberVision 64/3D Grafikkarte
           * 10 GByte Festplatte

@{b}  - A 1200@{ub}
           * 68060/50MHz (Blizzard 1260)
           * 1230 SCSI-Kit
           * int. IDE  HD 60MB
           * ext. SCSI HD 3.3GB
           * ext. SCSI CD-Player
           * ext. SCSI ZIP-Laufwerk (250 MB)
           * AmigaOS 3.9 mit BoingBag1
           * AGA-Screen (800x600 Pixel)

@{b}  - PC mit AmigaOS-XL auf QNX@{ub}
           * Pentium 4/1600MHz
           * 512 MB Rambus RAM/400MHz
           * ASUS P4T-E Motherboard
           * 40 GByte Maxtor Festplatte
           * LG DVD 12x-Laufwerk
           * HP 9200+ CD-Brenner
           * CreativeLabs SoundBlaster
           * TekRam DC-390 SCSI-Host-Adapter
           * GeForce 2 MX 400
           * ELSA 56k pro internes Modem

@ENDNODE
@NODE Install "Die Installation"


Hierzu sollte beiliegender Install-Skript verwendet werden.


Möchten Sie die Installation per Hand ausführen, dann führen Sie folgende Schritte durch:

* Verzeichnis "Emperor" erstellen
* Programmdatei "Emperor" in das erstellte Verzeichnis kopieren
* Startupbild "Emperor.pic" in das erstellte Verzeichnis kopieren
* Prefsdatei "Emperor.prefs" in das erstellte Verzeichnis kopieren
* Guidedatei "Emperor_deutsch.guide" in das erstellte Verzeichnis kopieren
* "Emperor_deutsch.guide" in "Emperor.guide" umbenennen
* Template-Projekt "template.project" in das erstellte Verzeichnis kopieren
* Scripts-Verzeichnis in das erstellte Verzeichnis kopieren
* Project-Verzeichnis in das erstellte Verzeichnis kopieren
* optional den deutschen Katalog nach "SYS:Locale/Catalogs/deutsch" kopieren

Danach steht Ihnen das Programm uneingeschränkt zur Verfügung.

@ENDNODE
@NODE Start "Der Programmstart"


Der Programmstart kann per CLI (Shell) ohne weitere Argumente erfolgen.

Aber der altbewährte Doppelklick auf's Piktogramm (Icon) des Programms tut's auch.


    Außerdem müssen diverse Dinge gewährleistet sein:

       * AmigaOS 3.5 installiert ?
       * vom Systemspeicher müssen mehr als 4 MBytes frei sein
       * Assign auf <PFAD>:Emperor
       * RexxMast gestartet ?
       * Stack auf mehr als 50000 Bytes eingestellt ?
         - unter CLI:   'stack 50000' eintippen
         - unter WB:    in den Piktogramminformationen einen Stack von >50000 Bytes einstellen
         - unter DOpus: in Menü 'Einstellungen-Umgebung' den Punkt CLI-Start anwählen und
                        Stack ändern !

@ENDNODE
@NODE Bedien "Die Bedienung"


@{b} Wie das Menü bedient wird... @{ub}

      @{"Menü" link Menu}


@{b} Wie die einzelnen Fenster Emperors bedient werden... @{ub}

      @{"Hauptfenster" link Mainwin}
            @{"Screen-Seite         " link Mainwinscreens}
            @{"Window-Seite         " link Mainwinwindows}
            @{"Reaction-Seite       " link Mainwingadgets}
            @{"GadTools-Seite       " link Mainwingadtools}
            @{"ICMap-Seite          " link Mainwinicmap}
            @{"Menu-Seite           " link Mainwinmenu}
            @{"Popup-Seite          " link Mainwinpopup}
            @{"Request-Seite        " link Mainwinreq}
            @{"ASL-Seite            " link Mainwinasl}
            @{"Locale-Seite         " link Mainwinlocale}
            @{"Variable-Seite       " link Mainwinglobvar}
            @{"Array-Seite          " link Mainwinarray}
            @{"Tooltype-Seite       " link Mainwintooltype}
            @{"Include-Seite        " link Mainwininclude}
            @{"Library-Seite        " link Mainwinlibrary}
            @{"Install-Seite        " link Mainwininstall}

@{b}      sonstige Fenster@{ub}
            @{"Einstellungen        " link Preferenceswin}
            @{"Programmumgebung     " link PrefsProgwin}

            @{"Texteditor           " link Texteditorwin}
            @{"Programmierhilfe     " link ProgHelpwin}
            @{"Nachrichtenbehandlung" link InputHandlewin}

@ENDNODE
@NODE Menu "Das Menü"


An dieser Stelle sollen die Menüeinträge aufgelistet und deren Funktion nur kurz
beschrieben werden.

@{b}Projekt@{ub}                        (Menütitel)
@{b}Neu@{ub}                            - Entfernt das aktuelle Projekt aus dem Speicher
                                 und somit alle erstellten Listen
                                 (lädt zusätzlich noch das "template.project")
@{b}Löschen@{ub}                        - Ein ganzes gespeichertes Projekt kann nach
                                 Auswahl gelöscht werden
@{b}Öffnen@{ub}                         - Öffnet ein bereits erstelltes Projekt ("*.project"-Datei)
@{b}Anhängen@{ub}                       - Fügt ein Projekt dem Aktuellen hinzu

@{b}Speichern@{ub}                      (Untermenü)
@{b}Projekt speichern@{ub}              - Speichert das aktuelle Projekt ("*.project"-Datei)
@{b}Storm-Projekt speichern@{ub}        - Generiert ein Storm-Projekt ("*.¶"-Datei)
@{b}Katalog-Roh-Dateien speichern@{ub}  - Generiert die Katalog-Roh Dateien ("*.cd" und "*_SPRACHE.ct"-Datei)
@{b}Katalog generieren@{ub}             - Generiert die Katalog Datei ("*.catalog"-Datei)
                                 ACHTUNG ! Funktioniert nur, wenn das Programm
                                 "CatComp" installiert ist.
@{b}Eigenen Quelltext speichern@{ub}    - Speichert den eigenen Quelltext ("*.h"-Datei)
@{b}Programmquelltext generieren@{ub}   - Generiert den kompilierbaren C/C++-Quelltext ("*.c"-Datei)
@{b}Speichern als@{ub}                  - Speichert das aktuelle Projekt unter neuem Namen ("*.project"-Datei)
@{b}Speichern als Vorgabe@{ub}          - Speichert das aktuelle Projekt als Vorgabeprojekt ("*.project"-Datei)
@{b}Clipboard speichern@{ub}            - Speichert den Clipboardinhalt (also ausgeschnittene Programmteile oder Listen)
@{b}Alles speichern@{ub}                - Speichert folgende Dateien:
                                 ("*.c"-Datei)                 generierter Programm-Code
                                 ("*.h"-Datei)                 Eigener Quelltext
                                 ("*.catalog"-Datei)           Locale-Katalog
                                 ("*.install"-file)            Install-Skript
                                 ("*.projekt"-Datei)           Emperor-Projekt
                                 ("*.¶"-Datei)                 Storm-Projekt
                                 ("*_SPRACHE.ct"-Datei)        Katalog-Übersetztungsdatei

@{b}Ausdrucken@{ub}                     (Untermenü)
@{b}Objekttabelle ausdrucken@{ub}       - Druckt die aktuelle Objekttabelle
@{b}Katalog-Roh-Dateien ausdrucken@{ub} - Druckt die Katalog-Roh Dateien ("*.cd" und "*_SPRACHE.ct"-Datei)
@{b}Eigenen Quelltext ausdrucken@{ub}   - Druckt den eigenen Quelltext ("*.h"-Datei)
@{b}Programmquelltext ausdrucken@{ub}   - Druckt den kompilierbaren C/C++-Quelltext ("*.c"-Datei)
@{b}Alles ausdrucken@{ub}               - Druckt folgende Dateien aus:
                                 ("*.c"-Datei)                 generierter Programm-Code
                                 ("*.h"-Datei)                 Eigener Quelltext
                                 ("*.install"-file)            Install-Skript
                                 sowie die Objekttabelle
@{b}Einstellungen@{ub}                  - Öffnet ein Fenster für diverse Programmeinstellungen
@{b}Programmeinstellungen@{ub}          - Öffnet ein Fenster für diverse programmspezifische Einstellungen
@{b}Verwaltung@{ub}                     - Wechselt auf Seite "Window"
@{b}Information@{ub}                    - Gibt eine Information über das Programm aus
@{b}Beenden@{ub}                        - Beendet das Programm


@{b}Bearbeiten@{ub}                     (Menütitel)
@{b}Markieren@{ub}                      - Setzt die Markierungsmarke des Texteditors an die Position des Cursors
@{b}Ausschneiden@{ub}                   - Schneidet den aktuellen Listeneintrag aus und speichert ihn im Clipboard
                                 (für Texteditor: schneidet markierten Text aus)
@{b}Kopieren@{ub}                       - Speichert das aktuelle Objekt ins Clipboard
                                 (für Texteditor: kopiert den markierten Text)
@{b}Einfügen@{ub}                       - Fügt den Inhalt des Clipboards in eine Liste ein
                                 (für Texteditor: fügt kopierten Text ab Position des Cursors ein)
@{b}Eingriff zurück@{ub}                - Letzter Eingiff im Texteditor wird zurückgenommen
@{b}Eingriff erneut@{ub}                - Eingriff im Texteditor wird erneut durchgeführt
@{b}Löschen@{ub}                        - Löscht den aktuellen Listeneintrag
                                 (für Texteditor: löscht den markierten Text)
@{b}Alles löschen@{ub}                  - Löscht die komplette Liste
                                 (für Texteditor: löscht den kompletten Text)
@{b}Aufwärts verschieben@{ub}           - Verschiebt den aktuellen Listeneintrag
@{b}Abwärts verschieben@{ub}            - Verschiebt den aktuellen Listeneintrag
@{b}Am Listenanfang hinzufügen@{ub}     - Fügt aktuelles Objekt der Liste hinzu
@{b}Am Listenende hinzufügen@{ub}       - Fügt aktuelles Objekt der Liste hinzu
@{b}Funktion hinzufügen@{ub}            - Fügt die entsprechend des aktuellen Objekts
                                 passende Funktion dem eigenen Quelltext hinzu
@{b}Überprüfe Einträge@{ub}             - Überprüft die Einträge des gesamten Projekts (deaktiviert)
@{b}Vorschau@{ub}                       - Zeigt eine Vorschau zum aktuellen Objekt an
@{b}Groß/Klein@{ub}                     - Ändert Buchstabe/Wort/Zeile zu Groß<->Klein
@{b}Klein@{ub}                          - Ändert Buchstabe/Wort/Zeile zu Klein->Groß
@{b}Groß@{ub}                           - Ändert Buchstabe/Wort/Zeile zu Groß->Klein
@{b}Zeile einrücken@{ub}                - die Zeile wird anhand der '{' und '}'-Marken im Text eingerückt
@{b}Text einrücken@{ub}                 - der Text wird anhand der '{' und '}'-Marken im Text eingerückt
@{b}Ausrichtung@{ub}                    - Markierter Text wird links/mittig/rechts ausgerichtet
@{b}Einfügemodus@{ub}                   - Eingabemodus des Texteditors


@{b}Fenster@{ub}                        (Menütitel)
@{b}Vorschaufenster@{ub}                - Öffnet ein Fenster, das (etwa) dem kompilierten Projekt entspricht
@{b}Attributfenster@{ub}                - Öffnet das Fenster, in dem objektabhängige Parametrierungen vorgenommen werden können
@{b}Texteditor@{ub}                     - Öffnet den internen @{"Texteditor" link Texteditorwin}
@{b}Programmierhilfe@{ub}               - Öffnet das @{"Programmierhilfe-Fenster" link ProgHelpwin}
@{b}Nachrichtenhandhabung@{ub}          - Öffnet das @{"Nachrichtenbehandlungs-Fenster" link InputHandlewin}


@{b}Programm@{ub}                       (Menütitel)
@{b}Starte StormC@{ub}                  - Startet StormC
@{b}Transferiere Projekt@{ub}           - Tranferiert das gespeicherte Projekt zu StormC (via ARexx)
@{b}Kompilieren@{ub}                    - StormC kompiliert das gespeicherte Projekt (via ARexx)
@{b}Debuggen@{ub}                       - StormC debugged das gespeicherte Projekt (via ARexx)
@{b}über CLI starten@{ub}               - Startet das kompilerte Programm via Shell
@{b}über StormRun starten@{ub}          - Startet das kompilerte Programm via StormRun

@ENDNODE
@NODE Mainwin "Das Hauptfenster"


Das Hauptfenster nimmt als Titel den aktuellen Namen des Projektes an. Es besitzt
eine Statusleiste, in der jeweils eine kleine Hilfe angezeigt wird, wenn der Maus-
zeiger über einem Gadget steht.
Weiterhin gibt es Karteikarten, die jeweils eine bestimmte Komponente des Systems
beschreiben. So sind hier 13 verschiedene Seiten zu finden:

            @{"Screen-Seite         " link Mainwinscreens}
            @{"Window-Seite         " link Mainwinwindows}
            @{"Reaction-Seite       " link Mainwingadgets}
            @{"GadTools-Seite       " link Mainwingadtools}
            @{"ICMap-Seite          " link Mainwinicmap}
            @{"Menu-Seite           " link Mainwinmenu}
            @{"Popup-Seite          " link Mainwinpopup}
            @{"Request-Seite        " link Mainwinreq}
            @{"ASL-Seite            " link Mainwinasl}
            @{"Locale-Seite         " link Mainwinlocale}
            @{"Variable-Seite       " link Mainwinglobvar}
            @{"Array-Seite          " link Mainwinarray}
            @{"Tooltype-Seite       " link Mainwintooltype}
            @{"Include-Seite        " link Mainwininclude}
            @{"Library-Seite        " link Mainwinlibrary}
            @{"Install-Seite        " link Mainwininstall}

Allgemein ist das Fenster für (fast) alle Karteikarten gleich:

Auf der linken Seite befindet sich beim Start eine leere Liste, die mit den eigenen
Objekten aufgefüllt wird;

rechts daneben befinden sich die Buttons:
mit "Hinzufügen" wird ein bereits modifiziertes Element der eigenen Liste hinzugefügt;
mit "Aufwärts"/"Abwärts" rutscht der aktive Eintrag in der eigenen Liste nach oben/unten;
mit "Löschen" löscht man den aktiven Eintrag aus der eigenen Liste;
mit "Liste zurücksetzen" löscht man die gesamte eigenen Liste;
mit "Bearbeiten" öffnet/schließt sich das Attributfenster
mit "Vorschau" kann man das Ergebnis der Arbeit bewundern, ohne zu kompilieren (abhängig
von der gewählten Karteikarte);

Auf der rechten Seite findet sich eine Liste mit Vorgaben für die jeweilige Komponente.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das sich auf
derjenigen Seite öffnet, auf der die jeweilige Seite beschrieben ist.

@ENDNODE
@NODE Mainwinscreens "Das Hauptfenster - die Screens - Seite"


Diese Seite ist neu seit der Version 4.2. Hier kann man Screens erstellen und im Quelltext
verarbeiten.

Zu beachten ist folgendes: der vorgefertigte Eintrag "Workbench Screen" bedeutet, dass die
Intuition-Funktion "LockPubScreen(NULL)" ausgeführt wird. Entsprechend ist es eine logische
Schlussfolgerung, dass nur ein Screen dieser Art in der Liste erscheinen sollte. Ein Screen
ist als Vorgabe bereits implementiert: nämlich ein "Workbench Screen". Dieser kann durchaus
mittels eines anderen Screen ("Custom Screen") ersetzt werden, der dann eine neue Anzeige
(Bildschirm/Screen) öffnet. Auch das Mischen der beiden ist zulässig.

Im Attributfenster ist auf der Seite "Sizes" unter dem Punkt "Screentype" einstellbar, für
welches Treibersystem (CGX, Picasso96 oder original Amiga) generiert werden soll. Dieses
Feature ist seit Version 4.3 verfügbar. Bitte beachten Sie folgende wichtige Richtlinien für
die entsprechenden Treibersysteme:

@{b}CyberGraphX@{ub}
Sie benötigen folgende Includes:
cybergraphx/cybergraphics.h
proto/cybergraphics.h

und natürlich die "cybergraphics.library"
(Versionseinstellung auf 40, BaseName auf "CyberGfxBase", Reaction auf FALSE)


@{b}Picasso 96@{ub}
Sie benötigen folgende Includes:
clib/picasso96_protos.h

und natürlich die "Picasso96API.library"
(Versionseinstellung auf 2, BaseName auf "P96Base", Reaction auf FALSE)



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinwindows "Das Hauptfenster - die Windows - Seite"


Dies ist diejenige Seite, in der man die Fenster, die man in das eigene Programm
implementieren will, konfiguriert.

Hierbei ist zu beachten, dass das jeweils aktive Fenster auch mit "aktiv"
gekennzeichnet ist. Das wiederum bedeutet, dass, abhängig vom gewählten aktiven Fenster,
die Gadgetlisten sich dem aktiven Fenster unterordnen und damit aktualisiert werden.
D.h., NUR wenn ein Fenster "aktiv" ist, kann auch sein Inhalt (Gadgets) geändert werden.


@{b} !!WICHTIG!! @{ub}

Im Attributfenster selbst kann nun festgelegt werden, ob ein Fenster im
AmigaOS 2.0 oder AmigaOS 3.5 - Look erscheinen soll. Ist ein OS 2.0 - Look gewählt, können
ihm keine Reaction-Gadgets zugewiesen werden ! Ebenso kann in ein "normales" Fenster kein
GadTools-Gadget gesetzt werden.

@{b} !!WICHTIG!! @{ub}



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwingadgets "Das Hauptfenster - die Reaction - Seite"


Auf der Gadgets-Seite befinden sich 3 Gruppen von Gadgets:


     *  Links befindet sich eine leere Liste, die später mit der eigenen hierarchischen
        Liste von Gadget-Objekten aufgefüllt werden soll.
        Als Einträge werden jeweils die Namen der Gadgets angenommen.
        Ein hinzugefügtes Gadget wird jeweils auf die nächsthöhere "Generation" gestellt;
        so ist es immer ein abgeleitetes Gadget des Vorausgegangenen.

     *  Mittig, beschriebene Buttons

     *  Rechts ist die Liste der derzeit implementierten Gadgets. Wenn Sie einen Eintrag
        anwählen, wird das "Attributfenster für Gadgets" aktualisiert, in dem
        dann die gewünschten Eigenschaften zu setzen sind. Die Eigenschaften selbst sind in
        dieser Anleitung kaum weiter erläutert, da ich denke das die AutoDocs und Includes
        genug Informationen enthalten. Sollten sich aber bei den Attributen Abweichungen
        ergeben, werden Sie selbstverständlich ausführlich erläutert.


Ziel dieser "neuen" Art, Oberflächen zu erstellen ist es, mehr und mehr Arbeit dem
Programmierer abzunehmen. Die Positionen und Ausmaße werden automatisch durch das
System, in Relation zu der Fenstergröße, bestimmt.
Sie können die Anordnung der Gadgets beeinflussen, indem sie vertikale bzw. horizontale
Gruppen (Layouts) einfügen. Gadgets, die einem bestimmten Layout zugehörig sein
sollen, müssen von dem Layout-Gadget abgeleitet werden, d.h., dass sie sich
in der Liste weiter rechts anordnen und somit eine eigene Unterklasse bilden.
So können auch horizontale und vertikale Layout-Gruppen wiederum in horizontale
und vertikale Layout-Gruppen aufteilen, wie es das 2. Beispiel zeigen wird.

Horizontale Gruppe bedeutet, dass sich alle Gadgets horizontal, also nebeneinander,
aufbauen. Entsprechend gilt dasselbe für die vertikalen Layouts.


@{b}Beispiel 1:@{ub}
        Einfaches Beispiel mit einem String-Gadget (Eingabefeld) und zwei Buttons.
                 ________________________________________________
                |x|                                          |-|=|
                |x|__________________________________________|=|=|
                |                                              | |
                |                                              | |
                |             ______________________________   | |
                |   Editfeld | Stringgadget                 |  | |
                |            |______________________________|  | |
                |                                              | |
                |                                              | |
                |                                              | |
                |      ______________      ______________      | |
                |     |              |    |              |     | |
                |     |   Button 1   |    |   Button 2   |     | |
                |     |______________|    |______________|     | |
                |                                              |_|
                |______________________________________________|x|


        Die Liste für dieses Beispiel muss nun so aussehen:

        Layout1                          das sog. "Root-Layout" bestimmt jeden Beginn
        |                                einer Gadgetliste. In diesem Fall sollte es
        |                                mit dem Attribut "Orientation-vertical"
        |                                ausgestattet sein, weil die 2 Gadget-Gruppen
        |                                (1. String-Gadget / 2. beide Buttons)
        |                                untereinander angeordnet sind.
        |
        +- String1                       das String-Gadget ist das erste sichtbare
        |                                Objekt in unserer Liste.
        |
        +- horizontal Layout2            eine erneute Aufteilung des Raumes findet
           |                             hier statt. Zuerst hatten wir das gesamte
           |                             Fenster aufgeteilt in untereinander liegende
           |                             Gruppen; in der einen befand sich das String-
           |                             Gadget und in der anderen erstellen wir jetzt
           |                             eine Gruppe, die nebeneinander liegende Gadgets
           |                             beinhalten wird.
           |
           +- Button1                    dies ist der linke Button
           +- Button2                    das ist der rechte


Eigentlich gar nicht so schwer, oder ?
Naja, dann zu umfangreicherem:


@{b}Beispiel 2:@{ub}
     _________________________________________________________________________
    |x|                                                                   |-|=|
    |x|___________________________________________________________________|=|=|
    |                                                                       | |
    |                                                                       | |
    |      _______________       _______________       _______________      | |
    |     |               |     |               |     |               |     | |
    |     |   Button  1   |     |   Button  2   |     |   Button  3   |     | |
    |     |_______________|     |_______________|     |_______________|     | |
    |                                                                       | |
    |      ___________________________     ___________________________      | |
    |     |      |      |      |      |   |      |      |      |      |     | |
    |     |        Fuelgauge  1       |   |        Fuelgauge  2       |     | |
    |     |___________________________|   |___________________________|     | |
    |                                                                       | |
    |      _____________ _       _______________       _____________ _      | |
    |     |             |x|     |  |            |     |             |x|     | |
    |     |             |-|     |##| Chooser  1 |     |             |-|     | |
    |     |             | |     |__I____________|     |             | |     | |
    |     |             | |                           |             | |     | |
    |     |             | |                           |             | |     | |
    |     | Listbrowser | |      _______________      | Listbrowser | |     | |
    |     |             | |     |  |            |     |             | |     | |
    |     |             |o|     |##| Chooser  2 |     |             |o|     | |
    |     |             | |     |__I____________|     |             | |     | |
    |     |             | |                           |             | |     | |
    |     |             | |                           |             | |     | |
    |     |             | |      _______________      |             | |     | |
    |     |             | |     |  |            |     |             | |     | |
    |     |             |_|     |##| Chooser  3 |     |             |_|     | |
    |     |_____________|x|     |__I____________|     |_____________|x|     | |
    |                                                                       | |
    |                    _______________________       _______________      | |
    |     String-Gadget |                       |     |               |     | |
    |                   |_______________________|     |   Button  4   |     | |
    |                                                 |_______________|     | |
    |                                                                       |_|
    |_______________________________________________________________________|x|


        Layout1
        |
        +- vertical Layout
           |
           +- horizontal Layout
           |  |
           |  +- Button1
           |  +- Button2
           |  +- Button3
           |
           +- horizontal Layout
           |  |
           |  +- Fuelgauge1
           |  +- Fuelgauge2
           |
           +- horizontal Layout
           |  |
           |  +- Listbrowser
           |  |
           |  +- vertical Layout
           |  |  |
           |  |  +- Chooser1
           |  |  +- Chooser2
           |  |  +- Chooser3
           |  |
           |  +- Listbrowser
           |
           +- horizontal Layout
              |
              +- String
              +- Button4


Spielen Sie ruhig ein wenig mit den horizontalen und vertikalen Gruppen herum,
damit Sie ein Gefühl dafür bekommen. Wenn Sie bisher immer mit der Gadtools-Library
gearbeitet und absolute Werte für Ausmaße und Positionen eingegeben haben,
ist die Umstellung machmal gar nicht so einfach ! Aber, ...

Übung macht den Meister !


@{SHINE} SPEZIELLE INFORMATIONEN... @{ENDSHINE}


@{b}ad 1 (Benutzung von Clicktab-Gadgets):@{ub}

Falls Clicktab-Gadgets benutzt werden sollen, MUSS die Gadget-Liste in etwa so aussehen:

         ________________________________________________
        |x|                                          |-|=|
        |x|__________________________________________|=|=|
        |  ________  ________  ________                | |
        | | node 1 || node 2 || node 3 |               | |
        | |________||________||________|_____________  | |
        | |                                          | | |
        | |  __________________  __________________  | | |
        | | |                  ||                  | | | |
        | | |                  ||                  | | | |
        | | |     Button 1     ||     Button 2     | | | |
        | | |                  ||                  | | | |
        | | |__________________||__________________| | | |
        | |                                          | | |
        | |__________________________________________| | |
        |                                              |_|
        |______________________________________________|x|


        Clicktab
        |
        +- vertical Page1
           |
           +- horizontal Page2
           |  |
           |  +- Button1
           |  +- Button2
           |  |
           +- vertical Page3
           |  |
           |  +- Integer1
           |  +- Integer2
           |  |
           +- horizontal Page4
              |
              +- Listbrowser1
              +- Listbrowser2


"Pages" werden generiert, indem ein Layout-Gadget in den "PageMode" versetzt wird.
(Attribut-Fenster)

@{b}ACHTUNG ! Niemals das erste Page-Gadget unter dem Clicktab vergessen !!!!@{ub}


@{b}ad 2 (Einbinden von Images):@{ub}

Images sind spezielle Gadgets, die Bildinformationen (geladene Bilder, Systemgadgets etc.)
enthalten. Möchten Sie ein solches Image auch in Ihr Programm integrieren, sollten Sie
darauf achten, dass das Image vom abhängigen Gadget entweder abgeleitet ist, bzw. dem Gadget
die Zuordnung via Image-Verbindung im Attributfenster erfolgt. Sie dürfen jedoch ein Image
lediglich von einem Button, einem Layout oder einem Slider ableiten; alle anderen Gadgets
verbieten dies !!!!

Ein Beispiel könnte etwa so aussehen:

        horizontal Layout1
        |
        +- vertical Layout2
        |  |
        |  +- Bitmap1
        |  |
        +- vertical Layout3
           |
           +- Button1
           |  |
           |  +- Glyph1
           |  |
           +- Slider1
              |
              +- Bitmap2


@{SHINE} SPEZIELLE INFORMATIONEN... @{ENDSHINE}



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwingadtools "Das Hauptfenster - die GadTools - Seite"


Da GadTools lediglich über Gadgets verfügt, die ihrerseits absolute Positionen verlangen, ist
die Handhabung etwas komplizierter (oder logischer ? :))).

Für die Erstellung eines Fensters mit Gadtools-Gadgets (OS 2.0 - Look) muss das Fenster selbst
ein OS 2.0 - Fenster sein.
Dies ist im Attributfenster auf der @{"Windows-Seite" link Mainwinwindows} einstellbar.
Wichtig ist nun, dass das Fenster, in welches man das Gadget positionieren will, auch offen ist.
Nun kann auf der GadTools-Seite das gewünschte Gadget gewählt werden, und im zweiten Schritt
die Lage und Größe mittels Mausklick (und Mausbewegung) in das Fenster übertragen werden.
Nachträgliche Änderungen sind ebenso, durch einfaches Fassen der gekennzeichneten
Randelemente, möglich. Will man ein anderes Gadget verschieben oder vergrößern/verkleinern,
genügt für die Aktivierung schon ein einfacher Klick auf das Gadget selbst.

Durch den Support von OS 2.0 - Fenstern und Gadgets ist es möglich, ein Programm zu generieren,
welches sowohl auf Basis von OS 2.0, als auch auf OS 3.5 läuft.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinicmap "Das Hauptfenster - Interconnection Map - Page"


Interconnection Maps sind dazu da, Gadgets untereinander zu verknüpfen. Die Verknüpfung lässt
es zu, dass man verschiedene Tags (Eigenschaften) und deren Werte zwischen den Gadgets austauschen
lassen kann.

Wird z.B. ein Fuelgauge-Gadget mit einem Palette-Gadget verbunden, muss auch über die geforderten
Tags (Eigenschaften) Klarheit bestehen. So kann z.B. der Tag "FUELGAUGE_Level" mit "PALETTE_Colour"
verbunden werden. Jedesmal, wenn die Palette einen anderen Wert erhält (durch klicken) wird diese
Veränderung direkt auf die Fuelgauge übertragen.

Zur Unterscheidung gibt es unidirektionale und bidirektionale Maps:
bei unidirektionalen Maps werden nur Informationen vom primären zum sekundären Gadget übertragen;
bei bidirektionalen Maps werden Informationen vom primären zum sekundären sowie vom sekundären zum
primären Gadget übertragen.

Um die Gadgets nun Daten austauschen zu lassen, muss die ICMap der eigenen Liste hinzugefügt werden.
Dann sind die Gadgets untereinander verknüpft, ohne dass auch nur ein einziges Byte Quelltext
getippt wurde !



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinmenu "Das Hauptfenster - die Menü - Seite"


Im Menüeditor sind in der rechten Liste (bisher) 8 Einträge zu finden, wobei die ersten
3 Einträge die Systemdefinitionen repräsentieren (Titel, Item, Subitem) -> siehe AutoDocs;

Die anderen drei Einträge sind komplette Menüs.
Project steht für das bekannte "Projekt"-Menü:
@{b}      * Projekt @{ub}
        * Neu
        * Öffnen
        * ---------
        * Speichern
        * Speichern als...
        * ---------
        * Drucken
        * ---------
        * Einstellungen
        * Informationen
        * ---------
        * Beenden


Edit ist das Menü "Bearbeiten":
@{b}      * Bearbeiten @{ub}
        * Ausschneiden
        * Kopieren
        * Einfügen
        * ---------
        * Eingriff zurück
        * Eingriff erneut
        * ---------
        * Löschen


Preferences ist das erweiterte Standart-Menü für Einstell-Programme wie "Time", "Font", "Serial" usw.:
@{b}      * Projekt @{ub}
        * Öffnen
        * Speichern als
        * ---------
        * Beenden

@{b}      * Bearbeiten @{ub}
        * Ausschneiden
        * Kopieren
        * Einfügen
        * ---------
        * Löschen
        * ---------
        * Widerrufen
        * Wiederherstellen
        * ---------
        * auf Vorgaben zurücksetzen
        * auf zuletzt gespeichertes
        * auf vorherigen Stand

@{b}      * Einstellungen @{ub}
        * Piktogramme erzeugen?


Project small ist das verkürzte "Projekt"-Menü:
@{b}      * Projekt @{ub}
        * Neu
        * ---------
        * Öffnen
        * Speichern
        * ---------
        * Informationen
        * Beenden


Edit small ist das verkürzte Menü "Bearbeiten":
@{b}      * Bearbeiten @{ub}
        * Ausschneiden
        * Kopieren
        * Einfügen
        * ---------
        * Löschen


Preferences small Standart-Menü für Einstell-Programme:
@{b}      * Projekt @{ub}
        * Öffnen
        * Speichern als
        * ---------
        * Beenden

@{b}      * Bearbeiten @{ub}
        * auf Vorgaben zurücksetzen
        * auf zuletzt gespeichertes
        * auf vorherigen Stand

@{b}      * Einstellungen @{ub}
        * Piktogramme erzeugen?


Der Eintrag muss nur angewählt und der eigenen Liste hinzugefügt werden. Schon hat man
das komplette Menü INKLUSIVE ÜBERSETZUNGEN parametriert. Die einzelnen Einträge können
dann auch selbstverständlich verändert und dem eigenen Geschmack angepasst werden.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinpopup "Das Hauptfenster - die PopUp-Menü - Seite"


Diese Seite ist eine Eigenkreation eines fiktiven GUI-Objektes. D.h., dieses Objekt
existiert nicht in Reaction, jedoch kann man solche Popup-Menüs mit Emperor erstellen.

Es ist UNBEDINGT notwendig, für das entsprechende Fenster, zu dem ein Popup-Menü gehört,
die Attribute "RMB_Trap" und "ReportMouse" anzuwählen !

Wird ein Popup-Menü hinzugefügt, wird im eigenen Source eine Funktion erstellt, die den
Namen "Window1_MouseButton_Right_Down_Event" trägt. Die Bezeichnung "Window1" hängt dabei
von dem jeweiligen Fenster ab, das gewählt wurde. Innerhalb dieser Funktion befindet sich
ein Aufruf des Popup-Menüs (z.B. "PopupMenu1();"), dessen Rückgabewert die Nummer des
gewählten Eintrag enthält.

Ein Popup-Menü benötigt folgende Attribute:
@{b}Misc-Seite@{ub}
PopupMenu Name                  - Name des Popup-Menüs, mit dem es im Source aufgerufen wird  (WICHTIG !)
PopupMenu Items                 - zugehöriges Array, das die Einträge des Popup-Menüs verwaltet  (WICHTIG !)
Window                          - zugehöriges Fenster  (WICHTIG !)
Screen                          - zugehöriger Bildschirmname  (WICHTIG !)
Alignment                       - Ausrichtung der Einträge (links, mittig, rechts)
PopupMenu Width                 - Breite des Popup-Menüs  (WICHTIG !)
Pulldown-menu support           - unterstützt, dass das Fenster auch ein "normales" Menü besitzt
                                  (für Profis: es wird das "RMB_Trap"-Flag für das entsprechende
                                  Fenster automatisch beim Event "MouseMove" an- bzw. ausgeschaltet)

@{b}Style-Seite@{ub}
Outer bevel - Bevel State       - ob die Umrandung eingedrückt oder erhaben erscheinen soll
Outer bevel - Bevel Style       - welche Umrandung benutzt werden soll
Outer bevel - Space             - Platz zwischen einem Eintrag und der äußeren Umrandung
Outer bevel - FillPen           - Farbe des Stiftes, der für den Hintergrund des Popup-Menüs
                                  benutzt werden soll
Inner bevel - Bevel State       - ob die Umrandung des Eintrags eingedrückt oder erhaben erscheinen soll
Inner bevel - Bevel Style       - welche Umrandung für den Eintrag benutzt werden soll
Inner bevel - Space             - Platz zwischen dem Text eines Eintrags und dessen Umrandung
Inner bevel - SelectPen         - Farbe des Stiftes, der für den selektierten Eintrag des Popup-Menüs
                                  benutzt werden soll



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinreq "Das Hauptfenster - die Requester - Seite"


Auf der Requester-Seite finden sich in der rechten Liste verschiedene Einträge, über
die Requester (Dialogfelder) wie z.B. für Informationen, Beenden oder Fehlermeldungen
generiert werden können. Ein einfacher Klick auf den entsprechenden Eintrag
(und mit angewähltem Menüeintrag "Fenster-Attributfenster") und schon kann dieser
editiert werden, um ihn danach in die eigene Liste einzufügen.

Es gibt bereits vorgefertigte Einträge, wie z.B. das Quitrequest (ein Dialogfenster,
dass eine eigenständige Erstellung zum Beenden überflüssig macht), das erfragt,
ob das Programm (hier geht es um das Selbstgeschriebene und nicht um Emperor)
wirklich beendet werden soll, wie man es von diversen Applikationen und Tools her kennt.

Der Eintrag Emptyrequest kann bei allen anderen (nicht vorgefertigten) angewandt
werden.

WICHTIG:Für den Requester-Bodytext (der Text, der die nähere Auskunft neben dem Titel
        und den Gadgets definiert) darf maximal 400 Zeichen lang sein !

vorgefertigte Requester und deren Bodytext:
@{b}Emptyrequest@{ub}     -  <LEER>

@{b}Errorrequest@{ub}     -  Ein Fehler ist aufgetreten: 

@{b}Openrequest@{ub}      -  Das Programm konnte die Datei nicht öffnen. 
                    Möglicherweise ist sie in Gebrauch, oder sie existierte nicht ! 

@{b}Saverequest@{ub}      -  Das Programm konnte die Datei nicht speichern. 
                    Möglicherweise ist sie in Gebrauch ! 

@{b}Overwriterequest@{ub} -  Die Datei existiert bereits. 
                    Soll sie ersetzt werden ? 

@{b}Deleterequest@{ub}    -  Möchten Sie die Datei wirklich löschen ? 

@{b}Nomemrequest@{ub}     -  Programm konnte keinen freien Speicher bekommen ! 
                    Bitte schließen Sie andere Applikationen 
                    und versuchen es nocheinmal ! 

@{b}Clearrequest@{ub}     -  Möchten Sie wirklich alle Daten löschen ? 

@{b}Inforequest@{ub}      -  <LEER>

@{b}Quitrequest@{ub}      -  Möchten Sie das Programm wirklich beenden ? 


Eine Besonderheit seit Version 4.1 weist diese Seite auf:
Es können Emperor-eigene Requester erstellt werden, die auf den Reaction-Gadgets basieren.
Man kann auf der Seite "Reaction" im Attributfenster dieses Feature aktivieren.
Folgende Parameter sind konfigurierbar:
CloseGadget    - der Requester erhält ein Schließsymbol
SetBusyPointer - der Mauszeiger wird in den "Busy"-Modus versetzt, wenn der Requester
                 inaktiv wird
Dragging       - diese Option erlaubt es, mittels Mausklick auf einen beliebigen Punkt des
                 Requesters dieses zu verschieben
HorizontalBar  - eine horizontale Linie wird zwischen Requestertext und Buttons gezeichnet
SizeGadget     - der Requester ist in der Größe variierbar
SizeBBottom    - das Größengadget wird auf der unteren Fensterleiste angebracht
SizeBRight     - das Größengadget wird auf der rechten Fensterleiste angebracht
Width          - Breite des Requesters
Heigth         - Höhe des Requesters
Position       - spezielle Positionierung des Requesters
Screen         - auf welchem Screen der Requester geöffnet wird



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinasl "Das Hauptfenster - die ASL - Seite"


Hier kann man die Requester (Dialogfenster) für Datei-, Schrift- und Bildschirmauswahl
verändern und nach Herzenslust ausprobieren, bis sie den Vorstellungen entsprechen.

Siehe AutoDocs !



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinlocale "Das Hauptfenster - die Locale - Seite"


Auf der Locale-Seite muss für die Erstellung eines Kataloges selbst nichts getan werden.
Die Katalog-Identifikationen werden jeweils aus den anderen Teilen des Programms
(Requester, Menü etc.) in diese Liste überführt.

Nur die Übersetzung selbst wird hier vorgenommen. Hierzu muss die gewünschte Sprache
gewählt werden und zusätzlich die zu übersetzende Katalog-ID.
Dann ist einfach nur noch (bei geöffnetem Attributfenster Menü-"Fenster-Attributfenster")
das mittlere Feld anzuwählen und die darunter stehende Zeichenkette zu übersetzen.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinglobvar "Das Hauptfenster - die GlobVars - Seite"


Hier kann zwischen diversen Variablentypen gewählt werden. Um sie später der
eigene Liste hinzuzufügen, müssen (wie immer) die spezifischen Einstellungen vorgenommen
werden.

Das erste Gadget (von oben) kann nur genutzt werden, wenn eine Systemstruktur
(siehe AutoDocs) aufgerufen und initialisiert werden soll.
Das zweite Eingabefeld bestimmt den Variablennamen, mit dem im Quelltext selbst
gearbeitet werden kann.
Das dritte bestimmt den initial zugewiesenen Wert.
Das unterste ist nur als Hilfe gedacht, in dem der Wertebereich der aktuellen Variable
angezeigt wird.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinarray "Das Hauptfenster - die Arrays - Seite"


Bei der Erstellung eines Arrays (Einträge für Listbrowser, Radiobutton, Chooser, Clicktabs und
Speedbar) MUSS das Menü-"Fenster-Attributfenster" geöffnet werden.
Hier, im Attributfenster ist wiederum eine Liste, die mit Einträgen des Arrays gefüllt
werden muss, bevor der Eintrag (Name des Arrays) zu der Liste im Hauptfenster hinzugefügt
werden kann.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwintooltype "Das Hauptfenster - die ToolTypes - Seite"


Diese Seite dient dazu, ToolTypes des Icons oder die Argumente beim CLI-Start auszuwerten.
Dabei ist es möglich, die angegebenen ToolTypes als Suchkriterium ausschließlich für echte Icon-
ToolTypes oder ausschließlich für CLI-Argumente zu nutzen, oder aber eine kombinierte Suche für
beide Möglichkeiten zu definieren.

Es wird eine ToolType-Funktion bei einem Doppelklick auf das entsprechende ToolType erzeugt, in
dem dann eigene Aufrufe, Befehle und Funktionen gesteuert werden können. Die Funktion wird beim
kombinierten Aufruf nur einmal angesteuert und erhält als Argument "STRPTR ToolVar" das Argument,
welches mit dem ToolType übergeben wurde.

@{b}FindToolType@{ub}        - beschreibt den Namen des ToolTypes, nach dem gesucht werden soll

@{b}CompareValue@{ub}        - optional angebbares Argument, welches mit dem Argument des ToolTypes
                       verglichen wird, bevor der Funktionsaufruf gestartet wird

@{b}hand over value@{ub}     - gibt an, ob ein Vergleich des Argumentes des Tooltypes geschehen soll

@{b}calling type@{ub}        - gibt an, ob das ToolType ausschließlich vom CLI-Start, Workbench-Start
                       oder beidem abhängig sein soll

Falls Icon-ToolTypes überprüft werden sollen, ist es unerläßlich, die icon.library (auf der Library-
Seite) und das clib/icon_protos.h-Include (auf der Include-Seite) hinzuzufügen. Dies können Sie durch
einfaches Zurücksetzen der gesamten Library- bzw. Include-Liste erreichen.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwininclude "Das Hauptfenster - die Includes - Seite"


Hier kann man Includes auswählen, die im generierten Quelltext berücksichtigt werden.

Diese Seite weist eine Besonderheit auf:
Der Button "Liste zurücksetzen" oder der Menüpunkt "Alles Löschen" setzt die Liste, abhängig
von der gewählten Quelltextart im Programmumgebungsfenster (!!), zurück zu initialen Werten.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwinlibrary "Das Hauptfenster - die Libraries - Seite"


Diese Seite dient dazu, Libraries auswählen, die im generierten Quelltext geöffnet werden.
Man benötigt neben dem Library-Pfad auch den sog. Basename ("IntuitionBase", "GfxBase" etc.).
Ausserdem wird eine minimal zu öffnende Versionsangabe verlangt und eine Angabe, ob diese
Library eine OS3.5+-Library ist (verändertes Handling im generierten Quelltext).
Die Checkbox "Reaction Library" hat etwas mit der Konzeption des generierten Source zu tun.
Da es möglich ist, OS3.5+ und OS2.0-Programme bzw. Mischcode zu produzieren, hat dieses Gadget
eine spezielle Aufgabe: wird eine Library während des Initialisierungsvorganges nicht gefunden,
so fragt die Routine, ob eine essentielle Notwendigkeit zum Öffnen vorliegt, oder ob diese
Library nicht unbedingt gebraucht wird. Im ersten Fall wird das Programm mit Fehlermeldung
beendet, im zweiten Fall die Variable "os35 = FALSE" gesetzt.

Diese Seite weist eine Besonderheit auf:
Der Button "Liste zurücksetzen" oder der Menüpunkt "Alles Löschen" setzt die Liste, abhängig
von der gewählten Quelltextart im Programmumgebungsfenster (!!), zurück zu initialen Werten.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Mainwininstall "Das Hauptfenster - die Install - Seite"


Auf dieser Seite ist es möglich, ein Install-Skript für Ihr Projekt zu erstellen.

Es ist nicht ratsam, dort Veränderungen vorzunehmen, weil sich diese Seite noch im Versuchsstadium
befindet und einen festgelegten Algorithmus, der durch die Einträge z.Zt. nicht beeinflussbar ist,
ausführt. Dies wird sich in naher Zukunft aber ändern.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Preferenceswin "Das Einstellungsfenster"


In diesem Fenster sind die Einstellungen von Emperor selbst vorzunehmen. Folgende Einstellungs-
möglichkeiten gibt es:

@{b}Seite "Misc":@{ub}
Pfad von StormC  - der Pfad des StormC-Programmpaketes (zu finden auf der Amiga Developer
                   CD 2.1 von der HAAGE & Partner GmbH
                   "ADCD_2.1:Contributions/Haage_&_Partner/StormC/")

Pfad von CatComp - der Pfad des Programmes "CatComp" (zu finden auf der Amiga Developer
                   CD 2.1 von der HAAGE & Partner GmbH
                   "ADCD_2.1:NDK/NDK_3.5/Tools/CatComp")

Pfad des Editors - der Pfad Ihres Lieblingseditors kann hier angegeben werden, so dass dieser
                   statt des Emperor-eigenen benutzt wird (bitte den Punkt "externen Editor
                   benutzen" auf der Seite "General" überprüfen !)

Includes-Verzeichnis - Pfad des initial gewählten Includes-Verzeichnisses
                       (genutzt im Attributfenster - Includes)

Libs-Verzeichnis     - Pfad des initial gewählten Library-Verzeichnisses
                       (genutzt im Attributfenster - Library)

kleine Schriftart    - Font für spezielle Listen, die viele Informationen enthalten.
                       Dieser Font sollte möglichst klein sein. Genutzt wird er im
                       Texteditor und in der Programmierhilfe

Bildschirm           - Wählen Sie einen Bildschirm (Screenmode) aus, auf dem Emperor geöffnet
                       werden soll. (erst nach Neustart Emperors aktiv)



@{b}Seite "General":@{ub}
Requester beim Löschen von Objekten  - beim Löschen von Objekten kann die Sicherheitsabfrage
                                       an-/abgeschaltet werden.

Doppelklick kreiert Funktion/Aufruf  - beim Doppelklick auf ein Objekt im Hauptfenster wird
                                       je nach Art des Objektes eine Funktion, ein Funktions-
                                       aufruf oder ein Variablenname in den Quelltext kopiert.
                                       Dies kann mit dieser Option unterbunden werden.

Erlaube drag'n'drop                  - ermöglicht das Nehmen & Ablegen von Objekten im Hauptfenster

Komponentenauswahl beim Öffnen       - öffnet vor dem Laden eines Projektes ein Auswahlfenster, das
                                       es ermöglicht, einige Komponenten beim laden zu umgehen.

Externen Editor benutzen             - zusammen mit dem Punkt "Pfad des Editors" auf der Seite "Misc"
                                       ist es möglich, den internen Editor von Emperor zu umgehen.

Projekt überprüfen                   - überprüft das Projekt auf logische Fehler vor dem Speichern

kleines Hauptfenster                 - verkleinert das Hauptfenster nach einem Neustart Emperors



@{b}Seite "Catalog creation"@{ub}
Aufgeführt sind die Sprachen, für die ein Katalog erstellt werden kann. Für die mit einem Häkchen
versehenen Sprachen wird dann tatsächlich auch ein zugehöriger Katalog erstellt.



@{b}Seite "StormC startup"@{ub}
Prozessortyp         - Dieser Parameter wird an das StormC-Projekt übergeben. Er beinhaltet
                       den Prozessor, für den das Projekt später kompiliert werden soll.

Wahlweise können die Argumente SaveMem, HotHelp und GoldED beim Start von StormC übergeben werden.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE PrefsProgwin "Das Programmumgebungsfenster"


In diesem Fenster werden projektabhängige Einstellungen vorgenommen. Folgende Parameter können
eingestellt werden:

@{b}Seite "Misc"@{ub}
Version/Revision      - Version des Projektes

Datum                 - Datum der Erstellung

Quelltextart          - mixed code: Programm wird für OS2.0 bzw. OS3.5+ erstellt
                      - pure OS3.5+ code: Programm wird ausschließlich für OS3.5+ erstellt
                      - pure OS2.0 code: Programm wird ausschließlich für OS2.0 erstellt

GadgetHelp Ausgabe    - herstellen einer Verbindung zu einem Gadget, das als Gadgethelp-Ausgabe-
                        Gadget fungiert. Die in GadgetHelp enthaltenen Texte werden in diesem
                        Gadget angezeigt.

keine Localedateien   - es werden keine Localedateien gespeichert (*.cd, *.ct und *.catalog)

keine Stormprojekte   - es wird kein Stormprojekt gespeichert (*.¶)

keine Install-Skripts - es wird kein Install-Skript gespeichert (*.install)

Multimenü             - ermöglicht das Erstellen von Menüs, die für jedes Fenster differenziert
                        definiert werden.

Verzeichniserstellung - alle Dateien (mit Ausnahme des Emperor-Projektes) werden in einem
                        Verzeichnis gespeichert, das denselben Namen trägt, wie das Projekt selbst

Piktogramme erzeugen  - Emperor erzeugt Piktogramme für alle Dateien

Autor                 - Name des Autors

Programmname          - Name des Programms

Portname              - Name des Programmports



@{b}Seite "Startup"@{ub}
Initial geöffnetes Fenster  - das beim Start des Programms geöffnete Fenster

Initial geöffneter Screen   - der beim Start des Programms geöffnete Screen

unterstütze doppelten Start - ob das Programm mehrfach gestartet werden kann, oder nicht

Speichercheck               - gibt an, ob beim Start des Programms eine Checkroutine aufgerufen
                              werden und welcher freier Speicher als Minimum vorliegen soll

Stackcheck                  - gibt an, ob beim Start des Programms eine Checkroutine aufgerufen
                              werden und welcher Stack als Minimum vorliegen soll

Programmpriorität           - gibt die Priorität des Programms an



@{b}Seite "Functions"@{ub}
automatische Generierung - ob die Funktionen nach dem vorliegenden Quelltext (*.h) erstellt
                           werden sollen

Die anderen Gadgets enthalten die Funktionen, die manuell generiert werden können.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Texteditorwin "Der Texteditor"


Ein integrierter Texteditor, mit dem das Programm selbst geschrieben wird.
In ihn können die entsprechenden Funktionen und Aufrufe der Funktionen
parametriert bzw. programmiert werden.

Der Inhalt des Texteditors wird als *.h-Datei gespeichert.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE ProgHelpwin "Die Programmierhilfe"


Von der Programmierhilfe aus kann man die vorgefertigten @{"Funktionsmakros" link Funcs} auswählen,
parametrieren und in den eigenen Quelltext einfügen.

        @{b}1.@{ub} Auswählen der gewünschten Funktion durch anklicken
        @{b}2.@{ub} Ein Fenster öffnet sich, in dem die Funktionsparameter eingestellt
           werden können.
        @{b}3.@{ub} Den Button "Funktion dem eigenen Quelltext hinzufügen" drücken
        @{b}4.@{ub} Zwei Fenster, der Texteditor und @{"Nachrichtenbehandlung" link InputHandlewin}
           öffnen sich (4a), falls der Texteditor selbst noch nicht offen war (4b).
                @{b}4a.@{ub} Im Fenster @{"Nachrichtenbehandlung" link InputHandlewin} die Nachricht
                    auswählen, bei der die Funktion eingefügt werden soll. Dies kann auch
                    eine noch nicht bestehende Funktion sein.
                @{b}4b.@{ub} Ist der Texteditor bereits geöffnet, wird die Funktion an der
                    Position des Cursors eingefügt.


Wenn eine Funktion ausgewählt wurde, kann mit @{b}HELP@{ub} die Onlinehilfe (Emperor.guide) gestartet
werden, das sich auf derjenigen Seite öffnet, auf der die Funktion beschrieben ist.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE InputHandlewin "Die Nachrichtenbehandlung"


Dieses Fenster teilt sich in zwei Listen auf. Die Liste auf der linken Seite
enthält eine Vielzahl von möglicherweise auftretenden Ereignissen.

Die Einträge bedeuten im Einzelnen:

        @{b}GadgetUp@{ub}                - wenn ein Gadget angeklickt wurde
        @{b}GadgetHelp@{ub}              - wenn der Mauszeiger über einem Gadget steht
        @{b}MenuPick@{ub}                - wenn ein Eintrag aus dem Menü gewählt wurde
        @{b}MenuHelp@{ub}                - wenn der Mauszeiger über einem Menüeintrag steht
        @{b}CloseWindow@{ub}             - wenn das Fensterschließsymbol gedrückt wurde
        @{b}Iconify@{ub}                 - wenn das Iconifizierungssymbol des Fensters gedrückt wurde
        @{b}Uniconify@{ub}               - wenn das Piktogramm (Icon) doppelt geklickt wurde
        @{b}ActiveWindow@{ub}            - wenn ein Fenster aktiviert wurde
        @{b}InactiveWindow@{ub}          - wenn ein Fenster in den Zustand "Inaktiv" gegangen ist
        @{b}RawKey@{ub}                  - wenn eine Taste gedrückt wurde
        @{b}VanillaKey@{ub}              - wenn eine Taste gedrückt wurde (Menü-Shortcut)
        @{b}MouseButtons@{ub}            - wenn eine Maustaste gedrückt wurde
        @{b}MouseButton_Left_Down@{ub}   - wenn die linke Maustaste gedrückt wurde
        @{b}MouseButton_Left_Up@{ub}     - wenn die linke Maustaste losgelassen wurde
        @{b}MouseButton_Middle_Down@{ub} - wenn die mittlere Maustaste gedrückt wurde
        @{b}MouseButton_Middle_Up@{ub}   - wenn die mittlere Maustaste losgelassen wurde
        @{b}MouseButton_Right_Down@{ub}  - wenn die rechte Maustaste gedrückt wurde
        @{b}MouseButton_Right_Up@{ub}    - wenn die rechte Maustaste losgelassen wurde
        @{b}MouseDoubleclick_Left@{ub}   - wenn die linke Maustaste doppelt gedrückt wurde
        @{b}MouseDoubleclick_Middle@{ub} - wenn die mittlere Maustaste doppelt gedrückt wurde
        @{b}MouseMove@{ub}               - wenn eine Mausbewegung ausgeführt wurde
        @{b}NewSize@{ub}                 - wenn sich die Größe eines Fensters geändert hat
        @{b}ChangeWindow@{ub}            - wenn sich die Größe oder Position eines Fenster geändert hat
        @{b}DisposedWindow@{ub}          - wenn ein Fenster eine Aktion ausgeführt hat
        @{b}IntuiTick@{ub}               - alle 1/10-Sekunden eine Nachricht
        @{b}ShowWindow@{ub}              - wenn ein Fenster geöffnet wird
        @{b}Startup@{ub}                 - bei Programmstart (zur Initialisierung)
        @{b}Shutdown@{ub}                - bei Programmende
          
        Für genauere Ausführungen der Nachrichten des Systems,
        konsultieren Sie bitte die AutoDocs der AmigaDeveloperCD!

          
Wird nun einer dieser Einträge angewählt, erscheinen die dazugehörigen Auswahlmöglichkeiten
zur Spezifizierung des gewünschten Gadgets/Menü/Fensters-Objekts in der Liste zur Rechten.

Ein Doppelklick auf den entsprechenden Eintrag in der rechten Liste, generiert eine neue
Funktion (Prozedur) im Texteditor, in der dann eigener Quelltext hinzugefügt werden kann.
Das können z.B. die vorgefertigten @{"Funktionsmakros" link Funcs} sein, oder die Systemfunktionen
des AmigaOS.



Mit @{b}HELP@{ub} kann die Onlinehilfe (Emperor.guide) gestartet werden, das diese Seite anzeigt.

@ENDNODE
@NODE Vars "vordefinierte Variablen"


Variablenname   Art                     enthält

@{b}os35@{ub}            (BOOL)                  = TRUE, falls auf dem System OS 3.5 installiert ist
@{b}terminated@{ub}      (BOOL)                  = TRUE, wenn das Programm verlassen werden soll

@ENDNODE
@NODE Funcs "Die Funktionen"


In Emperor gibt es einige Makrofunktionen, die z.T. komplizierte Operationen mit
einem einfachen Aufruf und den entsprechenden Parametern ausführen. Diese Makros
sind aus dem eigenen Quelltext heraus ansteuerbar.

@{b} Screenhandling@{ub}
      @{"Emperor_CloseScreen" link Func_closescr}
      @{"Emperor_OpenScreen" link Func_openscr}

@{b} Fensterhandling@{ub}
      @{"Emperor_CloseWindow" link Func_closewin}
      @{"Emperor_OpenWindow" link Func_openwin}
      @{"Emperor_IconifyWindow" link Func_iconifywin}
      @{"Emperor_UniconifyWindow" link Func_uniconifywin}

@{b} Fensterattribute@{ub}
      @{"Emperor_ChangeWindowPosition" link Func_winpos}
      @{"Emperor_ChangeWindowSize" link Func_winsize}
      @{"Emperor_SetWindowBusyPointer" link Func_winbusyptr}
      @{"Emperor_SetWindowTitle" link Func_wintitle}
      @{"Emperor_SetScreenTitle" link Func_scrtitle}

@{b} Gadgetattribute@{ub}
      @{"Emperor_GetGadgetAttr" link Func_getgadgetattr}
      @{"Emperor_GetGadgetAttrComplex" link Func_getgadgetattrcomplex}
      @{"Emperor_GetGadgetDisabledAttr" link Func_getdisabled}
      @{"Emperor_GetGadgetReadOnlyAttr" link Func_getreadonly}
      @{"Emperor_SetGadgetAttr" link Func_setgadgetattr}
      @{"Emperor_SetGadgetAttrComplex" link Func_setgadgetattrcomplex}
      @{"Emperor_SetGadgetDisabledAttr" link Func_setdisabled}
      @{"Emperor_SetGadgetReadOnlyAttr" link Func_setreadonly}
      @{"Emperor_ActivateGadget" link Func_activategad}
      @{"Emperor_RethinkLayout" link Func_rethinklayout}
      @{"Emperor_RefreshGadget" link Func_refreshgadget}

@{b} Menuattribute@{ub}
      @{"Emperor_GetMenuItemAttr" link Func_getmenuitem}
      @{"Emperor_SetMenuItemAttr" link Func_setmenuitem}

@{b} Verschiedene@{ub}
      @{"Emperor_QuitProgram" link Func_quit}
      @{"stringtoint()" link Func_stringtoint}
      @{"stringtofloat()" link Func_stringtofloat}
      @{"inttostring()" link Func_inttostring}
      @{"stringlength()" link Func_stringlength}
      @{"stringtoupper()" link Func_stringtoupper}

@ENDNODE
@NODE Func_closescr "Die Funktion Emperor_CloseScreen"


@{b} Funktion @{ub}
        Makrofunktion für das Schließen von Screens

@{b} Synopsis @{ub}
        Emperor_CloseScreen_ScreenX()

        void Emperor_CloseScreen_ScreenX();

@{b} Aktion @{ub}
        Diese Funktion erledigt mehrere Aufgaben für den Programmierer.
        1. Schließt sie den Screen
        2. Setzt die Variable ScreenX zurück.

@{b} Parameter @{ub}
        ScreenX - Hier muss der Name der Screenvariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie einen
                  neuen Screen erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  ScreenX; wobei X das Screen bestimmt;
                  also z.B. Screen1, Screen2...;

@{b} Beispiel @{ub}
        /* Das Schließen eines Screens muss unbedingt manuell erfolgen,  */
        /* da diese Aktionen der Speicherfreigabe nicht vom Hauptcode    */
        /* übernommen werden können. Wenn der Applikationsscreen         */
        /* geschlossen wird, entfernt Emperor aber noch lange nicht das  */
        /* Programm. Hierfür sollte die Funktion @{"Emperor_QuitProgram()" link Func_quit}  */
        /* genutzt werden. Dennoch gibt es durchaus vielfältige          */
        /* Anwendungsmöglichkeiten für diese Funktion.                   */

        void Chooser1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_CloseScreen_Screen1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Screen1 = Emperor_OpenScreen_Screen2();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        
@{b} Siehe auch @{ub}
        @{"Emperor_OpenScreen_ScreenX()" link Func_openscr}

@ENDNODE
@NODE Func_openscr "Die Funktion Emperor_OpenScreen"


@{b} Funktion @{ub}
        Makrofunktion für das Öffnen von Screens

@{b} Synopsis @{ub}
        Screen = Emperor_OpenScreen_ScreenX()

        struct Screen *Emperor_OpenScreen_ScreenX();

@{b} Aktion @{ub}
        Sie Öffnet den Screen.

@{b} Parameter @{ub}
        ScreenX - Hier muss der Name der Screenvariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie einen
                  neuen Screen erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  ScreenX; wobei X das Screen bestimmt;
                  also z.B. Screen1, Screen2...;

@{b} Ergebnis @{ub}
        ist eine Variable vom Typ "struct Screen *", also auf die alt-bekannte
        Intuition-Struktur. Dies sollte (vorteilhafterweise) die Variable sein,
        deren Namen Sie beim Erstellen des Screens im Projekt-Manager eingestellt
        haben. Sollten Sie die Vorgabe nicht verändert haben, ist diese immer eine
        so aufbaute "Variable":
                sturct Screen *ScreenX; wobei X das Screen bestimmt;
                also z.B. struct Screen *Screen1, *Screen2...;

@{b} Beispiel @{ub}
        void Button1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_CloseScreen_Screen1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Screen1 = Emperor_OpenScreen_Screen2();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        
@{b} Siehe auch @{ub}
        @{"Emperor_CloseScreen_ScreenX()" link Func_closescr}

@ENDNODE
@NODE Func_closewin "Die Funktion Emperor_CloseWindow"


@{b} Funktion @{ub}
        Makrofunktion für das Schließen von Fenstern

@{b} Synopsis @{ub}
        Emperor_CloseWindow_WindowX()

        void Emperor_CloseWindow_WindowX();

@{b} Aktion @{ub}
        Diese Funktion erledigt mehrere Aufgaben für den Programmierer.
        1. Zunächst entfernt sie das erstellte Menü (falls vorhanden !)
        2. Schließt sie das Fenster
        3. Setzt die Variable WindowX zurück.

@{b} Parameter @{ub}
        WindowX - Hier muss der Name der Fenstervariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie ein
                  neues Fenster erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  WindowX; wobei X das Fenster bestimmt;
                  also z.B. Window1, Window2...;

@{b} Beispiel @{ub}
        /* Das Schließen eines Fensters muss unbedingt manuell erfolgen, */
        /* da diese Aktionen der Speicherfreigabe nicht vom Hauptcode    */
        /* übernommen werden können. Wenn das Applikationsfenster        */
        /* geschlossen wird, entfernt Emperor aber noch lange nicht das  */
        /* Programm. Hierfür sollte die Funktion @{"Emperor_QuitProgram()" link Func_quit}  */
        /* genutzt werden. Dennoch gibt es durchaus vielfältige          */
        /* Anwendungsmöglichkeiten für diese Funktion.                   */

        void Chooser1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_CloseWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Window1 = Emperor_OpenWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        
@{b} Siehe auch @{ub}
        @{"Emperor_OpenWindow_WindowX()" link Func_openwin}

@ENDNODE
@NODE Func_openwin "Die Funktion Emperor_OpenWindow"


@{b} Funktion @{ub}
        Makrofunktion für das Öffnen von Fenstern

@{b} Synopsis @{ub}
        Window = Emperor_OpenWindow_WindowX()

        struct Window *Emperor_OpenWindow_WindowX();

@{b} Aktion @{ub}
        Diese Funktion erledigt mehrere Aufgaben für den Programmierer.
        1. Öffnet sie das Fenster
        2. Fügt sie das erstellte Menü (falls vorhanden !) hinzu

@{b} Parameter @{ub}
        WindowX - Hier muss der Name der Fenstervariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie ein
                  neues Fenster erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  WindowX; wobei X das Fenster bestimmt;
                  also z.B. Window1, Window2...;

@{b} Ergebnis @{ub}
        ist eine Variable vom Typ "struct Window *", also auf die alt-bekannte
        Intuition-Struktur. Dies sollte (vorteilhafterweise) die Variable sein,
        deren Namen Sie beim Erstellen des Fensters im Projekt-Manager eingestellt
        haben. Sollten Sie die Vorgabe nicht verändert haben, ist diese immer eine
        so aufbaute "Variable":
                sturct Window *WindowX; wobei X das Fenster bestimmt;
                also z.B. struct Window *Window1, *Window2...;

@{b} Beispiel @{ub}
        void Button1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_CloseWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Window1 = Emperor_OpenWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        
@{b} Siehe auch @{ub}
        @{"Emperor_CloseWindow_WindowX()" link Func_closewin}

@ENDNODE
@NODE Func_iconifywin "Die Funktion Emperor_IconifyWindow"


@{b} Funktion @{ub}
        Makrofunktion für das Ikonifizieren von Fenstern

@{b} Synopsis @{ub}
        Emperor_IconifyWindow_WindowX()

        void Emperor_IconifyWindow_WindowX();

@{b} Aktion @{ub}
        Diese Funktion erledigt mehrere Aufgaben für den Programmierer.
        1. Zunächst entfernt sie das erstellte Menü (falls vorhanden !)
        2. Schließt sie das Fenster
        3. Setzt die Variable Window zurück.

@{b} Parameter @{ub}
        WindowX - Hier muss der Name der Fenstervariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie ein
                  neues Fenster erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  WindowX; wobei X das Fenster bestimmt;
                  also z.B. Window1, Window2...;

@{b} Beispiel @{ub}
        /* Das Ikonifizieren eines Fensters muss unbedingt manuell */
        /* erfolgen, da diese Aktionen der Speicherfreigabe nicht  */
        /* vom Hauptcode übernommen werden können.                 */

        void Checkbox1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_IconifyWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Window2 = Emperor_UniconifyWindow_Window2();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        
@{b} Siehe auch @{ub}
        @{"Emperor_UniconifyWindow_WindowX()" link Func_uniconifywin}

@ENDNODE
@NODE Func_uniconifywin "Die Funktion Emperor_UniconifyWindow"


@{b} Funktion @{ub}
        Makrofunktion für das Rückikonifizieren von Fenstern

@{b} Synopsis @{ub}
        Window = Emperor_UniconifyWindow_WindowX()

        struct Window *Emperor_UniconifyWindow_WindowX();

@{b} Aktion @{ub}
        Diese Funktion erledigt mehrere Aufgaben für den Programmierer.
        1. Öffnet sie das Fenster
        2. Fügt sie das erstellte Menü (falls vorhanden !) hinzu

@{b} Parameter @{ub}
        WindowX - Hier muss der Name der Fenstervariablen angegeben werden.
                  Diesen stellen Sie im Projekt-Manager ein, wenn Sie ein
                  neues Fenster erstellen. Vorgabe ist immer eine so auf-
                  baute "Variable":
                  WindowX; wobei X das Fenster bestimmt;
                  also z.B. Window1, Window2...;

@{b} Ergebnis @{ub}
        ist eine Variable vom Typ "struct Window *", also auf die alt-bekannte
        Intuition-Struktur. Dies sollte (vorteilhafterweise) die Variable sein,
        deren Namen Sie beim Erstellen des Fensters im Projekt-Manager eingestellt
        haben. Sollten Sie die Vorgabe nicht verändert haben, ist diese immer eine
        so aufbaute "Variable":
                sturct Window *WindowX; wobei X das Fenster bestimmt;
                also z.B. struct Window *Window1, *Window2...;

@{b} Beispiel @{ub}
        void Checkbox1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_IconifyWindow_Window1();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Window = Emperor_UniconifyWindow_Window2();

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }
        

@{b} Siehe auch @{ub}
        @{"Emperor_IconifyWindow_WindowX()" link Func_iconifywin}

@ENDNODE
@NODE Func_winpos "Die Funktion Emperor_ChangeWindowPosition"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen der Window-Attribute.

@{b} Synopsis @{ub}
        Emperor_ChangeWindowPosition(Window, Left, Top)

        void Emperor_ChangeWindowPosition(struct Window *, WORD, WORD);

@{b} Aktion @{ub}
        Dieses Makro benutzt die ChangeWindowBox()-Funktion der Intuition-Library.
        Es wird die Position des Fensters modifiziert.

@{b} Parameter @{ub}
        Window - das zu verändernde Fenster. Beispiel: Window1
        Left   - Linke Ecke des Fensters relativ zum linken Bildschirmrand.
        Top    - Obere Ecke des Fensters relativ zum oberen Bildschirmrand

@{b} Beispiel @{ub}
        void Window1_ChangeWindow_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_ChangeWindowPosition(Window, 100, 200);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_ChangeWindowSize()" link Func_winsize}

@ENDNODE
@NODE Func_winsize "Die Funktion Emperor_ChangeWindowSize"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen der Window-Attribute.

@{b} Synopsis @{ub}
        Emperor_ChangeWindowSize(Window, Width, Height)

        void Emperor_ChangeWindowSize(struct Window *, WORD, WORD);

@{b} Aktion @{ub}
        Dieses Makro benutzt die ChangeWindowBox()-Funktion der Intuition-Library.
        Es wird die Größe des Fensters modifiziert.

@{b} Parameter @{ub}
        Window - das zu verändernde Fenster. Beispiel: Window1
        Width  - Breite des Fensters
        Height - Höhe des Fensters

@{b} Beispiel @{ub}
        void Window1_ChangeWindow_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_ChangeWindowSize(Window, 300, 400);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_ChangeWindowPosition()" link Func_winpos}

@ENDNODE
@NODE Func_winbusyptr "Die Funktion Emperor_SetWindowBusyPointer"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen der Window-Attribute.

@{b} Synopsis @{ub}
        Emperor_SetWindowBusyPointer(Window, on/off)

        void Emperor_Window(struct Window *, BOOL);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetWindowPointer()-Funktion der Intuition-Library.
        Es wird der Mauszeiger beim Aktivieren des Fensters in den "Busy"-Modus
        gesetzt.

@{b} Parameter @{ub}
        Window - das zu verändernde Fenster. Beispiel: Window1
        on/off - schaltet bei "TRUE" den BusyPointer an und bei "FALSE" ab.

@{b} Beispiel @{ub}
        void Window1_ChangeWindow_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetWindowBusyPointer(Window, TRUE);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@ENDNODE
@NODE Func_wintitle "Die Funktion Emperor_SetWindowTitle"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen der Window-Attribute.

@{b} Synopsis @{ub}
        Emperor_SetWindowTitle(Window, windowtitle)

        void Emperor_SetWindowTitle(struct Window *, STRPTR);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetWindowTitles()-Funktion der Intuition-Library.
        Es wird der Titel des Fensters modifiziert.

@{b} Parameter @{ub}
        Window - das zu verändernde Fenster. Beispiel: Window1
        windowtitle - der neue Titel für das Fenster

@{b} Beispiel @{ub}
        void Window1_ChangeWindow_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetWindowTitle(Window, "new title");

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetScreenTitle()" link Func_scrtitle}

@ENDNODE
@NODE Func_scrtitle "Die Funktion Emperor_SetScreenTitle"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen der Window-Attribute.

@{b} Synopsis @{ub}
        Emperor_SetScreenTitle(Window, screentitle)

        void Emperor_SetScreenTitle(struct Window *, STRPTR);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetWindowTitles()-Funktion der Intuition-Library.
        Es wird der Titel des Fensters modifiziert.

@{b} Parameter @{ub}
        Window - das zu verändernde Fenster. Beispiel: Window1
        screentitle - der neue Titel für den Screen

@{b} Beispiel @{ub}
        void Window1_ChangeWindow_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetScreenTitle(Window, "new title");

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetWindowTitle()" link Func_wintitle}

@ENDNODE
@NODE Func_getgadgetattr "Die Funktion Emperor_GetGadgetAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Erhalten eines Gadget-Wertes.

@{b} Synopsis @{ub}
        result = Emperor_GetGadgetAttr(GadgetObject)

        STRPTR Emperor_GetGadgetAttr(struct Gadget *);

@{b} Aktion @{ub}
        Dieses Makro benutzt die GetAttr()-Funktion der Intuition-Library.
        Je nachdem, welche Art Gadget abgefragt werden soll, steuert diese
        Funktion, ohne zusätzliche Parameterabfrage, die Flag-Auswahl
        eigenständig. Diese Flags (und deren zugehörige Gadgets) werden
        derzeit unterstützt:

        GA_Selected             (Button, Checkbox)
        CHOOSER_Selected
        CLICKTAB_Current
        FUELGAUGE_Level
        GETFILE_FullFile
        GETFONT_TextAttr
        GETSCREENMODE_DisplayID
        GRAD_CurVal
        INTEGER_Number
        LISTBROWSER_Selected
        PALETTE_Colour
        RADIOBUTTON_Selected
        SCROLLER_Top
        SLIDER_Level
        SPEEDBAR_Selected
        STRINGA_TextVal
        TDECK_Tape
        TEXTEDITOR_Contents - Flag.

        Sollen andere Flags aufgerufen werden, so nutzen Sie bitte die
        Intuition-Funktion GetAttr() oder die Funktion @{"Emperor_GetGadgetAttrComplex()" link Func_getgadgetattrcomplex}.
        Die entsprechenden Werte werden ausgelesen und als Rückgabewert ausgegeben.

@{b} Parameter @{ub}
        Gadget - welches Gadget ausgelesen werden soll.
                 Beispiel: Checkbox3

@{b} Ergebnis @{ub}
        Die Funktion gibt das o.a. Flag des entsprechenden Gadget aus.

        ACHTUNG!! Der Rückgabewert ist vom Typ "STRPTR" (Zeichenkette).
        Die Wandlung des Wertes kann mit den Funktionen:

        @{"stringtoint()" link Func_stringtoint}
        @{"stringtofloat()" link Func_stringtofloat}
        @{"inttostring()" link Func_inttostring}

        erfolgen.

@{b} Fehler @{ub}
        Funktion gibt in Version 2.00 noch einen unbrauchbaren Wert zurück.
        Dieser Fehler ist seit Version 2.20 kompensiert.

@{b} Beispiel @{ub}
        void Checkbox3_GadgetUp_Event(void)
        {
          LONG number;
          char string[20];

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          number = stringtoint(Emperor_GetGadgetAttr(Fuelgauge2));

          strcpy(string, Emperor_GetGadgetAttr(String3));

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetGadgetAttr()" link Func_setgadgetattr}
        @{"Emperor_GetGadgetAttrComplex()" link Func_getgadgetattrcomplex}
        @{"Emperor_SetGadgetAttrComplex()" link Func_setgadgetattrcomplex}

@ENDNODE
@NODE Func_getgadgetattrcomplex "Die Funktion Emperor_GetGadgetAttrComplex"


@{b} Funktion @{ub}
        Makrofunktion für das Erhalten eines Gadget-Wertes.

@{b} Synopsis @{ub}
        result = Emperor_GetGadgetAttrComplex(GadgetObject, GadgetattrID)

        STRPTR Emperor_GetGadgetAttrComplex(struct Gadget *, ULONG);

@{b} Aktion @{ub}
        Dieses Makro benutzt die GetAttr()-Funktion der Intuition-Library.
        Im Gegensatz zu @{"Emperor_GetGadgetAttr()" link Func_getgadgetattr} muss hier
        eine konkrete Angabe eines Tags erfolgen. Dafür können jedoch alle nur
        denkbaren Werte eingesetzt werden.

        ACHTUNG !! Bitte achten Sie darauf, dass Sie die zum Gadget gehörenden Tags nutzen !

@{b} Parameter @{ub}
        Gadget          - welches Gadget ausgelesen werden soll.
                          Beispiel: Checkbox3
        GadgetattrID    - welche GadgetattrID dafür verwendet werden soll.
                          Beispiel: CHECKBOX_TextPlace

@{b} Ergebnis @{ub}
        Die Funktion gibt den Wert des Tags abhängig vom Gadget aus.

        ACHTUNG!! Der Rückgabewert ist vom Typ "STRPTR" (Zeichenkette).
        Die Wandlung des Wertes kann mit den Funktionen:

        @{"stringtoint()" link Func_stringtoint}
        @{"stringtofloat()" link Func_stringtofloat}
        @{"inttostring()" link Func_inttostring}

        erfolgen.

@{b} Beispiel @{ub}
        void Checkbox3_GadgetUp_Event(void)
        {
          LONG number;
          char string[20];

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          number = stringtoint(Emperor_GetGadgetAttrComplex(Fuelgauge2, FUELGAUGE_Min));

          strcpy(string, Emperor_GetGadgetAttrComplex(Button3, GA_Text));

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetGadgetAttr()" link Func_getgadgetattr}
        @{"Emperor_SetGadgetAttr()" link Func_setgadgetattr}
        @{"Emperor_SetGadgetAttrComplex()" link Func_setgadgetattrcomplex}

@ENDNODE
@NODE Func_getdisabled "Die Funktion Emperor_GetGadgetDisabledAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Erhalten des Gadget_Disabled-Attributes.

@{b} Synopsis @{ub}
        result = Emperor_GetGadgetDisabledAttr(GadgetObject)

        BOOL Emperor_GetGadgetDisabledAttr(struct Gadget *);

@{b} Aktion @{ub}
        Dieses Makro benutzt die GetAttr()-Funktion der Intuition-Library.
        Es wird das GA_Disabled-Flag (ob das Gadget anwählbar ist)
        des Gadgets ausgelesen und als Rückgabewert ausgegeben.

@{b} Parameter @{ub}
        Gadget - welches Gadget ausgelesen werden soll.
                 Beispiel: Button1
                           Integer3

@{b} Ergebnis @{ub}
        Die Funktion gibt das GA_Disabled-Flag des entsprechenden Gadgets wieder.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          BOOL result;
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          result = Emperor_GetGadgetDisabledAttr(Button1);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetGadgetDisabledAttr()" link Func_setdisabled}

@ENDNODE
@NODE Func_getreadonly "Die Funktion Emperor_GetGadgetReadOnlyAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Erhalten des Gadget_ReadOnly-Attributes.

@{b} Synopsis @{ub}
        result = Emperor_GetGadgetReadOnlyAttr(GadgetObject)

        BOOL Emperor_GetGadgetReadOnlyAttr(struct Gadget *);

@{b} Aktion @{ub}
        Dieses Makro benutzt die GetAttr()-Funktion der Intuition-Library.
        Es wird das GA_ReadOnly-Flag (ob das Gadget ist)
        des Gadgets ausgelesen und als Rückgabewert ausgegeben.

@{b} Parameter @{ub}
        Gadget - welches Gadget ausgelesen werden soll.
                 Beispiel: Button1
                           Integer3

@{b} Ergebnis @{ub}
        Die Funktion gibt das GA_ReadOnly-Flag des entsprechenden Gadgets wieder.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          BOOL result;
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          result = Emperor_GetGadgetReadOnlyAttr(Button1);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetGadgetReadOnlyAttr()" link Func_setreadonly}

@ENDNODE
@NODE Func_setgadgetattr "Die Funktion Emperor_SetGadgetAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen eines Gadget-Wertes.

@{b} Synopsis @{ub}
        Emperor_SetGadgetAttr(GadgetObject, Value)

        void Emperor_SetGadgetAttr(struct Gadget *, STRPTR);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetGadgetAttrs()-Funktion der Intuition-Library.
        Je nachdem, welche Art Gadget neu beschrieben werden soll, steuert diese
        Funktion, ohne zusätzliche Parameterabfrage, die Flag-Auswahl
        eigenständig. Diese Flags (und deren zugehörige Gadgets) werden
        derzeit unterstützt:

        GA_Selected             (Button, Checkbox)
        CHOOSER_Selected
        CLICKTAB_Current
        FUELGAUGE_Level
        GETFILE_FullFile
        GETFONT_TextAttr
        GETSCREENMODE_DisplayID
        GRAD_CurVal
        INTEGER_Number
        LISTBROWSER_Selected
        PALETTE_Colour
        RADIOBUTTON_Selected
        SCROLLER_Top
        SLIDER_Level
        SPEEDBAR_Selected
        STRINGA_TextVal
        TDECK_Tape
        TEXTEDITOR_Contents - Flag.

        Sollen andere Flags aufgerufen werden, so nutzen Sie bitte die
        Intuition-Funktion (SetGadgetAttrs()). Die entsprechenden Werte werden ausgelesen und
        als Rückgabewert ausgegeben.

@{b} Parameter @{ub}
        Gadget - welches Gadget ausgelesen werden soll.
                 Beispiel: Checkbox3

        Value  - Wert, wie das Flag verändert werden soll.
                 ACHTUNG!! Der Parameter ist vom Typ "STRPTR" (Zeichenkette).
                 Die Wandlung des Wertes kann mit den Funktionen:

                 @{"stringtoint()" link Func_stringtoint}
                 @{"stringtofloat()" link Func_stringtofloat}
                 @{"inttostring()" link Func_inttostring}

                 erfolgen.

@{b} Beispiel @{ub}
        void Checkbox3_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetGadgetAttr(Fuelgauge2, "23");

          Emperor_SetGadgetAttr(String3, "String");

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetGadgetAttr()" link Func_getgadgetattr}
        @{"Emperor_GetGadgetAttrComplex()" link Func_getgadgetattrcomplex}
        @{"Emperor_SetGadgetAttrComplex()" link Func_setgadgetattrcomplex}

@ENDNODE
@NODE Func_setgadgetattrcomplex "Die Funktion Emperor_SetGadgetAttrComplex"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen eines Gadget-Wertes.

@{b} Synopsis @{ub}
        Emperor_SetGadgetAttrComplex(GadgetObject, GadgetattrID, Value)

        void Emperor_SetGadgetAttrComplex(struct Gadget *, ULONG, STRPTR);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetGadgetAttrs()-Funktion der Intuition-Library.
        Im Gegensatz zu @{"Emperor_SetGadgetAttr()" link Func_setgadgetattr} muss hier
        eine konkrete Angabe eines Tags erfolgen. Dafür können jedoch alle nur
        denkbaren Werte eingesetzt werden.

        ACHTUNG !! Bitte achten Sie darauf, dass Sie die zum Gadget gehörenden Tags nutzen !

@{b} Parameter @{ub}
        Gadget          - welches Gadget ausgelesen werden soll.
                          Beispiel: Checkbox3

        GadgetattrID    - welche GadgetattrID dafür verwendet werden soll.
                          Beispiel: CHECKBOX_TextPlace

        Value  - Wert, wie das Flag verändert werden soll.
                 ACHTUNG!! Der Parameter ist vom Typ "STRPTR" (Zeichenkette).
                 Die Wandlung des Wertes kann mit den Funktionen:

                 @{"stringtoint()" link Func_stringtoint}
                 @{"stringtofloat()" link Func_stringtofloat}
                 @{"inttostring()" link Func_inttostring}

                 erfolgen.

@{b} Beispiel @{ub}
        void Checkbox3_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetGadgetAttrComplex(Fuelgauge2, FUELGAUGE_Min, "23");

          Emperor_SetGadgetAttrComplex(String3, STRINGA_MaxChars, "10");

          Emperor_SetGadgetAttrComplex(Listbrowser1, LISTBROWSER_MinVisible, "20");

          Emperor_SetGadgetAttrComplex(Listbrowser1, LISTBROWSER_Labels, (STRPTR) &Listbrowser_NewListArray);
          /***********************************************/
          /* Dies ist kein Fehler im Guide....           */
          /* Wenn Labels geändert werden sollen, dann    */
          /* ist darauf zu achten, dass Sie das Argument */
          /* mit (STRPTR) casten und so auf diesem       */
          /* Wege die Adresse (&)!! übergeben            */
          /***********************************************/


          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetGadgetAttr()" link Func_getgadgetattr}
        @{"Emperor_SetGadgetAttr()" link Func_setgadgetattr}
        @{"Emperor_GetGadgetAttrComplex()" link Func_getgadgetattrcomplex}

@ENDNODE
@NODE Func_setdisabled "Die Funktion Emperor_SetGadgetDisabledAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen des Gadget_Disabled-Attributes.

@{b} Synopsis @{ub}
        Emperor_SetGadgetDisabledAttr(GadgetObject, disable/enable)

        void Emperor_SetGadgetDisabledAttr(struct Gadget *, BOOL);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetGadgetAttrs()-Funktion der Intuition-Library.
        Es wird das GA_Disabled-Flag (ob das Gadget nicht anwählbar ist)
        des Gadgets neu beschrieben.

@{b} Parameter @{ub}
        Gadget      - welches Gadget ausgelesen werden soll.
                      Beispiel: Button1
                                Integer3
        dis/enable  - Wert, ob das Flag gesetzt oder gelöscht werden soll.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetGadgetDisabledAttr(Button1, TRUE);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetGadgetDisabledAttr()" link Func_getdisabled}

@ENDNODE
@NODE Func_setreadonly "Die Funktion Emperor_SetGadgetReadOnlyAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen des Gadget_ReadOnly-Attributes.

@{b} Synopsis @{ub}
        Emperor_SetGadgetReadOnlyAttr(GadgetObject, on/off)

        void Emperor_SetGadgetReadOnlyAttr(struct Gadget *, BOOL);

@{b} Aktion @{ub}
        Dieses Makro benutzt die SetGadgetAttrs()-Funktion der Intuition-Library.
        Es wird das GA_ReadOnly-Flag (ob das Gadget ist)
        des Gadgets neu beschrieben.

@{b} Parameter @{ub}
        Gadget - welches Gadget ausgelesen werden soll.
                 Beispiel: Button1
                           Integer3
        on/off - ob das Flag gesetzt oder gelöscht werden soll.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetGadgetReadOnlyAttr(Button1, FALSE);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetGadgetReadOnlyAttr()" link Func_getreadonly}

@ENDNODE
@NODE Func_activategad "Die Funktion Emperor_ActivateGadget"


@{b} Funktion @{ub}
        Makrofunktion für das Aktivieren eines String- oder CustomGadgets.

@{b} Synopsis @{ub}
        Emperor_ActivateGadget(GadgetObject)

        void Emperor_ActivateGadget(struct Gadget *);

@{b} Aktion @{ub}
        Beim Aufruf dieser Funktion wird ein StringGadget aktiviert und der Cursor
        in das Gadget gesetzt, so das der User sofort, ohne zu klicken, Eingaben
        machen kann. Dieses Makro nutzt die Intuition-Funktion ActivateGadget()

@{b} Parameter @{ub}
        GadgetObject - Name des Gadgets, das aktiviert werden soll.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_ActivateGadget(String3);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@ENDNODE
@NODE Func_rethinklayout "Die Funktion Emperor_RethinkLayout"


@{b} Funktion @{ub}
        Makrofunktion für das Neuzeichnen des gesamten Layouts.

@{b} Synopsis @{ub}
        Emperor_RethinkLayout(GadgetObject)

        void Emperor_RethinkLayout(struct Gadget *);

@{b} Aktion @{ub}
        Dieses Makro nutzt die LayoutGadget-Funktion RethinkLayout().
        Beim Aufruf dieser Funktion wird das gesamte Fenster neugezeichnet.
        Dabei muss beim "Refreshing" jedoch nicht die gesamte hierarchische
        Liste der Gadgets neugezeichnet werden, sondern ist als Parameter
        mit definierbar. Wird ein Name eines Gadgets angegeben, wird ab
        dieser Position in der Liste der Gadgets alle nachfolgenden Objekte
        refresht.
        Wenn alles neugezeichnet werden soll, muss GadgetObject der Wert
        "GadgetX[0]" übergeben werden, oder je nach dem, wie Sie Ihre Gadgetliste
        im Projekt-Manager genannt haben. X repräsentiert hier die Nummer des
        Fensters in der Liste im Projekt-Manager. Wichtig beim vollständigen
        Refresh ist das "[0]" hinter dem Namen der Liste. Dieser Ausdruck
        steht für das Root-Gadget, also für das erste Gadget in der Liste.

@{b} Parameter @{ub}
        GadgetObject - Name des Gadgets, ab dessen Position in der Liste der Gadgets
                       alle nachfolgenden Objekte refresht werden sollen.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_RethinkLayout(Button1);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */

          Emperor_RethinkLayout(Gadget1[0]);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} siehe auch @{ub}
        @{"Emperor_RefreshGadgets()" link Func_refreshgadget}

@ENDNODE
@NODE Func_refreshgadget "Die Funktion Emperor_RefreshGadgets"


@{b} Funktion @{ub}
        Makrofunktion für das Neuzeichnen eines einzelnen Gadgets.

@{b} Synopsis @{ub}
        Emperor_RefreshGadgets(GadgetObject, on/off)

        void Emperor_RefreshGadgets(struct Gadget *, BOOL);

@{b} Aktion @{ub}
        Dieses Makro nutzt die Intuition-Funktion RefreshGList().
        Beim Aufruf dieser Funktion wird das angegebene Gadget neugezeichnet.

@{b} Parameter @{ub}
        GadgetObject - Name des Gadgets, das refresht werden soll.
        on/off - wie viele Gadgets in der hierarchischen Liste ab dem angegebenen Gadget
                 neugezeichnet werden sollen

@{b} Beispiel @{ub}
        void Checkbox3_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_RefreshGadgets(Button2, 5);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} siehe auch @{ub}
        @{"Emperor_RethinkLayout()" link Func_rethinklayout}

@ENDNODE
@NODE Func_getmenuitem "Die Funktion Emperor_GetMenuItemAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Erhalten eines Menüeintrag-Attributes.

@{b} Synopsis @{ub}
        result = Emperor_GetMenuItemAttr(MenuObject, MenuattrID)

        BOOL Emperor_GetMenuItemAttr(UBYTE, UWORD);

@{b} Aktion @{ub}
        Die Funktion erfragt den aktuellen Zustand der Attribute von Menüeinträgen.
        Es kann z.B. erfragt werden, ob ein Eintrag mit Checkit-Eigenschaften
        (angewählt, wenn das Check-Image (links ein kleiner Haken) zu sehen ist)
        angewählt ist oder nicht.

@{b} Parameter @{ub}
        MenuObject   - Dieser Parameter gibt den Namen des Menü-Objektes an,
                       der bei der Erstellung des Menüs angegeben werden kann.
                       Diese Lösung ist sehr vorteilhaft, denn die Verwaltung
                       von Menüs und deren ID-Nummern ist recht kompliziert
                       für Einsteiger. Auch ist es bei falschen Parametern durchaus
                       möglich, dass der Rechner abstürzt.
        MenuFlagmask - Dieser Parameter erwartet eine von den folgenden drei Masken,
                       die angeben sollen, welches Attribut erfragt werden soll:
                        * ITEMENABLED (ob der Eintrag anwählbar ist)
                        * MENUTOGGLED (für MutualExclude oder Checkit; erfragt,
                                       ob der Eintrag gewechselt wurde)
                        * CHECKED     (für MutualExclude oder Checkit; erfragt,
                                       ob der Eintrag angewählt ist)

@{b} Ergebnis @{ub}
        Das Ergebnis ist eine Variable vom Typ BOOL (wahr/falsch-Aussage).
        result = TRUE (wahr), wenn das ausgewählte Attribut gesetzt ist; ansonsten
        ist das Ergebnis result = FALSE (falsch).

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          BOOL boolean;

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          boolean = Emperor_GetMenuItemAttr(Menu_ItemCheckit, CHECKED);
          if(boolean) printf("Der Menü-Eintrag ist mit einem Haken angewählt");
          else printf("Der Menü-Eintrag hat keinen Haken");

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_SetMenuItemAttr()" link Func_setmenuitem}

@ENDNODE
@NODE Func_setmenuitem "Die Funktion Emperor_SetMenuItemAttr"


@{b} Funktion @{ub}
        Makrofunktion für das Setzen eines Menüeintrag-Attributes.

@{b} Synopsis @{ub}
        Emperor_SetMenuItemAttr(MenuObject, MenuattrID, Set/Reset)

        void Emperor_SetMenuItemAttr(UBYTE, UWORD, BOOL);

@{b} Aktion @{ub}
        Die Funktion kann den aktuellen den Zustand der Attribute von Menüeinträgen
        verändern. Es kann z.B. ein Eintrag mit Checkit-Eigenschaften
        (angewählt, wenn das Check-Image (links ein kleiner Haken) zu sehen ist)
        angewählt werden oder einen Menüeintrag unanwählbar (disabled) machen.

@{b} Parameter @{ub}
        MenuObject   - Dieser Parameter gibt den Namen des Menü-Objektes an,
                       der bei der Erstellung des Menüs angegeben werden kann.
        MenuFlagmask - Dieser Parameter erwartet eine von den folgenden zwei Masken,
                       die angeben sollen, welches Attribut gesetzt werden soll:
                        * ITEMENABLED (macht den Eintrag nicht anwählbar)
                        * CHECKED (für MutualExclude oder Checkit; wählt einen Eintrag an)
        Set/Reset    - Gibt an, ob die Maske gesetzt oder gelöscht werden soll.

@{b} Beispiel @{ub}
        void Integer1_GadgetUp_Event(void)
        {
          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_SetMenuItemAttr(Menu_ItemCheckit, CHECKED, FALSE);
          Emperor_SetMenuItemAttr(Menu_ItemCheckit, ITEMENABLED, TRUE);

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} Siehe auch @{ub}
        @{"Emperor_GetMenuItemAttr()" link Func_getmenuitem}

@ENDNODE
@NODE Func_quit "Die Funktion Emperor_QuitProgram"


@{b} Funktion @{ub}
        Makrofunktion für das Verlassen des Programms.

@{b} Synopsis @{ub}
        Emperor_QuitProgram()

        void Emperor_QuitProgram(void);

@{b} Aktion @{ub}
        Beim Aufruf dieser Funktion werden alle zuvor geöffneten Libraries etc.
        wieder geschlossen. Das bedeutet, geschlossen werden:
                * Libs
                * Catalog
                * geöffnete Fenster
                * allokierte Speicherbereiche für ASL-Requester, Menüs und sonstige.
        Vor Aufruf dieser Funktion müssen die Fenster nicht geschlossen werden !

@{b} Beispiel @{ub}
        void Menu_Copy1_MenuPick_Event(void)
        {
          BOOL error;

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          Emperor_QuitProgram();

          /*

          Ende

          */
        }

@ENDNODE
@NODE Func_stringtoint "Die Funktion stringtoint"


@{b} Funktion @{ub}
        Diese Funktion wandelt Zeichen vom Typ STRPTR (=Zeichenkette) in
        Integers (LONG = 32-Bitzahl) um.

@{b} Synopsis @{ub}
        result = stringtoint(string)

        LONG stringtoint(STRPTR);

@{b} Aktion @{ub}
        Diese Funktion konvertiert eine Zeichenkette vom Typ STRPTR
        (=Zeichenkette) in eine Integer (LONG = 32-Bitzahl) um.
        Dabei werden die einzelnen Zeichen der Zeichenkette der
        Reihenfolge nach ausgelesen und in die Integervariable geschrieben.
        Die Funktion ist ab Version 4.2 nur noch eine reine
        Wertübergabe an "atol()"

        Sie ist für die Umwandlung in Funktionen wie

        @{"Emperor_GetGadgetAttr" link Func_getgadgetattr}
        @{"Emperor_SetGadgetAttr" link Func_setgadgetattr}
        @{"Emperor_GetGadgetAttrComplex" link Func_getgadgetattrcomplex}
        @{"Emperor_SetGadgetAttrComplex" link Func_setgadgetattrcomplex}

        gedacht.

@{b} Parameter @{ub}
        string - umzuwandelnde Zeichenkette

@{b} Beispiel @{ub}
        void Menu_Cut1_MenuPick_Event(void)
        {
          LONG number;
          char *string = "-123456789";

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          number = stringtoint(string); /* !! number = -123456789 !! */

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} siehe auch @{ub}
        @{"stringtofloat()" link Func_stringtofloat}
        @{"inttostring()" link Func_inttostring}

@ENDNODE
@NODE Func_stringtofloat "Die Funktion stringtofloat"


@{b} Funktion @{ub}
        Diese Funktion wandelt Zeichen vom Typ STRPTR (=Zeichenkette) in
        Fließkommazahlen (FLOAT = 64-Bitzahl) um.

@{b} Synopsis @{ub}
        result = stringtofloat(string)

        FLOAT stringtofloat(STRPTR);

@{b} Aktion @{ub}
        Diese Funktion konvertiert eine Zeichenkette vom Typ STRPTR
        (=Zeichenkette) in eine Fließkommazahl (FLOAT = 64-Bitzahl) um.
        Dabei werden die einzelnen Zeichen der Zeichenkette der
        Reihenfolge nach ausgelesen und in die Fließkomma-Variable
        geschrieben. Die Funktion ist ab Version 4.2 nur noch eine reine
        Wertübergabe an "atof()"

        Sie ist für die Umwandlung in Funktionen wie

        @{"Emperor_GetGadgetAttr" link Func_getgadgetattr}
        @{"Emperor_SetGadgetAttr" link Func_setgadgetattr}
        @{"Emperor_GetGadgetAttrComplex" link Func_getgadgetattrcomplex}
        @{"Emperor_SetGadgetAttrComplex" link Func_setgadgetattrcomplex}

        gedacht.

@{b} Parameter @{ub}
        string - umzuwandelnde Zeichenkette

@{b} Beispiel @{ub}
        void Menu_Paste1_MenuPick_Event(void)
        {
          FLOAT number;
          char *string = "-123.456789";

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          number = stringtofloat(string); /* !! number = -123.456789 !! */

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} siehe auch @{ub}
        @{"stringtoint()" link Func_stringtoint}
        @{"inttostring()" link Func_inttostring}

@ENDNODE
@NODE Func_inttostring "Die Funktion inttostring"


@{b} Funktion @{ub}
        Diese Funktion wandelt Zahlen vom Typ Integer (LONG = 32-Bitzahl)
        in Zeichenketten um.

@{b} Synopsis @{ub}
        result = inttostring(number[, buffer])

        STRPTR inttostring(LONG[, STRPTR]);

@{b} Aktion @{ub}
        Diese Funktion konvertiert eine Zahl im Bereich von -2147483648
        bis 2147483647 in eine Zeichenkette (= STRPTR).
        Sie ist für die Umwandlung in Funktionen wie

        @{"Emperor_GetGadgetAttr" link Func_getgadgetattr}
        @{"Emperor_SetGadgetAttr" link Func_setgadgetattr}
        @{"Emperor_GetGadgetAttrComplex" link Func_getgadgetattrcomplex}
        @{"Emperor_SetGadgetAttrComplex" link Func_setgadgetattrcomplex}

        gedacht.

@{b} Parameter @{ub}
        number - umzuwandelnde Zahl
        buffer - Bereich, in dem das Ergebnis gespeichert wird

@{b} Beispiel @{ub}
        void Menu_Paste1_MenuPick_Event(void)
        {
          char string[12];

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          strcpy(string, (char *) inttostring(-1234567890));

          inttostring(-1234567890, string);  /* dies ist die überladene Funktion (seit Emperor v4.3)         */
                                             /* es ist sicherer diese, anstatt der alten, Funktion zu nutzen */
          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@{b} siehe auch @{ub}
        @{"stringtoint()" link Func_stringtoint}
        @{"stringtofloat()" link Func_stringtofloat}

@ENDNODE
@NODE Func_stringlength "Die Funktion stringlength"


@{b} Funktion @{ub}
        Diese Funktion gibt die Länge einer Zeichenkette aus.

@{b} Synopsis @{ub}
        result = stringlength(string)

        ULONG stringlength(STRPTR);

@{b} Parameter @{ub}
        string - Zeichenkette, deren Länge bestimmt werden soll

@{b} Beispiel @{ub}
        void Menu_Delete1_MenuPick_Event(void)
        {
          ULONG result;

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          result = stringlength("Hallo"); /* result = 5 */

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@ENDNODE
@NODE Func_stringtoupper "Die Funktion stringtoupper"


@{b} Funktion @{ub}
        Diese Funktion gibt die Zeichenkette in Großbuchstaben wieder aus.

@{b} Synopsis @{ub}
        result = stringtoupper(string)

        STRPTR stringtoupper(STRPTR);

@{b} Parameter @{ub}
        string - Zeichenkette, die in Großbuchstaben umgewandelt werden soll

@{b} Beispiel @{ub}
        void Menu_Delete1_MenuPick_Event(void)
        {
          STRPTR result;

          /*
          ... Abzuarbeitender Quelltext ...
          ...
          ...
          ...
          */

          result = stringtoupper("Hallo"); /* result = "HALLO" */

          /*
          ...
          ...
          ...
          ... weiterführender Quelltext ...
          */
        }

@ENDNODE
@NODE History "Die Geschichte"


@{b}2.0@{ub}  - Erste Veröffentlichung

@{b}2.1@{ub}  - AmigaOS 2.0 Gadgets hinzugefügt !!
       (GadTools-Gadgets sind nun verfügbar !)
     - Programm ist durch Code-Umsetzung von ReActor nach eigenem Code geschrumpft.

@{b}2.2@{ub}  - Programmabsturz, wenn Clicktab-Gadgets in einem Test-Fenster waren.
     - Geschwindigkeitsoptimierungen (z.B. beim Start, Ende etc.)
     - definierte Catalog-Erstellung
     - Makro "Preferences-Menü" für Einstellungs-Programme
     - C++-Quelltext Unterstützung
     - besserer & einfacherer generierter C-Quelltext
     - minimale Fehler behoben

@{b}2.3@{ub}  - Prefs-Editor überarbeitet
     - wählbarer Prozessortyp für generierten StormC-Projekt
     - modifizierte Programmierhilfe
     - diverse Funktionsmakros überarbeitet
     - minimale Fehler behoben

@{b}3.0@{ub}  - Gadget-Test Routine überarbeitet
     - Fehler beim Anzeigen von Tapedeck & Colorwheel Gadgets behoben
     - Probleme mit Clicktabs & Page Gadgets behoben (siehe "clicktabsexample")
     - Funktion "Shutdown()" hinzugefügt (Aufruf, bei Programmende)
     - Fortschrittsanzeige während des Speicherns
     - Makrofunktion @{"Emperor_Set/GetGadgetAttrComplex()" link Func_setgadgetattrcomplex} hinzugefügt

@{b}3.1@{ub}  - Fehler beim Quelltextgenerieren mit ColorWheels behoben
     - Quelltext ist nun SAS/C freundlich*er*
     - Fehler beim Kopieren einer Funktion von der Programmierhilfe in den Texteditor behoben
     - Online Hilfe für Makrofunktionen hinzugefügt (siehe Kapitel @{"Programmierhilfe" link ProgHelpwin})
     - ARexx-Verbindung zu StormC (Scripts - Verzeichnis)
     - Argumente beim Starten von StormC hinzugefügt (z.B. GoldED support für StormC)
     - Ladebild hinzugefügt

@{b}3.2@{ub}  - diverse Image-Gadgets (Bevel, Bitmap, Glyph) hinzugefügt
       (siehe "ClicktabExample" für Einzelheiten)
     - Fehler mit Slider und Getfile-Gadgets behoben
     - Problem mit dem Requester-Body-Text behoben ["\n" (Newline) wird nun berücksichtigt]
     - Routine für hinzufügen, verschieben (hoch und runter) und löschen von Objekten
       in den Listen überarbeitet

@{b}3.5@{ub}  - Anzeigen des Scroller & Slider-Gadgets ist überarbeitet worden
     - Layout-Gadget (BevelStyle & -State) springt nicht mehr zu zuvor eingestellten
       Werten zurück
     - Finnischen Katalog hinzugefügt
     - Programmumgebung zur Konfiguration von Version, Programmnamen, Stack, Speicher
       und vielem, vielem mehr hinzugefügt
     - löschen von Fenstern ist nun möglich
     - wenn Pages hinzugefügt wurden, waren deren Generationen inkorrekt
     - GadgetHelp hinzugefügt - einfach ein Gadget verbinden, um die GadgetHelp zu
       konfigurieren ! (Programmumgebung)
     - Funktion <Menü-Bearbeiten-Liste löschen> für das Zurücksetzen der aktiven Liste von
       Objekten hinzugefügt
     - Label's Locale-Verbindung arbeitet nun korrekt
     - GadgetHelp für beinahe jedes Gadget
     - wählbarer HookType für String-Gadgets
     - diverse Initial-konfigurationen für Texteditor-Gadgets hinzugefügt
     - verschieben von Locale-Einträgen ist nun möglich
     - editieren der Includeliste ist nun möglich
     - neues Startupbild hinzugefügt (Dank an Janne Peräaho)

@{b}3.6@{ub}  - Gradientsliders horiz/vert Ausrichtung arbeitet nun korrekt
     - einige Probleme mit globalen Variablen behoben
     - Probleme mit Node-Arrays behoben
     - spezielle Positionen/Größen für OS 2.0 Fenster arbeiten nun korrekt
     - wählbarer Smallfont für komplexe Listen (Texteditor/Programmierhilfe)
     - Fehler behoben beim verschieben vom Vorschaufenster
     - veränderbare Library-Integration für das eigene Projekt
     - Fehler behoben im Installer-Skript (arbeitet jetzt mit OS-Versionen >3.5 zusammen)
     - Interconnection Maps hinzugefügt (Verknüpfung von Gadgets)
     - Quelltextgenerierung auf Basis von AmigaOS 2.0, AmigaOS 3.5+ oder gemischt

@{b}4.0@{ub}  - GESCHAFFT ! der gesamte Quelltext ist neugeschrieben, strukturiert und überarbeitet !!
       nur noch 4 MBytes Systemspeicher sind für den Start von Emperor notwendig !
     - der Programmfluss hat sich teilweise geändert, weil auch alle low-level Funktionen
       neugeschrieben wurden.
     - neuer Look
     - komplexeres und professionelleres Menü
     - erweitertes GadTools-handling (mit RechtemMausButton)

@{b}4.1@{ub}  - französischen Katalog hinzugefügt (geschrieben von Olivier Martin -- besten Dank !)
     - Übersetzungen für vorgefertigte Menüs und Gadgets hinzugefügt
     - Attribute für Texteditor-, Speedbar- und Space-gadget hinzugefügt
     - neuer spezieller Requestertyp (im Reaction-Stil)
     - ARexx-Skript verändert/Probleme während des Transfers von Projekten beseitigt
     - fixe Positionen für Attribut-Fenster beseitigt
     - Problem mit Vorschau-Menü behoben
     - Array für Speedbar-Buttons hinzugefügt
     - Probleme mit Arrays beseitigt
     - Justierungsflächen um GadTools-Gadgets vergrößert
     - Pfad zu Includes und Libs konfigurierbar
     - Layout des Hauptfensters verändert (keine überlappenden Gadgets mehr)
     - Requester hinzugefügt, wenn Menüpunkt "Neu" gewählt wird
     - Fehler im Menüpunkt "Neu" behoben
     - Fehler im Menüpunkt "Löschen" behoben
     - wählbare Makrofunktionsgenerierung
     - generierter Quelltext durch Herauslassen unbenutzter Makrofunktionen und Restrukturierung
       wesentlich kleiner (ca. 40 %)
     - initial geöffnetes Fenster für eigenes Projekt wählbar
     - Fehler im generierten Quelltext bei nur einem Gadget beseitigt
     - spezifische Projekt-Verzeichnisse erstellbar
     - Fehler während des Öffnens alter Projekte, die einen Slider enthielten, behoben
     - Erstellung von Locale-dateien wählbar
     - Erstellung von Storm-projekten wählbar
     - Texteditor verarbeitet Änderungen nun korrekt
     - speichern von Zeichenketten mit einem linefeed ('\n') ist kein Problem mehr
     - amigaguide.library wegen Startschwierigkeiten geöffnet

@{b}4.2@{ub}  - Objekttabelle ausdrucken ist nun möglich
     - Ausschneiden/Kopieren/Einfügen für Gadgetlisten funktioniert
     - kein Konflikte mit Projekten, die mehere Fenster beinhalten
     - Probleme mit dem Quelltext von Projekten, die mehere Fenster beinhalten behoben
     - Funktion "inttostring" überarbeitet und verkürzt
     - Reaction-Gadgetlisten und Menüliste sind nun tatsächlich hierarchisch (unterstützt hiding und showing)
     - Support für Sprachen bosanski, català, czech, polski, russian, slovensko, srpski and türkçe hinzugefügt
     - Übersetzungen für alle vorgefertigten Menüs hinzugefügt (alle Sprachen)
     - vordefinierte Texte von Requester und ASL-Requester in alle unterstützten Sprachen übersetzt
     - erweitertes, vordefiniertes Menü "Preferences" hinzugefügt
     - Online-Hilfe für alle Programmbereiche und Fenster
     - völlig überarbeitete Guide-dateien
     - Screens-Array mit Vorschau
     - neues Fensterattribut: BackFill (Datei)
     - neues Fensterattribut: Screen
     - neues Bitmapattribut: Screen
     - neues Requesterattribut: Screen
     - überarbeitetes Design des Fensterattribut-Fensters
     - Arrayattribute auf einem Fenster vereinigt
     - Probleme mit InterConnection Maps beseitigt
     - neue Programmumgebungsvariable: Initial geöffneter Screen
     - Makrofunktionen für öffnen/schließen von Screens hinzugefügt
     - wählbare Taskpriorität
     - *.h-Datei in die Stormprojekt-Datei berücksichtigt
     - Stormprojekt-Datei Objektverzeichnis als "StormC:Objects"
     - Übergabe von Funktionen an Texteditor ist nun voreinstellbar
     - Löschen von Objekten mit abschaltbarer Sicherheitsabfrage
     - Template-projekt als ein Ersatz für initial eingebaute Objekte
     - lowlevel-Probleme beseitigt (beim ICMap-generieren und in der Programmierhilfe)
     - beim Speichern auftretende Probleme mit anhängendem "*.project" beseitigt
     - Probleme während des Speicherns in Verzeichnisse beseitigt
     - Button "Bearbeiten" ins Hauptfenster für öffnen/schließen des Attributfensters hinzugefügt
     - Button "Hinzufügen" ist für falsche Zugriffe auf der Reactionseite gesperrt
     - Doppelklick "Mitte" öffnet Attributfenster
     - Library Attributfenster arbeitet nun korrekt
     - Variable Attributfenster mit neuem Verhalten beim akzeptieren von Werten
     - Catalog- und VisualInfo-variablen konfigurierbar
     - Buttons im Hauptfenster bleiben nicht mehr selekiert
     - "Vorschau"- und "Bearbeiten"-Button mit Klammern versehen
     - keine falschen laufenden Nummern hinter verdefinierten Namen mehr
     - keine Notwendigkeit eines "Emperor:"-Assigns mehr
     - Probleme mit Startfortschrittsanzeige behoben
     - Fortschrittsanzeige beim Öffnen von Projekten
     - Funktionen auf Speichersparen getrimmt
     - Vorschau der Getfile-Gadgets überarbeitet
     - neue Mousebutton Events für: - Doppelklick links & mitte;
                                    - links, mitte, rechts in allen Fällen mit gedrückt & losgelassen
     - neue Attribute in Get/SetGadgetAttr(): - GETFILE_FullFile
                                              - GETFONT_TextAttr
                                              - GETSCREENMODE_DisplayID
                                              - und TDECK_Tape

@{b}4.3@{ub}  - Reaction basierte PopupMenüs
     - Bug in der GadgetHelp im Layout-Attributfenster behoben
     - Array Probleme behoben
     - beachtet CatalogIDs beim hinzufügen
     - Konflikte mit der Rundung der HSMathLibs umgangen
     - Workbench-Start Probleme mit dem initialen Projektverzeichnis behoben
     - merkt sich alle Fensterpositionen
     - neue, überladene inttostring-Funktion
     - Komponentenauswahl während des Öffnens
     - Anhängen von Projekten verursacht keine Probleme mehr
     - unterstützt CyberGraphX und Picasso96 Screens
     - kleinere Fehler behoben

@{b}4.5@{ub}  - MultiMenü; für jedes Fenster ein eigenes Pulldown-Menü
     - Beschriftung fensterabhängiger Listen (Gadgets und Menü)
     - Überprüfung von Projekten auf logische Fehler
     - Drag'n'Drop von Objekten implementiert
     - volle StormC v4-Unterstützung
     - Kategorie ToolTypes hinzugefügt
     - generieren von Installskripts implementiert
     - Hauptfenster in kleinerem Modus anzeigbar
     - Probleme mit Array-Fenster behoben
     - alle Listen durch Tastatur steuerbar
     - erweitere Einstellungsmöglichkeiten hinzugefügt
     - Nachrichtenbehandlung als hierarchische Liste
     - eigener Screen für Emperor wählbar
     - Probleme mit Previewfenster behoben
     - Projekt-Öffnen-Routinen optimiert
     - Fehler im generierten Source behoben
     - Fortschrittsanzeigen überarbeitet
     - einige Makrofunktionen optimiert
     - generierten Source optimiert
     - Icons für alle Dateien erzeugbar
     - volle AmigaOS3.9-Unterstützung
     - erweiterte Funktionen im Attributfenster
     - verbesserte Programmierhilfe
     - neue Texteditorfunktionen
     - verbesserte Online-Hilfe
     - erweitertes GadgetHelp
     - Initialisierungsfunktionen optimiert
     - kleine Fehler behoben

@ENDNODE
@NODE Faq "FAQ"


@{b}Frage:@{ub}   Wenn ich die Größe von GadTools-Gadgets verändern will, ist die Umrandung für das
         aktivierte Gadget nicht oder kaum noch zu erkennen.

@{b}Antwort:@{ub} Höchstwahrscheinlich nutzen Sie ein Programm wie VisualPrefs, welches die Darstellung
         von GadTools-Gadgets verändert. Wenn Sie es deaktivieren, sollte es wieder funktionieren.
         Sie können aber auch einfach, die Ränder der "String"- und "Integer"-Gadgets wieder
         auf Normalgröße bringen, was denselben Effekt hat.


@{b}Frage:@{ub}   Emperor startet auf meinem System nicht !

@{b}Antwort:@{ub} Es müssen diverse Dinge gewährleistet sein:
         * AmigaOS 3.5 installiert ?
         * vom Systemspeicher müssen mehr als 4 MBytes frei sein
         * Assign auf <PFAD>:Emperor
         * RexxMast gestartet ?
         * Stack auf mehr als 50000 Bytes eingestellt ?
           - unter CLI:  'stack 50000' eintippen
           - unter WB:   in den Piktogramminformationen einen Stack von >50000 Bytes einstellen
           - unter DOpus:in Menü 'Einstellungen-Umgebung' den Punkt CLI-Start anwählen und
                         Stack ändern !
         Eigentlich sollte zu jedem dieser Fehler aber ein Fehlerfenster erscheinen


@{b}Frage:@{ub}   Im Vorschaufenster werden keine Labels und Bitmaps angezeigt !

@{b}Antwort:@{ub} Das ist noch eine Kinderkrankheit Emperors, aber ich arbeite an diesem Problem !

@ENDNODE
@NODE Bugs "bekannte Fehler & zukünftige Pläne"


@{b}bekannte Fehler des Programms:@{ub}

       1. Das Attributfenster "Datebrowser" kann schriftartbedingt viel zu breit sein ! (nur warum .... ?)

       2. Labels und Bitmaps werden im Vorschaufenster nicht angezeigt.

       3. CHILD_xx-Tags beim generieren des Quelltextes nicht immer an der richtigen Stelle


@{b}zukünftige Pläne:@{ub}

       1. Undo/Redo der Listen soll verfügbar sein.

       2. Clips speichern funktioniert noch nicht richtig. (deaktiviert)

       3. Text bzw. Zeilenformatierung funktioniert nicht.

       4. Unterstützung externer Editoren

       5. Auslagerung des Generators

       6. Commodity-Unterstützung

@ENDNODE
@NODE Autor "Der Autor"


Falls es irgendwelche Verbesserungsvorschläge gibt oder sich Schwierigkeiten
mit dem Programm ergeben sollten, bitte an mich wenden.


@{b}Die Adresse des Autors:@{ub}

Matthias Gietzelt
Ringstraße 41
19069 Hundorf
Deutschland



@{b}eMail:@{ub}

shamane@gmx.net

@ENDNODE
@NODE Thanx "Danksagungen"


Ich möchte mich sehr bei Janne Peräaho für sein hübsches Startupbild bedanken.
Ebenso für seine Fehlerberichte um existente Fehler in Emperor zu beseitigen.
- Danke Janne !

Ebenfalls bedanken möchte ich mich bei Olivier Martin, der mich auf diverse Fehler
hingewiesen und ein Beispielprojekt mit Emperor kreiert hat. Das Beispielprojekt
trägt den Namen "Tiger" und ist im "Projects"-Verzeichnis Emperors zu finden.
- Danke Olivier !

Außerdem geht ein riesiges "Dankeschön" an Gerd Frank, der mir mit guten Vorschlägen
sehr bei der Entwicklung und der Fehlerbehebung geholfen hat. Ein Großteil der Features
der Version 4.2 gehen auf sein Konto (und auf seine Ideen) zurück.
- Danke Gerd !


Ich möchte mich auch bei allen anderen 'Fehlermeldern' für die gründliche Benutzung
Emperors bedanken !!

@ENDNODE
