/*
**	This source code was generated by Emperor
**	©2000-2002,Matthias Gietzelt
**	Ported to AmigaOS4 and maintained by
**	Vicente 'Ami603' Gimeno
*/

#define ALL_REACTION_CLASSES
#define ALL_REACTION_MACROS
#define __USE_INLINE__

#define TapeDeckObject   NewObject(NULL, "tapedeck.gadget"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <proto/asl.h>
#include <proto/dos.h>
#include <proto/exec.h>
#include <proto/gadtools.h>
#include <proto/graphics.h>
#include <proto/intuition.h>
#include <proto/locale.h>
#include <proto/utility.h>
#include <proto/wb.h>
#include <proto/colorwheel.h>
#include <proto/datebrowser.h>
#include <libraries/resource.h>
#include <proto/texteditor.h>
#include <gadgets/colorwheel.h>
#include <gadgets/datebrowser.h>
#include <gadgets/gradientslider.h>
#include <gadgets/tapedeck.h>
#include <gadgets/texteditor.h>
#include <proto/texteditor.h>
#include <reaction/reaction.h>
#include <intuition/icclass.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <workbench/startup.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <proto/asl.h>
#include <proto/dos.h>
#include <proto/exec.h>
#include <proto/gadtools.h>
#include <proto/graphics.h>
#include <proto/icon.h>
#include <proto/intuition.h>
#include <proto/locale.h>
#include <proto/utility.h>
#include <proto/wb.h>
#include <proto/colorwheel.h>
#include <proto/datebrowser.h>
#include <libraries/resource.h>
#include <proto/texteditor.h>
#include <gadgets/colorwheel.h>
#include <gadgets/datebrowser.h>
#include <gadgets/gradientslider.h>
#include <gadgets/tapedeck.h>
#include <gadgets/texteditor.h>
#include <proto/texteditor.h>
#include <reaction/reaction.h>
#include <intuition/icclass.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <workbench/startup.h>

enum
{
	GID_Layout_Root = 0,
	GID_Layout1,
	GID_Layout_General,
	GID_Checkbox_MemProt,
	GID_Checkbox_NoPPC,
	GID_Checkbox_EarlyTerm,
	GID_Layout_PowerUp,
	GID_Chooser_Terminator,
	GID_Checkbox_HideWarn,
	GID_Checkbox_NoPatch,
	GID_Layout2,
	GID_Layout_VideoAddress,
	GID_Chooser_AddressHandling,
	GID_String_Address,
	GID_Layout_Debugging,
	GID_Chooser_DebuggerHandling,
	GID_Checkbox_Segmentinfo,
	GID_Layout_Logdata,
	GID_Getfile_CrashFile,
	GID_Label_Crash,
	GID_Getfile_AlertFile,
	GID_Label_Alert,
	GID_Space1,
	GID_Layout_Button,
	GID_Button_Save,
	GID_Space2,
	GID_Button_Use,
	GID_Space3,
	GID_Button_Break,
	GID_LAST
};

enum
{
	OID_WindowObject1 = 0,
	OID_LAST
};

enum
{
	WID_Window1 = 0,
	WID_LAST
};

struct Screen *Screen1 = NULL;

struct Window	*win[WID_LAST];
Object		*obj[OID_LAST];
struct Gadget	*gad[GID_LAST];

#define LOCALE_TITLE_WINDOW1 (STRPTR) GetCatalogStr(Catalog, 0, "Window")
#define LOCALE_TITLE_WINDOWSCREEN1 (STRPTR) GetCatalogStr(Catalog, 1, "Workbench Screen")
#define LOCALE_TITLE_WINDOWICONIFIED1 (STRPTR) GetCatalogStr(Catalog, 2, "Iconified")
#define LOCALE_WINDOW_TITLE1 (STRPTR) GetCatalogStr(Catalog, 3, "WarpOS")
#define LOCALE_SCREEN_TITLE1 (STRPTR) GetCatalogStr(Catalog, 4, "Workbench Screen")
#define LOCALE_ICONIFIED_TITLE1 (STRPTR) GetCatalogStr(Catalog, 5, "WarpOS Icon")
#define LOCALE_GENERAL (STRPTR) GetCatalogStr(Catalog, 6, "General")
#define LOCALE_MEMPROT (STRPTR) GetCatalogStr(Catalog, 7, "Memory Protection")
#define LOCALE_NOPPC (STRPTR) GetCatalogStr(Catalog, 8, "PPC available")
#define LOCLE_EARLYTERM (STRPTR) GetCatalogStr(Catalog, 9, "Early Term")
#define LOCALE_POWERUP (STRPTR) GetCatalogStr(Catalog, 10, "PowerUp")
#define LOCALE_LOGDATA (STRPTR) GetCatalogStr(Catalog, 11, "Logdata")
#define LOCALE_VIDEOADDRESS (STRPTR) GetCatalogStr(Catalog, 12, "Videoaddress")
#define LOCALE_DEBUGGING (STRPTR) GetCatalogStr(Catalog, 13, "Debugging")
#define LOCALE_HIDEWARN (STRPTR) GetCatalogStr(Catalog, 14, "Hide Warning")
#define LOCALE_NOPATCH (STRPTR) GetCatalogStr(Catalog, 15, "No Patch")
#define LOCALE_SEGMENTINFO (STRPTR) GetCatalogStr(Catalog, 16, "Segmentinfo")
#define LOCALE_CRASH (STRPTR) GetCatalogStr(Catalog, 17, "Crash")
#define LOCALE_ALERT (STRPTR) GetCatalogStr(Catalog, 18, "Alert")
#define LOCALE_SAVE (STRPTR) GetCatalogStr(Catalog, 19, "_Save")
#define LOCALE_USE (STRPTR) GetCatalogStr(Catalog, 20, "_Use")
#define LOCALE_BREAK (STRPTR) GetCatalogStr(Catalog, 21, "_Break")
#define LOCALE_MENU_PROJECT1 (STRPTR) GetCatalogStr(Catalog, 22, "Project")
#define LOCALE_MENU_QUIT1 (STRPTR) GetCatalogStr(Catalog, 23, "Quit")
#define LOCALE_MENU_EDIT1 (STRPTR) GetCatalogStr(Catalog, 24, "Edit")
#define LOCALE_MENU_RESETDEFAULT1 (STRPTR) GetCatalogStr(Catalog, 25, "Reset To Defaults")
#define LOCALE_MENU_LASTSAVED1 (STRPTR) GetCatalogStr(Catalog, 26, "Last Saved")
#define LOCALE_MENU_RESTORE1 (STRPTR) GetCatalogStr(Catalog, 27, "Restore")
#define LOCALE_REQUEST_QUIT_TITLE1 (STRPTR) GetCatalogStr(Catalog, 28, "Program request")
#define LOCALE_REQUEST_QUIT_BODY1 (STRPTR) GetCatalogStr(Catalog, 29, " Do you really want to quit this program ?")
#define LOCALE_REQUEST_QUIT_GADGET1 (STRPTR) GetCatalogStr(Catalog, 30, "Okay|No")
#define LOCALE_ASL_FILEREQ_TITLE1 (STRPTR) GetCatalogStr(Catalog, 31, "Output-file at crash")
#define LOCALE_ASL_FILEREQ_TITLE2 (STRPTR) GetCatalogStr(Catalog, 32, "Output-file at alert")
#define LOCALE_TERM_OFF_ARRAY (STRPTR) GetCatalogStr(Catalog, 33, "Terminator off")
#define LOCALE_TERM_1_ARRAY (STRPTR) GetCatalogStr(Catalog, 34, "Terminator 1 ")
#define LOCALE_TERM_2_ARRAY (STRPTR) GetCatalogStr(Catalog, 35, "Terminator 2 ")
#define LOCALE_VIDEO_IGNORE_ARRAY (STRPTR) GetCatalogStr(Catalog, 36, "ignore address")
#define LOCALE_VIDEO_FALLBACK_ARRAY (STRPTR) GetCatalogStr(Catalog, 37, "fallback address")
#define LOCALE_VIDEO_ALWAYS_ARRAY (STRPTR) GetCatalogStr(Catalog, 38, "use address always")
#define LOCALE_DEBUG_NO_ARRAY (STRPTR) GetCatalogStr(Catalog, 39, "no debugging")
#define LOCALE_DEBUG_LEVEL_1_ARRAY (STRPTR) GetCatalogStr(Catalog, 40, "debuglevel 1")
#define LOCALE_DEBUG_LEVEL_2_ARRAY (STRPTR) GetCatalogStr(Catalog, 41, "debuglevel 2")
#define LOCALE_DEBUG_LEVEL_3_ARRAY (STRPTR) GetCatalogStr(Catalog, 42, "debuglevel 3")

#define Menu_Project1 65504
#define Menu_Quit1 63488
#define Menu_Edit1 65505
#define Menu_ResetToDefaults1 63489
#define Menu_LastSaved1 63521
#define Menu_Restore1 63553
LONG Quitrequest1(void);
STRPTR GetFile1_Filerequest(void);
STRPTR GetFile2_Filerequest(void);
void Getfile_CrashFile_GadgetUp_Evt(void);
void Getfile_AlertFile_GadgetUp_Evt(void);
void Window1_CloseWindow_Evt(void);
void Ep_InitProgram(void);
void Ep_QuitProgram(void);

void Ep_AllocChooserNode(struct List *, char **, WORD *);
void Ep_AllocClicktabNode(struct List *, char **, WORD *);
void Ep_AllocListbrowserNode(struct List *, char **, WORD *);
void Ep_AllocRadiobuttonNode(struct List *, char **, WORD *);

void Ep_CloseScreen_Screen1(void);
struct Screen *Ep_OpenScreen_Screen1(void);
void Ep_CloseWindow_Window1(void);
struct Window *Ep_OpenWindow_Window1(void);

LONG stringtoint(STRPTR);
STRPTR inttostring(LONG);
const char VERSION[] = "$VER: Workshop 1.26 (13-Sep-2001)";
const char AUTHOR[] = "Matthias Gietzelt";

BYTE Ep_Gadgetkind1[] = { 0, 12, 12, 12, 1, 1, 1, 12, 2, 1, 1, 12, 12, 2, 20, 12, 2, 1, 12, 7, 26, 7, 26, 18, 12, 0, 18, 0, 18, 0, -1 };
char *Ep_Terminator_Arrayraw[] = { "Terminator off", "Terminator 1 ", "Terminator 2 ", NULL };
WORD Ep_Terminator_Arrayattr[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
char *Ep_Video_Arrayraw[] = { "ignore", "fallback", "use always", NULL };
WORD Ep_Video_Arrayattr[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
char *Ep_Debug_Arrayraw[] = { "no debugging", "debuglevel 1", "debuglevel 2", "debuglevel 3", NULL };
WORD Ep_Debug_Arrayattr[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

struct ColumnInfo Terminator_Array[] =
{
	{ 0, "Terminator off", 0 },
	{ 0, "Terminator 1 ", 0 },
	{ 0, "Terminator 2 ", 0 },
	{ -1, (STRPTR)~0, -1 }
};

struct ColumnInfo Video_Array[] =
{
	{ 0, "ignore", 0 },
	{ 0, "fallback", 0 },
	{ 0, "use always", 0 },
	{ -1, (STRPTR)~0, -1 }
};

struct ColumnInfo Debug_Array[] =
{
	{ 0, "no debugging", 0 },
	{ 0, "debuglevel 1", 0 },
	{ 0, "debuglevel 2", 0 },
	{ 0, "debuglevel 3", 0 },
	{ -1, (STRPTR)~0, -1 }
};

struct NewMenu NewMenu[] =
{
	{ NM_TITLE, 0, 0, 0, 0, 0 },
	{ NM_ITEM, 0, "Q", 0, 0, 0 },
	{ NM_TITLE, 0, 0, 0, 0, 0 },
	{ NM_ITEM, 0, "D", 0, 0, 0 },
	{ NM_ITEM, 0, "L", 0, 0, 0 },
	{ NM_ITEM, 0, "R", 0, 0, 0 },
	{ NM_END, 0, 0, 0, 0, 0 }
};

void *VisualInfo1 = 0;
BOOL OS4 = TRUE;
BOOL terminated = FALSE;
ULONG WindowSignals1 = 0L;
struct Catalog *Catalog = NULL;

struct IntuiMessage *IntuiMessage = NULL;

struct Library *IntuitionBase = NULL;
struct Library *LocaleBase = NULL;
struct Library *GadToolsBase = NULL;
struct Library *AslBase = NULL;
struct Library *DOSBase = NULL;
struct Library *IconBase = NULL;
struct Library *ResourceBase = NULL;
struct Library *WindowBase = NULL;
struct Library *RequesterBase = NULL;
struct Library *ButtonBase = NULL;
struct Library *CheckBoxBase = NULL;
struct Library *ChooserBase = NULL;
struct Library *ClickTabBase = NULL;
struct Library *ColorWheelBase = NULL;
struct Library *DateBrowserBase = NULL;
struct Library *FuelGaugeBase = NULL;
struct Library *GetFileBase = NULL;
struct Library *GetFontBase = NULL;
struct Library *GetScreenModeBase = NULL;
struct Library *GradientSliderBase = NULL;
struct Library *IntegerBase = NULL;
struct Library *LayoutBase = NULL;
struct Library *ListBrowserBase = NULL;
struct Library *PaletteBase = NULL;
struct Library *RadioButtonBase = NULL;
struct Library *ScrollerBase = NULL;
struct Library *SliderBase = NULL;
struct Library *SpaceBase = NULL;
struct Library *SpeedBarBase = NULL;
struct Library *StringBase = NULL;
struct Library *TapeDeckBase = NULL;
struct Library *TextEditorBase = NULL;
struct Library *BevelBase = NULL;
struct Library *BitMapBase = NULL;
struct Library *GlyphBase = NULL;
struct Library *LabelBase = NULL;

struct IntuitionIFace *IIntuition = NULL;
struct LocaleIFace *ILocale = NULL;
struct GadToolsIFace *IGadTools = NULL;
struct AslIFace *IAsl = NULL;
struct DOSIFace *IDOS = NULL;
struct IconIFace *IIcon = NULL;
struct ResourceIFace *IResource = NULL;
struct WindowIFace *IWindow = NULL;
struct RequesterIFace *IRequester = NULL;
struct ButtonIFace *IButton = NULL;
struct CheckBoxIFace *ICheckBox = NULL;
struct ChooserIFace *IChooser = NULL;
struct ClickTabIFace *IClickTab = NULL;
struct ColorWheelIFace *IColorWheel = NULL;
struct DateBrowserIFace *IDateBrowser = NULL;
struct FuelGaugeIFace *IFuelGauge = NULL;
struct GetFileIFace *IGetFile = NULL;
struct GetFontIFace *IGetFont = NULL;
struct GetScreenModeIFace *IGetScreenMode = NULL;
struct GradientSliderIFace *IGradientSlider = NULL;
struct IntegerIFace *IInteger = NULL;
struct LayoutIFace *ILayout = NULL;
struct ListBrowserIFace *IListBrowser = NULL;
struct PaletteIFace *IPalette = NULL;
struct RadioButtonIFace *IRadioButton = NULL;
struct ScrollerIFace *IScroller = NULL;
struct SliderIFace *ISlider = NULL;
struct SpaceIFace *ISpace = NULL;
struct SpeedBarIFace *ISpeedBar = NULL;
struct StringIFace *IString = NULL;
struct TapeDeckIFace *ITapeDeck = NULL;
struct TextEditorIFace *ITextEditor = NULL;
struct BevelIFace *IBevel = NULL;
struct BitMapIFace *IBitMap = NULL;
struct GlyphIFace *IGlyph = NULL;
struct LabelIFace *ILabel = NULL;

struct List Ep_Chooser_Terminator_Array;
struct List Ep_Clicktab_Terminator_Array;
struct List Ep_Listbrowser_Terminator_Array;
struct List Ep_Radiobutton_Terminator_Array;
struct List Ep_Chooser_Video_Array;
struct List Ep_Clicktab_Video_Array;
struct List Ep_Listbrowser_Video_Array;
struct List Ep_Radiobutton_Video_Array;
struct List Ep_Chooser_Debug_Array;
struct List Ep_Clicktab_Debug_Array;
struct List Ep_Listbrowser_Debug_Array;
struct List Ep_Radiobutton_Debug_Array;
struct Menu *Menu = NULL;
struct MsgPort *AppPort = NULL;
struct MsgPort *MsgPort = NULL;

int main(int argc, char **argv)
{
	ULONG Ep_Code = 0L;
	ULONG Ep_Input = 0L;
	ULONG Ep_Micros = 0L;
	ULONG Ep_Seconds = 0L;
	struct Gadget *Ep_GadgetMessage = NULL;

	Ep_InitProgram();
	for(Ep_Code = 1;Ep_Code < argc;Ep_Code++)
	{
	}

	SetProgramName("Workshop");
	Ep_OpenWindow_Window1();
	while(!terminated)
	{
		Wait( SIGBREAKF_CTRL_C | WindowSignals1);
		while((Ep_Input = RA_HandleInput(obj[OID_WindowObject1], &Ep_Code)) != WMHI_LASTMSG)
		{
			switch(Ep_Input & WMHI_CLASSMASK)
			{
				case WMHI_GADGETUP:
					switch(Ep_Input & WMHI_GADGETMASK)
					{
						case GID_Getfile_CrashFile: Getfile_CrashFile_GadgetUp_Evt(); break;
						case GID_Getfile_AlertFile: Getfile_AlertFile_GadgetUp_Evt(); break;
						default: break;
					}
					break;
				case WMHI_GADGETHELP:
					switch(Ep_Input & WMHI_GADGETMASK)
					{
						default: break;
					}
					break;
				case WMHI_MENUPICK:
					switch(Ep_Input & WMHI_MENUMASK)
					{
						default: break;
					}
					break;
				case WMHI_MENUHELP:
					switch(Ep_Input & WMHI_MENUMASK)
					{
						default: break;
					}
					break;
				case WMHI_CLOSEWINDOW:
					Window1_CloseWindow_Evt();
					break;
				case WMHI_ICONIFY:
					break;
				case WMHI_UNICONIFY:
					break;
				case WMHI_ACTIVE:
					break;
				case WMHI_INACTIVE:
					break;
				case WMHI_RAWKEY:
					break;
				case WMHI_VANILLAKEY:
					break;
				case WMHI_MOUSEBUTTONS:
					break;
				case WMHI_MOUSEMOVE:
					break;
				case WMHI_NEWSIZE:
					break;
				case WMHI_CHANGEWINDOW:
					break;
				case WMHI_DISPOSEDWINDOW:
					break;
				case WMHI_INTUITICK:
					break;
			}
		}
	}
	Ep_QuitProgram();
	return(0);
}

void wbmain(struct WBStartup *Ep_ArgMsg)
{
	main(0, (char **) Ep_ArgMsg);
}

LONG Quitrequest1(void)
{
	struct EasyStruct EmperorRequest_Quitrequest1;

	EmperorRequest_Quitrequest1.es_StructSize = sizeof(struct EasyStruct);
	EmperorRequest_Quitrequest1.es_Flags = 0L;
	EmperorRequest_Quitrequest1.es_Title = (UBYTE *) LOCALE_REQUEST_QUIT_TITLE1;
	EmperorRequest_Quitrequest1.es_TextFormat = (UBYTE *) LOCALE_REQUEST_QUIT_BODY1;
	EmperorRequest_Quitrequest1.es_GadgetFormat = (UBYTE *) LOCALE_REQUEST_QUIT_GADGET1;
	return(EasyRequest(win[WID_Window1], &EmperorRequest_Quitrequest1, NULL, NULL));
}

STRPTR GetFile1_Filerequest(void)
{
	char Ep_ASLReturn[200] = "";
	struct FileRequester *Ep_ASLRequester;

	Ep_ASLRequester = (struct FileRequester *) AllocAslRequestTags(ASL_FileRequest, 
		ASLFR_Window,win[WID_Window1], 
		ASLFR_Screen, Screen1, 
		ASLFR_SleepWindow, TRUE, 
		ASLFR_TitleText, LOCALE_ASL_FILEREQ_TITLE1, 
		TAG_DONE);

	AslRequestTags(Ep_ASLRequester, 
		ASLFR_InitialDrawer, "CON:////WarpOS/CLOSE/WAIT", 
		ASLFR_SetSortBy, 0, 
		ASLFR_SetSortOrder, 0, 
		ASLFR_SetSortDrawers, 0, 
		ASLFR_RejectIcons, TRUE, 
		TAG_DONE);

	strcpy(Ep_ASLReturn, Ep_ASLRequester->fr_Drawer);
	AddPart(Ep_ASLReturn, Ep_ASLRequester->fr_File, 200);
	return(Ep_ASLReturn);
}

STRPTR GetFile2_Filerequest(void)
{
	char Ep_ASLReturn[200] = "";
	struct FileRequester *Ep_ASLRequester;

	Ep_ASLRequester = (struct FileRequester *) AllocAslRequestTags(ASL_FileRequest, 
		ASLFR_Window,win[WID_Window1], 
		ASLFR_Screen, Screen1, 
		ASLFR_SleepWindow, TRUE, 
		ASLFR_TitleText, LOCALE_ASL_FILEREQ_TITLE2, 
		TAG_DONE);

	AslRequestTags(Ep_ASLRequester, 
		ASLFR_InitialDrawer, "CON:////WarpOS/CLOSE/WAIT", 
		ASLFR_SetSortBy, 0, 
		ASLFR_SetSortOrder, 0, 
		ASLFR_SetSortDrawers, 0, 
		ASLFR_RejectIcons, TRUE, 
		TAG_DONE);

	strcpy(Ep_ASLReturn, Ep_ASLRequester->fr_Drawer);
	AddPart(Ep_ASLReturn, Ep_ASLRequester->fr_File, 200);
	return(Ep_ASLReturn);
}

void Ep_InitProgram(void)
{
	UWORD Ep_InitVar = 0;
	char Ep_OccuredError[50], Ep_ExceptionString[300];
	struct EasyStruct EmperorRequest_InitializationErrorRequest;

	IntuitionBase = OpenLibrary("intuition.library", 51L);
	IIntuition = (struct IntuitionIFace *) GetInterface(IntuitionBase,"main",1,NULL);
	if(!IntuitionBase || !IIntuition)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "intuition.library");
	}
	LocaleBase = OpenLibrary("locale.library", 51L);
	ILocale = (struct LocaleIFace *) GetInterface(LocaleBase,"main",1,NULL);
	if(!LocaleBase || !ILocale)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "locale.library");
	}
	GadToolsBase = OpenLibrary("gadtools.library", 51L);
	IGadTools = (struct GadToolsIFace *) GetInterface(GadToolsBase,"main",1,NULL);
	if(!GadToolsBase || !IGadTools)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadtools.library");
	}
	AslBase = OpenLibrary("asl.library", 51L);
	IAsl = (struct AslIFace *) GetInterface(AslBase,"main",1,NULL);
	if(!AslBase || !IAsl)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "asl.library");
	}
	DOSBase = OpenLibrary("dos.library", 51L);
	IDOS = (struct DOSIFace *) GetInterface(DOSBase,"main",1,NULL);
	if(!DOSBase || !IDOS)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "dos.library");
	}
	IconBase = OpenLibrary("icon.library", 51L);
	IIcon = (struct IconIFace *) GetInterface(IconBase,"main",1,NULL);
	if(!IconBase || !IIcon)
	{
		Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "icon.library");
	}
	ResourceBase = OpenLibrary("resource.library", 44L);
	IResource = (struct ResourceIFace *) GetInterface(ResourceBase,"main",1,NULL);
	if(!ResourceBase || !IResource)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "resource.library");
	}
	WindowBase = OpenLibrary("window.class", 51L);
	IWindow = (struct WindowIFace *) GetInterface(WindowBase,"main",1,NULL);
	if(!WindowBase || !IWindow)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "window.class");
	}
	RequesterBase = OpenLibrary("requester.class", 51L);
	IRequester = (struct RequesterIFace *) GetInterface(RequesterBase,"main",1,NULL);
	if(!RequesterBase || !IRequester)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "requester.class");
	}
	ButtonBase = OpenLibrary("gadgets/button.gadget", 51L);
	IButton = (struct ButtonIFace *) GetInterface(ButtonBase,"main",1,NULL);
	if(!ButtonBase || !IButton)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/button.gadget");
	}
	CheckBoxBase = OpenLibrary("gadgets/checkbox.gadget", 51L);
	ICheckBox = (struct CheckBoxIFace *) GetInterface(CheckBoxBase,"main",1,NULL);
	if(!CheckBoxBase || !ICheckBox)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/checkbox.gadget");
	}
	ChooserBase = OpenLibrary("gadgets/chooser.gadget", 51L);
	IChooser = (struct ChooserIFace *) GetInterface(ChooserBase,"main",1,NULL);
	if(!ChooserBase || !IChooser)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/chooser.gadget");
	}
	ClickTabBase = OpenLibrary("gadgets/clicktab.gadget", 51L);
	IClickTab = (struct ClickTabIFace *) GetInterface(ClickTabBase,"main",1,NULL);
	if(!ClickTabBase || !IClickTab)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/clicktab.gadget");
	}
	ColorWheelBase = OpenLibrary("gadgets/colorwheel.gadget", 51L);
	IColorWheel = (struct ColorWheelIFace *) GetInterface(ColorWheelBase,"main",1,NULL);
	if(!ColorWheelBase || !IColorWheel)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/colorwheel.gadget");
	}
	DateBrowserBase = OpenLibrary("gadgets/datebrowser.gadget", 51L);
	IDateBrowser = (struct DateBrowserIFace *) GetInterface(DateBrowserBase,"main",1,NULL);
	if(!DateBrowserBase || !IDateBrowser)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/datebrowser.gadget");
	}
	FuelGaugeBase = OpenLibrary("gadgets/fuelgauge.gadget", 51L);
	IFuelGauge = (struct FuelGaugeIFace *) GetInterface(FuelGaugeBase,"main",1,NULL);
	if(!FuelGaugeBase || !IFuelGauge)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/fuelgauge.gadget");
	}
	GetFileBase = OpenLibrary("gadgets/getfile.gadget", 51L);
	IGetFile = (struct GetFileIFace *) GetInterface(GetFileBase,"main",1,NULL);
	if(!GetFileBase || !IGetFile)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/getfile.gadget");
	}
	GetFontBase = OpenLibrary("gadgets/getfont.gadget", 51L);
	IGetFont = (struct GetFontIFace *) GetInterface(GetFontBase,"main",1,NULL);
	if(!GetFontBase || !IGetFont)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/getfont.gadget");
	}
	GetScreenModeBase = OpenLibrary("gadgets/getscreenmode.gadget", 51L);
	IGetScreenMode = (struct GetScreenModeIFace *) GetInterface(GetScreenModeBase,"main",1,NULL);
	if(!GetScreenModeBase || !IGetScreenMode)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/getscreenmode.gadget");
	}
	GradientSliderBase = OpenLibrary("gadgets/gradientslider.gadget", 51L);
	IGradientSlider = (struct GradientSliderIFace *) GetInterface(GradientSliderBase,"main",1,NULL);
	if(!GradientSliderBase || !IGradientSlider)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/gradientslider.gadget");
	}
	IntegerBase = OpenLibrary("gadgets/integer.gadget", 51L);
	IInteger = (struct IntegerIFace *) GetInterface(IntegerBase,"main",1,NULL);
	if(!IntegerBase || !IInteger)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/integer.gadget");
	}
	LayoutBase = OpenLibrary("gadgets/layout.gadget", 51L);
	ILayout = (struct LayoutIFace *) GetInterface(LayoutBase,"main",1,NULL);
	if(!LayoutBase || !ILayout)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/layout.gadget");
	}
	ListBrowserBase = OpenLibrary("gadgets/listbrowser.gadget", 51L);
	IListBrowser = (struct ListBrowserIFace *) GetInterface(ListBrowserBase,"main",1,NULL);
	if(!ListBrowserBase || !IListBrowser)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/listbrowser.gadget");
	}
	PaletteBase = OpenLibrary("gadgets/palette.gadget", 51L);
	IPalette = (struct PaletteIFace *) GetInterface(PaletteBase,"main",1,NULL);
	if(!PaletteBase || !IPalette)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/palette.gadget");
	}
	RadioButtonBase = OpenLibrary("gadgets/radiobutton.gadget", 51L);
	IRadioButton = (struct RadioButtonIFace *) GetInterface(RadioButtonBase,"main",1,NULL);
	if(!RadioButtonBase || !IRadioButton)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/radiobutton.gadget");
	}
	ScrollerBase = OpenLibrary("gadgets/scroller.gadget", 51L);
	IScroller = (struct ScrollerIFace *) GetInterface(ScrollerBase,"main",1,NULL);
	if(!ScrollerBase || !IScroller)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/scroller.gadget");
	}
	SliderBase = OpenLibrary("gadgets/slider.gadget", 51L);
	ISlider = (struct SliderIFace *) GetInterface(SliderBase,"main",1,NULL);
	if(!SliderBase || !ISlider)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/slider.gadget");
	}
	SpaceBase = OpenLibrary("gadgets/space.gadget", 51L);
	ISpace = (struct SpaceIFace *) GetInterface(SpaceBase,"main",1,NULL);
	if(!SpaceBase || !ISpace)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/space.gadget");
	}
	SpeedBarBase = OpenLibrary("gadgets/speedbar.gadget", 51L);
	ISpeedBar = (struct SpeedBarIFace *) GetInterface(SpeedBarBase,"main",1,NULL);
	if(!SpeedBarBase || !ISpeedBar)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/speedbar.gadget");
	}
	StringBase = OpenLibrary("gadgets/string.gadget", 51L);
	IString = (struct StringIFace *) GetInterface(StringBase,"main",1,NULL);
	if(!StringBase || !IString)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/string.gadget");
	}
	TapeDeckBase = OpenLibrary("gadgets/tapedeck.gadget", 40L);
	ITapeDeck = (struct TapeDeckIFace *) GetInterface(TapeDeckBase,"main",1,NULL);
	if(!TapeDeckBase || !ITapeDeck)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/tapedeck.gadget");
	}
	TextEditorBase = OpenLibrary("gadgets/texteditor.gadget", 51L);
	ITextEditor = (struct TextEditorIFace *) GetInterface(TextEditorBase,"main",1,NULL);
	if(!TextEditorBase || !ITextEditor)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "gadgets/texteditor.gadget");
	}
	BevelBase = OpenLibrary("images/bevel.image", 51L);
	IBevel = (struct BevelIFace *) GetInterface(BevelBase,"main",1,NULL);
	if(!BevelBase || !IBevel)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "images/bevel.image");
	}
	BitMapBase = OpenLibrary("images/bitmap.image", 51L);
	IBitMap = (struct BitMapIFace *) GetInterface(BitMapBase,"main",1,NULL);
	if(!BitMapBase || !IBitMap)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "images/bitmap.image");
	}
	GlyphBase = OpenLibrary("images/glyph.image", 51L);
	IGlyph = (struct GlyphIFace *) GetInterface(GlyphBase,"main",1,NULL);
	if(!GlyphBase || !IGlyph)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "images/glyph.image");
	}
	LabelBase = OpenLibrary("images/label.image", 51L);
	ILabel = (struct LabelIFace *) GetInterface(LabelBase,"main",1,NULL);
	if(!LabelBase || !ILabel)
	{
		OS4 = FALSE;Ep_InitVar = 1;
		strcpy(Ep_OccuredError, "images/label.image");
	}
	Catalog = OpenCatalogA(NULL, "Workshop.catalog", NULL);

	Ep_OpenScreen_Screen1();
	VisualInfo1 = GetVisualInfo(Screen1, TAG_DONE);
	if(!VisualInfo1) Ep_InitVar = 5;
	else
	{
		NewMenu[0].nm_Label = LOCALE_MENU_PROJECT1;
		NewMenu[1].nm_Label = LOCALE_MENU_QUIT1;
		NewMenu[2].nm_Label = LOCALE_MENU_EDIT1;
		NewMenu[3].nm_Label = LOCALE_MENU_RESETDEFAULT1;
		NewMenu[4].nm_Label = LOCALE_MENU_LASTSAVED1;
		NewMenu[5].nm_Label = LOCALE_MENU_RESTORE1;
		Menu = CreateMenus(NewMenu, GTMN_FullMenu, TRUE, TAG_DONE);
		if(!Menu) Ep_InitVar = 6;
		LayoutMenus(Menu, VisualInfo1, GTMN_FrontPen, 0, TAG_DONE);

		AppPort = CreateMsgPort();
		if(!AppPort) Ep_InitVar = 7;

		MsgPort = CreatePort("Workshop_Port", 0);
		if(!MsgPort) Ep_InitVar = 7;
	}
	strcpy(Ep_Terminator_Arrayraw[0], LOCALE_TERM_OFF_ARRAY);
	strcpy(Ep_Terminator_Arrayraw[1], LOCALE_TERM_1_ARRAY);
	strcpy(Ep_Terminator_Arrayraw[2], LOCALE_TERM_2_ARRAY);
	strcpy(Ep_Video_Arrayraw[0], LOCALE_VIDEO_IGNORE_ARRAY);
	strcpy(Ep_Video_Arrayraw[1], LOCALE_VIDEO_FALLBACK_ARRAY);
	strcpy(Ep_Video_Arrayraw[2], LOCALE_VIDEO_ALWAYS_ARRAY);
	strcpy(Ep_Debug_Arrayraw[0], LOCALE_DEBUG_NO_ARRAY);
	strcpy(Ep_Debug_Arrayraw[1], LOCALE_DEBUG_LEVEL_1_ARRAY);
	strcpy(Ep_Debug_Arrayraw[2], LOCALE_DEBUG_LEVEL_2_ARRAY);
	strcpy(Ep_Debug_Arrayraw[3], LOCALE_DEBUG_LEVEL_3_ARRAY);
	if(OS4)
	{
		Ep_AllocChooserNode(&Ep_Chooser_Terminator_Array, Ep_Terminator_Arrayraw, Ep_Terminator_Arrayattr);
		Ep_AllocClicktabNode(&Ep_Clicktab_Terminator_Array, Ep_Terminator_Arrayraw, Ep_Terminator_Arrayattr);
		Ep_AllocListbrowserNode(&Ep_Listbrowser_Terminator_Array, Ep_Terminator_Arrayraw, Ep_Terminator_Arrayattr);
		Ep_AllocRadiobuttonNode(&Ep_Radiobutton_Terminator_Array, Ep_Terminator_Arrayraw, Ep_Terminator_Arrayattr);
	}
	if(OS4)
	{
		Ep_AllocChooserNode(&Ep_Chooser_Video_Array, Ep_Video_Arrayraw, Ep_Video_Arrayattr);
		Ep_AllocClicktabNode(&Ep_Clicktab_Video_Array, Ep_Video_Arrayraw, Ep_Video_Arrayattr);
		Ep_AllocListbrowserNode(&Ep_Listbrowser_Video_Array, Ep_Video_Arrayraw, Ep_Video_Arrayattr);
		Ep_AllocRadiobuttonNode(&Ep_Radiobutton_Video_Array, Ep_Video_Arrayraw, Ep_Video_Arrayattr);
	}
	if(OS4)
	{
		Ep_AllocChooserNode(&Ep_Chooser_Debug_Array, Ep_Debug_Arrayraw, Ep_Debug_Arrayattr);
		Ep_AllocClicktabNode(&Ep_Clicktab_Debug_Array, Ep_Debug_Arrayraw, Ep_Debug_Arrayattr);
		Ep_AllocListbrowserNode(&Ep_Listbrowser_Debug_Array, Ep_Debug_Arrayraw, Ep_Debug_Arrayattr);
		Ep_AllocRadiobuttonNode(&Ep_Radiobutton_Debug_Array, Ep_Debug_Arrayraw, Ep_Debug_Arrayattr);
	}
	if((OS4) && (!Ep_InitVar))
	{
		obj[OID_WindowObject1] = (Object *) WindowObject,
			WA_Width, 410,
			WA_Height, 382,
			WA_SizeGadget, TRUE,
			WA_DragBar, TRUE,
			WA_DepthGadget, TRUE,
			WA_CloseGadget, TRUE,
			WA_Activate, TRUE,
			WA_SizeBBottom, TRUE,
			WA_AutoAdjust, TRUE,
			WA_IDCMP,	IDCMP_GADGETDOWN | IDCMP_GADGETUP | 
						IDCMP_GADGETHELP | IDCMP_MENUPICK | 
						IDCMP_MENUHELP | IDCMP_CLOSEWINDOW | 
						IDCMP_ACTIVEWINDOW | IDCMP_INACTIVEWINDOW | 
						IDCMP_RAWKEY | IDCMP_VANILLAKEY | 
						IDCMP_MOUSEBUTTONS | IDCMP_MOUSEMOVE |  
						IDCMP_INTUITICKS,
			WA_Title, LOCALE_WINDOW_TITLE1,
			WA_ScreenTitle, LOCALE_SCREEN_TITLE1,
			WA_PubScreen, Screen1,
			WINDOW_GadgetHelp, TRUE,
			WINDOW_IconifyGadget, TRUE,
			WINDOW_IconTitle, LOCALE_ICONIFIED_TITLE1,
			WINDOW_AppPort, AppPort,
			WINDOW_Position, WPOS_CENTERMOUSE,
			WINDOW_ParentGroup, VGroupObject,
				LAYOUT_SpaceOuter, TRUE,
				LAYOUT_DeferLayout, TRUE,
				LAYOUT_AddChild,  gad[GID_Layout_Root] = LayoutObject,
					GA_ID, GID_Layout_Root,
					GA_RelVerify, TRUE,
					GA_GadgetHelp, TRUE,
					LAYOUT_Label, "",
					LAYOUT_Orientation, 1,
					LAYOUT_HorizAlignment, LALIGN_LEFT,
					LAYOUT_VertAlignment, LALIGN_TOP,
					LAYOUT_LabelPlace, BVJ_TOP_CENTER,
					LAYOUT_BevelState, IDS_NORMAL,
					LAYOUT_BevelStyle, 4,
					LAYOUT_FixedHoriz, FALSE,
					LAYOUT_FixedVert, FALSE,
					LAYOUT_AddChild, gad[GID_Layout1] = LayoutObject,
						GA_ID, GID_Layout1,
						GA_RelVerify, TRUE,
						GA_GadgetHelp, TRUE,
						LAYOUT_Label, "",
						LAYOUT_Orientation, 0,
						LAYOUT_HorizAlignment, LALIGN_LEFT,
						LAYOUT_VertAlignment, LALIGN_TOP,
						LAYOUT_LabelPlace, BVJ_TOP_CENTER,
						LAYOUT_BevelState, IDS_NORMAL,
						LAYOUT_BevelStyle, 4,
						LAYOUT_FixedHoriz, FALSE,
						LAYOUT_FixedVert, FALSE,
						LAYOUT_AddChild, gad[GID_Layout_General] = LayoutObject,
							GA_ID, GID_Layout_General,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							LAYOUT_Label, LOCALE_GENERAL,
							LAYOUT_Orientation, 1,
							LAYOUT_HorizAlignment, LALIGN_LEFT,
							LAYOUT_VertAlignment, LALIGN_TOP,
							LAYOUT_LabelPlace, BVJ_TOP_CENTER,
							LAYOUT_BevelState, IDS_NORMAL,
							LAYOUT_BevelStyle, 2,
							LAYOUT_SpaceInner, TRUE,
							LAYOUT_SpaceOuter, TRUE,
							LAYOUT_FixedHoriz, FALSE,
							LAYOUT_FixedVert, FALSE,
							LAYOUT_AddChild, gad[GID_Checkbox_MemProt] = CheckBoxObject,
								GA_ID, GID_Checkbox_MemProt,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCALE_MEMPROT,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							LAYOUT_AddChild, gad[GID_Checkbox_NoPPC] = CheckBoxObject,
								GA_ID, GID_Checkbox_NoPPC,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCALE_NOPPC,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							LAYOUT_AddChild, gad[GID_Checkbox_EarlyTerm] = CheckBoxObject,
								GA_ID, GID_Checkbox_EarlyTerm,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCLE_EARLYTERM,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							End,
						LAYOUT_AddChild, gad[GID_Layout_PowerUp] = LayoutObject,
							GA_ID, GID_Layout_PowerUp,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							LAYOUT_Label, LOCALE_POWERUP,
							LAYOUT_Orientation, 1,
							LAYOUT_HorizAlignment, LALIGN_LEFT,
							LAYOUT_VertAlignment, LALIGN_TOP,
							LAYOUT_LabelPlace, BVJ_TOP_CENTER,
							LAYOUT_BevelState, IDS_NORMAL,
							LAYOUT_BevelStyle, 2,
							LAYOUT_SpaceInner, TRUE,
							LAYOUT_SpaceOuter, TRUE,
							LAYOUT_FixedHoriz, FALSE,
							LAYOUT_FixedVert, FALSE,
							LAYOUT_AddChild, gad[GID_Chooser_Terminator] = ChooserObject,
								GA_ID, GID_Chooser_Terminator,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								CHOOSER_Title, "",
								CHOOSER_AutoFit, TRUE,
								CHOOSER_PopUp, TRUE,
								CHOOSER_MaxLabels, 3,
								CHOOSER_Offset, 0,
								CHOOSER_Selected, -1,
								CHOOSER_Labels, (ULONG) &Ep_Chooser_Terminator_Array,
								End,
							LAYOUT_AddChild, gad[GID_Checkbox_HideWarn] = CheckBoxObject,
								GA_ID, GID_Checkbox_HideWarn,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCALE_HIDEWARN,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							LAYOUT_AddChild, gad[GID_Checkbox_NoPatch] = CheckBoxObject,
								GA_ID, GID_Checkbox_NoPatch,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCALE_NOPATCH,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							End,
						End,
					LAYOUT_AddChild, gad[GID_Layout2] = LayoutObject,
						GA_ID, GID_Layout2,
						GA_RelVerify, TRUE,
						GA_GadgetHelp, TRUE,
						LAYOUT_Label, "",
						LAYOUT_Orientation, 0,
						LAYOUT_HorizAlignment, LALIGN_LEFT,
						LAYOUT_VertAlignment, LALIGN_TOP,
						LAYOUT_LabelPlace, BVJ_TOP_CENTER,
						LAYOUT_BevelState, IDS_NORMAL,
						LAYOUT_BevelStyle, 4,
						LAYOUT_FixedHoriz, FALSE,
						LAYOUT_FixedVert, FALSE,
						LAYOUT_AddChild, gad[GID_Layout_VideoAddress] = LayoutObject,
							GA_ID, GID_Layout_VideoAddress,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							LAYOUT_Label, LOCALE_VIDEOADDRESS,
							LAYOUT_Orientation, 1,
							LAYOUT_HorizAlignment, LALIGN_LEFT,
							LAYOUT_VertAlignment, LALIGN_TOP,
							LAYOUT_LabelPlace, BVJ_TOP_CENTER,
							LAYOUT_BevelState, IDS_NORMAL,
							LAYOUT_BevelStyle, 2,
							LAYOUT_SpaceInner, TRUE,
							LAYOUT_SpaceOuter, TRUE,
							LAYOUT_FixedHoriz, FALSE,
							LAYOUT_FixedVert, FALSE,
							LAYOUT_AddChild, gad[GID_Chooser_AddressHandling] = ChooserObject,
								GA_ID, GID_Chooser_AddressHandling,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								CHOOSER_Title, "",
								CHOOSER_AutoFit, TRUE,
								CHOOSER_PopUp, TRUE,
								CHOOSER_MaxLabels, 3,
								CHOOSER_Offset, 0,
								CHOOSER_Selected, -1,
								CHOOSER_Labels, (ULONG) &Ep_Chooser_Video_Array,
								End,
							LAYOUT_AddChild, gad[GID_String_Address] = StringObject,
								GA_ID, GID_String_Address,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_TabCycle, TRUE,
								STRINGA_TextVal, "",
								STRINGA_MaxChars, 10,
								STRINGA_Justification, GACT_STRINGLEFT,
								STRINGA_MinVisible, 10,
								STRINGA_HookType, SHK_HEXADECIMAL,
								STRINGA_ReplaceMode, TRUE,
								End,
							End,
						LAYOUT_AddChild, gad[GID_Layout_Debugging] = LayoutObject,
							GA_ID, GID_Layout_Debugging,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							LAYOUT_Label, LOCALE_DEBUGGING,
							LAYOUT_Orientation, 1,
							LAYOUT_HorizAlignment, LALIGN_LEFT,
							LAYOUT_VertAlignment, LALIGN_TOP,
							LAYOUT_LabelPlace, BVJ_TOP_CENTER,
							LAYOUT_BevelState, IDS_NORMAL,
							LAYOUT_BevelStyle, 2,
							LAYOUT_SpaceInner, TRUE,
							LAYOUT_SpaceOuter, TRUE,
							LAYOUT_FixedHoriz, FALSE,
							LAYOUT_FixedVert, FALSE,
							LAYOUT_AddChild, gad[GID_Chooser_DebuggerHandling] = ChooserObject,
								GA_ID, GID_Chooser_DebuggerHandling,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								CHOOSER_Title, "",
								CHOOSER_AutoFit, TRUE,
								CHOOSER_PopUp, TRUE,
								CHOOSER_MaxLabels, 4,
								CHOOSER_Offset, 0,
								CHOOSER_Selected, -1,
								CHOOSER_Labels, (ULONG) &Ep_Chooser_Debug_Array,
								End,
							LAYOUT_AddChild, gad[GID_Checkbox_Segmentinfo] = CheckBoxObject,
								GA_ID, GID_Checkbox_Segmentinfo,
								GA_RelVerify, TRUE,
								GA_GadgetHelp, TRUE,
								GA_Text, LOCALE_SEGMENTINFO,
								CHECKBOX_TextPen, 1,
								CHECKBOX_FillTextPen, 1,
								CHECKBOX_BackgroundPen, 0,
								CHECKBOX_TextPlace, PLACETEXT_LEFT,
								End,
							End,
						End,
					LAYOUT_AddChild, gad[GID_Layout_Logdata] = LayoutObject,
						GA_ID, GID_Layout_Logdata,
						GA_RelVerify, TRUE,
						GA_GadgetHelp, TRUE,
						LAYOUT_Label, LOCALE_LOGDATA,
						LAYOUT_Orientation, 1,
						LAYOUT_HorizAlignment, LALIGN_LEFT,
						LAYOUT_VertAlignment, LALIGN_TOP,
						LAYOUT_LabelPlace, BVJ_TOP_CENTER,
						LAYOUT_BevelState, IDS_NORMAL,
						LAYOUT_BevelStyle, 2,
						LAYOUT_SpaceInner, TRUE,
						LAYOUT_SpaceOuter, TRUE,
						LAYOUT_FixedHoriz, FALSE,
						LAYOUT_FixedVert, FALSE,
						LAYOUT_AddChild, gad[GID_Getfile_CrashFile] = GetFileObject,
							GA_ID, GID_Getfile_CrashFile,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							GETFILE_TitleText, "",
							GETFILE_AcceptPattern, "",
							GETFILE_RejectPattern, "",
							GETFILE_FullFile, "CON:////WarpOS/AUTO/CLOSE/WAIT/INACTIVE",
							GETFILE_DoSaveMode, TRUE,
							GETFILE_RejectIcons, TRUE,
							End,
						CHILD_Label, gad[GID_Label_Crash] = LabelObject,
							LABEL_Justification, 0,
							LABEL_Text, LOCALE_CRASH,
							End,
						LAYOUT_AddChild, gad[GID_Getfile_AlertFile] = GetFileObject,
							GA_ID, GID_Getfile_AlertFile,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							GETFILE_TitleText, "",
							GETFILE_AcceptPattern, "",
							GETFILE_RejectPattern, "",
							GETFILE_FullFile, "CON:////WarpOS/AUTO/CLOSE/WAIT/INACTIVE",
							GETFILE_DoSaveMode, TRUE,
							GETFILE_RejectIcons, TRUE,
							End,
						CHILD_Label, gad[GID_Label_Alert] = LabelObject,
							LABEL_Justification, 0,
							LABEL_Text, LOCALE_ALERT,
							End,
						End,
					LAYOUT_AddChild, gad[GID_Space1] = SpaceObject,
						GA_ID, GID_Space1,
						GA_RelVerify, TRUE,
						GA_GadgetHelp, TRUE,
						SPACE_MinHeight, 10,
						SPACE_BevelStyle, 4,
						End,
					LAYOUT_AddChild, gad[GID_Layout_Button] = LayoutObject,
						GA_ID, GID_Layout_Button,
						GA_RelVerify, TRUE,
						GA_GadgetHelp, TRUE,
						LAYOUT_Label, "",
						LAYOUT_Orientation, 0,
						LAYOUT_HorizAlignment, LALIGN_LEFT,
						LAYOUT_VertAlignment, LALIGN_TOP,
						LAYOUT_LabelPlace, BVJ_TOP_CENTER,
						LAYOUT_BevelState, IDS_NORMAL,
						LAYOUT_BevelStyle, 4,
						LAYOUT_FixedHoriz, FALSE,
						LAYOUT_FixedVert, FALSE,
						LAYOUT_AddChild, gad[GID_Button_Save] = ButtonObject,
							GA_ID, GID_Button_Save,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							GA_Text, LOCALE_SAVE,
							BUTTON_AutoButton, 0,
							BUTTON_BevelStyle, 1,
							BUTTON_Justification, 1,
							End,
						LAYOUT_AddChild, gad[GID_Space2] = SpaceObject,
							GA_ID, GID_Space2,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							SPACE_MinWidth, 50,
							SPACE_BevelStyle, 4,
							End,
						LAYOUT_AddChild, gad[GID_Button_Use] = ButtonObject,
							GA_ID, GID_Button_Use,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							GA_Text, LOCALE_USE,
							BUTTON_AutoButton, 0,
							BUTTON_BevelStyle, 1,
							BUTTON_Justification, 1,
							End,
						LAYOUT_AddChild, gad[GID_Space3] = SpaceObject,
							GA_ID, GID_Space3,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							SPACE_MinWidth, 50,
							SPACE_BevelStyle, 4,
							End,
						LAYOUT_AddChild, gad[GID_Button_Break] = ButtonObject,
							GA_ID, GID_Button_Break,
							GA_RelVerify, TRUE,
							GA_GadgetHelp, TRUE,
							GA_Text, LOCALE_BREAK,
							BUTTON_AutoButton, 0,
							BUTTON_BevelStyle, 1,
							BUTTON_Justification, 1,
							End,
						End,
					End,
				EndGroup,
			EndWindow;
	}

	if(Ep_InitVar)
	{
		strcpy(Ep_ExceptionString, "Error during initialization:\n\n");
		switch(Ep_InitVar)
		{
			case 1: strcat(Ep_ExceptionString, "Can't open Amiga-library\n\"");
					strcat(Ep_ExceptionString, Ep_OccuredError);
					strcat(Ep_ExceptionString, "\"\n\nProbably you haven't got a\ncorrect installed AmigaOS system !");
					break;
			case 5: strcat(Ep_ExceptionString, "Can't get visualinfo of the screen."); break;
			case 6: strcat(Ep_ExceptionString, "Can't create menu."); break;
			case 7: strcat(Ep_ExceptionString, "Can't create message-port."); break;
		}
		if(Ep_InitVar >= 5) strcat(Ep_ExceptionString, "\n\nMaybe there isn't enough memory !");
		EmperorRequest_InitializationErrorRequest.es_StructSize = sizeof(struct EasyStruct);
		EmperorRequest_InitializationErrorRequest.es_Flags = 0L;
		EmperorRequest_InitializationErrorRequest.es_Title = (UBYTE *) "Program error";
		EmperorRequest_InitializationErrorRequest.es_TextFormat = (UBYTE *) Ep_ExceptionString;
		EmperorRequest_InitializationErrorRequest.es_GadgetFormat = (UBYTE *) "Okay";
		EasyRequest(NULL, &EmperorRequest_InitializationErrorRequest, NULL, NULL);
		Ep_QuitProgram();
	}
}

void Ep_QuitProgram(void)
{
	Ep_CloseWindow_Window1();
	if(obj[OID_WindowObject1])			DisposeObject(obj[OID_WindowObject1]);
	if(AppPort)			DeleteMsgPort(AppPort);
	if(MsgPort)			DeletePort(MsgPort);
	if(Menu)			FreeMenus(Menu);
	if(Screen1)			UnlockPubScreen(NULL, Screen1);
	if(Catalog)			CloseCatalog(Catalog);
	if(ILabel)			DropInterface((struct Interface *)ILabel);
	if(IGlyph)			DropInterface((struct Interface *)IGlyph);
	if(IBitMap)			DropInterface((struct Interface *)IBitMap);
	if(IBevel)			DropInterface((struct Interface *)IBevel);
	if(ITextEditor)			DropInterface((struct Interface *)ITextEditor);
	if(ITapeDeck)			DropInterface((struct Interface *)ITapeDeck);
	if(IString)			DropInterface((struct Interface *)IString);
	if(ISpeedBar)			DropInterface((struct Interface *)ISpeedBar);
	if(ISpace)			DropInterface((struct Interface *)ISpace);
	if(ISlider)			DropInterface((struct Interface *)ISlider);
	if(IScroller)			DropInterface((struct Interface *)IScroller);
	if(IRadioButton)			DropInterface((struct Interface *)IRadioButton);
	if(IPalette)			DropInterface((struct Interface *)IPalette);
	if(IListBrowser)			DropInterface((struct Interface *)IListBrowser);
	if(ILayout)			DropInterface((struct Interface *)ILayout);
	if(IInteger)			DropInterface((struct Interface *)IInteger);
	if(IGradientSlider)			DropInterface((struct Interface *)IGradientSlider);
	if(IGetScreenMode)			DropInterface((struct Interface *)IGetScreenMode);
	if(IGetFont)			DropInterface((struct Interface *)IGetFont);
	if(IGetFile)			DropInterface((struct Interface *)IGetFile);
	if(IFuelGauge)			DropInterface((struct Interface *)IFuelGauge);
	if(IDateBrowser)			DropInterface((struct Interface *)IDateBrowser);
	if(IColorWheel)			DropInterface((struct Interface *)IColorWheel);
	if(IClickTab)			DropInterface((struct Interface *)IClickTab);
	if(IChooser)			DropInterface((struct Interface *)IChooser);
	if(ICheckBox)			DropInterface((struct Interface *)ICheckBox);
	if(IButton)			DropInterface((struct Interface *)IButton);
	if(IRequester)			DropInterface((struct Interface *)IRequester);
	if(IWindow)			DropInterface((struct Interface *)IWindow);
	if(IResource)			DropInterface((struct Interface *)IResource);
	if(IIcon)			DropInterface((struct Interface *)IIcon);
	if(IDOS)			DropInterface((struct Interface *)IDOS);
	if(IAsl)			DropInterface((struct Interface *)IAsl);
	if(IGadTools)			DropInterface((struct Interface *)IGadTools);
	if(ILocale)			DropInterface((struct Interface *)ILocale);
	if(IIntuition)			DropInterface((struct Interface *)IIntuition);
	if(LabelBase)			CloseLibrary(LabelBase);
	if(GlyphBase)			CloseLibrary(GlyphBase);
	if(BitMapBase)			CloseLibrary(BitMapBase);
	if(BevelBase)			CloseLibrary(BevelBase);
	if(TextEditorBase)			CloseLibrary(TextEditorBase);
	if(TapeDeckBase)			CloseLibrary(TapeDeckBase);
	if(StringBase)			CloseLibrary(StringBase);
	if(SpeedBarBase)			CloseLibrary(SpeedBarBase);
	if(SpaceBase)			CloseLibrary(SpaceBase);
	if(SliderBase)			CloseLibrary(SliderBase);
	if(ScrollerBase)			CloseLibrary(ScrollerBase);
	if(RadioButtonBase)			CloseLibrary(RadioButtonBase);
	if(PaletteBase)			CloseLibrary(PaletteBase);
	if(ListBrowserBase)			CloseLibrary(ListBrowserBase);
	if(LayoutBase)			CloseLibrary(LayoutBase);
	if(IntegerBase)			CloseLibrary(IntegerBase);
	if(GradientSliderBase)			CloseLibrary(GradientSliderBase);
	if(GetScreenModeBase)			CloseLibrary(GetScreenModeBase);
	if(GetFontBase)			CloseLibrary(GetFontBase);
	if(GetFileBase)			CloseLibrary(GetFileBase);
	if(FuelGaugeBase)			CloseLibrary(FuelGaugeBase);
	if(DateBrowserBase)			CloseLibrary(DateBrowserBase);
	if(ColorWheelBase)			CloseLibrary(ColorWheelBase);
	if(ClickTabBase)			CloseLibrary(ClickTabBase);
	if(ChooserBase)			CloseLibrary(ChooserBase);
	if(CheckBoxBase)			CloseLibrary(CheckBoxBase);
	if(ButtonBase)			CloseLibrary(ButtonBase);
	if(RequesterBase)			CloseLibrary(RequesterBase);
	if(WindowBase)			CloseLibrary(WindowBase);
	if(ResourceBase)			CloseLibrary(ResourceBase);
	if(IconBase)			CloseLibrary(IconBase);
	if(DOSBase)			CloseLibrary(DOSBase);
	if(AslBase)			CloseLibrary(AslBase);
	if(GadToolsBase)			CloseLibrary(GadToolsBase);
	if(LocaleBase)			CloseLibrary(LocaleBase);
	if(IntuitionBase)			CloseLibrary(IntuitionBase);
	exit(0);
}

void Ep_CloseScreen_Screen1(void)
{
	if(Screen1)
	{
		UnlockPubScreen(NULL, Screen1);
		Screen1 = NULL;
	}
}

struct Screen *Ep_OpenScreen_Screen1(void)
{
	Screen1 = LockPubScreen(NULL);
	return(Screen1);
}

void Ep_CloseWindow_Window1(void)
{
	if(OS4)
	{
		if(Menu)	ClearMenuStrip(win[WID_Window1]);
		DoMethod(obj[OID_WindowObject1], WM_CLOSE, NULL);
		win[WID_Window1] = NULL;
		WindowSignals1 = 0L;
	}
}

struct Window *Ep_OpenWindow_Window1(void)
{
	if(OS4)
	{
		win[WID_Window1] = RA_OpenWindow(obj[OID_WindowObject1]);
		GetAttr(WINDOW_SigMask, obj[OID_WindowObject1], &WindowSignals1);
		SetMenuStrip(win[WID_Window1], Menu);
	}
	return(win[WID_Window1]);
}

STRPTR Ep_GetGadgetAttrComplex(struct Gadget *Ep_GadgetName, ULONG Ep_GadgetFlagMask)
{
	LONG Ep_GadgetAttrBuffer, Ep_GadgetCounter;
	char Ep_GadgetAttrReturn[100];

	Ep_GadgetAttrBuffer = 0L;
	for(Ep_GadgetCounter = 0;Ep_GadgetCounter < 1023;Ep_GadgetCounter++)
	{
		if(Gadget1[Ep_GadgetCounter] == Ep_GadgetName)
		{
			GetAttr(Ep_GadgetFlagMask, Ep_GadgetName, (ULONG *) &Ep_GadgetAttrBuffer);
			switch(Ep_Gadgetkind1[Ep_GadgetCounter])
			{
				case 0:
					if(Ep_GadgetFlagMask == GA_Text) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 1:
					if(Ep_GadgetFlagMask == GA_Text) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 2:
					if(Ep_GadgetFlagMask == CHOOSER_Title) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 3: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 4:
					if(Ep_GadgetFlagMask == WHEEL_Abbrv) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else
					{
						if((Ep_GadgetFlagMask == WHEEL_Red) || (Ep_GadgetFlagMask == WHEEL_Green) || (Ep_GadgetFlagMask == WHEEL_Blue) || (Ep_GadgetFlagMask == WHEEL_Hue) || (Ep_GadgetFlagMask == WHEEL_Saturation) || (Ep_GadgetFlagMask == WHEEL_Brightness)) strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer >> 24));
						else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					}
					break;
				case 5:
					if(Ep_GadgetFlagMask == DATEBROWSER_DayTitles) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 6:
					if(Ep_GadgetFlagMask == GA_Text) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 7:
					if((Ep_GadgetFlagMask == GETFILE_TitleText) || (Ep_GadgetFlagMask == GETFILE_File) || (Ep_GadgetFlagMask == GETFILE_Drawer) || (Ep_GadgetFlagMask == GETFILE_FullFile) || (Ep_GadgetFlagMask == GETFILE_Pattern) || (Ep_GadgetFlagMask == GETFILE_AcceptPattern) || (Ep_GadgetFlagMask == GETFILE_RejectPattern)) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 8:
					if(Ep_GadgetFlagMask == GETFONT_TitleText) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 9:
					if(Ep_GadgetFlagMask == GETSCREENMODE_TitleText) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 10: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 11: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 13: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 14: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 15: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 16: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 17: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 18: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 19: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 20:
					if((Ep_GadgetFlagMask == STRINGA_TextVal) || (Ep_GadgetFlagMask == STRINGA_Buffer) || (Ep_GadgetFlagMask == STRINGA_UndoBuffer) || (Ep_GadgetFlagMask == STRINGA_WorkBuffer)) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
				case 21: strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer)); break;
				case 22:
					if(Ep_GadgetFlagMask == GA_TEXTEDITOR_Contents) strcpy(Ep_GadgetAttrReturn, (char *) Ep_GadgetAttrBuffer);
					else strcpy(Ep_GadgetAttrReturn, inttostring(Ep_GadgetAttrBuffer));
					break;
			}
			break;
		}
	}
	return(Ep_GadgetAttrReturn);
}

void Ep_AllocChooserNode(struct List *Ep_List, char **Ep_Labels, WORD *Ep_Attributes)
{
	WORD Ep_Counter1 = 0;
	struct Node *Ep_Node;

	if(OS4)
	{
		NewList(Ep_List);
		while(*Ep_Labels)
		{
			Ep_Node = AllocChooserNode(CNA_Text, *Ep_Labels,
						CNA_Disabled, Ep_Attributes[Ep_Counter1],
 						CNA_ReadOnly, Ep_Attributes[Ep_Counter1 + 1],
						TAG_DONE);
			if(Ep_Node)	AddTail(Ep_List, Ep_Node);
			Ep_Labels++;
			Ep_Counter1 += 12;
		}
	}
}

void Ep_AllocClicktabNode(struct List *Ep_List, char **Ep_Labels, WORD *Ep_Attributes)
{
	WORD Ep_Counter1 = 0, Ep_Counter2 = 0;
	struct Node *Ep_Node;

	if(OS4)
	{
		NewList(Ep_List);
		while(*Ep_Labels)
		{
			Ep_Node = AllocClickTabNode(TNA_Text, *Ep_Labels, 
						TNA_Disabled, Ep_Attributes[Ep_Counter1], 
						TNA_Number, Ep_Counter2, 
						TAG_DONE);
			if(Ep_Node)	AddTail(Ep_List, Ep_Node);
			Ep_Labels++;
			Ep_Counter1 += 12;
			Ep_Counter2++;
		}
	}
}

void Ep_AllocListbrowserNode(struct List *Ep_List, char **Ep_Labels, WORD *Ep_Attributes)
{
	WORD Ep_Counter1 = 0, Ep_Counter2 = 0;
	struct Node *Ep_Node;

	if(OS4)
	{
		NewList(Ep_List);
		while(*Ep_Labels)
		{
			Ep_Counter2 = 0;
			if(Ep_Attributes[Ep_Counter1 + 1]) Ep_Counter2 += 1;
			if(Ep_Attributes[Ep_Counter1 + 2]) Ep_Counter2 += 4;
			if(Ep_Attributes[Ep_Counter1 + 3]) Ep_Counter2 += 8;
			if(Ep_Attributes[Ep_Counter1 + 4]) Ep_Counter2 += 16;
			Ep_Node = AllocListBrowserNode(1, LBNCA_Text, *Ep_Labels,
						LBNCA_CopyText, TRUE, 
						LBNA_Generation, Ep_Attributes[Ep_Counter1 + 10], 
						LBNA_Column, Ep_Attributes[Ep_Counter1 + 11],
						LBNA_Flags, Ep_Counter2, 
						LBNA_Selected, Ep_Attributes[Ep_Counter1 + 5], 
						LBNA_CheckBox, Ep_Attributes[Ep_Counter1 + 6], 
						LBNA_Checked, Ep_Attributes[Ep_Counter1 + 7], 
						TAG_DONE);
			if(Ep_Node)	AddTail(Ep_List, Ep_Node);
			Ep_Labels++;
			Ep_Counter1 += 12;
		}
	}
}

void Ep_AllocRadiobuttonNode(struct List *Ep_List, char **Ep_Labels, WORD *Ep_Attributes)
{
	struct Node *Ep_Node;

	if(OS4)
	{
		NewList(Ep_List);
		while(*Ep_Labels)
		{
			Ep_Node = AllocRadioButtonNode(1, RBNA_Labels, *Ep_Labels, 
						TAG_DONE);
			if(Ep_Node)	AddTail(Ep_List, Ep_Node);
			Ep_Labels++;
		}
	}
}

LONG stringtoint(STRPTR Emperor_StringBuffer)
{
	return(atol(Emperor_StringBuffer));
}

STRPTR inttostring(LONG Emperor_IntegerInput)
{
	char *Emperor_StringOutput = "abcdefghijk";
	char *Emperor_StringBegin;
	BYTE Emperor_Counter, Emperor_IntegerLength = 0;
	LONG buffer;

	strcpy(Emperor_StringOutput, "");
	Emperor_StringBegin = Emperor_StringOutput;
	if(Emperor_IntegerInput < 0)
	{
		*Emperor_StringOutput++ = '-';
		Emperor_IntegerInput = -Emperor_IntegerInput;
	}
	buffer = Emperor_IntegerInput;
	do
	{
		buffer = buffer / 10;
		Emperor_IntegerLength++;
	}
	while(buffer > 0);
	for(Emperor_Counter = 1;Emperor_Counter <= Emperor_IntegerLength;Emperor_Counter++)
	{
		buffer = (LONG) (Emperor_IntegerInput / (LONG) pow(10.0, (DOUBLE)Emperor_IntegerLength - Emperor_Counter));
		Emperor_IntegerInput -= buffer * (LONG) pow(10.0, (DOUBLE)Emperor_IntegerLength - Emperor_Counter);
		*Emperor_StringOutput++ = (char) (buffer + 48);
	}
	*Emperor_StringOutput = 0;
	Emperor_StringOutput = Emperor_StringBegin;
	return(Emperor_StringOutput);
}

#include "Workshop.h"
