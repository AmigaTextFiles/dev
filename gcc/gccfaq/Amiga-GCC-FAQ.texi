@setfilename gcc-faq.info
@settitle Amiga GCC FAQ

@node top, General Introduction, (dir), (dir) 


Warning:  This FAQ remains incomplete, i.e. some sections do not have an
answer or much of an answer.  However, on the whole, there is still a lot
of information here that could be of help to you.

Note: This is an update to some more current information.  I am trying
to find a convenient and non-intrusive way to insert URLs so that
texi2html produces the proper links, while tex would produce something
reasonable.

[If anyone's name is misspelled or needs umlauts or accents or whatever,
 please let me know, and how to correct it.]

                              Amiga GNU CC FAQ
				Version 0.6


@menu


List of Chapters

* General Introduction::

* Obtaining and Installing the Beast::

* Initial Problems with GCC::

* Amiga-specific extensions::

* Advanced Questions::

* C++ and Objective C::

* Notes For Un*x Hackers::

* Support Utilities::

* Additional Support::

* Known Bugs::

* Maintainers and Contributors::

* Future::

* History::



Appendices

* How does the GPL affect programs compiled by GCC?::

* GNU Porting activities and who dealing with them::

* Another Free C compiler (for those without much memory)::




@end menu

@node    General Introduction, Obtaining and Installing the Beast, Top,  Top 

@chapter General Introduction

@menu 

* The Amiga Developer's Environment (ADE)::

* GNU and the GPL:: 

* What GCC has to offer:: 

* Hardware and Software Requirements:: 

@end menu 

@node    The Amiga Developer's Environment (ADE), GNU and the GPL, , General Introduction 

@section  The Amiga Developer's Environment (ADE)

   Previously, ports of gcc and other free software (GNU and otherwise) have been
sporadic and lacking in overall organization.  The ADE project is an attempt to 
remedy that by providing a central repository (at ftp.ninemoons.com) of all ADE
packages, mailing lists for developers, and a project list.  Furthermore, one of
the goals of ADE is to provide a completely self-hosting environment, i.e. all
ADE packages can be compiled by compilers included in ADE, in which a developer
can change his tools in whatever way he sees fit.

 	Cronus donates the space on ftp.ninemoons.com for the central repository,
under the direction of Fred Fish.  Snapshots are made once every 2 or 3 months,
depending on Fred's work load, and are a complete rebuild of the entire ADE tree.
Phillipe Brand still maintains the net releases of gcc, as the ADE snapshots can
be on the bloody (through not quite bleeding) edge of development.

       For more information on ADE, consult <ftp://ftp.ninemoons.com/pub/ade/README>.
and <ftp://ftp.ninemoons.com/pub/ade/Projects>.  I also try to maintain a list of
web sites related to ADE (and other free amiga software) at
<http://nickel.ucs.indiana.edu/~owinebar/interests/amiga/amiga.html>, which includes this
FAQ.  For information on the ADE mailing lists, consult the relevant section (in the
chapter on Support).

@node    GNU and the GPL, What GCC has to offer, The Amiga Developer's Environment (ADE), General Introduction

@section  The FSF, the GNU Project, and the GPL

    The Free Software Foundation (FSF) is an institution dedicated to
the free flow of software (and information in general (?)).  To this end
it has start the GNU (GNU's Not Unix) project, a collection of widely
portable software of all sorts (compilers and Un*x utilities for the 
most part, but some other stuff as well).  But I'm sure Richard Stallman,
director and founder of the FSF, can say it better than I:
[Note that this is heavily clipped;  You should get the original at
<prep.mit.edu>]
@quotation
@display
Copyright (C) 1985, 1993 Free Software Foundation, Inc.



The GNU Manifesto
*****************


Why I Must Write GNU
====================

   I consider that the golden rule requires that if I like a program I
must share it with other people who like it.  Software sellers want to
divide the users and conquer them, making each user agree not to share
with others.  I refuse to break solidarity with other users in this
way.  I cannot in good conscience sign a nondisclosure agreement or a
software license agreement.  For years I worked within the Artificial
Intelligence Lab to resist such tendencies and other inhospitalities,
but eventually they had gone too far: I could not remain in an
institution where such things are done for me against my will.

   So that I can continue to use computers without dishonor, I have
decided to put together a sufficient body of free software so that I
will be able to get along without any software that is not free.  I
have resigned from the AI lab to deny MIT any legal excuse to prevent
me from giving GNU away.

Why GNU Will Be Compatible with Unix
====================================

   Unix is not my ideal system, but it is not too bad.  The essential
features of Unix seem to be good ones, and I think I can fill in what
Unix lacks without spoiling them.  And a system compatible with Unix
would be convenient for many other people to adopt.

How GNU Will Be Available
=========================

   GNU is not in the public domain.  Everyone will be permitted to
modify and redistribute GNU, but no distributor will be allowed to
restrict its further redistribution.  That is to say, proprietary
modifications will not be allowed.  I want to make sure that all
versions of GNU remain free.

Why Many Other Programmers Want to Help
=======================================

   I have found many other programmers who are excited about GNU and
want to help.

   Many programmers are unhappy about the commercialization of system
software.  It may enable them to make more money, but it requires them
to feel in conflict with other programmers in general rather than feel
as comrades.  The fundamental act of friendship among programmers is the
sharing of programs; marketing arrangements now typically used
essentially forbid programmers to treat others as friends.  The
purchaser of software must choose between friendship and obeying the
law.  Naturally, many decide that friendship is more important.  But
those who believe in law often do not feel at ease with either choice.
They become cynical and think that programming is just a way of making
money.

   By working on and using GNU rather than proprietary programs, we can
be hospitable to everyone and obey the law.  In addition, GNU serves as
an example to inspire and a banner to rally others to join us in
sharing.  This can give us a feeling of harmony which is impossible if
we use software that is not free.  For about half the programmers I
talk to, this is an important happiness that money cannot replace.

How You Can Contribute
======================

   I am asking computer manufacturers for donations of machines and
money.  I'm asking individuals for donations of programs and work.

   One consequence you can expect if you donate machines is that GNU
will run on them at an early date.  The machines should be complete,
ready to use systems, approved for use in a residential area, and not
in need of sophisticated cooling or power.

   I have found very many programmers eager to contribute part-time
work for GNU.  For most projects, such part-time distributed work would
be very hard to coordinate; the independently-written parts would not
work together.  But for the particular task of replacing Unix, this
problem is absent.  A complete Unix system contains hundreds of utility
programs, each of which is documented separately.  Most interface
specifications are fixed by Unix compatibility.  If each contributor
can write a compatible replacement for a single Unix utility, and make
it work properly in place of the original on a Unix system, then these
utilities will work right when put together.  Even allowing for Murphy
to create a few unexpected problems, assembling these components will
be a feasible task.  (The kernel will require closer communication and
will be worked on by a small, tight group.)

   If I get donations of money, I may be able to hire a few people full
or part time.  The salary won't be high by programmers' standards, but
I'm looking for people for whom building community spirit is as
important as making money.  I view this as a way of enabling dedicated
people to devote their full energies to working on GNU by sparing them
the need to make a living in another way.

Why All Computer Users Will Benefit
===================================

   Once GNU is written, everyone will be able to obtain good system
software free, just like air.(2)

   This means much more than just saving everyone the price of a Unix
license.  It means that much wasteful duplication of system programming
effort will be avoided.  This effort can go instead into advancing the
state of the art.

   Complete system sources will be available to everyone.  As a result,
a user who needs changes in the system will always be free to make them
himself, or hire any available programmer or company to make them for
him.  Users will no longer be at the mercy of one programmer or company
which owns the sources and is in sole position to make changes.

   Schools will be able to provide a much more educational environment
by encouraging all students to study and improve the system code.
Harvard's computer lab used to have the policy that no program could be
installed on the system if its sources were not on public display, and
upheld it by actually refusing to install certain programs.  I was very
much inspired by this.

   Finally, the overhead of considering who owns the system software
and what one is or is not entitled to do with it will be lifted.

   Arrangements to make people pay for using a program, including
licensing of copies, always incur a tremendous cost to society through
the cumbersome mechanisms necessary to figure out how much (that is,
which programs) a person must pay for.  And only a police state can
force everyone to obey them.  Consider a space station where air must
be manufactured at great cost: charging each breather per liter of air
may be fair, but wearing the metered gas mask all day and all night is
intolerable even if everyone can afford to pay the air bill.  And the
TV cameras everywhere to see if you ever take the mask off are
outrageous.  It's better to support the air plant with a head tax and
chuck the masks.

   Copying all or parts of a program is as natural to a programmer as
breathing, and as productive.  It ought to be as free.
@end quotation


The GNU Public License (GPL) was written in order to keep software published
under it free.  Here's the Preamble of the GPL:
@quotation
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                          675 Mass Ave, Cambridge, MA 02139, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

@end display
@end quotation
More information regarding the FSF, GNU, and the GPL can be obtained at
gnu.prep.mit.edu.  Note that the source code of any GPLed software must be
made available by the distributor (is this wording accurate?).  The GPL
may also affect how you distribute your programs, or maybe not.
For more information, check out Appendix A of this FAQ.
(Do this before believing all the bad hype about it.  Then decide for
yourself).

@node    What GCC has to offer, Hardware and Software Requirements, GNU and the GPL, General Introduction

@section  What GCC has to offer.

    A FREE C compiler, for starters.
    It's available for a wide range of machines (and thus it can't be
	beat for cross-compiling, at least on the Amiga).
    It's still actively supported.
    For the interested, a chance to change it as you like, make your own
      bug fixes, be an active part in the development process.

@node    Hardware and Software Requirements, , What GCC has to offer, General Introduction

@section  Hardware and Software Requirements

   This depends upon what you're doing, but here are some general guidelines.

Systems:
Any Amiga (ranging from A1000 up to A4000/40, including CD-32 & SX-1) will
run amigados-gnu utilities.

Memory:
A minimum of 4MB free memory is needed in order to compile small/medium
projects.
More memory will be needed for large projects, such as recompiling gcc
itself.
Gigamem is known to work with GCC so *maybe* less memory will work. 
But in this case, you'll need an MMU equiped amiga (A3000,A4000/40, etc...).
VMM40 (Public Domain Virtual memory manager) is also known to work with GCC.

[Editor's note:  using the g++ compiler can require even more, like at 
	least  6 MB of free RAM]
OS:
Starting from 2.6.3, 1.3 systems are not longer supported.
Gcc runs fine on all other systems, starting from 2.04 up to 3.1 (40.68).


Disk Space:
An installation of gcc requires the use of a hard disk. Approximately 10MB is
required at present to install the compiler and utilities required to use it.
In addition 3MB is required for the Commodore Developer Kit, which is required
to be able to compile AmigaDOS specific programs. This kit is available direct
from Commodore-Amiga.
 
CD-ROM distributions sre generally configured to allow everything to be run off
the CD-ROM, with a LOCAL: assign to point to modifications, third party development
files, etc.  


Yes, it can take a lot of resources, but that's a function of its
portability.  Be glad you can count on having the same compiler on your
Amiga at home or the Unix system at work (or vice versa :-)).  

@node    Obtaining and Installing the Beast, Initial Problems with GCC, General Introduction,  Top 

@chapter  Obtaining and Installing the Beast

@menu 

* Sources of the Amiga port of GCC:: 

* The Breakdown of the Distribution:: 

* Installation:: 

* Common Installation Problems:: 

@end menu 

@node    Sources of the Amiga port of GCC, The Breakdown of the Distribution, , Obtaining and Installing the Beast

@section  Sources of the Amiga port of GCC

   There are a couple of options for getting GCC.
   If you have access to the Internet, and ftp service, you can obtain
the current version of GCC from Aminet, in dev/gcc.
The main site of Aminet is <ftp.wustl.edu> in /pub/aminet, and has mirrors
world-wide:
@display
                     USA (MO)                ftp.wustl.edu
                     USA (WI)               ftp.netnet.net
                     USA (TX)                 ftp.etsu.edu
                     Scandinavia               ftp.luth.se
                     Switzerland              ftp.eunet.ch
                     Switzerland          ftp.math.ethz.ch
                     Germany        kelly.uni-paderborn.de
                     Germany          ftp.uni-paderborn.de
                     Germany          ftp.uni-stuttgart.de
                     Germany           ftp.uni-erlangen.de
                     Germany           ftp.cs.tu-berlin.de
                     Germany            ftp.tu-chemnitz.de
                     Germany            ftp.fh-augsburg.de
                     Germany             ftp.uni-bremen.de
                     Germany                 ftp.uni-kl.de
                     Germany              ftp.uni-trier.de
                     Germany      ftp.informatik.rwth-aach
                     France                    ftp.cnam.fr
                     Portugal                 ftp.ci.ua.pt
                     UK                   ftp.doc.ic.ac.uk
                     UK                 micros.hensa.ac.uk
@end display

    <ftp://ftp.funet.fi> also serves to act as a hub for porting GNU software to 
the Amiga, and serves to mirror Phillipe Brand's Amiga GCC tree directly, so 
that you may always find GCC there (particularly to guarantee the availability
of source code).

   <ftp://ftp.ninemoons.com> also carries a distribution of gcc binaries and source.
They will generally be more up to date than the latest Aminet distribution. Make sure
you check in the Breakdown of the Distribution for which files you should get.

CD-ROM distributions are particularly handy ways of obtaining GCC (and other free tools).
  Unfortunately, the FreshFish CD-ROM is no longer in production due
to lack of market.  However, Cronus will make a custom CD with the current ADE
development tree in a ready to run form for $50.  See <http://www.cronus.com>
for more details.  The Amiga Developer's CD may also be a source of the ADE development
tree (I'm not sure).

@node    The Breakdown of the Distribution, Installation, Sources of the Amiga port of GCC, Obtaining and Installing the Beast

@section  The Breakdown of the Distribution

   The net distribution of gcc is broken up into several parts, both to make it
easier to download and to respect the GPL.  Thus each archive is 
broken into two parts, one for binaries and one for sources.


Gcc-2.7.0 is split up into 15 archives:
@display
gcc270-base.lha         1568247 950902 Gcc v2.7.0 - Base part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-c.lha             777638 950902 Gcc v2.7.0 - C part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-c020.lha          724964 950902 Gcc v2.7.0 - 68020 C part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-cp.lha           1837009 950902 Gcc v2.7.0 - C++ part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-cp020.lha        1804177 950902 Gcc v2.7.0 - 68020 C++ part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-doc.lha          1191858 950902 Gcc v2.7.0 - Doc part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-inclib.lha        939537 950902 Gcc v2.7.0 - Headers and Libs part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-objc.lha          654300 950902 Gcc v2.7.0 - Objc part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-objc020.lha       631745 950902 Gcc v2.7.0 - 68020 Objc part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-readme.lha        121957 950902 Gcc v2.7.0 - README part - C/C++/ObjC Compiler set for AmigaDOS
gcc270-src.lha          8212723 950902 Gcc v2.7.0 - Sources part - C/C++/ObjC Compiler set for AmigaDOS
gccdoc.lha              1674382 930318 GNU CC documentation in TeX and Postscript format
ixemul-000s.lha           86332 960530 IXemul 43.1 - 68000 library
ixemul-000t.lha           88218 960530 IXemul 43.1 - 68000 trace library
ixemul-020f.lha           83997 960530 IXemul 43.1 - 68020+fpu library
ixemul-020s.lha           84269 960530 IXemul 43.1 - 68020 library
ixemul-030f.lha           93465 960408 IXemul 43.0 - 68030+fpu library
ixemul-030s.lha           93755 960408 IXemul 43.0 - 68030 library
ixemul-040f.lha           84141 960530 IXemul 43.1 - 68040+fpu library
ixemul-040s.lha           84269 960530 IXemul 43.1 - 68040 library
ixemul-bin.lha            35059 960530 IXemul 43.1 - various utilities
ixemul-doc.lha            42880 960530 IXemul 43.1 - various documentation
ixemul-sdk.lha          1618566 960530 IXemul 43.1 - developer's tool kit
ixemul-src.lha          1887510 960530 IXemul 43.1 - full source code
ixemul-tz.lha            214230 960530 IXemul 43.1 - TZ management files
ixpath.lha                12544 951223 Patch dos to use ixemul style path parsing
ixprefs1.2.lha            52561 950704 Ixemul 41.0-41.1 GUI/CLI config program
libnixV1_1.lha           374467 960310 A static library for gcc (V1.1)
@end display

   The ADE distribution is quite a bit different.  From the README:

The ADE is can be divided into several distinct files trees, as follows:
@display

ADE-bin		Binary tree where executables, runtime libraries,
		user documentation, etc live in "ready-to-run"
		form.  Uses "ADE:" as an alias (Amiga assign).
		The files in this area are built from source in
		ADE-src or copied from files in ADE-src.

ADE-src		Source tree which contains all the sources for
		components of the ADE.  Given the ADE-src tree, and
		a copy of the ADE-bin tree, it should be possible
		to completely recreate the ADE-bin and ADE-dist
		trees.

ADE-dist	Tree which contains material from ADE-bin and
		ADE-src, archived in a form suitable for BBS or ftp
		access.  Also contains baseline source archives
		for packages which have been modified and diff
		files for the Amiga sources relative to this
		baseline.
@end display

The ADE-dist tree normally contains several files for each program.
As an example, here are the names of the files for the GNU C compiler.
Each file also has an associated product info file which has the same
name but an additional suffix of ".pi":

@display
gcc-X.X.X-base.tgz	Baseline source before incorporation into the ADE.
			In some cases base files have been reorganized to
			match the same file tree structure as used for the
			Amiga source in the ADE, so that diff files can be
			mechanically generated.

gcc-X.X.X-bin.lha	The binary package for GNU C, C++, and Objective C.

gcc-X.X.X-src.tgz	The Amiga source from which the supplied binaries
			were compiled.

gcc-X.X.X-diffs.gz	The diffs from the baseline to the Amiga source.
			The baseline source, amiga source, and diff file
			form a complete source distribution.  In theory,
			only any two of these are needed, since the third
			can be regenerated from either of the other two.
@end display
Note that ".tgz" is short for ".tar.gz", which is a gzip compressed tar
archive.  To extract the contents, you would do something like:
@display
	tar -xvpzf gcc-X.X.X-base.tgz
@end display

If this causes you any problems, you can use pipes to do the decompression
and tar extraction as two separate processes, without creating a temporary
file:
@display

	zcat gcc-X.X.X-base.tgz | tar -xvpf -

@end display
Without using pipes, you can create a temporary file to extract from,
as follows:
@display

	zcat gcc-X.X.X-base.tgz >gcc-X.X.X-base.tar
	tar -xvpf gcc-X.X.X.tar

@end display

   The minimum set of packages is:
@display
ADE-misc-bin.lha
binutils-X.X-bin.lha
bison-X.X-bin.lha
diffutils-X.X-bin.lha
fifo-X.X-bin.lha
fileutils-X.X-bin.lha
findutils-X.X-bin.lha
flex-X.X-bin.lha
gcc-X.X-bin.lha
grep-X.X-bin.lha
gzip-X.X-bin.lha
ixemul-X.X-bin.lha
ixemul-X.X-env-bin.lha
ixemul-X.X-inc-bin.lha
ixpipe-X.X-bin.lha
libamiga-bin.lha
libg++-X.X-bin.lha
libm-X.X-bin.lha
libnix-X.X-bin.lha
make-X.X-bin.lha
os-inc-bin.lha
patch-X.X-bin.lha
pdksh-X.X-bin.lha
sed-X.X-bin.lha
sh-utils-X.X-bin.lha
tar-X.X-bin.lha
termcap-X.X-bin.lha
textutils-X.X-bin.lha
@end display


@node    Installation, Common Installation Problems, The Breakdown of the Distribution, Obtaining and Installing the Beast


@section  Installation

    Installation procedures may vary depending on your source, but
the final directory structure should be the same.  Check the README
files included in your distribution package for more details.  
    
    The ftp distribution (Phillipe Brand's) contains an Installer program.
    It utilizes the following layout:
@display
Name			What					Where	

COPYING			GNU LICENSE, read!!			All archives
COPYING.LIB		GNU LIBRARY LICENSE, read!!		All archives
README-2.6.3		this file				All archives
NEWS-2.6.3		What's new in gcc-2.6.3			gcc263-base
Installer		Commodore installer utility		gcc263-base
GCC-Install		Installer script to configure gcc	All archives
envarc/			global environment variables you should
			have set when using this programming	gcc263-base
			environment
include/		non-amiga specific C/C++ headers	gcc263-inclib
os-include/proto	amiga specific protos headers.		gcc263-inclib
os-include/inline	amiga specific inline C headers. Add	gcc263-inclib
			Commodore headers!!		
os-lib/			amiga specific libraries		gcc263-base
guide/			Docs in AmigaGuide(tm) format		gcc263-doc
man/			this is the root for tons of man pages	gcc263-doc
bin/			this is /bin, and contains all 		gcc263-c
			binaries of this distribution that	gcc263-c++
			are meant to be directly invoked by	gcc263-utils
			the user (contrary to the executables
     			in lib/gcc-lib/, that are meant to be
			invoked by a driver program like gcc)
lib/			normal (not base relatives) libraries	gcc263-inclib
lib/libm020/		normal 68020 libraries			gcc263-inclib
lib/libb/		base relatives libraries		gcc263-inclib
lib/libb/libm020/	base relatives using 68020 libraries	gcc263-inclib
lib/libnix/		Non-ixemul libraries			gcc263-inclib
lib/libm020/libnix/	Non-ixemul 68020 libraries		gcc263-inclib
lib/libb/libnix/	Non-ixemul base relatives libraries	gcc263-inclib
lib/libb/libm020/libnix	Non-ixemul base relatives 68020 libs	gcc263-inclib
lib/gcc-lib/		home of compilers called by gcc		gcc263-c
								gcc263-c++
								gcc263-objc
ixpipe/			a pipe handler needed by the library	gcc263-base
libs/			ixemul.library				gcc263-base
rexx/			ARexx wrappers for gcc and g++		gcc263-base
src-patches/		source patches				gcc263-diffs
geninline/		Perl scripts to generate inline headers	gcc263-inclib
			and -lamy glue
@end display

    A standard GNU directory tree structure has been adopted by the 
porting team to make life easier for everyone.  Starting with the
assign of GNU: to somewhere, we then have:
@display
     GNU:amigados			
     GNU:man
     GNU:Info
     GNU:etc
     GNU:bin
     GNU:include
     GNU:lib
     GNU:os-include
     GNU:os-lib 
@end display

    Since one of the aims of porting GNU software is to be able to provide
a Un*x like environment under AmigaOS, the porters decided to make a GNU
"root directory" (GNU:) in which a standard Un*x directory tree can live, like
/etc, /bin, and so on.  This decision makes for good Un*x compatibility.

   Also, in the past, you would have to add many assigns (>=10) to have your
GNU utilities working, and now it's just 5 (GNU:, MAN:, INFO:, ETC:, and 
BIN: ).

We no longer have a conflicting assign LIB: (which most other compilers use).

The above information is out of date (though true for older distributions).  Currently
the GNU directory has been changed to the ADE directory, and even fewer assigns
are needed.  Furthermore, all current programs from the ADE distribution refer
to the ade directory and not the gnu assign.

Here are the instructions for installing the ADE distribution:

Currently the only supported method of installing components of the ADE is
to create a directory which will be the root of the ADE binary tree, assign
ADE: to this directory, cd to ADE:, and use lha to extract the contents of
the packages you wish to install (everything is archived relative to ADE:).

For example, the following illustrates populating the ADE binary tree with
the minimum set of packages that we would recommend for doing serious C or
C++ development.  Replace -X.X- with the appropriate version numbers for
the current release:
@display
	makedir dh0:ADE
	assign ADE: dh0:ADE
	cd ADE:
	lha -mraxe x ADE-misc-bin.lha
	lha -mraxe x binutils-X.X-bin.lha
	lha -mraxe x bison-X.X-bin.lha
	lha -mraxe x diffutils-X.X-bin.lha
	lha -mraxe x fifo-X.X-bin.lha
	lha -mraxe x fileutils-X.X-bin.lha
	lha -mraxe x findutils-X.X-bin.lha
	lha -mraxe x flex-X.X-bin.lha
	lha -mraxe x gcc-X.X-bin.lha
	lha -mraxe x grep-X.X-bin.lha
	lha -mraxe x gzip-X.X-bin.lha
	lha -mraxe x ixemul-X.X-bin.lha
	lha -mraxe x ixemul-X.X-env-bin.lha
	lha -mraxe x ixemul-X.X-inc-bin.lha
	lha -mraxe x ixpipe-X.X-bin.lha
	lha -mraxe x libamiga-bin.lha
	lha -mraxe x libg++-X.X-bin.lha
	lha -mraxe x libm-X.X-bin.lha
	lha -mraxe x libnix-X.X-bin.lha
	lha -mraxe x make-X.X-bin.lha
	lha -mraxe x os-inc-bin.lha
	lha -mraxe x patch-X.X-bin.lha
	lha -mraxe x pdksh-X.X-bin.lha
	lha -mraxe x sed-X.X-bin.lha
	lha -mraxe x sh-utils-X.X-bin.lha
	lha -mraxe x tar-X.X-bin.lha
	lha -mraxe x termcap-X.X-bin.lha
	lha -mraxe x textutils-X.X-bin.lha

@end display
The following should be optional, unless you want to remake a "configure"
file, want EMACS, or current need a libcurses library (should be replaced
soon with ncurses):
@display

	lha -mraxe x autoconf-X.X-bin.lha
	lha -mraxe x emacs-X.X-bin.lha
	lha -mraxe x libcurses-X.X-bin.lha

@end display

You may want to examine the ixemul.library flavors in ADE:Sys/Libs and
select one more appropriate for your specific machine.  For example,
A4000 users might want to remove the default ixemul.library (68000)
and copy ixemul040fpu.library to ixemul.library.

If you want to just do libnix development and not ixemul development, note
that you still need the include files from ixemul-X.X-inc-bin.lha.

You should also ensure that you have an environment variable called
HOME, which should point to a local directory that can be used to
contain "reconfiguration scripts" that many tools look for.  As an
example, the following is a useful definition for $HOME/.inputrc:

@display

  # My ~/.inputrc file is in -*- text -*- for easy editing with Emacs.
  #
  # Notice the various bindings which are conditionalized depending
  # on which program is running, or what terminal is active.
  #

  # In all programs, all terminals, make sure this is bound.
  "\C-x\C-r": re-read-init-file

  # Amiga console specials
  "": delete-char

  "›A": previous-history
  "›B": next-history
  "›C": forward-char
  "›D": backward-char

@end display

Once you are done, arrange to assign ADE: in your startup, arrange to
execute ADE:Sys/S/ADE-Startup at boot time, and reboot.




@node    Common Installation Problems, , Installation, Obtaining and Installing the Beast

@section  Common Installation Problems

     Using the Installer program for the ftp distribution should get rid
of any problems.

     Check out the GNU documentation on the specs file if you are having 
problems customizing your installation (say you have another compiler, and 
don't want to have 2 separate copies of os-include).

     Also, for those of you who refuse to read the README, you need the 
Commodore includes.  Section 2 (d) tells you where to get them. 

     See 2 (c) about the GCC object format.  You may need to convert some
standard libraries.  Also check 2(a) on setting your stack properly.

     Most of these problems have been overcome and should not be problems
for current distributions.


@node    Initial Problems with GCC, Amiga-specific extensions, Obtaining and Installing the Beast,  Top 

@chapter  Initial Problems with GCC

@menu 

* Set your stack properly:: 

* Amiga specific Library options:: 

* The object file format of GCC:: 

* Getting the Commodore includes:: 

* The frontend of the compiler:: 

* Optimization may work where no optimization doesn:: 

* Using the OS functions with gcc:: 

* Removing Debug Symbols:: 

@end menu 

@node    Set your stack properly, Amiga specific Library options, , Initial Problems with GCC

@section  Set your stack properly

[Note: this warning is becoming dated as versions >= 2.7.0 will include
automatic stack checking.]

    GCC needs a lot of stack to run.  For a nice, small (<1000 lines)
source, a stack of 50,000 should do just fine.  For more complicated
code, you may need more, but 250,000 should do in any case, for gcc alone.

    Note that using make may increase the demands on the stack size, so
the above suggestions may not hold.

A word from Phillipe Brand's README:

You need to have a 50.000 stack size in order to compile with GCC. This should
be enough for most projects. Note than while recompiling gcc with itself it
has taken more than 300KB stack. Stack can grow due to source complexity.
Don't be afraid of it.

To set the stack size, see the AmigaDOS Command 'stack'. 

To use ar and/or ranlib, 50KB is the minimum acceptable. You should have a
much larger stack, if you use larger libraries.

Starting with 2.6.3 a new environnement variable, GCCSTACK, enables gcc to
read this variable and set stack upon startup. Thus now no need to set stack
to huge values, only gcc/ld/cpp/cc1#? will automatically set new stack,
according to GCCSTACK variable.

Simply commit a: 
	setenv GCCSTACK value
to set gcc stack to value.

Benefits: huge memory savings.

Note that GCC 2.7.0 will include automatic stack growth code, so you won't
need to worry about this anymore.

Actually 2.7.0 didn't quite solve this problem, but (I believe) that it has been solved
in the latest ADE distribution.

@node    Amiga specific Library options, The object file format of GCC, Set your stack properly, Initial Problems with GCC

@section  Amiga specific Library options

@menu 

* Ixemul.Library:: 

* libnix:: 

* Gerlib:: 

* the PDC library:: 

@end menu 

@node    Ixemul.Library, libnix, , Amiga specific Library options

@subsection  Ixemul.Library

        This library was developed by Markus Wild when originally started
porting GCC (up to version 2.3.3).  It is a shared library that emulates
a lot of Un*x functions, making life a lot easier for folks porting
GNU utilities and such.  Unfortunately, it is fairly resource hungry by
Amiga standards, and has caused not a little irritation among Amiga
users.  By default, GCC has programs it compiles open ixemul.library, so 
if you want to avoid it, you'll have to use -noixemul on the command line 
(see below in Amiga specific extensions and/or coding with libnix) and link 
to one of the libraries below.

	The general rule of thumb should be to use ixemul.library if you're
writing something non-Amiga specific (e.g. porting something) or one of the
below link libraries when writing something specifically for the Amiga.

    Getting ixconfig to work:
[Joerg-Cyril Hoehle]

@quotation Which ixconfig should we use for ixemul v40.4?
@end quotation

If you're using R.Luebbert ixem404lib.lha, use ixconfig from
there. It's actually called bin in that archive :-(
@display
[generic]            2925    5396  54.2% -lh5- b464 Sep  3  1994 ixem/bin
@end display
The ixemul.library from the gcc263 archive is R.Luebbert's 40.4.

If you're using another one:

Fred Fish's: I don't know whether he removed the ArpBase field in the
include/library/ixemul.h file. R.Luebbert removed it between his 40.2
and 40.4, which was a big mistake IMHO (as this mail and others
show). So I don't know which ixconfig is good for him.
[Needs updating]

Leonard's: He told me that he had never removed this field, so get any
old ixconfig you'll find. The one from the gcc263 archive will do.
[Does anyone use this version anymore?]

@node    libnix, Gerlib, Ixemul.Library, Amiga specific Library options

@subsection  libnix

         This is a standard link library to replace the functionality of
ixemul.library. Make sure you link to it if you use the -noixemul command
line option for gcc.  Here's the readme file from the distribution:
@display
Short: A library for amiga specific development on gcc
Type: dev/gcc
Uploader: fleischr@@izfm.uni-stuttgart.de
Author: fleischr@@izfm.uni-stuttgart.de, gnikl@@informatik.uni-rostock.de

This is libnix, a static (i.e. link) library for gcc 2.3.3 or above.
It's not a replacement for ixemul.library (though it's possible to
recompile most of the gcc environment with libnix) but a good thing
for amiga specific development on gcc:

* It's mostly compatible to SAS's way of handling things, i.e.
  you get even an automatic shared library opening feature and
  some other things you may miss in ixemul.library.
  This also means it's ANSI compliant.

* It doesn't need any shared libraries than normal Amiga OS ones.

* It is not copyrighted by the FSF. Therefore you neither need
  to include sources nor objects together with your executable.
  (read the GLGPL _before_ flaming on this statement)

* And it's short! I was able to compile a 492 byte 'hello, world'
  using normal main.

* It uses OS20 features whenever necessary.

To cut it short:

Use ixemul.library for porting Un*x programs, libnix for compiling
amiga-only programs and gcc becomes one of the best Amiga compilers.

There is no need to download this archive if you use gcc2.6.0 or above
since the libraries itself are included with the normal gcc distribution.

But if you use an older gcc version or if you want to get the sources
you can take this package. But be warned: The ld that comes with earlier
versions of gcc has some serious trouble with set elements. You cannot
use libnix without the fixed linker that comes with gcc2.6.0.
@end display

@node    Gerlib, the PDC library, libnix, Amiga specific Library options

@subsection  Gerlib

     Obsolete.  Well, unless you want to develop for 1.3 systems.

@node    the PDC library, , Gerlib, Amiga specific Library options

@subsection  the PDC library

     Obsolete.  Well, unless you want to develop for 1.3 systems.

@node    The object file format of GCC, Getting the Commodore includes, Amiga specific Library options, Initial Problems with GCC

@section  The object file format of GCC
     
     Yes, GCC uses its own object file format.  This means you aren't 
currently able to link to AmigaDOS hunk format object files (standard).  
But hunk2gcc (by Markus Wild) will do the conversion for you as described 
below.

   Why does GCC use its own object file format?  It's really just a design
decision that allows other gnu utilities to deal with these objects (for 
example, gdb, nm, objdump, and gas) without 
having to convert them to deal with AmigaDOS hunks. 

[From Brand's README-2.6.3]
@quotation
Starting from this release an AmigaDOS compliant library is provided,
thanks to libnix authors (Matthias Fleischer and Gunther Nikl).

Anyway if you want to rebuild one, there are two methods:

1) Using hunk2gcc; the AmigaDOS object converter made by Markus Wild. To
achieve this, simply grab a copy of latest amiga.lib (from Commodore
Development Kit) and make a new directory where you want your converted
object files to go, cd into it, and enter
@example

  hunk2gcc amiga.lib [..further libs if you like..]

@end example

This generates an a.out object file for every program unit present in the
hunk file (in this case, from amiga.lib).

As the final step convert all those files into an a.out style library by
issuing:

@example
  ar qc libamiga.a obj.*
  ranlib libamiga.a

@end example

The ranlib run builds a symbol table in the archive, and makes accesses to
the library much faster.

2) Creating a libamiga.a library with libnix is fairly easy, but takes some
time. Just uncompress sources.lha from libnix distribution and run a
'make libamiga.a'.

NOTE:

As long as you make no AmigaDOs specific calls, you can create a dummy library
using:
@example

  cat "int dummy;" >dummy.c
  gcc -c dummy.c
  ar crv libamiga.a dummy.o
  mv libamiga.a gcc:lib

@end example

A small libamiga.a (dummy) is also provided with libnix.

[current]
Now libamiga.a has its own archive in the ADE tree, and is not the Commodore
copyrighted one.  If for some reason you need the original, you will have
to follow the above procedures to get it.
@end quotation

@node    Getting the Commodore includes, The frontend of the compiler, The object file format of GCC, Initial Problems with GCC

@section  Getting the Commodore includes


[Jochen Wiedmann]

You can obtain the includes and some developer tools from any Fish CD
and some other CD's as well.

However, you will be missing the autodocs, which are definitely the
best information source for the OS functions. You can get them either
by buying the
@
    The Amiga ROM Kernel Manual:  Includes and Autodocs, ISBN
                                                          0-201-56773-3

(about 50-60$, as far as I know), or by buying the so-called NDU
(Native developers update kit, 5 disks, about 40$) from
@display

         Fa. Hirsch & Wolf
         Mittelstr. 33
         56564 Neuwied
	 Germany

         Phone: (0049) +2631 83990
Email: hhhirsch@@carla.adsp.sub.org

@end display

Sorry, but this is still the *only* source for the NDU, at least as
long as CATS (Commodore Amiga Technical Support) isn't alive.

I'd prefer buying the NDU, because it contains the newer information
than the book and I prefer it online.


[Rask Lambertsen]

[The C= includes are available via FTP from <ftp.dfv.rwth-aachen.de> in 
directory cdrom/bbs/cbm. URL: file://ftp.dfv.rwth-aachen.de/cdrom/bbs/cbm/

The latest package is nduk-v40.lha. It includes includes (asm and C), 
fd-files and a few developer tools (Atom, Alink, ...).

Just to advertice a little for my homepage (sorry), I keep an up-to-date
link to the OS includes. They seem to move around from time to time.

Regards,
@display
 ___________________________________________________________________________
/                                                                           \
| Rask Ingemann Lambertsen <gc948374@@gbar.dtu.dk> or <e9864029@@ebar.dtu.dk>|
|              WWW homepage: http://srv2.gbar.dtu.dk:8001/Rask/             |
|   Keyboard error: <Ctrl> and <Alt> are stuck - press <Del> to continue    |
\___________________________________________________________________________/

@end display
P.S. My homepage URL recently changed, hopefully to something permanent.



@node    The frontend of the compiler, Optimization may work where no optimization doesn, Getting the Commodore includes, Initial Problems with GCC

@section  The frontend of the compiler

         amigados-gcc and gcc are the same thing.  Since fork is unimplemented in
ixemul.library, gcc has been replaced by gccv (uses vfork instead of fork()).

         AREXX scripts [Phillipe Brand's README]:

The provided ARexx scripts have been contributed by Loren J. Rittle.
If you like ARexx, they're an alternate way of calling gcc. They 
automatically make sure you're using a large enough stack setting, and 
enable you to compile C++ programs with less obscure options. This 
approach is furthermore useful if you're not able to use the g++ /bin/sh
script.

These scripts should no longer be necessary.

@node    Optimization may work where no optimization doesn, Using the OS functions with gcc, The frontend of the compiler, Initial Problems with GCC

@section  Optimization may work where no optimization doesn't

         The folks who write GCC almost always use -O when compiling
GCC and other stuff.  Hence, the -O routines are better tested than
those without optimization.  So you may want to try it.

@node    Using the OS functions with gcc, Removing Debug Symbols, Optimization may work where no optimization doesn, Initial Problems with GCC

@section  Using the OS functions with gcc

[Jochen Wiedmann, with a small suggestion by Christian Stieber]

Let's write a simple "HelloWorld.c":
@example

    /*  Compile me with
	    gcc -noixemul -o HelloWorld HelloWorld.c -lauto
    */
    #include <stdlib.c>
    #include <intuition/intuition.h>
    #include <proto/intuition.h>

    int main(int argc, char *argv[])

    {
        struct EasyRequest er;

        er.es_StructSize = sizeof(er);
        er.es_Flags = 0;
        er.es_Title = "Message";
        er.es_TextFormat = "Hello, world!\nintuition.library is at 0x8l.";
        er.es_GadgetFormat = "Ok";
        EasyRequest(NULL, &er, NULL, IntuitionBase);
	exit(0);
    }

@end example
Some notes:
@display
  - We are using the function EasyRequestArgs() from intuition.library. 
    Thus we have to include the appropriate headers: intuition/intuition.h
    for the structures and constants, proto/intuition.h for the 
    function prototypes. Do not use headers from other compilers (for
    example pragmas/intuition.h), gcc headers (inline/intuition.h,
    included by proto/intuition.h) or even OS headers
    (clib/intuition_protos.h). The only exception are clib/alib_protos.h
    and clib/alib_stdio_protos.h: These represent link libraries and not
    shared libraries.

  - We did *not* open intuition.library. gcc does this for you by
    including proto/intuition.h and linking against libauto.a.
    However, this works only for OS libraries. Consult the GNU:libauto
    directory, if you want to know how to get the same possibilities for
    other shared libraries.

    Using proto/intuition.h you are safe and even source compatible
    to SAS/C and Dice.

  - If you *need* to open a library manually, do it as follows:
@example

	#include <stdlib.h>
	#include <stdio.h>
        #include <intuition/intuition.h>
	#include <proto/intuition.h>

        struct IntuitionBase *IntuitionBase = NULL;
	/*  Explicit initialization with NULL is a *must*!  */

	void Cleanup(void)

	{
	    if (IntuitionBase) CloseLibrary(IntuitionBase);
	}

	int main(int argc, char *argv[])

	{
	    if (atexit(Cleanup)) {
		perror("atexit");
		exit(20);
	    }

	    if (!(IntuitionBase = (struct IntuitionBase *)
			OpenLibrary("intuition.library", 37))) {
		fprintf(stderr, "Cannot open intuition.library, V37");
		exit(20);
	    }

	    /* Same program as above */
	}

@end example 
     Note the use of atexit(), which makes exit() calling Cleanup().

Note this possible alteration:

>         struct EasyRequest er;
> 
>         er.es_StructSize = sizeof(er);

This seems to be correct, but I suggest hardcoding 5*sizeof(ULONG) here.
That field serves as version information; using sizeof() and compiling
with newer headers would tell the OS that you're using the new structure.
But the additional fields will contain garbage...
@end display

@node    Removing Debug Symbols, , Using the OS functions with gcc, Initial Problems with GCC

@section  Removing Debug Symbols

	By default, GCC will leave the debugging symbols in the executable.
To turn this off, simply use -s on the command line when you compile.  It 
could significantly reduce the size of your executable.


@node    Amiga-specific extensions, Advanced Questions, Initial Problems with GCC,  Top 

@chapter  Amiga-specific extensions

@menu 

* The CHIP keyword:: 

* Command Line options:: 

@end menu 

@node    The CHIP keyword, Command Line options, , Amiga-specific extensions

@section  The CHIP keyword

	Most C compilers for the Amiga have a CHIP keyword or equivalent to
signify that an object should stored CHIP memory when declared.  I.e., 
CHIP struct Image *my_graphics = { ... } 
will cause the memory for the data to which my_graphics points to be allocated
in CHIP memory (pretty handy, huh?)

	This is obviously Amiga-specific, so of course it's not implemented
in the FSF code. BUT, the linker (ld) currently recognizes -chip and -fast 
options.  However, these aren't in gcc itself, mainly because gcc doesn't
output files in the right format to load data directly to chip memory.

However, there are several workarounds.  The first is software based, 
mainly you declare and define your data as an array (or whatever), then
Allocmem(sizeof(data),MEMF_CHIP), then copy the data from your original
data structure using cpymem().

[Lars Hecking] 
 I have written this code years ago to use Intuition++ (still on Aminet)
 with g++. The BOOL return type could be replaced with int, returning
 appropriate values instead of TRUE and FALSE. Everything should be
 self-explanatory ;-)
@example
begin>>

chip USHORT CTRL_ImageData[] = { .... };

becomes

extern USHORT CTRL_ImageData[];

USHORT *CTRLImageData;

BOOL AllocInitChipData()
{
 CTRLImageData = (USHORT *)AllocMem (sizeof(CRTL_ImageData),MEMF_CHIP);

 if (CTRLImageData == (USHORT *)NULL)
  return FALSE;

 CopyMemQuick ((APTR)&CTRL_ImageData[0], (APTR)CTRLImageData, sizeof(CRTL_ImageData));

 return TRUE;
}

void FreeChipData()
{
 FreeMem ((APTR)CTRLImageData,sizeof(CTRL_ImageData));
}

end>>
@end example

   The second way is to use a program like Bin2Hunk (on Aminet in
/dev/misc/BintoHunk.lha), which will take a data file and make it
into a linkable object file.  The documentation for Bin2Hunk tells
you how to specify variable names for the data in this file so you
can reference this data from within your program.  This seems like
a better solution than the first since you don't have to deal with
dynamically allocating memory and copying it.  However, I haven't
tested this program myself or this way of doing things -- please
let me know if it works and how well.

    The third way would be to use another compiler that allows
the CHIP keyword to compile the source code containing the data
that you want in CHIP memory, then link to it. This doesn't have
to mean SAS/C.  If you're just using it to compile a file that's
just a bunch of 
@example
CHIP UBYTE *data{ whatever ...}
@end example
you could probably use any Amiga native compiler, even if it's
old and decrepit for doing anything else.  Let me know if you
find a good, cheap or free compiler for this (maybe the old PDC,
or the DICE demo version will do it).  Certainly an old copy of
Lattice 5.10 should be able to handle this. 

@node    Command Line options, , The CHIP keyword, Amiga-specific extensions

@section  Command Line options

@menu 

* -noixemul:: 

* -fbaserel (not available in pre-2.7.0):: 

* -resident:: 

@end menu 

@node    -noixemul, -fbaserel (not available in pre-2.7.0), , Command Line options

@subsection  -noixemul

     This option prevents gcc from making your executable open
ixemul.library (of course, your program can still do so).  Make sure you
link to libnix or something similar to access those functions.


@node    -fbaserel (not available in pre-2.7.0), -resident, -noixemul, Command Line options

@subsection  -fbaserel (not available in pre-2.7.0)

[Christian Stieber]

            -fbaserel turns on base relative adressing; which means that 
global/static variables are referenced with a 16 bit offset relative to an 
address register (a4 is generally used for that). The startup-code loads a4 
with a pointer into the data segment. Result: every access to a global/shared
variable is only 16 bit instead of the usual 32 bit address -> shorter & 
faster. It also means that you're limited to at most 64K of global/static 
variables.

      Make sure you link to baserel libraries when you use this option(!).
The standard configuration of gcc should specify baserel versions of
standard libraries be used, but make sure if you make your own that they
are baserel too.

@node    -resident, , -fbaserel (not available in pre-2.7.0), Command Line options

@subsection  -resident

[Christian Stieber] 

           A "resident" program (the correct term is "pure") is a program that
can be loaded into memory just once, but executed by serveral processes
at the same time. Therefore, "resident" is actually "code sharing".
-resident turns on -fbaserel and links with a special startup code.
That first thing that special startup code is to allocate some memory,
copy the global/static variables into it and load a4 with a pointer to
that memory. Then, a normal startup-code and your normal program
is run. When the program exists, the memory block is freed.
Result: Every process has its very own, private data segment for
global/static variables. Since there all global/static variables are
accessed via a4+16-bit-offset (because of -fbaserel), the original
data segment is untouched. Result: the program can be executed
independently by several processes, with every process getting its
own data segment.

@node    Advanced Questions, C++ and Objective C, Amiga-specific extensions,  Top 

@chapter  Advanced Questions

@menu 

* How do I build a cross-compiler?:: 

* Working with AmiTCP:: 

* Writing code for ixemul.library:: 

* Writing code for libnix:: 

* Problems with asm():: 

* How do I save RAM?:: 

* Writing shared libraries and resident (pure) code:: 

* I want to change from SAS/C to GCC:: 

* Inline Headers:: 

* Writing Hooks:: 

@end menu 

@node    How do I build a cross-compiler?, Working with AmiTCP, , Advanced Questions

@section  How do I build a cross-compiler?

[from Phillipe Brand]
@display

How to generate a cross-compiler, AmigaDOS side:

- Get gcc-2.6.3.tar.gz from ftp.gnu.ai.mit.edu or mirror site
- Get ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-2.6.3-amiga.diffs file

>From CLI:

CLI> sh
# zcat gcc-2.6.3.tar.gz | tar xvf -
# cd gcc-2.6.3
# zcat ../gcc-2.6.3-amiga.diffs | patch -p1
# ./configure --host=amigados --target=CPU-COMPANY-SYSTEM
# make

@end display
When compilers are built, all you have to do is installing it using
make install, and to grab other architecture's libraries (libc.a, etc...),
and headers.

More infos: See GCC AmigaGuide documentation, look for "Cross-Compiling".

How to generate a cross-compiler, Other architecture side:
@display

- Get gcc-2.6.3.tar.gz from ftp.gnu.ai.mit.edu or mirror site
- Get ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-2.6.3-amiga.diffs file

>From CLI:

CLI> sh
# zcat gcc-2.6.3.tar.gz | tar xvf -
# cd gcc-2.6.3
# zcat ../gcc-2.6.3-amiga.diffs | patch -p1
# ./configure --target=amigados (host should be determined by configure itself)
# make

@end display
When compilers are built, all you have to do is installing it using
make install, and to grab AmigaDOS GCC libraries (libc.a, etc...),
and headers.

More infos: See GCC AmigaGuide documentation, look for "Cross-Compiling".

A working example of a cross-compiler running on sunos4.1.3 can be found
in ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-cross/....

@node    Working with AmiTCP, Writing code for ixemul.library, How do I build a cross-compiler?, Advanced Questions

@section  Working with AmiTCP

[Peter Ivimey-Cook]

@quotation
 Could somebody please explain where exactly gcc and the libraries
 that come with it fall down when it comes to using AmiTCP?
 
 What's missing etc.
 
 Then, Why can't (I assume you can't since veryone says you can't)
 use the C= Developers kit with gcc without fiddling.
@end quotation

The problems are:

a) gcc uses it's own object module and library format, so lots of the GNU
tools don't have to change too. 

b) gcc uses ixemul by default, which is not compatible directly with the SAS
libraries supplied with AmiTCP. 

a) is just a design decision, and indeed there are tools to convert. (b) is
harder to see; basically the SAS AmiTCP libraries assume the environment of
SAS/C, complete with references to the SAS FILE structure internals and the
functions which aren't in SAS or which need to be patched to work with
AmiTCP. In addition, the netincludes supplied with the AmiTCP port include
many items and structure definitions which are also defined in gcc, albeit
differently, resulting in a very confised compiler if you mix them. 

Unfortunately, a simplistic port (recompile with the right -I directives)
fails for two reasons; the includes are wrong, and even if they were matched,
the SAS-directed library patches the wrong things. Resulting in an executable
which will fail to operate as expected (it might work OK, or it might not -
depends what you call & when). 

What is needed is a new library - take out the duplicate definitions, patch
the right functions and remake the library for gcc. 

@node    Writing code for ixemul.library, Writing code for libnix, Working with AmiTCP, Advanced Questions

@section  Writing code for ixemul.library

         After looking at Markus Wild's README, I couldn't see anything
to include in particular, and the thing is way too long to put here.
Any specific suggestions of stuff to clip out?

         Actually, considering the update activity, the current maintainers/
developers should be providing a new README.  Particularly the functions
available in the different versions (regular fxns, the ones in the network
version, and the conflicts.  Somebody recently answered a question about
this last part, saying he was trying to integrate the 2).      

@menu 

* Finding bugs with trace():: 

@end menu 

@node    Finding bugs with trace(), , , Writing code for ixemul.library

@subsection  Finding bugs with trace()

[Joerg-Cyril Hoehle]

More than one year ago, I corrected a huge bug in the program trace (a
buffer overflow). Together with ixemul.trace, this program allows you
to see every ixemul call (aka SnoopDOS for ixemul.library programs)
and may be useful for debugging.

Before, because of that overflow, trace hung the whole system very
often (and very soon) when tracing every ixemul call. Now, I've been
able to trace long sessions of gcc compilation to a (K)CON: window
without trouble.


@node    Writing code for libnix, Problems with asm(), Writing code for ixemul.library, Advanced Questions

@section  Writing code for libnix

	You should really grab the documentation for libnix from the libnix
source archive and read it.  (This will be included in the Amigaguide/texi
versions of this FAQ).

	But in the meanwhile, here's a warning from one of the authors of
libnix:

[Gunther Nikl]

 Let's write a simple "HelloWorld.c":
@example

    /*  Compile me with
            gcc -noixemul -o HelloWorld HelloWorld.c -lauto
    */
                                                     ^^^^^^
@end example

 When using the "-noixemul" switch it is NOT nessecary (and better
 avoided) to use "-lauto". libnix uses an own technique to open
 the system libraries.

 Using "-noixemul" and "-lauto" together means that all system
 libraries will be opened twice...

 The "libauto.a" is only useful for IXEMUL linked programs.
 Please state this in the faq!

   Gunther



@node    Problems with asm(), How do I save RAM?, Writing code for libnix, Advanced Questions

@section  Problems with asm()

	It seems a lot of people have trouble making heads or tails of GNU's
documentation for this function.  As such, someone (or several someones) is
going to be rewriting the GCC documentation with regards to asm().  
Unfortunately, this won't be ready in time for 2.7.0, so I'm including some
answers to a couple of the problems people are having with asm(). 
[Perhaps the new GNU documentation for asm() will be distributed as a 
"patch" when it is done.]


[Niels M|ller <nisse@@lysator.liu.se>]
@quotation
How do I create and use functions that take their arguments in registers?
@end quotation
I'm not an expert, but I'll nevertheless try to answer.

If you define a function like below, the effect is that it takes two
arguments, in registers D0 and A0. (I hope I got this right, I
have actually never used this myself).
@example

int my_func(void /* Don't declare any arguments here */)
{
   register int arg1 __asm("d0");
   register int *arg2 __asm("a0");

   return do_something(arg1,arg2);
}

@end example
[Response from Tom Ollila]

This works since those registers are not used for anything else. When
declared in this way arg1 and arg2 are hardcoded to registers d0 and a0
(and are therefore not used for anything else when doing register
allocations (if alive)). And with scratch registers such as do and a0, =
a
function call will trash the registers if used inside the called functi=
on.

The "correct" way to make this thing above would be the following:

@example

int my_func(void /* Don't declare any arguments here */)
{
   register int d0 __asm("d0");
   int arg1 =3D d0;
   register int * a0 __asm("a0");
   int * arg2 =3D a0;

...
}

@end example
[back to Niels]

To make gcc call a function that takes registerized arguments is a
little more tricky. Here you have to use inline assembler. I quote an
example from the gcc manual (I guess the processor used in the example
is a sparc):

   You can put multiple assembler instructions together in a single
`asm' template, separated either with newlines (written as `\n') or wit=
h
semicolons if the assembler allows such semicolons.  The GNU assembler
allows semicolons and all Unix assemblers seem to do so.  The input
operands are guaranteed not to use any of the clobbered registers, and
neither will the output operands' addresses, so you can read and write
the clobbered registers as many times as you like.  Here is an example
of multiple instructions in a template; it assumes that the subroutine
`_foo' accepts arguments in registers 9 and 10:
@example

     asm ("movl %0,r9;movl %1,r10;call _foo"
          : /* no outputs */
          : "g" (from), "g" (to)
          : "r9", "r10");

@end example

This is equivalent to the C-statement
@example
foo(from,to);
@end example
except that "from" and "to" are passed in registers r9 and r10, and
not on the stack. To call amiga-style libraries is similar, the inline
headers shows how it can be done.

[Tomi Ollila]
@quotation
 To make gcc call a function that takes registerized arguments is a
 little more tricky. Here you have to use inline assembler. I quote an
 example from the gcc manual (I guess the processor used in the example
 is a sparc):
@end quotation
@display
/* example deleted */
@end display

We have written some macros to make these things easier. I'll include one
of the macro files below. These macros are used as follows:

...To declare a function (named `function') that takes int argument in
register d0 and ...

@example

void RAF2(function,
	  int,		arg,	d0
	  int *,	rvp,	a0)
#if 0
{	/* this is for emacs c-mode */
#endif

... and to make a call to this functions (RRAPx -macros also return a v=
alue)

int main()
{
  int rv;

  RAP1(function,
       int,	6,	d0,
       int *,	&rv,	a0);
	 =20
...
}
@end example

Tomi Ollila.
@example
/*
 * $Id: rafrap.h,v 3.1 1994/04/17 11:31:54 too Exp $
 *
* Author: Tomi Ollila <too@@nsdi.fi>
 *
 * Created: Fri Apr 15 17:32:12 1994 too
 * Last modified: Wed Oct  5 20:44:08 1994 too
 */

#ifndef RAFRAP_H
#define RAFRAP_H

/*
 * There can be no prototype checks when using these macros so please
 * be _VERY_ careful with your code when using these.
 * (could someone tell me if arguments can be but in register by defaul=
t
 * somehow with GCC (too))
 */

#define _S(x) #x

#if 0
#define RAP1(func, type1, reg1) \
  static inline void func(type1 a##reg1)\
{\
   register type1 reg1 __asm(#reg1) =3D a##reg1;\
   __asm __volatile(_S(jsr __##func)\
     : : "r" (reg1):  "a0", "a1", "d0", "d1", "memory");\
}
  /* the new version below will be more informative */
#endif

#define RAP1(func, type1, name1, reg1) \
  static inline void func(type1 name1)\
{\
   register type1 reg1 __asm(#reg1) =3D name1;\
   __asm __volatile(_S(jsr __##func)\
     : : "r" (reg1):  "a0", "a1", "d0", "d1", "memory");\
}

#define RAP2(func, type1, name1, reg1, type2, name2, reg2) \
  static inline void func(type1 name1, type2 name2)\
{\
   register type1 reg1 __asm(#reg1) =3D name1;\
   register type2 reg2 __asm(#reg2) =3D name2;\
   __asm __volatile(_S(jsr __##func)\
     : : "r" (reg1), "r" (reg2):  "a0", "a1", "d0", "d1", "memory");\
}

#define RRAP1(rettype, func, type1, name1, reg1) \
  static inline rettype func(type1 name1)\
{\
   register rettype _res __asm("d0");\
   register type1 reg1 __asm(#reg1) =3D name1;\
   __asm __volatile(_S(jsr __##func)\
     : "=3Dr" (_res) : "r" (reg1) :  "a0", "a1", "d0", "d1", "memory");=
\
   return _res;\
}

#define RRAP2(rettype, func, type1, name1, reg1, type2, name2, reg2)\
  static inline rettype func(type1 name1, type2 name2)\
{\
   register rettype _res __asm("d0");\
   register type1 reg1 __asm(#reg1) =3D name1;\
   register type2 reg2 __asm(#reg2) =3D name2;\
   __asm __volatile(_S(jsr __##func)\
     : "=3Dr" (_res) : "r" (reg1), "r" (reg2)\
     :  "a0", "a1", "d0", "d1", "memory");\
   return _res;\
}

/*
 * RAFs
 */

#define RAF1(funname,type1, arg1, reg1) \
  funname(VOID)                     \
{                                   \
  register type1 reg1 __asm(#reg1); \
  type1 arg1 =3D reg1;

#define RAF2(funname, type1, arg1, reg1, type2, arg2, reg2) \
  funname(VOID)                     \
{                                   \
  register type1 reg1 __asm(#reg1); \
  type1 arg1 =3D reg1;                \
  register type2 reg2 __asm(#reg2); \
  type2 arg2 =3D reg2;

#define RAF3(funname, type1, arg1, reg1, \
	     type2, arg2, reg2, type3, arg3, reg3) \
  funname(VOID)                     \
{                                   \
  register type1 reg1 __asm(#reg1); \
  type1 arg1 =3D reg1;                \
  register type2 reg2 __asm(#reg2); \
  type2 arg2 =3D reg2;		    \
  register type3 reg3 __asm(#reg3); \
  type3 arg3 =3D reg3;

#endif RAFRAP_H

@end example


@node    How do I save RAM?, Writing shared libraries and resident (pure) code, Problems with asm(), Advanced Questions

@section  How do I save RAM?

[Jochen Wiedmann, J@"o;rg H@"o;hle]

A simple try is to do a
@example
    setenv TMP MyHardDrive:t
@end example
before compiling. This will create temporary files on the harddisk and
not in RAM:. Depending on what you compile this can save several 100KB of
RAM and it doesn't slow down the compiler very much.

Another try is to turn off optimization (@samp{-O0} or not @samp{-O} at
all) until your program is stable.  Optimizing needs a lot of memory.

Another try is to run @code{cpp}, @code{cc1}, @code{as} and @code{ld}
directly instead of through the @code{gcc} driver.  This saves at least
one times your current stack size.  Use the @samp{-v} option to
@code{gcc} to see what the command lines would look like and copy&paste
them.

Previous @emph{inlines} used a lot of memory during compilation, but
this is no longer the case.  The new inlines (preprocessor based macros)
even work without optimization.


@node    Writing shared libraries and resident (pure) code, I want to change from SAS/C to GCC, How do I save RAM?, Advanced Questions

@section  Writing shared libraries and resident (pure) code

Here is some discussion from the amiga-gcc-port mailing list 
[not cooked up yet]

[Peter Ivimey-Cook]
@quotation
 Obviously there must be other solutions. Being able to build a library
 is not far away from being able to build a pure (=residentable)
 program, and gcc-2.3.3 was both largely above 64KB in size and
 residentable. So what's the trick?
@end quotation

Don't use global data referenced absolutely! residentable implies 
reentrant, which means that global data is read-only apart from the first 
instance (i.e. it's OK to initialise it, once, but once initialised it 
can't be modified or reinitialised). This effectively means the only data 
used in the must be on the stack or referenced from it by pointers, as 
the stack is separate for different invocations of a resident program.

Of course this does pose a major headache for programs which use lots of 
global data. And watch out for library use too!

Failing this, one must use a global data access mechanism which allows:

(a) the base address to be set up - e.g. by calling AllocMem() and 
storing the result in a register (NOT a global!)

(b) *all* accesses to "global" data are relative to this register.

[Peter Ivimey-Cook]
@quotation

 BUT: If we build a shared lib from the static link lib, code exists only once
 and is SHARED between callers of the lib (callers means different executables, using the lib)
 Here the problem comes up that the DATA MUST not be shared between different callers.
 This is because it is PRIVATE to the individual caller.
 IMHO the only way to realize multiple callers is the use of -fbaserel, since now access
 is relative to the A4 register and thus, every program can have IT'S OWN data, without
 interferring with each other.

@end quotation
It depends on the way the library is constructed. Most Amiga libraries 
are written to be re-entrant - i.e. they don't use global data items 
which would require loading - they use the stack. For items which can't 
be done this way, there are two solutions -

1. Use the library data space. It's global, unless you make provision for 
it to be otherwise - and availabl easily off a6.

2. Manage your own data space, using tags or whatever to allocate space 
for callers. Note that the only indication you have as to who is the 
current caller is the result of FindTask(). 

So, in general libraries try to make required data passed through 
parameters, or available on the stack, or shareably global. In which case 
no baserel or anything else is required.


[Jochen Wiedmann]
  - Of course it is possible to write shared libraries (ixemul.library,
    for example) with gcc, but *only* if the source is written with a
    shared library in mind.

  - It is possible (Matthias told how) to develop a solution that would
    allow to use existing source of link libraries for shared libraries
    (libbfd sources, for example) with at most very minor modifications

  - -fbaserel would be a must for the above solution. On the other hand
    it is not possible yet, at least not without going to the assembler
    level. (Really deep, not just using some headers with asm keywords.)

[Christian Stieber]
@quotation
 Jochen Wiedmann writes:
@quotation
   - Of course it is possible to write shared libraries (ixemul.library,
     for example) with gcc, but *only* if the source is written with a
     shared library in mind.
@end quotation 
 Could you elaborate on that so that we know a little more about it,
 please?
@end quotation

- keep in mind that all callers use the same global and static variables;
  that means: either protect them with semaphores (e.g. if your library
  is using a memory pool), or allocate a block of memory inside your library
  and pass pointers around.

- the "startup" code will contain the ROMTag structure and related data,
  as well as stubs to push parameters on the stack, calling the C function,
  cleaning up the stack.

- I generally write the libOpen(), libClose(), libInit() etc. functions
  as normal C functions, but some people might prefer to put them into
  the "startup code".

That's about all. It also means that many link-lib functions (e.g. from
libnix) can't be used; this has to be decided on a per-function basis.
It's pretty safe to say that you can't use stdio and malloc(). strcpy(),
isdigit() are safe, etc. Just be careful. Think about what the function does;
that should give you an idea whether you can use it or not.


[further elaboration by Christian Stieber]

@quotation
      Can you tell me what you mean by "startup code" here (since you put it
 in quotes).
@end quotation

Simple. The "startup code" is generally something that you pass to the
linker as the first file. It will then end up being the first thing in
the executable -> the stuff in the "startup code" is the stuff that gets
executed when you start the program.

A shared (Amiga) library doesn't get executed; however, a shared Amiga
library is supposed to be built in a specific way:
@example

	moveq #-1,d0
	rts			[ROMtag Structure]

ROMTag:
	a structure telling exec about the library
	is supposed to be here

@end example

That's why I used the term "startup code" in quotes. Instead of
the usual "startup code" duties (opening stdin/stdout/stderr,
setting up malloc() etc.) the "library startup code" includes
the two asm statements and the ROMTag structure; as well as
other data related to libraries.


[Jochen Wiedmann]
@quotation
 Jochen Wiedmann writes:
@quotation
   - Of course it is possible to write shared libraries (ixemul.library,
     for example) with gcc, but *only* if the source is written with a
     shared library in mind.
@end quotation 
 Could you elaborate on that so that we know a little more about it,
 please?
 
 Does it mean that you can't use any global variable? Or only one but
 declare it with something like__asm__("a4") and use it as a base
 pointer? Does it imply that you must use the inline/*.h? Does it imply
 that you must use a special startup code (of course :-), what must it
 do?
@end quotation

In short: You may well use something like
@display
  struct ExecBase *SysBase;
@end display
and read this variable from anywhere within your program, because you
can

  a) initialize it from the library startup code and
  b) be sure that it never changes

but you must not use global or static data otherwise.


[Christian Stieber]

[about why -resident isn't what you normally use for shared libraries]
@quotation
@quotation
 This is really a special case of resident code, and has nothing to do
 with -resident 
@end quotation
  Hmm, why is it called -resident then?
@end quotation

You were talking about writing shared libraries. As I explained in my last
mail, -resident causes the startup code to create a new data segment for
they don't clone their datasegment (usually. Some libraries do that).

That means you use -resident for programs that you want to be "pure";
you don't use -resident for libraries even though libraries are "pure"
as well.


@node    I want to change from SAS/C to GCC, Inline Headers, Writing shared libraries and resident (pure) code, Advanced Questions

@section  I want to change from SAS/C to GCC

        Great!

[Kriton Kyrimis]
@quotation
 I am also wondering if it is possible to link object files that were 
 created by different conpilers, specifically GCC and SAS. I need to do 
@end quotation

Try compiling SAS programs using DATA=FAR CODE=FAR, then use the hunk2gcc
program to convert the object files from amiga format to sun format.

One problem with this approach would be with floating point code and with
integer multiplication/division. If you can compile with CPU=68020 (or higher)
and MATH=68881, then SAS/C will produce inline code, and you will have no
problem. Otherwise, you'll have to grab the necessary modules from the SAS
libraries and convert them to sun format as well. (Compiling with the option
that produces code that uses utility.library, and linking with -lauto might
alleviate the problem.)
 
   And here's a little AREXX program to automagically convert sas libs to
gcc libs:

This arexx program is based on help from Philippe BRAND.

@example
/********************************HISTORY**********************************
* 18-DEC-94 : DJR : Created                                              *
**************************************************************************
*                                                                        *
* Name      : saslib2libgcc                                              *
* Author : David J. Ruscak ruscakd@@polaroid.com *
* Created   : 18-DEC-94                                                  *
* Purpose   : to convert SAS libraries to GCC libraries                  *
*                                                                        *
*************************************************************************/


/* To convert a SAS library to a GCC format library several steps are
   involved.

 1) cd to RAM: Either copy the library to RAM: or give the full path name.

    EX: gnu:saslib2libgcc X11:lib/Xtnb.lib

 2) You need the SAS Librarian 'oml' with a version =>  Library
    otherwise you'll get an error such as 'unknown hunk'.

 3) You need hunk2gcc, mv, ar and ranlib. If your using gcc you have the
    fastram, VMM2.1 swap works fine too.

*/


/* TRACE R */
SIGNAL ON ERROR
OPTIONS RESULTS

IF ~SHOW('l','rexxsupport.library') THEN
  IF (~ADDLIB("rexxsupport.library",0,-30,0)) THEN
     DO
        ECHO "Can't load rexxsupport.library"
        EXIT 10
     END


fullname = ""

PARSE ARG fullname

IF fullname  == "" THEN
   DO
      ECHO " No Library to convert"
      ECHO ""
      ECHO " EX: gnu:saslib2libgcc X11:lib/Xtnb.lib"
      EXIT 10
   END

IF (~EXISTS(fullname)) THEN
   DO
      ECHO "Can't find" fullname
      EXIT 10
   END


ADDRESS COMMAND
/* make 2 directories for object files   */

IF EXISTS('object') THEN
   DO
     ECHO "Directory object exists Please delete or rename it."
     EXIT
   END
'makedir  object'

IF EXISTS('object2') THEN
   DO
     ECHO "Directory object2 exists Please delete or rename it. "
     EXIT
   END
'makedir  object2'

'oml -oobject 'fullname 'X *' /* SAS Object Librarian  */


IF EXISTS('object') THEN
 DO
   objfiles = SHOWDIR('object','F')              /* list of all object files */
   nfiles = WORDS(SHOWDIR('object','F'))         /* count of object files    */
   DO    UNTIL nfiles == 0                /* must be a more efficient way... */
    'hunk2gcc >NIL: object/'WORD(objfiles,nfiles)   /* convert to GCC object */
    'mv >NIL: obj.#? object2/'WORD(objfiles,nfiles) /* restore original names*/
    nfiles = nfiles - 1
   END
 END


'cd object2' /* directory of converted objects */
path =  PRAGMA('D','object2')

IF (INDEX(fullname,':') > 0) THEN    /* strip out assign */
        fullname = SUBSTR(fullname,LASTPOS(':',fullname) + 1)

IF (INDEX(fullname,'/') > 0) THEN    /* strip off directories */
        libname = SUBSTR(fullname,LASTPOS('/',fullname) + 1)
ELSE
        libname = fullname

dot = POS('.',libname)

gcclibname = 'lib'SUBSTR(libname,1,dot)'a'

'ar qc 'gcclibname' #?.o'    /* archive new library */

'ranlib 'gcclibname

IF EXISTS(gcclibname) THEN
  DO
    needslash = LASTPOS(':',path)
    IF ~(needslash == LENGTH(path)) THEN
      path = path'/'
    ECHO " The following indicate a hunk2gcc error:"
    ECHO " Short reloc into N_DATA, what should I do?
    ECHO " Short reloc into N_BSS, what should I do?
    ECHO ""
    ECHO ""
    ECHO " Remember to move/rename "path"object2/"gcclibname" appropriately ."
  END
ELSE
  ECHO "No library created, what could have gone wrong ????"

EXIT

ERROR:

   ECHO " error = "RC
   ECHO " Hope its not the dreaded *Invalid Hunk type*"
EXIT

@end example

@node    Inline Headers, Writing Hooks, I want to change from SAS/C to GCC, Advanced Questions

@section  Inline Headers

[Christian Stieber] (maybe should clear out the specific bgui reference)
@quotation
 compiling bgui:demos/font.c:
   gcc -O3 -noixemul bgui:demos/font.c
 
 got errors:
   font.c:100: unterminated macro call
@end quotation

This is because the inlined varargs aren't useful at all. Do
#define NO_INLINE_STDARG (or whatever it is called), and create
varargs stubs like this:
@example

Prototype: BOOL SomeFunction(int, char *, ...);
and        BOOL SomeFunctionA(int, char *, APTR);

Stub function:
#define NO_INLINE_STDARG
#include <inline/someinline.h>
BOOL SomeFunction(int A, char *B, ...)
{
  return SomeFunctionA(A,B,(&B)+1);
}
@end example

That isn't really ANSI-C, but it works on all Amiga compilers I know of.

Create a .c file for every function, compile, ar and link it to
the program. Make sure the optimizer is on, else SomeFunctionA
won't be inlined.

How to create stubs for non-varargs functions:
In order to be able to compiler without -O, you want to create
stubs for the inline functions as well:
@example
#define NO_INLINE_STDARG
#define SomeFunctionA InlinedSomeFunctionA
#include <inline/someinlines.h>
#undef SomeFunctionA
BOOL SomeFunctionA(int A, char *B, APTR C)
{
  return InlinedSomeFunctionA(A,B,C);
}
@end example

Again, create such a file for every function and put the *.o files
into the archive mentioned above.

@node    Writing Hooks, , Inline Headers, Advanced Questions

@section  Writing Hooks

[Tomi Ollila]
@quotation
 1) How to I write a hook function - I.E. Specify which registers parameters
 should be received in and that the result should be returned in register D0.
@end quotation

One way to do this is to write the function entry the following way:

@example
ULONG hook(void)
{
  register char * a0 __asm("a0");
  char * buffer = a0;
  register ULONG d0 __asm("d0");
  ULONG size = d0;

  ...

  return length;
}

@end example

We wrote some macros for AmiTCP/IP project to make it easier to write this
kind of function entries...
@example

#define RAF2(funname, type1, arg1, reg1, type2, arg2, reg2) \
  funname(VOID)                     \
{                                   \
  register type1 reg1 __asm(#reg1); \
  type1 arg1 = reg1;                \
  register type2 reg2 __asm(#reg2); \
  type2 arg2 = reg2;

@end example
would make the above function look like:
@example

ULONG RAF2(hook,
	   char *,	buffer,	a0,
	   ULONG,	size,	d0)
#if 0
{
#endif
@end example

The whole macro file `amiga_raf.h' is available at kampi.hut.fi, directory
/AmiTCP. It defines RAF1 - RAF7 for both GNU C and SAS C compilers (someone
could write these to DICE as well).

@quotation
 2) Is there anyway to specify that a function should NOT be made inline (As
    I wouldn't want the hook function inlined.
@end quotation

Compile it in a separate module. This way gcc doesn't see the function code
when compiling. If you give a pointer to the function, then it must also
exist as a callable function.



@node    C++ and Objective C, Notes For Un*x Hackers, Advanced Questions,  Top 

@chapter  C++ and Objective C

@menu 

* C++:: 

@end menu 

@node    C++, , , C++ and Objective C

@section  C++

@menu 

* Use _complex.h instead of complex.h:: 

@end menu 

@node    Use _complex.h instead of complex.h, , , C++

@subsection  Use _complex.h instead of complex.h

	Because Amiga Dos is not case-sensitive, and there are
both complex.h and Complex.h on the Unix distribution, one had to be
changed.  This choice was recommended by the libg++ maintainer.

	
    (don't know much about these, except that they're not as well
     developed yet as the C compiler)

@node    Notes For Un*x Hackers, Support Utilities, C++ and Objective C,  Top 

@chapter  Notes For Un*x Hackers
     [additions to this section are welcome]    

@menu 

* @code{fork()} is not implemented:: 

@end menu 

@node    @code{fork()} is not implemented, , , Notes For Un*x Hackers

@section  @code{fork()} is not implemented

  This is from the current readme (in the ixemul source archive) for
ixemul.library.


PORTING UNIX PROGRAMS

Most programs compile out-of-the-box.  There are a few exceptions to this
rule.  First of all, programs like linkers and the like that have to be
able to read or write the standard Amiga hunk format obviously need a lot
of work.

Secondly, there is no virtual memory support, and therefore no real @code{fork()}
function.  In most cases the @code{fork()} function is only used to spawn a new
program, and in such cases it is possible to replace @code{fork()} by 
@code{vfork()},
which is a light-weight @code{fork()} replacement that was originally created for
Unix to reduce the overhead a real @code{fork()} introduced.

A @code{vfork()} doesn't create a copy of itself as @code{fork()} does, but uses the
parent's code and data.  Since the child will quickly call @code{execve()} to
spawn another program, this sharing of the code and data is no problem and
saves a lot of time.

In some cases, such as a Unix shell (pdksh for example), you really want to
be able to port a program that uses a fork() that cannot be replaced with
@code{vfork()}.  There is a way to do this, although it is a lot of work.  First
of all, the program has to be compiled with -resident.  Now you replace the
@code{fork()} by a @code{vfork2()} call, and in the child code you call 
ix_resident() to
copy the original data hunk to a new location.  Next you have to copy all
the parent's data structures to the child.  In other words, you have to
copy the complete state of the parent process to the child process.  This
can be a lot of work.  Finally, you call @code{vfork_resume()} which unblocks the
parent so that you now have two processes running separately from each
other.

It is important to realize that you should never @code{exit()} from the parent
before all @code{vfork()}'ed children have died.  Since exiting from the parent
causes the parents code and data segments to be deallocated, the child
would find itself without code space to run on, and would probably cause a
severe machine crash!

So always call at least @code{wait (0)} before returning from the parent.

For an example of how this works, see jobs.c from the pdksh source
distribution.  It's a kind of poor-man's @code{fork()}.

The third case I've come across that couldn't easily be ported were
programs that dump their state to a new file.  Emacs does this, as does GNU
Common Lisp.  The idea is that such a program will read lots of packages,
and then dump itself to a new file.  That new file can in turn be executed,
and you will no longer have to load all those packages.  All this assumes
that when you load a program, all the code and data ends up at the same
memory address.  Something that is true for Unix, but not for the Amiga due
to the lack of virtual memory.

However, if someone wants to do a port of such a program, please contact me
as I have developed a technique to implement this.  At least, I've made
this work with a small test program.  I've tried to use it with GNU Common
Lisp, but time constraints prevented me from developing this further.

The last problematic category I've seen is GNU Emacs.  This program assumes
that all the data it allocates will always end up in a continuous memory
block, and that the upper 8 bits of each memory address are always the
same.  The Amiga, however, can have multiple memory blocks positioned at
various places in memory.  While there is a GNU Emacs port, this port does
assume this limitation and if you have an Amiga with many memory blocks (as
I had) GNU Emacs may easily crash.  No easy solution exists.


@node    Support Utilities, Additional Support, Notes For Un*x Hackers,  Top 

@chapter  Support Utilities

@menu 

* Frontends:: 

* Debuggers:: 

@end menu 

@node    Frontends, Debuggers, , Support Utilities

@section  Frontends
	
[under construction]

@node    Debuggers, , Frontends, Support Utilities

@section  Debuggers
         
          GDB is the GNU debugger, and Fred Fish is the port maintaineer for it.
It is useable nowwith ixemul-based programs, though there are still some 
bugs to be worked out (it has problems when run in emacs because of the
UNIX style pathnames it uses).  Read the documentation for more information.
The source archive will probably contain more amiga-specific information if
it's needed.

   If you start gdb with the -enforcer option, then the program you are
debugging will automatically stop and drop into the debugger as soon as an
Enforcer hit occurs.  This is obviously very useful.


   Any debugger that can handle the stabs format should work.  If you know
of any such, let me know.


@node    Additional Support, Known Bugs, Support Utilities,  Top 

@chapter  Additional Support

@menu 

* amiga-gcc-port mailing list:: 

* ADE mailing lists::

* Individuals:: 

* You never  it could be a problem in base FSF code:: 

@end menu 

@node    amiga-gcc-port mailing list, ADE mailing lists, , Additional Support

@section  amiga-gcc-port mailing list

   Actually, amiga-gcc-port is no longer the main mailing list
for gcc.  Around late 1995/early 1996, many of the subscribers of this
mailing list migrated to the ADE mailing list.  However, I think it is
still running, and you will probably get some response from someone
(I believe Phillipe is still subscribed).  If it no longer exists, please
let me know. 

@display
From: Leonard Norrgard <vinsci@@nic.funet.fi>
To: amiga-gcc-port@@nic.funet.fi
Subject: Monthly mailing list info for list amiga-gcc-port


[This is an automatic monthly posting from the mailing list maintainer]
[Contains important practical info about mailserver features you maybe]
[are not aware of.]
[Last changed June 22nd, 1993.]

The mailing list amiga-gcc-port on lists.funet.fi is run automatically,
so you can both subscribe and unsubscribe to it simply by sending
e-mail to the mailing list server, or mailserver program.  You can
reach the mailserver at the address mailserver@@lists.funet.fi as
described below.  Please use the mailserver rather than the address
amiga-gcc-port-request@@lists.funet.fi (which remains valid) whenever
you can, so that human list management work can be minimized.
  If the automated way of doing things doesn't work for you for some
reason, please use the amiga-gcc-port-request@@lists.funet.fi address
instead, and I'll try to solve your problem manually.  Please NEVER
send subscription or unsubscription-requests to the address
amiga-gcc-port@@lists.funet.fi as that would send your request to all
subscribers of the mailing list.

To unsubscribe from this mailinglist only, send e-mail like this:
@display
> To: mailserver@@lists.funet.fi
>	Subject:
>
>	unsub amiga-gcc-port
@end display
To unsubscribe from _all_ mailinglists run by this mailserver, send
e-mail like this:
@display
> To: mailserver@@lists.funet.fi
>	Subject:
>
>	unsub *
@end display

To subscribe to this mailinglist, send e-mail like this:
@display
> To: mailserver@@lists.funet.fi
>	Subject:
>
>	sub amiga-gcc-port your_first_name your_last_name
@end display

To recieve additional information and help on how to use the
mailserver (this includes info on how to use the ftp archive
ftp.funet.fi by e-mail):

@display
> To: mailserver@@lists.funet.fi
>	Subject:
>
>	help
@end display

If you do not receive this mail once a month, you may have been
silently removed from the list.  This can happen whenever your e-mail
address stops working for some reason (a common problem is to set up
mail forwarding from machine A to machine B and from machine B to
machine A so as to make a mail-forwarding loop).  So if you don't
receive this mail once a month, you may want to 1) check the mailing
list to see if you're still on it (see below), and 2) Resubscribe
using the usual mailserver sub command described above.

To receive a list of all names on the mailing list
amiga-gcc-port@@lists.funet.fi, send e-mail like this:

@display
> To: mailserver@@lists.funet.fi
>	Subject:
>
>	review amiga-gcc-port

@end display

Virtually,

The amiga-gcc-port mailing list management.
@end display
	
@node ADE mailing lists, Individuals, amiga-gcc-port mailing list, Additional Support

The ADE mailing lists provide lots of information and support.  To subscribe
to one send an e-mail message to majordomo@@ninemoons.com with a line as
follows:
@display
subscribe <mailing list name> [<address>]
@end display
e.g.
@display
subscribe ADE
@end display
To recieve more information about how to use the majordomo server,
include a line
@display
HELP
@end display

These are the mailing lists currently available:

@menu
* ADE::
* ADE-GCC::
* ADE-Projects::
* ADE-Ixemul::
@end menu

@node  ADE, ADE-GCC, , ADE mailing lists

@subsection{ADE}

This mailing list is for general discussion about the Amiga Developer's
Environment, a project which is supported by volunteers from the Amiga
community.  There are separate lists for discussions about specific parts of
the ADE, such as ade-gcc for the GNU C compiler.  Please use this list only
for topics that are of general interest or which do not clearly pertain to
any of the other existing lists.  Note that you do not have to subscribe to
the other more specific lists in order to post to them, if for example you
have a question about gcc and want to post it to the ade-gcc list, but don't
want to see the normal chatter that happens on a day-to-day basis in that
list.

Because of the hard work from a number of members of the Amiga community, we
now have a large body of development tools and other packages that have been
ported to the Amiga and are available in both source and binary form.  The
ADE is available via ftp at ftp.ninemoons.com:pub/ade/....

We welcome mirrors and will list them here as they come on line.  The ADE
will also eventually be available on CD-ROM as part of the new series of
developer oriented CD-ROMs expected to be released by Cronus in the first
quarter of 1996.

Although the ADE started out as ports of tools covered by the GNU General
Public License, the GNU Library General Public License, or some code covered
by the "Berkeley License", it certainly isn't limited to those.  Any package
which is available in source is eligible to be part of the ADE.

One of the goals of the ADE is to have a completely self hosting
environment.  I.E. that everything within it be compilable by the GNU C
compiler or other provided compilers.  It should be possible for the
recipient of these utilities to make whatever changes or bug fixes they want
in any piece of code, and then rebuild and use that fixed version (and
hopefully send those changes back for integration into future releases).

@node ADE-GCC, ADE-Projects, ADE, ADE mailing lists

@subsection{ADE-GCC}

This mailing list if for discussion of the GNU C compiler, though discuss-
ions of other GNU compilers (such as C++, Objective-C, ADA, and Fortran) are
also appropriate until such time as these tools have their own lists.

If you subscribe to this list, you should also subscribe to the general
ADE list (ade@@ninemoons.com).

@node ADE-Projects, ADE-Ixemul, ADE-GCC, ADE mailing lists

@subsection{ADE-Projects}

This list is for discussion of projects that people are working on related
to the ADE.  This might include, for example, projects to extend various ADE
tools to make them more AmigaDOS friendly, projects to port tools which are
not currently part of the ADE but are intended to become part of it once
ported, etc.  The current projects list can be found at <ftp.amigalib.com:pub/ade/PROJECTS>.

If you are looking for an interesting project to do, and you have not
already been monitoring this list for a while, you should first check the
projects list to see if the project you are interested in is already being
worked on.  If you don't find it there, then post to this list asking if
anyone is already working on something similar or would like to collaborate
on this project.  When you have defined a project to work on and are
reasonably certain of the details of the project, send email to the
maintainer of the projects list so that it can be included in the list.

Note that there may be rewards offered for certain projects that are deemed
to be of importance to the overall evolution of the ADE.

If you subscribe to this list, you should also subscribe to the general
ADE list (ade@@ninemoons.com).

@node ADE-Ixemul, , ADE-Projects, ADE mailing lists

@subsection{ADE-Ixemul}

This list is for discussion of ixemul.library, a Unix emulation library that
fundamental to the ability to run Unix tools on AmigaDOS with few or no
changes at all.  Essentially the library provides almost all of the
functionality of a BSD like kernel and libraries, with the exception of a
few hard to emulate functions like a true fork() routine.

If you subscribe to this list, you should also subscribe to the general
ADE list (ade@@ninemoons.com).

@node    Individuals, You never  it could be a problem in base FSF code, ADE mailing lists, Additional Support



@section  Individuals

@display
Phillipe Brand
Ramses The Amiga Flying BBS - Main AmigaDOS-GNU BBS support site.
I can be reached on fidonet: 2:320/104.0
Phone numbers: +33-1-45845623/53791199/53791200

Fred Fish
fnf@@ninemoons.com

@end display

@node    You never  it could be a problem in base FSF code, , Individuals, Additional Support

@section  You never know, it could be a problem in base FSF code

       You might try subscribing to newsgroups in the gnu.gcc hierarchy.
You might also try ftping some of the code and information from 
@code{<prep.ai.mit.edu>} in /pub/gnu  is the primary archive for the GNU
Project.  If you need the FSF baseline code for something, it'll be there.

@node    Known Bugs, Maintainers and Contributors, Additional Support,  Top 

@chapter  Known Bugs

@menu 

* C compiler:: 

* C++ compiler (g++):: 

* Objective C compiler:: 

@end menu 

@node    C compiler, C++ compiler (g++), , Known Bugs

@section  C compiler

@menu 

* -resident option:: 

* -fbaserel option:: 

* General bugs (not Amiga-specific):: 

@end menu 

@node    -resident option, -fbaserel option, , C compiler

@subsection  -resident option

	    The last version in which this worked was 2.3.3.  Hence, you'll 
need to get that version if you want to compile a program you can easily make 
resident.

 	    Of course, you can always write your code to be resident, it
just takes a little more effort (see above).

	    This problem is fixed in 2.7.0.


@node    -fbaserel option, General bugs (not Amiga-specific), -resident option, C compiler

@subsection  -fbaserel option

	Won't be fixed until the -resident option is (as it's the
cause of the -resident problem).

@node    General bugs (not Amiga-specific), , -fbaserel option, C compiler

@subsection  General bugs (not Amiga-specific)

[Lars Hecking]

 Main g++ development seems to take place at Cygnus. Useful information about
 the current status can be obtained from <URL:http://www.cygnus.com/~mrs>.
 A list of g++-bugs to date is available at
@code{<URL:http://www.cygnus.com/~mrs/g++-bugs/>}


@node    C++ compiler (g++), Objective C compiler, C compiler, Known Bugs

@section  C++ compiler (g++)

[under construction]

@node    Objective C compiler, , C++ compiler (g++), Known Bugs

@section  Objective C compiler

[under construction]


@node    Maintainers and Contributors, Future, Known Bugs,  Top 

@chapter  Maintainers and Contributors
@display

Gcc v2.2.2 port:   Markus Wild
Gcc v2.3.3 port:   Markus Wild
Gcc v2.4.5 port:   Philippe Brand, Lars Hecking, Fred Fish
Gcc v2.5.0 and up: Philippe Brand, Fred Fish, Leonard Norrgard 

Ixemul.library:    Markus Wild, Leonard Norrgard, R. Luebbert, Hans Verukil
Libnix:            Matthias Fleischer, Gunther Nikl

Also, much testing, suggestions and debate have been provided by
Jorg  Hoehle
Peter Ivemey-Cook
Christian Stieber
Walter Harms
Lars Hecking
Kriton Kyrimis
Kamil Iskra
Niklas Hallqvist
Jochen Wiedmann
Thomas Walter
Laurent Perron

   not necessarily in that order.
@end display
 
[ I just compiled this list from looking at the 1995 archive and some of the
'94, whoever consistently either (a) made suggestions and wrote some code
or (b) has been reporting bugs from attempts at compiling GNU software
for a long time (i.e. not someone who's just having problems porting their
favorite package).  If I've left someone out, or if you have a problem
with my criteria, or if you think I should just thank the mailing list as
a whole, mail me].

The present FAQ maintainer is Lynn Winebarger (owinebar@@indiana.edu).
However, you should send corrections to amiga-gcc-port@@nic.funet.fi for
a look over, as that's what I'll do anyway. Flames directed to /dev/null.

@node    Future, History, Maintainers and Contributors,  Top 

@chapter  Future

[under construction]

@node    History, , Future,  Top 

@chapter  History

[under construction]

@node How does the GPL affect programs compiled by GCC? ,,, top
@appendix   How does the GPL affect programs compiled by GCC?

[Niklas Hallqvist]
@quotation
    If I compile one of my sources with gcc, do I have to
 distribute it under the GPL? I'm not using any GNU libraries or
 startup or anything.  My interpretation of the GPL is that i
 don't have to, but one of the teacher (lecturers?) say that I
 have to. Who's right?
@end quotation

You are.  The GPL (and LGPL) only covers distributed code, not code
generated by tools which are GPL:ed. As there are code which get
linked by GCC distributed with GCC, libgcc.a, one might think that the
GPL would apply to generated code, but no, libgcc.a is written without
GPL just to enable that use of the GNU compiler.  Think about it,
several object-only commercial applications including OSes are
compiled by GCC for enhanced performance, would they do that if they
had to give up their objectcode-only policy?  The key behind the GPL
is that no code based on work GPLed, should be locked to to that
specific compilation, but the user should be able to customize the GPLed
code as he wants to and recompile.  You are still allowed to protect
your own source as you see fit.  For example, let's say you use som
LGPLed library libfoo.a in your application app.  When you distribute
it you must also distribute a linkable objectfile app.o which, when
linked with the distibuted libfoo.a (with source) generates app.  If
the end-user wants, he should be able to customize libfoo, and relink
it with app.o to get a customized app.  It's not a very severe
limitation on distribution rights IMHO.

Remember that the (L)GPL was written to give programmers more Freedom,
not to limit their chance of protecting their own work.  As long as
their own work is clearly delimited from others GPLed work, it's
perfectly OK to keep a separate copyright policy on it.

In your case, your lecturer has misunderstood the intentions of the
(L)GPL which is easy to do.  These discussions come up ever so often
because of the legaleze used to express the GPL.  Too bad many get the
GPL wrong, as rumours like "you cannot use GNU products for business
work" severly harms the usage of GNU products.  To name a few uses of
GCC where the program did NOT fall under the GPL:  Dell Unix SVR4,
NextStep & some OSF/1 port.  Tell your lecturer about these, and ask
him why he thinks the GPL prevents them to be sold during other than
GPL conditions?  I ask you to actually convince him he was wrong as it
is harmful for the programming society that such misconceptions exist.

[This is where I'd like to put a list of libraries that are GPLed.]

@node GNU Porting activities and who dealing with them ,,, top
@appendix   GNU Porting activities and who dealing with them

[Not really GCC (Which is why it's an Appendix), but certainly one of
GCC's main uses.
      It would be good to keep track of these things anyway, in case someone
wants to start working on porting something (just as administratvia).]

@node Another Free C compiler (for those without much memory) ,,, top
@appendix   Another Free C compiler (for those without much memory)

   Warning, apparently lcc is not yet fully ported (no backend) for easy
use.

[Fred Fish]

> > One of the things I hope to eventually add to my FreshFish CD is a
> > port of lcc, which is much smaller and faster than gcc, and apparently
> > somewhat more ANSI compliant.  I just haven't had time yet to look
> > at doing so.
> 
> What's lcc? I never heard of it.

============================ begin inclusion ===========================

lcc is the retargetable compiler for ANSI C described in our book
`A Retargetable C Compiler: Design and Implementation'
(Benjamin Cummings, 1995, ISBN 0-8053-1670-1), which will be available
in December 1994. lcc is in production use at Princeton University and
AT&T Bell Laboratories.

The public distribution directory contains the following files.

README	this file.

install.{ps,txt}
	describes the distribution and gives installation
	instructions. install.ps is the PostScript generated from
	the HTML document, install.html, which is included in the
	the distribution.

X.Y.tar.{Z,gz}
	a compressed tar files for the distribution of version X.Y,
	e.g., 3.0.tar.Z the tar file compressed with compress. This
	distribution includes user documentation, the front end, the
	driver program, code generators for the SPARC, MIPS R3000 and
	x86, and the code-generator generator that produced them. A
	.gz file is the tar file compressed with gzip instead
	of compress.

The distribution is available via `anonymous' ftp from
ftp.cs.princeton.edu (128.112.152.13) in the directory pub/lcc.
Obtaining and extracting the distribution into its own directory is
accomplished by the following commands. Replace `3.0' with the latest
version, which is the only one typically available; versions like
`3.0a' identify minor updates and versions like `3.1beta' identify
pre-releases (which might be incomplete). As suggested, use your login
as the password, and use ftp's binary transfer mode.

mkdir lcc
cd lcc
ftp ftp.cs.princeton.edu
anonymous
yourlogin
cd pub/lcc
binary
get 3.0.tar.Z dist.tar.Z
quit
zcat dist.tar | tar xpof -
rm dist.tar.Z

To be added to the lcc mailing list, send a message with the 1-line body

subscribe lcc

to majordomo@@cs.princeton.edu. This line must appear in the message
body; `Subject:' lines are ignored. To learn more about mailing lists
served by majordomo, send a message with the body `help' to
majordomo@@cs.princeton.edu.

Additional information about lcc and about our book is available on the
WWW at URL http://www.cs.princeton.edu/software/lcc.


Chris Fraser / cwf@@research.att.com
David Hanson / drh@@cs.princeton.edu
Thu Aug 18 13:36:15 EDT 1994



[
@shortcontents

@contents

@bye
