@database fd2inline.guide

@Master /ade-src/my/fd2inline-1.11/fd2inline.texi

@Width 72


This is the AmigaGuide®  file fd2inline.guide, produced by Makeinfo-1.67 from 
the input file /ade-src/my/fd2inline-1.11/fd2inline.texi.

   This is a user's guide to FD2Inline 1.11, a parser converting FD
files to GCC "inlines".

   Copyright (C) 1996, 1997 Kamil Iskra

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


@Node Main "fd2inline.guide"
@Next "Introduction"

   This is a user's guide to @{b}FD2Inline@{ub} 1.11, a parser that converts the
AmigaOS shared library @{b}FD@{ub} files to format accepted by the @{b}GNU CC@{ub}.

   See file @{b}COPYING@{ub} for the GNU General Public License.

   Last updated January 31st, 1997.


 @{" Introduction              " Link "Introduction"}  What is this program for?
 @{" Installation              " Link "Installation"}  How to install it?
 @{" Usage                     " Link "Usage"}  How to use @{b}inlines@{ub} and @{b}FD2InLine@{ub}?
 @{" Rebuilding                " Link "Rebuilding"}  How to recompile it?
 @{" Internals                 " Link "Internals"}  How do @{b}inlines@{ub} work?
 @{" History                   " Link "History"}  What has changed?
 @{" Authors                   " Link "Authors"}  Who wrote it?

 @{" Index                     " Link "Index"}  Concept index.


@EndNode

@Node "Introduction" "fd2inline.guide/Introduction"
@Next "Installation"
@Prev "Main"
@Toc "Main"

Introduction
************

   @{b}FD2InLine@{ub} is useful if you want to use @{b}GCC@{ub} for AmigaOS-specific
development and would like to call the functions in the AmigaOS shared
libraries efficiently.

   The format of calls to the AmigaOS shared library functions differs
substantially from the default function call format of C compilers (see
@{"Background" Link "Background"}). Therefore, some tricks are necessary if you want to use
these functions.

   @{b}FD2InLine@{ub} is a parser that converts @{b}fd@{ub} files and @{b}clib@{ub} files to @{b}GCC
inlines@{ub}.

   @{b}fd@{ub} and @{b}clib@{ub} files contain information about functions in shared
libraries (see @{"Background" Link "Background"}).

   @{b}FD2InLine@{ub} reads these two files and merges the information contained
therein, producing an output file suitable for use with the @{b}GCC@{ub}
compiler.

   This output file contains so-called @{i}inlines@{ui} -- one for each function
entry. Using them, @{b}GCC@{ub} can produce very efficient code for making
function calls to the AmigaOS shared libraries.

     @{i}Note:@{ui} the term @{b}inlines@{ub} is misleading -- @{b}FD2InLine@{ub} no longer uses
     the @{b}__inline@{ub} feature of @{b}GCC@{ub} (see @{"New format" Link "New format"}).


@EndNode

@Node "Installation" "fd2inline.guide/Installation"
@Next "Usage"
@Prev "Introduction"
@Toc "Main"

Installation
************

   The following assumes you have the @{b}fd2inline-1.11-bin.lha@{ub} archive.

   If you use a recent release of @{b}GCC@{ub}, you might not need to install
anything. Starting with @{b}GCC@{ub} 2.7.2, the new format (see @{"New format" Link "New format"}) of
@{b}inlines@{ub} should be available with the compiler. However, the separate
@{b}fd2inline-1.11-bin.lha@{ub} archive will always contain the latest
version of @{b}FD2InLine@{ub} and the @{b}inlines@{ub}, which might not be the true for
the @{b}ADE@{ub} or @{b}Aminet@{ub} distributions. @{b}ADE@{ub} distribution might not contain
some of the supported 3rd party libraries' @{b}inlines@{ub}.

   The installation is very easy, so there is no Installer script :-).

   If you have an older version of the @{b}inlines@{ub} installed, please remove
it now, or you might encounter problems later. Typically, you will have
to remove the following subdirectories of the @{b}os-include@{ub} directory:
@{b}inline@{ub}, @{b}pragmas@{ub} and @{b}proto@{ub}.

   Next, please change your current directory to @{b}ADE:@{ub} (or @{b}GNU:@{ub}, if you
use old @{b}Aminet@{ub} release) and simply unpack the @{b}fd2inline-1.11-bin.lha@{ub}
archive. This should install everything in the right place. More
precisely, the headers will go to the @{b}include@{ub} directory, the libraries
to @{b}lib@{ub}, @{b}fd2inline@{ub} executable to @{b}bin@{ub} directory and the @{b}AmigaGuide@{ub}
documentation to the @{b}guide@{ub} directory.


@EndNode

@Node "Usage" "fd2inline.guide/Usage"
@Next "Rebuilding"
@Prev "Installation"
@Toc "Main"

Usage
*****

   This chapter describes two aspects of using @{b}FD2InLine@{ub}:


 @{" Using inlines             " Link "Using inlines"}  Making efficient function calls.
 @{" Using fd2inline           " Link "Using fd2inline"}  Creating @{b}inlines@{ub}.


@EndNode

@Node "Using inlines" "fd2inline.guide/Using inlines"
@Next "Using fd2inline"
@Prev "Usage"
@Toc "Usage"

Using inlines
=============

   Using @{b}inlines@{ub} is very simple. If you want to use a library called
@{b}foo.library@{ub} (or a device called @{b}bar.device@{ub}), simply include file
@{b}<proto/foo.h>@{ub} (@{b}<proto/bar.h>@{ub}) and that's it. For example:

     #include <proto/dos.h>
     
     int main(void)
     {
        Delay(100); /* Wait for 2 seconds */
     }

   Please @{i}always@{ui} include @{b}proto@{ub} files, @{i}not@{ui} @{b}inline@{ub} files - @{b}proto@{ub} files
often fix some incompatibilities between system headers and @{b}GCC@{ub}.
Besides, this technique makes your code more portable across various
AmigaOS @{b}C@{ub} compilers.

   There are a few preprocessor symbols which alter the behaviour of the
@{b}proto@{ub} and @{b}inline@{ub} files:

@{b}__NOLIBBASE__@{ub}
     By default, the @{b}proto@{ub} files make external declarations of the
     library base pointers. You can disable this behaviour by defining
     @{b}__NOLIBBASE__@{ub} before including a @{b}proto@{ub} file.

@{b}__CONSTLIBBASEDECL__@{ub}
     The external declarations described above declare plain pointer
     variables. The disadvantage of this is that the library base
     variable has to be reloaded every time some function is called. If
     you define @{b}__CONSTLIBBASEDECL__@{ub} to @{b}const@{ub}, less reloading will be
     necessary, and better code will be produced. However, declaring a
     variable as @{b}const@{ub} makes altering it impossible, so some dirty
     hacks are necessary (like defining the variable as plain in one
     file and altering it only there. However, this will @{i}not@{ui} work with
     base relative code).

@{b}<library>_BASE_NAME@{ub}
     Function definitions in the @{b}inline@{ub} files refer to the library base
     variable through the @{b}<library>_BASE_NAME@{ub} symbol (e.g.,
     @{b}AMIGAGUIDE_BASE_NAME@{ub} for @{b}amigaguide.library@{ub}). At the top of
     the @{b}inline@{ub} file, this symbol is redefined to the appropriate
     library base variable name (e.g., @{b}AmigaGuideBase@{ub}), @{i}unless@{ui} it has
     been already defined. This way, you can make the @{b}inlines@{ub} use a
     field of a structure as a library base, for example.

@{b}NO_INLINE_STDARG@{ub}
     This symbol prevents the definition of inline macros for varargs
     functions (see @{"Old format" Link "Old format"}).

@{b}_USEOLDEXEC_@{ub}
     This symbol is used only in @{b}proto/exec.h@{ub}. Unlike @{b}SAS/C@{ub},
     @{b}proto/exec.h@{ub} uses the @{b}SysBase@{ub} variable as the @{b}Exec@{ub} library
     base by default. This is usually faster than direct dereferencing
     of @{b}0x00000004@{ub} (see @{"Background" Link "Background"}), since it does not require reading
     from @{b}CHIP@{ub} memory (things might be even worse if you use @{b}Enforcer@{ub}
     or @{b}CyberGuard@{ub}, which protect the low memory region). However, in
     some low-level cases (like startup code) you might prefer
     dereferencing @{b}0x00000004@{ub}. To do this, define @{b}_USEOLDEXEC_@{ub} before
     including @{b}proto/exec.h@{ub}.


@EndNode

@Node "Using fd2inline" "fd2inline.guide/Using fd2inline"
@Prev "Using inlines"
@Toc "Usage"

Using fd2inline
===============

   You invoke @{b}FD2InLine@{ub} by writing:

     @{b}fd2inline@{ub} [options] @{I}FD-FILE@{ui} @{I}CLIB-FILE@{ui} [[-o] @{I}OUTPUT-FILE@{ui}]

   The command line arguments have the following meaning:

@{I}FD-FILE@{ui}
     The name of the input @{b}fd@{ub} file.

@{I}CLIB-FILE@{ui}
     The name of the input @{b}clib@{ub} file.

@{I}OUTPUT-FILE@{ui}
     The name of the output @{b}inline@{ub} file. If it is not specified (or if
     @{b}-@{ub} is specified), standard output will be used instead. The
     file name can be preceded by a @{b}-o@{ub}, for compatibility with most
     @{b}UN*X@{ub} software.

   The following options can be specified (anywhere on the command
line):

@{b}--new@{ub}
     Produce new format @{b}inlines@{ub}.

@{b}--old@{ub}
     Produce old format @{b}inlines@{ub}.

@{b}--stubs@{ub}
     Produce library stubs.

@{b}--proto@{ub}
     Produce @{b}proto@{ub} file. If this option is specified, providing @{b}clib@{ub}
     file is not necessary. @{b}fd2inline@{ub} will only read @{b}fd@{ub} file and will
     generate a @{b}proto@{ub} file, to be put in @{b}include/proto@{ub} directory.

@{b}--version@{ub}
     Print version information and exit.

   See @{"Internals" Link "Internals"}, for more information.

   Example:

     fd2inline ADE:os-lib/fd/exec_lib.fd ADE:os-include/clib/exec_protos.h -o ADE:include/inline/exec.h

   This will build file @{b}exec.h@{ub} containing new format @{b}inlines@{ub} of
@{b}exec.library@{ub} in directory @{b}ADE:include/inline@{ub}.

   If you want to add support for @{b}GCC@{ub} to a library, there are a few
things you should remember about.

   Sometimes, @{b}FD2InLine@{ub} might not know how to handle a function found
in a @{b}clib@{ub} file, if this function doesn't have a corresponding entry in
the @{b}fd@{ub} file. This is most often a case of @{b}varargs@{ub} functions (see
@{"Background" Link "Background"}), if they use nonstandard naming convention. @{b}FD2InLine@{ub} will
warn you if it finds such a function. There is an array of such
exceptions in @{b}FD2InLine@{ub} source code. You should add the name of this
function there and send a patch to @{b}FD2InLine@{ub} maintainer (see @{"Authors" Link "Authors"}),
for inclussion in the next release of @{b}FD2InLine@{ub}.

   @{b}FD2InLine@{ub} assumes that the type of the base variable is @{b}struct
Library *@{ub}. If it is something different in your case, you should extend
an array of exceptions in @{b}FD2InLine@{ub} source code (see above).

   @{b}FD2InLine@{ub} handles @{b}void@{ub} functions in a special way. It recognizes
them by the return value -- it has to be @{b}void@{ub} (the case is not
significant). If a @{b}clib@{ub} file uses a different convention, it has to be
modified before running @{b}FD2InLine@{ub}.

   In addition to creating @{b}inlines@{ub} you must also create a @{b}proto@{ub} file.

   The easiest way to do it is to call @{b}FD2InLine@{ub} with @{b}--proto@{ub} option.
Most often, the generated file will be ready to use. Unfortunately,
some libraries (like, for example, @{b}dos.library@{ub}) have broken header
files and @{b}GCC@{ub} generates warning messages if you try to use them. To
avoid these warnings, you have to include various headers in the @{b}proto@{ub}
file before including the @{b}clib@{ub} file.

   You might also want to create a @{b}pragmas@{ub} file, which might be
necessary for badly written @{b}SAS/C@{ub} sources. @{b}pragmas@{ub} are generated
automatically during the building of @{b}FD2InLine@{ub} by an @{b}AWK@{ub} script, so you
might either have a look at the @{b}fd2inline-1.11-src.lha@{ub} archive, or
simply create @{b}pragmas@{ub} file by hand.

   Creating a linker library with stubs might also be useful, in case
somebody doesn't want to, or can't, use inline headers.

   @{b}fd2inline-1.11-src.lha@{ub} contains necessary support for this. For
example, to generate a library @{b}libexec.a@{ub} with @{b}exec.library@{ub} stubs, you
should type:

     make alllib INCBASE=exec LIBBASE=exec

   This will create three @{b}libexec.a@{ub} libraries in @{b}lib@{ub} subdirectory:
plain, base relative and 32-bit base relative one. Of course, this
particular example doesn't make much sense since @{b}libamiga.a@{ub} already
contains these stubs.

   @{b}INCBASE@{ub} and @{b}LIBBASE@{ub} specify the base names of the (input) @{b}proto@{ub} and
@{b}fd@{ub} files and the (output) library.  This will often be the same,
but not always. For example, in the case of @{b}MUI@{ub}, @{b}INCBASE@{ub} has to be set
to @{b}muimaster@{ub}, but @{b}LIBBASE@{ub} should be set to @{b}mui@{ub}.


@EndNode

@Node "Rebuilding" "fd2inline.guide/Rebuilding"
@Next "Internals"
@Prev "Usage"
@Toc "Main"

Rebuilding
**********

   First, you have to get the @{b}fd2inline-1.11-src.lha@{ub} archive.

   Unarchive it. You might either build @{b}FD2InLine@{ub} in source directory
or in a separate, build directory. The latter is recommended. Type:

     lha -mraxe x fd2inline-1.11-src.lha
     mkdir fd2inline-bin
     cd fd2inline-bin
     sh ../fd2inline-1.11/configure --prefix=/ade
     make

   This should build the @{b}FD2InLine@{ub} executable, headers, libraries and
so on.

   Please note that the @{b}fd@{ub} files should be available in the directory
@{b}ADE:os-lib/fd@{ub}. If you store them in some other place, you will have
to edit the @{b}Makefile@{ub} and modify variable @{b}FD_DIR@{ub} before invoking @{b}make@{ub}.

   You can then type:

     make install

   This will install @{b}fd2inline@{ub}, the @{b}inlines@{ub} and the documentation in
the appropriate subdirectories of @{b}ADE:@{ub}.

   The @{b}fd2inline-1.11-src.lha@{ub} archive contains four patches in unified
diff format, in directory @{b}patches@{ub}. They fix bugs in OS 3.1 headers and
@{b}fd@{ub} files. Without applying @{b}amigaguide_lib.fd.diff@{ub} to
@{b}amigaguide.library@{ub} @{b}fd@{ub} file, the produced @{b}inlines@{ub} will be broken.
Applying @{b}timer.h.diff@{ub} to @{b}devices/timer.h@{ub} will prevent collision with
IXEmul's @{b}sys/time.h@{ub}. Two other patches rename an argument name from
@{b}true@{ub} to @{b}tf@{ub}, since @{b}true@{ub} is a reserved word in @{b}C++@{ub}. Use @{b}patch@{ub} to
apply these patches, for example:

     cd ADE:os-lib/fd
     patch -p0 <amigaguide_lib.fd.diff

   @{b}ADE@{ub} and @{b}Aminet@{ub} distributions contain more complete sets of patches.

   A few words about the source code:

   I know, it's not state-of-the-art @{b}C@{ub} programming example.  However,
believe me, it was in @{i}much@{ui} worse condition when I took it over. In its
current state it is at least readable (if you use tab size 3, as I do
:-). I think that rewriting it in @{b}C++@{ub} would clean it up considerably
(it's already written in @{b}OO@{ub} fashion, so this should be quite easy).
Using @{b}flex@{ub} and @{b}bison@{ub} to create the parser would also be a nice thing, I
guess. However, I don't think it's worth the effort. But, if somebody
wants to do it: feel free, this is @{b}GNU@{ub} software, so everybody can
modify it.


@EndNode

@Node "Internals" "fd2inline.guide/Internals"
@Next "History"
@Prev "Rebuilding"
@Toc "Main"

Internals
*********

   This chapter describes the implementation details of @{b}inlines@{ub}.


 @{" Background                " Link "Background"}  Function calls in shared libraries.
 @{" Old format                " Link "Old format"}  Inlines that use @{b}__inline@{ub}.
 @{" New format                " Link "New format"}  Inlines that use the preprocessor.
 @{" Stubs format              " Link "Stubs format"}  Not really inlines, but...


@EndNode

@Node "Background" "fd2inline.guide/Background"
@Next "Old format"
@Prev "Internals"
@Toc "Internals"

Background
==========

   This section describes the calling conventions used in the AmigaOS
shared libraries.

   User-callable functions in the AmigaOS are organized in @{i}libraries@{ui}.

   From our point of view, the most important part of a library is the
@{i}library base@{ui}. It always resides in RAM and contains library
variables and a @{i}jump table@{ui}. The location of the library base varies.
You can obtain the library base location of the main system library --
@{b}exec.library@{ub} -- by dereferencing @{b}0x00000004@{ub}. Locations of other
library bases can be obtained using the @{b}OpenLibrary@{ub} function of
@{b}exec.library@{ub}.

   Without providing unnecessary details, every function in a library
has a fixed location in the library's jump table. To call a function,
one has to jump to this location.

   Most functions require some arguments. In @{b}C@{ub}, these are usually
passed on the CPU stack. However, for some obscure reason, AmigaOS
system designers decided that arguments to shared libraries should be
passed in CPU registers.

   All the information required to make library function calls is
provided in @{i}fd@{ui} files. Every shared library should have such a file. It
provides the name a library base variable should have, the offset in
the jump table where each library function resides, and information
about which arguments should be passed in which registers.

   In order to check if arguments passed to a function have the correct
type, the @{b}C@{ub} compiler requires function prototypes. These are provided
in @{i}clib@{ui} files -- every library should have such a file.

   Starting with the AmigaOS release 2.0, certain functions have been
provided which accept a variable number of arguments (so-called @{i}varargs
functions@{ui}). Actually, these are only @{b}C@{ub} language stubs. Internally, all
optional arguments have to be put into an array of @{b}long ints@{ub} and the
address of this array must be passed to a fixed args library function.

   To implement calls to shared library functions, compiler vendors have
to either use some compiler-dependent tricks to make these calls
directly (so-called @{i}in line@{ui}), or provide linker libraries with function
stubs, usually written in assembler. In the latter case, a function
call from the user's code is compiled as usual -- arguments are passed
on the stack. Then, in the linking stage, a library stub gets linked
in. When this stub is called during program execution, it moves the
arguments from the stack to the appropriate registers and jumps to the
library jump table. Needless to say, this is slower than making a call
in line.


@EndNode

@Node "Old format" "fd2inline.guide/Old format"
@Next "New format"
@Prev "Background"
@Toc "Internals"

Old format
==========

     extern __inline APTR
     OpenAmigaGuideA(BASE_PAR_DECL struct NewAmigaGuide *nag, struct TagItem *attrs)
     {
        BASE_EXT_DECL
        register APTR res __asm("d0");
        register struct Library *a6 __asm("a6") = BASE_NAME;
        register struct NewAmigaGuide *a0 __asm("a0") = nag;
        register struct TagItem *a1 __asm("a1") = attrs;
        __asm volatile ("jsr a6@(-0x36:W)"
        : "=r" (res)
        : "r" (a6), "r" (a0), "r" (a1)
        : "d0", "d1", "a0", "a1", "cc", "memory");
        return res;
     }

   In this implementation, the AmigaOS shared library function stubs are
external functions. They are defined as @{b}__inline@{ub}, making @{b}GCC@{ub} insert
them at every place of call. The mysterious @{b}BASE_PAR_DECL@{ub} and
@{b}BASE_EXT_DECL@{ub} defines are hacks necessary for local library base
support (which is quite hard to achieve, so it will not be described
here). The biggest disadvantage of these @{b}inlines@{ub} is that compilation
becomes very slow, requiring huge amounts of memory. Besides, inlining
only works with optimization enabled.

     #ifndef NO_INLINE_STDARG
     #define OpenAmigaGuide(a0, tags...) \\
        ({ULONG _tags[] = { tags }; OpenAmigaGuideA((a0), (struct TagItem *)_tags);})
     #endif /* !NO_INLINE_STDARG */

   The source above shows how @{b}varargs@{ub} functions are implemented.
Handling them cannot be made using @{b}__inline@{ub} functions, since @{b}__inline@{ub}
functions require a fixed number of arguments.  Therefore, the unique
features of the @{b}GCC@{ub} preprocessor (such as @{b}varargs macros@{ub}) have to be
used, instead. This has some drawbacks, unfortunately. Since these are
actually preprocessor macros and not function calls, you cannot make
tricky things involving the preprocessor inside them. For example:

     #include <proto/amigaguide.h>
     
     #define OPENAG_BEG OpenAmigaGuide(
     #define OPENAG_END , TAG_DONE)
     
     void f(void)
     {
        OPENAG_BEG "a_file.guide" OPENAG_END;
        OpenAmigaGuide(
     #ifdef ABC
           "abc.guide",
     #else
           "def.guide",
     #endif
           TAG_DONE);
     }

   Neither of the above @{b}OpenAmigaGuide()@{ub} calls is handled correctly.

   In the case of the first call, you get an error:

     unterminated macro call

   By the time the preprocessor attempts to expand the @{b}OpenAmigaGuide@{ub}
macro, @{b}OPENAG_END@{ub} is not yet expanded, so the preprocessor cannot find
the closing bracket. This code might look contrived, but @{b}MUI@{ub}, for
example, defines such macros to make code look more pretty.

   In the case of the second call, you'll see:

     warning: preprocessing directive not recognized within macro arg

   A workaround would be to either surround entire function calls with
conditions, or to conditionally define a preprocessor symbol @{b}GUIDE@{ub}
somewhere above and simply put @{b}GUIDE@{ub} as a function argument:

     #ifdef ABC
     #define GUIDE "abc.guide"
     #else
     #define GUIDE "def.guide"
     #endif
     
     void f(void)
     {
     #ifdef ABC
        OpenAmigaGuide("abc.guide", TAG_DONE);
     #else
        OpenAmigaGuide("def.guide", TAG_DONE);
     #endif
        OpenAmigaGuide(GUIDE, TAG_DONE);
     }

   Another problem is that when you pass a pointer as an argument, you
get a warning:

     warning: initialization makes integer from pointer without a cast

   This is because all optional arguments are put as initializers to an
array of @{b}ULONG@{ub}. And, if you attempt to initialize an @{b}ULONG@{ub} with a
pointer without a cast, you get a warning. You can avoid it by explicit
casting of all pointer arguments to @{b}ULONG@{ub}.

   Because of these drawbacks, @{b}varargs inlines@{ub} can be disabled by
defining @{b}NO_INLINE_STDARG@{ub} before including a @{b}proto@{ub} file.  In such a
case, you will need a library with function stubs.


@EndNode

@Node "New format" "fd2inline.guide/New format"
@Next "Stubs format"
@Prev "Old format"
@Toc "Internals"

New format
==========

     #define OpenAmigaGuideA(nag, attrs) \\
        LP2(0x36, APTR, OpenAmigaGuideA, struct NewAmigaGuide *, nag, a0, struct TagItem *, attrs, a1, \\
        , AMIGAGUIDE_BASE_NAME)

   As you can see, this implementation is much more compact. The @{b}LP2@{ub}
macro (and others) are defined in @{b}inline/macros.h@{ub}, which is included at
the beginning of every @{b}inline@{ub} file.

     #define LP2(offs, rt, name, t1, v1, r1, t2, v2, r2, bt, bn) \\
     ({							\\
        t1 _##name##_v1 = (v1);				\\
        t2 _##name##_v2 = (v2);				\\
        {							\\
           register rt _##name##_re __asm("d0");		\\
           register struct Library *const _##name##_bn __asm("a6") = (struct Library*)(bn);\\
           register t1 _n1 __asm(#r1) = _##name##_v1;	\\
           register t2 _n2 __asm(#r2) = _##name##_v2;	\\
           __asm volatile ("jsr a6@(-"#offs":W)"		\\
           : "=r" (_##name##_re)				\\
           : "r" (_##name##_bn), "r"(_n1), "r"(_n2)		\\
           : "d0", "d1", "a0", "a1", "cc", "memory");	\\
           _##name##_re;					\\
        }							\\
     })

   If you compare this with the old @{b}inlines@{ub} (see @{"Old format" Link "Old format"}) you will
notice many similarities. Indeed, both implementations use the same
tricks. This means that there should be small, if any, difference in
code quality between old and new @{b}inlines@{ub}.

   With the new @{b}inlines@{ub}, however, inlining is performed very early, at
the preprocessing stage. This makes compilation much faster, less
memory hungry, and independent of the optimization options used.  This
also makes it very easy to use local library bases -- all that is
needed is to define a local variable with the same name as library base.

   Unfortunately, using the preprocessor instead of the compiler for
making function calls has its drawbacks, as described earlier (see
@{"Old format" Link "Old format"}). There is not much you can do about it apart from modifying
your code.

   Depending on the type of a function, @{b}FD2InLine@{ub} generates calls to
different @{b}LP@{ub} macros.

   Macros are distinguished by one or more of the qualifiers described
below:

@{b}digit@{ub}
     As you may have already guessed, digit indicates the number of
     arguments a function accepts. Therefore, it is mandatory.

@{b}NR@{ub}
     This indicates a "no return" (@{b}void@{ub}) function.

@{b}A4, A5@{ub}
     These two are used when one of the arguments has to be in either
     the @{b}a4@{ub} or @{b}a5@{ub} register. In certain situations, these registers have
     special meaning and have to be handled more carefully.

@{b}UB@{ub}
     This indicates "user base" -- the library base pointer has to be
     specified explicitly by the user. Currently, this is used for
     @{b}cia.resource@{ub} only. Since there are two @{b}CIA@{ub} chips, the
     programmer has to specify which one [s]he wants to use.

@{b}FP@{ub}
     This means that one of the arguments is of type "pointer to a
     function". To overcome strange @{b}C@{ub} syntax rules in this case, inside
     @{b}FP@{ub} macros a @{b}typedef@{ub} to @{b}__fpt@{ub} is performed.  The @{b}inline@{ub} file
     passes @{b}__fpt@{ub} as the argument type to the @{b}LP@{ub} macro. The actual type
     of the argument, in a form suitable for a @{b}typedef@{ub}, is passed as an
     additional, last argument.

   As you can see, there could be more than a hundred different
variations of the @{b}LP@{ub} macros. @{b}inline/macros.h@{ub} contains only 34, which
are used in the current OS version and supported 3rd party libraries.
More macros will be added in the future, if needed.

   If you look carefully at the definition of @{b}OpenAmigaGuideA@{ub} at the
beginning of this section, you might notice that the next to last
argument to the @{b}LP@{ub} macro is not used. New @{b}inlines@{ub} were not implemented
in one evening, and they went through many modifications. This unused
argument (which was once a type of library base pointer) is provided
for backwards compatibility. Actually, there are more unnecessary
arguments, like function and argument names, but it was decided to
leave them in peace.


@EndNode

@Node "Stubs format" "fd2inline.guide/Stubs format"
@Prev "New format"
@Toc "Internals"

Stubs format
============

   Stubs format is very similar to old format (see @{"Old format" Link "Old format"}). The
functions are not defined as @{b}extern@{ub}, however.

   The main difference is the format of the @{b}varargs@{ub} functions -- they
are plain functions, not preprocessor macros.

     APTR OpenAmigaGuide(struct NewAmigaGuide *nag, int tag, ...)
     {
        return OpenAmigaGuideA(nag, (struct TagItem *)&tag);
     }

   This format is not suitable for inlining, and it is not provided for
this purpose. It is provided for the building of linker libraries with
stubs (see @{"Using fd2inline" Link "Using fd2inline"}).


@EndNode

@Node "History" "fd2inline.guide/History"
@Next "Authors"
@Prev "Internals"
@Toc "Main"

History
*******

   Version 1.0,  July 14th, 1996,  Kamil Iskra
   @{b}*@{ub} First officially available version.

   Version 1.1,  October 24th, 1996,  Kamil Iskra
   @{b}*@{ub} Removed a lot of language mistakes from the documentation (Kriton
     Kyrimis).

   @{b}*@{ub} Inlines of @{b}dospath.library@{ub}, @{b}screennotify.library@{ub}, @{b}ums.library@{ub} and
     @{b}wbstart.library@{ub} integrated (Martin Steigerwald).

   @{b}*@{ub} Inlines of @{b}muimaster.library@{ub} integrated (Kamil Iskra).

   @{b}*@{ub} Floating point registers @{b}fp0@{ub} and @{b}fp1@{ub} are now marked as clobbered
     (Kamil Iskra, reported by Kriton Kyrimis).

   @{b}*@{ub} Improved handling of @{b}clib@{ub} files, particularly recognition of
     function prototypes and varargs functions (Kamil Iskra).

   @{b}*@{ub} Added support for @{b}--proto@{ub} and @{b}--version@{ub} options. Minor changes in
     output file generators, most notably making @{b}proto@{ub} files work with
     other compilers than @{b}GCC@{ub}, too. Finalized support for building
     linker libraries (Kamil Iskra, change in @{b}proto@{ub} files suggested by
     Joop van de Wege).

   Version 1.11,  January 31st, 1997,  Kamil Iskra
   @{b}*@{ub} Minor fixes in @{b}Makefile.in@{ub} for @{b}ADE@{ub} tree (Fred Fish).

   @{b}*@{ub} Fixed handling of prototypes in which the argument name was the
     same as the type name (Kamil Iskra, reported by Martin
     Recktenwald).

   @{b}*@{ub} Added support for building 32-bit base relative linker libraries
     (Kamil Iskra).

   @{b}*@{ub} Added a paragraph about @{b}void@{ub} functions (Kamil Iskra, suggested by
     Martin Recktenwald).


@EndNode

@Node "Authors" "fd2inline.guide/Authors"
@Next "Index"
@Prev "History"
@Toc "Main"

Authors
*******

   The first parser for @{b}GCC inlines@{ub} was written in @{b}Perl@{ub} by Markus Wild.

   It had several limitations, which were apparently hard to fix in
@{b}Perl@{ub}. This is why Wolfgang Baron decided to write a new parser
in @{b}C@{ub}.

   For some reason, however, he never finished it. In early 1995. Rainer
F. Trunz took over its development and "improved, updated, simply made
it workable" (quotation from the change log). It still contained quite
a few bugs, though.

   In more-or-less the same time, I started a discussion on the
@{b}amiga-gcc-port@{ub} mailing list about improving the quality of @{b}inlines@{ub}.
The most important idea came from Matthias Fleischer, who introduced
the new format of @{b}inlines@{ub} (see @{"New format" Link "New format"}).  Since I started the
discussion, I volunteered to make improvements to the @{b}inlines@{ub} parser.
Having no idea about programming in @{b}Perl@{ub}, I decided to modify the
parser written in @{b}C@{ub}. I fixed all the bugs known to me, added some new
features, and wrote this terribly long documentation :-).

   Not all of the files distributed in the @{b}FD2InLine@{ub} archives were
created by me or @{b}FD2InLine@{ub}. Most of the files in @{b}include/proto-src@{ub} and
@{b}include/inline-src@{ub} (@{b}alib.h@{ub}, @{b}strsub.h@{ub} and @{b}stubs.h@{ub}) were written by
Gunther Nikl (with some modifications by Joerg Hoehle and me).

   If you have any comments concerning this work, please write to:

   ade-gcc@ninemoons.com

   This is a list to which most of the @{b}ADE GCC@{ub} developers and activists
subscribe, so you are practically guaranteed to get a reply.

   However, if, for some reason, you want to contact me personally, you
can do so in one of the following ways:

   @{b}*@{ub} E-mail (preferred :-):

     iskra@student.uci.agh.edu.pl

     Should be valid until October 1999 (at least I hope so :-).

   @{b}*@{ub} Snail-mail (expect to wait long for a reply :-):

     Kamil Iskra
     Luzycka 51/258
     30-658 Krakow
     Poland

   Latest version of this package should always be available on my WWW
page:

http://student.uci.agh.edu.pl/~iskra


@EndNode

@Node "Index" "fd2inline.guide/Index"
@Prev "Authors"
@Toc "Main"

Index
*****

@Index "Index"



 @{" <library>_BASE_NAME                      " Link "Using inlines"}   Using inlines
 @{" __CONSTLIBBASEDECL__                     " Link "Using inlines"}   Using inlines
 @{" __NOLIBBASE__                            " Link "Using inlines"}   Using inlines
 @{" _USEOLDEXEC_                             " Link "Using inlines"}   Using inlines
 @{" Address                                  " Link "Authors"}   Authors
 @{" Authors                                  " Link "Authors"}   Authors
 @{" Background                               " Link "Background"}   Background
 @{" CLIB files                               " Link "Background"}   Background
 @{" Creating inlines                         " Link "Using fd2inline"}   Using fd2inline
 @{" FD files                                 " Link "Background"}   Background
 @{" Function arguments                       " Link "Background"}   Background
 @{" Function calls format in shared libraries " Link "Background"}   Background
 @{" History                                  " Link "History"}   History
 @{" Installation                             " Link "Installation"}   Installation
 @{" Internals                                " Link "Internals"}   Internals
 @{" Introduction                             " Link "Introduction"}   Introduction
 @{" Jump table                               " Link "Background"}   Background
 @{" Latest version                           " Link "Authors"}   Authors
 @{" Libraries                                " Link "Background"}   Background
 @{" Library base                             " Link "Background"}   Background
 @{" Linker libraries                         " Link "Background"}   Background
 @{" Making efficient calls                   " Link "Using inlines"}   Using inlines
 @{" New inlines format                       " Link "New format"}   New format
 @{" Old inlines format                       " Link "Old format"}   Old format
 @{" Other parsers                            " Link "Authors"}   Authors
 @{" Preprocessor symbols                     " Link "Using inlines"}   Using inlines
 @{" Rebuilding                               " Link "Rebuilding"}   Rebuilding
 @{" Reporting bugs                           " Link "Authors"}   Authors
 @{" Source code                              " Link "Rebuilding"}   Rebuilding
 @{" Stubs inlines format                     " Link "Stubs format"}   Stubs format
 @{" Usage                                    " Link "Usage"}   Usage
 @{" Using FD2Inline                          " Link "Using fd2inline"}   Using fd2inline
 @{" Using inlines                            " Link "Using inlines"}   Using inlines
 @{" Varargs functions                        " Link "Background"}   Background
 @{" Varargs problems                         " Link "Old format"}   Old format
 @{" What FD2InLine is                        " Link "Introduction"}   Introduction
 @{" What has changed                         " Link "History"}   History
 @{" Where to put it                          " Link "Installation"}   Installation

@EndNode

