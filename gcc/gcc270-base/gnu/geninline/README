This is the third release of the inline header generator. See the 
changelog entries at the start of conv.p.

**************************************************************************

The converter `conv.p' included in this package is free software; you can
redistribute it and/or modify it under the terms of the GNU General Public
License as published by the Free Software Foundation; either version 2, or
(at your option) any later version.

conv.p is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
details.

You should have received a copy of the GNU General Public License along
with conv.p; see the file COPYING.  If not, write to the Free Software
Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.

**************************************************************************


The converter itself is my first attempt in programming Perl, so please
bear with some kludgy or inefficient (? please tell me ;-)) parts.


(Please don't ask me to provide you with a copy of Perl. The version I
have is in no way a current version, I had the sources laying around on
my harddisk very long until I compiled it. There should be much newer
versions out there by now.)


Writing such a converter is not necessarily a trivial task, just consider
that you have to take something like 

  APTR SetFunction( struct Library *library, long funcOffset,
	unsigned long (*newFunction)() );

as input, remove the argument names (because you can't rely on them, they're
optional!), insert (at the right place...) the argument names from the
fd files, and then go ahead and write a function for this beast...

I tested this converter on Commodore clib/ prototype headers, the inline
headers included in this distribution are are the result of this test (they're
in the os-include/inline directory in this 3rd distribution). They
were slightly hand editted in those ~5 cases where the converter issued a
warning that either A4 or A5 is spilled, to save those registers
before clobbering them.  There's a last spot that needed intervention, and
that's the declaration of this function:

  void SetCollision( unsigned long num,
	void (*routine)(struct VSprite *vSprite, APTR),
	struct GelsInfo *gelsInfo );

the converter doesn't yet understand full ANSI declarations, it relies on
the fact that it is able to split the argument line at every comma, which
generates a wrong result in this case. The solution is to rewrite this
declaration as:

  void SetCollision( unsigned long num,
	void (*routine)(),
	struct GelsInfo *gelsInfo );

and then the converter has no problems parsing it. (If you feel like you
want the converter to be able to recognise full ANSI syntax, go ahead. But
keep in mind that you not only have to add fancier argument splitting, but
also add more intelligence to the part that inserts the right argument
names into the declaration..).

If you want to run the converter on your own library- and fd-files, the
following strategy should give best results:

  | create/use a prototype file that contains mostly function declarations.
  | The converter logic is *not* a full blown C compiler, it works best
  | when used in the context where it was made for. If you feed it with
  | nonsense, all hell can get lose, you may get no output at all, you
  | may get wrong output, just use your imagination ;-))
 
Then try to convert with:

  perl conv.p your_headerfile your_fdfile

and look at the generated output.  You can then redirect the output to a
file if you think the generated code seems correct.


Some notes to gcc-1.40 users
----------------------------
The generated inline headers of this converter won't run on 1.40. This is
simply because I chose to write declarations as

  register int d2 asm ("d2") = foo;

instead of in the older style:

  register int d2 asm ("d2");
  ....
  d2 = foo;

The new style is more compact and should help people that are short on
memory. If you absolutely need the older style, change the conv.p script
to output it, this shouldn't be too difficult.


Explanation for those __BEGIN_DECLS and __END_DECLS
---------------------------------------------------
All headers now include <sys/cdefs.h> to define those two macros. Their
effect depends on whether running under C or C++. If running under C,
they expand into nothing. Under C++ however they build an

  extern "C" {
  ...
  };

block to make sure that the functions are generated with C linkage rules.


Well.. now it's your part! I already found lots of headers in the (short)
history of this converter, that it didn't parse correctly. These headers
always lead to a change of some regular expressions in the converter, and
I'm pretty sure it needs some more of those changes ;-)) If you have such
header files, and you can fix the converter to accept them, please send
me the diffs!

-Markus

<wild@nessie.cs.id.ethz.ch> or <wild@amiga.physik.unizh.ch>
