                              Amiga GNU CC FAQ
				Version 0.2

    This FAQ is intended to answer most (all, if possible) common questions
concerning the Amiga Port of GCC.  It is divided into the following
subsections:

0.  General Introduction
    a. The FSF, the GNU Project, and the GPL
    b. What GCC has to offer
    c. Hardware and Software requirements
1.  Obtaining and Installing the Beast
    a. Sources of GCC
    b. The breakdown of the distribution
    c. Installation
    d. Common Problems with the Installation
2.  Initial problems using GCC
    a. Set your stack properly
    b. Amiga specific library options
       i) ixemul.library
       ii) libnix
       iii) libamiga.a and others
    c. The object file format of GCC
	i) Converting libraries to this format
    d. Getting the Commodore includes
    e. The frontend of the compiler 
    f. Optimization may work where no optimization doesn't
    g. Using the OS functions (an example)
3.  Amiga-specific extensions
    a. The CHIP keyword  (not currently implemented)      
    b. Command Line options
       i) -noixemul   (maybe goes in 2. (b))
       ii) -fbaserel
       iii) -resident
       iv)  Any more?
    c. Startup Code options
4.  Advanced Questions
    a. How do I build a cross-compiler?
    b. Working with AmiTCP
    c. Writing code for ixemul.library
    d. Writing code for libnix
    f. Saving some RAM
    g. Writing shared libraries and resident (pure) code
    h. I want to change over from SAS/C to GCC
    i. Inline Headers
    j. Writing Hooks
5.  C++ and Objective C
    (don't know much about these, except that they're not as well
     developed yet as the C compiler)
6.  Notes for Un*x Hackers
    a. fork() is not implemented
7.  Support Utilities
    a. Frontends
    b. Debuggers  
    c. What else?
8.  Additional Support 
    a. amiga-gcc-port mailing list
    b. snail mail (?)  - for people getting it off of CD-ROM
    c. You never know, it could be a problem in base FSF code
	(is there a newsgroup to point to here?)
9.  Known Bugs
    a. the C compiler
        i) -resident option
        ii) -fbaserel option
    b. the C++ compiler
    c. the Objective C compiler
10. Maintainers and Contributors
11. Future
12. History
Appendix A: How does the GPL affect programs compiled by GCC?
Appendix B: GNU ports and who's dealing with them
Appendix C: Another free C compiler (for those with little memory)

Section 0, General Introduction
-------------------------------

a.  The FSF, the GNU Project, and the GPL
    The Free Software Foundation (FSF) is an institution dedicated to
the free flow of software (and information in general (?)).  To this end
it has start the GNU (GNU's Not Unix) project, a collection of widely
portable software of all sorts (compilers and Un*x utilities for the 
most part, but some other stuff as well).  But I'm sure Richard Stallman,
director and founder of the FSF, can say it better than I:
[Note that this is heavily clipped;  You should get the original at
prep.mit.edu]

----------------------------------------------------------------------
Copyright (C) 1985, 1993 Free Software Foundation, Inc.



The GNU Manifesto
*****************


Why I Must Write GNU
====================

   I consider that the golden rule requires that if I like a program I
must share it with other people who like it.  Software sellers want to
divide the users and conquer them, making each user agree not to share
with others.  I refuse to break solidarity with other users in this
way.  I cannot in good conscience sign a nondisclosure agreement or a
software license agreement.  For years I worked within the Artificial
Intelligence Lab to resist such tendencies and other inhospitalities,
but eventually they had gone too far: I could not remain in an
institution where such things are done for me against my will.

   So that I can continue to use computers without dishonor, I have
decided to put together a sufficient body of free software so that I
will be able to get along without any software that is not free.  I
have resigned from the AI lab to deny MIT any legal excuse to prevent
me from giving GNU away.

Why GNU Will Be Compatible with Unix
====================================

   Unix is not my ideal system, but it is not too bad.  The essential
features of Unix seem to be good ones, and I think I can fill in what
Unix lacks without spoiling them.  And a system compatible with Unix
would be convenient for many other people to adopt.

How GNU Will Be Available
=========================

   GNU is not in the public domain.  Everyone will be permitted to
modify and redistribute GNU, but no distributor will be allowed to
restrict its further redistribution.  That is to say, proprietary
modifications will not be allowed.  I want to make sure that all
versions of GNU remain free.

Why Many Other Programmers Want to Help
=======================================

   I have found many other programmers who are excited about GNU and
want to help.

   Many programmers are unhappy about the commercialization of system
software.  It may enable them to make more money, but it requires them
to feel in conflict with other programmers in general rather than feel
as comrades.  The fundamental act of friendship among programmers is the
sharing of programs; marketing arrangements now typically used
essentially forbid programmers to treat others as friends.  The
purchaser of software must choose between friendship and obeying the
law.  Naturally, many decide that friendship is more important.  But
those who believe in law often do not feel at ease with either choice.
They become cynical and think that programming is just a way of making
money.

   By working on and using GNU rather than proprietary programs, we can
be hospitable to everyone and obey the law.  In addition, GNU serves as
an example to inspire and a banner to rally others to join us in
sharing.  This can give us a feeling of harmony which is impossible if
we use software that is not free.  For about half the programmers I
talk to, this is an important happiness that money cannot replace.

How You Can Contribute
======================

   I am asking computer manufacturers for donations of machines and
money.  I'm asking individuals for donations of programs and work.

   One consequence you can expect if you donate machines is that GNU
will run on them at an early date.  The machines should be complete,
ready to use systems, approved for use in a residential area, and not
in need of sophisticated cooling or power.

   I have found very many programmers eager to contribute part-time
work for GNU.  For most projects, such part-time distributed work would
be very hard to coordinate; the independently-written parts would not
work together.  But for the particular task of replacing Unix, this
problem is absent.  A complete Unix system contains hundreds of utility
programs, each of which is documented separately.  Most interface
specifications are fixed by Unix compatibility.  If each contributor
can write a compatible replacement for a single Unix utility, and make
it work properly in place of the original on a Unix system, then these
utilities will work right when put together.  Even allowing for Murphy
to create a few unexpected problems, assembling these components will
be a feasible task.  (The kernel will require closer communication and
will be worked on by a small, tight group.)

   If I get donations of money, I may be able to hire a few people full
or part time.  The salary won't be high by programmers' standards, but
I'm looking for people for whom building community spirit is as
important as making money.  I view this as a way of enabling dedicated
people to devote their full energies to working on GNU by sparing them
the need to make a living in another way.

Why All Computer Users Will Benefit
===================================

   Once GNU is written, everyone will be able to obtain good system
software free, just like air.(2)

   This means much more than just saving everyone the price of a Unix
license.  It means that much wasteful duplication of system programming
effort will be avoided.  This effort can go instead into advancing the
state of the art.

   Complete system sources will be available to everyone.  As a result,
a user who needs changes in the system will always be free to make them
himself, or hire any available programmer or company to make them for
him.  Users will no longer be at the mercy of one programmer or company
which owns the sources and is in sole position to make changes.

   Schools will be able to provide a much more educational environment
by encouraging all students to study and improve the system code.
Harvard's computer lab used to have the policy that no program could be
installed on the system if its sources were not on public display, and
upheld it by actually refusing to install certain programs.  I was very
much inspired by this.

   Finally, the overhead of considering who owns the system software
and what one is or is not entitled to do with it will be lifted.

   Arrangements to make people pay for using a program, including
licensing of copies, always incur a tremendous cost to society through
the cumbersome mechanisms necessary to figure out how much (that is,
which programs) a person must pay for.  And only a police state can
force everyone to obey them.  Consider a space station where air must
be manufactured at great cost: charging each breather per liter of air
may be fair, but wearing the metered gas mask all day and all night is
intolerable even if everyone can afford to pay the air bill.  And the
TV cameras everywhere to see if you ever take the mask off are
outrageous.  It's better to support the air plant with a head tax and
chuck the masks.

   Copying all or parts of a program is as natural to a programmer as
breathing, and as productive.  It ought to be as free.

---------------------------------------------------------------------


The GNU Public License (GPL) was written in order to keep software published
under it free.  Here's the Preamble of the GPL:

---------------------------------------------------------------------
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                          675 Mass Ave, Cambridge, MA 02139, USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

------------------------------------------------------------------------

More information regarding the FSF, GNU, and the GPL can be obtained at
gnu.prep.mit.edu.  Note that the source code of any GPLed software must be
made available by the distributor (is this wording accurate?).  The GPL
may also affect how you distribute your programs, or maybe not.
For more information, check out Appendix A of this FAQ.
(Do this before believing all the bad hype about it.  Then decide for
yourself).

b.  What GCC has to offer.
    A FREE C compiler, for starters.  I'm sure there's some other stuff.
    It's available for a wide range of machines (and thus it can't be
	beat for cross-compiling, at least on the Amiga).
    For the interested, a chance to change it as you like, make your own
      bug fixes, be an active part in the development process.

c. Hardware and Software Requirements
   This depends upon what you're doing.  Here's an excerpt from Phillipe
Brand's readme for his distribution on the net:


- Systems:
Any Amiga (ranging from A1000 up to A4000/40, including CD-32 & SX-1) will
run amigados-gnu utilities.

- Memory:
A minimum of 4MB free memory is needed in order to compile small/medium
projects.
More memory will be needed for large projects, such as recompiling gcc
itself.
Gigamem is known to work with GCC so *maybe* less memory will work. 
But in this case, you'll need an MMU equiped amiga (A3000,A4000/40, etc...).
VMM40 (Public Domain Virtual memory manager) is also known to work with GCC.

[Editor's note:  using the g++ compiler can require even more, like at 
	least  6 MB of free RAM]
- OS:
Starting from this release [2.6.3], 1.3 systems are not longer supported.
Gcc runs fine on all other systems, starting from 2.04 up to 3.1 (40.68).

- Disk Space;
An installation of gcc requires the use of a hard disk. Approximately 10MB is
required at present to install the compiler and utilities required to use it.
In addition 3MB is required for the Commodore Developer Kit, which is required
to be able to compile AmigaDOS specific programs. This kit is available direct
from Commodore-Amiga.
 
[Note, this is not true for the FreshFish distribution, which can be run
straight off the CD-ROM if desired.]

----------------------------end quote---------------------------------

Yes, it can take a lot of resources, but that's a function of its
portability.  Be glad you can count on having the same compiler on your
Amiga at home or the Unix system at work (or vice versa :-)).  

1.  Obtaining and Installing the Beast
a. Sources of the Amiga port of GCC
   There are a couple of options for getting GCC.
   If you have access to the Internet, and ftp service, you can obtain
the current version of GCC from Aminet, in dev/gcc.
The main site of Aminet is ftp.wustl.edu in /pub/aminet, and has mirrors
world-wide:
                     USA (MO)                ftp.wustl.edu
                     USA (WI)               ftp.netnet.net
                     USA (TX)                 ftp.etsu.edu
                     Scandinavia               ftp.luth.se
                     Switzerland              ftp.eunet.ch
                     Switzerland          ftp.math.ethz.ch
                     Germany        kelly.uni-paderborn.de
                     Germany          ftp.uni-paderborn.de
                     Germany          ftp.uni-stuttgart.de
                     Germany           ftp.uni-erlangen.de
                     Germany           ftp.cs.tu-berlin.de
                     Germany            ftp.tu-chemnitz.de
                     Germany            ftp.fh-augsburg.de
                     Germany             ftp.uni-bremen.de
                     Germany                 ftp.uni-kl.de
                     Germany              ftp.uni-trier.de
                     Germany      ftp.informatik.rwth-aach
                     France                    ftp.cnam.fr
                     Portugal                 ftp.ci.ua.pt
                     UK                   ftp.doc.ic.ac.uk
                     UK                 micros.hensa.ac.uk


    ftp.funet.fi also serves to act as a hub for porting GNU software to 
the Amiga, and serves to mirror Phillipe Brand's Amiga GCC tree directly, so 
that you may always find GCC there (particularly to guarantee the availability
of source code).

   The distribution is broken up into several parts, both to make it
easier to download and to respect the GPL.  Thus each archive is 
broken into two parts, one for binaries and one for sources.


Gcc-2.6.3 is split up into 15 archives:

gcc263-readme.lha	holds readmes files (include installation notes).
gcc263-base.lha         basic gcc distribution, hold necessary files.
gcc263-inclib.lha	headers and libraries.
gcc263-c.lha		C compiler.
gcc263-c-020.lha	68020+68881 version of C compiler.
gcc263-c++.lha		C++ compiler, headers and libraries.
gcc263-c++-020.lha	68020+68881 versions of C++ compiler.
gcc263-objc.lha		Objective-C compiler, header and libraries.
gcc263-objc-020.lha	68020+68881 versions of Objective-C compiler.
gcc263-doc.lha		Gcc AmigaGuide(tm) documents & manpages.
gcc263-utils.lha	Useful utilities needed for development.
gcc263-utilsdoc.lha	Utilities documentation (guide & manpages).
gcc263-texi.lha		All Texinfo documents.
gcc263-diffs.lha	Diff files for all binaries.
gcc263-src.lha		Source for gcc-2.6.3 plus diff file.


   The second way is to utilize your CD-ROM drive and get one of Fred Fish's
great CD-ROM collections. Any of the FreshFish or GoldFish Vol. 2 will
have it, though the later the CD-ROM the later the version.  He also
includes as many ports of GNU utilities as he can.  His restriction is
simply that the binaries he includes must be compilable from the sources
he includes (this has been a problem in the past, and Fred is a stringent
observer of the GPL).  So, yes, you also get all the sources with the
binaries.  (If you've got a CD-ROM drive, you should get one of these 
anyway; it's a great deal).
   These CD-ROMs may be purchased from Amiga Library Services by:
Snail Mail:  Amiga Library Services
	     610 N. Alma School Road, Suite 18
	     Chandler, AZ   85224-3687
	     USA
FAX or Voice: (602) 491-0048
Phone: 	      (800) 804-0833
or Email:    orders@amigalib.com
(but sending credit card information over e-mail is not secure, so one
of the other methods would be preferable.  Fred is working on using some
kind of encryption though.  More details when they're available.)

   There may be other CD-ROMs containing GCC, I just know of Fred's since
he is directly involved in the porting of it.
   The breakdown of this distribution is different.  Check the specific
CD-ROM for details.  They also include the Commodore Native Developer
Updates (no Autodocs) for 2.04, 3.0, and 3.1, which is a big bonus.  
   
c.  Installation
    Installation procedures may vary depending on your source, but
the final directory structure should be the same.  Check the README
files included in your distribution package for more details.  
    
    The ftp distribution (Phillipe Brand's) contains an Installer program.
    It utilizes the following layout:

Name			What					Where	
----			----					-----

COPYING			GNU LICENSE, read!!			All archives
COPYING.LIB		GNU LIBRARY LICENSE, read!!		All archives
README-2.6.3		this file				All archives
NEWS-2.6.3		What's new in gcc-2.6.3			gcc263-base
Installer		Commodore installer utility		gcc263-base
GCC-Install		Installer script to configure gcc	All archives
envarc/			global environment variables you should
			have set when using this programming	gcc263-base
			environment
include/		non-amiga specific C/C++ headers	gcc263-inclib
os-include/proto	amiga specific protos headers.		gcc263-inclib
os-include/inline	amiga specific inline C headers. Add	gcc263-inclib
			Commodore headers!!		
os-lib/			amiga specific libraries		gcc263-base
guide/			Docs in AmigaGuide(tm) format		gcc263-doc
man/			this is the root for tons of man pages	gcc263-doc
bin/			this is /bin, and contains all 		gcc263-c
			binaries of this distribution that	gcc263-c++
			are meant to be directly invoked by	gcc263-utils
			the user (contrary to the executables
     			in lib/gcc-lib/, that are meant to be
			invoked by a driver program like gcc)
lib/			normal (not base relatives) libraries	gcc263-inclib
lib/libm020/		normal 68020 libraries			gcc263-inclib
lib/libb/		base relatives libraries		gcc263-inclib
lib/libb/libm020/	base relatives using 68020 libraries	gcc263-inclib
lib/libnix/		Non-ixemul libraries			gcc263-inclib
lib/libm020/libnix/	Non-ixemul 68020 libraries		gcc263-inclib
lib/libb/libnix/	Non-ixemul base relatives libraries	gcc263-inclib
lib/libb/libm020/libnix	Non-ixemul base relatives 68020 libs	gcc263-inclib
lib/gcc-lib/		home of compilers called by gcc		gcc263-c
								gcc263-c++
								gcc263-objc
ixpipe/			a pipe handler needed by the library	gcc263-base
libs/			ixemul.library				gcc263-base
rexx/			ARexx wrappers for gcc and g++		gcc263-base
src-patches/		source patches				gcc263-diffs
geninline/		Perl scripts to generate inline headers	gcc263-inclib
			and -lamy glue


    A standard GNU directory tree structure has been adopted by the 
porting team to make life easier for everyone.  Starting with the
assign of GNU: to somewhere, we then have:

     GNU:amigados			
     GNU:man
     GNU:Info
     GNU:etc
     GNU:bin
     GNU:include
     GNU:lib
     GNU:os-include
     GNU:os-lib 
 
    Since one of the aims of porting GNU software is to be able to provide
a Un*x like environment under AmigaOS, the porters decided to make a GNU
"root directory" (GNU:) in which a standard Un*x directory tree can live, like
/etc, /bin, and so on.  This decision makes for good Un*x compatibility.
   Also, in the past, you would have to add many assigns (>=10) to have your
GNU utilities working, and now it's just 5 (GNU:, MAN:, INFO:, ETC:, and 
BIN: ).
We no longer have a conflicting assign LIB: (which most other compilers use).

d. Common Installation Problems
   Using the Installer program for the ftp distribution should get rid
of these problems.
   Check out the section on the specs file if you are having problems 
customizing your installation (say you have another compiler, and don't
want to have 2 separate copies of os-include).
   Also, for those of you who refuse to read the README, you need the 
Commodore includes.  Section 2 (d) tells you where to get them. 
   See 2 (c) about the GCC object format.  You may need to convert some
standard libraries.  Also check 2(a) on setting your stack properly.

2.  Initial Problems with GCC

a.  Set your stack properly.
    GCC needs a lot of stack to run.  For a nice, small (<1000 lines)
source, a stack of 50,000 should do just fine.  For more complicated
code, you may need more, but 250,000 should do in any case, for gcc alone.
    Note that using make may increase the demands on the stack size, so
the above suggestions may not hold.

A word from Phillipe Brand's README:

You need to have a 50.000 stack size in order to compile with GCC. This should
be enough for most projects. Note than while recompiling gcc with itself it
has taken more than 300KB stack. Stack can grow due to source complexity.
Don't be afraid of it.

To set the stack size, see the AmigaDOS Command 'stack'. 

To use ar and/or ranlib, 50KB is the minimum acceptable. You should have a
much larger stack, if you use larger libraries.

Starting with 2.6.3 a new environnement variable, GCCSTACK, enables gcc to
read this variable and set stack upon startup. Thus now no need to set stack
to huge values, only gcc/ld/cpp/cc1#? will automatically set new stack,
according to GCCSTACK variable.

Simply commit a: 
	setenv GCCSTACK value
to set gcc stack to value.

Benefits: huge memory savings.

----------------end quote

Note that GCC 2.7.0 will include automatic stack growth code, so you won't
need to worry about this anymore.


b. Amiga specific Library options
    i) Ixemul.Library
        This library was developed by Markus Wild when originally started
porting GCC (up to version 2.3.3).  It is a shared library that emulates
a lot of Un*x functions, making life a lot easier for folks porting
GNU utilities and such.  Unfortunately, it is fairly resource hungry by
Amiga standards, and has caused not a little irritation among Amiga
users.  GCC opens ixemul.library by default, so if you want to avoid it, 
you'll have to use -noixemul on the command line (see below in Amiga 
specific extensions and/or coding with x.lib) and link to one of the 
libraries below.
	The general rule of thumb should be to use ixemul.library if you're
writing something non-Amiga specific (e.g. porting something) or one of the
below link libraries when writing something specifically for the Amiga.

    Using ixconfig to work:
----------------------------------
[Joerg-Cyril Hoehle]

> Which ixconfig should we use for ixemul v40.4?

If you're using R.Luebbert ixem404lib.lha, use ixconfig from
there. It's actually called bin in that archive :-(
[generic]            2925    5396  54.2% -lh5- b464 Sep  3  1994 ixem/bin

The ixemul.library from the gcc263 archive is R.Luebbert's 40.4.

If you're using another one:

Fred Fish's: I don't know whether he removed the ArpBase field in the
include/library/ixemul.h file. R.Luebbert removed it between his 40.2
and 40.4, which was a big mistake IMHO (as this mail and others
show). So I don't know which ixconfig is good for him.

Leonard's: He told me that he had never removed this field, so get any
old ixconfig you'll find. The one from the gcc263 archive will do.



     ii) libnix
         This is a standard link library to replace the functionality of
ixemul.library. Make sure you link to it if you use the -noixemul command
line option for gcc.  Here's the readme file from the distribution:

Short: A library for amiga specific development on gcc
Type: dev/gcc
Uploader: fleischr@izfm.uni-stuttgart.de
Author: fleischr@izfm.uni-stuttgart.de, gnikl@informatik.uni-rostock.de

This is libnix, a static (i.e. link) library for gcc 2.3.3 or above.
It's not a replacement for ixemul.library (though it's possible to
recompile most of the gcc environment with libnix) but a good thing
for amiga specific development on gcc:

* It's mostly compatible to SAS's way of handling things, i.e.
  you get even an automatic shared library opening feature and
  some other things you may miss in ixemul.library.
  This also means it's ANSI compliant.

* It doesn't need any shared libraries than normal Amiga OS ones.

* It is not copyrighted by the FSF. Therefore you neither need
  to include sources nor objects together with your executable.
  (read the GLGPL _before_ flaming on this statement)

* And it's short! I was able to compile a 492 byte 'hello, world'
  using normal main.

* It uses OS20 features whenever necessary.

To cut it short:

Use ixemul.library for porting Un*x programs, libnix for compiling
amiga-only programs and gcc becomes one of the best Amiga compilers.

There is no need to download this archive if you use gcc2.6.0 or above
since the libraries itself are included with the normal gcc distribution.

But if you use an older gcc version or if you want to get the sources
you can take this package. But be warned: The ld that comes with earlier
versions of gcc has some serious trouble with set elements. You cannot
use libnix without the fixed linker that comes with gcc2.6.0.
 

     iii) Gerlib
          Obsolete

     iv) the PDC library   
          Obsolete 

c.  The object file format of GCC
     
     Yes, GCC uses its own object file format.  This means you aren't 
currently able to link to AmigaDOS hunk format object files (standard).  
But hunk2gcc (by Markus Wild) will do the conversion for you as described 
below.

   Why does GCC use its own object file format?  It's really just a design
decision that allows other gnu utilities to deal with these objects (for 
example, gdb) without having to convert them to deal with AmigaDOS hunks. 

>From Brand's README-2.6.3

Starting from this release an AmigaDOS compliant library is provided,
thanks to libnix authors (Matthias Fleischer and Gunther Nikl).

Anyway if you want to rebuild one, there are two methods:

1) Using hunk2gcc; the AmigaDOS object converter made by Markus Wild. To
achieve this, simply grab a copy of latest amiga.lib (from Commodore
Development Kit) and make a new directory where you want your converted
object files to go, cd into it, and enter

  hunk2gcc amiga.lib [..further libs if you like..]

This generates an a.out object file for every program unit present in the
hunk file (in this case, from amiga.lib).

As the final step convert all those files into an a.out style library by
issuing:

  ar qc libamiga.a obj.*
  ranlib libamiga.a

The ranlib run builds a symbol table in the archive, and makes accesses to
the library much faster.

2) Creating a libamiga.a library with libnix is fairly easy, but takes some
time. Just uncompress sources.lha from libnix distribution and run a
'make libamiga.a'.

NOTE:

As long as you make no AmigaDOs specific calls, you can create a dummy library
using:

  cat "int dummy;" >dummy.c
  gcc -c dummy.c
  ar crv libamiga.a dummy.o
  mv libamiga.a gcc:lib

A small libamiga.a (dummy) is also provided with libnix.
 

    d. Getting the Commodore includes
[Jochen Wiedmann]

You can obtain the includes and some developer tools from any Fish CD
and some other CD's as well.

However, you will be missing the autodocs, which are definitely the
best information source for the OS functions. You can get them either
by buying the

    The Amiga ROM Kernel Manual:  Includes and Autodocs, ISBN
                                                          0-201-56773-3

(about 50-60$, as far as I know), or by buying the so-called NDU
(Native developers update kit, 5 disks, about 40$) from

         Fa. Hirsch & Wolf
         Mittelstr. 33
         56564 Neuwied
	 Germany

         Phone: (0049) +2631 83990
	 Email: hhhirsch@carla.adsp.sub.org

Sorry, but this is still the *only* source for the NDU, at least as
long as CATS (Commodore Amiga Technical Support) isn't alive.

I'd prefer buying the NDU, because it contains the newer information
than the book and I prefer it online.



    e. The frontend of the compiler 
         amigados-gcc and gcc are the same thing.
         AREXX scripts:

The provided ARexx scripts have been contributed by Loren J. Rittle.
If you like ARexx, they're an alternate way of calling gcc. They 
automatically make sure you're using a large enough stack setting, and 
enable you to compile C++ programs with less obscure options. This 
approach is furthermore useful if you're not able to use the g++ /bin/sh
script.

    f. Optimization may work where no optimization doesn't
         The folks who write GCC almost always use -O when compiling
GCC and other stuff.  Hence, the -O routines are better tested than
those without optimization.  So you may want to try it.

g.) Using the OS functions with gcc.

[Jochen Wiedmann, with a small suggestion by Christian Stieber]

Let's write a simple "HelloWorld.c":

    /*  Compile me with
	    gcc -noixemul -o HelloWorld HelloWorld.c -lauto
    */
    #include <stdlib.c>
    #include <intuition/intuition.h>
    #include <proto/intuition.h>

    int main(int argc, char *argv[])

    {
        struct EasyRequest er;

        er.es_StructSize = sizeof(er);
        er.es_Flags = 0;
        er.es_Title = "Message";
        er.es_TextFormat = "Hello, world!\nintuition.library is at 0x8l.";
        er.es_GadgetFormat = "Ok";
        EasyRequest(NULL, &er, NULL, IntuitionBase);
	exit(0);
    }

Some notes:

  - We are using the function EasyRequestArgs() from intuition.library. 
    Thus we have to include the appropriate headers: intuition/intuition.h
    for the structures and constants, proto/intuition.h for the 
    function prototypes. Do not use headers from other compilers (for
    example pragmas/intuition.h), gcc headers (inline/intuition.h,
    included by proto/intuition.h) or even OS headers
    (clib/intuition_protos.h). The only exception are clib/alib_protos.h
    and clib/alib_stdio_protos.h: These represent link libraries and not
    shared libraries.

  - We did *not* open intuition.library. gcc does this for you by
    including proto/intuition.h and linking against libauto.a.
    However, this works only for OS libraries. Consult the GNU:libauto
    directory, if you want to know how to get the same possibilities for
    other shared libraries.

    Using proto/intuition.h you are safe and even source compatible
    to SAS/C and Dice.

  - If you *need* to open a library manually, do it as follows:

	#include <stdlib.h>
	#include <stdio.h>
        #include <intuition/intuition.h>
	#include <proto/intuition.h>

        struct IntuitionBase *IntuitionBase = NULL;
	/*  Explicit initialization with NULL is a *must*!  */

	void Cleanup(void)

	{
	    if (IntuitionBase) CloseLibrary(IntuitionBase);
	}

	int main(int argc, char *argv[])

	{
	    if (atexit(Cleanup)) {
		perror("atexit");
		exit(20);
	    }

	    if (!(IntuitionBase = (struct IntuitionBase *)
			OpenLibrary("intuition.library", 37))) {
		fprintf(stderr, "Cannot open intuition.library, V37");
		exit(20);
	    }

	    /* Same program as above */
	}
 
     Note the use of atexit(), which makes exit() calling Cleanup().

Note this possible alteration:

>         struct EasyRequest er;
> 
>         er.es_StructSize = sizeof(er);

This seems to be correct, but I suggest hardcoding 5*sizeof(ULONG) here.
That field serves as version information; using sizeof() and compiling
with newer headers would tell the OS that you're using the new structure.
But the additional fields will contain garbage...


3.  Amiga-specific extensions

    a. The CHIP keyword      

	Most C compilers for the Amiga have a CHIP keyword or equivalent to
signify that an object should stored CHIP memory when declared.  I.e., 
CHIP struct Image *my_graphics = { ... } 
will cause the memory for the data to which my_graphics points to be allocated
in CHIP memory (pretty handy, huh?)
	This is obviously Amiga-specific, so of course it's not implemented
in the FSF code. BUT, the linker (ld) currently recognizes -chip and -fast 
options.  However, these haven't been put in gcc itself quite yet, though I 
have been assured they will be here soon (there have been more important 
things to work on, like getting -resident to work again, see below).
         So if you're using 2.6.3 or below, here are some basic work-arounds:

(I gotta find these)

    b. Command Line options

       i) -noixemul   (maybe just reference 2. (b))
              This option prevents gcc from making your executable open
ixemul.library (of course, your program can still do so).  Make sure you
link to libnix or something similar to access those functions.
 	      See also 2. (b) (ii)

       ii) -fbaserel (currently broken until 2.7.0)
[from Christian Stieber]
            -fbaserel turns on base relative adressing; which means that 
global/static variables are referenced with a 16 bit offset relative to an 
address register (a4 is generally used for that). The startup-code loads a4 
with a pointer into the data segment. Result: every access to a global/shared
variable is only 16 bit instead of the usual 32 bit address -> shorter & 
faster. It also means that you're limited to at most 64K of global/static 
variables.

       iii) -resident
[from Christian Stieber] 
           A "resident" program (the correct term is "pure") is a program that
can be loaded into memory just once, but executed by serveral processes
at the same time. Therefore, "resident" is actually "code sharing".
-resident turns on -fbaserel and links with a special startup code.
That first thing that special startup code is to allocate some memory,
copy the global/static variables into it and load a4 with a pointer to
that memory. Then, a normal startup-code and your normal program
is run. When the program exists, the memory block is freed.
Result: Every process has its very own, private data segment for
global/static variables. Since there all global/static variables are
accessed via a4+16-bit-offset (because of -fbaserel), the original
data segment is untouched. Result: the program can be executed
independently by several processes, with every process getting its
own data segment.


    c. Startup Code options  (may be redundant)

4.  Advanced Questions

    a. How do I build a cross-compiler?
[from Phillipe Brand]

How to generate a cross-compiler, AmigaDOS side:
------------------------------------------------

- Get gcc-2.6.3.tar.gz from ftp.gnu.ai.mit.edu or mirror site
- Get ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-2.6.3-amiga.diffs file

>From CLI:

CLI> sh
# zcat gcc-2.6.3.tar.gz | tar xvf -
# cd gcc-2.6.3
# zcat ../gcc-2.6.3-amiga.diffs | patch -p1
# ./configure --host=amigados --target=CPU-COMPANY-SYSTEM
# make

When compilers are built, all you have to do is installing it using
make install, and to grab other architecture's libraries (libc.a, etc...),
and headers.

More infos: See GCC AmigaGuide documentation, look for "Cross-Compiling".

How to generate a cross-compiler, Other architecture side:
----------------------------------------------------------

- Get gcc-2.6.3.tar.gz from ftp.gnu.ai.mit.edu or mirror site
- Get ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-2.6.3-amiga.diffs file

>From CLI:

CLI> sh
# zcat gcc-2.6.3.tar.gz | tar xvf -
# cd gcc-2.6.3
# zcat ../gcc-2.6.3-amiga.diffs | patch -p1
# ./configure --target=amigados (host should be determined by configure itself)
# make

When compilers are built, all you have to do is installing it using
make install, and to grab AmigaDOS GCC libraries (libc.a, etc...),
and headers.

More infos: See GCC AmigaGuide documentation, look for "Cross-Compiling".

A working example of a cross-compiler running on sunos4.1.3 can be found
in ftp.telesys-innov.fr:/pub/amigados-gnu/gcc-cross/....


    b. Working with AmiTCP

> Could somebody please explain where exactly gcc and the libraries
> that come with it fall down when it comes to using AmiTCP?
> 
> What's missing etc.
> 
> Then, Why can't (I assume you can't since veryone says you can't)
> use the C= Developers kit with gcc without fiddling.

The problems are:

a) gcc uses it's own object module and library format, so lots of the GNU
tools don't have to change too. 

b) gcc uses ixemul by default, which is not compatible directly with the SAS
libraries supplied with AmiTCP. 

a) is just a design decision, and indeed there are tools to convert. (b) is
harder to see; basically the SAS AmiTCP libraries assume the environment of
SAS/C, complete with references to the SAS FILE structure internals and the
functions which aren't in SAS or which need to be patched to work with
AmiTCP. In addition, the netincludes supplied with the AmiTCP port include
many items and structure definitions which are also defined in gcc, albeit
differently, resulting in a very confised compiler if you mix them. 

Unfortunately, a simplistic port (recompile with the right -I directives)
fails for two reasons; the includes are wrong, and even if they were matched,
the SAS-directed library patches the wrong things. Resulting in an executable
which will fail to operate as expected (it might work OK, or it might not -
depends what you call & when). 

What is needed is a new library - take out the duplicate definitions, patch
the right functions and remake the library for gcc. 

Does this help? 

Peter Ivimey-Cook.


    c. Writing code for ixemul.library
         After looking at Markus Wild's README, I couldn't see anything
to include in particular, and the thing is way too long to put here.
Any specific suggestions of stuff to clip out?

         Actually, considering the update activity, the current maintainers/
developers should be providing a new README.  Particularly the functions
available in the different versions (regular fxns, the ones in the network
version, and the conflicts.  Somebody recently answered a question about
this last part, saying he was trying to integrate the 2).      

            i)  Finding bugs with trace()

[Joerg-Cyril Hoehle]
more than one year ago, I corrected a huge bug in the program trace (a
buffer overflow). Together with ixemul.trace, this program allows you
to see every ixemul call (aka SnoopDOS for ixemul.library programs)
and may be useful for debugging.

Before, because of that overflow, trace hung the whole system very
often (and very soon) when tracing every ixemul call. Now, I've been
able to trace long sessions of gcc compilation to a (K)CON: window
without trouble.



    d. Writing code for libnix
        Maybe a referral to the libnix docs in the source file, or should
I stick them in here (I believe they're only in the source archive, so people
may tend not to grab it)?

     e.  Problems with asm() 

[Insert your answer here,please]


     f. How do I save RAM?
[Jochen Wiedmann]

A simple try is to do a

    setenv TMP MyHardDrive:t

before compiling. This will create temporary files on the harddisk and
not in RAM. Depending on what you compile this can save some 100K of
RAM while compiling and it doesn't slow down the compiler very much.

Another try is to turn off optimization. This prevents the "inline"
headers from being included, which need *very* much RAM. If you like
optimization (for example because of the additional checks!) you can
use the options

    -O -D__NOINLINES__

which turn on optimization, but prevent the inline headers from being
included. (The negative effect is, that you need an additional
function call any time, you use an OS function, but one can live with
it.)

    g. Writing shared libraries and resident (pure) code

Here is some discussion from the amiga-gcc-port mailing list 
[not cooked up yet]

[Peter Ivimey-Cook]

> Obviously there must be other solutions. Being able to build a library
> is not far away from being able to build a pure (=residentable)
> program, and gcc-2.3.3 was both largely above 64KB in size and
> residentable. So what's the trick?
> 

Don't use global data referenced absolutely! residentable implies 
reentrant, which means that global data is read-only apart from the first 
instance (i.e. it's OK to initialise it, once, but once initialised it 
can't be modified or reinitialised). This effectively means the only data 
used in the must be on the stack or referenced from it by pointers, as 
the stack is separate for different invocations of a resident program.

Of course this does pose a major headache for programs which use lots of 
global data. And watch out for library use too!

Failing this, one must use a global data access mechanism which allows:

(a) the base address to be set up - e.g. by calling AllocMem() and 
storing the result in a register (NOT a global!)

(b) *all* accesses to "global" data are relative to this register.

[Peter Ivimey-Cook]
> 
> BUT: If we build a shared lib from the static link lib, code exists only once
> and is SHARED between callers of the lib (callers means different executables, using the lib)
> Here the problem comes up that the DATA MUST not be shared between different callers.
> This is because it is PRIVATE to the individual caller.
> IMHO the only way to realize multiple callers is the use of -fbaserel, since now access
> is relative to the A4 register and thus, every program can have IT'S OWN data, without
> interferring with each other.

It depends on the way the library is constructed. Most Amiga libraries 
are written to be re-entrant - i.e. they don't use global data items 
which would require loading - they use the stack. For items which can't 
be done this way, there are two solutions -

1. Use the library data space. It's global, unless you make provision for 
it to be otherwise - and availabl easily off a6.

2. Manage your own data space, using tags or whatever to allocate space 
for callers. Note that the only indication you have as to who is the 
current caller is the result of FindTask(). 

So, in general libraries try to make required data passed through 
parameters, or available on the stack, or shareably global. In which case 
no baserel or anything else is required.


[Jochen Wiedmann]
  - Of course it is possible to write shared libraries (ixemul.library,
    for example) with gcc, but *only* if the source is written with a
    shared library in mind.

  - It is possible (Matthias told how) to develop a solution that would
    allow to use existing source of link libraries for shared libraries
    (libbfd sources, for example) with at most very minor modifications

  - -fbaserel would be a must for the above solution. On the other hand
    it is not possible yet, at least not without going to the assembler
    level. (Really deep, not just using some headers with asm keywords.)

[Christian Stieber]
> Jochen Wiedmann writes:
>  >   - Of course it is possible to write shared libraries (ixemul.library,
>  >     for example) with gcc, but *only* if the source is written with a
>  >     shared library in mind.
> 
> Could you elaborate on that so that we know a little more about it,
> please?

- keep in mind that all callers use the same global and static variables;
  that means: either protect them with semaphores (e.g. if your library
  is using a memory pool), or allocate a block of memory inside your library
  and pass pointers around.

- the "startup" code will contain the ROMTag structure and related data,
  as well as stubs to push parameters on the stack, calling the C function,
  cleaning up the stack.

- I generally write the libOpen(), libClose(), libInit() etc. functions
  as normal C functions, but some people might prefer to put them into
  the "startup code".

That's about all. It also means that many link-lib functions (e.g. from
libnix) can't be used; this has to be decided on a per-function basis.
It's pretty safe to say that you can't use stdio and malloc(). strcpy(),
isdigit() are safe, etc. Just be careful. Think about what the function does;
that should give you an idea whether you can use it or not.

[Jochen Wiedmann]

> Jochen Wiedmann writes:
>  >   - Of course it is possible to write shared libraries (ixemul.library,
>  >     for example) with gcc, but *only* if the source is written with a
>  >     shared library in mind.
> 
> Could you elaborate on that so that we know a little more about it,
> please?
> 
> Does it mean that you can't use any global variable? Or only one but
> declare it with something like__asm__("a4") and use it as a base
> pointer? Does it imply that you must use the inline/*.h? Does it imply
> that you must use a special startup code (of course :-), what must it
> do?

In short: You may well use something like

  struct ExecBase *SysBase;

and read this variable from anywhere within your program, because you
can

  a) initialize it from the library startup code and
  b) be sure that it never changes

but you must not use global or static data otherwise.




    h.  I want to change from SAS/C to GCC

        Great!

[Kriton Kyrimis]

> I am also wondering if it is possible to link object files that were 
> created by different conpilers, specifically GCC and SAS. I need to do 

Try compiling SAS programs using DATA=FAR CODE=FAR, then use the hunk2gcc
program to convert the object files from amiga format to sun format.

One problem with this approach would be with floating point code and with
integer multiplication/division. If you can compile with CPU=68020 (or higher)
and MATH=68881, then SAS/C will produce inline code, and you will have no
problem. Otherwise, you'll have to grab the necessary modules from the SAS
libraries and convert them to sun format as well. (Compiling with the option
that produces code that uses utility.library, and linking with -lauto might
alleviate the problem.)
----------------------------------
 
   And here's a little AREXX program to automagically convert sas libs to
gcc libs:

This arexx program is based on help from Philippe BRAND.


/********************************HISTORY**********************************
* 18-DEC-94 : DJR : Created                                              *
**************************************************************************
*                                                                        *
* Name      : saslib2libgcc                                              *
* Author    : David J. Ruscak  ruscakd@polaroid.com                      *
* Created   : 18-DEC-94                                                  *
* Purpose   : to convert SAS libraries to GCC libraries                  *
*                                                                        *
*************************************************************************/


/* To convert a SAS library to a GCC format library several steps are
   involved.

 1) cd to RAM: Either copy the library to RAM: or give the full path name.

    EX: gnu:saslib2libgcc X11:lib/Xtnb.lib

 2) You need the SAS Librarian 'oml' with a version =>  Library
    otherwise you'll get an error such as 'unknown hunk'.

 3) You need hunk2gcc, mv, ar and ranlib. If your using gcc you have the
    fastram, VMM2.1 swap works fine too.

*/


/* TRACE R */
SIGNAL ON ERROR
OPTIONS RESULTS

IF ~SHOW('l','rexxsupport.library') THEN
  IF (~ADDLIB("rexxsupport.library",0,-30,0)) THEN
     DO
        ECHO "Can't load rexxsupport.library"
        EXIT 10
     END


fullname = ""

PARSE ARG fullname

IF fullname  == "" THEN
   DO
      ECHO " No Library to convert"
      ECHO ""
      ECHO " EX: gnu:saslib2libgcc X11:lib/Xtnb.lib"
      EXIT 10
   END

IF (~EXISTS(fullname)) THEN
   DO
      ECHO "Can't find" fullname
      EXIT 10
   END


ADDRESS COMMAND
/* make 2 directories for object files   */

IF EXISTS('object') THEN
   DO
     ECHO "Directory object exists Please delete or rename it."
     EXIT
   END
'makedir  object'

IF EXISTS('object2') THEN
   DO
     ECHO "Directory object2 exists Please delete or rename it. "
     EXIT
   END
'makedir  object2'

'oml -oobject 'fullname 'X *' /* SAS Object Librarian  */


IF EXISTS('object') THEN
 DO
   objfiles = SHOWDIR('object','F')              /* list of all object files */
   nfiles = WORDS(SHOWDIR('object','F'))         /* count of object files    */
   DO    UNTIL nfiles == 0                /* must be a more efficient way... */
    'hunk2gcc >NIL: object/'WORD(objfiles,nfiles)   /* convert to GCC object */
    'mv >NIL: obj.#? object2/'WORD(objfiles,nfiles) /* restore original names*/
    nfiles = nfiles - 1
   END
 END


'cd object2' /* directory of converted objects */
path =  PRAGMA('D','object2')

IF (INDEX(fullname,':') > 0) THEN    /* strip out assign */
        fullname = SUBSTR(fullname,LASTPOS(':',fullname) + 1)

IF (INDEX(fullname,'/') > 0) THEN    /* strip off directories */
        libname = SUBSTR(fullname,LASTPOS('/',fullname) + 1)
ELSE
        libname = fullname

dot = POS('.',libname)

gcclibname = 'lib'SUBSTR(libname,1,dot)'a'

'ar qc 'gcclibname' #?.o'    /* archive new library */

'ranlib 'gcclibname

IF EXISTS(gcclibname) THEN
  DO
    needslash = LASTPOS(':',path)
    IF ~(needslash == LENGTH(path)) THEN
      path = path'/'
    ECHO " The following indicate a hunk2gcc error:"
    ECHO " Short reloc into N_DATA, what should I do?
    ECHO " Short reloc into N_BSS, what should I do?
    ECHO ""
    ECHO ""
    ECHO " Remember to move/rename "path"object2/"gcclibname" appropriately ."
  END
ELSE
  ECHO "No library created, what could have gone wrong ????"

EXIT

ERROR:

   ECHO " error = "RC
   ECHO " Hope its not the dreaded *Invalid Hunk type*"
EXIT

	h.  Inline Headers

[Christian Stieber] (maybe should clear out the specific bgui reference)

> compiling bgui:demos/font.c:
>   gcc -O3 -noixemul bgui:demos/font.c
> 
> got errors:
>   font.c:100: unterminated macro call

This is because the inlined varargs aren't useful at all. Do
#define NO_INLINE_STDARG (or whatever it is called), and create
varargs stubs like this:

Prototype: BOOL SomeFunction(int, char *, ...);
and        BOOL SomeFunctionA(int, char *, APTR);

Stub function:
#define NO_INLINE_STDARG
#include <inline/someinline.h>
BOOL SomeFunction(int A, char *B, ...)
{
  return SomeFunctionA(A,B,(&B)+1);
}

That isn't really ANSI-C, but it works on all Amiga compilers I know of.

Create a .c file for every function, compile, ar and link it to
the program. Make sure the optimizer is on, else SomeFunctionA
won't be inlined.

How to create stubs for non-varargs functions:
In order to be able to compiler without -O, you want to create
stubs for the inline functions as well:

#define NO_INLINE_STDARG
#define SomeFunctionA InlinedSomeFunctionA
#include <inline/someinlines.h>
#undef SomeFunctionA
BOOL SomeFunctionA(int A, char *B, APTR C)
{
  return InlinedSomeFunctionA(A,B,C);
}

Again, create such a file for every function and put the *.o files
into the archive mentioned above.

     j. Writing Hooks

[Tomi Ollila]
> 1) How to I write a hook function - I.E. Specify which registers parameters
> should be received in and that the result should be returned in register D0.

One way to do this is to write the function entry the following way:

ULONG hook(void)
{
  register char * a0 __asm("a0");
  char * buffer = a0;
  register ULONG d0 __asm("d0");
  ULONG size = d0;

  ...

  return length;
}

We wrote some macros for AmiTCP/IP project to make it easier to write this
kind of function entries...

#define RAF2(funname, type1, arg1, reg1, type2, arg2, reg2) \
  funname(VOID)                     \
{                                   \
  register type1 reg1 __asm(#reg1); \
  type1 arg1 = reg1;                \
  register type2 reg2 __asm(#reg2); \
  type2 arg2 = reg2;


would make the above function look like:

ULONG RAF2(hook,
	   char *,	buffer,	a0,
	   ULONG,	size,	d0)
#if 0
{
#endif

The whole macro file `amiga_raf.h' is available at kampi.hut.fi, directory
/AmiTCP. It defines RAF1 - RAF7 for both GNU C and SAS C compilers (someone
could write these to DICE as well).

 > 2) Is there anyway to specify that a function should NOT be made inline (As
 > I wouldn't want the hook function inlined.

Compile it in a separate module. This way gcc doesn't see the function code
when compiling. If you give a pointer to the function, then it must also
exist as a callable function.




5.  C++ and Objective C

    a. C++

	i)  Use _complex.h instead of complex.h
	    Because Amiga Dos is not case-sensitive, and there are
both complex.h and Complex.h on the Unix distribution, one had to be
changed.  This choice was recommended by the libg++ maintainer.

    (don't know much about these, except that they're not as well
     developed yet as the C compiler)

6.  Notes For Un*x Hackers

     [additions to this section are welcome]    
       a. fork() is not implemented
	     
	      Here's a clip from Markus Wild's README in the ixemul source
distribution:


Some notes to vfork() and friends
=================================

**IX/BSD process management is one of the most nasty design differences
between AmigaDOS ans **IX/BSD. `fork()' for example is hardly possible to
implement on AmigaDOS, as it requires to create an identical copy of the
parent process. This is only feasible with virtual memory, where processes
can be mapped at equal places in memory. Under AmigaDOS this would have
to be simulated by copying of stack and malloc'd data whenever a process
is activated, and copying them to a safe place before it is disactivated.

This problem can be avoided, if the program to be run under AmigaDOS is
only fork()ing, because it just wants to start another process. In that
case, no such copying as described before is necessary, and BSD therefore
invented the `vfork()' function, which works like `fork', but runs the 
child on the parents memory segments (stack and malloc'd data). While the
child is using the parents resources, the parent is sleeping in a not
interruptible state. 

That much for theory;-) I tried to implement an as compatible as possible
vfork() function, that behaves like the BSD one. This should work under
any OS version, for Kickstart 1.3 the arp.library is used, starting with
OS 2.0 dos.library is powerful enough to do it itself.

Since I won't try to implement `fork', I provided a possible alternative
(you tell me;-)). As an extension, you get the `vfork_resume()' function,
which causes the parent to resume, just like it would if you called 
`_exit()' or one of the `exec*()' functions. Since this function is quite
dangerous (and an even bigger hack than vfork() itself..), here's what's
happening in `vfork_resume()':

  o  the child switches to its own stack. After vfork(), the child is
     using the stack of the parent process. Since no two processes can
     share the same stack in parallel, vfork_resume() causes a switch
     to the `real' stack of the child.
  o  the parent is sent a wakeup message.
  o  both processes run concurrently

The first point is the most important one: Since vfork_resume() changes
the stack pointer of the running process, you can't refer to any variables
or parameters anymore after calling vfork_resume()! Only register
variables survive such a call, and you have to explicitly store values
in register variables that are subject to survive!

There's another potential problem with vfork_resume():

**************************************************************************
  Don't exit() from the parent before all vfork()'d children have died!!
**************************************************************************

Since exiting from the parent causes the parents code and data segments to
be deallocated, the child would find itself without code space to run
on, and would probably cause a severe machine crash!

So always call at least `wait (0)' before returning from the parent.



exec*()
=======

In most cases, you just use `vfork()' to later overlay the process with 
a new image, that is you want to start another program. The way AmigaDOS
loads processes is not too well suited to do `exec' style program starting,
yet it is possible, although with slight resource wasting.. 

First problem is, that all exec* functions pass an argument vector to
the new program, whereas AmigaDOS programs expect to be passed an argument
line (instead of the vector of arguments). Since in my opinion it would
be a good thing if a program could get an argument vector directly (in that
case the inherent problem of passing multi word arguments to a program would
be finally solved, no more weird quoting needed!). That's why I provided
a mechanism that allows this vector passing, and it works like this (look
at crt0.c for a concrete implementation of this concept!):

  The program has to provide a magic header at the first executable location
  in its code. This magic header looks like this:
     o  JMP instruction to common AmigaDOS startup
     o  struct exec area. Use the OMAGIC a_magic code.
     o  provide an alternate entry vector in a_entry. execve() jumps thru
        this vector to pass vectors to your program, instead of going
        thru the normal AmigaDOS startup part.

As long as you use my crt0.o and libc.a, this whole thing is completely
transparent to your program, you only have to care for it, if you want
to support the mechanism in other languages as well.

The second problem is how to start `old' AmigaDOS programs from execve().
If the program has the described magic header, starting is easy. Else 
another approach is taken, depending on the OS version. Common to both
OS versions (1.3 and 2.0) is redirection of stdin and stdout. Since the
new program can't refer to the real file descriptors (I can't pass the
open library without my startup code), I have to setup DOS fields to
use my filehandles. This may succeed or not, depending on whether the
descriptors in question are realized by DOS files or not (in the future
a not-compatible alternative would be descriptors that refer to sockets!).
Actual starting of the program is done with RunCommand() under 2.0, and
some own hack under 1.3. If someone is interested to get this working
well under 1.3, I'd be happy to include a better starter function, my
kludge doesn't particularly deal graceful with BCPL functions...




7.  Support Utilities

    a. Frontends

       I'm thinking of GUI's here.  There is one (something like GCC_Frontend)
on the April 1994 Aminet CD-ROM collection.  If I remember correctly though,
when I tried using it, it bugged out on me.  Anybody know of anything else?

    b. Debuggers  (Maybe just GDB?)
         
          GDB is the GNU debugger, and Fred Fish is the port master for it.
Here is something from his readme.


GDB 4.12 has been ported to the extent that you can build an AmigaDOS
executable that knows how to load and examine executables from non-AmigaDOS
systems.  Much work remains.  See the gnu:src/diffs/gdb-4.12-README file.

[He's referring to the general gnu:source directory.  If you unpack the
gdb source archive to your GNU: directory, it should be in that same directory.]



    c. What else?

8.  Additional Support 

    a. amiga-gcc-port mailing list

    b. snail mail (?)  - for people getting it off of CD-ROM
	
    c. You never know, it could be a problem in base FSF code

       gnu.gcc Newsgroup and daughter newsgroups
       ftp: prep.ai.mit.edu in /pub/gnu  is the primary archive for the GNU
	    Project.  If you need the FSF baseline code for something,
	    it'll be there.

9.  Known Bugs
    
    a. C compiler
       
       i) -resident option
	    This has been broken since 2.3.3.  Hence, you'll need to get
that version if you want to compile a program you can easily make resident.
 	    Of course, you can always write your code to be resident, it
just takes a little more effort (see above).

	    This is fixed in 2.7.0.

       ii) -fbaserel option 
		Won't be fixed until the -resident option is (as it's the
cause of the -resident problem).

    b.  C++ compiler (g++)

    c.  Objective C compiler 

10. Maintainers and Contributors

Gcc v2.2.2 port:   Markus Wild
Gcc v2.3.3 port:   Markus Wild
Gcc v2.4.5 port:   Philippe Brand, Lars Hecking, Fred Fish
Gcc v2.5.0 and up: Philippe Brand, Fred Fish, Leonard Norrgard 

Ixemul.library:    Markus Wild, Leonard Norrgard, R. Luebbert
Libnix:            Matthias Fleischer, Gunther Nikl

Also, much testing, suggestions and debate have been provided by
Jorg  Hoehle
Peter Ivemey-Cook
Christian Stieber
Walter Harms
Lars Hecking
Kriton Kyrimis
Niklas Hallqvist
Jochen Wiedmann
Thomas Walter

   not necessarily in that order.
 
[ I just compiled this list from looking at the 1995 archive and some of the
'94, whoever consistently either (a) made suggestions and wrote some code
or (b) has been reporting bugs from attempts at compiling GNU software
for a long time (i.e. not someone who's just having problems porting their
favorite package).  If I've left someone out, or if you have a problem
with my criteria, or if you think I should just thank the mailing list as
a whole, mail me].

The present FAQ maintainer is Lynn Winebarger (owinebar@indiana.edu).
However, you should send corrections to amiga-gcc-port@nic.funet.fi for
a look over, as that's what I'll do anyway.
[or maybe they should just send them to me, and I can screen out the 
very common screw-up from people who think they know.]
Flames directed to /dev/null.


11. Future

12. History

Appendix A: How does the GPL affect programs compiled by GCC?

[Niklas Hallqvist]

>    If I compile one of my sources with gcc, do I have to
> distribute it under the GPL? I'm not using any GNU libraries or
> startup or anything.  My interpretation of the GPL is that i
> don't have to, but one of the teacher (lecturers?) say that I
> have to. Who's right?

You are.  The GPL (and LGPL) only covers distributed code, not code
generated by tools which are GPL:ed. As there are code which get
linked by GCC distributed with GCC, libgcc.a, one might think that the
GPL would apply to generated code, but no, libgcc.a is written without
GPL just to enable that use of the GNU compiler.  Think about it,
several object-only commercial applications including OSes are
compiled by GCC for enhanced performance, would they do that if they
had to give up their objectcode-only policy?  The key behind the GPL
is that no code based on work GPLed, should be locked to to that
specific compilation, but the user should be able to customize the GPLed
code as he wants to and recompile.  You are still allowed to protect
your own source as you see fit.  For example, let's say you use som
LGPLed library libfoo.a in your application app.  When you distribute
it you must also distribute a linkable objectfile app.o which, when
linked with the distibuted libfoo.a (with source) generates app.  If
the end-user wants, he should be able to customize libfoo, and relink
it with app.o to get a customized app.  It's not a very severe
limitation on distribution rights IMHO.

Remember that the (L)GPL was written to give programmers more Freedom,
not to limit their chance of protecting their own work.  As long as
their own work is clearly delimited from others GPLed work, it's
perfectly OK to keep a separate copyright policy on it.

In your case, your lecturer has misunderstood the intentions of the
(L)GPL which is easy to do.  These discussions come up ever so often
because of the legaleze used to express the GPL.  Too bad many get the
GPL wrong, as rumours like "you cannot use GNU products for business
work" severly harms the usage of GNU products.  To name a few uses of
GCC where the program did NOT fall under the GPL:  Dell Unix SVR4,
NextStep & some OSF/1 port.  Tell your lecturer about these, and ask
him why he thinks the GPL prevents them to be sold during other than
GPL conditions?  I ask you to actually convince him he was wrong as it
is harmful for the programming society that such misconceptions exist.

    This is where I'd like to put that list of libraries that are GPLed.


Appendix B:  GNU Porting activities and who's dealing with them

    Not really GCC (Which is why it's an Appendix), but certainly one of
GCC's main uses.
      It would be good to keep track of these things anyway, in case someone
wants to start working on porting something (just as administratvia).


Appendix C:  Another Free C compiler (for those without much memory)

   Warning, apparently lcc is not yet fully ported (no backend) for easy
use.

[Fred Fish]

> > One of the things I hope to eventually add to my FreshFish CD is a
> > port of lcc, which is much smaller and faster than gcc, and apparently
> > somewhat more ANSI compliant.  I just haven't had time yet to look
> > at doing so.
> 
> What's lcc? I never heard of it.

============================ begin inclusion ===========================

lcc is the retargetable compiler for ANSI C described in our book
`A Retargetable C Compiler: Design and Implementation'
(Benjamin Cummings, 1995, ISBN 0-8053-1670-1), which will be available
in December 1994. lcc is in production use at Princeton University and
AT&T Bell Laboratories.

The public distribution directory contains the following files.

README	this file.

install.{ps,txt}
	describes the distribution and gives installation
	instructions. install.ps is the PostScript generated from
	the HTML document, install.html, which is included in the
	the distribution.

X.Y.tar.{Z,gz}
	a compressed tar files for the distribution of version X.Y,
	e.g., 3.0.tar.Z the tar file compressed with compress. This
	distribution includes user documentation, the front end, the
	driver program, code generators for the SPARC, MIPS R3000 and
	x86, and the code-generator generator that produced them. A
	.gz file is the tar file compressed with gzip instead
	of compress.

The distribution is available via `anonymous' ftp from
ftp.cs.princeton.edu (128.112.152.13) in the directory pub/lcc.
Obtaining and extracting the distribution into its own directory is
accomplished by the following commands. Replace `3.0' with the latest
version, which is the only one typically available; versions like
`3.0a' identify minor updates and versions like `3.1beta' identify
pre-releases (which might be incomplete). As suggested, use your login
as the password, and use ftp's binary transfer mode.

mkdir lcc
cd lcc
ftp ftp.cs.princeton.edu
anonymous
yourlogin
cd pub/lcc
binary
get 3.0.tar.Z dist.tar.Z
quit
zcat dist.tar | tar xpof -
rm dist.tar.Z

To be added to the lcc mailing list, send a message with the 1-line body

subscribe lcc

to majordomo@cs.princeton.edu. This line must appear in the message
body; `Subject:' lines are ignored. To learn more about mailing lists
served by majordomo, send a message with the body `help' to
majordomo@cs.princeton.edu.

Additional information about lcc and about our book is available on the
WWW at URL http://www.cs.princeton.edu/software/lcc.


Chris Fraser / cwf@research.att.com
David Hanson / drh@cs.princeton.edu
Thu Aug 18 13:36:15 EDT 1994



