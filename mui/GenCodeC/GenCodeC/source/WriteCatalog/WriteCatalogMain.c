/* Main-Header File inserted by GenCodeC */
/* Libraries */
#include <libraries/mui.h>
#include <libraries/gadtools.h> /* for BARLABEL in MenuItem */

/* Prototypes */
#ifdef __GNUC__
#include <proto/muimaster.h>
#include <proto/exec.h>
#include <proto/alib.h>
#include <proto/dos.h>
#else
#include <clib/muimaster_protos.h>
#include <clib/exec_protos.h>
#include <clib/alib_protos.h>
#include <clib/dos_protos.h>
#include <pragmas/muimaster_pragmas.h>
#endif /* __GNUC__ */

/*  Ansi  */
#include <stdlib.h>
#include <stdio.h>

/* Increase stack size */
LONG __stack=8192;
/* GenCodeC header end */

/* Include generated by GenCodeC */
#include "WriteCatalogGUI.h"

#include <clib/asl_protos.h>
#include <string.h>

#include "Tools.h"
#include "TextField.h"
#include "WriteCatalogFiles.h"

struct ObjTextField 	*TF_Catalog = NULL;
BOOL					NormalEnd;

/* Declarations for libraries (inserted by GenCodeC) */
struct Library * MUIMasterBase;

struct Library * IntuitionBase = NULL;
struct Library * TextFieldBase = NULL;

/* Init() function */
void init( void )
{
	if (!(IntuitionBase = OpenLibrary("intuition.library",36)))
	{
		exit(20);
	}

	if (!(MUIMasterBase = OpenLibrary(MUIMASTER_NAME,MUIMASTER_VMIN)))
	{
		DisplayMsg("Can't Open MUIMaster Library\n");
		CloseLibrary(IntuitionBase);
		exit(20);
	}

	if (!(TextFieldBase = OpenLibrary("gadgets/textfield.gadget", 0)))
	{
		DisplayMsg("Can't Open Textfield gadget\n");
		CloseLibrary(MUIMasterBase);
		CloseLibrary(IntuitionBase);
		exit(20);
	}
}
/* GenCodeC init() end */

/* End() function */
void end(void *App )
{
	struct ObjApp * app = App;

	if (app)
	{
		set(app->WI_WriteCatalog,
			MUIA_Window_Open,FALSE);

		if (TF_Catalog && TF_Catalog->textfield)
			DoMethod(app->GR_Text, OM_REMOVE, TF_Catalog->textfield);

		DisposeTextField(TF_Catalog);

		DisposeApp((struct ObjApp *)App);
	}

	CloseAllFiles(!NormalEnd);
	ClearMemory(!NormalEnd);

	CloseLibrary(TextFieldBase);
	CloseLibrary(MUIMasterBase);
	CloseLibrary(IntuitionBase);
	exit(20);
}
/* GenCodeC end() end */

/* Get a Catalog Description File Name with a File Requester */
BOOL GetFile(STRPTR *FileName)
{
	struct Library			*AslBase;
	struct FileRequester	*FileRequest;

	if (!(AslBase = OpenLibrary(AslName,0)))
	{
		DisplayMsg("Can't Open Asl Library\n");
		return FALSE;
	}

	if (!(FileRequest=AllocAslRequestTags(ASL_FileRequest,
										  ASLFR_TitleText,"Choose a file",
										  ASLFR_InitialDrawer,"PROGDIR:",
										  TAG_DONE)))
	{
		DisplayMsg("Can't alloc a FileRequester \n");
		CloseLibrary(AslBase);
		return FALSE;
	}

	if (AslRequest(FileRequest,NULL) &&
		strcmp(FileRequest->fr_File,""))
	{
		if (strlen(FileRequest->fr_File)>=3 &&
			FileRequest->fr_File[strlen(FileRequest->fr_File)-3]=='.' &&
			FileRequest->fr_File[strlen(FileRequest->fr_File)-2]=='c' &&
			FileRequest->fr_File[strlen(FileRequest->fr_File)-1]=='d')
		{
			if (!(*FileName=AllocMemory(strlen(FileRequest->fr_Drawer)+1+
									    strlen(FileRequest->fr_File)+1,FALSE)))
			{
				FreeAslRequest(FileRequest);
				CloseLibrary(AslBase);
				return FALSE;
			}
			strcpy(*FileName,FileRequest->fr_Drawer);
			AddPart(*FileName,FileRequest->fr_File,strlen(FileRequest->fr_Drawer)+1+
												   strlen(FileRequest->fr_File)+1);
			FreeAslRequest(FileRequest);
			CloseLibrary(AslBase);
			return TRUE;
		}
		else
		{
			char *msg;

			if (!(msg=AllocMemory(strlen(FileRequest->fr_File)+38+1,FALSE)))
			{
				FreeAslRequest(FileRequest);
				CloseLibrary(AslBase);
				return FALSE;
			}
			sprintf(msg,"%s is not a Catalog Description File !!\n",FileRequest->fr_File);
			DisplayMsg(msg);
			FreeMemory(msg);
			FreeAslRequest(FileRequest);
			CloseLibrary(AslBase);
			return FALSE;
		}
	}
	else
	{
		FreeAslRequest(FileRequest);
		CloseLibrary(AslBase);
		return FALSE;
	}
}

/* Main Function inserted by GenCodeC */
int main(int argc,char **argv)
{
	struct ObjApp 			*App = NULL;	/* Object */
	BOOL					running = TRUE;
	ULONG					signal;
	LONG					Args[3]={0L,0L,0L};
	struct RDArgs 			*result;
	char					*CatalogName;
	char					*GetString = NULL;
	char					*CatalogText;
	BOOL					NoGenerate=FALSE;

	/* Program initialisation : generated by GenCodeC */
	init();

	NormalEnd = TRUE;
	if (!(result=ReadArgs("CDN=CatalogDescriptionName/K,GSN=GetStringName/K,Reserved/S",Args,NULL)))
	{
		printf("Error\n");
		printf("Usage : WriteCatalog CDN=CatalogDescriptionName/A/K GSN=GetStringName/A/K\n");
		end(App);
	}

	/* test reserved argument */
	NoGenerate=((Args[2]!=0) ? TRUE : FALSE);

	/* test CatalogDescriptionName */
	if (Args[0]==0)
	{
		if (!GetFile((STRPTR *)&CatalogName))
		{
			FreeArgs(result);
			end(App);
		}
	}
	else
	{
		if (!(CatalogName=AllocMemory(strlen((char *)Args[0])+1,FALSE)))
		{
			FreeArgs(result);
			end(App);
		}
		strcpy(CatalogName,(char *)Args[0]);

		if (strlen(CatalogName)<3 ||
			CatalogName[strlen(CatalogName)-3]!='.' ||
			CatalogName[strlen(CatalogName)-2]!='c' ||
			CatalogName[strlen(CatalogName)-1]!='d')
		{
			char *msg;

			if (!(msg=AllocMemory(strlen(CatalogName)+38+1,FALSE)))
			{
				FreeMemory(CatalogName);
				FreeArgs(result);
				end(App);
			}
			sprintf(msg,"%s is not a Catalog Description File !!\n",CatalogName);
			DisplayMsg(msg);
			FreeMemory(msg);
			FreeMemory(CatalogName);
			FreeArgs(result);
			end(App);
		}
	}

	/* test GetString Name */
	if (Args[1]!=0)
	{
		if (!(GetString=AllocMemory(strlen((char *)Args[1])+1,FALSE)))
		{
			FreeMemory(CatalogName);
			FreeArgs(result);
			end(App);
		}
		strcpy(GetString,(char *)Args[1]);
	}

	FreeArgs(result);

	NormalEnd = FALSE;
	/* Create Object : generated by GenCodeC */
	if (!(App = CreateApp()))
	{
		DisplayMsg("Can't Create App\n");
		end(NULL);
	}

	SetDataQuit((void *)App);
	SetFunctionQuit(end);

	/* Create and fill a textfield object */
	if (!(TF_Catalog = CreateTextField()))
	{
		DisplayMsg("Can't Create Textfield object\n");
		end((void *)App);
	}
	DoMethod(App->GR_Text, OM_ADDMEMBER, TF_Catalog->textfield);
	CatalogText = LoadFileInRAM(CatalogName,FALSE);
	if (CatalogText)
	{
		set(TF_Catalog->text,TEXTFIELD_Text,CatalogText);
		FreeMemory(CatalogText);
	}

	set(App->STR_GetStringName,MUIA_String_Contents,GetString);

	if (NoGenerate)
	{
		set(App->BT_GenerateFiles,MUIA_ShowMe,FALSE);
		set(App->GR_GetStringName,MUIA_ShowMe,FALSE);
	}

	set(App->WI_WriteCatalog,
		MUIA_Window_Open,TRUE);

	while (running)
	{
		switch (DoMethod(App->App,MUIM_Application_Input,&signal))
		{
			case MUIV_Application_ReturnID_Quit:
				running = FALSE;
				break;

			/* Insert your code between the "case" statement and comment "end of case ..." */
			case ID_BT_GenerateFiles:
			{
				ULONG size;
				char  *text;
				FILE  *file;
				char  *Catalog_h_File;
				char  *Catalog_c_File;
				char  *GetStringName;

				get(App->STR_GetStringName,MUIA_String_Contents,&GetStringName);
				if (strlen(GetStringName)==0)
				{
					DisplayMsg("Please enter a string in the field \"GetString Name\"");
				}
				else
				{
					if (GetString==0)
					{
						GetString=AllocMemory(strlen(GetStringName)+1,TRUE);
						strcpy(GetString,GetStringName);
					}

					set(TF_Catalog->text,TEXTFIELD_ReadOnly,TRUE);
					get(TF_Catalog->text,TEXTFIELD_Size,&size);
					get(TF_Catalog->text,TEXTFIELD_Text,&text);

					if (!(file=fopenFile(CatalogName,"w",FALSE)))
					{
						char *msg;

						msg=AllocMemory(14+strlen(CatalogName)+1,TRUE);
						sprintf(msg,"Can't update %s\n",CatalogName);
						DisplayMsg(msg);
						FreeMemory(msg);
						FreeMemory(CatalogName);
						FreeMemory(GetString);
						end((void *)App);
					}
					fwrite(text,size,1,file);
					fcloseFile(file);

					remove_extend(CatalogName);

					Catalog_h_File = AllocMemory(strlen(CatalogName)+7,TRUE);
					strcpy(Catalog_h_File, CatalogName);
					strcat(Catalog_h_File, "_cat");
					add_extend(Catalog_h_File, ".h");

					Catalog_c_File = AllocMemory(strlen(CatalogName)+7,TRUE);
					strcpy(Catalog_c_File, CatalogName);
					strcat(Catalog_c_File, "_cat");
					add_extend(Catalog_c_File, ".c");

					add_extend(CatalogName,".cd");

					if (!Write_Catalog_h_File(Catalog_h_File,CatalogName,GetString))
					{
						FreeMemory(CatalogName);
						FreeMemory(GetString);
						FreeMemory(Catalog_h_File);
						FreeMemory(Catalog_c_File);
						end((void *)App);
					}

					if (!Write_Catalog_c_File(Catalog_c_File,CatalogName,GetString))
					{
						FreeMemory(CatalogName);
						FreeMemory(GetString);
						FreeMemory(Catalog_h_File);
						FreeMemory(Catalog_c_File);
						end((void *)App);
					}

					FreeMemory(Catalog_h_File);
					FreeMemory(Catalog_c_File);

					set(TF_Catalog->text,TEXTFIELD_ReadOnly,FALSE);
				}
			}
			break;
			/* end of case ID_BT_GenerateFiles */

			case ID_BT_Save:
			{
				ULONG size;
				char  *text;
				FILE  *file;

				set(TF_Catalog->text,TEXTFIELD_ReadOnly,TRUE);
				get(TF_Catalog->text,TEXTFIELD_Size,&size);
				get(TF_Catalog->text,TEXTFIELD_Text,&text);

				if (!(file=fopenFile(CatalogName,"w",FALSE)))
				{
					char *msg;

					msg=AllocMemory(14+strlen(CatalogName)+1,TRUE);
					sprintf(msg,"Can't update %s\n",CatalogName);
					DisplayMsg(msg);
					FreeMemory(msg);
					FreeMemory(CatalogName);
					FreeMemory(GetString);
					end((void *)App);
				}
				fwrite(text,size,1,file);
				fcloseFile(file);

				set(TF_Catalog->text,TEXTFIELD_ReadOnly,FALSE);
			}
			break;
			/* end of case ID_BT_Save */

			/* End computing of IDCMP */
		}
		if (running && signal) Wait(signal);
	}

	FreeMemory(CatalogName);
	FreeMemory(GetString);

	NormalEnd = TRUE;
	end((void *)App);
}
