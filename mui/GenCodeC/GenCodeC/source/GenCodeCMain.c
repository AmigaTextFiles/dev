/* Main-Header File inserted by GenCodeC */
/* Libraries */
#include <libraries/mui.h>
#include <libraries/gadtools.h> /* for BARLABEL in MenuItem */

/* Prototypes */
#ifdef __GNUC__
#include <proto/muimaster.h>
#include <proto/exec.h>
#include <proto/alib.h>
#include <proto/dos.h>
#else
#include <clib/muimaster_protos.h>
#include <clib/exec_protos.h>
#include <clib/alib_protos.h>
#include <clib/dos_protos.h>
#include <pragmas/muimaster_pragmas.h>
#endif /* __GNUC__ */

/*  Ansi  */
#include <stdlib.h>
#include <stdio.h>

/* Increase stack size */
LONG __stack=8192;
/* GenCodeC header end */

/* Include generated by GenCodeC */

#include "GenCodeCGUI.h"

#include <exec/memory.h>
#include <string.h>

#include "TextField.h"
#include "Tools.h"
#include "GenCodeC.h"
#include "MB_pragmas.h"
#include "MB_protos.h"
#include "MB.h"

/* defines for header file */
#define  HHEADER     1
#define  CHEADER     2
#define  MAINHEADER  3

#define  LOCALSAVE   1
#define  GLOBALSAVE  2

/* Global variables */
BOOL	TextFieldLocked = FALSE;
BOOL	NormalEnd = FALSE;

struct ObjTextField	*TF_H_Header = NULL;
struct ObjTextField	*TF_C_Header =  NULL;
struct ObjTextField	*TF_Main_Header = NULL;

char 	*H_Header_Text;
char 	*C_Header_Text;
char 	*Main_Header_Text;

/* Declarations for libraries (inserted by GenCodeC) */
struct Library * MUIMasterBase;

struct Library * IntuitionBase = NULL;
struct Library * MUIBBase      = NULL;
struct Library * TextFieldBase = NULL;

/* Init() function */
void init( void )
{
	if (!(IntuitionBase = OpenLibrary("intuition.library",36)))
	{
		exit(20);
	}

	if (!(MUIMasterBase = OpenLibrary(MUIMASTER_NAME,MUIMASTER_VMIN)))
	{
		DisplayMsg("Can't Open MUIMaster Library\n");
		CloseLibrary(IntuitionBase);
		exit(20);
	}

	if (!(MUIBBase = OpenLibrary("muibuilder.library", 0)))
	{
		DisplayMsg("Can't Open MUIBuilder Library\n");
		CloseLibrary(MUIMasterBase);
		CloseLibrary(IntuitionBase);
		exit(20);
	}

	/* exit if we cant init the Library */
	if (!MB_Open())
	{
		DisplayMsg("Unable to Get Temporary files !\n");
		CloseLibrary(MUIBBase);
		CloseLibrary(MUIMasterBase);
		CloseLibrary(IntuitionBase);
		exit(20);
	}

	if (!(TextFieldBase = OpenLibrary("gadgets/textfield.gadget", 0)))
	{
		DisplayMsg("Can't Open Textfield gadget\n");
		MB_Close();
		CloseLibrary(MUIBBase);
		CloseLibrary(MUIMasterBase);
		CloseLibrary(IntuitionBase);
		exit(20);
	}
}
/* GenCodeC init() end */

void UnlockTextFieldTexts(struct ObjTextField *,char *,struct ObjTextField *,char *,struct ObjTextField *,char *);

/* End() function */
void end(void *ptr_void)
{
	struct ObjApp *app=(struct ObjApp *)ptr_void;

	MB_Close();    /* Free Memory and Close Temporary Files */

	if (app)
	{
		set(app->WI_C_Generation,
			MUIA_Window_Open, FALSE);

		if (TextFieldLocked)
			UnlockTextFieldTexts(TF_H_Header,H_Header_Text,
							 TF_C_Header,C_Header_Text,
							 TF_Main_Header,Main_Header_Text);

		if (TF_H_Header && TF_H_Header->textfield)
			DoMethod(app->GR_H_Header, OM_REMOVE, TF_H_Header->textfield);

		if (TF_C_Header && TF_C_Header->textfield)
			DoMethod(app->GR_C_Header, OM_REMOVE, TF_C_Header->textfield);

		if (TF_Main_Header && TF_Main_Header->textfield)
			DoMethod(app->GR_Main_Header, OM_REMOVE, TF_Main_Header->textfield);

		DisposeTextField(TF_H_Header);
		DisposeTextField(TF_C_Header);
		DisposeTextField(TF_Main_Header);

		DisposeApp(app);
	}

	CloseAllFiles(!NormalEnd);
	ClearMemory(!NormalEnd);

	CloseLibrary(TextFieldBase);
	CloseLibrary(MUIBBase);
	CloseLibrary(MUIMasterBase);
	CloseLibrary(IntuitionBase);
	exit(20);
}
/* GenCodeC end() end */

/* Read a header file and load it in memory */
char *LoadHeaderFile(int HeaderFile)
{
	char  *TMPFile;
	char  *HF;
	int   size;
	char  *MBDir=NULL;
	char  *FileName;
	
	MB_Get(MUIB_FileName,&FileName,TAG_END);
	
	/* Get Current Directory Name */
	MBDir = GetCurrentDirectory();
	  
	size = strlen(MBDir)+1+9+1+strlen(FilePart(FileName))+12+1;
	TMPFile = AllocMemory(size,TRUE);

	/* Try to read local header and if there is no local header, try to read global header */
	strcpy(TMPFile,MBDir);
	AddPart(TMPFile,"C_Headers",size);
	AddPart(TMPFile,FilePart(FileName),size);
	remove_extend(TMPFile);
	switch(HeaderFile)
	{
		case HHEADER:
			add_extend(TMPFile,".H-Header");
			break;
			
		case CHEADER:
			add_extend(TMPFile,".C-Header");
			break;
			
		case MAINHEADER:
			add_extend(TMPFile,".Main-Header");
			break;
	}
	if (!(HF = LoadFileInRAM(TMPFile,FALSE)))
	{
		FreeMemory(TMPFile);
		size = strlen(MBDir)+1+9+1+12+1;
		TMPFile = AllocMemory(size,FALSE);

		strcpy(TMPFile,MBDir);
		AddPart(TMPFile,"C_Headers",size);
		switch(HeaderFile)
		{
			case HHEADER:
				AddPart(TMPFile,"H-Header",size);
				break;
					
			case CHEADER:
				AddPart(TMPFile,"C-Header",size);
				break;
					
			case MAINHEADER:
				AddPart(TMPFile,"Main-Header",size);
				break;
		}
		if (!(HF = LoadFileInRAM(TMPFile,FALSE)))
		{
			DisplayMsg("Can't open Header file !!!");
		}
		FreeMemory(MBDir);
		FreeMemory(TMPFile);
		return HF;
	}
	else
	{
		FreeMemory(MBDir);
		FreeMemory(TMPFile);
		return HF;
	}
}

/* Save a header file */
void SaveHeaderFile(int HeaderFile,char *HeaderText,int PrefsSave)
{
	char  *TMPFile;
	int   size;
	char  *MBDir = NULL;
	char  *FileName;
	BOOL  Prefs = (PrefsSave==LOCALSAVE);
	BPTR  file;
	
	MB_Get(MUIB_FileName,&FileName,TAG_END);
	
	/* Get Current Directory Name */
	MBDir = GetCurrentDirectory();
	  
	size = strlen(MBDir)+1+9+((Prefs) ? (1+strlen(FilePart(FileName))):1)+12+1;
	if (!(TMPFile = AllocMemory(size,FALSE)))
	{
		FreeMemory(MBDir);
		DisplayMsg("Can't save Header file !!! \n");
		return;
	}
	else
	{
		strcpy(TMPFile,MBDir);
		AddPart(TMPFile,"C_Headers",size);
		if (Prefs)
		{
			AddPart(TMPFile,FilePart(FileName),size);
			remove_extend(TMPFile);
		}
		switch(HeaderFile)
		{
			case HHEADER:
				(Prefs) ? add_extend(TMPFile,".H-Header") : AddPart(TMPFile,"H-Header",size);
				break;
			
			case CHEADER:
				(Prefs) ? add_extend(TMPFile,".C-Header") : AddPart(TMPFile,"C-Header",size);
				break;
			
			case MAINHEADER:
				(Prefs) ? add_extend(TMPFile,".Main-Header") : AddPart(TMPFile,"Main-Header",size);
				break;
		}
		if (file = OpenFile(TMPFile, MODE_NEWFILE, FALSE))
		{
			FreeMemory(MBDir);
			FreeMemory(TMPFile);
			FWrite(file,HeaderText,strlen(HeaderText),1);
			CloseFile(file);
		}
		else
		{
			DisplayMsg("Can't save Header file !!! \n");
		}
	}
}

void CreateTextFieldObjects(struct ObjApp *App,
							struct ObjTextField **TF_H_Header,
							struct ObjTextField **TF_C_Header,
							struct ObjTextField **TF_Main_Header)
{
	char  *HeaderText;
	
	if (!(*TF_H_Header = CreateTextField()))
	{
		DisplayMsg("Can't Create Textfield object\n");
		end((void *)App);
	}
	DoMethod(App->GR_H_Header, OM_ADDMEMBER, (*TF_H_Header)->textfield);
	HeaderText = LoadHeaderFile(HHEADER);
	if (HeaderText)
	{
		set((*TF_H_Header)->text,TEXTFIELD_Text,HeaderText);
		FreeMemory(HeaderText);
	}
	
	if (!(*TF_C_Header = CreateTextField()))
	{
		DisplayMsg("Can't Create Textfield object\n");
		end((void *)App);
	}
	DoMethod(App->GR_C_Header, OM_ADDMEMBER, (*TF_C_Header)->textfield);
	HeaderText = LoadHeaderFile(CHEADER);
	if (HeaderText)
	{
		set((*TF_C_Header)->text,TEXTFIELD_Text,HeaderText);
		FreeMemory(HeaderText);
	}
	
	if (!(*TF_Main_Header = CreateTextField()))
	{
		DisplayMsg("Can't Create Textfield object\n");
		end((void *)App);
	}
	DoMethod(App->GR_Main_Header, OM_ADDMEMBER, (*TF_Main_Header)->textfield);
	HeaderText = LoadHeaderFile(MAINHEADER);
	if (HeaderText)
	{
		set((*TF_Main_Header)->text,TEXTFIELD_Text,HeaderText);
		FreeMemory(HeaderText);
	}
}

void LockTextFieldTexts(struct ObjApp *App,
						struct ObjTextField *TF_H_Header,char **H_Header_Text,
						struct ObjTextField *TF_C_Header,char **C_Header_Text,
						struct ObjTextField *TF_Main_Header,char **Main_Header_Text)
{
	char	*text;
	ULONG	size;
	
	set(TF_H_Header->text,TEXTFIELD_ReadOnly,TRUE);
	set(TF_C_Header->text,TEXTFIELD_ReadOnly,TRUE);
	set(TF_Main_Header->text,TEXTFIELD_ReadOnly,TRUE);
	
	get(TF_H_Header->text,TEXTFIELD_Size,&size);
	get(TF_H_Header->text,TEXTFIELD_Text,&text);
	*H_Header_Text = AllocMemory(size+1,TRUE);
	strncpy(*H_Header_Text,text,size);
	(*H_Header_Text)[size]='\0';

	get(TF_C_Header->text,TEXTFIELD_Size,&size);
	get(TF_C_Header->text,TEXTFIELD_Text,&text);
	*C_Header_Text = AllocMemory(size+1,TRUE);
	strncpy(*C_Header_Text,text,size);
	(*C_Header_Text)[size]='\0';
	
	get(TF_Main_Header->text,TEXTFIELD_Size,&size);
	get(TF_Main_Header->text,TEXTFIELD_Text,&text);
	*Main_Header_Text = AllocMemory(size+1,TRUE);
	strncpy(*Main_Header_Text,text,size);
	(*Main_Header_Text)[size]='\0';

	TextFieldLocked = TRUE;
}

void UnlockTextFieldTexts(struct ObjTextField *TF_H_Header,char *H_Header_Text,
							struct ObjTextField *TF_C_Header,char *C_Header_Text,
							struct ObjTextField *TF_Main_Header,char *Main_Header_Text)
{
	set(TF_H_Header->text,TEXTFIELD_ReadOnly,FALSE);
	set(TF_C_Header->text,TEXTFIELD_ReadOnly,FALSE);
	set(TF_Main_Header->text,TEXTFIELD_ReadOnly,FALSE);

	FreeMemory(H_Header_Text);
	FreeMemory(C_Header_Text);
	FreeMemory(Main_Header_Text);

	TextFieldLocked = FALSE;
}

/* Main Function inserted by GenCodeC */
int main(int argc,char **argv)
{
	struct ObjApp	*App = NULL; /* Object */
	BOOL			running = TRUE;
	ULONG			signal;
	BOOL			Locale;

	/* Program initialisation : generated by GenCodeC */
	init();
	
	/* Create Object : generated by GenCodeC */
	if (!(App = CreateApp()))
	{
		DisplayMsg("Can't Create App\n");
		end((void *)App);
	}

	SetDataQuit((void *)App);
	SetFunctionQuit(end);	

	CreateTextFieldObjects(App,&TF_H_Header,&TF_C_Header,&TF_Main_Header);
	
	MB_Get(MUIB_Locale,&Locale,TAG_DONE);
	if (!Locale)
		set(App->GR_Catalog,MUIA_ShowMe,FALSE);
	
	set(App->WI_C_Generation,
		MUIA_Window_Open, TRUE
		);
	
	while (running)
	{
		switch (DoMethod(App->App,MUIM_Application_Input,&signal))
		{
			case MUIV_Application_ReturnID_Quit:
			running = FALSE;
			break;
			
			/* Insert your code between the "case" statement and comment "end of case ..." */
			case ID_BT_SAVE_LOCAL:
			{
				LockTextFieldTexts(App,TF_H_Header,&H_Header_Text,
									   TF_C_Header,&C_Header_Text,
									   TF_Main_Header,&Main_Header_Text);
					
				SaveHeaderFile(HHEADER,H_Header_Text,LOCALSAVE);
				SaveHeaderFile(CHEADER,C_Header_Text,LOCALSAVE);
				SaveHeaderFile(MAINHEADER,Main_Header_Text,LOCALSAVE);
					
				UnlockTextFieldTexts(TF_H_Header,H_Header_Text,
									 TF_C_Header,C_Header_Text,
									 TF_Main_Header,Main_Header_Text);
			}
			break;
			/* end of case ID_BT_SAVE_LOCAL */

			case ID_BT_SAVE_GLOBAL:
			{
				LockTextFieldTexts(App,TF_H_Header,&H_Header_Text,
									   TF_C_Header,&C_Header_Text,
									   TF_Main_Header,&Main_Header_Text);
					
				SaveHeaderFile(HHEADER,H_Header_Text,GLOBALSAVE);
				SaveHeaderFile(CHEADER,C_Header_Text,GLOBALSAVE);
				SaveHeaderFile(MAINHEADER,Main_Header_Text,GLOBALSAVE);

				UnlockTextFieldTexts(TF_H_Header,H_Header_Text,
									 TF_C_Header,C_Header_Text,
									 TF_Main_Header,Main_Header_Text);
			}
			break;
			/* end of case ID_BT_SAVE_GLOBAL */

			case ID_BT_GENERATE:
			{
				LockTextFieldTexts(App,TF_H_Header,&H_Header_Text,
									   TF_C_Header,&C_Header_Text,
									   TF_Main_Header,&Main_Header_Text);

				GenerateCode(App,H_Header_Text,C_Header_Text,Main_Header_Text);

				UnlockTextFieldTexts(TF_H_Header,H_Header_Text,
									 TF_C_Header,C_Header_Text,
									 TF_Main_Header,Main_Header_Text);
			}
			break;
			/* end of case ID_BT_GENERATE */

			/* End computing of IDCMP */
		}
		if (running && signal) Wait(signal);
	}
	NormalEnd = TRUE;
	end((void *)App);
}
