@database "MCC_HexEdit"
@master "Development:Source/HexEdit/doc/MCC_HexEdit.doc"

@Node Main "MCC_HexEdit.doc"
    @{" --background-- " Link "--background--"}
    @{" MUIA_HexEdit_ActiveField() " Link "MUIA_HexEdit_ActiveField()"}
    @{" MUIA_HexEdit_AddressChars() " Link "MUIA_HexEdit_AddressChars()"}
    @{" MUIA_HexEdit_BaseAddressOffset() " Link "MUIA_HexEdit_BaseAddressOffset()"}
    @{" MUIA_HexEdit_BytesPerColumn() " Link "MUIA_HexEdit_BytesPerColumn()"}
    @{" MUIA_HexEdit_BytesPerLine() " Link "MUIA_HexEdit_BytesPerLine()"}
    @{" MUIA_HexEdit_ByteValue() " Link "MUIA_HexEdit_ByteValue()"}
    @{" MUIA_HexEdit_ColumnsPerLine() " Link "MUIA_HexEdit_ColumnsPerLine()"}
    @{" MUIA_HexEdit_CursorAddress() " Link "MUIA_HexEdit_CursorAddress()"}
    @{" MUIA_HexEdit_CursorNibble() " Link "MUIA_HexEdit_CursorNibble()"}
    @{" MUIA_HexEdit_CursorVisible() " Link "MUIA_HexEdit_CursorVisible()"}
    @{" MUIA_HexEdit_EditMode() " Link "MUIA_HexEdit_EditMode()"}
    @{" MUIA_HexEdit_First() " Link "MUIA_HexEdit_First()"}
    @{" MUIA_HexEdit_FirstLine() " Link "MUIA_HexEdit_FirstLine()"}
    @{" MUIA_HexEdit_FullRefresh() " Link "MUIA_HexEdit_FullRefresh()"}
    @{" MUIA_HexEdit_HighBound() " Link "MUIA_HexEdit_HighBound()"}
    @{" MUIA_HexEdit_LowBound() " Link "MUIA_HexEdit_LowBound()"}
    @{" MUIA_HexEdit_MoveCursor() " Link "MUIA_HexEdit_MoveCursor()"}
    @{" MUIA_HexEdit_NibbleValue() " Link "MUIA_HexEdit_NibbleValue()"}
    @{" MUIA_HexEdit_PropObject() " Link "MUIA_HexEdit_PropObject()"}
    @{" MUIA_HexEdit_SelectMode() " Link "MUIA_HexEdit_SelectMode()"}
    @{" MUIA_HexEdit_VisibleLines() " Link "MUIA_HexEdit_VisibleLines()"}
    @{" MUIM_HexEdit_CreateDisplayAddress() " Link "MUIM_HexEdit_CreateDisplayAddress()"}
    @{" MUIM_HexEdit_FilterChar() " Link "MUIM_HexEdit_FilterChar()"}
    @{" MUIM_HexEdit_ReadMemoryByte() " Link "MUIM_HexEdit_ReadMemoryByte()"}
    @{" MUIM_HexEdit_Redraw() " Link "MUIM_HexEdit_Redraw()"}
    @{" MUIM_HexEdit_WriteMemoryByte() " Link "MUIM_HexEdit_WriteMemoryByte()"}
@EndNode

@Node "--background--" "HexEdit/--background--"

@{b}   NAME@{ub}
	HexEdit -- ... (V14)

@{b}   FUNCTION@{ub}
	This class provides you with an easy way to present hexadecimal
	dump of a memory region to the user.  Additionally, memory
	contents are visible in ASCII representation.  Editing in both
	modes is possible.  HexEdit class is very flexible, with many
	settable parameters and some critical methods (like byte reading
	and writing) waiting to be overloaded.

@EndNode

@Node "MUIA_HexEdit_ActiveField()" "HexEdit/MUIA_HexEdit_ActiveField"

@{b}   NAME@{ub}
	MUIA_HexEdit_ActiveField, @{"LONG" Link "include:exec/types.h/Main" 35} [ISG] -- ... (V14)

@{b}   SPECIAL INPUTS@{ub}
	MUIV_HexEdit_ActiveField_HexDump
	MUIV_HexEdit_ActiveField_Chars

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_ActiveField you can decide over which field of
	the object (hexdump or character) active cursor should be
	positioned.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_AddressChars()" "HexEdit/MUIA_HexEdit_AddressChars"

@{b}   NAME@{ub}
	MUIA_HexEdit_AddressChars, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   SPECIAL INPUTS@{ub}
	MUIV_AddressChars_Auto

@{b}   FUNCTION@{ub}
	This attribute lets you define how many characters will be devoted
	to representing addresses displayed by HexEdit.  For example, if
	you specify a value of 4, all addresses will be displayed as 16
	bit.  Default is 8, i.e.  32 bit.

	Address calculation's precision is not dependant on this
	attribute, it's for display purposes only.  Internally all
	addresses are treated as LONGs.

@{b}   NOTES@{ub}
	This value ranges from 1 to 8, but please see
	@{"MUIM_HexEdit_CreateDisplayAddress()" Link "MUIM_HexEdit_CreateDisplayAddress()"}.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIM_HexEdit_CreateDisplayAddress()" Link "MUIM_HexEdit_CreateDisplayAddress()"}
@EndNode

@Node "MUIA_HexEdit_BaseAddressOffset()" "HexEdit/MUIA_HexEdit_BaseAddressOffset"

@{b}   NAME@{ub}
	MUIA_HexEdit_BaseAddressOffset, @{"LONG" Link "include:exec/types.h/Main" 35} [ISG] -- ... (V14)

@{b}   FUNCTION@{ub}
	The value of this attribute is added to the current address every
	time when it is about to be displayed.  For example, if you have
	your data at 0x04000000 and you want the addresses to be shown as
	starting from 0, set this attribute to -0x04000000.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_BytesPerColumn()" "HexEdit/MUIA_HexEdit_BytesPerColumn"

@{b}   NAME@{ub}
	MUIA_HexEdit_BytesPerColumn, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_BytesPerColumn you can define how many bytes
	should constitute one column.  For example, default value of 4
	groups memory dump in a following way:

	01234567 01234567 01234567 01234567 

	By changing it to 3, you would get:

	012345 670123 456701 234567

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_BytesPerLine()" "HexEdit/MUIA_HexEdit_BytesPerLine"

@{b}   NAME@{ub}
	MUIA_HexEdit_BytesPerLine, @{"LONG" Link "include:exec/types.h/Main" 35} [..G] -- ... (V14)

@{b}   FUNCTION@{ub}
	With this attribute you can learn how many bytes are displayed in a
	single line of HexEdit object.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_ByteValue()" "HexEdit/MUIA_HexEdit_ByteValue"

@{b}   NAME@{ub}
	MUIA_HexEdit_ByteValue, @{"LONG" Link "include:exec/types.h/Main" 35} [.SG] -- ... (V14)

@{b}   FUNCTION@{ub}
	This attribute lets you read and modify the value of byte under
	the cursor.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_NibbleValue()" Link "MUIA_HexEdit_NibbleValue()"}
@EndNode

@Node "MUIA_HexEdit_ColumnsPerLine()" "HexEdit/MUIA_HexEdit_ColumnsPerLine"

@{b}   NAME@{ub}
	MUIA_HexEdit_ColumnsPerLine, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   FUNCTION@{ub}
	By querying this attribute you can learn how many columns are
	currently displayed in one line of HexEdit object.  By default,
	the number of columns varies with the size of the object.  If,
	however MUIA_HexEdit_ColumnsPerLine is set at the creation time,
	the object will always use a value then specified.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_CursorAddress()" "HexEdit/MUIA_HexEdit_CursorAddress"

@{b}   NAME@{ub}
	MUIA_HexEdit_CursorAddress, @{"LONG" Link "include:exec/types.h/Main" 35} [.SG] -- ... (V14)

@{b}   FUNCTION@{ub}
	Reading this attribute will return the cursor's current address.

	Setting it will move the cursor to a new location, possibly
	scrolling and/or redrawing the display.

@{b}   NOTES@{ub}
	Address, as usual, is specified as byte offset from
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}, @{"MUIA_HexEdit_HighBound()" Link "MUIA_HexEdit_HighBound()"},
	@{"MUIA_HexEdit_CursorNibble()" Link "MUIA_HexEdit_CursorNibble()"}
@EndNode

@Node "MUIA_HexEdit_CursorNibble()" "HexEdit/MUIA_HexEdit_CursorNibble"

@{b}   NAME@{ub}
	MUIA_HexEdit_CursorNibble, @{"LONG" Link "include:exec/types.h/Main" 35} [ISG] -- ... (V14)

@{b}   FUNCTION@{ub}
	With this attribute you can set or get the nibble over which the
	cursor is currently positioned.

@{b}   RESULTS@{ub}
	0 for upper nibble, 1 for lower nibble.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_CursorAddress()" Link "MUIA_HexEdit_CursorAddress()"}
@EndNode

@Node "MUIA_HexEdit_CursorVisible()" "HexEdit/MUIA_HexEdit_CursorVisible"

@{b}   NAME@{ub}
	MUIA_HexEdit_CursorVisible, @{"BOOL" Link "include:exec/types.h/Main" 68} [ISG] -- ... (V14)

@{b}   FUNCTION@{ub}
	With this attribute you can set and get the state of cursor's
	visibility.

@{b}   NOTES@{ub}
	Please do not attempt to switch off the cursor's while in the edit
	mode, as it may confuse the user.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_EditMode()" "HexEdit/MUIA_HexEdit_EditMode"

@{b}   NAME@{ub}
	MUIA_HexEdit_EditMode, @{"BOOL" Link "include:exec/types.h/Main" 68} [ISG] -- ... (V14)

@{b}   FUNCTION@{ub}
	This attribute determines if HexEdit object will let the user edit
	a memory space that is under its control.  If it is set to TRUE,
	user can input 0-9/a-f digits while in the hexdump part of the
	display and alphanumerics while in the character part.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_CursorVisible()" Link "MUIA_HexEdit_CursorVisible()"}, @{"MUIM_HexEdit_WriteMemoryByte()" Link "MUIM_HexEdit_WriteMemoryByte()"},
	@{"MUIM_HexEdit_FilterChar()" Link "MUIM_HexEdit_FilterChar()"}
@EndNode

@Node "MUIA_HexEdit_First()" "HexEdit/MUIA_HexEdit_First"

@{b}   NAME@{ub}
	MUIA_HexEdit_First, @{"LONG" Link "include:exec/types.h/Main" 35} [ISG] -- ... (V14)

@{b}   FUNCTION@{ub}
	MUIA_HexEdit_First specifies offset (counting from
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}) of the first byte to be displayed at the
	top of HexEdit object.  This attribute is always rounded down to a
	multiply of @{"MUIA_HexEdit_BytesPerLine()" Link "MUIA_HexEdit_BytesPerLine()"}.

@{b}   NOTES@{ub}
	In certain cases this attribute does not change, despite set()ting
	a value different from the current - for example when there are
	not enough data lines below to fill the entire HexEdit object.  If
	you want to highlight certain position, please rather use
	@{"MUIA_HexEdit_CursorAddress()" Link "MUIA_HexEdit_CursorAddress()"}.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_CursorAddress()" Link "MUIA_HexEdit_CursorAddress()"}
@EndNode

@Node "MUIA_HexEdit_FirstLine()" "HexEdit/MUIA_HexEdit_FirstLine"

@{b}   NAME@{ub}
	MUIA_HexEdit_FirstLine, @{"LONG" Link "include:exec/types.h/Main" 35} [.S.] -- ... (V14)

@{b}   SPECIAL INPUTS@{ub}
	MUIV_HexEdit_FirstLine_Up
	MUIV_HexEdit_FirstLine_Down
	MUIV_HexEdit_FirstLine_PageUp
	MUIV_HexEdit_FirstLine_PageDown
	MUIV_HexEdit_FirstLine_Top
	MUIV_HexEdit_FirstLine_Bottom

@{b}   FUNCTION@{ub}
	Changing this attribute lets you move around your memory space.

@{b}   NOTES@{ub}
	Only values listed above are allowed as input.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_FullRefresh()" "HexEdit/MUIA_HexEdit_FullRefresh"

@{b}   NAME@{ub}
	MUIA_HexEdit_FullRefresh, @{"BOOL" Link "include:exec/types.h/Main" 68} [.S.] -- ... (V14)

@{b}   FUNCTION@{ub}
	Setting this attribute to TRUE will force redraw of the entire
	object area next time @{"MUIA_HexEdit_First()" Link "MUIA_HexEdit_First()"} is set.  Normally, only
	parts that are new on display would be drawn.

@{b}   NOTES@{ub}
	This attribute may be helpful with some more exotic subclasses of
	HexEdit.  Usually, you won't need to touch it, though.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_First()" Link "MUIA_HexEdit_First()"}
@EndNode

@Node "MUIA_HexEdit_HighBound()" "HexEdit/MUIA_HexEdit_HighBound"

@{b}   NAME@{ub}
	MUIA_HexEdit_HighBound, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_HighBound you can define where in Amiga memory
	space ends the area you want HexEdit to operate on.

@{b}   NOTES@{ub}
	This attribute MUST be specified, even if you overload
	@{"MUIM_HexEdit_ReadMemoryByte()" Link "MUIM_HexEdit_ReadMemoryByte()"} or MUIM_HexEdit_WriteMemoryByte()!

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}, @{"MUIM_HexEdit_ReadMemoryByte()" Link "MUIM_HexEdit_ReadMemoryByte()"},
	@{"MUIM_HexEdit_WriteMemoryByte()" Link "MUIM_HexEdit_WriteMemoryByte()"}
@EndNode

@Node "MUIA_HexEdit_LowBound()" "HexEdit/MUIA_HexEdit_LowBound"

@{b}   NAME@{ub}
	MUIA_HexEdit_LowBound, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_LowBound you can define where in Amiga memory
	space begins the area you want HexEdit to operate on.

@{b}   NOTES@{ub}
	This attribute MUST be specified, even if you overload
	@{"MUIM_HexEdit_ReadMemoryByte()" Link "MUIM_HexEdit_ReadMemoryByte()"} or MUIM_HexEdit_WriteMemoryByte()!

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_HighBound()" Link "MUIA_HexEdit_HighBound()"}, @{"MUIM_HexEdit_ReadMemoryByte()" Link "MUIM_HexEdit_ReadMemoryByte()"},
	@{"MUIM_HexEdit_WriteMemoryByte()" Link "MUIM_HexEdit_WriteMemoryByte()"}
@EndNode

@Node "MUIA_HexEdit_MoveCursor()" "HexEdit/MUIA_HexEdit_MoveCursor"

@{b}   NAME@{ub}
	MUIA_HexEdit_MoveCursor, @{"LONG" Link "include:exec/types.h/Main" 35} [.S.] -- ... (V14)

@{b}   SPECIAL INPUTS@{ub}
	MUIV_HexEdit_MoveCursor_Up
	MUIV_HexEdit_MoveCursor_Down
	MUIV_HexEdit_MoveCursor_Left
	MUIV_HexEdit_MoveCursor_Right
	MUIV_HexEdit_MoveCursor_PageUp
	MUIV_HexEdit_MoveCursor_PageDown
	MUIV_HexEdit_MoveCursor_Top
	MUIV_HexEdit_MoveCursor_Bottom
	MUIV_HexEdit_MoveCursor_WordLeft
	MUIV_HexEdit_MoveCursor_WordRight
	MUIV_HexEdit_MoveCursor_LineStart
	MUIV_HexEdit_MoveCursor_LineEnd

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_MoveCursor you can control cursor movements
	exactly as if you were using the keyboard.  Of course, they do not
	make much sense if the cursor is actually turned off.

@{b}   NOTES@{ub}
	Only values listed above are allowed as input.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_CursorVisible()" Link "MUIA_HexEdit_CursorVisible()"}
@EndNode

@Node "MUIA_HexEdit_NibbleValue()" "HexEdit/MUIA_HexEdit_NibbleValue"

@{b}   NAME@{ub}
	MUIA_HexEdit_NibbleValue, @{"LONG" Link "include:exec/types.h/Main" 35} [.SG] -- ... (V14)

@{b}   FUNCTION@{ub}
	This attribute lets you read and modify the value of nibble under
	the cursor. The value is always passed in a lower four bits.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_ByteValue()" Link "MUIA_HexEdit_ByteValue()"}
@EndNode

@Node "MUIA_HexEdit_PropObject()" "HexEdit/MUIA_HexEdit_PropObject"

@{b}   NAME@{ub}
	MUIA_HexEdit_PropObject, @{"LONG" Link "include:exec/types.h/Main" 35} [.SG] -- ... (V14)

@{b}   FUNCTION@{ub}
	With MUIA_HexEdit_PropObject you can easily connect proportional
	gadget with the HexEdit object.  Simply pass a pointer to prop
	object as the value of this attribute and you're done.  HexEdit
	will handle all house-keeping for you. How convinient! ;)

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_SelectMode()" "HexEdit/MUIA_HexEdit_SelectMode"

@{b}   NAME@{ub}
	MUIA_HexEdit_SelectMode, @{"LONG" Link "include:exec/types.h/Main" 35} [I.G] -- ... (V14)

@{b}   SPECIAL INPUTS@{ub}
	MUIV_HexEdit_SelectMode_Nibble
	MUIV_HexEdit_SelectMode_Byte

@{b}   FUNCTION@{ub}
	This attribute defines if the cursor moving over hexadecimal data
	should span entire bytes or just single nibbles.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIA_HexEdit_VisibleLines()" "HexEdit/MUIA_HexEdit_VisibleLines"

@{b}   NAME@{ub}
	MUIA_HexEdit_VisibleLines, @{"LONG" Link "include:exec/types.h/Main" 35} [..G] -- ... (V14)

@{b}   FUNCTION@{ub}
	With this attribute you can learn how many text lines are
	currently visible in the HexEdit object.  It may be useful for
	notifications.

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIM_HexEdit_CreateDisplayAddress()" "HexEdit/MUIM_HexEdit_CreateDisplayAddress"

@{b}   NAME@{ub}
	MUIM_HexEdit_CreateDisplayAddress (V14)

@{b}   SYNOPSIS@{ub}
	DoMethod(obj, MUIM_HexEdit_CreateDisplayAddress, @{"UBYTE" Link "include:exec/types.h/Main" 46} **cp, ULONG address);

@{b}   FUNCTION@{ub}
	HexEdit class calls this method to generate ASCII representation
	of current address.  If you want to create some fancy-looking
	addresses, you can overload this method in your subclass.

@{b}   NOTES@{ub}
	If you're overloading this method, you HAVE TO set
	@{"MUIA_HexEdit_AddressChars()" Link "MUIA_HexEdit_AddressChars()"} to length of the largest output of
	your address creator, so that HexEdit knows how much space
	allocate for it.

@{b}   EXAMPLE@{ub}
	This is HexEdit's implementation of
	MUIM_HexEdit_CreateDisplayAddress method:

	ULONG __asm _CreateDisplayAddress(REG(A0) struct @{"IClass" Link "include:intuition/classes.h/Main" 25} *cl, REG(A2) @{"Object" Link "include:intuition/classusr.h/Main" 18} *obj, REG(A1) struct MUIP_HexEdit_CreateDisplayAddress *msg)
	{
		struct Data *d = INST_DATA(cl,obj);
		ULONG address;
		@{"UBYTE" Link "include:exec/types.h/Main" 46} i;
		@{"UBYTE" Link "include:exec/types.h/Main" 46} *hextable = "0123456789ABCDEF";

		address = (d->base_address + msg->address) << (HE_MAX_ADDRESS_LEN - d->address_chars * 4);

		for(i = 0; i < d->address_chars; i++)
		{
			*(*msg->cp)++ = hextable[address >> (HE_MAX_ADDRESS_LEN - 4)];
			address <<= 4;
		}

		return(TRUE);
	}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIA_HexEdit_AddressChars()" Link "MUIA_HexEdit_AddressChars()"}
@EndNode

@Node "MUIM_HexEdit_FilterChar()" "HexEdit/MUIM_HexEdit_FilterChar"

@{b}   NAME@{ub}
	MUIM_HexEdit_FilterChar (V14)

@{b}   SYNOPSIS@{ub}
	DoMethod(obj, MUIM_HexEdit_FilterChar, ULONG value, @{"UBYTE" Link "include:exec/types.h/Main" 46} *buffer);

@{b}   FUNCTION@{ub}
	HexEdit class calls this method to generate ASCII representation
	of character it is currently processing.  You can overload it to
	e.g. show only characters you want and replace others with dots.

@{b}   EXAMPLE@{ub}
	This is example implementation of MUIM_HexEdit_FilterChar:

	ULONG __asm _FilterChar(REG(A0) struct @{"IClass" Link "include:intuition/classes.h/Main" 25} *cl, REG(A2) @{"Object" Link "include:intuition/classusr.h/Main" 18} *obj, REG(A1) struct MUIP_HexEdit_FilterChar *msg)
	{
		if(isascii(msg->value))
			*msg->buffer = msg->value;
		else
			*msg->buffer = '.';

		return(TRUE);
	}


@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIM_HexEdit_ReadMemoryByte()" "HexEdit/MUIM_HexEdit_ReadMemoryByte"

@{b}   NAME@{ub}
	MUIM_HexEdit_ReadMemoryByte (V14)

@{b}   SYNOPSIS@{ub}
	DoMethod(obj, MUIM_HexEdit_ReadMemoryByte, @{"UBYTE" Link "include:exec/types.h/Main" 46} *value, ULONG address);

@{b}   FUNCTION@{ub}
	HexEdit class calls this method to read a byte from memory.  You
	can overload it in your subclass, so that operation on areas which
	are not present in Amiga's memory space is possible.

@{b}   NOTES@{ub}
	Address, as usual, is specified as byte offset from
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}

@{b}   EXAMPLE@{ub}
	This is HexEdit's implementation of MUIM_HexEdit_ReadMemoryByte
	method:

	ULONG __asm _ReadMemoryByte(REG(A0) struct @{"IClass" Link "include:intuition/classes.h/Main" 25} *cl, REG(A2) @{"Object" Link "include:intuition/classusr.h/Main" 18} *obj, REG(A1) struct MUIP_HexEdit_ReadMemoryByte *msg)
	{
		struct Data *d = INST_DATA(cl,obj);

		*msg->value = *(UBYTE *)(d->bound_low + msg->address);

		return(TRUE);
	}


@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIM_HexEdit_WriteMemoryByte()" Link "MUIM_HexEdit_WriteMemoryByte()"}
@EndNode

@Node "MUIM_HexEdit_Redraw()" "HexEdit/MUIM_HexEdit_Redraw"

@{b}   NAME@{ub}
	MUIM_HexEdit_Redraw (V14)

@{b}   SYNOPSIS@{ub}
	DoMethod(obj, MUIM_HexEdit_Redraw);

@{b}   FUNCTION@{ub}
	Redraws the entire object's contents.

@{b}   NOTES@{ub}

@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
@EndNode

@Node "MUIM_HexEdit_WriteMemoryByte()" "HexEdit/MUIM_HexEdit_WriteMemoryByte"

@{b}   NAME@{ub}
	MUIM_HexEdit_WriteMemoryByte (V14)

@{b}   SYNOPSIS@{ub}
	DoMethod(obj, MUIM_HexEdit_ReadMemoryByte, ULONG value, ULONG address);

@{b}   FUNCTION@{ub}
	HexEdit class calls this method to write a byte to memory.  You
	can overload it in your subclass, so that operation on areas which
	are not present in Amiga's memory space is possible.

@{b}   NOTES@{ub}
	Address, as usual, is specified as byte offset from
	@{"MUIA_HexEdit_LowBound()" Link "MUIA_HexEdit_LowBound()"}

@{b}   EXAMPLE@{ub}
	This is HexEdit's implementation of MUIM_HexEdit_WriteMemoryByte
	method:

	ULONG __asm _WriteMemoryByte(REG(A0) struct @{"IClass" Link "include:intuition/classes.h/Main" 25} *cl, REG(A2) @{"Object" Link "include:intuition/classusr.h/Main" 18} *obj, REG(A1) struct MUIP_HexEdit_WriteMemoryByte *msg)
	{
		struct Data *d = INST_DATA(cl,obj);

		*(UBYTE *)(d->bound_low + msg->address) = msg->value;

		return(TRUE);
	}


@{b}   BUGS@{ub}
	No known bugs.

@{b}   SEE ALSO@{ub}
	@{"MUIM_HexEdit_ReadMemoryByte()" Link "MUIM_HexEdit_ReadMemoryByte()"}
@EndNode

