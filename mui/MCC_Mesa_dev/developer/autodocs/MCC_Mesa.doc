TABLE OF CONTENTS

Mesa.mcc/Mesa.mcc
Mesa.mcc/MUIA_Mesa_Base
Mesa.mcc/MUIA_Mesa_Context
Mesa.mcc/MUIA_Mesa_Display
Mesa.mcc/MUIA_Mesa_DrawHook
Mesa.mcc/MUIA_Mesa_DriverBase
Mesa.mcc/MUIA_Mesa_Resized
Mesa.mcc/MUIA_Mesa_ResizeHook
Mesa.mcc/MUIA_Mesa_Tags
Mesa.mcc/MUIA_Mesa_UseSubtask
Mesa.mcc/MUIM_Mesa_Redraw
Mesa.mcc/Mesa.mcc

This class allows you to use OpenGL graphics in MUI programs.
Every Mesa object creates its own rendering context. You can use it and
issue any GL commands, results will be visible after glFlush().
Preferable way is to define a draw hook that will be called anytime mesa
object needs to be refreshed.

Szymon Ulatowski, szulat@friko6.onet.pl

 Mesa MCC support site: 
http://friko6.onet.pl/rz/szulat/mesamcc/

 AmigaMesaRTL:
http://kcbbs.gen.nz/~jarno/

Mesa.mcc/MUIA_Mesa_Base

    NAME
	MUIA_Mesa_Base -- [I.G], struct Library*

    FUNCTION
   Gives you the "mesamain.library" base, being used by this object.  You
   can also specify this tag at creation time to supply your own base (if
   you want to share it across Mesa instances or open the library yourself).
   Otherwise the object opens own library and you have to use this tag value
   as the base for in Mesa function calls.

    NOTE
   You may not share mesaBase when using subtask rendering in multiple
   objects!

    SEE ALSO
	MUIA_Mesa_DriverBase, MUIA_Mesa_Context, MUIA_Mesa_UseSubtask
	
Mesa.mcc/MUIA_Mesa_Context

    NAME
	MUIA_Mesa_Context -- [..G], AmigaMesaRTLContext

    FUNCTION
   This is Mesa rendering context used by the object.  You may need this value
   for AmigaMesaRTL driver functions.

   In many common circumstances the object sets the context automaticaly.
   You don't need to do call AmigaMesaRTLMakeCurrent() manually:
    - after object creation
    - in DrawHook
    - in ResizeHook

    SEE ALSO
	MUIA_Mesa_Base

Mesa.mcc/MUIA_Mesa_Display
  
    NAME
	MUIA_Mesa_Mesa_Display -- [..G], int

    SPECIAL VALUES
   MUIV_Mesa_Display_Hidden
   MUIV_Mesa_Display_OK
   MUIV_Mesa_Display_Unable
   MUIV_Mesa_Display_Waiting
 
    FUNCTON
   You can check here, what's the display status of your object.
   Notification is also allowed.

   MUIV_Mesa_Display_Hidden:  object is not visible at the moment.  You can
     use this to prevent from creating the graphics that nobody will see
     (but it steals your cpu time)

   MUIV_Mesa_Display_OK:  quantizer was initialized properly and it claims
     the picture is shown to the user

   MUIV_Mesa_Display_Unable: a quantizer can not be found or it can not
     display in a given environment

   MUIV_Mesa_Display_Waiting: object is waiting for subtask to render
     the graphics (only if MUIA_Mesa_UseSubtask is enabled)


    EXAMPLE

   DoMethod(mesa_ob,MUIM_Notify,MUIA_Mesa_Display,MUIV_Mesa_Display_Unable,
		mesa_ob,3,MUIM_Set,MUIA_ShortHelp,
      "Alert! You have to select another quantizer module!");
   DoMethod(mesa_ob,MUIM_Notify,MUIA_Mesa_Display,MUIV_Mesa_Display_OK,
		mesa_ob,3,MUIM_Set,MUIA_ShortHelp,0);

Mesa.mcc/MUIA_Mesa_DrawHook

    NAME
	MUIA_Mesa_DrawHook -- [IS.], struct Hook*

    FUNCTION
   A given hook will be called every time mesa object needs to be
   refreshed. You should put glFlush() at the end of your function if you
   want to see something!
   Before calling your hook the object's context is set as current, so you
   don't have to call MakeCurrent().

    NOTES
   When using subtask rendering, your hook function is executed by
   a background task. You will receive SIGBREAKF_CTRL_D signal when
   your mesa object wants to start a new rendering (eg. because 
   the user changed some parameters and expects to see a new picture).
	It's up to you what you do with this signal.
   You can:
	1.Abort the function and don't call glFlush()
	 - In that case Mesa will call it again from the begining
		The user won't see the current drawing, but only the final
      version.
	2.Ignore the signal
	 - User will see your drawing and then mesa will start the next one
      (so we delay that image)
	3.Draw something quick
	 - You can draw a simplified version of the scene (or call glFlush
      without drawing all objects)
      It's the compromise: user will see some feedback immediately and
      also the next image will not be delayed too much

   You should choose the action that is most proper for the application.
   See the demo program for the complete example.
   
    EXAMPLE
   Draw a wire sphere if the break signal is received or the solid
   one under normal conditions.

    if (CheckSignal(SIGBREAKF_CTRL_D))
	     glutWireSphere(1.0, 20, 8);
    else
	     glutSolidSphere(1.2, 20, 8); break;
    glFlush();


    SEE ALSO
	MUIM_Mesa_Redraw, MUIA_Mesa_Base, MUIA_Mesa_Context, 
   MUIA_Mesa_UseSubtask

Mesa.mcc/MUIA_Mesa_DriverBase

    NAME
	MUIA_Mesa_DriverBase -- [..G], struct Library*

    FUNCTION
   You can get the value of "mesadriverBase" here. If your object opens its own
   library, you have to use this base in driver functions.
   There is no need to use this tag in single-task or single-object
   applications.

    SEE ALSO
	MUIM_Mesa_Base

Mesa.mcc/MUIA_Mesa_Resized

    NAME
	MUIA_Mesa_Resized -- [..G], BOOL

    FUNCTION
   TRUE means the object was resized recently and needs a glViewport()
   call. You can set up a notification on this tag or use it normal way
   (eg. in your redraw funtion)

    SEE ALSO
	MUIA_Mesa_ResizeHook

Mesa.mcc/MUIA_Mesa_ResizeHook

    NAME
	MUIA_Mesa_ResizeHook -- [IS.], struct Hook*

    SPECIAL INPUT
   MUIV_Mesa_ResizeHook_DefaultViewport

    FUNCTION
   Your hook will be called each time the object is resized and you should
   use glViewport() to set display rectangle for Mesa.
   Before calling your hook the proper context is set as current, so you
   don't have to call MakeCurrent().
   Your hook function will receive a pointer to MCCMesaResizeData in A1:

   struct MCCMesaResizeData {long Width,Height;};

   'Width' and 'Height' are of course the new display size for your object.

   MUIV_Mesa_ResizeHook_DefaultViewport will automatically call
   glViewport(0,0,Width,Height), this may be sufficient in many simple
   cases.


    SEE ALSO
	MUIA_Mesa_Resized, MUIA_Mesa_Base, MUIA_Mesa_Context

Mesa.mcc/MUIA_Mesa_Tags

    NAME
	MUIA_Mesa_Tags -- [I..]

    FUNCTION
   Here you can specify initial Mesa tags.  You give a pointer to the tag
   array that will be passed to AmigaMesaRTLCreateContext. Probably you
   need to put here {AMRTL_RGBMode,TRUE,TAG_END} or
   {AMRTL_IndexMode,TRUE,TAG_END}

Mesa.mcc/MUIA_Mesa_UseSubtask

    NAME
   MUIA_Mesa_UseSubtask -- [I..], BOOL

    FUNCTION
   If TRUE, mesa will spawn a new background task for your DrawHook
   and window refresh will not be blocked by mesa objects refreshing.
   3D rendering can be very time consuming so you should always
   use this tag if you can make your application work safe in
   multitasking. 
   
   Default is FALSE.

    NOTES

   1. When using this feature, every object has to use different
   mesamainBase (and also glut.library if you use it). This means
   you have to get MUIA_Mesa_Base from the newly created object
   and call the GL functions relative to this base. The only exception
   is if you have only one mesa object, you can use global mesa
   base in that case.

   2. Mesa drawing functions use lot of stack space. If you don't use
   subtask rendering, your main task should have stack bigger than
	70000. Object creation will fail otherwise.
   With 'UseSubtask' enabled, the new process will automaticaly get
   a big stack.

   3.  You should check if your application supports multitasking.  Is it
   designed to let many tasks access the data used by your drawing routine?


    SEE ALSO
   MUIA_Mesa_Base, MUIA_Mesa_DrawHook


Mesa.mcc/MUIM_Mesa_Redraw

    NAME
	MUIM_Mesa_Redraw
 
    FUNCTON
   Ask the object to redraw itself (DrawHook will be called).
   
    EXAMPLE
   A button starts image rendering:

   DoMethod(button,MUIM_Notify,MUIA_Selected,0,
		mesa_ob,1,MUIM_Mesa_Redraw);

    SEE ALSO
	MUIA_Mesa_DrawHook
