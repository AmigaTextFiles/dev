@database BCC
@$VER: 1.0

@Index Index

@node "Main" "BCC"

                                 BCC v3.51 BETA
             Precompiler for easy building BOOPSI/MUI classes

                         (c)1998 by Rafaî Mantiuk 
                     This piece of software is @{b}Mailware @{ub}


        @{" Introduction " link Background}
        @{" Copyright    " link Copyright }
        @{" Requirements " link Requirements }
        @{" Installation " link Installation}
        @{" Tutorial     " link Tutorial}
        @{" Syntax       " link Syntax}
        @{" Usage        " link Usage} 
        @{" Options      " link Options} 
        @{" Examples     " link Examples}
        @{" Known bugs   " link Bugs}  
        @{" Bug report   " link BugReport}
        @{" Author       " link Author}     
        @{" History      " link History}


Note: This version should have never been released. I was going to
stop developement at v3.3. But a few mails I'd got convinced me that
two or three more releases are worth my work. However I'm not going
to continue developing up to v9.9. I'm going to fix all the bugs I
was or will be reported on and add only a few minor improvements that
don't require much efforts. 

See History for list of changes.

@endnode

@node "Background" "Background "
I wrote this program because of two reasons:

-) to limit boring typing when building up MUI or BOOPSI custom classes,

-) to make a source code more readable.

Although there was a similar program - MUI2C (v1.7), I didn't like its syntax,
way of associating tag values, one class - only one file, and other limitations.
BCC is free of these disadvantages and provides:

-) references to the methods and attributes by simple '->' like in
C++. For example:

	instead of:	SetAttr( win, MUIA_Window_Open, TRUE, TAG_DONE );
	type just: win->Open = TRUE;

	or instead of: DoMethod( list, MUIM_List_GetEntry, 0, &e );
	type: list->GetEntry( 0, &e );

-) You feel like it would be realy C++ when You type:
	'New foo( MUIA_foo_arg1, 1 )' intead of 
		NewObject( cl_foo->mcc_Class, NULL, MUIA_foo_arg1, 1 ) 
	'Delete blee' intead of DisposeObject( blee )

-) handles both MUI and BOOPSI classes

-) very nice syntax (like C++)

-) methods of one class can be placed in many files

-) user doesn't care about tag values, they are calculated from tag names
(hashing). Since v3.0, own tag base can be specified.

-) easy handling parameters that are passed to methods

-) <class data> variables accessed as local variables; simple <xx> instead
of data-><xx> 

-) very convenient handling of OM_SET and OM_GET

-) extra tags can be easily passed to the super class when OM_NEW is called

-) there is option file, so the user can configurate the program to fit his
needs. To handle options easier, the program with GUI is provided. 

-) user can place his stuff in a class' header file

-) both public and private classes can be super classes

-) C and C++ comments are handled

-) also strings are processed correctly

-) in case of syntax error, full information (where and why)

-) and even more ...


@endnode

@node Installation Installation

 To install BCC follow the steps.

@{b}Step 1@{ub}

Copy BCC precompiler (file "BCC") to a directory that the shell looks for
executables in. It can be C:, SC:c/ or other.

@{b}Step 2@{ub}

Copy BCCOpts to the same directory as the file "BCC".

@{b}Step 3@{ub}

Copy <.bcc_files> to ENV:bcc/ and ENVARC/bcc. Copy files from only one of the
directories:
 
	.bcc-files/MUI - suggested
	.bcc-files/BOOPSI -  if You are sure You will not use MUI

See @{".bcc_files" link bcc_files} for more information.

@{b}Step 4@{ub}

 a) Copy BCClib/Includes/libraries/bcc.h to Your <include>/libraries
directory.

 b) Copy one of the bcc.lib files (BCClib/lib/...) to Your LIB: directory. 
If none of these files works with Your compiler, make proper linkable library
from the sources (BCClib/sources). If You sent me the library You created, so
I could include it in the next release , I would appreciate it.

See @{"BCC lib" link BCClib} for more information


@endnode

@node Copyright Copyright

 This software is subject to the "Standard Amiga FD-Software Copyright Note".
 It is MAILWARE as defined in paragraph 4b. If You find this program useful,
 send me a mail with Your opinion, suggestions or just an information You
 use it.

 For more information please read @{"AFD-COPYRIGHT" link AFD-COPYRIGHT/} (Version 1 or higher).


@endnode

@node bcc_Files ".bcc_<xx> files"

When BCC generates .c or .h file, it includes the proper .bcc_<xx> file at
the beginning of the output file. 

.bcc_every - inserted in every generated file
.bcc_header - inserted in <xx>.h files
.bcc_code - inserted in <xx>.c files
.bcc_initcl - inserted in initcl.c file

The files above are included in this archive. You may change them to adopt
to Your compiler and environment.

BCC looks for these files in the current directory, then in ENV:bcc/. So if
You want to override default .bcc_<xx> files, copy new ones to the current 
directory.



@endnode

@node BCClib "'bcc.lib' linkable library"

BCC generates sources, which refers to the following functions and macros:

      BCC_Set( obj, attr, val );	/* macro */
 LONG BCC_XGet( obj, attr );
ULONG BCC_DoSuperNew( cl, obj, tag1, ... );

Neither intuition.library nor amiga.lib provides such functions, so they
must be delivered in extra library. BCC.lib is such a library.

This library will grow up in the future.



@endnode

@node "Syntax" "Syntax"

When BCC parses the <name>.bc or <name>.bh file, it copies the text it doesn't
understand or creates the proper code when it encounters special keyword. C and
C++ comments are ignored. Strings ("") are processed correctly.

Every BCC class consists of two files: its header with definition and one
or more files with methods and attributes. 

The header file name must be exactly the same as class name plus ".bh" suffix.
For example: "foo.bh" if name of the class is "foo". Case of the letter is
significant even if it's filename (like under UNIX system).

There must be at least one file with methods or attributes (if class has no
methods it can be even an empty file). The name of this file should be the name
of the class that methods belong to plus ".bc" suffix. For example:
"foo.bc" if name of the class is foo. This file is very important because
dispatcher, OM_SET, OM_GET and other stuff will be appended to it. Also all
super methods, attributes, constructor and destructor MUST be placed in this
file. Other methods can be placed in any ".bc" file.

When BCC is executed with the parameter "foo.bc" (cli command: "BCC
foo.bc") file "foo.bc" is translated into "foo.c". "foo.c" is ready for
C or C++ compilation. If the file "foo.bc" includes any ".bh" files
(#include "foo.bh"), then all those include files will be scanned or
translated into <xxx>.h files. BCC checks if <xxx>.bh has more recent date
than <xxx>.h and if it does BCC translates it. Otherwise BCC only scans
this file. Note that system clock must be set to the current date.


See how to organize @{"<class name>.bh" link Header} file
                and @{"<class name>.bc" link Body} file

After that see also how to use @{"BCC syntax outside methods" link BCCBlock }


@endnode

@node Header "Header file (.bh)"

<class name>.bh file (similar to C++'s <xxx>.h file) contains class definition
and extra stuff like #defines and #includes. There must NOT be any code for 
methods or attributes. The legal syntax for this file is:

/* Place for #includes and defines */

<user stuff>

[@{"selfcreate" link selfcreate}][@{"MUI|BOP" link MUIBOP}] Class <name>@{"[:<super class>]" link sclass} {

	@{"[<class data>]" link classdata}

	@{"[Method <mname1>();]" link methoddef}
	[Method <mname2>();]
	.......

	@{"[Attribute <aname1>;]" link customattr}
	[Attribute <aname2>;]
	........

};

/* Place for #includes and defines */

<user stuff>


Example 1:
(file name is "My.bh" )

@{i}#include <graphics/gfx.h>

MUI Class My: MUIC_Area {

        ULONG data1:SG, data2:I, data3;

        Method Beep( );

        Attribute Xval:S;

};

#define FOO 10
@{ui}

@endnode



@node Body "BCC code file (.bc)"

This file contains code for 

@{"-)" link method} methods 

@{"-)" link attribute} attributes.


See also @{"'->' references" link newref} to methods and attributes.

Note: At the beginning of <xx>.bc file there should be:

#include "<header file>.bh"

where header file contains definition of class that all methods and
attributes in <xx>.bc file belong to. If You refer to other classes
but You do not declare any method or attributes of these classes, put:

#include "<header file>.h"

Do not put any '#include "<header file>.bh"' inside <xx>.bh file.


@{b}Example 1:@{ub}
(file name is My.bc)

@{i}#include <My.bh>        /* Include class header */

Method My::Beep( struct Screen *scr )   /* method with parameters */ 
{
        if( data1 ) DisplayBeep( scr ); 
}

Method My::My():                        /* creator (OM_NEW) */
   MUIA_Background, MUII_WindowBack     /* extra tags passed to the super class */
{

        if( !data2 ) mreturn 0;        /* use mreturn to return from a method */

        data3 = FOO;

}

Method My::~My()                        /* destructor (OM_DISPOSE) */
{
        DoMethod( obj, MUIM_My_Beep );
}

Attribute Set Xval                          /* Xval custom attribute */ 
{
        data3 = val;
        obj->MUIM_My_Beep( );
}
@{ui}

@endnode

@node newref "-> references"

You no longer need to type:

	SetAttr( win, MUIA_Window_Open, TRUE, TAG_DONE );

as You can do it by simple

	win->Open = TRUE;

Only think to do is to declare 'win' as a MUI Window class' object:

	MUI Class *win;

You can put such a declaration in <class data> or as local variable inside
Your method or attribute.

There are three ways of referring to object:

		<obj>-><method>( <pars> ) for DoMethod()
		<obj>-><attribute> = <x> for SetAttrs()
		<obj>-><attribute> for GetAttr()

Note 1: You can not combine set and get attribute. The code:
	a = (foo->Attribute = x);
WON'T work !!!!

Note 2: If a method or attribute doesn't belong to object's class but to
object's super class (MUIC_Notify, MUIC_Area), You must give the super
class' name. For example:

	 listview->@{b}List_@{ub}GetEntry( 0, &e );

or: listview->_Frame = MUIV_Frame_None; 

if class name should not appear in <MUIA_XXX> string (MUIA_Frame, 
MUIA_Background of MUIC_Area).

Note 3: BCC doesn't check if class, method or attribute really exists. If
You type something wrong, the error will be catch by the C compiler.

Note 4: Inside method or attribute variable 'obj' may be also accessed by
'->'.

Note 5: Unlike C++, current class method are accessed by 'obj->met()', not
simple 'met()'.

Note 6: Get attribute (<obj>-><attribute>) always returns 'unsigned long'
value. So You should force type of returned value, for example:
	bm = (struct BitMap*)(Pic->bm);

@endnode

@node MUIBOP "MUI and BOOPSI classes"

BCC can generate both mui and BOOPSI classes. Of course mui classes are
also BOOPSI classes, but they are handled with muimaster.library.

Switch 'BOP' or 'MUI' should be placed before 'Class' definition to select
type of the class. BOOPSI and MUI classes have different tag prefixes and
class creation functions.

@endnode

@node sclass "[:<super class>]"

This is an optional parameter. You can specify any super class, for
example: MUIC_Area, "gadgetclass", etc. If you don't provide this
parameter MUIC_Notify or "rootclass" will be used.

If You want to privide a private class as a super class, put keyword
'private' and <class name>. For example:

MUI Class NewXZY: private OldXYZ {
...

Pointer to super class must be available in global variable 
cl_<class name> (for example: cl_OldXYZ). If this is MUI class it 
must be 'struct MUI_CustomClass*', if BOOPSI - 'struct IClass*'.


@endnode

@node attribute "Attributes"

Attributes are long word variables that can be set or read. Two special
methods: OM_SET and OM_GET are used to handle them. Under BCC user doesn't
need to cope with these methods. They are automatically generated.

BCC provides two types of attributes:

@{"-)" link simpleattr} simple attributes

@{"-)" link customattr} custom attributes

General notes for both types of attributes:

For each attribute tag is defined. The tag name is: MUIA_<class name>_<attr
name> or BOPA_<class name>_<attr name>. Such names are compatible with mui
system. You don't need to specify tag values, i.e. numbers associated with
tag names. You even don't need to worry about base value for tags. All
tag values are calculated from tag names. Such a technique is called
hashing. The advantage of this is tag values are always the same and
doesn't depend on order of methods/attributes in source file (like in case
of MUI2C). There are also disadvantages : such a technique can produce two
different tags with the same values (rather low possibility) and it's not
recommended by MUI author (every developer should have his own tag base).
In spite of these disadvantages, such a solution saves a lot of time. I
often used to debug programs only to find that tag values were invalid.

Note for v3.0: Both disadvantages have been removed. User can specify his
very own tag base. The range of hashing will be reduced, so the possibility
of being two tags with same tag value is higher in such case. But now
this also is not a problem. All tag values are compared to each other, so
if same tag value is encountered twice, the proper worning appears.



@endnode

@node customattr "Custom attributes"

@{b}Custom attributes@{ub} must be defined inside Class definition:

	Attribute <name>:[S][G][I]

So the tag: MUIA_<name> or BOPA_<name> will be created.

Note: default type is 'S'. So if you don't specify type it will be ':S'.

Next, code for this attribute must appear in <class name>.bc file. It would
look like this:

[@{"super" link super}][virtual] Attribute <classname>::<name>:[S][G][I][(<partype> <parname> )]
{

[<user code>]

}

<user code> can access "obj", "cl" and "data" variables. If it's of type
'Get', put result in '*store' variable, if it's 'Set' or 'Init' - use
'value' to get value.

New for v3.1: You no longer need to use 'value' of type ULONG and 'store'
of type 'ULONG*'. You can define Your own parameter. For example:

Attribute MyCl::Attr1:S( struct foo *f )
{
....
}

You can access 'struct foo' as an ordinary parameter.

Note: You must use types that can be transfomed to ULONG, for example:
pointers, long, etc.

This is an option so if You want to use standard 'store' and 'value', don't
put '( <partype> <parname> )'. For example:

Attribute MyCl::Attr1:S
{
....
}

If You want to use the same code for both Init and Set, type:

Attribute AA::BB:SI
{
...
}

@{b}Very important note: If the custom attribute is Init You must place it
before constructor. You must specify constructor even if You don't want
to put any code inside.@{ub}


There is also the old syntax (obsolete) accepted:

	Attribute Set AA::BB equals Attribute AA::BB:S
or	Attribute Get AA::BB equals Attribute AA::BB:G
or Attribute Init AA::BB equals Attribute AA::BB:I

You can not use old syntax for: Attribute AA::BB:SI

Note: If you wish to write your own OM_SET/OM_GET methods use ONLY
virtual attributes (BCC do not generate OM_SET/GET for them).
Your own OM_SET or OM_GET define as follows:

super Method foo::OM_SET()
{
 [code]
}


Note: Code for custom attributes may refer to opSet and opGet structures. This is
particulary required when creating BOOPSI classes. For example: to access ops_GInfo
in opSet/Get, write: msg->ops_GInfo.


@{b}Example 1:@{ub}

@{i}Attribute App::Port:G
{
	*store = cycle->Active;
}@{ui}

@{b}Example 2:@{ub}

@{i}Attribute App::State:S
{
 ULONG v, x;
 STRPTR cont;
 v = value  & JP_DIRECTION_MASK;


	if( value != lastval ) {
		RawDoFmt( "$%lx", (ULONG*)&value, myputch, txbuf );
		dval->Contents = txbuf;
	}

	( .......... )

}@{ui}


@endnode


@node classdata "<class data>"

BCC generates typedef <class name>Data, which contains all variables from the
body of the class definition. There must be given at least one such a variable.
All @{i}data@{ui} variables will be of type of this typedef.

All <class data> variables can be easily associated with @{"simple attributes" link simpleattr}.

Variables can have their @{b}default values@{ub}. Default values are copied to
variables just after variables are declared ( and eventually set to '0' ),
but before simple Init Attributes are parsed. All this actions are done 
inside creator (OM_NEW). 

To assign defalut value to variable use '='. For example:

	short a = 0, b = 1, c;

	long X:SGI = 100, Y:SGI = 100;

	long BufSize = DEF_BUF_SIZE;


You can't assign default value to 'x[]' variables.


@endnode


@node simpleattr "Simple attributes"

If the only function of attribute is to set or get variable from <class
data>, simple attributes are the best way to handle this. They don't need
any code. All what You have to do is to put a ':' after defined variable
(inside @{"class definition" link header}) then select type of it made from the letters 'S',
'G' and 'I'. For example:

@{i}MUI Class blee {

 ULONG par:I, var1:SG, var2:G, var3;

};@{ui}

If the variable is of 'S' type it can be set, if 'G' - get, if 'I' - set at
the initialization time (inside OM_NEW).

For each simple attribute the tag will be generated. For the given example
there would be the following tags:

	MUIA_blee_par
	MUIA_blee_var1
	MUIA_blee_var2

If it were a BOOPSI class it would be:

	BOPA_blee_par
	......

Note 1: var3 is an ordinary variable and can not be set or get by OM_SET
and OM_GET.

Note 2: all variables associated to simple attributes must be of size
4-bytes. You can use LONG, ULONG and all pointers, but you can't use BYTE
or WORD. Be careful about this because BCC doesn't check if the size is
proper.

See also @{"custom attributes" link customattr}

@endnode

@node methoddef "Method definition"

You have to define (inside Class definition) only the methods that belong
to this class (whose name starts with XXXM_<class name>_). You don't need
to define creator (OM_NEW), destructor (OM_DISPOSE) or super class' methods
(MUIM_Draw, MUIM_Clean, MUIM_Show, ... ).

Method definition looks like this:

	[virtual] @{i}Method <name>( );@{ui}

For each method, tag is defined: MUIM_<class name>_<name> or BOPM_<class
name>_<name>. Tag values for these tag names are hashed. See @{"attributes" link attribute} to
find how this system works.

If You specify switch virtual (works both for method and attribute), tags
will be generated but there won't be any reference to this method from
the dispatcher. It's useful, if You wan't to refer to the higher level
class from the super class. For example: There is a class that handles
lists. One of its method scanes all list nodes and executes some code for
each list node . This 'some code' may be refered by a hook, but this is not
very nice way to do it. Better solution is to define virtual method
(virtual Method ScanProc();) and put obj->ScanProc( node ) where 'some code'
should be executed. Then You create super class with super method 'ScanProc'.


@endnode


@node method "Method"

There are four types of methods:

@{"-)"link OM_NEW} constructor (OM_NEW)

@{"-)" link OM_DISPOSE} destructor (OM_DISPOSE)

@{"-)" link super} super class' methods (MUIM_Draw, MUIM_Show, ... )

@{"-)" link thismethod} this class' methods

Only the last ones must be defined.

General notes for all types of methods:

Method's code can refer to variables 'cl' - pointer to class, 'obj' -
pointer to this object and 'msg' - pointer to a message. You can also refer
to 'data' structure. It contains all variables You specified inside class
definition (See @{"[<class data>]" link classdata}).

Don't use 'return <res>' to return from method (unless you specified @{"custom" link custom}
switch). Use 'mreturn <res>' instead. Use positive (=1) <res> for success
and zero (=0) for failure . Note that this differs in the case of constructor.

Variable '_res' is ULONG that will be returned when the method exits. You can
change this variable directly, or use 'mreturn'.

You can access <class data> variables as they were local variables. You
don't need to type 'data->var' since simple 'var' is enough. For compatibility
reasons 'data-><xx>' is also valid syntax (no data->data-><xx> will be
generated).


@endnode


@node thismethod "This class' method"


Having @{"defined method" link methoddef}, code for this method should be declared. The right
place for this is <class name>.bc file. But unless it's super class'
method, creator or destructor, such a code can be put in <anyname>.bc file.
(Remember to insert: '#include "<class name>.bh"' at the beginning of .bc
file).

Method declaration matches the syntax:

[@{"custom" link custom}|@{"super" link super}] Method <class name>::<name>( <type1> <par1>, <type2>
<par2>, ... )
{

[<user code>]

}


See also @{"Parameters" link Parameters}

Example 1:

@{i}Method EJG::Anim( unsigned long sig )
{
	if( render ) {
		if( sig ) hit = 1;
		MUI_Redraw( obj, MADF_DRAWUPDATE );
	}
}@{ui}


@endnode


@node super "Super method"

@{b}Super methods@{ub} are those methods that belong to super class and are
only pre or post processed by Your custom class. For example super class
method is MUIM_Draw or MUIM_Show.

Custom class' methods don't need to be defined; there MUST NOT be any sign
of them inside 'Class' definition (.bh file). But they MUST be placed in
<class name>.bc file.

There must be super switch before declaration of this kind of method. There
must be full method name given.

The following super methods are handled properly (the right code is
inserted):

	MUIM_AskMinMax
	MUIM_Draw
	MUIM_HandleInput
	MUIM_Cleanup
	MUIM_Setup
	MUIM_Show
	MUIM_Hide
	MUIM_DragBegin
	MUIM_DragDrop
	MUIM_DragFinish
	MUIM_DragQuery
	MUIM_DragReport
   MUIM_DrawBackground
   MUIM_ContextMenuChoice
   MUIM_ContextMenuBuild
   MUIM_HandleEvent

If You specifi one of those methods You don't need to care about call to
the super class. Also msg is of the right type, for example MUIP_Draw for
MUIM_Draw.

If You want to use super method that is not on this list You have to help
the precompiler and define what kind of code there should be inserted. For
this reason there are three extra switches: 'presuper', 'postsuper' and
'supercheck'. When 'presuper' is set, super method is called before your
code, whereas 'postsuper' calls super method after Your code. If the
'supercheck' is active, method execution is stopped if super method or your
code returns 0.


Example 1:

@{i}super Method EJG::MUIM_AskMinMax()
{
	msg->MinMaxInfo->MinWidth  += 50;
	msg->MinMaxInfo->DefWidth  += 120;
	msg->MinMaxInfo->MaxWidth  += MBQ_MUI_MAXMAX;

	msg->MinMaxInfo->MinHeight += 6;
	msg->MinMaxInfo->DefHeight += 6;
	msg->MinMaxInfo->MaxHeight += 6;

}@{ui}

Example 2:

@{i}super Method EJG::MUIM_Draw()
{

	if ( msg->flags & MADF_DRAWUPDATE ) {

		SetBPen( _rp( obj ), 0 );
		ScrollRaster( _rp( obj ), 1, 0, _mleft( obj )+1, _mtop( obj ), _mright( obj ), _mbottom( obj ) );
		if( hit ) {
			SetAPen( _rp( obj ), 2 );
			WritePixel( _rp( obj ), _mright( obj ), _mtop( obj ) + 1 );
		}
		else {
			SetAPen( _rp( obj ), 1 );
			WritePixel( _rp( obj ), _mright( obj ), _mtop( obj ) + 4 );
		}

		hit = 0;

	}
	
}@{ui}


@endnode

@node OM_NEW "Constructor (OM_NEW)"

The code for constructor should be placed within <class name>.bc file and follow
the syntax:

[@{"cleardata" link cleardata}|@{"custom" link custom}] Method <class name>::<class name>( )
	[:tagname1, tagval1,
	tagname2, tagval2 ]
{

[user code]

}

When an error occurs, use 'mreturn 0'. This will call 
CoerceMethod( cl, obj, OM_DISPOSE ) and return 0. When everything went ok
and You want to perform return inside code - use 'mreturn obj'. Don't use
'mreturn obj' at the end of the method code.

BCC let You access data variables even before object is created. Thus you
can store values in data of Your object when specifing tags for super
class. For example:

Method foo::foo():
	Child, str = StringObject,
	.....

Where 'str' is a member of data structure. Such references are possible,
because BCC creates temporary data structure. Then, after object was
created, contents of temporary data is copied to real data structure.

If You don't use data in ':[tag1, ...' block, You can specify @{b}noearlydata@{ub}
switch. The data will be available after object is created. No not
neccesary code will be inserted.

@{b}Example 1:@{ub}

@{i}cleardata Method MyApp::MyApp()
[ int a ]
:		MUIA_Application_Base, "JOYTEST",
		MUIA_Application_Title, "JoyTest",
		MUIA_Application_Version, "$VER: JOYTEST 1.0 "__AMIGADATE__,
		MUIA_Application_Copyright, "Copyright (c)1997, Rafaî Mantiuk",
		MUIA_Application_Description, "Joystick test."
{

	for( a = 0; a < 10; a++ ) pt[a] = 1;

}
@{ui}

@{b}Example 2:@{ub}

@{i}Method MyApp::MyApp()
{

	if( !InitParam ) mreturn 0;

}
@{ui}

@{b}Example 3:@{ub}

@{i}custom Method MyApp::MyApp()
{

  if( !(obj = (Object*)DoSuperMethodA( cl, obj, msg )) ) return 0;

  return (ULONG)obj;

}
@{ui}

@endnode

@node cleardata cleardata

"cleardata" switch can be used only before constructor method. It
guarantees that object data is filled with 0. It inserts:

	@{i}memset( data, 0, sizeof( <class name>Data );@{ui}

just after 

	@{i}data = INST_DATA( cl, obj );@{ui}

@endnode

@node nodata nodata

!!!OBSOLETE!!! (automatic detection since v3.5)

"nodata" can be used with any method or custom attribute. When "nodata"
switch is set, variable @{i}data@{ui} is not defined; line:

	@{i}data = INST_DATA( cl, obj );@{ui}

is NOT inserted in a code. This removes C compiler warning "variable data
never used".

@endnode

@node custom custom

"custom" switch can be used with any method. When it's set, BCC generates
no extra code for method; user has to define data, call super class, return
value, etc. himself. It works like '*' in MUI2C.


@endnode

@node ecode "<early code>"

!!!OBSOLETE!!!

<early code> is put before any generated code. There should go all the
declarations since C language syntax requires that declarations are put
before any code.

Wrong. Declarations must go just after '{' but not neccessary at the
begining of the procedure. I hadn't known it since somene smarter than me
told me that. Now BCC inserts '{' thus solving all the problem.

Note: Used only in constructor method.

@endnode

@node OM_DISPOSE "Destructor (OM_DISPOSE)"

The code for destructor should be placed within <class name>.bc file and follow
the syntax:

Method <class name>::~<class name>( )
{

[user code]

}

@{b}Example 1:@{ub}

@{i}Method MyApp::~MyApp()
{

	DisplayBeep( NULL );

}
@{ui}

@{b}Example 2:@{ub}

@{i}Method MyApp::~MyApp()
{

	DeleteMsgPort( port );

}
@{ui}

@endnode

@node BCCBlock

BCC syntax outside methods
--------------------------

With the aid of "BCCBlock" instruction you can use BCC syntax outside
methods and attributes. For example:

BCCBlock {/*BEG OF BCCBlock*/

MUI Class App *app;

void cprocedure( void )
{

	app = new App( TAG_DONE );
	app->variable = 1;
}


} /*END OF BCCBlock*/

BCCBlock can be nested, i.e. you can put BCCBlock inside another one.

Note that, even if there are neither Methods nor attributes, suffix for
file name should be '.bc'

See also example program JoyTest (MUI_Main.bc)


@endnode


@node History History

v3.5 (23.2.98)
----
-) BCC v3.5 performs multiple parses over single file, so that it can
foresee what will happen inside the method. These feature let me make 
automatic detection for switches 'nodata' and 'noearlydata' thus making
them obsolete. You need no longer cope with those overcomplicated switches.
BCC will decide what code should be generated.
-) Inside custom Attributes structs opSet and opGet are available. This is
necessary for BOOPSI classes that must refer to msg->ops_GInfo.
-) OM_GET return TRUE if the given tagvalue was found and processed, FALSE
otherwise
-) String handling improved. This should fix the problem with long names, or
... cause even more problems if there are some bugs.
-) BCCBlock : see @{"BCC syntax outside methods" link BCCBlock }
-) A few changes that might well reduce system crushes :-). I'm still working
on it.

v3.4 (10.10.97)
----
-) Adds extra brackets inside every Method/Attribute so there is no longer
problem with declarations after code inserted by BCC. Example (it's generated
C code):

static unsigned long mFieldMUIM_Draw( struct IClass *cl, Object *obj, struct MUIP_Draw* msg )
{
 unsigned long _ret = 1;
 FieldData *data = INST_DATA( cl, obj );
 _ret = DoSuperMethodA( cl, obj, (Msg)msg );

{	/* <= this makes that the following declarations are accepted by
		C compiler */

 Object  *brd;
 struct RastPort *rp = 0;
 long ty, sx, sy;


v3.3 (1.10.97)
----
@{"-)" link classdata 8} default values for data-><xx> variables.
@{"-)" link bclines} preprocessor #line command inserted.
-) bug fixed: for Attributes: ti_Tag intead of ti_Data.
-) a few changes in parser, so it should work better now.


v3.2
----
-) new syntax is generated for parameters: instead of (not very nice) forcing
type of 'msg' twice ( ((type)((ULONG*)msg)[x]) *-| ), unnamed structure is
created, so msg members can be accessed: msg-><parname>, or short version:
<parname>. These changes didn't afect compatibility to the previous
versions.
-) there is also new syntax for attribute's parameters. Instead of value of
ti_Data, pointer to TagItem structure is passed.
-) new way of declaration attributes: intead of	'Attribute Set AA::BB',
there is 'Attribute AA::BB:S'. The old syntax is also accepted.
-) custom attributes can be Set and Init at the same time, there is no need
to write separate code for both.
-) bug fixed: init custom attributes just didn't work.
-) bug fixed: "-) bug fixed: init attributes were parsed before 'obj' was 
initialized. So pointer to 'obj' for all init attributes was invalid." -
this was only partialy fixed. I forgot to correct it for constructor
without extra tags. Sorry. Now it should be OK.
-) bug fixed: when file name contained numbers, '#ifndef <name>' was
inserted with wrong name.
-) bug fixed: program printed 'BCC v3.0', althought it was version v3.1


v3.1 (22.6.97)
----
-) major changes in code for attributes. Now, attributes can be even super.
Attribute parameter doesn't need to be ULONG val or ULONG *store. User can
define name and type of these parameters.
-) bug fixed: attribute parameter name for Get and Init was 'val' instead
of 'value'
-) bug fixed: init attributes were parsed before 'obj' was initialized. So
pointer to 'obj' for all init attributes was invalid.
-) '#define value' is no longer used. It caused problems with mui.h.
-) new switch for class 'selfcreate'
-) if there are both method and dispatcher in the same file, function
for method is 'static'.
-) new 'bccopts' gui v1.1.
-) international characters are handled.

v3.0 (15.6.97)
----
-) 'New <class>()' instead of NewObject()
-) 'Delete <obj>' instead of DisposeObject()
-) options
-) gui to handle option file
-) user can specify tag base
-) check for two same tag values
-) virtual methods and attributes
-) now generated .h files starts with:
    #ifndef <fname>
    #define <fname>
   and ends:
    #endif
-) more super class' methods handled:
    MUIM_DrawBackground
    MUIM_ContextMenuChoice
    MUIM_ContextMenuBuild
    MUIM_HandleEvent
-) procedures for '->' class references were rewritten. Now, they are more
   flexible. You can use class definition even as a type of method parameter.
-) new switch: noearlydata
-) bug fixed: bcc initcl could generate initcl.c that creates classes in
   the wrong order. The class was created, whereas it's super class hadn't
   been created (and so available) yet.
-) bug fixed: when there was nither method nor attribute inside .bh, BCC
   didn't work.
-) bug fixed: error report showed wrong file name
-) bug fixed: there was no include of clib/alib_protos.h inside .bcc_code.

v2.0 (1.6.97)
----
-) New way of referring to objects, their methods and attributes:
		<obj>-><method>( <pars> ) for DoMethod()
		<obj>-><attribute> = <x> for SetAttrs()
		<obj>-><attribute> for GetAttr()
-) <class data> refered as local variables.
-) Private class can be super class.
-) BCC uses 'bcc.lib' - linkable library.
-) There are new and better '.bcc_<xx>' files.
-) Super class' methods for MUI's drag&drob handled.
-) Strings handled properly.
-) To handle method parameters defines are no longer used. BCC replaces code
   itself. This solve problems with structures. In version v1.0 the code below
   wasn't handled properly.
			Method xx::yy( struct BitMap *BitMap )
			{
				struct BitMap bm;
				......
			}
   'BitMap' was replaced with parameter reference. Now it works OK.
-) No multiple includes.
-) Comments works fine now.
-) Many minor changes.

v1.0 (22.5.97)
----
First public release . Many things must be corrected. I want to get to know
if there is anybody interested in this piece of software.

@endnode

@node Author Author

This one was written by Rafal Mantiuk. After long struggle with laziness,
he created this piece of software, wrote a guide (in language that at least
looks like English), and provided it to the public. Although he didn't expect
any reward, You, thankful user, may encourage him in his efforts by
sending an e-mail ( or better money :-) ).

If the gods make the server still work, the e-mail address is:

	cret@cerber.ii.tuniv.szczecin.pl





@endnode


@node Examples Examples

The best way to learn BCC syntax is to look at example programs. JoyTest is
a complete program that works and can be compiled (SAS C recommended).
'smakefile' for this program is a good example how to adopt BCC to the
compiler.

For v3.0 there is also a source for BCCopts included.


@endnode

@node Usage Usage

BCC is a cli command and should be executed as follows:

	BCC <name>.bc

File <name>.bc will be translated into <name>.c. The <hname>.bh files that
<name>.bc refers to will be also processed.

If You created a new class You should update initcl.c file. You can do it
this way:

	BCC initcl

File 'initcl.c' contains two functions: '_initclasses()' and
'_freeclasses()'. '_initclasses()' must be called before any NewObject()
call and '_freeclasses()' should be called when the program exits.
Remember to check the result of '_initclasses()' for TRUE value. If it
returns FALSE, that means the program should be terminated, because classes
weren't created. The classes are available via cl_<name> global variables.
Note that for MUI classes these are pointers to MUI_CustomClass structures
and struct IClass* for BOOPSI classes.

Note 1: BCC consumes vast quantities of stack. If there any any problems, set
stack for 20 Kb.

Note 2: BCC is compiled for 68020, as I don't think there is anyone who
programs with 68000.

@endnode

@node Options Options

Version 3.0 of BCC lets the user configurate the program. This can be done
by editing file 'BCCOptions' (text file), or better with the help of
BCCopts.

Local and global options

When BCC starts, it tries to load options from file 'BCCOptions' in the
current directory. Such option file is called local options. When local
options are not available (there is not such file), BCC looks for global
options. Global options are written in file 'ENV:bcc/BCCOptions'. Except
directory there is no difference between format of local and global
options.

BCCOpts note: Gadget 'Save' saves local options, whereas 'Save default'
saves global options.

Note: BCC uses one or another option file. Two of them are not overridden .
So if there is local option file, global one doesn't affect any option.

Option file format

Each option (with its arguments) must be placed in separate line. No spaces
before option name are allowed. There should be precisely one space
character before argument. For example:

tagbase 0231
verbose

Options

@{"-)" link deftype} deftype
@{"-)" link tagbase} tagbase
@{"-)" link incdir} incdir
@{"-)" link noversion} noversion
@{"-)" link verbose} verbose
@{"-)" link forcetrans} forcetrans
@{"-)" link bclines} bclines

@endnode

@node bclines

	bclines

When 'bclines' is set, BCC inserts '#line' preprocessor commands. This makes
correcting errors easier. When error in '.c' file occurs, the compiler
refers to corresponding line in '.bc' file. This makes finding mistakes
very convenient, but also it makes debugging difficult. Because some
code doesn't exists in .bc file (but exists in .c file) debugger can 
act sometimes unproperly.



@endnode

@node deftype 

	deftype [MUI|BOP]

Sets the default type of tags. If there is no 'BOP' or 'MUI' string before
class declaration or definition, the class is of default type. For example:

if the option file consists:

	deftype BOP

and there is class definition somewhere in .bh file:

	Class foo {

		....

	};

Class foo is of type 'BOP'; all tags start with BOPA_ or BOPM_


@endnode


@node tagbase

	tagbase <four hex digits>

Defines upper 16 bits of tag value.

See also @{"Attributes " link attribute}

Note: Having changed this attribute recompile all the project (smake -a) to
avoid problems.

@endnode

@node incdir

	incdir "<dir>"

Specify directory that .bcc-files are placed in. By default this directory
is "ENV:bcc/". If You want to put these files somewhere else, specify
their directory in this option.

Note: Directory name must be surrounded by double quotes.


@endnode


@node noversion

	noversion

If it's set, line:

BCC v<x>.<y>

is not printed when BCC is executed.

@endnode

@node verbose

	verbose

Prints additional information during program execution.

@endnode

@node forcetrans

	forcetrans

By default, .bh files are translated into .h only when they are modified .
Otherwise they are scanned (no .h file is created). If this option is set,
.bh files are always translated.

@endnode

@node Bugs

BCC requires that every input file ends with empty line; there must be EOL
(return) at the end of file.

Example:

wrong:

	/*this is the last line*/<eol>

correct:

	/*this is the last line*/
	<eol>

This problem is not caused by BCC, but by the bug in StormC library. If the
line doesn't end with EOL, function fgets() fills the buffer with single 0.
It's not correct beheavior, because it should fill the buffer with context
of read line and put 0 at the end of this string.

This will be corrected as soon as the bug from storm.lib will be removed.

@endnode

@node selfcreate

When selfcreate switch is set, tha class is created at the first call to
NewObject. You MUST use <xx>Object macro instead of NewObject(
<xx>->mcc_Class, ... ).

Class with 'selfcreate' set doesn't require any initialization code. Such
classes doesn't affect file 'initcl.c'.

Pointer to the class ('cl_<xx>') is placed in file '<xx>.c'.

@endnode

@node Requirements

-) KickStart v2.0+

-) MC68020+

-) mui v3.0+ (for 'bccopts', not necessary)

-) knowledge how to handle BOOPSI classes



@endnode

@node Parameters

Ordinary methods (not super ones) can handle parameters. They are defined
in the same way as function parameters in 'C' language. For example:

Method AA::BB( long par1, long *par2 )
{
...
}

Parameters are also refered in the same way as C language . In the example
above it would be just 'par1' and 'par2'. Method addresses can be obtained:
'&par1' and '&par2'.

There is only one difference: @{b}all method parameters must be four byte
long@{ub}. So You can use 'long', 'unsigned long' and all pointers, but You
MUST NOT use 'short' or 'char'. Be careful about this because BCC doesn't
check if the size is proper.

How does it works? BCC creates unnamed structure that contains all the
parameters plus special parameter 'unsigned long MethodID' at the beginning.
Variable 'msg' contains pointer to this structure. All references to
parameters are modified so they are really references to members of 'msg'.
For example: 'par' would be changed to '(msg->par)'. Typing 'msg->par' to
refer to parameter is also valid syntax so You can use both 'par' and
'msg->par'. To get special parameter 'MethodID' (equals to tag value for
the method) You can only use 'msg->MethodID'.



@endnode

@node Tutorial

This chapter is for people who don't like reading all the instruction
before running program. Follow the steps to learn quick and easy main 
BCC features. But remeber that this tutorial doesn't cover all options
and features. So You will have to take a look into the instruction soon or
later.

To save work and time we use ready project and add a new class to it.

Step one
--------

Create catalog, in which the new project will be located.
Copy all the files from catalog with sources for BCCOpts to this catalog.

Step two
--------

Define class: Create file with the name 'MyClass.bh' containing:

---cut---
Class MyClass: MUIC_Area {

	ULONG pad;

};
---cut---

Note that although we don't use any class data there must be at least one
data member inside class definition (in this case 'ULONG pad;'). Because we
will use only super methods for this class (MUIM_AskMinMax, MUIM_Draw), we
don't need to define any methods inside class definition.

Step three
----------

Write class' code: Create file with the name 'MyClass.bc' containing:

---cut---
#include <proto/graphics.h>
#include "MyClass.bh"

super Method MyClass::MUIM_AskMinMax()
{
	msg->MinMaxInfo->MinWidth  += 50;
	msg->MinMaxInfo->DefWidth  += 120;
	msg->MinMaxInfo->MaxWidth  += MBQ_MUI_MAXMAX;

	msg->MinMaxInfo->MinHeight += 50;
	msg->MinMaxInfo->DefHeight += 240;
	msg->MinMaxInfo->MaxHeight += MBQ_MUI_MAXMAX;

}

super Method MyClass::MUIM_Draw()
{
	if ( msg->flags & MADF_DRAWOBJECT ) {
		SetAPen( _rp( obj ), 1 );
		Move( _rp( obj ), _mleft( obj ), _mtop( obj ) );
		Draw( _rp( obj ), _mright( obj ), _mbottom( obj ) );
	}
}
---cut---

This is a code for super methods: MUIM_AskMinMax, MUIM_Draw. 

Step four
---------

Use this class in the application: Add lines:

---cut---
	Child, MyClassObject,
	End,
---cut---

to 'App.bc' in the proper place (for example line 108).

Step five
---------

Correct smakefile: 
!!Important!! Change variable PROG from 'BCCopts' to something else.
Add 'MyClass.o' to OBJS variable (must be before 'App.o' because 'App.o'
uses 'MyClass.o')

Add at the end of the file:

---cut---
MyClass.o: MyClass.c
MyClass.c: MyClass.bc MyClass.bh
---cut---

Step six
--------

Execute shell command: 'BCC initcl'
This will update file 'initcl.c' and 'initcl.h'
Of course the current directory must be the catalog where the project is.

Step seven
----------

Now You can compile the program and run it.


If everything went OK You can start experimenting with some BCC features

Creating own Method, creator with extra tags and '->' references
----------------------------------------------------------------

Step one: put method definition inside class definition (file 'MyClass.bh')

---cut---
	Method Beep();
---cut---

Step two: put code for this method in file 'MyClass.bc':

---cut---
Method MyClass::Beep()
{
	Class Window *win;

	win = (Object*)obj->_WindowObject;
	if( win ) DisplayBeep( (struct Screen*)win->Screen );

}
---cut---

There is a sign '_' before WindowObject because this is a reference to
super class attribute; not attribute of class MyClass.

Step three

Make the method workinkg: the method will be executed each time object is
pressed.

Put creator in 'MyClass.bc'

---cut---
Method MyClass::MyClass():
	MUIA_InputMode, MUIV_InputMode_RelVerify
{

	obj->_Notify( 
		MUIA_Pressed, TRUE,
		obj, 1, MUIM_MyClass_Beep );


}
---cut---

Step four: Compile and run.


@endnode

@node BugReport

BCC is not thoroughly tested. I spent more time on adding new features
than on testing them. Now, the program is too complcated to test each possible
input file. Thus the only way to correct my mistakes is to send me
bug report. And I strongly encourage to doing it.

Sending me an information that program crashes when you do this or that
is not enought. I need an example. <foo>.bc file and corresponding <foo>.bh
file will do. You don't need to send me all the program. But if you like to
show me your masterpiece you created using BCC, I would be delighted.

Besides an example send me a short description. This can be really short, 
for example: 'computer crashes'.

Don't send me information about crashes or malfunctions that occur not
regulary. I need .bc file that always has "bad effect" on BCC.



@endnode

