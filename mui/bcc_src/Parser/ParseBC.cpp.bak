#include "ParseBC.h"
#include "ClassDef.h"
#include "MethodDef.h"
#include "VarDef.h"

#include "Global.h"

#include <string.h>

short ParseBC::Start( void )
{

	ins_every.Insert( ofh );
	ins_code.Insert( ofh );
	
	switches = 0;
	
	while( 1 ) {
	
		GetToken();
		if( !TokLen ) break;
		
		if( TokType == ALN ) {
			if( TokLen == 6 && !strncmp( "Method", Tok, 6 ) ) {
				if( !DoMA() ) {
					if( !ErrorBuf ) Error( 12 );
					return 0;
				}
				switches = 0;
			} else {
			if( TokLen == 7 && !strncmp( "include", Tok, 7 ) ) {
				if( !DoHeader() ) {
					if( !ErrorBuf ) Error( 12 );
					return 0;
				}
			} else {
			if( TokLen == 9 && !strncmp( "Attribute", Tok, 9 ) ) {
				if( !DoMA( 1 ) ) {
					if( !ErrorBuf ) Error( 12 );
					return 0;
				}
				switches = 0;
			} else {
			if( TokLen == 6 && !strncmp( "nodata", Tok, 6 ) ) {
				switches |= SW_NODATA;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 6 && !strncmp( "custom", Tok, 6 ) ) {
				switches |= SW_CUSTOM;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 8 && !strncmp( "presuper", Tok, 8 ) ) {
				switches |= SW_PRESUPER;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 9 && !strncmp( "postsuper", Tok, 9 ) ) {
				switches |= SW_POSTSUPER;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 10 && !strncmp( "supercheck", Tok, 10 ) ) {
				switches |= SW_SUPERCHECK;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 11 && !strncmp( "noearlydata", Tok, 11 ) ) {
				switches |= SW_NOEARLYDATA;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 9 && !strncmp( "cleardata", Tok, 9 ) ) {
				switches |= SW_CLEARDATA;
				StopCopy();
				StartCopy();
			} else {
			if( TokLen == 5 && !strncmp( "super", Tok, 5 ) ) {
				switches |= SW_SUPER;
				StopCopy();
				StartCopy();
			} else switches = 0;
			}
			}
			}
			}
			}
			}
			}
			}
			}
			}
		}

		
	}
	
	FScan( ClassDef, c1, &ClassList ) {
		if( !stricmp( sfname, c1->Name ) ) {
			cd = c1;
			CreateDisp( ofh );
		}
	}
	
	return 1;

}

short ParseBC::DoMA( short attr )
{
 short BLevel;
 short mdspec = 0;
 MethodDef *md;

	reppar.Clear();
	clref.Clear();

	StopCopy();

	GetToken();
	if( !TokLen ) return 0;
	
	if( attr ) {
	
		switches |= SW_CUSTOM;
		
		if( TokLen == 3 && !strncmp( "Set", Tok, 3 ) ) switches |= SW_SET;
		else {
		if( TokLen == 3 && !strncmp( "Get", Tok, 3 ) ) switches |= SW_GET;
		else {
		if( TokLen == 4 && !strncmp( "Init", Tok, 4 ) ) switches |= SW_INIT;
		else {
			Error( 10 );
			return 0;
		}
		}
		}

		GetToken();
		if( !TokLen ) return 0;

	}
		
	cd = (ClassDef*)(ClassList.FindItem( Tok, TokLen ));
	
	if( !cd ) {
		Error( 6 );
		return 0;
	}

	GetToken();
	if( !TokLen ) return 0;
	
	if( TokLen != 2 || strncmp( Tok, "::", 2 ) ) {
		Error( 7 );
		return 0;
	}

	GetToken();
	if( !TokLen ) return 0;

	BLevel = MBracket;

	switches |= stricmp( sfname, cd->Name ) ? 0 : SW_LOCAL;
	if( switches & SW_LOCAL ) fprintf( ofh, "static " );

	if( !attr ) {

	if( TokLen == strlen( cd->Name ) && !strncmp( cd->Name, Tok, TokLen ) ) {
		md = new MethodDef( "OM_NEW", 6, 0, switches );
		cd->AddTail( (Family*)md );
		mdspec = 1;
	} else {

	if( TokLen == strlen( cd->Name )+1 && *Tok == '~' && !strncmp( cd->Name, Tok+1, TokLen-1 ) ) {
		md = new MethodDef( "OM_DISPOSE", 10, 0, switches );
		cd->AddTail( (Family*)md );
		mdspec = 2;
	} else {

	if( switches & SW_SUPER ) {
		md = new MethodDef( Tok, TokLen, 0, switches );
		cd->AddTail( (Family*)md );
	} else {
		md = (MethodDef*)(cd->FindItem( Tok, TokLen ));
		md->switches |= switches;
	}
	
	}
	
	}
	
	if( !md ) {
		Error( 8 );
		return 0;
	}
	
	if( md->switches & SW_VIRTUAL ) {
		Error( 17 );
		return 0;
	}
	
	switches |= md->switches;
	
	short CLevel = CBracket;
			
	GetToken();
	if( !TokLen ) return 0;
			
	if( !chcmp( '(' ) ) {
		Error( 5 );
		return 0;
	}

	/* Parameters */
	
	char pbuf[100];
	pbuf[0] = 0;
	short i1 = 0, i2 = 0, iscl = 0;
	long num = 1;
	InitClassPtrDef();
	
	while( 1 ) {
	
	beg_par:
		GetToken();
		if( !TokLen ) return 0;
		
		short ret;
		ret = ClassPtrDefinition( &clref, 0, 1 );
		if( ret == -1 ) return 0;
		if( ret ) iscl = 1;

		if( ( chcmp( ')' ) && CBracket == CLevel ) || chcmp( ',' ) ) {
		
			if( chcmp( ')' ) && num == 1 && !i1 ) break;

			if( i2 <= 1 ) {
				Error( 13 );
				return 0;
			}
			
			char prep[50], ptype[30];
			if( iscl ) strcpy( ptype, "Object*" );
			else {
				memcpy( ptype, pbuf+1, i2-2 );
				ptype[i2-2] = 0;
			}
			iscl = 0;
			sprintf( prep, "((%s)((ULONG*)msg)[%ld])", ptype, num );
			reppar.Add( pbuf+i2, i1-i2, prep, 0 );
			
			i1 = i2 = 0;
			num++;
			if( chcmp( ')' ) ) break;
			goto beg_par;
		}	
		
		pbuf[i1] = ' ';
		i1++;
		memcpy( pbuf + i1, Tok, TokLen );

		i2 = i1;
		i1 += TokLen;
		

	}
	
	fprintf( ofh, "unsigned long m%s%s( struct IClass *cl, Object *obj, %s msg )\n", cd->Name, md->Name, md->msgtype );
	
	fprintf( ofh, "{\n" );

	short sbrc = SBracket;

	GetToken();
	if( !TokLen ) return 0;

	/* early code */	
	InitClassPtrDef();
	if( chcmp( '[' ) ) {
		StartCopy();
		while( 1 ) {

			GetToken();
			if( !TokLen ) return 0;
			
			if( chcmp( ']' ) && sbrc == SBracket ) break;

			if( ClassPtrDefinition( &clref ) == -1 ) return 0;
			
		}
		StopCopy();

		GetToken();
		if( !TokLen ) return 0;

	}
	
	if( !(switches & SW_CUSTOM) ) {
	
		if( mdspec == 1 ) fprintf( ofh, " unsigned long _ret;\n" );
		else fprintf( ofh, " unsigned long _ret = 1;\n" );
	
	/* OM_NEW */
	if( mdspec == 1 ) {
	
		if( chcmp( ':' ) ) {

			InsertIAttrPre( ofh );
			
			if( !(switches & SW_NODATA) ) {
				if( switches & SW_NOEARLYDATA ) {
					fprintf( ofh, " %sData *data;\n", cd->Name );
				} else {
					fprintf( ofh, " %sData *data, _tdata;\n data = &_tdata;\n", cd->Name );
					if( switches & SW_CLEARDATA ) fprintf( ofh, " memset( data, 0, sizeof( %sData ) );\n", cd->Name );
				}
			}

			fprintf( ofh, " obj = (Object*)BCC_DoSuperNew( cl, obj,\n" );

			StartCopy();
		
			while( 1 ) {
			
				GetToken();
				if( !TokLen ) return 0;

				short rcr;
				rcr = FullCheck( );
				if( rcr == -1 ) return 0;

				if( chcmp( '{' ) ) break;

			}
			
			StopCopy();
			
			fprintf( ofh, ",\n TAG_MORE, (unsigned long)msg->ops_AttrList,\n TAG_DONE );\n" );
			
			InsertIAttr( ofh );
			
			fprintf( ofh, " _ret = (unsigned long)obj;\n if( !obj ) return 0;\n" );
			if( !(switches & SW_NODATA ) ) {
				if( switches & SW_NOEARLYDATA ) {
					fprintf( ofh, " data = INST_DATA( cl, obj );\n", cd->Name );
					if( switches & SW_CLEARDATA ) fprintf( ofh, " memset( data, 0, sizeof( %sData ) );\n", cd->Name );
				} else fprintf( ofh, " data = INST_DATA( cl, obj );\n memcpy( data, &_tdata, sizeof( %sData ) );\n", cd->Name );
			}
		} else {
			InsertIAttrPre( ofh );
			if( !(switches & SW_NODATA) ) {
				if( cont ) {
					fprintf( ofh, " %sData *data, _tdata;\n data = &_tdata;\n", cd->Name );
					if( switches & SW_CLEARDATA ) fprintf( ofh, " memset( data, 0, sizeof( %sData ) );\n", cd->Name );
				} else fprintf( ofh, " %sData *data;\n", cd->Name );
			}
			InsertIAttr( ofh );
			fprintf( ofh, " obj = (Object*)DoSuperMethodA( cl, obj, (Msg)msg );\n" );
			fprintf( ofh, " _ret = (unsigned long)obj;\n if( !obj ) return 0;\n" );
			if( !(switches & SW_NODATA ) ) {
				if( cont ) {
					fprintf( ofh, " data = INST_DATA( cl, obj );\n memcpy( data, &_tdata, sizeof( %sData ) );\n", cd->Name );
				} else {
					fprintf( ofh, " data = INST_DATA( cl, obj );\n" );
					if( switches & SW_CLEARDATA ) fprintf( ofh, " memset( data, 0, sizeof( %sData ) );\n", cd->Name );
				}
			}
		}
	/* Other method */
	} else {
		if( !(switches & SW_NODATA ) ) fprintf( ofh, " %sData *data = INST_DATA( cl, obj );\n", cd->Name );
		if( switches & SW_PRESUPER ) {
			fprintf( ofh, " _ret = DoSuperMethodA( cl, obj, (Msg)msg );\n" );
			if( switches & SW_SUPERCHECK ) fprintf( ofh, " if( !_ret ) return 0;\n" );
		}
	}
	
	}
	
	} else {
	/* Attribute mode */
	
		VarDef *vd;

		if( switches & SW_SUPER ) {
			vd = new VarDef( Tok, TokLen, switches );
			cd->Var.AddTail( (Family*)vd );
		} else 
		if( !(vd = (VarDef*)((TextItem*)&cd->Var)->FindItem( Tok, TokLen )) ) {
			Error( 11 );
			return 0;
		}
		
		vd->switches |= switches;

		if( vd->switches & SW_SIMPLE ) {
			Error( 14 );
			return 0;
		}
		
		if( vd->switches & SW_VIRTUAL ) {
			Error( 17 );
			return 0;
		}


		fprintf( ofh, "void a%s%s", cd->Name, vd->Name );
		if( vd->switches & SW_GET ) {
			fprintf( ofh, "Get( struct IClass *cl, Object *obj, " );
		} else {
			if( vd->switches & SW_SET ) fprintf( ofh, "Set" );
			else fprintf( ofh, "Init" );
			fprintf( ofh, "( struct IClass *cl, Object *obj, " );
		}

		short CLevel = CBracket;
		
		GetToken();
		if( !TokLen ) return 0;
		
		if( chcmp( '(' ) ) {
		
			StartCopy();
		
			short s_par, e_par = 0, e_typ = 0, f_time = 1, c_line;
			
			c_line = LineN;
			s_par = TokStart+TokLen;
		
			while( 1 ) {
	
				GetToken();
				if( !TokLen ) return 0;
				
				if( c_line != LineN ) {
					Error( 21 );
					return 0;
				}
				
				short ret;
				ret = ClassPtrDefinition( &clref );
				if( ret == -1 ) return 0;

				if( chcmp( ')' ) && CBracket == CLevel ) break;

				e_typ = e_par;
				e_par = TokStart;
				
			}
			
			StopCopy();
			
			if( e_par ) {
				memcpy( vd->ParType, LineBuf+s_par, e_par - s_par );
				vd->ParType[e_par-s_par] = 0;
			}

			GetToken();
			if( !TokLen ) return 0;
			
		} else {
			if( vd->switches & SW_GET ) {
				fprintf( ofh, " unsigned long *store" );
				strcpy( vd->ParType, "unsigned long*" );
			}
			else {
				fprintf( ofh, " unsigned long value" );
				strcpy( vd->ParType, "unsigned long" );
			}
		}
		

		
		fprintf( ofh, " )\n{\n" );
 
		if( !(switches & SW_NODATA ) ) fprintf( ofh, " %sData *data = INST_DATA( cl, obj );\n", cd->Name );

	}

	if( !chcmp( '{' ) ) {
		Error( 2 );
		return 0;
	}

	fprintf( ofh, " /* UC Beg */\n" );

	StartCopy();
	
	short wasmret = 0;
	
	char objrefbuf[30];
	strcpy( objrefbuf, cd->type );
	strcpy( objrefbuf+3, cd->Name );
	clref.Add( "obj", 3, objrefbuf, 0 );

	InitClassPtrDef();

	/* Inside code */		
	while( 1 ) {
	
		again:

		GetToken();
		if( !TokLen ) break;
		
		short rcr;

		rcr = FullCheck( );
		if( rcr == -1 ) return 0;
		if( rcr ) goto again;

		if( chcmp( '}' ) && MBracket == BLevel ) break;

		rcr = ClassPtrDefinition( &clref );
		if( rcr == -1 ) return 0;
		if( rcr ) goto again;

		if( TokLen == 7 && !strncmp( Tok, "mreturn", 7 ) ) {
			StopCopy();
			fprintf( ofh, "{ _ret = " );
			StartCopy();
			
			while( 1 ) {
				GetToken();
				if( !TokLen ) return 0;
				
				if( chcmp( ';' ) ) break;
			}
			
			StopCopy();
			StartCopy();
			
			fprintf( ofh, "; goto %s_exit; } ", md->Name );
			wasmret = 1;
		}
	
	}

	fprintf( ofh, "\n /* UC End */\n" );
	
	if( !(switches & SW_CUSTOM) ) {
	
		fprintf( ofh, "%s_exit:\n", md->Name );

		if( mdspec == 1 ) {
			if( wasmret ) fprintf( ofh, " if( !_ret ) CoerceMethod( cl, obj, OM_DISPOSE );\n" );
		} else
		if( switches & SW_POSTSUPER ) {
			if( switches & SW_SUPERCHECK ) fprintf( ofh, " if( !_ret ) return 0;\n" );
			fprintf( ofh, " _ret = DoSuperMethodA( cl, obj, (Msg)msg );\n" );
		}
		
		fprintf( ofh, "return _ret;\n" );
	
	}

	return 1;

}
