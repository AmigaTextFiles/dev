TABLE OF CONTENTS

muiextend.library/MUIE_DisposeObjects
muiextend.library/MUIE_GetAttr
muiextend.library/MUIE_Main
muiextend.library/MUIE_MakeAll.DONT.USE
muiextend.library/MUIE_MakeMethods
muiextend.library/MUIE_MakeObjects
muiextend.library/MUIE_SetAttrs
muiextend.library/MUIE_DisposeObjects   muiextend.library/MUIE_DisposeObjects

   NAME
	MUIE_DisposeObjects -- Disposes a RealObject tree.

   SYNOPSIS
	MUIE_DisposeObjects( ObjectTree )
	                         a0
	void MUIE_DisposeObjects( struct RealObject );

   FUNCTION
	This disposes all the *root* objects in the tree, and sets all the object
	pointers to NULL.

   INPUTS
	ObjectTree - This is a tree of RealObject structures. You should never
	    actually have to play with them yourself, but using the Object MACROs
	    to create them it is quite simple.

   NOTES
	You should use this rather than disposing the objects yourself as it will
	take care of any RO_Next objects, useful for ContextMenus!

   SEE ALSO
	muimaster.library/MUI_DisposeObject(), MUIE_MakeObjects(),
	libraries/muiextend_macros.i.

muiextend.library/MUIE_GetAttr                 muiextend.library/MUIE_GetAttr

   NAME
	MUIE_GetAttr -- Performs a GetAttr and returns the result in d0.

   SYNOPSIS
	attr = MUIE_GetAttr( AttrID, Object )
	 d0                    d0      a0
	ULONG MUIE_GetAttr( ULONG, struct RealObject * );

   FUNCTION
	This does almost exactly the same as intuition.library/GetAttr, but
	returns the result in d0 instead of in memory.

   INPUTS
	AttrID - the attribute tag ID understood by the object's class.
	Object - Pointer to the RealObject that you are interested in.

   RESULT
	Returns the data GetAttrs sends to StaragePtr.

   NOTES
	Although there should be no problems using this, you should use GetAttrs
	itself, as this also tells you if it was successful, with this a result
	of 0 could be either a return or a fail.

   SEE ALSO
	intuition.library/GetAttrs(), MUIE_SetAttrs()

muiextend.library/MUIE_Main                       muiextend.library/MUIE_Main

   NAME
	MUIE_Main -- Basically a Wait() loop, but is MUI-legal.

   SYNOPSIS
	MUIE_Main( ApplicationObject )
	                  a0
	void MUIE_Main( struct RealObject * );

   FUNCTION
	It contains all the code for a Wait() loop, including checking on
	signals, in a totally MUI-Legal way. When it returns the user has asked
	to quit, and this has been confirmed if needed.

   INPUTS
	ApplicationObject - Pointer to Application's RealObject.

   NOTES
	If you have designed your application properly then there should be no
	problem using this.

   SEE ALSO
	exec.library/Wait(), MUIE_MakeObjects().

muiextend.library/MUIE_MakeAll.DONT.USEuiextend.library/MUIE_MakeAll.DONT.USE

   NAME
	MUIE_MakeAll -- ** DONT USE ** DONT USE ** DONT USE **

   SYNOPSIS
	result = MUIE_MakeAll( ObjectTree, MethodList, Flags )
	  d0                       a0          a1       d0
	BOOL MUIE_MakeAll( struct RealObject *, struct RealMethod *, ULONG );

   FUNCTION
	Just joins together MUIE_MakeObjects and MUIE_MakeMethods. I thought it
	might be useful to put them together and see what happened.

	* DONT USE ** DONT USE ** DONT USE ** DONT USE ** DONT USE ** DONT USE *

	I will probably change the format of this in the near future to allow for
	automatic creation of Custom Classes, MUIE_Main, then freeing and
	quitting totally automagically.

   INPUTS
	ObjectTree - This is a tree of RealObject structures. You should never
	    actually have to play with them yourself, but using the Object MACRO
	    to create them it is quite simple.
	MethodList - This is a list of RealMethod structures. You should never
	    actually have to play with them yourself, but using the Method MACRO
	    to create them it is quite simple.
	Flags - currently unused. Any ideas?

   RESULT
	TRUE if MakeObjects succeeded, FALSE otherwise

   BUGS
	This will only fail if the object creation failed, I don't know any way
	to make it fail with a dud method.

   SEE ALSO
	MakeObjects(), MakeMethods().

muiextend.library/MUIE_MakeMethods         muiextend.library/MUIE_MakeMethods

   NAME
	MUIE_MakeMethods -- Make an entire MUIMethod list in one go.

   SYNOPSIS
	result = MUIE_MakeMethods( MethodList, Flags )
	  d0                           a0       d0
	ULONG MUIE_MakeMethods( struct RealMethod *, ULONG );

   FUNCTION
	This is really simple - you just reformat your method definitions into
	RealMethod format and pass it to this function, this takes care of all
	the method creation and allocation. It is pretty safe, though there could
	be problems on low memory systems.

   INPUTS
	MethodList - This is a list of RealMethod structures. You should never
	    actually have to play with them yourself, but using the Method MACRO
	    to create them it is quite simple. (See example)
	Flags - currently unused. Any ideas?

   RESULT
	Return code of last Method used.

   NOTE
	If you find that your first Method isn't working then you are doing a
	   move.l   Method_1,a0
	instead of a
	   lea.l    Method_1,a0

   SEE ALSO
	MUIE_MakeAll(), MUIE_MakeObjects(), amiga.lib/DoMethod(), muiextend.i.

muiextend.library/MUIE_MakeObjects         muiextend.library/MUIE_MakeObjects

   NAME
	MUIE_MakeObjects -- Make an entire RealObject tree in one go.

   SYNOPSIS
	MUIE_MakeObjects( ObjectTree, Flags )
	                      a0       d0
	BOOL MUIE_MakeObjects( struct RealObject *, ULONG );

   FUNCTION
	This is really simple - you just reformat your object definition into
	RealObject format and pass it to this function, this takes care of all
	the object creation and allocation. It is pretty safe, though there could
	be problems on low memory systems.

   INPUTS
	ObjectTree - This is a tree of RealObject structures. You should never
	    actually have to play with them yourself, but using the Object MACRO
	    to create them it is quite simple. (See example)
	Flags - currently unused. Any ideas?

   RESULT
	TRUE if successful, FALSE otherwise. :)

   EXAMPLE
		...
		moveq		#0,d0
		movea.l	MyApplication,a0
		jsr		_LVOMakeObjects(a6)
		tst.l		d0
		beq		.failed
		...
		rts

	MyApplication:	Object	MUIC_Application,NULL,MyWindow
						TagList	...
	MyWindow:		Object	MUIC_Window,MySecondWindow,MyRoot
						TagList	...
	MyRoot:			Object...
	...

   NOTES
	If you want to use something like ContextMenus, which are not exactly
	children (ie. they don't get disposed with the parent) then just set
	the RO_Next field of the ApplicationObject to the Menustrip(...) object,
	then add them in a method/set call.

   SEE ALSO
	MUIE_MakeAll(), MUIE_MakeMethods(), MUIE_DisposeObjects(),
	muimaster.library/MUI_NewObjectA(), libraries/muiextend.i,
	libraries/muiclasses.i, libraries/muiextend_macros.i.

muiextend.library/MUIE_SetAttrs               muiextend.library/MUIE_SetAttrs

   NAME
	MUIE_SetAttrs -- Performs safe SetAttrs.

   SYNOPSIS
	result = MUIE_SetAttrs( Object, TagList )
	  d0                      a0      a1
	ULONG MUIE_SetAttrs(APTR, struct TagItem * );

   FUNCTION
	Calls SetAttrs, but copies the taglist before doing it. Didn't you know
	that MUI can trash the taglist - it's OK using the stack, but I don't
	like the stack.

   INPUTS
	Object - abstract pointer to a MUI class. (or boopsi even)
	TagList - array of TagItem structures with attribute/value pairs.

   RESULT
	Up to the object.

   NOTES
	Although you can use this quite safely, you should consider using
	MUIMethods if you need to do a lot of SetAttrs.
	Don't forget MUIM_MultiSet if you need to set a lot of objects to the
	same value.

   SEE ALSO
	intuition.library/SetAttrs(), MUIE_Get().

