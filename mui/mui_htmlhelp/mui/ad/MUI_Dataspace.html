<HTML><HEAD>
<title>MUI_Dataspace</title>
</HEAD><BODY>
<pre>
TABLE OF CONTENTS

Dataspace.mui/Dataspace.mui
Dataspace.mui/MUIA_Dataspace_Pool
Dataspace.mui/MUIM_Dataspace_Add
Dataspace.mui/MUIM_Dataspace_Clear
Dataspace.mui/MUIM_Dataspace_Merge
Dataspace.mui/MUIM_Dataspace_ReadIFF
Dataspace.mui/MUIM_Dataspace_Remove
Dataspace.mui/MUIM_Dataspace_WriteIFF
Dataspace.mui/Dataspace.mui

        The Dataspace class serves as a very simple container for
        all kinds of data. You can add data items and reference them
        later through an ID. Furthermore, Dataspace class features
        methods to import/export a complete Dataspace from/to an IFF
        file handle.

        MUI uses subclasses of dataspace class to handle all its
        configuration data and thats probably the main purpose of a
        dataspace.
Dataspace.mui/MUIA_Dataspace_Pool

    NAME
        MUIA_Dataspace_Pool -- (V11) [I..], APTR

    FUNCTION
        If you specify a memory pool from exec.library/CreatePool()
        here, the dataspace object will use this pool for all its
        entries.

        If you omit this tag or pass NULL, the dataspace object
        will create its own memory pool instead.

    SEE ALSO
        MUIM_Dataspace_Add, exec.library/CreatePool
Dataspace.mui/MUIM_Dataspace_Add

    NAME
        MUIM_Dataspace_Add (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_Add,APTR data, LONG len, ULONG id);

   FUNCTION
        This method adds a new entry to the dataspace. If an entry
        with the same ID already exists, it will be replaced with
        the new entry.

    INPUTS
        data - pointer to a data
        len  - length of data
        id   - reference id

    RESULT
        Returns NULL on failure (probably because of a memory
        shortage) or some non NULL value on success.

    SEE ALSO
        MUIM_Dataspace_Remove, MUIM_Dataspace_Find
Dataspace.mui/MUIM_Dataspace_Clear

    NAME
        MUIM_Dataspace_Clear (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_Clear,);

   FUNCTION
        This method clears all the contents of a dataspace. Depending
        on the state of the memory pool that the dataspace object uses,
        this may or may not result in more free memory.

    INPUTS
        none

    RESULT
        All entries will be removed from the dataspace.
        The return value of this method is currently undefined.

    SEE ALSO
        MUIM_Dataspace_Add, MUIM_Dataspace_Remove,
        MUIM_Dataspace_Merge
Dataspace.mui/MUIM_Dataspace_Merge

    NAME
        MUIM_Dataspace_Merge (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_Merge,Object *dataspace);

   FUNCTION
        This method adds all the contents of the merge dataspace
        specified as parameter to the objects dataspace.
        As with MUIM_Dataspace_Add, entries with equal IDs
        will be replaced.

    INPUTS
        dataspace - dataspace objects whichs contents should
                    be merged.

    RESULT
        Returns the number of entries that have been
        added/replaced in the objects dataspace. If this
        number doesnt match the number of entries in the
        merge dataspace, something probably went wrong.

    SEE ALSO
        MUIM_Dataspace_Add, MUIM_Dataspace_Remove
Dataspace.mui/MUIM_Dataspace_ReadIFF

    NAME
        MUIM_Dataspace_ReadIFF (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_ReadIFF,struct IFFHandle *handle);

    FUNCTION
        Adds the contents of an IFF handle from iffparse.library to
        the dataspace. As always, objects with the same ID that
        are already in the dataspace will be replaced.

        This method does not look for any chunk types and chunk ids
        itself. Instead, it expects that you have already located
        the chunk which contains your data and does nothing
        but ReadChunkBytes() until all dataspace entries of
        the current chunk are read.

    NOTES
        Do not call MUIM_Dataspace_ReadIFF if your handle is
        positioned on chunks that were not written with 
        MUIM_Dataspace_WriteIFF or strange things may happen!

    INPUTS
        handle - pointer to a struct IFFHandle from
                 iffparse.library/AllocIFF(). The handle must
                 already be open, initialized for reading and
                 positioned on a chunk that was created with
                 MUIM_Dataspace_WriteIFF.

    RESULT
        Returns 0 on success or some IFFERR_xxx on failure.

    SEE ALSO
        MUIM_Dataspace_ReadIFF, iffparse.library/AllocIFF
Dataspace.mui/MUIM_Dataspace_Remove

    NAME
        MUIM_Dataspace_Remove (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_Remove,ULONG id);

   FUNCTION
        This method removes an entry from the dataspace.

    INPUTS
        id - reference id

    RESULT
        Returns NULL if no entry with the given ID was found
        in the dataspace or some non NULL value on success.

    SEE ALSO
        MUIM_Dataspace_Add, MUIM_Dataspace_Find
Dataspace.mui/MUIM_Dataspace_WriteIFF

    NAME
        MUIM_Dataspace_WriteIFF (V11)

    SYNOPSIS
        DoMethod(obj,MUIM_Dataspace_WriteIFF,struct IFFHandle *handle, ULONG type, ULONG id);

    FUNCTION
        Writes the contents of a dataspace to an IFF handle of
        iffparse.library.

        In detail, a chunk with the specified type and id is created
        with PushChunk(), the contents of the dataspace are written
        with WriteChunkBytes() and the chunk is terminated with
        PopChunk().

    INPUTS
        handle - pointer to a struct IFFHandle from
                 iffparse.library/AllocIFF(). The handle must
                 already be open and initialized for writing.

        type   - type of chunk to create
        id     - id of chunk to create

    RESULT
        Returns 0 on success or some IFFERR_xxx on failure.

    SEE ALSO
        MUIM_Dataspace_ReadIFF, iffparse.library/AllocIFF

> >RESULT
> >
> >Always return 0 or the value from DoSuperMethod() if you want
> >your parent classes to be able to import theirselves.
>
> I don't understand when should I return 0 and when the value from
> DoSuperMethod().

    RESULT
        Return 0 if you dont want your superclasses to be able to
        import/export any values themselves. Otherwise
        return(DoSuperMethodA(cl,obj,msg));

> >EXAMPLE
> >
> >ULONG mImport(struct IClass *cl,Object *obj,struct MUIP_Import *msg)
> >{
> >   struct Data *mydata = INST_DATA(cl,obj);
> >   ULONG id;
> >   ULONG *data;
> >
> >   if (id=(muiNotifyData(obj)->mnd_ObjectID))
>                                 ^^^^^^^^^^^^
> If the macro "muiNotifyData" returns address of Notify class'es instance
> data (a pointer to struct MUI_NotifyData), what is this "mnd_ObjectID"
> member? It is not defined in mui.h as a member of struct MUI_NotifyData
> (unless it is private, but then why does it appear in this example? :-)
> Another strange thing is that MUIA_ObjectID is an atribute of Area class
> and not Notify class, why should mnd_ObjectID be in Notify's instance data?

This is a documentation bug. MUIA_ObjectID of course belongs to notify
class. Also, the mnd_ObjectID in the instance data structure was
accidently made private. Here it is:

struct MUI_NotifyData
{
        struct MUI_GlobalInfo *mnd_GlobalInfo;
        ULONG                  mnd_UserData;
        ULONG                  mnd_ObjectID;
};

> >      if (data = (ULONG *)DoMethod(msg->dataspace,MUIM_Dataspace_Find,id))
>                                                    ^^^^^^^^^^^^^^^^^^^
> MUIM_Dataspace_Find is neither documented in the autodoc for Dataspace
> class nor defined in mui.h. I think somebody on this list already complained
> about it but AFAIK he did not get answer.

Also a little "privacy" accident.

#define MUIM_Dataspace_Find                 0x8042832c /* V11 */
struct  MUIP_Dataspace_Find                 { ULONG MethodID; ULONG id; };

It returns the pointer you added with MUIM_Dataspace_Add or NULL when the
id was not found in the dataspace.

--
Greetings, Stefan



</pre></body>
