DEFINITION MODULE MuiMacros;

(*$ DEFINE Locale:=FALSE *)

(****************************************************************************
**
**      MUI Macros 2.0
**
**      Converted to Modula by Christian "Kochtopf" Scholz
**
**      refer also to MuiMacros.mod if you want to know, how they are made.
**
**      $Id: MuiMacros.def,v 1.4 1994/02/09 14:50:03 Kochtopf Exp $
**
**      $Log: MuiMacros.def,v $
# Revision 1.4  1994/02/09  14:50:03  Kochtopf
# Versionsnummer in 2.0 geaendert.
#
**
****************************************************************************
** Class Tree
****************************************************************************
**
** rootclass               (BOOPSI's base class)
** +--Notify               (implements notification mechanism)
**    +--Application       (main class for all applications)
**    +--Window            (handles intuition window related topics)
**    +--Area              (base class for all GUI elements)
**       +--Rectangle      (creates empty rectangles)
**       +--Image          (creates images)
**       +--Text           (creates some text)
**       +--String         (creates a string gadget)
**       +--Prop           (creates a proportional gadget)
**       +--Gauge          (creates a fule gauge)
**       +--Scale          (creates a percentage scale)
**       +--Boopsi         (interface to BOOPSI gadgets)
**       +--Colorfield     (creates a field with changeable color)
**       +--List           (creates a line-oriented list)
**       !  +--Floattext   (special list with floating text)
**       !  +--Volumelist  (special list with volumes)
**       !  +--Scrmodelist (special list with screen modes)
**       !  \--Dirlist     (special list with files)
**       +--Group          (groups other GUI elements)
**          +--Virtgroup   (handles virtual groups)
**          +--Scrollgroup (handles virtual groups with scrollers)
**          +--Scrollbar   (creates a scrollbar)
**          +--Listview    (creates a listview)
**          +--Radio       (creates radio buttons)
**          +--Cycle       (creates cycle gadgets)
**          +--Slider      (creates slider gadgets)
**          +--Coloradjust (creates some RGB sliders)
**          \--Palette     (creates a complete palette gadget)
**
****************************************************************************)

IMPORT  MD:MuiD;
IMPORT  ML:MuiL;
IMPORT  UD:UtilityD;
FROM    UtilityD IMPORT HookPtr;
FROM    SYSTEM IMPORT ADDRESS, ADR, TAG;

TYPE    APTR    = ADDRESS;      (* just for readability *)
        StrPtr  = ADDRESS;

        ShortString = ARRAY[0..3] OF CHAR;  (* for MakeID *)

        (* Here some Types you have to use, IF you want to fill the
           array, the ListDisplayHook gets as parameter and which the hook
           has to fill *)

        STRING      = ARRAY[0..128] OF CHAR;
        STRPTR      = POINTER TO STRING;
        STRARR      = ARRAY[0..10] OF STRPTR; (* set 10 to the number of columns you have in your list *)
        STRARRPTR   = POINTER TO STRARR;

        (* Use it the following way :

        Your Hookfunction :

        PROCEDURE dspfunc(hook : HookPtr; array : APTR; entry : APTR) : APTR;

            BEGIN
                CAST(STRARRPTR,array)^[0]:=ADR(first string);
                CAST(STRARRPTR,array)^[1]:=ADR(second string);
                ...
                RETURN 0;
            END dspfunc;

        As you see, it is the same as string-arrays in C  *)


        (* Here your PROCEDURE-Prototype for your hookfunction : *)

        HookDef     = PROCEDURE(HookPtr, APTR, APTR):APTR;

(*
**  MUI - Object Generation
**
**  These Macros are equal to the C-Macros which can be found in mui.h
**  But notice, that you have a different usage of these :
**
**  Instead of
**
**      app = ApplicationObject,
**
**              ...
**
**            End;
**
**  you now write :
**
**      app := ApplicationObject(TAG(buffer,    (* TAG from SYSTEM *)
**
**              ...
**
**             tagEnd));    (* tagEnd imported from UtilityD *)
**
**  Also you can't use :
**
**      app := ApplicationObject(TAG(buffer,
**
**              ...
**  ====>            window:=WindowObject(TAG(buffer, ... , tagEnd)),
**              ...
**
**             tagEnd));
**
**  instead of this, you have to define your Window-Object before the
**  Application-Object and then use the pointer in the App-Definition :
**
**      window := WindowObject(TAG(buffer, ... , tagEnd)),
**
**      app := ApplicationObject(TAG(buffer,
**
**              ...
**                   window,
**              ...
**
**             tagEnd));
**
**  So you can't define a whole application with one command if you need
**  the pointer of some objects later on (for a Notify, etc.)
**
*)

CONST   Child           = MD.maGroupChild;
        SubWindow       = MD.maApplicationWindow;
        WindowContents  = MD.maWindowRootObject;

PROCEDURE WindowObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ImageObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE NotifyObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ApplicationObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE TextObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE RectangleObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ListObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE PropObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE StringObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ScrollbarObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ListviewObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE RadioObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE VolumelistObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE FloattextObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE DirlistObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE SliderObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE CycleObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE GaugeObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ScaleObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE BoopsiObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ColorfieldObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ColoradjustObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE PaletteObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE GroupObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE VirtgroupObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE ScrollgroupObject(tags : UD.TagItemPtr) : APTR;
(* missing Defs!
PROCEDURE Popstring(tags : UD.TagItemPtr) : APTR;
PROCEDURE Popobject(tags : UD.TagItemPtr) : APTR;
PROCEDURE Popasl(tags : UD.TagItemPtr) : APTR;
*)
PROCEDURE ScrmodelistObject(tags : UD.TagItemPtr) : APTR;
PROCEDURE VGroup(tags : UD.TagItemPtr) : APTR;
PROCEDURE HGroup(tags : UD.TagItemPtr) : APTR;
PROCEDURE ColGroup(cols : LONGCARD; tags : UD.TagItemPtr) : APTR;
PROCEDURE RowGroup(rows : LONGCARD; tags : UD.TagItemPtr) : APTR;
PROCEDURE PageGroup(tags : UD.TagItemPtr) : APTR;
PROCEDURE VGroupV(tags : UD.TagItemPtr) : APTR;
PROCEDURE HGroupV(tags : UD.TagItemPtr) : APTR;
PROCEDURE ColGroupV(cols : LONGCARD; tags : UD.TagItemPtr) : APTR;
PROCEDURE RowGroupV(rows : LONGCARD; tags : UD.TagItemPtr) : APTR;
PROCEDURE PageGroupV(tags : UD.TagItemPtr) : APTR;


(*
**  MakeID
**  Generate an ID out of a 4-char-string.
**  Use it the as WindowID ! (look in MuiTest for an example!)
*)

PROCEDURE MakeID (name : ShortString): LONGINT;

(*
**
**  Hook Macros
**
**  Use it the following way :
**      1. Write your Hook-Function :
**          PROCEDURE hookfunc(hook:HookPtr; obj : APTR; args : APTR) : APTR
**              BEGIN
**              ...
**              END hookfunc;
**          Note, that your function needs not to specify registers, but
**          your PROCEDURE must be looking like name(HookPtr, APTR, APTR)!!
**
**      2. Define in your VAR-section a pointer to a Hookrecord :
**          VAR hook    : UtilitiesD.HookPtr;
**
**      3. fill it with MakeHook :
**          MakeHook(hookfunc,hook);
**
**      4. Use it with MUI, as you like, e.g. :
**          DoMethod(button,TAG(buffer,MD.mmCallHook,hook,arg1,arg2));
**
*)

PROCEDURE MakeHook(entry:HookDef; VAR hook : HookPtr);

(*
**
**  Spacing Macros
**
**  (not all from mui.h)
**
*)

PROCEDURE HVSpace() : APTR;
PROCEDURE HSpace(x : LONGCARD) : APTR;
PROCEDURE VSpace(x : LONGCARD) : APTR;

(*
**
**  Popup-Object
**
**
*)

PROCEDURE Popup (object : APTR;
                 hook : HookPtr;
             VAR imageObj : APTR;
                 imgSpec : ADDRESS) : APTR;


(*
**
** String-Object
**
** Creates a simple String-Gadget
**
*)

(*$ IF Locale *)
PROCEDURE String(contents : StrPtr; maxlen : LONGINT) : APTR;
PROCEDURE KeyString(contents : StrPtr; maxlen : LONGINT; key : CHAR) : APTR;
(*$ ELSE *)
PROCEDURE String(contents : ARRAY OF CHAR; maxlen : LONGINT) : APTR;
PROCEDURE KeyString(contents : ARRAY OF CHAR; maxlen : LONGINT; key : CHAR) : APTR;
(*$ ENDIF *)

(*
**
** Checkmark
**
** creates a Checkmark Gadget
**
*)

PROCEDURE Checkmark(selected : BOOLEAN) : APTR;
PROCEDURE KeyCheckmark(selected : BOOLEAN; key : CHAR) : APTR;

(*
**
** Buttons
**
** Here the same note : Use small letters for Keybuttons!
**
*)

(*$ IF Locale *)
PROCEDURE Simplebutton(name : StrPtr) : APTR;
PROCEDURE Keybutton(name : StrPtr; key : CHAR) : APTR;
(*$ ELSE *)
PROCEDURE Simplebutton(name : ARRAY OF CHAR) : APTR;
PROCEDURE Keybutton(name : ARRAY OF CHAR; key : CHAR) : APTR;
(*$ ENDIF *)
(*
**
**  Radio Object
**
*)
(*$ IF Locale *)
PROCEDURE Radio(name : StrPtr; array : APTR) : APTR;
(*$ ELSE *)
PROCEDURE Radio(name : ARRAY OF CHAR; array : APTR) : APTR;
(*$ ENDIF *)

(*$ IF Locale *)
PROCEDURE KeyRadio(name : StrPtr; array : APTR; key : CHAR) : APTR;
(*$ ELSE *)
PROCEDURE KeyRadio(name : ARRAY OF CHAR; array : APTR; key : CHAR) : APTR;
(*$ ENDIF *)

(*
**
** Label Objects
**
** The same as in mui.h
**
** Label()  : create a Label for Objects without a frame
** Label1() : create a label for Objects with a standard frame (Checkmarks...)
** Label2() : create a label for Objects with double high frame (String Gadgets...)
**
*)
(*$ IF Locale *)
PROCEDURE Label(label : StrPtr) : APTR;
PROCEDURE Label1(label : StrPtr) : APTR;
PROCEDURE Label2(label : StrPtr) : APTR;
PROCEDURE KeyLabel(label : StrPtr; HiChar : CHAR) : APTR;
PROCEDURE KeyLabel1(label : StrPtr; HiChar : CHAR) : APTR;
PROCEDURE KeyLabel2(label : StrPtr; HiChar : CHAR) : APTR;
(*$ ELSE *)
PROCEDURE Label(label : ARRAY OF CHAR) : APTR;
PROCEDURE Label1(label : ARRAY OF CHAR) : APTR;
PROCEDURE Label2(label : ARRAY OF CHAR) : APTR;
PROCEDURE KeyLabel(label : ARRAY OF CHAR; HiChar : CHAR) : APTR;
PROCEDURE KeyLabel1(label : ARRAY OF CHAR; HiChar : CHAR) : APTR;
PROCEDURE KeyLabel2(label : ARRAY OF CHAR; HiChar : CHAR) : APTR;
(*$ ENDIF *)

(*
**
**  Cycle-Objects
**
*)

PROCEDURE Cycle(array : APTR) : APTR;
PROCEDURE KeyCycle(array : APTR; key : CHAR) : APTR;

(*
**
**  Slider-Objects
**
*)

PROCEDURE Slider(min, max, level : LONGINT; horiz : BOOLEAN) : APTR;
PROCEDURE KeySlider(min, max, level : LONGINT; horiz : BOOLEAN; key : CHAR) : APTR;


(*
**
** Controlling Objects
**
** Again the same as in mui.h :
**
** set : set an attribute of an object
** get : get an attribute of an object
**       didn't work in previous releases :-( (but now!! :-)
**
*)

PROCEDURE get(obj : APTR; attr : LONGCARD; store : ADDRESS);
PROCEDURE set(obj : APTR; attr : LONGCARD; value : LONGINT);
PROCEDURE setmutex(obj : APTR; n : LONGINT);
PROCEDURE setcycle(obj : APTR; n : LONGINT);
(*$ IF Locale *)
PROCEDURE setstring(obj : APTR; s : StrPtr);
(*$ ELSE *)
PROCEDURE setstring(obj : APTR; s : ARRAY OF CHAR);
(*$ ENDIF *)
PROCEDURE setcheckmark(obj : APTR; b : BOOLEAN);
PROCEDURE setslider(obj : APTR; l : LONGINT);

(*
** Now some macros which are not part of mui.h (in other words : my own ;-)
**
** First : NoteClose (app,obj,ID)
**         ----------------------
**         This macro sets up a notification on the close-gadget of a window
**         if it gets pressed, the app-obj gets back an ID
**         app : the application-object, which will receive the ID
**         obj : the window-object
**         ID  : the ID, which will be send to the app-obj, when the user
**               presses the close-gadget of the window-object specified in
**               obj.
*)

PROCEDURE NoteClose(app : APTR;
                    obj : APTR;
                    ID  : LONGINT);

(*
**  Notebutton (app,obj,ID)
**  -----------------------
**  Sets up a notification on a button. If it gets pressed, the app-obj
**  receives an ID.
**  app : the app-obj, which will receive the ID.
**  obj : the pointer to the Button-Object (created by Keybutton, etc.)
**  ID  : The ID, which will be send to the app-obj.
**
*)

PROCEDURE NoteButton(app : APTR;
                     obj : APTR;
                     ID  : LONGINT);

(*
** RemMember (obj,member)
** ----------------------
** The following macro deletes a member from an object
**
** obj      : The object which holds the child to remove
** member   : The child which shall be removed
** ATTENTION: You have to dispose the removed child-objects yourself!
**
*)

PROCEDURE RemMember(obj : APTR; member : APTR);

(*
** AddMember (obj,member)
** ----------------------
** This macro will add a new child to an group-  or application-object
**
** obj      : The group or application to which the new object will be added
** member   : The new child-object which shall be added to obj.
**
*)

PROCEDURE AddMember(obj : APTR; member : APTR);

END MuiMacros.







