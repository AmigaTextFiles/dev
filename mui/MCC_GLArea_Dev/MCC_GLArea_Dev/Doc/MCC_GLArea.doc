TABLE OF CONTENTS

GLArea.mcc/---Overview---
GLArea.mcc/---ImageDB.mcc---
GLArea.mcc/MUIA_GLArea_Buffered
GLArea.mcc/MUIA_GLArea_DefWidth
GLArea.mcc/MUIA_GLArea_DefHeight
GLArea.mcc/MUIA_GLArea_DrawFunc
GLArea.mcc/MUIA_GLArea_InitFunc
GLArea.mcc/MUIA_GLArea_glBase
GLArea.mcc/MUIA_GLArea_gluBase
GLArea.mcc/MUIA_GLArea_glutBase
GLArea.mcc/MUIA_GLArea_MaxHeight
GLArea.mcc/MUIA_GLArea_MaxWidth
GLArea.mcc/MUIA_GLArea_MinHeight
GLArea.mcc/MUIA_GLArea_MinWidth
GLArea.mcc/MUIA_GLArea_MouseDownFunc
GLArea.mcc/MUIA_GLArea_MouseMoveFunc
GLArea.mcc/MUIA_GLArea_MouseUpFunc
GLArea.mcc/MUIA_GLArea_ResetFunc
GLArea.mcc/MUIA_GLArea_SingleTask
GLArea.mcc/MUIA_GLArea_Status
GLArea.mcc/MUIA_GLArea_Threaded
GLArea.mcc/MUIM_GLArea_Break
GLArea.mcc/MUIM_GLArea_Init
GLArea.mcc/MUIM_GLArea_Redraw
GLArea.mcc/MUIM_GLArea_Reset
GLArea.mcc/---Overview---

    This class is a subclass of Area. It's main purpose is to simplify StormMesa
    context manipulation and to implement an easy way of integration of
    3D graphics in MUI User Interfaces.

    Another goal was to write a "threaded" rendering system, because of the
    complexity of OpenGL rendering (slow rendering), it's a good idea to do all
    this rendering in sub-processes. The developer doesn't need to care about inter-process
    communication at all, everything is controlled by the GLArea class.

    Each GLArea object will create a sub-process (unless you use the SingleTask
    attribut) and talk with it via signals and shared variables.
    When the object should be redrawn or something else, the GLArea object will
    send commands to his sub-process.

    You tell each GLArea object which function will be called for
    drawing/initialising/reseting/mouse events. All these functions needs to
    set their respective StormMesa library base pointer, which are opened by the sub-process.
    These values are always passed as argument to your functions, (see struct
    GLContext in the include files for more details).

    The rendering functions *MUST* handle break signals (SIGBREAKF_CTRL_D)
    for correct threads communications. If the function was breaked
    you *HAVE TO RETURN TRUE*, else return FALSE (if an incorrect value is returned,
    dead-locks may happen).

    Here is an example of a single gl draw function

    Ex:
    int DrawGL(struct GLContext *glcontext) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base;

        //--- your gl stuff ---

        //--- ALWAYS Add this kind of line at the end of your rendering function
        if (CheckSignal(SIGBREAKF_CTRL_D) return TRUE

        return FALSE
    }

    This function will be called by the GLArea sub-process.

GLArea.mcc/---ImageDB.mcc---

    ImageDB.mcc is another class very usful for GLArea.mcc

    ImageDB will take care of textures manipulation needed for OpenGL renderings.

GLArea.mcc/MUIA_GLArea_Buffered

  NAME
    MUIA_GLArea_Buffered -- [ISG], BOOL

  FUNCTION
    Defines if the object uses GL buffering mode.
    Should always be TRUE.

  DEFAULT VALUE
    TRUE

  BUGS
    Seems to make no difference if bufferd mode is on or not (?)

  SEE ALSO

GLArea.mcc/MUIA_GLArea_DefWidth

  NAME
    MUIA_GLArea_DefWidth -- [ISG], int

  FUNCTION
    Define the default width of the GL context

  DEFAULT VALUE
    320

  BUGS
    No known bugs.

  SEE ALSO
    MUIA_GLArea_MaxWidth, etc...

GLArea.mcc/MUIA_GLArea_DefHeight

  NAME
    MUIA_GLArea_DefHeight -- [ISG], int

  FUNCTION
    Define the default height of the GL context

  DEFAULT VALUE
    240

  BUGS
    No known bugs.

  SEE ALSO

    MUI_GLArea_DefWidth, MUIA_GLArea_MaxWidth, etc...
GLArea.mcc/MUIA_GLArea_DrawFunc

  NAME
    MUIA_GLArea_DrawFunc -- [ISG], (PF*)

  FUNCTION
    Define the rendering function. Each time the object should be redrawn,
    this function is called. This function receives as its only argument a
    struct GLContext pointer which contains some usful information.

    This functions has to handle SIGBREAKF_CTRL_D signals.

    Ex:
    int DrawGL(struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        ...

        //--- if breaked return TRUE (1) ---
        if (CheckSignal(SIGBREAKF_CTRL_D)) return 1;
        //--- else return FALSE (0) ---
        return 0;
    }

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_InitFunc

  NAME
    MUIA_GLArea_InitFunc -- [ISG], (PF*)

  FUNCTION
    Define the GL context initialising function. Each time the object
    should be initialised (MUIM_Show method), this function is called.

    This function receive as its only argument a struct GLContext pointer
    which contains useful information.

    Ex:
    int InitGL(struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        ...

        return FALSE;
    }

  SPECIAL VALUES

    MUIV_GLArea_InitFunc_Standard

        A default Init function is called, here is the code

        GLfloat lightDirection[4]={5.0,5.0,5.0,1.0};
        GLfloat diffuseColor[4]={1.0,1.0,1.0,1.0};
        GLfloat ambientColor[4]={0.2,0.2,0.2,1.0};

        glLightModeli (GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
        glEnable (GL_DEPTH_TEST);
        glEnable (GL_LIGHTING);
        glShadeModel(GL_SMOOTH);
        glLightfv (GL_LIGHT0,GL_AMBIENT,ambientColor);
        glLightfv (GL_LIGHT0,GL_DIFFUSE,diffuseColor);
        glLightfv (GL_LIGHT0,GL_POSITION,lightDirection);
        glEnable (GL_LIGHT0);
        glFrontFace(GL_CCW);
        glDisable(GL_CULL_FACE);
        glDisable(GL_LIGHT1);
        glDisable(GL_LIGHT2);
        glDisable(GL_LIGHT3);
        glDisable(GL_LIGHT4);
        glDisable(GL_DITHER);
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        glEnable (GL_NORMALIZE);
        glClearColor(0.0,0.0,0.0,1.0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        glMatrixMode (GL_PROJECTION);
        glLoadIdentity();
        gluPerspective (40.0,1.333,0.1,6000.0);
        glMatrixMode (GL_MODELVIEW);
        glLoadIdentity();

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_glBase

  NAME
    MUIA_GLArea_glBase -- [..G], (struct Library *)

  FUNCTION
    Return the glBase library pointer of this MUI app task
    (also not this object sub-process library base).

    When the first GLArea object is created, it opens the
    StormMesa libraries for the MUI application.
    So you could retreive the glBase,gluBase,glutBase to work
    with it in another environment than the GLArea object.

    If you want, you could then handle yourself all the GL context
    switches using the retured library base without the help
    of the GLArea object.

  BUGS
    No known bugs.

  SEE ALSO
    MUIA_GLArea_gluBase, MUIA_GLArea_glutBase
GLArea.mcc/MUIA_GLArea_gluBase

  NAME
    MUIA_GLArea_gluBase -- [..G], (struct Library *)

  FUNCTION
    Return the gluBase library pointer of the MUI main task.

  BUGS
    No known bugs.

  SEE ALSO
    MUIA_GLArea_glBase
GLArea.mcc/MUIA_GLArea_glutBase

  NAME
    MUIA_GLArea_glutBase -- [..G], (struct Library *)

  FUNCTION
    Return the glutBase library pointer of the MUI main task.

  BUGS
    No known bugs.

  SEE ALSO
    MUIA_GLArea_glBase
GLArea.mcc/MUIA_GLArea_MaxHeight

   NAME
    MUIA_GLArea_MaxHeight -- [ISG], int


  FUNCTION
    Define the maximum height of the GL context

  DEFAULT VALUE
    600

  BUGS
    No known bugs.

  SEE ALSO

    MUI_GLArea_DefWidth, MUIA_GLArea_MaxWidth, etc...
GLArea.mcc/MUIA_GLArea_MaxWidth

   NAME
    MUIA_GLArea_MaxWidth -- [ISG], int


  FUNCTION
    Define the maximum width of the GL context

  DEFAULT VALUE
    800

  BUGS
    No known bugs.

  SEE ALSO

    MUI_GLArea_DefWidth, MUIA_GLArea_MaxWidth, etc...
GLArea.mcc/MUIA_GLArea_MinHeight

  NAME
    MUIA_GLArea_MinWidth -- [ISG], int

  FUNCTION
    Define the minimum height of the GL context

  DEFAULT VALUE
    60

  BUGS
    No known bugs.

  SEE ALSO

    MUI_GLArea_DefWidth, MUIA_GLArea_MaxWidth, etc...
GLArea.mcc/MUIA_GLArea_MinWidth

  NAME
    MUIA_GLArea_MinWidth -- [ISG], int

  FUNCTION
    Define the minimum width of the GL context

  DEFAULT VALUE
    80

  BUGS
    No known bugs.

  SEE ALSO

    MUI_GLArea_DefWidth, MUIA_GLArea_MaxWidth, etc...
GLArea.mcc/MUIA_GLArea_MouseDownFunc

  NAME
    MUIA_GLArea_MouseDownFunc -- [ISG], (PFD*)

  FUNCTION
    Define the GL context mouse down function. When the mouse is clicked
    in the GL context, this function will be called with a
    struct GLContext pointer, and the x,y coordinate of the mouse.

    The GLArea object WILL NOT call the DrawFunc, only the MouseDonwFunc is
    called when the mouse is hit.

    Ex:
    int MouseDownGL(int x, int y, struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        //--- use x,y ---

        return 0;
    }

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_MouseMoveFunc

  NAME
    MUIA_GLArea_MouseMoveFunc -- [ISG], (PFD*)

  FUNCTION
    Define the GL context mouse move function. When the mouse is moved
    AFTER the mouseclick (MouseDownFunc) in the GL context, this function
    will be called with a struct GLContext pointer, and the dx,dy coordinate
    of the mouse (relative coordinate to the point where MouseDownFunc was
    called).

    The DrawFunc WILL NOT be called after this one.

    Ex:
    int MouseMoveGL(int dx, int dy, struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        ...

        return 0;
    }

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_MouseUpFunc

  NAME
    MUIA_GLArea_MouseUpFunc -- [ISG], (PFD*)

  FUNCTION
    When the mouse is released this function will be called.
    The function will be called with a struct GLContext pointer,
    and the x,y coordinate of the mouse.

    DrawFunc WILL be called after this one automatically.

    Ex:
    int MouseUpGL(int x, int y, struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        ...

        return FALSE;
    }

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_ResetFunc

  NAME
    MUIA_GLArea_ReseteFunc -- [ISG], (PF*)

  FUNCTION
    Define the GL context reset function..
    This function receives as its only argument a struct GLContext
    pointer.

    Ex:
    int ResetGL(struct GLContext *glcontex) {
        struct Library *glBase=glcontext->gl_Base;
        struct Library *gluBase=glcontext->glu_Base;
        struct Library *glutBase=glcontext->glut_Base

        //--- Some OpenGL reset functions

        return FALSE;
    }

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_SingleTask

  NAME
    MUIA_GLArea_SingleTask -- [I.G], BOOL

  FUNCTION
    Define if the GLArea object spawn a sub-process for the rendering.

    If this value is FALSE then a new process is
    created (you could then choose to do a threaded rendering or
    not).

    If this value is TRUE, no new process is created and the rendering
    will always be in non-threaded mode. All GUI will block until the
    rendering is done. Use this attribut if you are sure that the rendering
    is fast enough, so you avoid all overheads of inter-process communication.

  DEFAULT
    FALSE

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_Status

  NAME
    MUIA_GLArea_Status -- [..G], int

  FUNCTION
    Define the GLArea sub-process rendering status.

  OUTPUT
    MUIV_GLArea_Ready
        The sub-process is ready for a new rendering

    MUIV_GLArea_Busy
        The sub-process is already rendering something

    MUIV_GLArea_NotActive
        The sub-process is not active (Not sub-process rendering)
        You obtain this values when SingleTask is TRUE

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIA_GLArea_Threaded

  NAME
    MUIA_GLArea_Threaded -- [ISG], BOOL

  FUNCTION
    Define if the rendering should be threaded when using sub-processes.

    When the rendering is threaded, the sub-process will render
    the DrawFunc, but the GLArea object and the MUI App could
    continue to work (The user interface is not blocked during
    the rendering).

    If the rendering is not threaded, the sub-process will render
    the DrawFunc (also, the sub-process will render the func in
    all case), but will block the GLArea object and the MUI App
    (the MUI Interface is freezed) until the rendering is done.

    Setting this attribut let you switch between threaded/non threaded
    rendering at any moment (See GLArea_Demo program).

  DEFAULT VALUE
    TRUE

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIM_GLArea_Break

  NAME
    MUIM_GLArea_Break

  FUNCTION
    Breaks a busy GLArea subprocess.
    A signal SIGBREAKF_CTRL_D is send to the sub-process.

    Has no effect when SingleTask is TRUE.

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIM_GLArea_Init

  NAME
    MUIM_GLArea_Init

  FUNCTION
    Call the init func. If the object (sub-process) is busy, it will break it.

 BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIM_GLArea_Redraw

  NAME
    MUIM_GLArea_Redraw

  SYNOPSIS
    DoMethod(obj,MUIM_GLArea_Redraw);

  FUNCTION
    Call the draw func. If the object is busy, it will break it and
    redraw the DrawFunc.

  BUGS
    No known bugs.

  SEE ALSO
GLArea.mcc/MUIM_GLArea_Reset

  NAME
    MUIM_GLArea_Reset

  SYNOPSIS
    DoMethod(obj,MUIM_GLArea_Reset);

  FUNCTION
    Call the reset func. If the object is busy, it will break it.

  BUGS
    No known bugs.

  SEE ALSO


