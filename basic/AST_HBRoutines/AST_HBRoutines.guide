@database "AST_HBRoutines.guide"
@width 78
@remark http://www.facebook.com/amispatra/

@node main "Introducción / Introduction"

@{b}------------------------------------------------------------------------------@{ub}
 @{fg highlight}@{u}@{b}Rutinas para Hisoft Basic / Maxon Basic@{ub}@{uu}@{fg text}            @{"versión 1.1 (20.03.2010)" link "Notas"}
  @{fg highlight}@{u}@{b}Routines for Hisoft Basic/Maxon Basic@{ub}@{uu}

                   Copyright © 2002-2010 Dámaso D. Estévez
             AmiSpaTra - http://www.xente.mundo-r.com/amispatra/@{fg text}
@{b}------------------------------------------------------------------------------@{ub}

   @{b}Introducción / Introduction@{ub}

   Esta  pequeña  colección  de rutinas surgió cuando escribí algunos pequeños
   programas:   ImageDTInfo,  IBcc,  OldTimes  (no  ha pasado nunca de ser una
   beta)  y  ABF.   Posteriormente,  he  decidido  ampliarla  y  mejorarla  en
   previsión de futuros proyectos o mejoras de los ya existentes...  aunque yo
   no contaría con que lleguen a ver la luz.

   This  little  collection  was  created  when  I  wrote  some  miniprograms:
   ImageDTInfo,  IBcc,  OldTimes  (permanent  beta) and ABF.  Later on, I have
   decided to expand/improve it in forecast of future projects or improvements
   of  those  already existent...  although I would not count that they end up
   seeing the light.

   @{b}Lista de rutinas / Routine's list@{ub}

     N ! @{"AllocMemL" link "AllocMemL"} (vea el fichero "MemL.bas" / see the "MemL.bas" file)
     N ! @{"ArgvZero" link "ArgvZero"}
     N ! @{"CCase" link "CCase"}
     +   @{"ChangeExt" link "ChangeExt"}
       ! @{"ChkPat" link "ChkPat"}
     N ! @{"CopyFDAtribs" link "CopyFDAtribs"}
     N ! @{"CopyFile" link "CopyFile"}
     N   @{"CreateVarEnv" link "CreateVarEnv"}
     + ! @{"Exists" link "Exists"}
         @{"FixPath" link "FixPath"}
     N ! @{"FreeMemL" link "FreeMemL"} (vea el fichero "MemL.bas" / see the "MemL.bas" file)
     N   @{"LetraNIF" link "LetraNIF"}
       ! @{"Mkd" link "Mkd"}
     N   @{"NewPri" link "NewPri"}
     N ! @{"ParseArgs" link "ParseArgs"}
         @{"ReplaceChars" link "ReplaceChars"}
     N ! @{"ReqS" link "ReqS"}
     +   @{"SGetArg" link "SGetArg"}
     N ! @{"SReqFD" link "SReqFD"}
     N ! @{"SReqFont" link "SReqFont"}
     N ! @{"SReqScr" link "SReqScr"}
     N   @{"Str2B" link "StrTo"}    (vea el fichero "StrTo.bas" / see the "StrTo.bas" file)
     N   @{"Str2C" link "StrTo"}    (vea el fichero "StrTo.bas" / see the "StrTo.bas" file)
     N   @{"WKey" link "WKey"}

     @{u}Leyendas / Legends@{uu}

         N = Novedad
             New

         + = Rutina actualizada
             Updaded routine

         ! = Desactive los eventos del Basic al ejecutarla
             Disable the Basic events when you execute it

   @{b}Notas generales / General notes@{ub}

   En  general,  se  han diseñado para que el consumo de recursos sea el menor
   posible  (de  ahí  por  ejemplo  que no suelan abrir ellas directamente las
   bibliotecas  que  puedan  necesitar  y,  al menos unas cuantas, no realizan
   controles   internos   -exhaustivos-  de  errores...   esas  tareas  deberá
   realizarlas  el programador, así como cargar los ficheros de inclusión y de
   rutinas correspondientes O:D).

   Todas  aquellas que requieran recursos ajenos al Basic, deben ser invocadas
   desactivando  los  eventos para evitar que el programa se interrumpa cuando
   se  estén ejecutando y dichos recursos se pierdan...  las he marcado con la
   leyenda "!" :).

   Estas  rutinas  son  de uso y modificación libre, aunque agradecería que me
   comentase  si  las  ha  encontrado útiles (incluso en su adaptación a otros
   lenguajes  ;),  sugerencias  para  futuras  mejoras y los errores que pueda
   encontrar  en  ellas.  No aguarde respuesta, porque suelo estar muy ocupado
   8-/.

   Y recuerde: ¡Sólo Amiga (y nosotros) lo hacemos posible!

                                     ---

   In general, they have been designed so that the consumption of resources is
   the  possible  minor  (of  there for example that they used to not open the
   libraries  that  they  can need directly and, at least some how many, don't
   carry  out  internal  controls  -exhaustive- of errors...  those tasks will
   carry  out them the programmer and load the include/routines files required
   O:D).

   All  those  that  require  resources  unaware  to  Basic, should be invoked
   disabling the events to avoid that the program is interrupted when they are
   executing  and  theses  resources  get lost...  I have marked them with the
   legend "!" :).

   These  routines  are  of  use and free modification, although I would thank
   that  comments me if you has found them useful (even in their adaptation to
   other  coding  languages;),  suggestions  for  future  improvements and the
   errors  that  you can find in them.  Not await answer, because I am usually
   very busy 8-/.  And remember:  Only Amiga (and us) makes it possible!

@endnode


@node ArgvZero "ArgvZero"

 @{fg highlight}ArgvZero$()@{fg text}

 @{b}Reemplaza a/ Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Devuelve la misma información que *argv[0] en el lenguaje C.

   Returns the same info what *argv[0] at C language.

 @{b}Argumentos / Arguments@{ub}

   ---

 @{b}Devuelve / Returns@{ub}

   Cadena / String

      Nombre del programa.

      Program's name.

 @{b}Requisitos / Requeriments@{ub}

   Bibliotecas Exec y DOS (v36)
   Ficheros de inclusión "Exec.bh" y "DOS.bh".
   Fichero de rutinas "ArgvZero.bas".

   Exec and DOS (v36) libraries.
   Exec.bh & DOS.bh include files.
   ArgvZero.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   PRINT " You runs the program / Ejecuta el programa: `";ArgvZero$();"'"

 @{b}Notas / Notes@{ub}

   Sólo  funciona con programas invocados desde la interfaz Shell, devolviendo
   en  otro  caso,  o  si  hay algún problema, una cadena nula.  El tamaño del
   tampón  actual  es  arbitrario  (y espero que suficientemente grande) al no
   encontrar  información  precisa  sobre  el  límite  exacto del nombre de un
   fichero  (hasta  el AmigaOS 3.9 podría alcanzar los 107 caracteres según la
   estructura  FileInfoBlock).

   Only  works  with programs invoked from the Shell, returning at other case,
   or  if  there are some trouble, an empty string.  The current buffer's size
   is arbitrary (and high, I think) because I can't find a detailed info about
   the max filename length (under AmigaOS 3.9 the maximum seems 107 chars -see
   the  FileInfoBlock  struct-).

@endnode


@node CCase "CCase"

 @{fg highlight}CCase$(BYVAL st$, BYVAL mode&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   UCASE$ / LCASE$

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Cambia la altura de la caja de los caracteres de un texto (o sea, convierte
   el texto completo a mayúsculas o minúsculas ;).

   Convert a full text to upper or lower case.

 @{b}Argumentos / Arguments@{ub}

   st$

      Texto a convertir (cadena)

      Text to convert (string)

   mode&
      Modo: 0&          = conversión a minúsculas (caja baja).
            otro valor  = conversión a mayúsculas (caja alta).

      Mode: 0&          = to lower case.
            other value = to upper case.

 @{b}Devuelve / Returns@{ub}

   Cadena / string

      Cadena convertida.

      String converted.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Locale (v38)
   Ficheros de inclusión "Locale.bh".
   Fichero de rutinas "CCase.bas".

   Locale (v38) library.
   Locale.bh include file.
   CCase.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   a$ = "áÁäÄàÀâÂñÑçÇæÆ"
   PRINT " Muestra/Sample: '";a$;"'"
   mode& = 1&
   PRINT " > Mayúsculas / Upper case: '";CCase$(a$,mode&);"'"
   mode& = 0&
   PRINT " > Minúsculas / Lower case: '";CCase$(a$,mode&);"'"

 @{b}Notas / Notes@{ub}

   Sólo  funciona  con  el  Amiga  clásico  que utiliza el juego de caracteres
   ISO-LATIN-1  (la  rutina  generará  el  error  nº  51, error interno, si no
   respeta  esta  limitación),  ya  que  el  AmigaOS4+ soporta otros juegos de
   caracteres   incluyendo   los   multiocteto...    quizás   si  consigo  más
   documentación  algún  día elimine esta limitación :).  Antes de terminar la
   rutina invoca al recolector de basura por si se ha generado mucha basura al
   manejar las cadenas.

   Only  works  with  the Amiga Classic what uses the ISO-LATIN-1 charset (the
   routine  will  generates the #51 error, internal error, if you ignores this
   advertisement),   because   the  AmigaOS4+  will  supports  other  charsets
   including  the  multibyte...  perhaps if I obtain more info and I have free
   time  some  day  I will remove this limitation :).  The routine invokes the
   Basic's garbage collector at end.

@endnode


@node AllocMemL "AllocMemL"

 @{fg highlight}AllocMemL&(BYVAL sz&, BYVAL flags&, BYVAL pml&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Version / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Reserva  memoria  con  los  atributos  pedidos  creando,  si  no  existe, o
   ampliando  si  existe,  una  lista de memoria a medida  (bloques de memoria
   encadenados).

   Allocates  memory with attributes requested creating, if this don't exists,
   or expanding if this exists, a custom memory list (memory chunks linked).


 @{b}Argumentos / Arguments@{ub}

   sz&

      Tamaño del bloque de memoria a reservar

      Chunk memory's size

   flags&

      Atributos del S.O. para dicho bloque (MEMF_CLEAR&,...)

      OS memory's attributes (MEMF_CLEAR&,...)

   pml&

      Puntero al último bloque reservado con AllocMemL&
      o 0& si desea crear una nueva lista de memoria.

      Pointer to the last memory chunk allocated with AllocMemL&
      or 0& if you want to create a new memory list.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      Puntero al bloque de memoria reservado o 0& si fracasa.

      Pointer to the chunk reserved or 0& if this fails.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec.
   Ficheros de inclusión "Exec.bh".
   Fichero de rutinas "MemL.bas".

   Exec library.
   Exec.bh include file.
   MemL.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   ' Creando una lista de memoria de nueve elementos
   '   Creating a memory list with nine elements

   DIM ptr&(8)
   ptr&(0) = AllocMemL&(100000&,MEMF_ANY&,0&)

   IF ptr&(0) <> NULL& THEN
     PRINT "#  1  mem chunk: 0x";HEX$(ptr&(0))

     FOR c% = 1 TO 8

        ptr&(c%) = AllocMemL&(4096&,MEMF_ANY& OR MEMF_CLEAR&,ptr&(c%-1%))

        IF ptr&(c%) = NULL& THEN
           EXIT FOR
        ELSE
           PRINT "# ";c%+1;" mem chunk: 0x";HEX$(ptr&(c%))
        END IF

     NEXT c%

   END IF

   ' Liberando la memoria reservada
   '  Freeing the memory allocated

   a& = FreeMemL&(ptr&(8))
   IF a& = ptr&(0) THEN
     PRINT "All memory reserved, now free!"
    ELSE
     PRINT "FreeMemL& failed!"
   END IF

 @{b}Notas / Notes@{ub}

   ¡¡No  utilice  como  argumento  pml&  un  puntero  a  un  bloque de memoria
   reservado por otros medios (Freevec(), AllocMem(), etc.)!!  Para liberar la
   memoria  reservada  utilice la función FreeMemL& y pásele como argumento el
   puntero  al  último  bloque  de  la  lista.   Consulte el fichero "MemL.ds"
   (creado  con  DrawStudio  2)  para entender la estructura de los bloques de
   memoria y cómo se enlazan.

   Don't use as pml& argument a pointer to a memory chunk allocated with other
   method (FreeVec(), AllocMem(), etc.)!!  For to release the memory allocated
   uses  the  FreeMemL&  function  passing  the  last  memory chunk pointer as
   argument.   See the "MemL.ds" (created with DrawStudio 2) for to understand
   how works my memory custom lists.

@endnode


@node FreeMemL "FreememL"

 @{fg highlight}FreeMemL&(BYVAL pml&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Borra una lista de memoria creada con AllocMemL&, liberando dicha memoria.

   Deletes a memory list created with AllocMemL& (releasing the memory).

 @{b}Argumentos / Arguments@{ub}

   pml&

      Puntero al último bloque de memoria reservado de la lista.

      Pointer to the last element from the memory list created.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      Puntero  al primer bloque de memoria reservado (nodo inicial)
      o 0& si la función fracasa.

      Pointer  to  the  first memory chunck allocated (start node)
      or 0& if the function fails.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec.
   Ficheros de inclusión "Exec.bh".
   Fichero de rutinas "MemL.bas".

   Exec library.
   Exec.bh include file.
   MemL.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   Puesto que es una rutina complementaria de @{"AllocMemL" link "AllocMemL"}, consulte su ejemplo.

   This a complementary routine for @{"AllocMemL" link "AllocMemL"}: check their example.

 @{b}Notas / Notes@{ub}

   ---

@endnode


@node LetraNIF "LetraNIF"

 @{fg highlight}FreeMemL&(BYVAL pml&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Genera el carácter de control del número
   del D.N.I. (Documento Nacional de Identidad) español.

   Generates the control char
   for the D.N.I. (ID number for Spanish citizens).

 @{b}Argumentos / Arguments@{ub}

   dni&

      El nº del D.N.I.

      The D.N.I.

 @{b}Devuelve / Returns@{ub}

   Cadena / string

      El carácter de control.

      The control char.

 @{b}Requisitos / Requeriments@{ub}

   ---

 @{b}Ejemplos / Examples@{ub}


   dni& = 12345678
   PRINT "Mi N.I.F. es / My N.I.F. is: ";RTRIM$(STR$(dni&));LetraNIF$(dni&)

 @{b}Notas / Notes@{ub}

   El  dígito  de  control  calculado no sirve para el C.I.F.  (certificado de
   identificación fiscal), pues este último utiliza otro algoritmo.

   The  char  control calculated isn't valid for the C.I.F.  (similar to N.I.F
   but for companies): this uses other algorythm.

@endnode


@node ChangeExt "ChangeExt"

 @{fg highlight}ChangeExt$(BYVAL flname$,BYVAL ext$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Añade, cambia o suprime la extensión final del nombre de un fichero.

   Adds, changes or removes the final suffix at the end of a filename.

 @{b}Argumentos / Arguments@{ub}

   flname$

      Nombre del fichero (con o sin extensión).

      Filename (with or without extension).

   ext$

      Nuevo sufijo/extensión a añadir o cadena vacía
      si quiere eliminar la extensión de flname$.

      The new suffix/extension to add or empty string
      for to remove the extension included in flname$

 @{b}Devuelve / Returns@{ub}

   cadena / String

      El nuevo nombre del fichero.

      The new filename.

 @{b}Requisitos / Requeriments@{ub}

   ---

 @{b}Ejemplos / Examples@{ub}

   PRINT ChangeExt$("","jpg")

   -> .jpg

   PRINT ChangeExt$("Photo.jpg","bmp")

   -> Photo.bmp

   PRINT ChangeExt$("Program.exe","")

   -> Program

   PRINT ChangeExt$("MyPack.lha.zip","lzx")

   -> MyPack.lha.lzx

 @{b}Notas / Notes@{ub}

   ---

@endnode

@node ChkPat "ChkPat"

 @{fg highlight}ChkPat&(BYVAL cad$,BYVAL pat$, nocase&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Comprueba si una cadena se ajusta al patrón indicado.

   Checks if a string match with a pattern.

 @{b}Argumentos / Arguments@{ub}

   cad$

      Cadena a comprobar

      String for to check.

   pat$

      Patrón (=expresión que puede incluir símbolos comodín del AmigaOS).

      Pattern.

    nocase&

      TRUE&  (NO diferencia mayúsculas de minúsculas / case NO sensitive).

      FALSE& (diferencia mayúsculas de minúsculas / case sensitive).

 @{b}Devuelve / Returns@{ub}

    Palabra larga / Long word

       0&   - No / No
       1&   - Sí / Yes
       2&   - Memoria libre insuficiente / Out of memory
      >2&   - Error (IoErr)

    ¡Atención! ¡¡ La rutina puede modificar el argumento nocase& !!
    Consulte la sección de "Notas" para más información.

    Warning! The routine would modify the nocase& argument!!
    Read the "Notes" section for more info.

 @{b}Requisitos / Requeriments@{ub}

   Biblitecas Exec y DOS (v37).
   Ficheros de inclusión "Exec.bh" y "Dos.bh".
   Fichero de rutinas "ChkPat.bas"

   Exec & DOS (v37) libraries.
   Exec.bh and Dos.bh include files.
   ChkPat.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

  ChkPat&("MiFichero.PNG","#?.png",FALSE&)
    -> 1

  ChkPat&("Juan Reinoso Rial","[a-z]u#? Rial",TRUE&)
    -> 0

 @{b}Notas / Notes@{ub}

   La  rutina funciona también con la versión 36 de la biblioteca DOS, pero en
   este  caso la comparación SIEMPRE será sensible a la altura de caja (o sea,
   se  diferenciará entre mayúsculas y minúsculas independientemente del valor
   del  argumento  nocase$ y éste será modificado por la rutina cambiándolo al
   valor FALSE&).

   The  function  also  works with the dos.library v36, but at this case,  the
   comparison  will be ALWAYS case sensitive (the nocase$ argument will be not
   relevant and the routine will change their value to FALSE&).

@endnode


@node CopyFDAtribs "CopyFDAtribs"

 @{fg highlight}CopyFDAtribs&(BYVAL source$,BYVAL destination$,BYVAL att&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Copia  los  atributos  principales  (hora/fecha,  protección,  comentario y
   propietario/grupo)  de  un directorio o fichero en otro.  Se permite copiar
   los atributos de un fichero en un directorio y viceversa.

   Copy    the    main   atributes   (time/date,   protection,   comment   and
   owneruid/ownergid) from a drawer or a file over other.  You can copy theses
   from a file to a dir and viceversa.

 @{b}Argumentos / Arguments@{ub}

   source$

      Directorio o fichero de origen.

      Source directory or file.

    destdir$

      Directorio o fichero de destino.

      Destination directory or file.

    att&

      &B0001& - Fecha / Date
      &B0010& - Protección / Protection
      &B0100& - Comment / Comentario
      &B1000& - Propietario y grupo / OwnerUID and OwnerGID


      Versión de la biblioteca DOS (algunas funciones
      requieren la v36 y otras la  v39 como mínimo).

      DOS library version (some functions
      requires the v36, others v39 as minimum).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

                 NULL& - Todo se ha copiado correctamente.
                         All are copied correctly.

   &B000000000000xxx1& - Falló la fecha / Fails the date
   &B000000000000xx1x& - Falló la protección / Fails the protection
   &B000000000000x1xx& - Failó el comentario / Fails the comment
   &B0000000000001xxx& - Failó el propietario-grupo / Fails OwnerUID-OwnerGID
   &B0000000100000000& - Falló Lock&() / Lock() fails
   &B0000001000000000& - Falló AllocDOSObject&() / AllocDOSObject() fails
   &B0000010000000000& - Falló ExamineFH&() / ExamineFH&() fails

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca DOS (v36)
   Fichero de inclusión "Dos.bh" y "Exec.bc".
   Fichero de rutinas "CopyFDAtribs.bas".

   DOS (v36) library.
   Dos.bh & Exec.bc include file.
   CopyFDAtribs.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   PRINT CopyFDAtribs&("SYS:Disk.info","SYS:C",&B1111&)

   --> 0

 @{b}Notas / Notes@{ub}

   El  valor  devuelto  puede  ser  una  suma de varios errores:  p. ej. si ha
   fallado  el  copiado  de la  fecha y el comentario, el valor devuelto sería
   &B0101&.  La opción de copiar el propietario y el grupo exige haber abierto
   la v39 de la biblioteca DOS.


   The returned value can be a sum.  I.e.  if the date and comment copy fails,
   the  returned  value  would  be &B0101&.  The owneruid-ownergid attrib copy
   requires as minimum DOS library v39.

@endnode


@node CopyFile "CopyFile"

 @{fg highlight}CopyFile&(BYVAL sdir$,BYVAL ddir$,BYVAL fname$,BYVAL nname$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   CopyFile 1.5

 @{b}Versión / Version@{ub}

   2.0

 @{b}¿Qué hace? / What do it?@{ub}

   Copia un fichero, con un nuevo nombre si quiere, en el directorio indicado.

   Copy a file, with a new name if you want, in the dir selected.

 @{b}Argumentos / Arguments@{ub}

   sdir$

      Directorio de origen.

      Source directory.

   ddir$

      Directorio de destino.

      Destination directory.

   fname$

      Nombre del fichero fuente.

      The origin filename.

   nname$

      Nombre del fichero de destino.

      The final file name.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      DOSTRUE&

         La copia del fichero se ha realizado con éxito.

         The copy process was done ok.

      DOSFALSE&

         La copia ha fracaso.

         The copy process was failed.

 @{b}Requisitos / Requeriments@{ub}

   Bibliotecas Exec y DOS (v36).
   Ficheros de inclusión "Exec.bh" y "Dos.bh".
   Fichero de rutinas "CopyFile.bas".

   Exec & DOS (v36) libraries.
   Exec.bh and Dos.bh include files.
   CopyFile.bas routines's file.

 @{b}Ejemplos / Examples@{ub}

   PRINT CopyFile&("SYS:","RAM:","Disk.info","")

   -> -1

      (la rutina copia "Disk.info" de "SYS:" a "RAM:")
      (this copy the "Disk.info" file from "SYS:" to "RAM:")

 @{b}Notas / Notes@{ub}

   El  tampón  utilizado  para la copia estará comprendido entre el tamaño del
   fichero  a  copiar y los 4 kilooctetos (se evalúa cada vez que se invoca la
   rutina).  Consulte también la función "CopyFDAtribs&".

   The buffer used for the copy process will be evaluated with each call (from
   file size to 4 KB).  See also the "CopyFDAtribs" function.

@endnode


@node CreateVarEnv "CreatVarEnv"

 @{fg highlight}CreateVarEnv&(BYVAL appname$,BYVAL varname$,BYVAL v$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Crea, sólo si no existe, una variable de entorno con el valor dado.

   Creates, only if this don't exists,
   the  enviroment's var with the value passed.

 @{b}Argumentos / Arguments@{ub}

   appname$

      Nombre de la aplicación.

      Application's name.

   varname$

      Nombre de la variable de entorno.

      Enviroment's var name.

   v$

      Valor por defecto.

      Default value.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      TRUE&  - la variable existe (no sufre modificación)
               the env var exists (the routine don't change it).

      FALSE& - la variable no existe y se crea.
               the env var don't exits and the routine creates it.

 @{b}Requisitos / Requeriments@{ub}

   ---

 @{b}Ejemplos / Examples@{ub}


 @{b}Notas / Notes@{ub}

   La  rutina  es  100%  Basic,  de  manera  que  no  supone  ningún  problema
   interrumpir su funcionamiento.  ¡No incluye tratamiento de errores!.

   The routine is 100% pure Basic (not troubles if the program is stopped in).
   This routine don't include errors' treatment!

@endnode

@node Exists "Exists"

 @{fg highlight}Exists&(BYVAL oname$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   FEXISTS

 @{b}Versión / Version@{ub}

   2.0

 @{b}¿Qué hace? / What do it?@{ub}

   Informa si existe un fichero, UNIDAD o DIRECTORIO pedido.

   Says if a file, unit or a DRAWER exists.

 @{b}Argumentos / Arguments@{ub}

   oname$

      Nombre del fichero, directorio o unidad (con su ruta completa).

      Filename, drawer or unit (with their full path).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

       0& - El fichero, directorio o unidad NO existe.
            The file or drawer couldn't exists.


       1& - El fichero, directorio o unidad.
            The file, directory or unit exists.

      >1& - Código de error de IoErr& (excepto los errores
            ERROR_OBJECT_NOT_FOUND&, ERROR_DIR_NOT_FOUND& o
            ERROR_DEVICE_NOT_MOUNTED& que hacen que
            la rutina devuelva el valor 0&).

            IoErr& code error (except the ERROR_OBJECT_NOT_FOUND&,
            ERROR_DIR_NOT_FOUND& or ERROR_DEVICE_NOT_MOUNTED& values:
            at this case the routine returns 0&).

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Dos.
   Fichero de inclusión "dos.bh".
   Fichero de rutinas "Exists.bas".

   DOS library.
   Dos.bh include file.
   Exists.bas routine's file.

 @{b}Ejemplos / Examples@{ub}

    PRINT Exists&("SYS:C")

    -> 1

    PRINT Exists&("SYS:C/")

    -> 1

    PRINT Exists&("SYS:Disk.info")

    -> 1

    PRINT Exists&("DH0:")

    -> 1

    PRINT Exists&("Ficticious:DontExistsDrawer")

    -> 0

 @{b}Notas / Notes@{ub}

   Si  invoca  la  función  con  una  cadena  vacía  como argumento, fracasará
   generando el error nº 5 ("llamada ilegal a la función").

   If  you  call  the  function  with  an  empty  string, this will fails with
   "Illegal function call" error (#5).

@endnode


@node FixPath "FixPath"

 @{fg highlight}FixPath$(BYVAL path$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Corrige  una  ruta  (de  acceso) absoluta o relativa, añadiendo al final de
   ésta el símbolo "/" si es necesario.

   Fix  an  absolute  or  relative  path  adding the "/" at the end if this is
   necessary.

 @{b}Argumentos / Arguments@{ub}

   path$

      Ruta (de acceso).

      Path.

 @{b}Devuelve / Returns@{ub}

   Cadena / String

      Ruta, si es necesario corregida.

      Path, if this is necesary, fixed.


 @{b}Requisitos / Requeriments@{ub}

   ---

 @{b}Ejemplos / Examples@{ub}

    PRINT FixPath$("SYS:")

    -> SYS:

   PRINT FixPath$("MiDir/Otro")

   -> MiDir/Otro/

   PRINT FixPath$("SYSTEM:Devs/Dosdrivers/")

   -> SYSTEM:Devs/Dosdrivers/

 @{b}Notas / Notes@{ub}

   ---

@endnode


@node Mkd "Mkd"

 @{fg highlight}MKD&(BYVAL dirname$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   MKDIR

 @{b}Versión / Version@{ub}

   1.1

 @{b}¿Qué hace? / What do it?@{ub}

   Crea un nuevo directorio.

   Make a new directory.

 @{b}Argumentos / Arguments@{ub}

   dirname$

      Nombre del directorio (con su ruta completa).

      Directory name (with the full path).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

       0&  - El directorio se ha creado correctamente.

             The drawer was created succesfully.

      >0&  - Código de error de IoErr& / IoErr& code error

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca DOS.
   Ficheros de inclusión "Exec.bc" y "Dos.bh".
   Fichero de rutinas "Mkd.bas".

   DOS library.
   Exec.bc & Dos.bh include files.
   Mkd.bas routine's file.

 @{b}Ejemplos / Examples@{ub}

   PRINT MKD&("RAM:Example")
   -> 0   (si no existe/if the drawer don't exists)
   -> 203 (si existe/if the drawer exists)

 @{b}Notas / Notes@{ub}

   ---

@endnode


@node NewPri "NewPri"

 @{fg highlight}NewPri&(newpriority&,mode&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Cambia la prioridad, de forma absoluta o relativa, de una tarea.

   Changes the absolute or relative task's priority.

 @{b}Argumentos / Arguments@{ub}

   npri&

      Nuevo valor de la prioridad.

      The new priority's value.

   mode&

      TRUE&

         Modo absoluto (el valor de npri& es la prioridad).

         Absolute mode (the npri& value is the priority).

      FALSE&

         Modo relativo (npri& indica el incremento, si el valor es positivo,
         o decremento, si el valor es negativo, de la prioridad previa).

         Relative mode (npri& says how the routine must to increase, if the
         value is positive, or to decrease, if the value is negative,
         the previous priority).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      Prioridad original o previa (¡entero sin signo!).

      The original/previous priority (integer without sign!).

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec.
   Fichero de inclusión "Exec.bh".
   Fichero de rutinas "NewPri.bas".

   Exec library.
   Exec.bh include file.
   NewPri.bas routine's file.

 @{b}Ejemplos / Examples@{ub}

   Si la prioridad original fuese 2/If the original priority was 2:

   Primera opción (modo absoluto)/First option (absolute mode)
   -----------------------------------------------------------
   p& = NewPri&(-1,TRUE&)

   ahora la prioridad es de -1 (vea la sección de "Notas").
   now the priority is -1 (see the "Notes" section).

   Segunda opción (modo relativo)/Second option (relative mode)
   ------------------------------------------------------------
   p& = NewPri&(-1,FALSE&)

   ahora la prioridad es 1 / now the priority is 1.

 @{b}Notas / Notes@{ub}

   Mis  experimentos  indican  que  el valor devuelto parece ser un entero sin
   signo  r8-?...   en  otras palabras, para una prioridad -1 (y aunque admite
   este parámetro directamente) devuelve, si era esa su prioridad original, el
   valor 255.

   Warning!   My  experiments  shows  what the value returned seems a unsigned
   integer  r8-?...   i.e.   if  the  program has -1 as priority, the function
   returns the 255 value.

@endnode


@node ParseArgs "ParseArgs"

 @{fg highlight}ParseArgs&(tpt$(2),BYVAL appname$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   @{"SGetArg" link "SGetArg"}, COMMAND$

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Procesa  los  argumentos  de  la  línea  de comandos (Shell) o los tipos de
   herramienta (Workbench) usando las funciones del S.O.

   Parse  the Shell's arguments (Shell) or the tooltypes (Workbench) using the
   OS functions.

 @{b}Argumentos / Arguments@{ub}

   tpt$(X,3)

      Matriz bidimensional con
      X (0 a X-1) * 3 (0 a 2) elementos que contiene:

       (X,0) la palabra clave del argumento CLI/tipo de herramienta,

       (X,1) el tipo de argumento CLI en formato AmigaDOS
             (p. ej. "/S" para un interruptor),

       (X,2) está vacío, salvo que el argumento deba ser una cadena,
             en cuyo caso ha de inicializar este elemento con
             la cadena CHR$(0).

       (X,3) sus contenidos son irrelevantes antes de invocar la función;
             cuando la rutina termine contendrá los argumentos CLI
             o los valores de los tipos de herramienta.

     -----------------------------------------------------------------

     Bidimensional array with
     X (0 to X-1) * 4 (0 to 2) elements with theses contents:

       (X,0) the keyword for CLI argument or the WB tooltype,

       (X,1) the CLI argument type with AmigaDOS format
             (i. e. "/S" for a switch),

       (X,2) empty, except if the argument must be a string:
             at this case, you must be defined this element as CHR$(0).

       (X,3) irrelevant at the start; when the routine finnish, this
             will contents the CLI argument or WB tooltype value.

   appname$

      Nombre de la aplicación (vea @{"ArgvZero" link "ArgvZero"}).

      Application's name (see @{"ArgvZero" link "ArgvZero"}).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

     TRUE& si la rutina ha hecho su trabajo o NULL& si la rutina ha fallado.

     TRUE& if the routine works succesfully or NULL& if this has failed.

 @{b}Requisitos / Requeriments@{ub}

   Bibliotecas Exec, Dos (v36) e Icon.
   Ficheros de inclusión "Exec.bh", "Dos.bh", "Icon.bh" y "Workbench.bc".
   Fichero de rutinas "ParseArgs.bas".

   Exec, Dos (v36) and Icon libraries.
   Exec.bh, Dos.bh, Icon.bh & Workbench.bc include files.
   ParseArgs.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   DIM tpt$(3,3)

   tpt$(0,0) = "FROM"
   tpt$(0,1) = "/K"
   tpt$(0,2) = CHR$(0)
   tpt$(1,0) = "TO"
   tpt$(1,1) = "/K"
   tpt$(1,2) = CHR$(0)
   tpt$(2,0) = "VERBOSE"
   tpt$(2,1) = "/S"
   tpt$(2,2) = ""
   tpt$(3,0) = "QUIET"
   tpt$(3,1) = "/S"
   tpt$(3,2) = ""

   parse& = ParseArgs&(tpt$(),"MyProgram")

   --> La variable parse& tendrá el valor TRUE& si ha podido hacer su trabajo
       correctamente y en ese caso los elementos de tpt$(x,3) contendrán los
       argumentos como cadenas.

       The parse& var will contais the TRUE& value if the routine do the work
       succesfully and at this case, the tpt$(x,3) elements will contains all
       the arguments as strings.

 @{b}Notas / Notes@{ub}

  ¡¡ATENCIÓN!!   Esta  función MODIFICA los elementos (X,3) de la matriz usada
  como  argumento para que contengan los argumentos Shell o los valores de los
  tipos de herramienta.  Rutina creada para la versión 1.3 de mi proyecto IBcc
  (IBrowse Cache Cleaner).

  WARNING!!   This  function  CHANGES  the  arrays'  elements  (X,3)  used  as
  argument:   The  new  contents  will  be the CLI arguments or the tooltypes'
  values.  Created for my IBcc (IBrowse Cache Cleaner) project, release 1.3.

@endnode


@node ReplaceChars "ReplaceChars"

 @{fg highlight}ReplaceChars$(BYVAL cadena$,BYVAL caracteres$,BYVAL cadsust$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Sustituye los caracteres (individuales) por otros.

   Replaces the (individual) chars for others.


 @{b}Argumentos / Arguments@{ub}

   cadena$

      Cadena original.

      Original string.

   caracteres$

      Caracteres a cambiar (interpretados individualmente).

      The chars what the routine
      must to replace (parsed as individual chars).

   cadsust$

      Cadena que sustituye a cada carácter solicitado.

      Strings what replace each character requested.

 @{b}Devuelve / Returns@{ub}

   Cadena / String

      Cadena modificada.

      Modified string.

 @{b}Requisitos / Requeriments@{ub}

   ---

 @{b}Ejemplos / Examples@{ub}

  PRINT ReplaceChars$("María tenía un... obús","aioáíú","<CHG>")

  -> M<CHG>r<CHG><CHG> ten<CHG><CHG> un... <CHG>b<CHG>s

 @{b}Notas / Notes@{ub}

   ¡Cuidado!   La  función puede hacer un uso intensivo de las cadenas, de ahí
   que ella misma llame al recolector de basura.

   Warning!   The  function  could  use  intensivily the strings:  this is the
   reason because the function calls the garbage collector.

@endnode


@node ReqS "ReqS"

 @{fg highlight}ReqS&(BYVAL win&, BYVAL trq$, BYVAL brq$, BYVAL butrq$, BYVAL args&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Abre una petición informativa simple.

   Open a simple requester.

 @{b}Argumentos / Arguments@{ub}

   win&

      Puntero a la ventana de la que depende (WINDOW(7) si utiliza una ventana
      creada con el comando WINDOW del Hisoft Basic) o 0&.

      Pointer to window (WINDOW(7) if you uses a Hisoft Basic Window) or 0&.

   trq$

      Título de la petición (o CHR$(10) si no quiere asignarle uno).

      Title's requester (or CHR$(0) if you don't want to assign one).

   brq$

      Mensaje  de texto.  Utilice CHR$(10) para los saltos de línea y símbolos
      % al estilo del C (para integrar contenidos de variables en la cadena).

      Text  message.   Uses  the  CHR$(10)  for to start a new text line and %
      symbols as C language (for to include var's values in the strings).

   butrq$

      Texto  del botón.  Soporta los símbolos % al estilo del C (para integrar
      contenidos de variables en la cadena).

      Button  text.   Supports  %  symbols as C language (for to include var's
      values in the strings).

   args&

      Puntero  a una tabla de argumentos (si las cadenas del mensaje del texto
      o  los  botones incluyen símbolos % al estilo del C para "incrustar" los
      contenidos de variables) o 0& (sin argumentos).

      Pointer  to args table (if the text or button texts includes % sybols as
      C lenguage for to inserte the var's values) or 0& (no arguments).

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      Devuelve un valor comprendido entre 0 (al presionar el único botón o, si
      hay más, al seleccionar el situado más a la derecha) y "n" (al presionar
      el  resto  de  los botones cuando hay más que uno, siendo n=1, n=2, etc.
      de izquierda a derecha).

      Returns  a  value  from 0 (whith only one button, when the user press it
      or,  if there are more buttons, when the user press the "more" right) to
      "n"  (when  the  user  press the others button if there are two or more,
      with n=1, n=2, etc. from left to right).

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Intuition (v37).
   Fichero de inclusión "Intuition.bh" y "Exec.bc".
   Fichero de rutinas "ReqS.bas"

   Intuition (v37) library.
   Intuition.bh & Exec.bc include files.
   ReqS.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   texto$ = "Fin del programa"+CHR$(10)+"Presione el botón"

   PRINT ReqS&(WINDOW(7),CHR$(10),texto$,"Continuar",0&)
   id& = ReqS&(0&,"Confirmar...","Elija:","1|2|3|Cancelar",0&)

   IF id& = 0& THEN
      PRINT "¿Cancelar? / Cancel?"
   ELSE
      PRINT "Ha seleccionado / You have press: ";id&
   END IF

   nombre$ = "Federico Campos"+CHR$(0)
   anos!   = 38
   texto$  = "Mi nombre es %.8s y tengo %ld años"
   fin$    = "Fin / End"+CHR$(0)
   ' Mi tabla de datos / My data's table
   data$   = STRING$(4*3,CHR$(0))
   ' Definiendo los valores / Setting the values
   POKEL SADD(data$)  , SADD(nombre$)
   POKEL SADD(data$)+4, anos!
   POKEL SADD(data$)+8, SADD(fin$)

   PRINT ReqS&(0&,"Prueba",texto$,"%.3s",SADD(data$))

 @{b}Notas / Notes@{ub}

   Consulte   en   la   documentación   para   desarrolladores  las  funciones
   "intuition.library/EasyRequestArgs"  y "exec.library/RawDoFmt".  La función
   generará  un  error  "Illegal  function  call" (nº 5) si se ejecuta con una
   versión de la biblioteca Intuition inferior a la 36.

   See the "intuition.library/EasyRequestArgs" & "exec.library/RawDoFmt" Amiga
   functions'  docs.   The  function  will break the program with the "Illegal
   function call" error (#5) if the Intuition library is < 36 release.

@endnode

@node SGetArg "SGetArg"

 @{fg highlight}SGetArg$(BYVAL p%,BYVAL template$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   COMMAND$

 @{b}Versión / Version@{ub}

   1.6

 @{b}¿Qué hace? / What do it?@{ub}

   Devuelve argumento de la línea de comandos pedido.

   Returns the Shell argument requested.

 @{b}Argumentos / Arguments@{ub}

   p%

      Nº del argumento (su posición en la cadena COMMAND$).

      # of argument (their position in the COMMAND$ string).

   template$

      Plantilla a mostrar cuando se usa el argumento "?"

      Template what the routine will shows with argument "?".

 @{b}Devuelve / Returns@{ub}

   Cadena / String

      Argumento pedido o una cadena vacía si no existe.

      Argument requested or an empty string if this don't exists.

 @{b}Requisitos / Requeriments@{ub}

   Fichero de rutinas "SGetArg.bas".
   Trampa de errores del Hisoft Basic.

   SGetArg.bas routine's file.
   Hisoft Basic error's trap.

 @{b}Ejemplos / Examples@{ub}

   tpt$  = "QUIET/S"
   IF SGetArg$(1%,tpt$) = "" THEN
      PRINT "Sin argumentos / No arguments"
   END IF

 @{b}Notas / Notes@{ub}

   ¡¡Cuidado!!   Esta  rutina hace uso de la trampa de errores, desactivándola
   al terminarse:  si su programa también la utiliza, (re)actívela al salir de
   la  rutina,  puesto  que el (Amiga|Hisoft) Basic no permite ni averiguar su
   estado  (para  restaurarlo  tras  salir de la rutina) ni definirla de forma
   local  (para  que no interfiera con el programa principal u otras rutinas).
   ¡¡Cuidado!!   El  argumento  p%  ha  de ser mayor que cero o se generará un
   error  "Illegal  function  call" (error nº 5; llamada ilegal a la función).
   ¡¡Cuidado!!   La  rutina  no  evalúa o comprueba la cadena introducida como
   plantilla:    es   labor  del  programador  interpretar  correctamente  los
   "argumentos"  devueltos  (por  ejemplo, si son en realidad palabras clave).
   ¡¡Cuidado!!  La función puede hacer un uso intensivo de las cadenas, de ahí
   que ella misma llame al recolector de basura.

   La rutina soporta el uso de comillas para deliminar los argumentos (que son
   convenientemente  eliminadas  al  devolver  el argumento), elimina espacios
   iniciales  y  finales  innecesarios  y  muestra  la  sintaxis si el usuario
   utiliza "?" como argumento.

                                   ---=---

   Warning!!  This routine uses the Hisoft Basic trap's errors, disabling this
   when  the  function ends:  if their code uses it, (re)enable/define it when
   this  function  end.  Warning!!  The p% argument requires a value >0 or the
   function  will  generate  an "Illegal function call" (#5) error.  Warning!!
   The  routine don't check or evaluate the template's string:  the coder must
   to  parse  correctly  the  "arguments"  returned  (i.e.  if this isn'a real
   "argument",   this  is  a  keyword).   Warning!   The  function  could  use
   intensivily the strings:  this is the reason because the function calls the
   garbage collector.

   The  routines  support  the quotes for to enclose the arguments (but theses
   are  removed  when  the  argument  is  returned),  remove  extra spaces -at
   start/end- and shows the template if the user uses the "?" argument.

@endnode


@node SReqFD "SReqFD"

 @{fg highlight}SReqFD&(BYVAL win&, BYVAL title$, _
               wx&, wy&, ww&, wh&, _
               ipat$, idir$, ifile$, _
         BYVAL typeonlydir&, BYVAL noicons&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ReqF$

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Abre una petición ASL de ficheros o directorios.

   Open an ASL file or drawer requester.

 @{b}Argumentos / Arguments@{ub}

   win&

      Puntero a la ventana de la que depende o 0& (si no hay ventana).

      Pointer to window or 0& (no window attached).

   title$

      Título de la petición.

      Requester's title.

   wx&

      Coordenada   X   de  la  esquina  superior  izquierda  de  la  petición.
      ¡¡Cuidado!!   La  función  modifica  esta  variable  (de  manera  que el
      programador podrá usar esa información, si lo desea...  por ejemplo para
      abrir   la  próxima  petición  en  la  misma  ubicación/con  las  mismas
      dimensiones).

      Left  edge request (X coordinate).  Warning!!  This function modify this
      variable  (the  coder  can  use this info...  i.e.  for to open the next
      requester at the same location/with the same size).

   wy&

      Coordenada Y de la esquina superior izquierda de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Top edge request (Y coordinate).
      Warning!!  This function modify this variable.

   ww&

      Anchura de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Width's request.  Warning!!  This function modify this variable.

   wh&

      Altura de la petición.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Height's request.  Warning!!  This function modify this variable.

   ipat$

      Patrón inicial.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Initial pattern.  Warning!!  This function modify this variable.

   idir$

      Ruta inicial.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Initial path.  Warning!!  This function modify this variable.

   ifile$

      Fichero inicial.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Initial file.  Warning!!  This function modify this variable.


   typeonlydir&

      TRUE&  - Abre una petición de directorios.

               Opens a drawer request.

      FALSE& - Abre una petición de ficheros.

               Opens a file request.

   noicons&

      TRUE&  - Oculta los iconos.

               Hide the icons.

      FALSE& - Muestra también los iconos.

               Shows also the icons.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      TRUE&  - La rutina ha funcionado correctamente.

               The routine has work succesfully.

      FALSE& - La rutina ha fallado o se ha cancelado la petición.

               The routine has failed o the user has cancel the request.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec y Asl (v36).
   Ficheros de inclusión "Exec.bh", "Utility.bc" y "Asl.bh".
   Fichero de rutinas "SReqFD.bas".

   Exec y Asl (v36) libraries.
   Exec.bh, Utility.bc & Asl.bh include files.
   SReqFD.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   y& = 10&
   h& = 100&
   ip$="#?.device"
   ic$="DEVS:"
   if$="ramdrive.device"

   rs& = SReqFD&(0&,"Prueba",10&,y&,100&,h&,ip$,ic$,if$,0&,TRUE&)

   IF rs& THEN
      PRINT "Selección/Selection > ";ic$;if$

      ip$ ="[F-L]#?"
      ic$ ="SYS:"

      rs& = SReqFD&(0&,"Otra prueba",10&,y&,100&,h&,ip$,ic$,if$,TRUE&,FALSE&)
   ELSE
       PRINT " Fin (Cancelación) - End (Cancel)"
   END IF

 @{b}Notas / Notes@{ub}

   ¡¡Cuidado!!   Las  variables  wx&,  wy&, ww&, wh&, ifile$, idir$, ipat$ son
   modificables  desde  la rutina, por ello debe pasar estos datos a la rutina
   como  variables  y  no  como  constantes...   salvo  que quiera ignorar los
   cambios.   Recuerde  que para que la petición se abra en el lugar y con las
   dimensiones   deseadas   las  preferencias  de  Asl  deben  permitirlo  ;).
   ¡¡Cuidado!!   Si solicita una petición de ficheros, ofreciendo un nombre de
   fichero por defecto, cambia de directorio desde la petición sin seleccionar
   otro  fichero  y  presiona [Aceptar], la función le devolverá la nueva ruta
   ¡¡y  el  fichero  definido  por  defecto!!  (que evidentemente no estará en
   dicho cajón,  por ello,  puede ser interesante recurrir a la función @{"Exists" link "Exists"}
   incluida  en este paquete para evaluar si el resultado es real/válido antes
   de utilizarlo ;).

   Warning!!   The  wx&, wy&, ww&m wh&, ifile$, idir$, ipat$ vars are modified
   by  the  routine:  you should pass theses datas to the routine as variables
   not  as  values...  unless you want to ignore their changes.  Remember that
   so that the requester opens up in the place and with the wanted dimensions,
   the  Asl  preferences  should  allow  it.   Warning!!   If  you uses a file
   requester,  offering  a  default  filename, you changes the drawer from the
   requester  without  selecting another file and you press [OK], the function
   will  return  the  new  path....   and  the  default  file defined!!  (that
   evidently isn't correct... you can use the @{"Exists" link "Exists"} included in this package
   to evaluate if the result is real/valid before using it ;).

@endnode


@node SReqFont "SReqFont"

 @{fg highlight}SReqFont&(BYVAL win&, BYVAL title$, _
                 wx&, wy&, ww&, wh&, _
                 ifont$, _
                 isize&, _
                 istyle&, _
           BYVAL showonlyfixed&, BYVAL showstyle&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Abre una petición ASL para elección la de un tipo de imprenta/letra.

   Opens an ASL font requester.

 @{b}Argumentos / Arguments@{ub}

   win&

      Puntero a la ventana de la que depende o 0& (si no hay ventana).

      Pointer to window or 0& (no window attached).

   title$

      Título de la petición.

      Requester's title.

   wx&

      Coordenada   X   de  la  esquina  superior  izquierda  de  la  petición.
      ¡¡Cuidado!!   La  función  modifica  esta  variable  (de  manera  que el
      programador podrá usar esa información, si lo desea...  por ejemplo para
      abrir   la  próxima  petición  en  la  misma  ubicación/con  las  mismas
      dimensiones).

      Left  edge request (X coordinate).  Warning!!  This function modify this
      variable  (the  coder  can  use this info...  i.e.  for to open the next
      requester at the same location/with the same size).

   wy&

      Coordenada Y de la esquina superior izquierda de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Top edge request (Y coordinate).
      Warning!! This function modify this variable.

   ww&

      Anchura de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Width's request.  Warning!! This function modify this variable.

   wh&

      Altura de la petición.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Height's request.  Warning!! This function modify this variable.

   ifont$

      Nombre (inicial) del tipo de letra/imprenta (podría ser una cadena nula,
      "",  si no quiere especificarse).  ¡¡Cuidado!!  La función modifica esta
      variable.

      (Initial)  font name, or an empty string, "", if the coder don't want to
      define one.  Warning!!  This function modify this variable.

   isize&

      Tamaño (inicial) del tipo de letra/imprenta.
      ¡¡Cuidado!!  La función modifica esta variable.

      (Initial) font's size.
      Warning!!  This function modify this variable.

   istyle&

      Estilo (inicial) del tipo de letra/imprenta.
      ¡¡Cuidado!!  La función modifica esta variable.

      (Initial) font's style.
      Warning!!  This function modify this variable.

   showonlyfixed&

      TRUE&  - Mostrará sólo los tipos de anchura fija.

               Only fixed (width) fonts.

      FALSE& - Mostrará todos los tipos (anchura fija + proporcional).

               All fonts (fixed + proportional width).

   showstyle&

      TRUE&  - Mostrará las casillas (de verificación) de estilos.

               Shows the style's checkboxes.

      FALSE& - No mostrará las casillas de estilos.

               Don't show the style checkboxes.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      TRUE&  - La rutina ha funcionado correctamente.

               The routine has work succesfully.

      FALSE& - La rutina ha fallado o se ha cancelado la petición.

               The routine has failed o the user has cancel the request.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec y Asl (v36).
   Ficheros de inclusión "Exec.bh", "Graphics.bc", "Utility.bc" y "Asl.bh".
   Fichero de rutinas "SReqFont.bas".

   Exec y Asl (v36) libraries.
   Exec.bh, Graphics.bc, Utility.bc & Asl.bh include files.
   SReqFont.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   r& = SReqFont&(0&,"Elija un tipo...",0&,0&,200&,200&, _
                  "garnet.font",9&,FSF_UNDERLINED&,TRUE&,TRUE&)

   IF r& = FALSE& THEN
      BEEP
      END
   ELSE
      PRINT "Ha seleccionado / You has selected: ";ifont$;" (";isize&;")"
   END IF

 @{b}Notas / Notes@{ub}

   ¡¡Cuidado!!   Las variables wx&, wy&, ww&, wh&, ifont$, isize&, istyle$ son
   modificables  desde  la rutina, por ello debe pasar estos datos a la rutina
   como  variables  y  no  como  constantes...   salvo  que quiera ignorar los
   cambios.   Recuerde  que para que la petición se abra en el lugar y con las
   dimensiones   deseadas   las  preferencias  de  Asl  deben  permitirlo  ;).
   Si el sistema dispone de la versión 45 de la biblioteca ASL se ofrecerá una
   muestra  del  texto  con  el tipo de letra seleccionado (debido a que usted
   podría  no disponer de dichos ficheros de inclusión, en el código he optado
   por incluir la constante numérica directamente).

   Warning!! The wx&, wy&, ww&, wh&, ifont$, isize$, istyle$ vars are modified
   by  the  routine:  you should pass theses datas to the routine as variables
   not  as  values...  unless you want to ignore their changes.  Remember that
   so that the requester opens up in the place and with the wanted dimensions,
   the  Asl  preferences  should allow it.  If the system have the ASL library
   release 45, the requester will show a sample text using the font selected.

@endnode


@node SReqScr "SReqScr"

 @{fg highlight}SReqScr&(BYVAL win&, BYVAL title$, _
                 wx&, wy&, ww&, wh&, _
                 imodscr&, iwscr&, ihscr&, _
           BYVAL showsize&, BYVAL showinfo&, _
                 iwx&, iwy&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Abre una petición de modo de pantalla ASL.

   Opens an ASL screenmode requester.

 @{b}Argumentos / Arguments@{ub}

   win&

      Puntero a la ventana de la que depende o 0& (si no hay ventana).

      Pointer to window or 0& (no window attached).

   title$

      Título de la petición.

      Requester's title.

   wx&

      Coordenada   X   de  la  esquina  superior  izquierda  de  la  petición.
      ¡¡Cuidado!!   La  función  modifica  esta  variable  (de  manera  que el
      programador podrá usar esa información, si lo desea...  por ejemplo para
      abrir  la  próxima  petición  en la misma misma ubicación/con las mismas
      dimensiones).

      Left  edge request (X coordinate).  Warning!!  This function modify this
      variable  (the  coder  can  use this info...  i.e.  for to open the next
      requester at the same location/with the same size).

   wy&

      Coordenada Y de la esquina superior izquierda de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Top edge request (Y coordinate).
      Warning!! This function modify this variable.

   ww&

      Anchura de la petición.
      ¡¡Cuidado!!  La función modifica esta variable.

      Width's request.  Warning!! This function modify this variable.

   wh&

      Altura de la petición.
      ¡¡Cuidado!!  La  función modifica esta variable.

      Height's request.  Warning!! This function modify this variable.

   imodscr&

      Modo (inicial) seleccionado.
      ¡¡Cuidado!!  La  función modifica esta variable.


      (Initial) selected screenmode.
      Warning!! This function modify this variable.

   iwscr&

      Anchura (inicial) seleccionada.
      ¡¡Cuidado!!  La  función modifica esta variable.


      (Initial) display with.
      Warning!! This function modify this variable.

   ihscr&

      Altura (inicial) seleccionada.
      ¡¡Cuidado!!  La  función modifica esta variable.


      (Initial) height selected.
      Warning!! This function modify this variable.

   showsize&

      TRUE&  - Mostrará los artilugios de altura/anchura.

               Shows the height/width gadgets.

      FALSE& - No mostrará los artilugios de altura/anchura.

               Don't show the height/withd gadgets.

   showinfo&

      TRUE&  - Mostrará la ventana de información.

               Shows the info window.

      FALSE& - No mostrará la ventana de información.

               Don't show the info window.
   iwx&

      Coordenada  X  de  la  esquina  superior  izquierda  de  la  ventana  de
      información.   ¡¡Cuidado!!  La función modifica esta variable (de manera
      que  el  programador  podrá  usar  esa  información, si lo desea...  por
      ejemplo para abrir la próxima ventana con la misma ubicación).

      Left  edge  of  info  window  (X  coordinate).  Warning!!  This function
      modify  this variable (the coder can use this info...  i.e.  for to open
      the next window at the same location).

   iwy&

      Coordenada  Y  de  la  esquina  superior  izquierda  de  la  ventana  de
      información.  ¡¡Cuidado!!  La función modifica esta variable.

      Top edge of info window (Y coordinate).
      Warning!! This function modify this variable.

 @{b}Devuelve / Returns@{ub}

   Palabra larga / Long word

      TRUE&  - La rutina ha funcionado correctamente.

               The routine has work succesfully.

      FALSE& - La rutina ha fallado o se ha cancelado la petición.

               The routine has failed o the user has cancel the request.

 @{b}Requisitos / Requeriments@{ub}

   Biblioteca Exec y Asl (v36).
   Ficheros de inclusión "Exec.bh", "Utility.bc" y "Asl.bh".
   Fichero de rutinas "SReqScr.bas".

   Exec y Asl (v36) libraries.
   Exec.bh, Utility.bc & Asl.bh include files.
   SReqScr.bas routines' file.

 @{b}Ejemplos / Examples@{ub}

   resx&  = 640
   resy&  = 200
   initm& = 0&
   dummy& = SReqScr&(WINDOW(7),"Pantalla/Screen",11,11,180,180,initm&,resx&,resy&,TRUE&,TRUE&,50,50)

   IF dummy& THEN
      PRINT " Tamaño / Size : ";rx&;" x ";ry&
      PRINT " Modo   / Mode : &H";HEX$(mo&)
   ELSE
      PRINT "Petición fallida o cancelada / Requester failed or cancelled"
   END IF

 @{b}Notas / Notes@{ub}

   ¡¡Cuidado!!   Las  variables  wx&, wy&, ww&, wh&, imodscr&, iwscr&, ihscr&,
   iwx&,  iwy&  son  modificables  desde  la rutina, por ello debe pasar estos
   datos  a la rutina como variables y no como constantes...  salvo que quiera
   ignorar los cambios.  Recuerde que para que la petición se abra en el lugar
   y con las dimensiones deseadas las preferencias de Asl deben permitirlo ;).

   Warning!!   The  wx&,  wy&,  ww&, wh&, imodscr&, iwscr&, ihscr&, iwx&, iwy&
   vars  are  modified  by  the  routine:  you should pass theses datas to the
   routine  as  variables  not  as  values...  unless you want to ignore their
   changes.   Remember  that  so  that the requester opens up in the place and
   with the wanted dimensions, the Asl preferences should allow it.

@endnode


@node StrTo "Str2B / Str2C"

 @{fg highlight}Str2B$(BYVAL cad$)@{fg text}

 @{fg highlight}Str2C$(BYVAL cad$)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.1 y 1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Convierte,  respectivamente,  una  cadena  tipo C a una cadena tipo Basic y
   viceversa,  o  sea,  elimina  o  añade  el  carácter CHR$(0) que en el C se
   utiliza como delimitador de las cadenas.

   Converts  a  C  string  to a Basic string and vice versa (remove or add the
   CHR$(0) char...  at C language, this ends the strings).

 @{b}Argumentos / Arguments@{ub}

   cad$

      Cadena original.

      Original string.

 @{b}Devuelve / Returns@{ub}

   Cadena / String

      Cadena modificada (sin o con el código CHR$(0) final).

      Modified string (without or with the CHR$(0) char at end).

 @{b}Requisitos / Requeriments@{ub}

   Fichero de rutina "StrTo.bas".

   StrTo.bas routine's file.

 @{b}Ejemplos / Examples@{ub}

   ex$ = "Mifichero.jpg"
   PRINT "Original string"
   PRINT ex$;" (";LEN(ex$);")"
   PRINT

   PRINT "Basic to C string"
   ex$ = Str2C$(ex$)
   PRINT ex$;" (";LEN(ex$);")"
   PRINT

   PRINT "C to Basic string"
   ex$ = Str2B$(ex$)
   PRINT ex$;" (";LEN(ex$);")"

 @{b}Notas / Notes@{ub}

   La  función  Str2B$  generará un error "Illegal function call" (nº 5) si la
   cadena en C no está terminada por el código CHR$(0).

   The function Str2B$ will break the program with the "Illegal function call"
   error (#5) if the C string isn't finnished with the CHR$(0) char.

@endnode


@node WKey "WKey"

 @{fg highlight}WKey(BYVAL mode&)@{fg text}

 @{b}Reemplaza a / Supersedes@{ub}

   ---

 @{b}Versión / Version@{ub}

   1.0

 @{b}¿Qué hace? / What do it?@{ub}

   Detiene la ejecución de un programa hasta que se pulse una tecla o botón.

   The program waits what the user press a key or a button.

 @{b}Argumentos / Arguments@{ub}

   mode&

      Modo / Mode

        Aguarda que el usuario presione...
        Waits what the user press...

        <= 255    La tecla del código CHR$(mode&)
                  The key CHR$(mode&)

           256    Cualquier tecla
                  One key

           257    El botón de acción del ratón (=izquierdo)
                  The action mouse button (=left)

           258    El botón de disparo de la palanca de juegos nº 0
                  The fire button from the joy #0

           259    El botón de disparo de la palanca de juegos nº 1
                  The fire button from the joy #1

 @{b}Devuelve / Returns@{ub}

   ---

 @{b}Requisitos / Requeriments@{ub}

   Fichero de rutinas "WKey.bas".
   Una ventana del Hisoft Basic
   (la automática o la creada con el comando WINDOW).

   Wkey.bas routines' file.
   An Hisoft Basic window
   (the automatic or created with the WINDOW command).

 @{b}Ejemplos / Examples@{ub}

   PRINT "Pulse la barra espaciadora para terminar el programa"
   PRINT "  Press the space bar for to finnish the program"
   WKey(32)
   PRINT "*** FIN / THE END **"
   END

 @{b}Notas / Notes@{ub}

   ¡Atención!   Esta  subrutina  sólo  puede  utilizarse con la ventana creada
   automáticamente  por  Hisoft Basic o con las creadas con el comando WINDOW.
   ¡¡ No intente utilizarlo con otras !!  La rutina generará un error "Illegal
   function call" (nº 5) si se utiliza un valor fuera de rango (compruebe éste
   en el apartado Argumentos).

   Warning!   This  subroutine only works with the automatic window created by
   Hisoft  Basic  or with a window created with the WINDOW command.  Don't use
   with  others  windows  !!   The  subroutine will break the program with the
   "Illegal  function  call"  error  (#5)  if  you use a value illegal (out of
   range):  check theses reading the Arguments section.

@endnode


@node Notas "Evolución histórica / History"

 @{b}Versión actual@{ub}

   Segunda versión enviada a Aminet con veintitres (23) rutinas.

   Second version sent to Aminet with twenty three (23) routines.


 @{b}1.0 (10/03/2002)@{ub}

   Primera versión publicada en Aminet con ocho (8) rutinas.

   First version uploaded to Aminet with eight (8) routines.

@endnode
