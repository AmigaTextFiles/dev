' *********************************************************************
'                         TTEngine_SpeedText.bas
'       de/by Dámaso D. Estévez {correoamidde-aminet000,yahoo,es}
'          AmiSpaTra - htp://www.xente.mundo-r.com/amispatra/
'
'                   based over C version included in
'             the developper package by Grzegorz Kraszewski
'                                -----
'                 basado en la versión en C incluida en
'         el paquete de desarrolladores de Grzegorz Kraszewski
'
'          All rights reserved / Todos los derechos reservados
'
'                        TTEngine speed test
'                  Prueba de velocidad de TTEngine
' ---------------------------------------------------------------------
'        CodeWatcher by Michael Plitkins says what this program
'         don't free all memory allocated... but the C version
'             has the same behaviour (a TTEngine library
'            fault or feature (deferred resource release)?).
'               Beware with name fields and their size for
'               some OS structs: check the "*.bc" files.
'
'     CodeWatcher de Michael Plitkins informa de que este programa
'    no libera toda la memoria reservada... pero la versión en C se
'     comporta igual (¿es un problema o una prestación (liberación
'             demorada) de la propia biblioteca TTEngine?).
'      Cuidado con el nombre de los campos y el tamaño de éstos
'  de algunas estructuras del SO: compruébelos en los ficheros "*.bc".
' ---------------------------------------------------------------------
'             All rights reserved over this derivative work:
'                my Hisoft Basic developpers package.
'      Forbidden to remove ALL legal/copyrights remarks included
'          in this package: if you create a derivate work,
'                 you MUST to include all legal notes.
'
'      Todos los derechos reservados sobre este trabajo derivado:
'   mi paquete para desarrolladores que programen con Hisoft Basic.
'         Está prohibido eliminar cualquier comentario o nota
'    de autoría/legal de este paquete: si crea un trabajo derivado
'       HA DE INCLUIR OBLIGATORIAMENTE TODAS LAS NOTAS LEGALES.
' *********************************************************************

v$ = "$VER: TTEngine_SpeedTest 1.0 (24/07/2011) by Dámaso 'AmiSpaTra' Domínguez based over C version wrote by Grzegorz Kraszewski"

'      Hisoft Basic don't include some library definitions r8-?
' Hisoft Basic no incluye las definiciones de algunas bibliotecas r8-?
' --------------------------------------------------------------------
LIBRARY DECLARE "mathieeesingbas.library"

DECLARE FUNCTION IEEESPFix& LIBRARY
DECLARE FUNCTION IEEESPDiv& LIBRARY
DECLARE FUNCTION IEEESPMul& LIBRARY
DECLARE FUNCTION IEEESPFlt& LIBRARY

'        Compiler's metacommands (see the Hisoft Basic Manual)
' Metacomandos para el compilador (consulte el manual del Hisoft Basic)
' ---------------------------------------------------------------------
REM $NOWINDOW
REM $NOBREAK
REM $NOEVENT

' Hisoft Basic include files / Ficheros de inclusión del Hisoft Basic
' ---------------------------------------------------------------------
REM $include dos.bh
REM $include exec.bh
REM $include intuition.bh
REM $include graphics.bh
REM $include ttengine.bh
REM $include asl.bh
REM $include timer.bh
REM $include utility.bc                                      ' TAG_END&

'    From/De:  http://aminet.net/package/dev/basic/AST_HBRoutines
'             Fix the paths / Corrige las rutas de acceso
' ---------------------------------------------------------------------
REM $include BLib_AST/FixPath.bas

BREAK STOP

'          Some global vars / Algunas variables globales
' ---------------------------------------------------------------------
DIM MainTags&((10-1)*2)           ' 10 Tags / Etiquetas (OPTION BASE 0)
EClock& = NULL&

' =====================================================================
'         Subroutines and functions / Subrutinas y funciones
' =====================================================================

FUNCTION get_font_name$
	LOCAL freq&, localtags&

	DIM localtags&((6-1)*2)      ' 6 Tags / Etiquetas (OPTION BASE 0)

	freq& = AllocAslRequest&(ASL_FileRequest&, NULL&)

	IF freq& THEN

		TAGLIST VARPTR(localtags&(0)), _
			ASLFR_TitleText&,      SADD("Select a TrueType font / Elija un tipo TrueType"+CHR$(0)), _
			ASLFR_InitialDrawer&,  SADD("FONTS:"+CHR$(0)), _
			ASLFR_DoPatterns&,     TRUE&, _
			ASLFR_InitialPattern&, SADD("#?.ttf"+CHR$(0)), _
			ASLFR_RejectIcons&,    TRUE&, _
			TAG_END&

		IF AslRequest&(freq&, VARPTR(localtags&(0))) THEN

				'     As you can see, this version is more
				'          simple and don't require
				'         a free_font_name function
				'             vs the C version.
				'
				'       Como puede ver, esta versión
				'        es más simple y no requiere
				'        una función free_font_name
				'         frente a la versión en C.
				' ---------------------------------------------
				get_font_name$ = FixPath$(PEEK$(PEEKL(freq&+fr_Drawer%))) + PEEK$(PEEKL(freq&+fr_File%))

		END IF

		FreeAslRequest freq&

	END IF

	ERASE localtags&

END FUNCTION

' ---------------------------------------------------------------------

SUB test_loop(rp&, cad$, EClock&)
	LOCAL a%, b%, start$, stop$, speed&, dummy&

	start$ = STRING$(EClockVal_sizeof%,CHR$(0))
	stop$  = STRING$(EClockVal_sizeof%,CHR$(0))

	Forbid
	dummy& = ReadEClock&(SADD(start$))

	FOR a% = 10% TO 400 STEP 10

		SetAPen rp&,    (a% >> 3)
		SetBPen rp&, NOT(a% >> 3)

		FOR b% = 40% TO 415 STEP 16

			Move rp&, a%, b%
			TT_Text rp&, SADD(cad$), LEN(cad$)

		NEXT b%

	NEXT a%

	dummy& = ReadEClock&(SADD(stop$))

	Permit

	IF (PEEKL(SADD(stop$)+ev_lo%) < PEEKL(SADD(start$)+ev_lo%)) THEN

		POKEL (SADD(stop$)+ev_lo%), NOT((PEEKL(SADD(start$)+ev_lo%))-PEEKL(SADD(stop$)+ev_lo%))

	ELSE

		POKEL (SADD(stop$)+ev_lo%), (PEEKL(SADD(stop$)+ev_lo%)-PEEKL(SADD(start$)+ev_lo%))

	END IF

	speed& = IEEESPFix&(IEEESPDiv&(IEEESPMul&(IEEESPFlt&(10000), IEEESPFlt&(EClock&)), IEEESPFlt&(PEEKL(SADD(stop$)+ev_lo%))))
	
	PRINT LTRIM$(STR$(speed&));" glyphs per second / glifos por segundo."

END SUB

' =====================================================================
'                      Main code / Código principal
' =====================================================================

'  Opening all using easy method / Abriendo todo por el método rápido
' ---------------------------------------------------------------------

LIBRARY OPEN "exec.library"
LIBRARY OPEN "dos.library",             37&
LIBRARY OPEN "intuition.library",       39&
LIBRARY OPEN "graphics.library",        39&
LIBRARY OPEN "asl.library",             38&
LIBRARY OPEN "ttengine.library",         5&
LIBRARY OPEN "mathieeesingbas.library", 37&

'  Workbench or CLI? / ¿Workbench o interfaz de la línea de comandos?
' ---------------------------------------------------------------------
IF PEEKL(SYSTAB+8) <> 0 THEN
	wb& = TRUE&
ELSE
	wb& = FALSE&
END IF

'               Select a TrueType font via ASL request
'   Elija un tipo de impresión TrueType a través de una petición ASL
' ---------------------------------------------------------------------
fontname$ = get_font_name$

IF fontname$ <> ""

	TAGLIST VARPTR(MainTags&(0)),   _
		WA_Top&,           25&, _
		WA_Left&,           0&, _
		WA_Width&,        640&, _
		WA_Height&,       480&, _
		WA_CloseGadget&, TRUE&, _
		WA_DragBar&,     TRUE&, _
		WA_DepthGadget&, TRUE&, _
		WA_IDCMP&,       IDCMP_CLOSEWINDOW&,_
		WA_Title&,       SADD("ttengine library speed text / prueba de velocidad de ttengine"+CHR$(0)), _
		TAG_END&

	win& = OpenWindowTagList&(NULL&, VARPTR(MainTags&(0)))

	IF win& THEN

		running& = TRUE&
		rp&      = PEEKL(win&+RPort%)

		TAGLIST VARPTR(MainTags&(0)),   _
			TT_FontFile&, SADD(fontname$+CHR$(0)), _
			TT_FontSize&, 16&, _
			TAG_END&

		font& = TT_OpenFontA&(VARPTR(MainTags&(0)))

		IF font& THEN

			req$ = STRING$(timerequest_sizeof%,CHR$(0))
			ev$  = STRING$(EClockVal_sizeof%,  CHR$(0))

			'          Spanish string: Prueba de velocidad
			' ---------------------------------------------------------
			c$   = "speed test"

			IF OpenDevice&(SADD("timer.device"+CHR$(0)), UNIT_ECLOCK&, SADD(req$), 0) = 0 THEN

				LIBRARY VARPTR "timer.device", PEEKL(SADD(req$)+tr_node%+IORequestio_Device%)

				EClock& = ReadEClock&(SADD(ev$))

				dummy& = PutStr&(SADD("E Clock will be used for measurements, frecuency is"+STR$(EClock&)+" Hz."+CHR$(10)+CHR$(0)))
				dummy& = PutStr&(SADD("Se utilizará 'EClock' para las mediciones, la frecuencia es"+STR$(EClock&)+" Hz."+CHR$(10)+CHR$(0)))

				IF TT_SetFont&(rp&, font&) THEN

					TAGLIST VARPTR(MainTags&(0)), _
						TT_Window&,    win&, _
						TT_Antialias&, TT_Antialias_Off&, _
						TAG_END&

					dummy& = TT_SetAttrsA&(rp&, VARPTR(MainTags&(0)))

					SetDrMd rp&, JAM1&

					dummy& = PutStr&(SADD("Antialias: OFF, mode: JAM1 / Suavizado: NO, modo: JAM1"+CHR$(10)+CHR$(0)))
					test_loop rp&, c$, EClock&
					EraseRect rp&, PEEKB(win&+BorderLeft%), PEEKB(win&+BorderTop%),(PEEKW(win&+WindowWidth%) - PEEKB(win&+BorderRight%)-1), (PEEKW(win&+WindowHeight%) - PEEKB(win&+BorderBottom%)-1)

					TAGLIST VARPTR(MainTags&(0)), _
						TT_Antialias&, TT_Antialias_On&, _
						TAG_END&

					dummy& = TT_SetAttrsA&(rp&, VARPTR(MainTags&(0)))

					dummy& = PutStr&(SADD("Antialias: ON, mode: JAM1 / Suavizado: SÍ, modo: JAM1"+CHR$(10)+CHR$(0)))
					test_loop rp&, c$, EClock&
					EraseRect rp&, PEEKB(win&+BorderLeft%), PEEKB(win&+BorderTop%),(PEEKW(win&+WindowWidth%) - PEEKB(win&+BorderRight%)-1), (PEEKW(win&+WindowHeight%) - PEEKB(win&+BorderBottom%)-1)

					SetDrMd rp&, JAM2&

					dummy& = PutStr&(SADD("Antialias: ON, mode: JAM2 / Suavizado: SÍ, modo: JAM2"+CHR$(10)+CHR$(0)))
					test_loop rp&, c$, EClock&
					EraseRect rp&, PEEKB(win&+BorderLeft%), PEEKB(win&+BorderTop%),(PEEKW(win&+WindowWidth%) - PEEKB(win&+BorderRight%)-1), (PEEKW(win&+WindowHeight%) - PEEKB(win&+BorderBottom%)-1)

					TAGLIST VARPTR(MainTags&(0)), _
						TT_Antialias&, TT_Antialias_Off&, _
						TAG_END&

					dummy& = TT_SetAttrsA&(rp&, VARPTR(MainTags&(0)))

					dummy& = PutStr&(SADD("Antialias: OFF, mode: JAM2 / Suavizado: NO, modo: JAM2"+CHR$(10)+CHR$(0)))
					test_loop rp&, c$, EClock&
					EraseRect rp&, PEEKB(win&+BorderLeft%), PEEKB(win&+BorderTop%),(PEEKW(win&+WindowWidth%) - PEEKB(win&+BorderRight%)-1), (PEEKW(win&+WindowHeight%) - PEEKB(win&+BorderBottom%)-1)

				ELSE

					dummy& = PutStr&(SADD("TT_SetFont() failed! / ¡TT_SetFont() ha fracasado!"+CHR$(10)+CHR$(0)))

				END IF

				TT_CloseFont font&

			ELSE

				dummy& = PutStr&(SADD("Font open failed! / ¡Apertura del tipo de impresión fallida!"+CHR$(10)+CHR$(0)))

			END IF

			LIBRARY VARPTR "timer.device", NULL&
			CloseDevice SADD(req$)

		ELSE

			dummy& = PutStr&(SADD("Timer device isn't available! / ¡El dispositivo Timer no está disponible!"+CHR$(10)+CHR$(0)))

		END IF

		' Beware! Use 1& (and not only 1) in the "(1& <<..." or the expression won't work
		' ¡Cuidado! Utilice 1& (y no sólo 1) en la expresión "(1& <<..." o no funcionará
		' -------------------------------------------------------------------------------
		sigmask& = SIGBREAKF_CTRL_C& OR (1& << PEEKB(PEEKL(win&+UserPort%)+mp_SigBit%))

		WHILE running&

			signals& = xWait&(sigmask&)

			'   Break support (only in this loop) via AmigaOS.

			'     Soporte de la interrupción del usuario
			'   (sólo en este bucle) a través del AmigaOS.
			' ---------------------------------------------------
			IF (signals& AND SIGBREAKF_CTRL_C&) THEN running& = FALSE&

			IF (signals& AND (1& << PEEKB(PEEKL(win&+UserPort%)+mp_SigBit%))) THEN

				'    Get the message
				' Se obtiene el mensaje
				' ---------------------
				imsg& = GetMsg&(PEEKL(win&+UserPort%))

				IF imsg& THEN

					'   The user want to close the window?
					'  ¿El usuario quiere cerrar la ventana?
					' ---------------------------------------
					IF PEEKL(imsg&+Class%) = IDCMP_CLOSEWINDOW& THEN
						running& = FALSE&
					END IF

					ReplyMsg imsg&

				END IF

			END IF

		WEND

		TT_DoneRastPort PEEKL(win&+RPort%)
		CloseWindow win&

	ELSE

		dummy& = PutStr&(SADD("I can't open a window / ¡Imposible abrir una ventana!"+CHR$(10)+CHR$(0)))

	END IF

END IF

LIBRARY CLOSE

'     Return the value if the user starts the program from Shell.

'         Devuelve un valor si el usuario ha puesto en marcha
'         el programa desde la interfaz de línea de comandos.
' ---------------------------------------------------------------------
IF wb& = FALSE& THEN
	STOP RETURN_OK&
END IF

BREAK ON

END
