' *********************************************************************
'                         TTEngine_TextFit.bas
'       de/by Dámaso D. Estévez {correoamidde-aminet000,yahoo,es}
'          AmiSpaTra - http://www.xente.mundo-r.com/amispatra/
'
'                   based over C version included in
'             the developper package by Grzegorz Kraszewski
'                                -----
'                 basado en la versión en C incluida en
'         el paquete de desarrolladores de Grzegorz Kraszewski
'
'          All rights reserved / Todos los derechos reservados
'
'                   Print a text in a constraining box
'       Impresión ajustada del texto a un recuadro que se reduce
' ---------------------------------------------------------------------
'        CodeWatcher by Michael Plitkins says what this program
'         don't free all memory allocated... but the C version
'             has the same behaviour (a TTEngine library
'            fault or feature (deferred resource release)?).
'               Beware with name fields and their size for
'               some OS structs: check the "*.bc" files.
'
'     CodeWatcher de Michael Plitkins informa de que este programa
'    no libera toda la memoria reservada... pero la versión en C se
'     comporta igual (¿es un problema o una prestación (liberación
'             demorada) de la propia biblioteca TTEngine?).
'      Cuidado con el nombre de los campos y el tamaño de éstos
'  de algunas estructuras del SO: compruébelos en los ficheros "*.bc".
' ---------------------------------------------------------------------
'             All rights reserved over this derivative work:
'                my Hisoft Basic developpers package.
'      Forbidden to remove ALL legal/copyrights remarks included
'          in this package: if you create a derivate work,
'                 you MUST to include all legal notes.
'
'      Todos los derechos reservados sobre este trabajo derivado:
'   mi paquete para desarrolladores que programen con Hisoft Basic.
'         Está prohibido eliminar cualquier comentario o nota
'    de autoría/legal de este paquete: si crea un trabajo derivado
'       HA DE INCLUIR OBLIGATORIAMENTE TODAS LAS NOTAS LEGALES.
' *********************************************************************

v$ = "$VER: TTEngine_TextFit 1.0 (24/07/2011) by Dámaso 'AmiSpaTra' Domínguez based over C version wrote by Grzegorz Kraszewski"

'        Compiler's metacommands (see the Hisoft Basic Manual)
' Metacomandos para el compilador (consulte el manual del Hisoft Basic)
' ---------------------------------------------------------------------
REM $NOWINDOW
REM $NOBREAK
REM $NOEVENT

' Hisoft Basic include files / Ficheros de inclusión del Hisoft Basic
' ---------------------------------------------------------------------
REM $include dos.bh
REM $include exec.bh
REM $include intuition.bh
REM $include graphics.bh
REM $include ttengine.bh
REM $include asl.bh
REM $include utility.bc                                      ' TAG_END&

'    From/De:  http://aminet.net/package/dev/basic/AST_HBRoutines
'             Fix the paths / Corrige las rutas de acceso
' ---------------------------------------------------------------------
REM $include BLib_AST/FixPath.bas

BREAK STOP

'          Some global vars / Algunas variables globales
' ---------------------------------------------------------------------
DIM MainTags&((10-1)*2)           ' 10 Tags / Etiquetas (OPTION BASE 0)
Red&   = NULL&
dummy& = NULL&                                ' Misc uses / Uso variado

' =====================================================================
'         Subroutines and functions / Subrutinas y funciones
' =====================================================================

FUNCTION get_font_name$
	LOCAL freq&, localtags&

	DIM localtags&((6-1)*2)      ' 6 Tags / Etiquetas (OPTION BASE 0)

	freq& = AllocAslRequest&(ASL_FileRequest&, NULL&)

	IF freq& THEN

		TAGLIST VARPTR(localtags&(0)), _
			ASLFR_TitleText&,      SADD("Select a TrueType font / Elija un tipo TrueType"+CHR$(0)), _
			ASLFR_InitialDrawer&,  SADD("FONTS:"+CHR$(0)), _
			ASLFR_DoPatterns&,     TRUE&, _
			ASLFR_InitialPattern&, SADD("#?.ttf"+CHR$(0)), _
			ASLFR_RejectIcons&,    TRUE&, _
			TAG_END&

		IF AslRequest&(freq&, VARPTR(localtags&(0))) THEN

				'     As you can see, this version is more
				'          simple and don't require
				'         a free_font_name function
				'             vs the C version.
				'
				'       Como puede ver, esta versión
				'        es más simple y no requiere
				'        una función free_font_name
				'         frente a la versión en C.
				' ---------------------------------------------
				get_font_name$ = FixPath$(PEEK$(PEEKL(freq&+fr_Drawer%))) + PEEK$(PEEKL(freq&+fr_File%))

		END IF

		FreeAslRequest freq&

	END IF
	
	ERASE localtags&

END FUNCTION

' ---------------------------------------------------------------------

SUB fitted_text(BYVAL txt$, BYVAL y%, BYVAL rp&, cte&, te&, BYVAL Red&)
	LOCAL to_draw&

	SetAPen rp&, Red&

	Move rp&, 20% + PEEKW(cte&+te_Extent%+RectangleMinX%), y% + PEEKW(cte&+te_Extent%+RectangleMinY%)
	Draw rp&, 20% + PEEKW(cte&+te_Extent%+RectangleMaxX%), y% + PEEKW(cte&+te_Extent%+RectangleMinY%)
	Draw rp&, 20% + PEEKW(cte&+te_Extent%+RectangleMaxX%), y% + PEEKW(cte&+te_Extent%+RectangleMaxY%)
	Draw rp&, 20% + PEEKW(cte&+te_Extent%+RectangleMinX%), y% + PEEKW(cte&+te_Extent%+RectangleMaxY%)
	Draw rp&, 20% + PEEKW(cte&+te_Extent%+RectangleMinX%), y% + PEEKW(cte&+te_Extent%+RectangleMinY%)

	to_draw& = TT_TextFit&(rp&, SADD(txt$), LEN(txt$), te&, cte&, 1%, 0%, 0%)

	SetAPen rp&, 2

	Move rp&, 20% + PEEKW(te&+te_Extent%+RectangleMinX%), y% + PEEKW(te&+te_Extent%+RectangleMinY%)
	Draw rp&, 20% + PEEKW(te&+te_Extent%+RectangleMaxX%), y% + PEEKW(te&+te_Extent%+RectangleMinY%)
	Draw rp&, 20% + PEEKW(te&+te_Extent%+RectangleMaxX%), y% + PEEKW(te&+te_Extent%+RectangleMaxY%)
	Draw rp&, 20% + PEEKW(te&+te_Extent%+RectangleMinX%), y% + PEEKW(te&+te_Extent%+RectangleMaxY%)
	Draw rp&, 20% + PEEKW(te&+te_Extent%+RectangleMinX%), y% + PEEKW(te&+te_Extent%+RectangleMinY%)

	'               Drawing the text / Imprimiendo el texto
	' ---------------------------------------------------------------
	SetAPen rp&, 1&
	Move rp&, 20&, y%
	TT_Text rp&, SADD(txt$), to_draw&

END SUB

' =====================================================================
'                      Main code / Código principal
' =====================================================================

'  Opening all using easy method / Abriendo todo por el método rápido
' ---------------------------------------------------------------------

LIBRARY OPEN "exec.library"
LIBRARY OPEN "dos.library",        37&
LIBRARY OPEN "intuition.library",  39&
LIBRARY OPEN "graphics.library",   39&
LIBRARY OPEN "asl.library",        38&
LIBRARY OPEN "ttengine.library",    5&

'  Workbench or CLI? / ¿Workbench o interfaz de la línea de comandos?
' ---------------------------------------------------------------------
IF PEEKL(SYSTAB+8) <> 0 THEN
	wb& = TRUE&
ELSE
	wb& = FALSE&
END IF

'               Select a TrueType font via ASL request
'   Elija un tipo de impresión TrueType a través de una petición ASL
' ---------------------------------------------------------------------
fontname$ = get_font_name$

IF fontname$ <> ""

	TAGLIST VARPTR(MainTags&(0)),   _
		WA_Top&,           25&, _
		WA_Left&,           0&, _
		WA_Width&,        640&, _
		WA_Height&,       210&, _
		WA_CloseGadget&, TRUE&, _
		WA_DragBar&,     TRUE&, _
		WA_DepthGadget&, TRUE&, _
		WA_IDCMP&,       IDCMP_CLOSEWINDOW&,_
		WA_Title&,       SADD("TT_TextFit() text / Prueba de TT_TextFit()"+CHR$(0)), _
		TAG_END&

	win& = OpenWindowTagList&(NULL&, VARPTR(MainTags&(0)))

	IF win& THEN

		running& = TRUE&
		rp&      = PEEKL(win&+RPort%)

		TAGLIST VARPTR(MainTags&(0)), _
			OBP_Precision&, PRECISION_IMAGE&, _
			TAG_END&

		Red& = ObtainBestPenA&(PEEKL(PEEKL(win&+WScreen%)+ScreenViewPort%+ColorMap%), 201&, 0&, 0&, VARPTR(MainTags&(0)))

		'         An struct (easy, but dangerous method)
		'      Una estructura (método fácil, pero peligroso)
		' -------------------------------------------------------
		cte$ = STRING$(TextExtent_sizeof%,CHR$(0))

		POKEW (SADD(cte$)+te_Width%),  32767%
		POKEW (SADD(cte$)+te_Height%), 32767%
		POKEW (SADD(cte$)+te_Extent%+RectangleMinX%), -10%
		POKEW (SADD(cte$)+te_Extent%+RectangleMinY%), -20%
		POKEW (SADD(cte$)+te_Extent%+RectangleMaxX%), 600%
		POKEW (SADD(cte$)+te_Extent%+RectangleMaxY%),  20%

		TAGLIST VARPTR(MainTags&(0)),   _
			TT_FontFile&, SADD(fontname$+CHR$(0)), _
			TT_FontSize&, 16&, _
			TAG_END&

		font& = TT_OpenFontA&(VARPTR(MainTags&(0)))

		IF font& THEN

			IF TT_SetFont&(rp&, font&) THEN

				TAGLIST VARPTR(MainTags&(0)), _
					TT_Window&,    win&, _
					TT_Antialias&, TT_Antialias_On&, _
					TAG_END&

				dummy& = TT_SetAttrsA&(rp&, VARPTR(MainTags&(0)))

				SetDrMd rp&, JAM1&

				'        Spanish text: El ejemplo de TT_TextFit() muestra cómo
				'       el texto es ajustado en un rectángulo que se constriñe.
				'---------------------------------------------------------------------
				s$ = "TT_TextFit() example shows how the text is fitted into constraining rectangle."

				te$ = STRING$(TextExtent_sizeof%,CHR$(0))

				FOR i% = 0% TO 99

					fitted_text s$, 45, rp&, SADD(cte$), SADD(te$), Red&
					POKEW (SADD(cte$)+te_Extent%+RectangleMaxX%), (PEEKW((SADD(cte$)+te_Extent%+RectangleMaxX%))-5&)

					Delay 10&

					EraseRect rp&, PEEKB(win&+BorderLeft%), PEEKB(win&+BorderTop%),(PEEKW(win&+WindowWidth%) - PEEKB(win&+BorderRight%) - 1), (PEEKW(win&+WindowHeight%) - PEEKB(win&+BorderBottom%) - 1)

				NEXT i%

			ELSE

				dummy& = PutStr&(SADD("TT_SetFont() failed! / ¡TT_SetFont() ha fracasado!"+CHR$(10)+CHR$(0)))

			END IF

			TT_CloseFont font&

		ELSE

			dummy& = PutStr&(SADD("Font open failed! / ¡Apertura del tipo de impresión fallida!"+CHR$(10)+CHR$(0)))

		END IF

		' Beware! Use 1& (and not only 1) in the "(1& <<..." or the expression won't work
		' ¡Cuidado! Utilice 1& (y no sólo 1) en la expresión "(1& <<..." o no funcionará
		' -------------------------------------------------------------------------------
		sigmask& = SIGBREAKF_CTRL_C& OR (1& << PEEKB(PEEKL(win&+UserPort%)+mp_SigBit%))

		WHILE running&

			signals& = xWait&(sigmask&)

			'   Break support (only in this loop) via AmigaOS.

			'     Soporte de la interrupción del usuario
			'   (sólo en este bucle) a través del AmigaOS.
			' ---------------------------------------------------
			IF (signals& AND SIGBREAKF_CTRL_C&) THEN running& = FALSE&

			IF (signals& AND (1& << PEEKB(PEEKL(win&+UserPort%)+mp_SigBit%))) THEN

				'    Get the message
				' Se obtiene el mensaje
				' ---------------------
				imsg& = GetMsg&(PEEKL(win&+UserPort%))

				IF imsg& THEN

					'   The user want to close the window?
					'  ¿El usuario quiere cerrar la ventana?
					' ---------------------------------------
					IF PEEKL(imsg&+Class%) = IDCMP_CLOSEWINDOW& THEN
						running& = FALSE&
					END IF

					ReplyMsg imsg&

				END IF

			END IF

		WEND

		ReleasePen PEEKL(PEEKL(win&+WScreen%)+ScreenViewPort%+ColorMap%), Red&
		TT_DoneRastPort PEEKL(win&+RPort%)
		CloseWindow win&

	ELSE

		dummy& = PutStr&(SADD("I can't open a window / ¡Imposible abrir una ventana!"+CHR$(10)+CHR$(0)))

	END IF

END IF

LIBRARY CLOSE

'     Return the value if the user starts the program from Shell.

'         Devuelve un valor si el usuario ha puesto en marcha
'         el programa desde la interfaz de línea de comandos.
' ---------------------------------------------------------------------
IF wb& = FALSE& THEN
	STOP RETURN_OK&
END IF

BREAK ON

END
