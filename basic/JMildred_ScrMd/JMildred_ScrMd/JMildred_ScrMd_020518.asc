
  version$ = "$VER: ScreenMode_Example V1.03,18/05-2002 Peter Thor"

; This is a complete example of opening a screenmoderequester, opening a screen
; depending on the requester and showing some output using Mildred.
; One type of doublebuffering with RTG/AGA (some bugs with P96 RTG)
;
; You can change the constants #CLOSEWB #BLITOBJECTS and the variable mode_blit.b
; to select different approaches of how the testprogram should work.
;
; Feel free to contact me for questions/suggestions or whatever you might want to tell me.
; Please send me the logfile(s) which is saved in Ram: about how fast the program
; can run to me via e-mail. I would appreciate this very much. Try the program
; with different blitting- and displaymodes
;
; pettho-0@student.luth.se
;
; Greetings goes to all Blitz-coders and the Blitzlist
;
;
; HISTORY:
; V1.03 - 18/05 2002
;         Added some compile-time constants the user can select upon compiling (#CLOSEWB)
;         Using Timer.device to calculate FPS instead of built-in commands
;         Changed size.w -> size.l in .jbitmap because it caused memoryleaks because of overflow
;         Changed InitBBitmap to allocate BitMap in either Fast/Chip if running RTG/AGA
;        Note: There seems to be some problems with P96, I personally use CGX but I am trying to find as many bugs as posslible
;        More code has to be added in order to fully support P96 as well
;
; V1.02 - 24/4 2001
;         Added doublebuffering for AGA - Be careful with what ILBM-file you use tho. One is included, works on both AGA/RTG.
;         Added FreeBBitmap{}, InitBBitmap{}, CalcFPS{}, CloseWorkbench{}, OpenWorkbench{}
;         Renamed some routines
;         Changed a lot of routines and fixed bugs here and there
;         Added some misc shite here and there =)
;         I have tested, RTG (CGX3), AGA/DBLAGA, NTSC/DBLNTSC and EURO:36Hz which all work.
;
; V1.01 - 2nd release on Aminet
;         Minor changes: Added more comments, fixed the .readmefile
;         Added different rastport-blitting modes (WPA|WPA8|WCP)
;         Added doublebuffering routines
;         Added some moving blocks
;
; V1.00 - 1st release on Aminet
;
;-----------------------------------------------------------------------------

  DEFTYPE .w
.
.CONSTANTS

  #TRUE_        = 1
  #FALSE_       = 0

  #WPA          = 1                                       ; CGX/P96
  #WCP          = 2                                       ; V40 (OS3.1+)
  #WPA8         = 3                                       ; V36+

  #CLOSEWB      = #FALSE_                                 ; close wb or not, make a choise
;  #CLOSEWB      = #TRUE_

  #BLITOBJECTS  = #FALSE_                                 ; blit moving objects or not, make a choise
  #BLITOBJECTS  = #TRUE_

  mode_blit.b         = #WCP                              ; V40 (3.1+) (make a choise)
;  mode_blit.b         = #WPA                              ; CGX/P96 (Gfx-card)
;  mode_blit.b         = #WPA8                             ; V36 (Oldest version)

  ;--

  #RECTFMT_LUT8 = 3                                       ; for RTG

  #VIEWSCREEN   = 0                                       ; for screen to view
  #VIEWWINDOW   = 0                                       ;     window to view

  #VIEWPALETTE  = 0                                       ;     palette to view

  #VIEWMBITMAP  = 0                                       ;     mildred-bitmap to view
  #STOREMBITMAP = 1                                       ;     mildred-bitmap to pick gfx from when an MUnQueue gets issues
  #MAPGRABMBITMAP = 2

  #VIEWMSHAPE   = 0                                       ;     mildred-shape to view
  #VIEWMQUEUE   = 0                                       ;     mildred-queue to blit shapes to

  #VIEWMC2PWINDOW = 0

  #MAXSHAPESINQUEUE = 30                                  ; maximum shapes allowed to store in MQueue
                                                          ; change this to get more blocks on screen
  #BMODE_DOUBLE = 0                                       ; BufferMode - Double buffering
  #BMODE_TRIPLE = 1                                       ; BufferMode - Triple buffering, not supported yet

  #MAXBITMAPS = 2-1                                       ; we will use TWO Bitmaps if AGA but only ONE if RTG

;--

  NEWTYPE .jbitmap                                        ; this structure is for allocation and disallocation of bitmap-memory
    *mem.l                                                ; pointer to memory where bitmap-data is located
    size.l                                                ; size of bitmap
  End NEWTYPE
  Dim bitmappointers.jbitmap(#MAXBITMAPS)

  NEWTYPE .block                                          ; for the movement of the shape-blocks we pick up and animate
    x.q
    y
    xs
    ys
  End NEWTYPE
  Dim Blocks.block(#MAXSHAPESINQUEUE)                     ; set up some moving blocks

;--

.FreeBBitmap
Statement FreeBBitmap {bitmapnr.w}
  ;
  ; FreeBBitmap V0.3, Peter Thor
  ;
  ; Frees up a bitmap
  ;

  SHARED bitmappointers.jbitmap()

  ;--

  If bitmappointers(bitmapnr)\mem
    FreeMem_ bitmappointers(bitmapnr)\mem, bitmappointers(bitmapnr)\size
    Free BitMap bitmapnr
    bitmappointers(bitmapnr)\mem = 0
  EndIf
End Statement

Statement Fail{text$}
  ;
  ; Fail V0.2, Peter Thor
  ;
  ; Will print errormessages (if any)
  ;

  SHARED *RP0.RastPort, *VP0.ViewPort
  SHARED IsRTG.b

  ;--

  If text$
    tmp.l = EasyRequest("Failure",text$,"Quit")
  EndIf

  If *RP0 Then Free Window #VIEWWINDOW                  ; free window
  If *VP0 Then Free Screen #VIEWSCREEN                  ; free screen

  If IsRTG                                              ; free bitmaps
    FreeBBitmap{0}
  Else
    FreeBBitmap{0}
    FreeBBitmap{1}
  EndIf

  End

End Statement

; Function : IsAGA{}
; Author : James L Boyd - jamesboyd@all-hail.freeserve.co.uk
; Returns True (-1) if it's an AGA machine. This makes for
; a much smaller executable than CheckAGA (around half-size :)
; Note that AGA is only activated after AGA machines have
; their SetPatch program run!
Function.b IsAGA {}
  lib$="graphics.library"
  *gfxbase.GfxBase=OpenLibrary_(&lib$,33)

  If *gfxbase
    If *gfxbase\ChipRevBits0 AND #GFXB_AA_ALICE
      aga.b=-1
    Else aga=0
    EndIf
    CloseLibrary_ *gfxbase
  EndIf
  Function Return aga
End Function

;--

.InitBBitmap
Statement InitBBitmap {bitmapnr.w, width.w, height.w, depth_.w}
  ;
  ; InitBBitmap V0.3, Peter Thor
  ;
  ; Allocates memory for a bitmap in either chip/fast and saves
  ; some data for it so that we can free it later.
  ;

  SHARED bitmappointers.jbitmap()
  SHARED IsRTG

  ;--

  If bitmappointers(bitmapnr)\mem = False

    If IsRTG
      *bitmapmem.l = AllocMem_(width*height*depth_/8,#MEMF_FAST|#MEMF_CLEAR)
    Else
      *bitmapmem.l = AllocMem_(width*height*depth_/8,#MEMF_CHIP|#MEMF_CLEAR)
    EndIf

    If *bitmapmem = False                                     ; allocate memory for a blitz-bitmap
      Fail{"Init Bitmap (Probably low on memory)!"}
    Else
      CludgeBitMap bitmapnr,width,height,depth_,*bitmapmem    ; "make" the blitz-bitmap we allocated memory for
      bitmappointers(bitmapnr)\mem    = *bitmapmem            ; save pointer to bitmap
      bitmappointers(bitmapnr)\size   = width*height*depth_/8 ; save size of bitmap
    EndIf
  EndIf
End Statement

;--
.
.CloseTimer
Statement CloseTimer {}
  SHARED *TimerMP.MsgPort
  SHARED *TimerIO.timerequest
  If *TimerMP
    CloseDevice_ (*TimerIO)
    DeleteIORequest_ (*TimerIO)
    DeleteMsgPort_ (*TimerMP)
  EndIf
End Statement

.OpenTimer
Function.b OpenTimer {}
  SHARED *TimerMP.MsgPort
  SHARED *TimerIO.timerequest
  ;--
  *TimerMP.MsgPort = CreateMsgPort_()
  If *TimerMP
    *TimerIO.timerequest = CreateIORequest_ (*TimerMP,SizeOf .timerequest)
    If *TimerIO
      If OpenDevice_ ("timer.device",#UNIT_MICROHZ,*TimerIO,0) = 0
        Function Return True
      Else
        Function Return False
      EndIf
    Else
      Function Return False
    EndIf
  Else
    Function Return False
  EndIf
End Function

.GetSystemTime
#GST_SECS = 0
#GST_MICRO = 1
Function.l GetSystemTime {mode.b}
  SHARED *TimerMP.MsgPort
  SHARED *TimerIO.timerequest
  *TimerIO\tr_node\io_Command = #TR_GETSYSTIME
  SendIO_ *TimerIO
  WaitPort_ *TimerMP
  Repeat
    *TimerMsg.Message = GetMsg_(*TimerMP)
  Until *TimerMsg
  If mode = #GST_SECS
    Function Return *TimerIO\tr_time\tv_secs
  Else
    Function Return *TimerIO\tr_time\tv_micro
  EndIf
End Function

;--

CNIF #CLOSEWB = #TRUE_
Function.b CloseWorkbench {}
  ;
  ; CloseWorkbench V0.2, Peter Thor
  ;
  ; Will just close down WorkBench

  If CloseWorkBench_
    Function Return True
  Else
    Function Return False
  EndIf
End Function

Statement OpenWorkbench{}
  ;
  ; OpenWorkbench V0.1, Peter Thor
  ;
  ; Will reopen the workbench
  ;
  ; Don't care about what gets returned.. :)
  ; This is just an example, not a guide to program the Amiga =)

  OpenWorkBench_

End Statement
CEND

;--

Function.b Exist {name$}
  ;
  ; Exist V0.1, Peter Thor
  ;
  ; Checks if a file exists or not
  ;

  *lock.l = Lock_(name$, #ACCESS_READ)

  If *lock
    UnLock_(*lock)
    Function Return True
  Else
    Function Return False
  EndIf

End Function

;--

Function.s GetScreenModeName {scrmodeid.l}
  ;
  ; GetScreenModeName V0.2, Peter Thor
  ;
  ; Function that returns a string containing the name of the
  ; supplied screenmodeid. (like "DBLPAL", "PAL Interlace" etc)
  ;

  IDhandle.l = FindDisplayInfo_(scrmodeid)
  GetDisplayInfoData_ IDhandle,&NamInfoBuf.NameInfo,SizeOf.NameInfo,#DTAG_NAME,0

  For n = 0 To 32-1                             ; maximum size is 32 bytes for the string
    modename.s + Chr$(NamInfoBuf\Name[n])
  Next

  Function Return StripTrail$(modename,0)       ; remove spaces, if any

End Function

;--

Function.b IsRTG {scrmodeid.l}
  ;
  ; IsRTG V0.3, Peter Thor
  ;
  ; Opens a testscreen behind all others with the supplied screenmode
  ; and returns True or False if or if not it is an RTG- or AGA-Screen
  ;

  #SCREEN_TEST = 0
  If ScreenTags(#SCREEN_TEST,"foo",#SA_Behind,1,#SA_DisplayID,scrmodeid) = False
    Fail {"Could not open testscreen! (IsRTG())"}
  Else

    *SCR.Screen   = Peek.l(Addr Screen(#SCREEN_TEST))       ; get hold of some structures for OS-calls.
    *VP0.ViewPort = *SCR\ViewPort
    *BM0.BitMap   = *VP0\RasInfo\BitMap

    If GetBitMapAttr_(*BM0,#BMA_FLAGS) AND #BMF_STANDARD    ; check for AGA/RTG
      retval.b = False
    Else
      retval   = True
    EndIf

    Free Screen #SCREEN_TEST                                ; close the testscreen

    Function Return retval

  EndIf

End Function

;-----------------------------------------------------------------
; This is the statement that the smr hook will call.  Put the label before
; the statement you want to jump to.
Runerrsoff ; Important!
hook_jump: ; Do not remove or modify!
Statement smrhook {*dahook.Hook, modeID.l, *smr.ScreenModeRequester}
  ;
  ;
  ;

  SHARED funcret.l

  ;--

  DEFTYPE.DisplayInfo DisInfoBuf
  DEFTYPE.DimensionInfo DimInfoBuf
  DEFTYPE.MonitorInfo MonInfoBuf
  DEFTYPE.NameInfo NamInfoBuf
  ;Refer to Includes/Graphics/DisplayInfo.h or view newtypes

  IDhandle.l = FindDisplayInfo_(modeID)
  GetDisplayInfoData_ IDhandle,&DisInfoBuf,SizeOf.DisplayInfo,#DTAG_DISP,0
  GetDisplayInfoData_ IDhandle,&DimInfoBuf,SizeOf.DimensionInfo,#DTAG_DIMS,0
  GetDisplayInfoData_ IDhandle,&MonInfoBuf,SizeOf.MonitorInfo,#DTAG_MNTR,0
  GetDisplayInfoData_ IDhandle,&NamInfoBuf,SizeOf.NameInfo,#DTAG_NAME,0

  ;Do tests. True = Mode is valid, False = mode is invalid.
  ;See newtypes for DisplayInfo,DimensionInfo,MonitorInfo and NameInfo for things to further test
  If DimInfoBuf\MaxDepth <> 8
    ;No true-colour modes, only 8-bit
    funcret=False
  Else
    MaxX = 320 : MaxY = 256
    If DimInfoBuf\Nominal\MaxX <= MaxX AND DimInfoBuf\Nominal\MaxY <= MaxY
      funcret = True
    Else
      funcret = False
    EndIf
  EndIf

End Statement
Runerrson ; Important!

;--
.
.SetUpScreenMode
Statement SetUpScreenMode{}
  ;
  ; SetupScreenMode() V0.2, Peter Thor
  ;
  ; V1.03 - More errorchecking added, especially since
  ;         problems with using Picasso96 was found
  ;

  SHARED PrefDisplayID.l,PrefDisplayWidth.w,PrefDisplayHeight.w,PrefDisplayDepth.w,funcret.l

  ;--

  DEFTYPE.Hook myhook ; The hook for ASL tag as &myhook
  myhook\h_Entry=?hook
  MOVE.l a5,globalbase
  MOVE.l a4,localbase

  Dim BMIDA_TagItems.TagItem(4-1)
  BMIDA_TagItems(0)\ti_Tag = #BIDTAG_NominalWidth,  320
  BMIDA_TagItems(1)\ti_Tag = #BIDTAG_NominalHeight, 256
  BMIDA_TagItems(2)\ti_Tag = #BIDTAG_Depth,           8
  BMIDA_TagItems(3)\ti_Tag = #TAG_DONE,0

  Dim SMRtags.TagItem(18-1)
  SMRtags(0)\ti_Tag=#ASLSM_InitialLeftEdge,20                     ; X coord of requester
  SMRtags(1)\ti_Tag=#ASLSM_InitialTopEdge,20                      ; Y coord of requester
  SMRtags(2)\ti_Tag=#ASLSM_InitialWidth,250                       ; Width of requester
  SMRtags(3)\ti_Tag=#ASLSM_InitialHeight,180                      ; Height of requester
  SMRtags(4)\ti_Tag=#ASLSM_InitialDisplayID, $21000               ; (Pal:LowRes)
  SMRtags(5)\ti_Tag=#ASLSM_InitialDisplayDepth,8                  ; Default depth (8-bit usually)
  SMRtags(6)\ti_Tag=#ASLSM_InitialDisplayWidth,PrefDisplayWidth
  SMRtags(7)\ti_Tag=#ASLSM_InitialDisplayHeight,PrefDisplayHeight
  SMRtags(8)\ti_Tag=#ASLSM_InitialOverscanType,1                  ; Default overscan type (Text)
  SMRtags(9)\ti_Tag=#ASLSM_InitialInfoOpened,0                    ; Info window?
  SMRtags(10)\ti_Tag=#ASLSM_InitialInfoLeftEdge,270-20            ; X coord of info window
  SMRtags(11)\ti_Tag=#ASLSM_InitialInfoTopEdge,20-20              ; Y coord of info window
  SMRtags(12)\ti_Tag=#ASLSM_DoDepth,0                             ; Depth gadget? (Generally NO for chunky 8-bit)
  SMRtags(13)\ti_Tag=#ASLSM_DoOverscanType,0                      ; Overscan gadget?
  SMRtags(14)\ti_Tag=#ASLSM_DoWidth,0                             ; Width gadget?
  SMRtags(15)\ti_Tag=#ASLSM_DoHeight,0                            ; Height gadget?
  SMRtags(16)\ti_Tag=#ASLSM_FilterFunc,&myhook                    ; Address of callback hook routine
  SMRtags(17)\ti_Tag=#TAG_DONE,0

  ;--

  *sreq.ScreenModeRequester = 0
  *sreq = AllocAslRequest_(#ASL_ScreenModeRequest,&SMRtags(0)\ti_Tag)
  If *sreq = False
    Fail{"Could not AllocAslRequest() (SetupScreenMode())"}
  Else
    res.b = AslRequest_(*sreq,&SMRtags(0)\ti_Tag) = False
    If res = -1                               ; something went wrong or user pressed cancel

      err.l = IoErr_
      Select err

        Case 0                                ; pressed cancel
          Fail{""}                            ; so end nicely

        Case #ERROR_NO_FREE_STORE
          Fail{"Low on memory, filterhook (SetupScreenMode())"}

        Case #ERROR_NO_MORE_ENTRIES
          msg$ = "No suitable displaymodes available (SetupScreenMode())"+Chr$(10)
          msg$ + "Default screenmode should be 320x240x8"+Chr$(10)+Chr$(10)
          msg$ + "Trying to find a suitable screenmode..."+Chr$(10)

          scrmodeid.l = BestModeIDA_(&BMIDA_TagItems(0))
          screenmodename$ = GetScreenModeName {scrmodeid}

          If screenmodename$ <> ""

            ; obtain data from the found mode
            IDhandle.l = FindDisplayInfo_(scrmodeid)
            If GetDisplayInfoData_(IDhandle, &DimensionBuf.DimensionInfo, SizeOf.DimensionInfo, #DTAG_DIMS, 0) = 0
              Fail{msg$+"No DimensionInfo available for monitor!"+Chr$(10)+"Cannot continue!"}
            EndIf
            PrefDisplayID.l     = scrmodeid
            PrefDisplayWidth.w  = DimensionBuf\Nominal\MaxX + 1
            PrefDisplayHeight.w = DimensionBuf\Nominal\MaxY + 1
            PrefDisplayDepth.w  = DimensionBuf\MaxDepth

            msg$ + "Found: "+screenmodename$
            msg$ + " ("+Str$(PrefDisplayWidth)+":"+Str$(PrefDisplayHeight)+":"+Str$(PrefDisplayDepth)+")"+Chr$(10)
            a.l = EasyRequest("Note", msg$, "Run with found screenmode|Cancel")
            If a = 0        ; pressed cancel
              Fail{""}      ; end nicely
            EndIf

          Else
            msg$ + "Found: [None] (Cannot continue)"
            Fail{msg$}
          EndIf

      End Select

    Else                                        ; user selected a mode

      displayid.l = *sreq\sm_DisplayID
      PrefDisplayID.l     = *sreq\sm_DisplayID
      PrefDisplayWidth.w  = *sreq\sm_DisplayWidth
      PrefDisplayHeight.w = *sreq\sm_DisplayHeight
      PrefDisplayDepth.w  = *sreq\sm_DisplayDepth

      If PrefDisplayWidth = 0 OR PrefDisplayHeight = 0 OR PrefDisplayDepth = 0
        ; might be some bug, P96 has shown to give such problems

        oldscreenmodename$ = screenmodename$

        msg$ = "Possible bug with Graphics-software! (GetScreenModeName())"+Chr$(10)
        msg$ + "Report this bug along with your Hardware and software!"+Chr$(10)

        scrmodeid.l = BestModeIDA_(&BMIDA_TagItems(0))
        screenmodename$ = GetScreenModeName {scrmodeid}

        ; obtain data from the found mode
        IDhandle.l = FindDisplayInfo_(scrmodeid)
        If GetDisplayInfoData_(IDhandle, &DimensionBuf.DimensionInfo, SizeOf.DimensionInfo, #DTAG_DIMS, 0) = 0
          Fail{msg$+"No DimensionInfo available for monitor! (SetupScreenMode())"}
        EndIf
        msg$ + "Trying to find suitable screenmode..."+Chr$(10)
        msg$ + "New: "+screenmodename$ + " ("
        msg$ + Str$(DimensionBuf\Nominal\MaxX + 1)+":"
        msg$ + Str$(DimensionBuf\Nominal\MaxY + 1)+":"
        msg$ + Str$(DimensionBuf\MaxDepth)+")"+Chr$(10)+Chr$(10)
        msg$ + "Old: "+oldscreenmodename$+" (320:240:8)"

        a.l = EasyRequest("Note!",msg$,"Use New|Force old|Cancel")

        Select a
          Case 0                              ; cancel
            Fail{""}                          ; end nicely

          Case 1                              ; use new
            PrefDisplayID.l     = scrmodeid
            PrefDisplayWidth.w  = DimensionBuf\Nominal\MaxX + 1
            PrefDisplayHeight.w = DimensionBuf\Nominal\MaxY + 1
            PrefDisplayDepth.w  = DimensionBuf\MaxDepth

          Case 2                              ; use old
            displayid.l         = *sreq\sm_DisplayID
            PrefDisplayID.l     = displayid
            PrefDisplayWidth.w  = 320
            PrefDisplayHeight.w = 240
            PrefDisplayDepth.w  = 8
        End Select

      Else
;        msg$ = "Opening screen: "+Str$(PrefDisplayWidth)+":"+Str$(PrefDisplayHeight)+":"+Str$(PrefDisplayDepth)
;        a.l = EasyRequest("Request",msg$,"Ok|Cancel")
;        If a = 0 Then Fail{""}
      EndIf

    EndIf

    If *sreq Then FreeAslRequest_(*sreq)

  EndIf

  Goto SkipSMR

  ; Hook
  Macro goto_hook
    JSR `1+6
  End Macro

  Runerrsoff ; Important
globalbase: Dc.l 0
localbase:  Dc.l 0
;**********************
hook: ;This hook is called by the filter hook callback from screenmode requester, per item
  ; Store registers
  MOVEM.l   d1-d7/a0-a6,-(a7) ; Not d0!

  ; Put parameters into dregs ready for a statement
  MOVE.l    a0,d0
  MOVE.l    a1,d1
  MOVE.l    a2,d2

  ; Get global variable base
  MOVE.l    globalbase,a5
  MOVE.l    localbase,a4

  ; Goto hook statement
  !goto_hook{hook_jump}

  GetReg d0,funcret ; return accept/discard

  ; Restore registers
  MOVEM.l   (a7)+,d1-d7/a0-a6 ; Not d0!

  RTS
;**********************
  Runerrson
SkipSMR:
End Statement

;--

.OpenDisplay
Function.b OpenDisplay {scrnr.w, winnr.w, mode_db.w, title$}
  ;
  ; OpenDisplay V0.2, Peter Thor
  ;
  ; Tries and open a display
  ;

  SHARED PrefDisplayID.l,PrefDisplayWidth.w,PrefDisplayHeight.w,PrefDisplayDepth.w
  SHARED *VP0.ViewPort
  SHARED *RP0.RastPort
  SHARED *BM0.BitMap
  SHARED IsRTG.b
  SHARED bitmappointers.jbitmap()

  ;--

  If mode_db = #BMODE_DOUBLE AND IsRTG
    height.w = PrefDisplayHeight*2
  Else
    height = PrefDisplayHeight
  EndIf

  Dim ScrTags.TagItem(11)                                 ; fill in whatever you like, check autodocs
  ScrTags(0)\ti_Tag=#SA_Width,      PrefDisplayWidth
  ScrTags(1)\ti_Tag=#SA_Height,     height
  ScrTags(2)\ti_Tag=#SA_Depth,      PrefDisplayDepth
  ScrTags(3)\ti_Tag=#SA_DisplayID,  PrefDisplayID
  ScrTags(4)\ti_Tag=#SA_Type,       $F
  ScrTags(5)\ti_Tag=#SA_Quiet,      0
  ScrTags(6)\ti_Tag=#SA_ShowTitle,  0
  ScrTags(7)\ti_Tag=#SA_Behind,     0
  ScrTags(8)\ti_Tag=#SA_Exclusive,  0
  ScrTags(9)\ti_Tag=#SA_Draggable,  1
  ScrTags(10)\ti_Tag=#SA_BitMap,    0
  If IsRTG = False
    ScrTags(10)\ti_Tag=#SA_BitMap,  Addr BitMap(0)
  EndIf
  ScrTags(11)\ti_Tag=#TAG_DONE,     0

  If ScreenTags(scrnr,title$,&ScrTags(0)) = False
    Function Return False
  Else
    If IsRTG
      If Window(winnr,0,0,PrefDisplayWidth,height,$8,"",0,1) = False
        Function Return False
      Else
        *RP0.RastPort = RastPort(0)
        *BM0 = *RP0\BitMap
      EndIf
    EndIf
    *VP0.ViewPort = ViewPort(0)                         ; find ViewPort addy
    Menus Off                                           ; turn off right mousebutton
    Function Return True                                ; success! =)
  EndIf

End Function

;--

GrabMBitmapFromBitmap
Statement GrabMBitmapFromBitmap {bitmapnr.w, mbitmapnr.w, xstart.w, ystart.w, width.w,height.w}
  ;
  ; GrabMBitmapFromBitmap V0.1, Peter Thor
  ;
  ; Grabs the gfx from a standard blitz-bitmap to a mildred-bitmap
  ;

  Use BitMap bitmapnr
  MUseBitmap mbitmapnr

  If width > -1 AND height > -1                             ; just to make sure
    For y.w = ystart To height-1                                 ; grab pixels from blitz-bitmap to mildred-bitmap
      For x.w = xstart To width-1
        pnt.w = Point(x,y)
        If pnt > -1 Then MPlot x,y,pnt
      Next x
    Next y
  EndIf

End Statement

GrabMShapeFromMBitmap
Statement GrabMShapeFromMBitmap {shapenr.w, mbitmapnr.w, x.w,y.w, width.w,height.w}
  ;
  ; GrabMShapeFromMBitmap V0.1, Peter Thor
  ;
  ; Grabs the a Mildred-Shape from a Mildred-Bitmap
  ;

  MUseBitmap mbitmapnr
  If MShape(shapenr,width,height) = False
    Fail{"Init Shape (Probably low on memory)"}
  EndIf

  MGetaShape shapenr, x.w, y.w, width,height

End Statement


;--
.
.SwitchOutput
Statement SwitchOutput {db.b, mode_db.b}
  ;
  ; SwitchOutput V0.1, Peter Thor
  ;
  ; RTG:
  ;  Will change the base of the y-coordinate a Blit will take into account
  ;  (also known as handle)
  ; AGA:
  ;  Will swap the blitz-bitmap-pointer our MC2P-call will use
  ;

  SHARED IsRTG.b
  SHARED PrefDisplayHeight.w
  SHARED y_blitbasecoord.w

  SHARED *planarbase.l
  SHARED bitmappointers.jbitmap()

  ;--

  If IsRTG                                              ; RTG uses a double-height-window to do doublebuffering
    y_blitbasecoord = PrefDisplayHeight * db
  Else                                                  ; AGA uses two bitmaps, so switch between them
    *planarbase.l = bitmappointers(db)\mem
  EndIf

End Statement

;--

#TESTMODE_WRITECHUNKY = 0
#TESTMODE_BLITBITMAP  = 1

.OutputBitmap
Statement OutputBitmap {db.b, mbitmapnr.w, testmode.b}
  ;
  ; OutputBitmap V0.2, Peter Thor
  ;
  ; RTG: Blits the MBitMap #bitmapnr to a position in the rastport
  ; AGA: C2P-Blits a Blitz-BitMap to bitmapnr
  ;

  SHARED *RP0.RastPort, *BM0.BitMap
  SHARED y_blitbasecoord.w, mode_blit.b, IsRTG.b
  SHARED *planarbase.l

  ;--

  width.w  = MBitmapWidth(mbitmapnr)
  height.w = MBitmapHeight(mbitmapnr)

  If IsRTG                                            ; just a 'fix' - dangerous ;)
    If height <> 240 Then height = 240
  EndIf

  If IsRTG
    Select mode_blit
      Case #WCP
        If testmode = #TESTMODE_BLITBITMAP
          BltBitMapRastPort_ Addr BitMap(mbitmapnr),0,0, *RP0,0,y_blitbasecoord, width,height, $C0
        Else
          WriteChunkyPixels_ *RP0, 0,y_blitbasecoord, width-1,y_blitbasecoord+height-1, MBitmapPtr(mbitmapnr),width
        EndIf
      Case #WPA
        If testmode = #TESTMODE_BLITBITMAP
          BltBitMapRastPort_ Addr BitMap(mbitmapnr),0,0, *RP0,0,y_blitbasecoord, width,height, $C0
        Else
          WritePixelArray_ MBitmapPtr(mbitmapnr),0,0,width,*RP0,0,y_blitbasecoord,width,height,#RECTFMT_LUT8
        EndIf
      Case #WPA8
        If testmode = #TESTMODE_BLITBITMAP
          BltBitMapRastPort_ Addr BitMap(mbitmapnr),0,0, *RP0,0,y_blitbasecoord, width,height, $C0
        Else
          WritePixelArray8_ *RP0, 0,y_blitbasecoord, width-1,y_blitbasecoord+height-1, MBitmapPtr(mbitmapnr),0
        EndIf
    End Select
  Else
    Mc2p MBitmapPtr(mbitmapnr), *planarbase
  EndIf

End Statement

;--

.ShowOutput
Statement ShowOutput {db.b, mode_db.w}
  ;
  ; ShowOutput V0.2, Peter Thor
  ;
  ; RTG:
  ;  Will wait for a vertical-blank and then switch y-position
  ; AGA:
  ;  Uses blitz's ShowBitmap to switch blitz-bitmap
  ;

  SHARED *VP0.ViewPort
  SHARED PrefDisplayHeight.w, IsRTG.b

  ;--

  If IsRTG
    Select mode_db
      Case #BMODE_DOUBLE                              ; doublebuffering
        *VP0\DyOffset = -db*PrefDisplayHeight         ; change ycoordinate in viewport to display
;        WaitTOF_                                      ; wait for vertical blank
        ScrollVPort_ *VP0                             ; and scroll viewport, thus complete the doublebuffer

      Case #BMODE_TRIPLE                              ; triplebuffering - not supported yet

    End Select
  Else                                                ; AGA
    Select mod_db
      Case #BMODE_DOUBLE
        ShowBitMap db                                 ; change bitmap to display, happens instantly

    End Select
  EndIf

End Statement

;--

Statement QBlitMShape {mshapenr.w, mbitmapnr, mqueuenr.w, x.w, y.w}
  ;
  ; QBlitMShape V0.1, Peter Thor
  ;
  ; Just blits a mildred-shape to a mildred-bitmap

  MUseBitmap mbitmapnr
  MQBlit mqueuenr, mshapenr,x,y

End Statement

Statement InitMBitmap {mbitmapnr.w, width.w,height.w}
  ;
  ; InitMBitmap V0.1, Peter Thor
  ;
  ; inits a mildred-bitmap for usage

  If MBitmap(mbitmapnr, width, height) = False
    Fail{"Init MBitmap (Probably low on memory)!"}
  EndIf

End Statement

Statement InitMQueue {mqueuenr.w, queueitems.w}
  ;
  ; InitMQueue V0.1, Peter Thor
  ;
  ; inits a milred-queue

  If MQueue(mqueuenr, queueitems) = alse
    Fail{"Init MQueue (Probably low on memory)!"}
  EndIf

End Statement

Statement CopyMBitmapToMBitmap {sourcembitmap.w, destmbitmap.w, width.w,height.w}
  ;
  ; CopyMBitmap V0.1, Peter Thor
  ;
  ; Will try and copy the graphics from one MBitmap to another MBitmap
  ; NOTE: no errorchecking is done! (I don't care :)
  ;

  MUseBitmap destmbitmap
  MScroll 0,0,width,height,0,0,sourcembitmap

End Statement

;--

Statement JShowPalette {palettnr.b}
  ;
  ; JShowPalette V0.1, Peter Thor
  ;
  ; Will change the palette of a display (same as ShowPalette)
  ;

  SHARED *VP0.ViewPort

  ;--

  LoadRGB32_ *VP0,Peek.l(Addr Palette(palettnr))

End Statement

;*************************************************************************************

  NoCli : WBStartup

  ;--

.
.INITIALIZE

  ; higher buffering than double-buffering not supported yet
  mode_buffering.b = #BMODE_DOUBLE                        ; BufferMode - doublebuffer

  iffname$ = "sourcepic1.iff"                             ; Use this for 320x256x8 AGA!!!!
                                                          ; I do NOT guarantee it will work otherwise...
                                                          ; leave the compiler on and see what happens if you
                                                          ; change to another picture =)
                                                          ; RTG is more tolerant, i've added a little 'fix' in
                                                          ; the blitting routine (OutputBitmap())
                                                          ; to make it look nice on RTG.

  SetUpScreenMode {}                                      ; open a screenmoderequester
  screentitle$ = GetScreenModeName {PrefDisplayID}        ; get the name of the mode
  IsRTG.b = IsRTG {PrefDisplayID}                         ; check for AGA/RTG

  ;--

  If Exist {iffname$} = False                             ; check if file exists
    Fail{"IFF-File does not exists!"}
  EndIf

  ILBMInfo iffname$                                       ; get some dimensions from bitmap
  width.w   = ILBMWidth
  height.w  = ILBMHeight
  depth_.w  = ILBMDepth

  If IsRTG                                                ; RTG
    InitBBitmap {0,width,height, depth_}
  Else                                                    ; AGA
    CNIF #CLOSEWB = #TRUE_
      If CloseWorkbench{} Then wb_closed.b = True         ; try and close workbench
    CEND
    InitBBitmap {0,width,height, depth_}                  ; allocate one bitmap to grab bitmap->chunky
    InitBBitmap {1,width,height, depth_}
    Mc2pWindow #VIEWMC2PWINDOW,width,height
  EndIf

  InitPalette #VIEWPALETTE,2^depth_                       ; load a palette
  LoadBitMap 0,iffname$, #VIEWPALETTE                     ; and load the bitmap

  ;--

  InitMBitmap {#VIEWMBITMAP, width,height}                    ; allocate some mildred-objects
  InitMBitmap {#STOREMBITMAP, width,height}
  InitMQueue  {#VIEWMQUEUE, #MAXSHAPESINQUEUE}

  GrabMBitmapFromBitmap {0, #VIEWMBITMAP, 0,0,width,height}   ; grab a mildred-bitmap from a blitz-bitmap
  CNIF #BLITOBJECTS = #TRUE_
    GrabMShapeFromMBitmap {#VIEWMSHAPE, #VIEWMBITMAP, 80,100,16,16}   ;  grab a mildred-Shape from a mildr d-bitmap
    CopyMBitmapToMBitmap {#VIEWMBITMAP, #STOREMBITMAP, width, height} ; copy the loaded-bitmap to store-bitmap use by MunQueue
    For n = 0 To #MAXSHAPESINQUEUE-1                                  ; init some blocks which fly around
      Blocks(n)\x = Rnd(width-64)+32,Rnd(height-64)+32,(Rnd-.5)*8,(Rnd-.5)*8
    Next
  CEND

  ;--

  If OpenDisplay {#VIEWSCREEN,#VIEWWINDOW, mode_buffering, screentitle$} = False
    Fail{"Opening display (OpenDisplay())"}
  EndIf

  JShowPalette {#VIEWPALETTE}                             ; show our palette

  ;--

  If OpenTimer{} Then timer_open = True
  oldsecs.l  = GetSystemTime {#GST_SECS}
  initsecs.l = oldsecs

;*******************************************************************************************
;*******************************************************************************************
.
.MAINLOOP

  Repeat

    ;--

    If RawStatus($45) Then QUIT.b = True                  ; check for escape-key
    If Joyb(0) = 1 Then QUIT = True                       ; checks for mouseclicks

    If IsRTG                                              ; for RTG, AGA uses no window
      ev.l = Event                                        ; check for Intuition-events
      Select ev
        Case #IDCMP_CLOSEWINDOW
          QUIT = True
      End Select
    EndIf

    ;--                                                   ; do something else

    db.b = 1 - db                                         ; change doublebuffercounter

    If testmode_seconds.b = 1                                         ; RTG change between WriteChunky and BltBitmap
      testmode_db = 1-testmode_db
      testmode = testmode_db
      testmode_seconds = 0
    EndIf

    CNIF #BLITOBJECTS = #TRUE_
      For n = 0 To #MAXSHAPESINQUEUE-1                    ; blit some mildred-shapes
        Blocks(n)\x + Blocks(n)\xs                        ; move blocks
        Blocks(n)\y + Blocks(n)\ys
        If Blocks(n)\x < 32 OR Blocks(n)\x > width  - 32 Then Blocks(n)\xs = -Blocks(n)\xs
        If Blocks(n)\y < 32 OR Blocks(n)\y > height - 32 Then Blocks(n)\ys = -Blocks(n)\ys
        QBlitMShape  {#VIEWMSHAPE, #VIEWMBITMAP, #VIEWMQUEUE, Blocks(n)\x, Blocks(n)\y}
      Next
    CEND

    SwitchOutput  {db, mode_buffering}                    ; switch output-rastport/bitmap (RTG/AGA)
    OutputBitmap  {db, #VIEWMBITMAP, testmode}            ; blit the mbitmap/bitmap in use to the used rastport-part/b
    ShowOutput    {db, mode_buffering}                    ; and show the switced output-"buffer" synced with the vertical-blank

    CNIF #BLITOBJECTS = #TRUE_
      MUnQueue #VIEWMQUEUE, #STOREMBITMAP                 ; restore background the blocks overwrote
    CEND

    ;--

    nrofframes.l + 1
    framecounter.l + 1
    newsecs.l = GetSystemTime {#GST_SECS}
    If newsecs - oldsecs >= 1
      seconds + 1
      testmode_seconds + 1
      If seconds = 8 Then QUIT = True

      If IsRTG
        If testmode = #TESTMODE_WRITECHUNKY
          If (framecounter > fps_rtg_writechunky.q) Then fps_rtg_writechunky = framecounter
          If (framecounter*width*height) > bytes_rtg_writechunky.l Then bytes_rtg_writechunky = framecounter*width*height
        Else
          If (framecounter > fps_rtg_blitbitmap.q) Then fps_rtg_blitbitmap = framecounter
          If (framecounter*width*height) > bytes_rtg_blitbitmap.l Then bytes_rtg_blitbitmap = framecounter*width*height
        EndIf
      Else
        If framecounter > fps_aga Then fps_aga = framecounter
        If (framecounter*width*height) > bytes_aga.l Then bytes_aga = framecounter*width*height
      EndIf

      framecounter = 0
      newsecs.l = GetSystemTime {#GST_SECS}
      oldsecs = newsecs
    EndIf

  Until QUIT

  ;--

  If timer_open Then CloseTimer{}
  msg$ = "Running time :"+Str$(oldsecs-initsecs)+Chr$(10)

  cpu.b=0
  *e.ExecBase = Peek.l(4)
  #AFF_68060=(1 LSL 7)                    ; flag for 060, not  n Blitz includes
  If *e
    If *e\AttnFlags & #AFF_68010          ; gotta do it like this,
      If *e\AttnFlags & #AFF_68020        ; cos each processor has the
        If *e\AttnFlags & #AFF_68030      ; flags of the previous processor
          If *e\AttnFlags & #AFF_68040    ; set, too...
            If *e\AttnFlags & #AFF_68060  ;
              cpu=6
            Else cpu=4
            EndIf
          Else cpu=3
          EndIf
        Else cpu=2
        EndIf
      Else cpu=1
      EndIf
    Else cpu=0
    EndIf
    CPU$ = "0"+Str$(cpu)+"0"
  EndIf

  Select mode_blit
    Case #WCP
      rtg_mode$ = "WCP"
    Case #WPA
      rtg_mode$ = "WPA"
    Case #WPA8
      rtg_mode$ = "WPA8"
  End Select

  If IsRTG
    msg$ + "Bytes/second "+rtg_mode$+"(): "+Str$(bytes_rtg_writechunky)+Chr$(10)
    msg$ + "Bytes/second BlitBitMapRastPort(): "+Str$(bytes_rtg_blitbitmap)+Chr$(10)
    msg$ + "FPS "+rtg_mode$+"(): "+Str$(fps_rtg_writechunky)+Chr$(10)
    msg$ + "FPS BltBitMapRastPort(): "+Str$(fps_rtg_blitbitmap)+Chr$(10)
    msg$ + "Ratio: 1/"+ Str$(fps_rtg_blitbitmap/fps_rtg_writechunky)+Chr$(10)
    filename$ = "Ram:SpeedTest_RTG_"+CPU$+"_"+rtg_mode$+".log"
  Else
    msg$ + "Bytes/second CustomC2P(): "+Str$(bytes_aga)+Chr$(10)
    msg$ + "FPS CustomC2P(): "+Str$(fps_aga)+Chr$(10)
    filename$ = "Ram:SpeedTest_AGA_"+CPU$+".log"
  EndIf
  msg$ + screentitle$ + " ("+Str$(PrefDisplayWidth)+":"+Str$(PrefDisplayHeight)+":"+Str$(PrefDisplayDepth)+")"+Chr$(10)

  CNIF #BLITOBJECTS
    msg$ + "Objects blitted"+Chr$(10)
  CELSE
    msg$ + "Objects not blitted"+Chr$(10)
  CEND

  If WriteFile(0,filename$)
    FileOutput 0
    msg$ + "CPU: 680"+Str$(cpu)+"0"
    Print msg$
    CloseFile 0
  EndIf

  DefaultOutput
  If FromCLI
    NPrint msg$
  Else
    a.l = EasyRequest("Info",msg$,"Quit")
  EndIf

  CNIF #CLOSEWB = #TRUE_
    If wb_closed Then OpenWorkbench {}           ; reopen workbench
  CEND
  Fail {""}

;*******************************************************************************************
