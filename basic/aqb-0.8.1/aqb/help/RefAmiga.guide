@DATABASE
@node MAIN


@{b}                       AQB / Amiga specific commands@{ub}

@{"AREA" link "area"}
@{"AREAFILL" link "areafill"}
@{"AREA OUTLINE" link "area-outline"}
@{"BITMAP FREE" link "bitmap-free"}
@{"BITMAP OUTPUT" link "bitmap-output"}
@{"BITMAP()" link "bitmap()"}
@{"CIRCLE" link "circle"}
@{"COLOR" link "color"}
@{"CLOSE" link "close"}
@{"CLS" link "cls"}
@{"CSRLIN()" link "csrlin()"}
@{"FONT FREE" link "font-free"}
@{"FONT" link "font"}
@{"FONT()" link "font()"}
@{"FONTSTYLE" link "fontstyle"}
@{"FONSTYLE()" link "fonstyle()"}
@{"GET" link "get"}
@{"INKEY$()" link "inkey()"}
@{"INPUT" link "input"}
@{"LINE" link "line"}
@{"LINE INPUT" link "line-input"}
@{"LOCATE" link "locate"}
@{"LOCATE XY" link "locate-xy"}
@{"MOUSE()" link "mouse()"}
@{"MOUSE ( ON | OFF )" link "mouse-(-on--off-)"}
@{"MOUSE MOTION ( ON | OFF )" link "mouse-motion-(-on--off-)"}
@{"ON MOUSE CALL" link "on-mouse-call"}
@{"ON MOUSE MOTION CALL" link "on-mouse-motion-call"}
@{"ON TIMER CALL" link "on-timer-call"}
@{"OPEN" link "open"}
@{"PAINT" link "paint"}
@{"PALETTE" link "palette"}
@{"PATTERN" link "pattern"}
@{"PATTERN RESTORE" link "pattern-restore"}
@{"POS()" link "pos()"}
@{"PRINT" link "print"}
@{"PSET" link "pset"}
@{"PUT" link "put"}
@{"SCREEN" link "screen"}
@{"SCREEN CLOSE" link "screen-close"}
@{"SLEEP" link "sleep"}
@{"SLEEP FOR" link "sleep-for"}
@{"TEXTWIDTH()" link "textwidth()"}
@{"TIMER ON|OFF" link "timer-onoff"}
@{"VWAIT" link "vwait"}
@{"WINDOW" link "window"}
@{"WINDOW CLOSE" link "window-close"}
@{"WINDOW OUTPUT" link "window-output"}
@{"WINDOW()" link "window()"}

@endnode
@node area "AREA"


@{b}AREA@{ub}

Syntax:

  AREA [STEP] (x, y)
  

add a point to an area to be filled

@endnode
@node areafill "AREAFILL"


@{b}AREAFILL@{ub}

Syntax:

  AREAFILL [mode]
  

fill a polygon defined by AREA statements, mode: 0=regular fill, 1=inverted
fill

@endnode
@node area-outline "AREA OUTLINE"


@{b}AREA OUTLINE@{ub}

Syntax:

  AREA OUTLINE ( TRUE | FALSE )
  

enable or disable drawing of AREA polygon outlines

@endnode
@node bitmap-free "BITMAP FREE"


@{b}BITMAP FREE@{ub}

Syntax:

  BITMAP FREE bm
  

free allocated resources for a bitmap

@endnode
@node bitmap-output "BITMAP OUTPUT"


@{b}BITMAP OUTPUT@{ub}

Syntax:

  BITMAP OUTPUT bm
  

redirect drawing commands output to bm

@endnode
@node bitmap() "BITMAP()"


@{b}BITMAP()@{ub}

Syntax:

  BITMAP "(" width, height, depth [ , cont ] ")"
  

allocate an offscreen bitmap buffer. If cont is TRUE, planes will be
allocated in one continous memory space suitable for BOBs.

Example:

  DIM AS BITMAP_t PTR b = BITMAP (64, 64, 2)
  

@endnode
@node circle "CIRCLE"


@{b}CIRCLE@{ub}

Syntax:

  CIRCLE [STEP] "(" x "," y ")" "," r [ "," [color] [ "," [start] [ "," [fini] [ "," ratio ] ] ] ]
  

draw a circle or ellipse.

Arguments:

  * x, y : center coordinates
  * r : radius
  * color : color register to use
  * start, end: start and end angles of ellipse arc
  * aspect ratio of ellipse (rx vs ry radius, default: 0.44)
  

@endnode
@node color "COLOR"


@{b}COLOR@{ub}

Syntax:

  COLOR [ fg ] ["," [bg] ["," [o] [ "," drmd ] ]]
  

set foreground, background, area outline pen and or draw mode.

Useful draw mode values include:

  DRMD_JAM1       = 0
  DRMD_JAM2       = 1 : REM default
  DRMD_COMPLEMENT = 2
  DRMD_INVERSVID  = 4
  

@endnode
@node close "CLOSE"


@{b}CLOSE@{ub}

Syntax:

  CLOSE [ ["#"] expN ( "," ["#"] expM )* ]
  

close one or more files

@endnode
@node cls "CLS"


@{b}CLS@{ub}

Syntax:

  CLS
  

Clear the current output window and set the cursor position to the upper
left corner

@endnode
@node csrlin() "CSRLIN()"


@{b}CSRLIN()@{ub}

Syntax:

  CSRLIN "(" ")"
  

returns the current text row position

@endnode
@node font-free "FONT FREE"


@{b}FONT FREE@{ub}

Syntax:

  FONT FREE font
  

free allocated resources for a font

@endnode
@node font "FONT"


@{b}FONT@{ub}

Syntax:

  FONT font
  

set current font to be used for text output

@endnode
@node font() "FONT()"


@{b}FONT()@{ub}

Syntax:

  FONT "(" name "," size [ "," dir ] ")"
  

load a new font by name and size. If dir is specified the font is loaded
from that directory, otherwise tries to load a system font.

Example:

  DIM AS FONT_t PTR f = FONT ("opal.font", 12)
  

@endnode
@node fontstyle "FONTSTYLE"


@{b}FONTSTYLE@{ub}

Syntax:

  FONTSTYLE style
  

set font soft styling used for text output. style can be any OR combination of

  * FSF_UNDERLINED = 1
  * FSF_BOLD       = 2
  * FSF_ITALIC     = 4
  * FSF_EXTENDED   = 8
  

@endnode
@node fonstyle() "FONSTYLE()"


@{b}FONSTYLE()@{ub}

Syntax:

  FONTSTYLE "(" ")"
  

return the current soft font styling flags.

@endnode
@node get "GET"


@{b}GET@{ub}

Syntax:

  GET [[STEP] "(" x1 "," y1 ")" ] "-" [STEP] "(" x2 "," y2 ")" "," bm
  

copy a rectangular region from current window to a background bitmap
buffer.  See BITMAP() for more information on how to allocate a bitmap. Use
PUT to copy a bitmap back onto the screen.

Example:

  DIM AS BITMAP_t PTR b = BITMAP (64, 64, 2)
  
  GET (0,0)-(63,63), b
  
  PUT (100, 40), b
  

@endnode
@node inkey() "INKEY$()"


@{b}INKEY$()@{ub}

Syntax:

  INKEY$ "(" ")"
  

returns a character entered from the keyboard

Non-ascii key codes:

  * 28 Up cursor
  * 29 Down cursor
  * 30 Right cursor
  * 31 Left cursor
  * 129 F1
  * 130 F2
  * 131 F3
  * 132 F4
  * 133 F5
  * 134 F6
  * 135 F7
  * 136 F8
  * 137 F9
  * 138 F10
  

@endnode
@node input "INPUT"


@{b}INPUT@{ub}

Syntax:

  INPUT [ ";" ] [ prompt (";" | ",") ] expDesignator ( "," expDesignator* )
  

read input from the keyboard, store values in the variables given.

@endnode
@node line "LINE"


@{b}LINE@{ub}

Syntax:

  LINE [[STEP] "(" x1 "," y1 ")" ] "-" [STEP] "(" x2 "," y2 ")" [ "," [color] ["," b[f]] ]
  

draw a line or a box on the current window, "b": A box is drawn, "bf": a
filled box is drawn.  If option STEP is set, coordinates are relative.

@endnode
@node line-input "LINE INPUT"


@{b}LINE INPUT@{ub}

Syntax:

  LINE INPUT [ ";" ] [ stringLiteral ";" ] expDesignator
  

request a STRING keyboard entry from a program user.

@endnode
@node locate "LOCATE"


@{b}LOCATE@{ub}

Syntax:

  LOCATE [ row ] [ "," col ]
  

move cursor to col / row

@endnode
@node locate-xy "LOCATE XY"


@{b}LOCATE XY@{ub}

Syntax:

  LOCATE XY "(" x "," y ")"
  

move cursor to coordinates (x/y)

@endnode
@node mouse() "MOUSE()"


@{b}MOUSE()@{ub}

Syntax:

  MOUSE "(" n ")"
  

return information about the current status of the mouse. Mouse positions
are reported relative to the upper left corner of the current output
window.

Valid values for n:

  * 0: number of times the left mouse button was pressed since the last MOUSE(0) call:
  ** 0: left mouse button was and is not pressed
  ** 1: left mouse button was pressed once but isn't held down now
  ** 2: left mouse button was pressed twice but isn't held down now
  ** -1: left mouse button was pressed once and is still held down
  ** -2: left mouse button was pressed twice and is still held down
  * 1: current mouse X location
  * 2: current mouse Y location
  * 3: mouse X when last time a button was pressed
  * 4: mouse Y when last time a button was pressed
  * 5: mouse X when last time a button was released
  * 6: mouse Y when last time a button was released
  

@endnode
@node mouse-(-on--off-) "MOUSE ( ON | OFF )"


@{b}MOUSE ( ON | OFF )@{ub}

Syntax:

  MOUSE ON
  MOUSE OFF
  

enable or disable mouse button events

@endnode
@node mouse-motion-(-on--off-) "MOUSE MOTION ( ON | OFF )"


@{b}MOUSE MOTION ( ON | OFF )@{ub}

Syntax:

  MOUSE MOTION ON
  MOUSE MOTION OFF
  

enable or disable mouse move events

@endnode
@node on-mouse-call "ON MOUSE CALL"


@{b}ON MOUSE CALL@{ub}

Syntax:

  ON MOUSE CALL sub
  

call sub on left mouse button press and release

@endnode
@node on-mouse-motion-call "ON MOUSE MOTION CALL"


@{b}ON MOUSE MOTION CALL@{ub}

Syntax:

  ON MOUSE MOTION CALL sub
  

call sub when mouse is moved

@endnode
@node on-timer-call "ON TIMER CALL"


@{b}ON TIMER CALL@{ub}

Syntax:

  ON TIMER CALL id, t, sub
  

assign timer #id to call sub every t seconds. After setup
the timer still has to be enabled using the TIMER ON statement.

@endnode
@node open "OPEN"


@{b}OPEN@{ub}

Syntax:

  OPEN filename FOR ( RANDOM | INPUT | OUTPUT | APPEND | BINARY ) [ ACCESS ( READ [WRITE] | WRITE ) ] AS ["#"] f [LEN = rln]
  

open a file for input or output

@endnode
@node paint "PAINT"


@{b}PAINT@{ub}

Syntax:

  PAINT [STEP] "(" x "," y ")" [ "," paintColor [ "," outlineColor ] ]
  

flood fill an enclosed area surrounded by outlineColor with the specified
color

@endnode
@node palette "PALETTE"


@{b}PALETTE@{ub}

Syntax:

  PALETTE n, red, green, blue
  

change the color palette entry for pen number n. The red, green and blue
arguments are be floating point values in the 0.0 ... 1.0 range.

@endnode
@node pattern "PATTERN"


@{b}PATTERN@{ub}

Syntax:

  PATTERN [ lineptrn ] [ "," areaptrn ]
  

change pattern used to draw lines and areas.

  * lineptrn: 16 bit integer that defines the pattern for lines
  * areaptrn: array of 16 bit integers, number of elements must be a power of 2 (1, 2, 4, 8, ...)
  

@endnode
@node pattern-restore "PATTERN RESTORE"


@{b}PATTERN RESTORE@{ub}

Syntax:

  PATTERN RESTORE
  

Restore line and area pattern to default (solid)

@endnode
@node pos() "POS()"


@{b}POS()@{ub}

Syntax:

  POS "(" expression ")"
  

returns the column of the cursor in the current window (expression given is
a dummy value for compatibility reasons, usually 0).

@endnode
@node print "PRINT"


@{b}PRINT@{ub}

Syntax:

  PRINT [ "#" expFNo "," ]  [ expression ( [ ";" | "," ] expression )* ]
  

print the listed expressions to the screen or a file (if expFNo is given). ";" means no space, "," means
skip to next 9 col tab, ";" or "," at the end of the line mean no newline
is printed.

@endnode
@node pset "PSET"


@{b}PSET@{ub}

Syntax:

  PSET [ STEP ] "(" x "," y ")" [ "," color ]
  

set a point in the window

@endnode
@node put "PUT"


@{b}PUT@{ub}

Syntax:

  PUT [[STEP] "(" x "," y ")" ], bm, [minterm [ "," [ "(" x1 "," y1 ")" ] "-" "(" x2 "," y2 ")" ] ]
  

copy a bitmap onto the screen.

Useful minterms:

  * 0x30 Replace destination area with inverted source.
  * 0x50 Replace destination area with an inverted version of itself.
  * 0x80 Only put bits into destination where there is a bit in the same position for both source and destination (sieve operation).
  * 0xC0 Copy from source to destination.
  

Example:

  DIM AS BITMAP_t PTR b = BITMAP (64, 64, 2)
  
  GET (0,0)-(63,63), b
  
  PUT (100, 40), b, &HC0, (20,10)-(40,40)
  

@endnode
@node screen "SCREEN"


@{b}SCREEN@{ub}

Syntax:

  SCREEN screen-id, width, height, depth, mode [, title]
  

create a new screen

mode is a combination of:

  * AS_MODE_GENLOCK_VIDEO   = &H0002
  * AS_MODE_LACE            = &H0004
  * AS_MODE_DOUBLESCAN      = &H0008
  * AS_MODE_SUPERHIRES      = &H0020
  * AS_MODE_PFBA            = &H0040
  * AS_MODE_EXTRA_HALFBRITE = &H0080
  * AS_MODE_GENLOCK_AUDIO   = &H0100
  * AS_MODE_DUALPF          = &H0400
  * AS_MODE_HAM             = &H0800
  * AS_MODE_EXTENDED_MODE   = &H1000
  * AS_MODE_VP_HIDE         = &H2000
  * AS_MODE_SPRITES         = &H4000
  * AS_MODE_HIRES           = &H8000
  

@endnode
@node screen-close "SCREEN CLOSE"


@{b}SCREEN CLOSE@{ub}

Syntax:

  SCREEN CLOSE id
  

close screen indicated by id

@endnode
@node sleep "SLEEP"


@{b}SLEEP@{ub}

Syntax:

  SLEEP
  

Suspend program until next event occurs.

@endnode
@node sleep-for "SLEEP FOR"


@{b}SLEEP FOR@{ub}

Syntax:

  SLEEP FOR seconds
  

Suspend program for the specified number of seconds (floating point value,
so fractions of seconds are supported).

@endnode
@node textwidth() "TEXTWIDTH()"


@{b}TEXTWIDTH()@{ub}

Syntax:

  TEXTWIDTH "(" s ")"
  

Returns the width of s in pixels, taking the current font into account.

@endnode
@node timer-onoff "TIMER ON|OFF"


@{b}TIMER ON|OFF@{ub}

Syntax:

  TIMER (ON|OFF) id
  

Enable or disable events from timer #id

@endnode
@node vwait "VWAIT"


@{b}VWAIT@{ub}

Syntax:

  VWAIT
  

Wait for vertical blank to occur

@endnode
@node window "WINDOW"


@{b}WINDOW@{ub}

Syntax:

  WINDOW id [ "," [ title ] [ "," [ "(" x1 "," y1 ")" "-" "(" x2 "," y2 ")" ] [ "," [flags] [ "," screen-id ]]]]
  

Create and activate a new window, make it the new output window.

flags is an OR combination of:

  * AW_FLAG_SIZEGADGET     = &H00000001
  * AW_FLAG_DRAGBAR        = &H00000002
  * AW_FLAG_DEPTHGADGET    = &H00000004
  * AW_FLAG_CLOSEGADGET    = &H00000008
  * AW_FLAG_SIZEBRIGHT     = &H00000010
  * AW_FLAG_SIZEBBOTTOM    = &H00000020
  * AW_FLAG_REFRESHBITS    = &H000000C0
  * AW_FLAG_SMART_REFRESH  = &H00000000
  * AW_FLAG_SIMPLE_REFRESH = &H00000040
  * AW_FLAG_SUPER_BITMAP   = &H00000080
  * AW_FLAG_OTHER_REFRESH  = &H000000C0
  * AW_FLAG_BACKDROP       = &H00000100
  * AW_FLAG_REPORTMOUSE    = &H00000200
  * AW_FLAG_GIMMEZEROZERO  = &H00000400
  * AW_FLAG_BORDERLESS     = &H00000800
  * AW_FLAG_ACTIVATE       = &H00001000
  * AW_FLAG_RMBTRAP        = &H00010000
  * AW_FLAG_NOCAREREFRESH  = &H00020000
  * AW_FLAG_NW_EXTENDED    = &H00040000
  * AW_FLAG_NEWLOOKMENUS   = &H00200000
  

default flags: AW_FLAG_SIZEGADGET OR AW_FLAG_DRAGBAR OR AW_FLAG_DEPTHGADGET OR AW_FLAG_CLOSEGADGET OR AW_FLAG_SMART_REFRESH OR AW_FLAG_GIMMEZEROZERO OR AW_FLAG_ACTIVATE

@endnode
@node window-close "WINDOW CLOSE"


@{b}WINDOW CLOSE@{ub}

Syntax:

  WINDOW CLOSE id
  

close window indicated by id.

@endnode
@node window-output "WINDOW OUTPUT"


@{b}WINDOW OUTPUT@{ub}

Syntax:

  WINDOW OUTPUT id
  

make window indicated by id the current output window.

@endnode
@node window() "WINDOW()"


@{b}WINDOW()@{ub}

Syntax:

  WINDOW "(" n ")"
  

return information about a window. n is one of

  *  0: current active window id
  *  1: current output window id
  *  2: current output window width
  *  3: current output window height
  *  4: current output cursor X
  *  5: current output cursor Y
  *  6: highest color index
  *  7: pointer to current intuition output window
  *  8: pointer to current rastport
  *  9: output file handle
  * 10: foreground pen
  * 11: background pen
  * 12: text width
  * 13: text height
  * 14: input file handle
  

@endnode
@node navidx "Index"


 * @{"Start" link "README.guide/main"}

 * @{"Reference: Core" link "help/RefCore.guide/main"}
 * @{"Reference: Amiga specific commands" link "help/RefAmiga.guide/main"}
 * @{"Reference: IFFSupport module" link "help/IFFSupport.guide/main"}
 * @{"Reference: AnimSupport module" link "help/AnimSupport.guide/main"}
@endnode
@index navidx

