@DATABASE
@node MAIN


@{b}                               Core Language@{ub}

@{"ACOS()" link "acos()"}
@{"AND" link "and"}
@{"ALLOCATE()" link "allocate()"}
@{"ASC()" link "asc()"}
@{"ASSERT" link "assert"}
@{"ASIN()" link "asin()"}
@{"ATN()" link "atn()"}
@{"BREAK" link "break"}
@{"CALL" link "call"}
@{"CAST()" link "cast()"}
@{"CHR$()" link "chr()"}
@{"CINT()" link "cint()"}
@{"CONST" link "const"}
@{"CONTINUE" link "continue"}
@{"COS()" link "cos()"}
@{"DATA" link "data"}
@{"DEALLOCATE" link "deallocate"}
@{"DECLARE FUNCTION|SUB" link "declare-functionsub"}
@{"DEFINT" link "defint"}
@{"DEFLNG" link "deflng"}
@{"DEFSNG" link "defsng"}
@{"DEFSTR" link "defstr"}
@{"DIM" link "dim"}
@{"DO ... LOOP" link "do--loop"}
@{"END" link "end"}
@{"EQV" link "eqv"}
@{"ERASE" link "erase"}
@{"ERR" link "err"}
@{"ERROR" link "error"}
@{"EXIT" link "exit"}
@{"EXP()" link "exp()"}
@{"FIX()" link "fix()"}
@{"FOR ... NEXT" link "for--next"}
@{"FREE()" link "free()"}
@{"GOTO" link "goto"}
@{"GOSUB" link "gosub"}
@{"IF ... THEN" link "if--then"}
@{"IMPORT" link "import"}
@{"INT()" link "int()"}
@{"LBOUND()" link "lbound()"}
@{"LEN()" link "len()"}
@{"LET" link "let"}
@{"LOG()" link "log()"}
@{"LOOP" link "loop"}
@{"_MEMSET" link "memset"}
@{"MOD" link "mod"}
@{"NEXT" link "next"}
@{"NOT" link "not"}
@{"ON ERROR" link "on-error"}
@{"ON BREAK" link "on-break"}
@{"OPTION BREAK" link "option-break"}
@{"OPTION DEBUG" link "option-debug"}
@{"OPTION EXPLICIT" link "option-explicit"}
@{"OPTION PRIVATE" link "option-private"}
@{"PEEK()" link "peek()"}
@{"PEEKW()" link "peekw()"}
@{"PEEKL()" link "peekl()"}
@{"POKE" link "poke"}
@{"POKEW" link "pokew"}
@{"POKEL" link "pokel"}
@{"RANDOMIZE" link "randomize"}
@{"READ" link "read"}
@{"REDIM" link "redim"}
@{"RESTORE" link "restore"}
@{"RETURN" link "return"}
@{"RND()" link "rnd()"}
@{"SELECT CASE" link "select-case"}
@{"SIN()" link "sin()"}
@{"SIZEOF()" link "sizeof()"}
@{"SQR()" link "sqr()"}
@{"STATIC" link "static"}
@{"STR$()" link "str()"}
@{"SYSTEM" link "system"}
@{"TAN()" link "tan()"}
@{"TIMER()" link "timer()"}
@{"TRACE" link "trace"}
@{"TYPE (UDT alias)" link "type-(udt-alias)"}
@{"TYPE (UDT record)" link "type-(udt-record)"}
@{"UBOUND()" link "ubound()"}
@{"VAL()" link "val()"}
@{"VALINT()" link "valint()"}
@{"VALUINT()" link "valuint()"}
@{"VALLNG()" link "vallng()"}
@{"VALULNG()" link "valulng()"}
@{"VARPTR()" link "varptr()"}
@{"WHILE ... WEND" link "while--wend"}
@{"WEND" link "wend"}

@endnode
@node acos() "ACOS()"


@{b}ACOS()@{ub}

Syntax:

  ACOS "(" a ")"
  

obtain the arccosine of the floating point number

@endnode
@node and "AND"


@{b}AND@{ub}

Syntax:

  expr1 AND expr2
  

logical conjunction of expr1 and expr2

@endnode
@node allocate() "ALLOCATE()"


@{b}ALLOCATE()@{ub}

Syntax:

  ALLOCATE "(" size [ "," flags ] ")"
  

Try to allocate size number of bytes of memory, return pointer to allocated memory block if ok, NULL otherwise.

Flags is a combination of
* 0 MEMF_ANY
* 1 MEMF_PUBLIC
* 2 MEMF_CHIP
* 4 MEMF_FAST
* 256 MEMF_LOCAL
* 512 MEMF_24BITDMA
* 1024 MEMF_KICK
* 65536 MEMF_CLEAR

@endnode
@node asc() "ASC()"


@{b}ASC()@{ub}

Syntax:

  ASC "(" expr ")"
  

return the ascii code of the first character in the given string

@endnode
@node assert "ASSERT"


@{b}ASSERT@{ub}

Syntax:

  ASSERT expr
  

raise an error message including line number information if the given
expression evaluates to FALSE.

@endnode
@node asin() "ASIN()"


@{b}ASIN()@{ub}

Syntax:

  ASIN "(" a ")"
  

obtain the arcsine of the floating point number

@endnode
@node atn() "ATN()"


@{b}ATN()@{ub}

Syntax:

  ATN "(" a ")"
  

obtain the arctangent of the floating point number

@endnode
@node break "BREAK"


@{b}BREAK@{ub}

Syntax:

  BREAK
  

insert a debug breakpoint here

@endnode
@node call "CALL"


@{b}CALL@{ub}

Syntax:

  CALL ( subCall | expDesignator )
  

call a SUB or FUNCTION.

@endnode
@node cast() "CAST()"


@{b}CAST()@{ub}

Syntax:

  CAST "(" typedesc "," expr ")
  

casts an expression to a different data type

@endnode
@node chr() "CHR$()"


@{b}CHR$()@{ub}

Syntax:

  CHR$ "(" expr ")"
  

returns a string containing the single character associated with the given
character code

@endnode
@node cint() "CINT()"


@{b}CINT()@{ub}

Syntax:

  CINT "(" x ")"
  

convert x to an integer by rounding the fractional portion

@endnode
@node const "CONST"


@{b}CONST@{ub}

Syntax A:

  [ PUBLIC | PRIVATE ] CONST id1 [AS type] "=" expr [ "," id2 [AS type] "=" expr [ "," ...]]
  

Syntax B:

  [ PUBLIC | PRIVATE ] CONST AS type id1 "=" expr [ "," id2 "=" expr [ "," ...]]
  

declare constants

@endnode
@node continue "CONTINUE"


@{b}CONTINUE@{ub}

Syntax:

  CONTINUE [ ( DO | FOR | WHILE ) ]
  

continue next iteration of a loop

@endnode
@node cos() "COS()"


@{b}COS()@{ub}

Syntax:

  COS "(" a ")"
  

obtain the cosine of the floating point number

@endnode
@node data "DATA"


@{b}DATA@{ub}

Syntax:

  DATA literal ( "," literal )*
  

add values to the data section of the program. Those values can be later
READ by the program at runtime.

@endnode
@node deallocate "DEALLOCATE"


@{b}DEALLOCATE@{ub}

Syntax:

  DEALLOCATE ptr
  

free memory that was allocated at ptr

@endnode
@node declare-functionsub "DECLARE FUNCTION|SUB"


@{b}DECLARE FUNCTION|SUB@{ub}

Syntax:

  [ PRIVATE | PUBLIC ] DECLARE procHeader [ LIB exprOffset identLibBase "(" [ ident ( "," ident)* ] ")"
  

Forward declare a SUB or FUNCTION. When the LIB portion of this command is
used, an OS library function is declared.

@endnode
@node defint "DEFINT"


@{b}DEFINT@{ub}

Syntax:

  DEFINT letter [ "-" letter ] ( "," letter [ "-" letter ] )*
  

define all variables with names starting with the specified letter (or
letter range) as INTEGER

@endnode
@node deflng "DEFLNG"


@{b}DEFLNG@{ub}

Syntax:

  DEFLNG letter [ "-" letter ] ( "," letter [ "-" letter ] )*
  

define all variables with names starting with the specified letter (or
letter range) as LONG

@endnode
@node defsng "DEFSNG"


@{b}DEFSNG@{ub}

Syntax:

  DEFSNG letter [ "-" letter ] ( "," letter [ "-" letter ] )*
  

define all variables with names starting with the specified letter (or
letter range) as SINGLE

@endnode
@node defstr "DEFSTR"


@{b}DEFSTR@{ub}

Syntax:

  DEFSTR letter [ "-" letter ] ( "," letter [ "-" letter ] )*
  

define all variables with names starting with the specified letter (or
letter range) as STRING

@endnode
@node dim "DIM"


@{b}DIM@{ub}

Syntax A:

  [ PUBLIC | PRIVATE ] DIM [ SHARED ] var1 [ "(" arrayDimensions ")" ] AS type [ "=" expr ] [ "," var2 ...]
  

Syntax B:

  [ PUBLIC | PRIVATE ] DIM [ SHARED ] AS type var1 [ "(" arrayDimensions ")" ] [ "=" expr ] [ "," var2 ... ]
  

declare variables

Examples:

  DIM f AS SINGLE                          : REM traditional QBasic Syntax
  DIM SHARED g AS UBYTE                    : REM shared variable
  
  DIM AS ULONG l1, l2                      : REM declare multiple variables of the same type
  
  DIM AS INTEGER a (9, 1)                  : REM 2D dynamic array
  DIM AS INTEGER b (STATIC 9, 1)           : REM 2D static, C-like array
  
  DIM p AS INTEGER PTR                     : REM pointer
  
  DIM fp AS FUNCTION (INTEGER) AS INTEGER  : REM function pointer
  

static arrays are much faster than dynamic arrays but offer no runtime
bounds checking

@endnode
@node do--loop "DO ... LOOP"


@{b}DO ... LOOP@{ub}

Syntax A:

  DO [ ( UNTIL | WHILE ) expression ]
      <code>
  LOOP
  

Syntax B:

  DO
      <code>
  LOOP [ ( UNTIL | WHILE ) expression ]
  

generic loop, loops until or while the given expression evaluates to TRUE.
Expression test can either happen at the beginning or end of loop depending
on the syntax used. If no UNTIL/WHILE clause is given, this will create an
endless loop (which can still be exited from within the loop body using the
EXIT statement).

@endnode
@node end "END"


@{b}END@{ub}

Syntax:

  END
  

exit the program (same as SYSTEM)

@endnode
@node eqv "EQV"


@{b}EQV@{ub}

Syntax:

  expr1 EQV expr2
  

logic equivalence of expr1 and expr2

@endnode
@node erase "ERASE"


@{b}ERASE@{ub}

Syntax:

  ERASE arrayName [ "," arrayName2 ...]
  

Free the allocated memory for each dynamic array listed.

@endnode
@node err "ERR"


@{b}ERR@{ub}

Syntax:

  ERR : REM public variable
  

public variable that contains the last error number.

@endnode
@node error "ERROR"


@{b}ERROR@{ub}

Syntax:

  ERROR n
  

raise error code n, exits the program unless a corresponding handler is
registered using the ON ERROR ... statement. ERR is set to the error number
specified when calling the error handler.

@endnode
@node exit "EXIT"


@{b}EXIT@{ub}

Syntax:

  EXIT ( SUB | FUNCTION | DO | FOR | WHILE | SELECT ) [ "," ( SUB | ... ) ... ]
  

exits a DO, WHILE or FOR loop, a FUNCTION or a SUB procedure, or a SELECT
statement.

@endnode
@node exp() "EXP()"


@{b}EXP()@{ub}

Syntax:

  EXP "(" a ")"
  

obtain the exponential of the floating point number

@endnode
@node fix() "FIX()"


@{b}FIX()@{ub}

Syntax:

  FIX "(" x ")"
  

return the truncated integer part of x

@endnode
@node for--next "FOR ... NEXT"


@{b}FOR ... NEXT@{ub}

Syntax:

  FOR id [ AS type ] "=" expr TO expr [ STEP expr ]
      <code>
  NEXT [ id1 [ "," id2 [ "," ...] ] ]
  

counter loop using specified start and stop numerical boundaries, default
increment is 1

@endnode
@node free() "FREE()"


@{b}FREE()@{ub}

Syntax:

  FREE "(" x ")"
  

.Table x values
|===
|Value | Description

|-2
|stack size

|-1
|chip + fast mem

|0
|chip mem

|1
|fast mem

|2
|largest chip mem

|3
|largest fast mem

|===

@endnode
@node goto "GOTO"


@{b}GOTO@{ub}

Syntax:

  GOTO ( num | ident )
  

jump a line label or a line number in the program

@endnode
@node gosub "GOSUB"


@{b}GOSUB@{ub}

Syntax:

  GOSUB ( num | ident )
  

jump to a subroutine at line label or a line number in the program

@endnode
@node if--then "IF ... THEN"


@{b}IF ... THEN@{ub}

Syntax A:

  IF expr ( GOTO ( numLiteral | ident ) [ ( ELSE numLiteral | Statement* ) ]
          | THEN ( numLiteral | Statement*) [ ( ELSE numLiteral | Statement* ) ]
          )
  

Syntax B:

  IF expr THEN
      <code>
  ( ELSEIF expr THEN
      <code> )*
  [ ELSE
      <code> ]
  ( END IF | ENDIF )
  

executes a statement or statement block depending on specified conditions.

@endnode
@node import "IMPORT"


@{b}IMPORT@{ub}

Syntax:

  IMPORT id
  

import a module

@endnode
@node int() "INT()"


@{b}INT()@{ub}

Syntax:

  INT "(" x ")"
  

return the largest integer less than or equal to x

@endnode
@node lbound() "LBOUND()"


@{b}LBOUND()@{ub}

Syntax:

  LBOUND "(" array [ "," dimension ] ")"
  

Return the lower bound for the given array dimension.

@endnode
@node len() "LEN()"


@{b}LEN()@{ub}

Syntax:

  LEN "(" s ")"
  

return the length of string s in characters.

@endnode
@node let "LET"


@{b}LET@{ub}

Syntax:

  LET expDesignator "=" expression
  

assign the value of an expression to a variable or designator. The LET
keyword is optional.

@endnode
@node log() "LOG()"


@{b}LOG()@{ub}

Syntax:

  LOG "(" l ")"
  

obtain the natural logarithm of the floating point number

@endnode
@node loop "LOOP"


@{b}LOOP@{ub}

see DO...LOOP

@endnode
@node memset "_MEMSET"


@{b}_MEMSET@{ub}

Syntax:

  _MEMSET "(" dst "," c "," n ")"
  

set n bytes of memory to c starting from dst

@endnode
@node mod "MOD"


@{b}MOD@{ub}

Syntax:

  expr1 MOD expr2
  

modulus operation on expr1 and expr2.

@endnode
@node next "NEXT"


@{b}NEXT@{ub}

see FOR

@endnode
@node not "NOT"


@{b}NOT@{ub}

Syntax:

  NOT expr
  

return logical not of expr

@endnode
@node on-error "ON ERROR"


@{b}ON ERROR@{ub}

Syntax:

  ON ERROR CALL handler
  

call SUB program handler when an error occurs.

@endnode
@node on-break "ON BREAK"


@{b}ON BREAK@{ub}

Syntax:

  ON BREAK CALL handler
  

call SUB program handler when CTRL-C is detected. The handler may call
RESUME NEXT to ignore the CTRL-C signal.

@endnode
@node option-break "OPTION BREAK"


@{b}OPTION BREAK@{ub}

Syntax:

  OPTION BREAK [ ( ON | OFF ) ]
  

instructs the compiler to add checks for CTRL-C/D in loops, subprogram
calls so programs can be interrupted when they run into an endless loop or
recursion. Enabled by default, disable to gain a bit of performance.

@endnode
@node option-debug "OPTION DEBUG"


@{b}OPTION DEBUG@{ub}

Syntax:

  OPTION DEBUG [ ( ON | OFF ) ]
  

instructs the compiler to generate debug code (i.e. DPRINT etc.) or not

@endnode
@node option-explicit "OPTION EXPLICIT"


@{b}OPTION EXPLICIT@{ub}

Syntax:

  OPTION EXPLICIT [ ( ON | OFF ) ]
  

instructs the compiler to require variable declaration

@endnode
@node option-private "OPTION PRIVATE"


@{b}OPTION PRIVATE@{ub}

Syntax:

  OPTION PRIVATE [ ( ON | OFF ) ]
  

make declared variables, types, functions and subprograms private (not
exported) by default

@endnode
@node peek() "PEEK()"


@{b}PEEK()@{ub}

Syntax:

  PEEK "(" address ")"
  

return a byte from memory at the specified address

@endnode
@node peekw() "PEEKW()"


@{b}PEEKW()@{ub}

Syntax:

  PEEKW "(" address ")"
  

return a word (16 bits) from memory at the specified address

@endnode
@node peekl() "PEEKL()"


@{b}PEEKL()@{ub}

Syntax:

  PEEK "(" address ")"
  

return a long (32 bits) from memory at the specified address

@endnode
@node poke "POKE"


@{b}POKE@{ub}

Syntax:

  POKE address, value
  

store byte value at the specified memory address

@endnode
@node pokew "POKEW"


@{b}POKEW@{ub}

Syntax:

  POKEW address, value
  

store word (16 bits) value at the specified memory address

@endnode
@node pokel "POKEL"


@{b}POKEL@{ub}

Syntax:

  POKEL address, value
  

store long (32 bits) value at the specified memory address

@endnode
@node randomize "RANDOMIZE"


@{b}RANDOMIZE@{ub}

Syntax:

  RANDOMIZE seed
  

re-initialize the built-in pseudo random number generator to the
given seed.

@endnode
@node read "READ"


@{b}READ@{ub}

Syntax:

  READ varDesignator ( "," varDesignator )*
  

read values from the DATA section and assign them to one or more variables

@endnode
@node redim "REDIM"


@{b}REDIM@{ub}

Syntax:

  REDIM [PRESERVE] [SHARED] arrayId ([[lbound TO] ubound [ "," ...]]) [ AS datatype ] [, ...]
  

declare or resize a dynamic array. Previous values are erased unless the
PRESERVE keyword is specified.

@endnode
@node restore "RESTORE"


@{b}RESTORE@{ub}

Syntax:

  RESTORE [ dataLabel ]
  

restore data read pointer to the specified label, if no label is specified,
restore read pointer to the first data statement.

@endnode
@node return "RETURN"


@{b}RETURN@{ub}

Syntax:

  RETURN [ expr ]
  

return from a subroutine or function. In case of return from a function,
expr specifies the return value

@endnode
@node rnd() "RND()"


@{b}RND()@{ub}

Syntax:

  RND ([n])
  

returns a random number with a value between 0 (inclusive) and 1
(exclusive).

  * n = 0: return the last value returned
  * n < 0: reset the pseudo random number generator to the built-in seed
  * n > 0: the sequence of numbers generated will not change unless RANDOMIZE
is initiated
@endnode
@node select-case "SELECT CASE"


@{b}SELECT CASE@{ub}

Syntax:

  SELECT CASE expr
  
  CASE caseExpr ( "," caseExpr2 )*
    statements1
  
  [ CASE caseExpr3 ( "," caseExpr4 )*
    statements2 ]
  
  ...
  
  [ CASE ELSE
    statementsN ]
  
  END SELECT
  

determine the program flow by comparing the value of an expression to
specific CASE values

Case Expression syntax:

  ( expression [ TO expression ]
  | IS ( '=' | '>' | '<' | '<>' | '<=' | '>=' ) expression )
  

@endnode
@node sin() "SIN()"


@{b}SIN()@{ub}

Syntax:

  SIN "(" a ")
  

obtain the sine of the floating point number

@endnode
@node sizeof() "SIZEOF()"


@{b}SIZEOF()@{ub}

Syntax:

  SIZEOF "(" ident ")
  

Returns the memory size in bytes of a given variable or named type

@endnode
@node sqr() "SQR()"


@{b}SQR()@{ub}

Syntax:

  SQR "(" x ")"
  

obtain the square root of the floating point number

@endnode
@node static "STATIC"


@{b}STATIC@{ub}

Syntax A:

  STATIC Identifier AS TypeIdentifier [ "(" arrayDimensions ")" ] [ "=" expr] ( "," Indetifier2 AS ... )*
  

Syntax B:

  STATIC AS TypeIdentifier [ "(" arrayDimensions ")" ] Identifier [ "=" expr] ( "," Identifier2 ... )*
  

declare variable(s) as static.

@endnode
@node str() "STR$()"


@{b}STR$()@{ub}

Syntax:

  STR$ "(" expr ")"
  

return a string representation (the same one that is used in PRINT output)
of a given numeric expression

@endnode
@node system "SYSTEM"


@{b}SYSTEM@{ub}

Syntax:

  SYSTEM
  

exit the program (same as END)

@endnode
@node tan() "TAN()"


@{b}TAN()@{ub}

Syntax:

  TAN "(" a ")"
  

obtain the tangent of the floating point number

@endnode
@node timer() "TIMER()"


@{b}TIMER()@{ub}

Syntax:

  TIMER "(" ")"
  

returns the number of seconds past the previous midnite as a SINGLE float
value

@endnode
@node trace "TRACE"


@{b}TRACE@{ub}

Syntax:

  TRACE [ expression ( [ ";" | "," ] expression )* ]
  

print the listed expressions to the debug console. ";" means no space, "," means
skip to next 9 col tab, ";" or "," at the end of the line mean no newline
is printed.

@endnode
@node type-(udt-alias) "TYPE (UDT alias)"


@{b}TYPE (UDT alias)@{ub}

Syntax:

  TYPE ident AS typedesc [ "(" arrayDimensions ")" ]
  

Example:

  TYPE a_t AS INTEGER (STATIC 9)
  

declares a new named UDT

@endnode
@node type-(udt-record) "TYPE (UDT record)"


@{b}TYPE (UDT record)@{ub}

Syntax:

  TYPE ident
  
    [PRIVATE:|PUBLIC:|PROTECTED:]
    var [ "(" arrayDimensions ")" ] AS typedesc
    AS typedesc var [ "(" arrayDimensions ")" ]
    DECLARE (SUB|FUNCTION|CONSTRUCTOR) ...
    ...
  
  END TYPE
  

declares a new record UDT

@endnode
@node ubound() "UBOUND()"


@{b}UBOUND()@{ub}

Syntax:

  UBOUND "(" array [ "," dimension ] ")"
  

Return the upper bound for the given array dimension.

@endnode
@node val() "VAL()"


@{b}VAL()@{ub}

Syntax:

  VAL "(" str ")"
  

return the floating-point representation of the given string argument str.

@endnode
@node valint() "VALINT()"


@{b}VALINT()@{ub}

Syntax:

  VALINT "(" str ")"
  

return the integer representation of the given string argument str.

@endnode
@node valuint() "VALUINT()"


@{b}VALUINT()@{ub}

Syntax:

  VALUINT "(" str ")"
  

return the unsigned integer representation of the given string argument
str.

@endnode
@node vallng() "VALLNG()"


@{b}VALLNG()@{ub}

Syntax:

  VALLNG "(" str ")"
  

return the long representation of the given string argument str.

@endnode
@node valulng() "VALULNG()"


@{b}VALULNG()@{ub}

Syntax:

  VALULNG "(" str ")"
  

return the unsigned long representation of the given string argument str.

@endnode
@node varptr() "VARPTR()"


@{b}VARPTR()@{ub}

Syntax:

  VARPTR "(" designator ")"
  

returns the address of a variable

@endnode
@node while--wend "WHILE ... WEND"


@{b}WHILE ... WEND@{ub}

Syntax:

  WHILE expression
      <code>
  WEND
  

repeat loop body while expression evaluates to TRUE

@endnode
@node wend "WEND"


@{b}WEND@{ub}

see WHILE ... WEND

@endnode
@node navidx "Index"


 * @{"Start" link "README.guide/main"}

 * @{"Reference: Core" link "help/RefCore.guide/main"}
 * @{"Reference: Amiga specific commands" link "help/RefAmiga.guide/main"}
 * @{"Reference: IFFSupport module" link "help/IFFSupport.guide/main"}
 * @{"Reference: AnimSupport module" link "help/AnimSupport.guide/main"}
@endnode
@index navidx

