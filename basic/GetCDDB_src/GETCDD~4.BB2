;GetCDDB_BigFunc.bb2

INCDIR "misc:data_/data/blitz_projects/getcddb/"
XINCLUDE GetCDDB_CDFuncs.bb2
XINCLUDE GetCDDB_TCPFuncs.bb2
XINCLUDE GetCDDB_ParseFuncs.bb2
XINCLUDE GetCDDB_Consts.bb2

Function.b GetCDDB{email$,scsidev$,scsiid,cdplayer$,genre$}

SHARED discpath$
SHARED TOCCDID$
SHARED overwrite.b

server$="cddb.cddb.com"
cddbfile$="t:cddb.tmp"
cdplayer$="optycdplayer"

If Len(email$)<3 OR Instr(email$,"@")=0 OR Len(scsidev$)=0
  ErrorReq{"Invalid email or device"}
  Function Return #_ARGS_ERROR
EndIf

SetStatus{"Opening device..."}

If InitCDDA{}=0
  ErrorReq{"Unable to open CD"}
  Function Return #_CD_ERROR
EndIf

SetStatus{"Reading CD contents..."}

If CDDAReadContents{}
  ErrorReq{"Unable to read CD contents"}
  EndingCDDA{}
  Function Return #_CD_ERROR
EndIf


If Exists(discpath$+TOCCDID$) AND overwrite.b=0
  EndingCDDA{}
  Function Return -1
EndIf

SocketBase.l=OpenLibrary_("bsdsocket.library",0)
If SocketBase.l
  TCPenabled.b=-1
  CloseLibrary_(SocketBase)
Else
  TCPenabled=0
EndIf


SetStatus{"Calculating disc id..."}

discid$=ComputeCDDBDiscId{}

EndingCDDA{}

  Dim stored_ids$(100)
  Dim stored_genres$(100)

;If NOT TCPenabled.b ;miami not running
;  If OpenFile(0,ProgsDir{}+"getcddb.ids")
;    FileOutput 0
;    NPrint discid$
;    NPrint genre$
;    CloseFile 0
;  Else
;    ErrorReq{"Unable to open getcddb.ids for writing"}
;    Function Return #_WRITE_ERROR
;  EndIf
;  Function Return #_TCP_ERROR
;Else
;;  miami is running
;  ids.b=1
;  If ReadFile(0,ProgsDir{}+"getcddb.ids")
;    FileInput 0
;    Repeat
;      stored_ids$(ids.b)=Edit$(80)
;      stored_genres$(ids.b)=Edit$(80)
;      ids+1
;    Until Eof(0) OR ids.b=99
;  EndIf
;EndIf

stored_ids$(0)=discid$
stored_genres$(0)=genre$
ids.b=0

Dim genrelist$(100)

genrelist$(0)=genre$
maxgenre.b=1

If OpenFile(0,ProgsDir{}+"cddb.genres")
  FileInput 0
  Repeat
    genrelist$(maxgenre.b)=Edit$(80)
    If NOT Len(genrelist$(maxgenre.b))
      maxgenre.b+1
    EndIf
  Until Eof(0) OR maxgenre.b=99
  CloseFile 0
EndIf

For i.b=0 To ids.b ; loop through all of the stored ids

  ; the loop below should loop through all of the different genres to check
  ; to see if the cd is in any of them
  ; checks the 'prefered' genre first

  res.b=#_NOENTRY_ERROR
  g.b=0 ;genre number

  While res.b=#_NOENTRY_ERROR AND g.b<maxgenre.b
    res.b=ReadCDDB{server$, cddbfile$, discid$, genrelist$(g.b), email$}
    g.b+1
  Wend
  If res.b<>-1
;    Pop For
    ;Function Return res.b
  EndIf
  If res.b=-1
    res.b=ConvertCDDBFile{cdplayer$,cddbfile$, discpath$+TOCCDID$}
    DeleteFile_ cddbfile$
  EndIf
Next

;NOTE - ONLY RETURNS THE RESULT OF THE *LAST* DISCID

Function Return res.b

End Function

