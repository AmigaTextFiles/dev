;MyTCP_ASM.bb2

; Attempt to convert TCP funcs into ASM...

;-----------------------------------------------------------
; Standard Blitz TCP Functions V1.8 by Paul Burkey (c)1997-1998
; Compiled with help from Ercole Spiteri and Anton Reinauer
; You *must* have the bsdsocket.library setup in Blitz!!
; Contact me at burkey@bigfoot.com
;-----------------------------------------------------------
;History
;-------
;<16.2.97> Version 1.8
;Added NLPrintTCP{} for easy send string with carrage return and newline.
;Removed need for 3rd Party libs (only bsdsocket.library needed)
;
;<24.12.97> Version 1.7
;ReadTCP{} Updated with extra safety and Speed
;
;<18.9.97> Version 1.6
;Added PrintTCP{}  for an easy "send string" command.
;Added NPrintTCP{} for easy send string with carrage return
;CheckTCP{} merged into the ConnectTCP{} function.
;
;---------------
; Function List
;---------------
;
;ReadTCP{}                       ; Similar to Edit$() - recives data via TCP connection
;ReadMemTCP{ReadAdd.l,MaxSize.l} ; Similar to ReamMem - recives data via TCP connection
;ConnectTCP{host$,port.w}        ; Connect to a remote machine (Full error checking)
;PrintTCP{text$}                 ; Similar to Print - sends data via TCP connection
;CloseTCP{}                      ; Closes TCP Connection

;---------------------------------
; TCP library Variables/Constants
;---------------------------------

#TCPBuflen=$2048                ;Maximum data size to read at any time
TCPmem.l=AllocMem(#TCPBuflen,0) ;Allocate the temp buffer used for all TCP reads
#FIONREAD=$4004667f             ;FIONREAD request

;---------------------------------
; Standard TCP library structures
;---------------------------------

NEWTYPE.list
  *ItemA.b
  *ItemB.b
End NEWTYPE
NEWTYPE.inaddr
  s_addr.l
End NEWTYPE
NEWTYPE.sockaddrin
  sin_len.b
  sin_family.b
  sin_port.w
  sin_addr.inaddr
  sin_zero.b[8]
End NEWTYPE
NEWTYPE.hostent
  *h_name.b
  *h_aliases.list
  h_addrtype.l
  h_length.l
  *h_addr_list.list
End NEWTYPE

Statement CloseSocket{sock.l}
  SHARED SocketBase.l

  PutReg a6,temp.l

  GetReg d1,SocketBase ; put SocketBase into d1
  MOVE.l d1,a6         ; move SocketBase from d1 to a6
;  GetReg d0,sock.l
  JSR -120(a6)
  GetReg d1,temp.l
  MOVE.l d1,a6            ; restore a6
  AsmExit

End Statement

Function.l gethostbyname{host$}
  SHARED SocketBase.l

  PutReg a6,temp.l

  GetReg d1,SocketBase ; put SocketBase into d1
  MOVE.l d1,a6         ; move SocketBase from d1 to a6
  GetReg d1,&host$
  MOVE.l d1,a0          ; put address of host into a0
  JSR -210(a6)
;  PutReg d0,res.l

  GetReg d1,temp.l      ; restore a6
  MOVE.l d1,a6

  AsmExit
End Function

Function.l socket{d.l, t.l, p.l}
  SHARED SocketBase.l

  PutReg a6,temp.l

  GetReg d3,SocketBase ; put SocketBase into d1
  MOVE.l d3,a6         ; move SocketBase from d1 to a6
;  GetReg d0,d.l        ; store vars in registers
;  GetReg d1,t.l
;  GetReg d2,p.l
  JSR -30(a6)
;  PutReg d0,res.l  ; not needed
  GetReg d1,temp.l
  MOVE.l d1,a6

  AsmExit
End Function


Function.l connect{sock.l, host.l, StructLength.l}
  SHARED SocketBase.l

  PutReg a6,temp.l

  GetReg d3,SocketBase ; put SocketBase into d1
  MOVE.l d3,a6         ; move SocketBase from d1 to a6

;  GetReg d0,sock.l
  MOVE.l d1,a0 ; put host.l into a0
  MOVE.l d2,d1 ; move StructLength into d1
  JSR -54(a6)
;  PutReg d0,res.l
  GetReg d3,temp.l  ; restore a6
  MOVE.l d3,a6
  AsmExit

End Function

Function.l recv{sock.l, buf.l,lenght.l,flags.l}
  SHARED SocketBase.l

  PutReg a6,temp.l
  GetReg d4,SocketBase.l
  MOVE.l d4,a6
;  GetReg d0,sock.l
;  GetReg a0,buf.l
  MOVE.l d1,a0
;  GetReg d1,lenght.l
  MOVE.l d2,d1
;  GetReg d2,flags.l
  MOVE.l d3,d2
  JSR -78(a6)
;  PutReg d0,res.l
  GetReg d4,temp.l
  MOVE.l d4,a6

  AsmExit
End Function

Function.l IoctlSocket{sock.l, req.l, argp.l}
  SHARED SocketBase.l

  PutReg a6,temp.l
  GetReg d3,SocketBase.l
  MOVE.l d3,a6
;  GetReg d0,sock.l
;  GetReg d1,req.l
;  GetReg a0,argp.l
  MOVE.l d3,a0
  JSR -144(a6)
;  PutReg d0,res.l
  GetReg d3,temp.l
  MOVE.l d3,a6
  AsmExit

End Function

Function WaitSelect{nfds.l, readfds.l, writefds.l, exceptfds.l, timeout.l, signals.l}
  SHARED SocketBase.l

  PutReg a6,temp.l
  GetReg d6,SocketBase.l
  MOVE.l d6,a6
;  GetReg d0, nfds.l
;  GetReg a0, readfds.l
  MOVE.l d1,a0
;  GetReg a1, writefds.l
  MOVE.l d2,a1
;  GetReg a2, exceptfds.l
  MOVE.l d3,a2
;  GetReg a3, timeout.l
  MOVE.l d4,a3
;  GetReg d1, signals.l
  MOVE.l d5,d1
  JSR -126(a6)
;  PutReg d0, res.l
  GetReg d6,temp.l
  MOVE.l d6,a6
  AsmExit
End Function

Function.l send{sock.l, buf.l, lenght.l, flags.l}
  SHARED SocketBase.l

  PutReg a6,temp.l
  GetReg d4,SocketBase.l
  MOVE.l d4,a6
;  GetReg d0, sock.l
;  GetReg a0, buf.l
  MOVE.l d1,a0
;  GetReg d1, lenght.l
  MOVE.l d2,d1
;  GetReg d2, flags.l
  MOVE.l d3,d2
  JSR -66(a6)
;  PutReg d0, res.l

  GetReg d4,temp.l
  MOVE.l d4,a6
  AsmExit
End Function


;---------------------------------
; Standard TCP Blitz Functions
;---------------------------------

.ReadTCP
Function .s ReadTCP{}
  SHARED sock.l,TCPmem.l
  ;
  ; This Function reads data from the server the result is passed back in a
  ; string. If there is no messages then it will return an empty string =""
  ;
  sockread.l=0                                ;Clear Readmask
  sockread.l BitSet sock.l                    ;Set Readmask on our socket
  e.l=IoctlSocket{sock.l,#FIONREAD,TCPmem.l} ;How much data is there?
  f.l=Peek.l(TCPmem.l)                        ;Place value in f
  If f>0
    If f>#TCPBuflen Then f=#TCPBuflen         ;Don't read more than #TCPBuflen
    c=recv{sock.l,TCPmem.l,f,0}              ;Read all Data
    c$=String$(" ",f)                         ;Reserve String
    CopyMem_ TCPmem.l,&c$,f                   ;Copy Data to string
    Function Return c$
  Else
    Function Return ""
  EndIf
End Function


.WriteMemTCP
Statement WriteMemTCP{ad.l,size.w}
  SHARED sock.l
  ;
  ; This routine writes data via TCP.
  ;
  sockwrite.l=0                           ;Clear Writemask
  sockwrite.l BitSet sock.l               ;set Writemask on our socket
  g.l=WaitSelect{2,0,&sockwrite.l,0,0,0} ;Wait until server is ready to read our data
  c.l=send{sock.l,ad,size,0}             ;Send data to server
End Statement



.ConnectTCP
Function .b ConnectTCP{host$,port.w}
  SHARED sock.l
  SHARED SocketBase.l
  ;
  ; Check if Miami/AmiTCP stack is available
  ; Connect to host at specified port
  ; Return true or False if Connection is made

  SocketBase.l=OpenLibrary_("bsdsocket.library",0)
  If SocketBase=0
    Function Return 0
  Else

;    CloseLibrary_(SocketBase)

    sock.l=socket{2,1,0}

;    Request "Hmm","Sock="+Str$(sock.l),"OK"
    *a.hostent=gethostbyname{host$}
;    Request "Hmm","*a="+Str$(*a),"OK"

    If *a=0
      CloseLibrary_(SocketBase.l)
      Function Return 0   ; host not found (or internal TCP error)
    Else
      ;
      ; Copy Details to our Sockaddrin structure
      ;
      CopyMem_ *a\h_addr_list\ItemA,&host.sockaddrin\sin_addr,*a\h_length
      host.sockaddrin\sin_port=port       ;Set port number
      host.sockaddrin\sin_family=2        ;Set type to AT_INET
      StructLength.l=SizeOf .sockaddrin   ;Get lenght of structure sockaddrin
      Request "o",Str$(host.sockaddrin),"OK"
      If connect{sock.l,host.sockaddrin,StructLength}
        CloseSocket{sock.l}
        CloseLibrary_(SocketBase)
        Function Return 0
      Else
        Function Return -1
      EndIf
    EndIf
  EndIf
End Function



.PrintTCP
Statement PrintTCP{text$}
  ;
  ; Send String via TCP
  ;
  WriteMemTCP{&text$,Len(text$)}
End Statement

.CloseTCP
Statement CloseTCP{}
  SHARED sock.l
  SHARED SocketBase.l
  ;
  ; This is a simple close socket command
  ; Provided for the shear hell of it :)
  ;
  CloseSocket{sock.l}

  CloseLibrary_(SocketBase)
  SocketBase=0
End Statement







;  If NOT ConnectTCP{"cddb.cddb.com",80};#_FALSE
;    Request "moo","Unable to connect to CDDB server","OK"
;    End
;  EndIf
;
;  CloseTCP{}
;
;  End

