;GetCDDB_MiscFuncs.bb2

XINCLUDE GetCDDB_Consts.bb2

;-----------------------------------------------------------------
; My Misc Funcs
;-----------------------------------------------------------------

Statement ErrorReq{error$}
  SHARED noreq.b
  If NOT noreq
    Request "Error",error$,"OK"
  EndIf
End Statement

Statement SetStatus{stat$}
  SHARED noreq.b
  If NOT noreq.b
    GTSetString #_MAIN_WIN,#_STATUS_TEXT,stat$
  EndIf
End Statement

;-----------------------------------------------------------------
; Returns value of #_DISC_PATH string

Function.s GetDiscPath{}
  discpath$=GTGetString(0,#_DISC_STRING)
  If Right$(discpath$,1)<>":" AND Right$(discpath$,1)<>"/"
    discpath$+"/"
  EndIf
  Function Return discpath$
End Function

;-----------------------------------------------------------------
; Other Misc Funcs
;-----------------------------------------------------------------

Function.s ASLPathRequest{title$,pathname$}
  *scr.Screen=Peek.l(Addr Screen(Used Screen))

  top.w=0
  left.w=0
  width.w=ScreenWidth/2 ; remove /2 for full-screen requester! ;)
  height.w=ScreenHeight

  Dim Tags.TagItem(9)
  Tags(0)\ti_Tag=#ASLFR_Screen,*scr
  Tags(1)\ti_Tag=#ASLFR_TitleText,&title$
  Tags(2)\ti_Tag=#ASLFR_InitialDrawer,&pathname$
  Tags(3)\ti_Tag=#ASLFR_InitialLeftEdge,left
  Tags(4)\ti_Tag=#ASLFR_InitialTopEdge,top
  Tags(5)\ti_Tag=#ASLFR_InitialWidth,width
  Tags(6)\ti_Tag=#ASLFR_InitialHeight,height
  Tags(7)\ti_Tag=#ASLFR_DrawersOnly,-1
  Tags(8)\ti_Tag=#TAG_END,0

 *filereq.FileRequester=AllocAslRequest_(#ASL_FileRequest,&Tags(0))
  If *filereq
    ok.l=AslRequest_(*filereq,&Tags(0))
    If ok
      f$=Peek.s(*filereq\fr_Drawer)
      If Len(f$)>0 Then If Right$(f$,1)<>":" AND Right$(f$,1)<>"/" Then f$+"/"
      f$=f$+Peek.s(*filereq\fr_File)
    Else
      f$="nil:" ; an impossible/unusable case!
    EndIf
    FreeAslRequest_(*filereq)
  EndIf
  Function Return f$
End Function
;

;-----------------------------------------------------------------

; Function : ProgsDir {}

; Author : Nick Clover - nick@bauk.freeserve.co.uk

; Returns a string with the program's directory.

; IMPORTANT! Only works with compiled executables,as
; Compiling & Running doesn't use a directory (obviously ;)

; **** REPLACEMENT by Nick Clover ****
; Now returns program directory when run from WB as well!
; Cool :)

; UPDATE - renamed to ProgsDir, to keep in line with ProgsName,
;          because ProgDir is a Blitz Support Suite command.

Function.s ProgsDir{}

  MaxLen path$=200
  NameFromLock_ GetProgramDir_(),&path$,200
  path$=Peek$(&path$)
  If Right$(path$,1)<>":" AND Right$(path$,1)<>"/"
    path$+"/"
  EndIf
Function Return path$
End Function

;-----------------------------------------------------------------

Function.s ProgsName{}

If FromCLI=-1

  *stringbuffer = AllocMem_(255, 0)
  suc.l=GetProgramName_(*stringbuffer,255)

  If suc
    pname$=Peek$(*stringbuffer)
  EndIf

  FreeMem_ *stringbuffer,255

Else pname$=Peek$(Peek.l(FindTask_(0)+$B0)+4)
EndIf

Function Return pname$

End Function

; Function : ToolString { icon, tooltype }

; Author : James L Boyd - jamesboyd@all-hail.freeserve.co.uk
; - adapted from someone else's source!

; Returns tooltype's contents (if any)...

Function.s ToolString {icon$,tool$}

*Icon.DiskObject=GetDiskObject_(&icon$)

; *Icon.DiskObject=GetDiskObjectNew_(&icon$)
; ^ this uses the default-type icon if there isn't one...

If *Icon
  a.l=FindToolType_(*Icon\do_ToolTypes,&tool$)
  If a
    a$=Peek$(a)
  Else a$=""
  EndIf
  FreeDiskObject_ *Icon
Else
  Request "o","moo","blob"
 Function Return ""
EndIf

End Function
;-----------------------------------------------------------------

; Function : Value { number as string }

; Author : Curt Esser - camge@ix.netcom.com

; This function returns correct values
; for very large numbers - Blitz doesn't!

; Probably saves quite a bit on executable size too.

Function.l  Value {input$}
  valu.l=0
  chars.w=StrToLong_(&input$,&valu)
  Function Return valu
End Function

; demo :

; test$="1087504386"

; NPrint "Blitz's Val      : ",Val(test$)
; NPrint "Value{} function : ",Value{test$}

; MouseWait
; End

;-----------------------------------------------------------------

; Function : LockWindow { window }

; Locks the specified window, puts up busy pointer.

; Unlocked with the UnLockWindow {} statement.

; IMPORTANT!!! You should store the result as a long
; variable, as in the demo - this is needed for the
; UnLockWindow {} statement!

Function.l LockWindow {win.l}
  lock.l=AllocMem_(SizeOf .Requester,1)
  If lock
    win=Peek.l(Addr Window(win))
    InitRequester_(lock)
    If Request_(lock,win)
      *_exec.Library=Peek.l(4)
      If *_exec\lib_Version=>39
        Dim tag.TagItem(1)
        tag(0)\ti_Tag=#WA_BusyPointer,-1
        tag(1)\ti_Tag=#TAG_END
        SetWindowPointerA_ win,&tag(0)
      EndIf
    Else
      FreeMem_ lock,SizeOf .Requester
      lock=0
    EndIf
  EndIf
  Function Return lock
End Function

;-----------------------------------------------------------------

; Statement : UnLockWindow { window, lock }

; Unlocks a window locked with the LockWindow {} function.

; IMPORTANT!!!! The "lock" parameter is the value returned
; from LockWindow {} , eg. lock.l=LockWindow {0}

; You supply this value to this statement.

Statement UnlockWindow{win.l,lock.l}
  win=Peek.l(Addr Window(win))
  *_exec.Library=Peek.l(4)
  If *_exec\lib_Version=>39
    Delay_ 5
    Dim tag.TagItem(0)
    tag(0)\ti_Tag=#TAG_END
    SetWindowPointerA_ win,&tag(0)
  EndIf
  EndRequest_ lock,win
  FreeMem_ lock,SizeOf .Requester
End Statement

; demo :

; FindScreen 0

; Window 0,0,0,640,100,$40f,"Delayed for 2 seconds",1,2
; GTButton 0,0,0,0,200,10,"Click me!",0

; AttachGTList 0,0

; lock.l=LockWindow {0}

;   Delay_ 100

; If lock Then UnlockWindow {0,lock}

;   Delay_ 100

; End



