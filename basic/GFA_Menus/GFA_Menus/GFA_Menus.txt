GFA-Basic Errors
----------------

GFA-Basic has serious problems with its event handling (menus, windows).

o  if a menu item is deleted or inserted, the entire menu handler for
   ON MENU has to be altered

o  the SLEEP command used for event handling uses polling instead of
   waiting, thus needs a lot of CPU time

This package provides a solution by using functions of the operating
system.

GFA-Basic Fehler
----------------

GFA-Basic hat Probleme mit der Ereignisbehandlung für Menüs und Fenster.

·  Wenn ein Menüpunkt eingefügt bzw. gelöscht wird, muss die gesamte
   Menübehandlung (ON MENU) umgeschrieben werden
   
·  Der Befehl SLEEP, der für die Ereignisbehandlung zuständig ist, verwendet
   "Polling" und verschwendet deshalb Rechenzeit.
   
Dieses Paket bietet eine Lösung, indem es Funktionen des Betriebssystems
verwendet.

The solution
------------

The following steps are necessary to set up a menu:

(1) Build an array containing the menu items
(2) Call "MENU <array>" to attach it to the current window
(3) Optionally call MENU KEY... to assign command keys to the menu items.
(4) Use the following event handler instead of ON MENU..., ON MESSAGE...,
    and SLEEP.
    
    Note: replace 0 by the number of the current window within WINDOW(0).

    m% holds the # of the menu selected (starting with 0)
    i% holds the # of the menu item selected (starting with 0)
    s% holds the # of the sub item selected (starting with 0)

    class% holds the event number (&H200 = CLOSEWINDOW, &H100 = MENUPICK)
    
REPEAT
  msg=WaitPort(LPEEK(WINDOW(0)+86))
  msg=GetMsg(LPEEK(WINDOW(0)+86))
  WHILE (msg)
    class%=LPEEK(msg+20)
    code%=DPEEK(msg+24)
    ~ReplyMsg(msg)
    '
    IF HEX$(class%)="200" ! *** CLOSEWINDOW
      ' Handle CLOSEWINDOW event
    ENDIF
    IF HEX$(class%)="100" ! *** MENUPICK
      i$=RIGHT$(STRING$(16,"0")+BIN$(code%),16)
      s%=VAL("%"+MID$(i$,1,5)) ! *** sub item
      i%=VAL("%"+MID$(i$,6,6)) ! *** menu item
      m%=VAL("%"+MID$(i$,12,5)) ! *** menu
      ' Handle MENUPICK event
    ENDIF
    '
    msg=GetMsg(LPEEK(WINDOW(0)+86))
  WEND
UNTIL FALSE

Die Lösung
----------

Folgende Schritte sind zur Erstellung eines Menüs notwendig:

(1) Erstellung eines Arrays mit Menüpunkten
(2) Aktivierung des Menüs mittels MENU <arrayname>
(3) Optional: Zuweisung von Tastaturbefehlen mittels MENU KEY ...
(4) Ersetzung der üblichen Befehle ON MENU..., ON MESSAGE... und SLEEP
    durch die folgende Ereignisbehandlung.

    Hinweis: Ersetzen Sie in WINDOW(0) 0 durch die Nummer des Fensters.

    m% ist die Nummer des Menüs (erstes = 0)
    i% ist die Nummer des Menüpunktes (erster = 0)
    s% ist ggf. die Nummer des Untermenüpunktes (erster = 0)
    
    class: ist die Ereignisnummer (&H200 = CLOSEWINDOW, &H100 = MENUPICK)

REPEAT
  msg=WaitPort(LPEEK(WINDOW(0)+86))
  msg=GetMsg(LPEEK(WINDOW(0)+86))
  WHILE (msg)
    class%=LPEEK(msg+20)
    code%=DPEEK(msg+24)
    ~ReplyMsg(msg)
    '
    IF HEX$(class%)="200" ! *** CLOSEWINDOW
      ' Benutzer möchte Fenster schließen ...
    ENDIF
    IF HEX$(class%)="100" ! *** MENUPICK
      i$=RIGHT$(STRING$(16,"0")+BIN$(code%),16)
      s%=VAL("%"+MID$(i$,1,5)) ! *** Untermenüpunkt
      i%=VAL("%"+MID$(i$,6,6)) ! *** Menüpunkt
      m%=VAL("%"+MID$(i$,12,5)) ! *** Menü
      ' Benutzer wählte Menüpunkt ...
    ENDIF
    '
    msg=GetMsg(LPEEK(WINDOW(0)+86))
  WEND
UNTIL FALSE

Distribution
------------

This package is placed in the public domain and may be freely distributed.
You my use it in your own programs.

Dieses Paket ist Public Domain und frei verteilbar; Sie dürfen es in Ihren
Programmen verwenden.

Author / Autor
--------------

Frank Reibold
Ottberger Weg 13
31737 Rinteln

GERMANY

