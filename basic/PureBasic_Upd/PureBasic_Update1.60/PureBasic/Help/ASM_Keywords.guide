
  ***********************************************************************
  *                                                                      *
  *               PureBasic Inlined ASM Keywords List                    *
  *                                                                      *
   ***********************************************************************



-------------------
                   -
68000 instructions: -
                   -
-------------------

 Name    |   Possible forms          |    Description
---------+---------------------------+------------------------
ABCD        Dy,Dx                      Add Decimal with Extend
ABCD        -(Ay),-(Ax)
ADD.x       <ea>,Dn                    Add
ADD.x       Dn,<ea>
ADDA.x      <ea>,An                    Add Address
ADDI.x      #<data>,<ea>               Add Immediate
ADDQ.x      #<data>,<ea>               Add Quick
ADDX.x      Dy,Dx                      Add Extended
ADDX.x      -(Ay),-(Ax)
AND.x       <ea>,Dn                    And Logical
AND.x       Dn,<ea>
ANDI.x      #<data>,<ea>               And Immediate
ANDI.x      #<data>,CCR                And Immediate to Condition Codes
ANDI.x      #<data>,SR                 And Immediate to the Status Register
ASL/ASR.x   Dx,Dy                      Arithmetic Shift Left/Right
ASL/ASR.x   #<data>,Dy
ASL/ASR     <ea>
B<cc>.x     <label>                    Branch Conditionally
BCHG        Dn,<ea>                    Test a Bit and Change
BCHG        #<data>,<ea>
BCLR        Dn,<ea>                    Test a Bit and Clear
BCLR        #<data>,<ea>
BRA.x       <label>                    Branch Always
BSET        Dn,<ea>                    Test a Bit and Set
BSET        #<data>,<ea>
BSR.x       <label>                    Branch to Subroutine
BTST.x      Dn,<ea>                    Test a Bit
BTST.x      #<data>,<ea>
CHK.x       <ea>,Dn                    Check Register Against Bounds
CLR.x       <ea>                       Clear an Operand
CMP.x       <ea>,Dn                    Compare
CMPA.x      <ea>,An                    Compare Address
CMPI.x      #<data>,<ea>               Compare Immediate
CMPM.x      (Ay)+,(Ax)+                Compare Memory
DB<cc>      Dn,<label>                 Test Condition, Decrement, and Branch
DIVS        <ea>,Dn                    Signed Divide
DIVU        <ea>,Dn                    Unsigned Divide
EOR.x       Dn,<ea>                    Exclusive-OR Logical
EORI.x      #<data>,<ea>               Exclusive-OR Immediate
EORI.x      #<data>,CCR                Exclusive-OR Immediate to Cond. Codes
EORI.x      #<data>,SR                 Exclusive-OR Immediate to Status Reg.
EXG         Rn,Rm                      Exchange Registers
EXT.x       Dn                         Sign Extend
ILLEGAL                                Take Illegal Instruction Trap
JMP         <ea>                       Jump
JSR         <ea>                       Jump to Subroutine
LEA         <ea>,An                    Load Effective Address
LINK        An,#<displacement>         Link and Allocate
LSL/LSR.x   Dx,Dy                      Logical Shift Left/Right
LSL/LSR.x   #<data>,Dy
LSL/LSR     <ea>
MOVE.x      <ea>,<ea>                  Move Data from Source to Destination
MOVEA.x     <ea>,An                    Move Address
MOVE        <ea>,CCR                   Move to Condition Codes
MOVE        <ea>,SR                    Move to the Status Register
MOVE        SR,<ea>                    Move from Status Register
MOVE        USP,An                     Move User Stack Pointer
MOVE        An,USP
MOVEM.x     <register list>,<ea>       Move Multiple Registers
MOVEM.x     <ea>,<register list>
MOVEP.x     Dx,(d,Ay)                  Move Peripheral Data (not 68060!)
MOVEP.x     (d,Ay),Dx
MOVEQ       #<data>,Dn                 Move Quick
MULS        <ea>,Dn                    Signed Multiply
MULU        <ea>,Dn                    Unsigned Multiply
NBCD        <ea>                       Negate Decimal with Extend
NEG.x       <ea>                       Negate
NEGX.x      <ea>                       Negate with Extend
NOP                                    No Operation
NOT.x       <ea>                       Logical Complement
OR.x        <ea>,Dn                    Inclusive-OR Logical
OR.x        Dn,<ea>
ORI.x       #<data>,<ea>               Inclusive-OR Immediate
ORI.x       #<data>,CCR                Inclusive-OR Immediate to Cond. Codes
PEA         <ea>                       Push Effective Address
RESET                                  Reset External Devices
ROL/ROR.x   Dx,Dy                      Rotate (without Extend) Left/Right
ROL/ROR.x   #<data>,Dy
ROL/ROR     <ea>
ROXL/ROXR.x Dx,Dy                      Rotate Left/Right with Extend
ROXL/ROXR.x #<data>,Dy
ROXL/ROXR   <ea>
RTE                                    Return from Exception
RTR                                    Return and Restore Condition Codes
RTS                                    Return from Subroutine
SBCD        Dx,Dy                      Subtract Decimal with Extend
SBCD        -(Ax),-(Ay)
S<cc>       <ea>                       Set According to Condition
STOP        #<data>                    Load Status Register and Stop
SUB.x       <ea>,Dn                    Subtract
SUB.x       Dn,<ea>
SUBA.x      <ea>,An                    Subtract Address
SUBI.x      #<data>,<ea>               Subtract Immediate
SUBQ.x      #<data>,<ea>               Subtract Quick
SUBX.x      Dx,Dy                      Subtract with Extend
SWAP        Dn                         Swap Register Halves
TAS         <ea>                       Test and Set an Operand
TRAP        #<vector>                  Take Trap Exception
TRAPV                                  Trap on Overflow
TST.x       <ea>                       Test an Operand
UNLK        An                         Unlink

Integer Condition Codes <cc>:
CC (HS)  carry clear (higher or same)  CS (LO)  carry set (lower)
EQ       equal                         F        never true
GE       greater or equal              GT       greater than
HI       higher                        LE       less or equal
LS       less or same                  LT       less than
MI       negative                      NE       not equal
PL       positive                      T        always true
VC       overflow clear                VS       overflow set


-------------------
                   -
68010 instructions: -
                   -
-------------------

 Name    |   Possible forms          |    Description
---------+---------------------------+------------------------
BKPT        #<data>                    Breakpoint
MOVE        CCR,<ea>                   Move from the Condition Code Register
MOVEC       Rc,Rn                      Move Control Registers
MOVEC       Rn,Rc
MOVES       Rn,<ea>                    Move Address Space
MOVES       <ea>,Rn
RTD         #<displacement>            Return and Deallocate


-------------------
                   -
68020 instructions: -
                   -
-------------------

 Name    |   Possible forms          |    Description
---------+---------------------------+------------------------
BFCHG       <ea>{offset:width}         Test Bit Field and Change
BFCLR       <ea>{offset:width}         Test Bit Field and Clear
BFEXTS      <ea>{offset:width},Dn      Extract Bit Field Signed
BFEXTU      <ea>{offset:width},Dn      Extract Bit Field Unsigned
BFFFO       <ea>{offset:width},Dn      Find First One in Bit Field
BFINS       Dn,<ea>{offset:width}      Insert Bit Field
BFSET       <ea>{offset:width}         Test Bit Field and Set
BFTST       <ea>{offset:width}         Test Bit Field
CALLM       #<data>,<ea>               Call Module (68020 ONLY!)
CAS.x       Dc,Du,<ea>                 Compare and Swap with Operand
CAS2.x      Dc1:Dc2,Du1:Du2,(Rn1):(Rn2) (020-040 only!)
CHK2.x      <ea>,Rn  (020-040 only!)   Check Register Against Bounds
CMP2.x      <ea>,Rn  (020-040 only!)   Compare Register Against Bounds
DIVS.L      <ea>,Dq                    Signed Divide
DIVS.L      <ea>,Dr:Dq  (020-040 only!)
DIVSL.L     <ea>,Dr:Dq
DIVU.L      <ea>,Dq                    Unsigned Divide
DIVU.L      <ea>,Dr:Dq  (020-040 only!)
DIVUL.L     <ea>,Dr:Dq
EXTB.L      Dn                         Sign Extend
LINK.L      An,#<displacement>         Link and Allocate
MULS.L      <ea>,Dl                    Signed Multiply
MULS.L      <ea>,Dh:Dl
MULU.L      <ea>,Dl                    Unsigned Multiply
MULU.L      <ea>,Dh:Dl
PACK        -(Ax),-(Ay),#<adjustment>  Pack BCD
PACK        Dx,Dy,#<adjustment>
RTM         Rn                         Return from Module (68020 ONLY!)
TRAP<cc>                               Trap on Condition
TRAP<cc>.x  #<data>
UNPK        -(Ax),-(Ay),#<adjustment>  Unpack BCD
UNPK        Dx,Dy,#<adjustment>


-------------------
                   -
68040 instructions: -
                   -
-------------------

 Name    |   Possible forms          |    Description
---------+---------------------------+------------------------
CINVL       <caches>,(An)              Invalidate Cache Lines
CINVP       <caches>,(An)              (<caches> = DC, IC, BC or NC)
CINVA       <caches>
CPUSHL      <caches>,(An)              Push and Invalidate Cache Lines
CPUSHP      <caches>,(An)
CPUSHA      <caches>
MOVE16      (Ax)+,(Ay)+                Move 16 Bytes Block
MOVE16      xxx.L,(An)
MOVE16      xxx.L,(An)+
MOVE16      (An),xxx.L
MOVE16      (An)+,xxx.L


-------------------
                   -
68060 instructions: -
                   -
-------------------

 Name    |   Possible forms          |    Description
---------+---------------------------+------------------------
LPSTOP      #<data>                    Low-Power Stop
HALT                                   Processor halted
PULSE                                  Send $14 pulse on PSTx
