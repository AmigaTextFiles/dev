
; $VER: BitmapPrint.bb2 v1.1 (30.08.2000)

; Original authors: David McMinn, Curt Esser
; Additional modifications: Damir Arh
; E-mail: damir.arh@telesat.si
; WWW:    http://damir.gajba.net/

; This source code is completely free. You can redistribute
; and/or modify it without any restrictions whatsoever.

;-------------------------------------------------------------

; This function is an easy way to print text to any bitmap
; using standard intuition fonts.

; At the end of this source ('main' label) there's a small
; demo to show you, what is possible and how you could use
; this function.

;-------------------------------------------------------------


;-------------------------------------------------------------
.BitmapPrint:
;-------------------------------------------------------------

; This the actual text printing function. Before using it
; you must have a bitmap opened and an intuifont loaded
; before calling the function.

; The text will get printed on the current bitmap using
; the current intuifont. If the text wouldn't fit on the
; bitmap it won't get printed as this would cause a mess.

; Function parameters:

; text$ = The string to print. You can use Chr$(167) to
;         separate several lines of text.
; x     = The x location to center text horizontally on.
; y     = The y location to print the text.
; color = The variable contains color number for the
;         text, outline and shadow. The value is obtained
;         by calling the BP_GetColor{} function.
; style = The style of the printing. Add the constants to
;         get the desired style (some fonts don't support
;         all styles (it's a limitation of the font):

#BP_Normal     = 0
#BP_Bold       = 1
#BP_Underlined = 2
#BP_Italic     = 4
#BP_Extended   = 8
#BP_Shadow     = 16
#BP_Outline    = 32

Statement BitmapPrint{text$,x.w,dummy.l,y.w,color.l,style.l}

  If Asc(Left$(text$,1))<>0 ; is there anything to print

    ; extract shadow information
    shadow = style BitTst 4
    style = style BitClr 4
    shadowcol.w = color MOD 256
    color = color / 256

    ; extract outline information
    outline = style BitTst 5
    style = style BitClr 5
    outlinecol.w = color MOD 256
    color = color / 256

    enabl.l = 79 ; the enable bits for setting the softstyle

    ; create a rastport for the bitmap
    DEFTYPE._RastPort rp
    InitRastPort_ &rp
    rp\_BitMap = Addr BitMap(Used BitMap)

    ; set the font and its attributes
    SetFont_ &rp,Peek.l(Addr IntuiFont(Used IntuiFont)+8)
    SetDrMd_ &rp,0 ; print letters only, no backgroud rectangle
    styl.l = SetSoftStyle_(&rp,style,enabl) ; set text style

    BMwidth.w=8*rp\_BitMap\BytesPerRow
    BMheight.w=rp\_BitMap\Rows
    FontSize.w=rp\Font\tf_YSize

    ; get the number of lines to print
    lines = 1
    For i = 1 To Len(text$)-1
      If Mid$(text$,i,1)=Chr$(167)
        lines = lines + 1
      EndIf
    Next i

    j = 1 ; current postion in the text
    y = y - FontSize
    For i = 1 To lines
      s=j ; start of the line
      l=0 ; length of the line
      While j <= Len(text$) AND Mid$(text$,j,1)<>Chr$(167)
        l = l + 1
        j = j + 1
      Wend
      j = j + 1
      y = y + FontSize

      If l>0 ; if there is anything to print
        temp$ = Mid$(text$,s,l) ; get the text for this line
        pixels.w=TextLength_(&rp,&temp$,l)

        cx=x-pixels/2 ; text centering

        ; check if the text fits
        If (cx+2+pixels<BMwidth) AND (cx-1>=0) AND (y-FontSize-1>=0) AND (y+2<BMheight)
          ; print the shadow
          If shadow
            Move_ &rp,cx+2,y+2
            SetAPen_ &rp,shadowcol
            Text_ &rp,&temp$,Len(temp$)
          EndIf
          ; print the outline
          If outline
            SetAPen_ &rp,outlinecol
            Move_ &rp,cx+1,y
            Text_ &rp,&temp$,Len(temp$)
            Move_ &rp,cx,y+1
            Text_ &rp,&temp$,Len(temp$)
            Move_ &rp,cx-1,y
            Text_ &rp,&temp$,Len(temp$)
            Move_ &rp,cx,y-1
            Text_ &rp,&temp$,Len(temp$)
          EndIf
          ;print the text
          Move_ &rp,cx,y
          SetAPen_ &rp,color
          Text_ &rp,&temp$,Len(temp$)
        EndIf
      EndIf
    Next i
  EndIf

End Statement


;-------------------------------------------------------------
.BP_GetColor:
;-------------------------------------------------------------

; This a support function for generating a color value
; needed when calling the BitmapPrint{} function.

; Function parameters:

; text    = Pen color for the text.
; shadow  = Pen color for the shadow.
; dummy = A throwaway value to compensate for the
;         function bug in some versions of AcidLibs.
; outline = Pen color for the outline.

Function.l BP_GetColor{text.q,shadow.q,dummy.l,outline.q}
  Function Return (((text*256)+outline)*256)+shadow
End Function


;------------------------------------------------------------
.main:
;------------------------------------------------------------

; This is just a short program to test the above functions.

; It shows, how to use the functions correctly and shouldn't
; be directly copied into your program.

WBStartup
WBenchToFront_
FindScreen 0
LoadFont 0,"Diamond.font",12
Window 0,10,10,300,150,$1000,"Print Demo",1,0
BitMap 0,300,150,2
Cls 3
BitmapPrint{"Outline, Italic",150,0,15,BP_GetColor{2,0,0,0},#BP_Italic}
BitmapPrint{"Two"+Chr$(167)+"Lines",150,0,40,BP_GetColor{3,1,0,2},#BP_Outline+#BP_Shadow}
BitMaptoWindow 0,0
MouseWait
End

