@DATABASE Misc V1.20
$VER: Pure Basic - Misc library V1.30 (04.09.2000) © Fantaisie Software
@NODE MAIN "Misc V1.30"

  @{b}PureBasic Misc library V1.30@{ub}

    This library provides a lot of very useful but inclassifiable
    functions..

  @{b}Commands summary:@{ub}

    @{" Delay           " LINK Delay}
    @{" FPU             " LINK FPU}
    @{" GetCLIArg       " LINK GetCLIArg}
    @{" GetFilePart     " LINK GetFilePart}
    @{" GetPathPart     " LINK GetPathPart}
    @{" MMU             " LINK MMU}
    @{" MouseButtons    " LINK MouseButtons}
    @{" MouseWait       " LINK MouseWait}
    @{" NumberOfCLIArgs " LINK NumberOfCLIArgs}
    @{" PeekB           " LINK PeekX}
    @{" PeekL           " LINK PeekX}
    @{" PeekS           " LINK PeekX}
    @{" PeekW           " LINK PeekX}
    @{" PokeB           " LINK PokeX}
    @{" PokeL           " LINK PokeX}
    @{" PokeS           " LINK PokeX}
    @{" PokeW           " LINK PokeX}
    @{" Print           " LINK Print}
    @{" PrintN          " LINK PrintN}
    @{" PrintNumber     " LINK PrintNumber}
    @{" PrintNumberN    " LINK PrintNumberN}
    @{" Processor       " LINK Processor}
    @{" ProgramPriority " LINK ProgramPriority}
    @{" RunProgram      " LINK RunProgram}
    @{" VWait           " LINK VWait}

@ENDNODE


@NODE Delay

    @{b}SYNTAX@{ub}
  Delay(Time)

    @{b}FUNCTION@{ub}
  Halts the program execution for the given time.

  Time: Number of seconds to wait.

@ENDNODE


@NODE FPU

    @{b}SYNTAX@{ub}
  Result = FPU()

    @{b}FUNCTION@{ub}
  Return if a FPU (Floating Point Unit) is present on the Amiga.

  Possible values:

  0: No FPU available
  1: 68881 FPU detected
  2: 68882 FPU detected

@ENDNODE


@NODE GetCLIArg

    @{b}SYNTAX@{ub}
  Argument$ = GetCLIArg(Position.w)

    @{b}FUNCTION@{ub}
  Returns the argument at position (Position.w) that was passed to the
  program at CLI start. If less arguments were given the function
  returns NULL.
  It is assumed that the function @{" NumberOfCLIArgs " LINK NumberOfCLIArgs} has been called
  once before for this function to work correctly.

  Example:

    Second$ = GetCLIArg(2)

  Second$ will be 'b', if the program 'TestProg' has been startet with
  > TestProg "a c" b
  from CLI.

@ENDNODE


@NODE GetFilePart

    @{b}SYNTAX@{ub}
  FileName$ = GetFilePart(String$)

    @{b}FUNCTION@{ub}
  Returns the FileName of a path and filename string.

  Example:

    FileName$ = GetFilePart("Dh0:Games/SuperFrog/SuperFrog.exe")

  FileName$ will be 'SuperFrog.exe'.

@ENDNODE


@NODE GetPathPart

    @{b}SYNTAX@{ub}
  PathName$ = GetPathPart(String$)

    @{b}FUNCTION@{ub}
  Returns the full path of a path and filename string.

  Example:

    PathName$ = GetPathPart("Dh0:Games/SuperFrog/SuperFrog.exe")

  PathName$ will be 'Dh0:Games/SuperFrog/'.

@ENDNODE


@NODE MouseButtons

    @{b}SYNTAX@{ub}
  PressedButtons.w = MouseButtons()

    @{b}FUNCTION@{ub}
  Returns the currently pressed mousebuttons (1 = left, 2 = right, 3 = both,
  0 = none).

@ENDNODE


@NODE MMU

    @{b}SYNTAX@{ub}
  Result = MMU()

    @{b}FUNCTION@{ub}
  If no MMU (Memory Management Unit) is present on the Amiga, the command
  returns 0, else a MMU is present.

@ENDNODE


@NODE MouseWait

    @{b}SYNTAX@{ub}
  MouseWait()

    @{b}FUNCTION@{ub}
  Waits for a left mouse button click.

@ENDNODE


@NODE NumberOfCLIArgs

    @{b}SYNTAX@{ub}
  NumOfArgs.w = NumberOfCLIArgs()

    @{b}FUNCTION@{ub}
  Returns the number of arguments that were passed to the program at CLI
  start.
  The single arguments must be separated by spaces. If an argument contains
  spaces it must be surrounded by double quotes (Chr(34)). If the number of
  double quotes is odd the function returns 0, independent of the argument
  string's contents.

@ENDNODE


@NODE PeekX

    @{b}SYNTAX@{ub}
  Result = PeekB/W/L/S(*Address)

    @{b}FUNCTION@{ub}
  Return a byte, word, long or string, depending of the suffix used, located
  at the given *Address.

@ENDNODE


@NODE PokeX

    @{b}SYNTAX@{ub}
  PokeB/W/L/S(*Address, Data)

    @{b}FUNCTION@{ub}
  Put the given data to the specified *Address. It can put a byte, word,
  long or string depending of the the suffix used.

@ENDNODE


@NODE Print

    @{b}SYNTAX@{ub}
  Print(String$)

    @{b}FUNCTION@{ub}
  Prints the given 'String$' to the default output (CLI/Shell).

@ENDNODE


@NODE PrintN

    @{b}SYNTAX@{ub}
  PrintN(String$)

    @{b}FUNCTION@{ub}
  Prints the given 'String$' to the default output (CLI/Shell) and adds
  an 'end of line' character at the end of the string.

@ENDNODE


@NODE PrintNumber

    @{b}SYNTAX@{ub}
  PrintNumber(Number)

    @{b}FUNCTION@{ub}
  Prints the given number to the default output (CLI/Shell).

@ENDNODE


@NODE PrintNumberN

    @{b}SYNTAX@{ub}
  PrintNumberN(Number)

    @{b}FUNCTION@{ub}
  Prints the given number to the default output (CLI/Shell) and adds
  a 'end of line' character.

@ENDNODE


@NODE VWait

    @{b}SYNTAX@{ub}
  VWait()

    @{b}FUNCTION@{ub}
  Waits until the next frame begins. It's also known as Vertical Blank. Used
  to synchronize animation with the display.

@ENDNODE


@NODE RunProgram

    @{b}SYNTAX@{ub}
  RunProgram(DefaultPath$, CommandLine$, ASynchrone, Stack)

    @{b}FUNCTION@{ub}
  Launches an external program from your program, using the given
  parameters.

  DefaultPath$: Full path to be used by default for the launched program.

  CommandLine$: Command to execute (Path and name of the program to launch).

  ASynchrone: If set to 1, will launch the program in asynchrone matter, so
              your program will continue immediatly after the launch. Else
              your program will be halted until the launched program quits.

  Stack: Stack value for the launched program. Set it at least to 4096 if you
         don't know what it does !

@ENDNODE


@NODE Processor

    @{b}SYNTAX@{ub}
  Result = Processor()

    @{b}FUNCTION@{ub}
  Return which processor is present in the Amiga.

  Possible values:

  0: 68000
  1: 68010
  2: 68020
  3: 68030
  4: 68040
  6: 68060

@ENDNODE


@NODE ProgramPriority

    @{b}SYNTAX@{ub}
  OldPriority.b = ProgramPriority(NewPriority)

    @{b}COMMAND@{ub}
  It allows the programmer to set the priority of the program. It could
  be very useful when launching a task which uses a lot of cpu time
  during long periods (ie: rendering, compression...) and shouldn't lock
  the whole system. So set a priority of -1 and it will multitask very
  well!

  In another side, a game needs most system resources, so when doing a fast
  arcade game in a multitasking environment, you must set your task priority
  to 10 (at least). Don't forget to reduce it when no more action is needed
  (ie: menus, waiting...)

@ENDNODE

