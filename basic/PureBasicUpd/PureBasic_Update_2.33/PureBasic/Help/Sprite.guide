@DATABASE Sprite V1.00
$VER: PureBasic - Sprite library V1.00 (29.02.2000) © Fantaisie Software
@NODE MAIN "Sprite V1.00"

  @{b}PureBasic - Sprite library V1.00@{ub}

    'Sprites' are well known from game players. This is small pictures,
    sometimes called 'brushes', which can be displayed at any position
    on a screen. The sprites can move over graphics without destroy
    them, unlike other graphics operations which are destructives.
    PureBasic sprites are fully based on the 'Blitter', a very fast
    hardware chip which can move quickly tons of data. This library is
    very optimized and as a particularity: it works in parallel with
    the main CPU, the 680x0. So you can display some sprite and
    use the CPU to achieve other tasks like artificial intelligence.
    All these functions are 100% OS friendly and you can use it for
    any kind of programs.

  @{b}Commands summary in alphabetical order:@{ub}

    @{" AddBlockSprite       " LINK AddBlockSprite}
    @{" AddBufferedSprite    " LINK AddBufferedSprite}
    @{" AddSprite            " LINK AddSprite}
    @{" CreateSpriteBuffer   " LINK CreateSpriteBuffer}
    @{" CopySprite           " LINK CopySprite}
    @{" FlushSpriteBuffer    " LINK FlushSpriteBuffer}
    @{" FreeSprite           " LINK FreeSprite}
    @{" FreeSpriteBuffer     " LINK FreeSpriteBuffer}
    @{" InitSprite           " LINK InitSprite}
    @{" LoadSprite           " LINK LoadSprite}
    @{" LoadSprites          " LINK LoadSprites}
    @{" ResetSpriteServer    " LINK ResetSpriteServer}
    @{" RestoreBackground    " LINK RestoreBackground}
    @{" SaveSprites          " LINK SaveSprites}
    @{" SpriteDepth          " LINK SpriteDepth}
    @{" SpriteHandler        " LINK SpriteHandler}
    @{" SpriteHeight         " LINK SpriteHeight}
    @{" SpriteWidth          " LINK SpriteWidth}
    @{" StartSpriteServer    " LINK StartSpriteServer}
    @{" StopSpriteServer     " LINK StopSpriteServer}
    @{" UseSpriteBuffer      " LINK UseSpriteBuffer}
    @{" WaitSpriteServer     " LINK WaitSpriteServer}

  @{b}Example:@{ub}

    @{" Sprite example " LINK "PureBasic:Examples/Sources/WaponezII.pb/Main"}

@ENDNODE


@NODE AddBlockSprite

    @{b}SYNTAX@{ub}
  AddBlockSprite(#Sprite, x, y)

    @{b}COMMAND@{ub}
  Display the sprite at the specified position on the current sprite
  buffer. This function is the fastest way to display a sprite at
  the screen but has some limitations:

    + The sprite width must be a multiple of 16 (ie: 16, 32, 48, 64...)
    + The position 'x' must be a multiple of 16.
    + There is no transparent colour for this sprite.


  Note: If another sprite is being displayed, the function add this
  sprite to the server queue list and return immediately. You can
  never assume than this sprite is effectively display when this
  function return ! Use the command 'WaitSpriteServer()' if you
  want to be sure than this sprite is really displayed. See the
  'StartSpriteServer()' description for more informations about
  this asynchrone process.

@ENDNODE


@NODE AddBufferedSprite

    @{b}SYNTAX@{ub}
  AddBufferedSprite(#Sprite, x, y)

    @{b}COMMAND@{ub}
  Display the sprite at the specified position on the current sprite
  buffer. Before to display this sprite, the background which will be
  destroyed by the sprite is saved in the sprite buffer. You must
  allocate some memory to store the background data (this is done
  via 'CreateSpriteBuffer()'). The saved background can be restored
  later with the command 'RestoreBackground()'. The colour 0 of the
  sprite is considered as transparent. This command is not clipped,
  so be sure to display the sprite inside the BitMap.


  Note: If another sprite is being displayed, the function add this
  sprite to the server queue list and return immediately. You can
  never assume than this sprite is effectively display when this
  function return ! Use the command 'WaitSpriteServer()' if you
  want to be sure than this sprite is really displayed. See the
  'StartSpriteServer()' description for more informations about
  this asynchrone process.

@ENDNODE


@NODE AddSprite

    @{b}SYNTAX@{ub}
  AddSprite(#Sprite, x, y)

    @{b}COMMAND@{ub}
  Display the sprite at the specified position on the current sprite
  buffer. The background area is destroyed by this function. If you
  need to preserve the background, use 'AddBufferedSprite()' instead.
  The colour 0 of the sprite is considered as transparent. This
  command is not clipped, so be sure to display the sprite inside
  the BitMap.


  Note: If another sprite is being displayed, the function add this
  sprite to the server queue list and return immediately. You can
  never assume than this sprite is effectively display when this
  function return ! Use the command 'WaitSpriteServer()' if you
  want to be sure than this sprite is really displayed. See the
  'StartSpriteServer()' description for more informations about
  this asynchrone process.

@ENDNODE


@NODE CreateSpriteBuffer

    @{b}SYNTAX@{ub}
  CreateSpriteBuffer(#SpriteBuffer, Size, BitMapID)

    @{b}FUNCTION@{ub}
  Creates and initializes a new sprite buffer. 'BitMapID' is the identifiant
  of the bitmap on which you want to display the sprites. 'Size' is only useful
  when you display some sprites with the 'AddBufferedSprite()' command,
  when a background is saved. This 'Size' is function of the number of
  sprites displayed at the same time, their sizes, and of the bitmap
  depth. To calculate it, you can use the following rule:

    Size = (BitMapDepth * (SpriteWidth*SpriteHeight)*NumberOfSpriteDisplayed) / 8 + 1000

  This newly created sprite buffer becomes the current sprite buffer.

@ENDNODE


@NODE FreeSprite

    @{b}SYNTAX@{ub}
  FreeSprite(#Sprite)

    @{b}FUNCTION@{ub}
  Remove the specified sprite from memory. You can no more use it.

@ENDNODE


@NODE FreeSpriteBuffer

    @{b}SYNTAX@{ub}
  FreeSpriteBuffer(#SpriteBuffer)

    @{b}FUNCTION@{ub}
  Free the specified sprite buffer and release all its allocated memory.

@ENDNODE


@NODE InitSprite

    @{b}SYNTAX@{ub}
  Result = InitSpriteFile(#MaxSprites, #MaxDisplayedSprites, #MaxSpriteBuffers)

    @{b}FUNCTION@{ub}
  Init all the sprite environments for later use.  You  must  put  this
  function at the top of your source code if you want to use the sprite
  commands. You can test the result to see if the sprite environment
  has been correctly initialized. If not, quit the program or disable
  all the calls to the sprite related commands.

@ENDNODE


@NODE LoadSprite

    @{b}SYNTAX@{ub}
  Result = LoadSprite(#Sprite, FileName$)

    @{b}STATEMENT@{ub}
  Load the specified sprite into the memory for immediate use. The sprite
  must be in IFF/ILBM format (compressed or not, both cases are supported).
  If something wrong happens, 0 is returned.

@ENDNODE


@NODE ResetSpriteServer

    @{b}SYNTAX@{ub}
  ResetSpriteServer()

    @{b}STATEMENT@{ub}
  Once you have finished to display all the needed sprites, you have to reset
  the sprite server to tell the system than all is fine. Internally, the sprite
  queue list is reseted to 0, so all non yet displayed sprites will be never
  displayed. Use the 'WaitSpriteServer()' function to be sure than the sprite
  server has finished. A good solution is to reset the sprite server at every
  frame (for a game of course).

@ENDNODE


@NODE RestoreBackground

    @{b}SYNTAX@{ub}
  RestoreBackground()

    @{b}STATEMENT@{ub}
  Restore the previously destroyed background of the current sprite buffer.
  Each sprite buffer has its own background area. The background has been
  saved with the command 'AddBufferedSprite()'.

@ENDNODE


@NODE SpriteDepth

    @{b}SYNTAX@{ub}
  Result.w = SpriteDepth(#Sprite)

    @{b}STATEMENT@{ub}
  Return the depth of the specified sprite.

@ENDNODE


@NODE SpriteHeight

    @{b}SYNTAX@{ub}
  Result.w = SpriteHeight(#Sprite)

    @{b}STATEMENT@{ub}
  Return the height in pixel of the specified sprite.

@ENDNODE


@NODE SpriteWidth

    @{b}SYNTAX@{ub}
  Result.w = SpriteWidth(#Sprite)

    @{b}STATEMENT@{ub}
  Return the width in pixel of the specified sprite.

@ENDNODE


@NODE StartSpriteServer

    @{b}SYNTAX@{ub}
  StartSpriteServer()

    @{b}STATEMENT@{ub}
  Allocate the 'Blitter' chip ressources in OS compliant way and intialize
  the server for immediate use. Once you have called this function, you can
  use quietly any of the AddSprite() functions. But remember than the
  Blitter is owned only by your program and the whole OS can no more use
  it (to draw window, text...). The graphics are freezed, so don't forget to
  stop the server as soon as you don't need anymore of the sprite
  functionnality. A good idea is to start/stop the server at every frame
  so you will ensure a minimum for the OS survive... This function is of course
  very fast.


  Some additional notes about the sprite server (for advanced users):

  The server can be see as a queue list and when you add a sprite to
  this list there is two possibility: the list is empty, so the sprite
  is displayed immediately, or the list has some entries and your sprite
  is added at the end of the list. All the entry are processed one
  after one, in the right order. The good point on this system is than
  the main CPU doesn't need to wait until the 'Blitter' finishes his work.
  So we gain substantial CPU power against other classic solutions.
  To be sure than all your sprites has been displayed, simply use the
  'WaitSpriteServer()' command.

@ENDNODE


@NODE StopSpriteServer

    @{b}SYNTAX@{ub}
  StopSpriteServer()

    @{b}STATEMENT@{ub}
  Stop the sprite server activity and release immediately the 'Blitter'
  chip to the AmigaOS. If some sprites haven't been displayed, there are
  lost. This command is very fast.

@ENDNODE


@NODE UseSpriteBuffer

    @{b}SYNTAX@{ub}
  UseSpriteBuffer(#SpriteBuffer)

    @{b}STATEMENT@{ub}
  Change the current sprite buffer with the supplied one.

@ENDNODE


@NODE WaitSpriteServer

    @{b}SYNTAX@{ub}
  WaitSpriteServer()

    @{b}STATEMENT@{ub}
  Wait until the sprite server has finished to display all the sprites.
  This command is needed unless you are sure than all your sprites
  has been displayed. This command should be tipically called at the
  end of the main loop, when all other 'CPU' only functions have been
  processed. It's one of the advantage of the parallel working: you can
  use the CPU while the sprite are displayed.

@ENDNODE


@NODE LoadSprites

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.l = LoadSprites(#@{b}Sprite@{ub}.l,#@{b}Sprite@{ub}.l,@{b}FileName@{ub}$,@{b}Chip/Fast@{ub})

    @{b}FUNCTION@{ub}
  Load in some sprites from disk, the file
  must been saved with SaveSprites().

  The new sprite objects will be loaded over
  any old ones, so make sure it's free where
  you decide to put them.

  @{b}Sprite@{ub}
  This is the first sprite object that will be
  initialized with the first sprite from file.

  @{b}Sprite@{ub}
  The last sprite object that will be initialized
  from sprite file, it don't have to be the last
  sprite in the sprite file.

  @{b}FileName@{ub}
  The full path to the sprite file.

  @{b}Chip/Fast@{ub}
  #MEMF_CHIP (2) or #MEMF_FAST (4).

  @{b}Result@{ub}
  This show how many sprites that have been
  successfully loaded.

  If there is some uninitialized sprite objects
  somewhere in the sprite file they will not be
  counted in here.
@ENDNODE


@NODE SaveSprites

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.l = SaveSprites(#@{b}Sprite@{ub}.l,#@{b}Sprite@{ub}.l,@{b}FileName@{ub}$)

    @{b}FUNCTION@{ub}
  To save a bunch of sprite objects to
  disk.

  @{b}Sprite@{ub}
  Start to save from this sprite object.

  @{b}Sprite@{ub}
  This is the last sprite object that
  will be saved to the sprite file.

  @{b}FileName@{ub}
  The full path to the sprite file.

  @{b}Result@{ub}
  This show how many sprites that have been
  successfully saved.

  If there is some uninitialized sprite
  objects somewhere they will not be
  counted in here.
@ENDNODE


@NODE CopySprite

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.l = CopySprite(#@{b}Sprite@{ub}.l,#@{b}Sprite@{ub}.l,@{b}Chip/Fast@{ub})

    @{b}FUNCTION@{ub}
  To make a complet copy of a sprite object
  then call this function.

  Could be used to quickly move sprites
  to chipmem from a buffer of sprites
  that recides in fastmem.

  @{b}Sprite@{ub}
  Make a copy out of this sprite
  object.

  @{b}Sprite@{ub}
  The copy will end up in this
  sprite object.

  @{b}Chip/Fast@{ub}
  #MEMF_CHIP (2) or #MEMF_FAST (4).

  @{b}Result@{ub}
  TRUE if the copy have been done.
@ENDNODE


@NODE FlushSpriteBuffer

    @{b}SYNTAX@{ub}
  FlushSpriteBuffer(#@{b}SpriteBuffer@{ub}.l)

    @{b}STATEMENT@{ub}
  Use this statement to clear a spritebuffer
  from the background data.

  @{b}SpriteBuffer@{ub}
  The spritebuffer to flush.
@ENDNODE


@NODE SpriteHandler

    @{b}SYNTAX@{ub}
  SpriteHandler(#@{b}Sprite@{ub}.l,@{b}x@{ub}.w,@{b}y@{ub}.w)

    @{b}STATEMENT@{ub}
  Call this statement to give the sprite
  x and y offset values from upper left
  corner.

  @{b}Sprite@{ub}
  The sprite object to give a
  new x and/or y handler.

  @{b}x@{ub}
  The x offset.

  @{b}y@{ub}
  The y offset.
@ENDNODE
