'IFF-LIBRARY - Basicheader & Doc
'based on the ifflib.doc V22.1
'Basic-conversion by Steffen Leistner
'IFF-Library is
'COPYRIGHT (C) 1987-1992 BY CHRISTIAN A. WEBER, BRUGGERWEG 2,
'CH-8037 ZUERICH, SWITZERLAND.
'FREEWARE. USE AT YOUR OWN RISK.

REM $UNDERLINES
REM $INCLUDE iff.bc
LIBRARY DECLARE "iff.library"

DECLARE SUB IFFLCloseIFF& LIBRARY

'    CloseIFF -- CLOSE an IFF file and deallocate buffers
'
'    SYNOPSIS
'        CloseIFF( iffhandle )
'
'    FUNCTION
'        Returns the memory previously allocated by OpenIFF().
'
'    INPUTS
'        iffhandle - IFF file handle, from OpenIFF()
'
'    RESULTS
'        For now, always results TRUE (this may change in the future).
'
'    SEE ALSO
'        OpenIFF()


DECLARE FUNCTION IFFLCompressBlock& LIBRARY

'    CompressBlock -- Compress a memory block
'
'    SYNOPSIS
'        result = CompressBlock( source, destination, size, mode )
'
'    FUNCTION
'        Compress the memory block using the appropriate compression mode.
'        If the compressed data would become longer than the uncompressed,
'        an error is returned.
'
'    INPUTS
'        source      - Pointer to data to compress
'        destination - Target address for compression
'        size        - Number of data bytes to compress
'        mode        - Compression mode. Currently, the following modes
'                      are supported:
'
'                      COMPR_NONE     - Vanilla copy
'                      COMPR_BYTERUN1 - CmpByteRun1 (ILBM BODY data)
'                      COMPR_FIBDELTA - Fibonacci Delta (8SVX BODY data)
'
'    RESULTS
'        Length of compressed data or 0 if an error occurred.
'        IFFError() returns ERROR_BADCOMPRESSION if you ask for
'        an unsupported compression mode.
'
'    SEE ALSO
'        DecompressBlock()


DECLARE FUNCTION IFFLDecodePic& LIBRARY

'    DecodePic -- decode the BODY of an ILBM file into a BitMap
'
'    SYNOPSIS
'        success = DecodePic( iff, bitmap )
'
'    FUNCTION
'        Decodes and decompresses a picture into the user supplied BitMap.
'        If the picture is larger than your BitMap's planes, it will be
'        truncated. If your BitMap is larger than the picture, the picture
'        will be drawn into the top left corner of your BitMap.
'        If the picture has less planes than the BitMap, the unused planes
'        are NOT touched by this routine, so you may wish to clear them
'        before calling DecodePic(). If the picture has more planes
'        than your BitMap, the surplus planes of the picture are ignored.
'
'    INPUTS
'        iff    - IFF file handle, from OpenIFF()
'        bitmap - Pointer to a properly initialized BitMap structure:
'                 bm_Planes[] must point to valid BitPlanes,
'                 bm_Depth contains the number of planes.
'                 bm_Width and bm_Height must be set according to the
'                 size of your bit planes.
'
'    RESULTS
'        Non-zero if successful, zero if error. Call IFFError() to
'        know the reason of the failure
'
'    NOTE
'        This routine needs at least 650 bytes of stack space


DECLARE FUNCTION IFFLDecompressBlock& LIBRARY

'    DecompressBlock -- Decompress a memory block
'
'    SYNOPSIS
'        result = DecompressBlock( source, destination, size, mode )
'
'    FUNCTION
'        Decompress the memory block using the appropriate Decompression mode.
'        If the Decompressed data would become longer than the supplied size,
'        an error is returned.
'
'    INPUTS
'        source      - Pointer to data to decompress
'        destination - Target address for decompression
'        size        - Number of _DECOMPRESSED_ data bytes
'        mode        - Compression mode. Currently, the following modes
'                      are supported:
'
'                      COMPR_NONE     - Vanilla copy
'                      COMPR_BYTERUN1 - CmpByteRun1 (ILBM BODY data)
'                      COMPR_FIBDELTA - Fibonacci Delta (8SVX BODY data)
'
'    RESULTS
'        Length of uncompressed data or 0 if an error occurred.
'        IFFError() returns ERROR_BADCOMPRESSION if you ask for
'        an unsupported compression mode.
'
'    SEE ALSO
'        CompressBlock()


DECLARE FUNCTION IFFLFindChunk& LIBRARY

'   FindChunk -- find an IFF-chunk
'
'   SYNOPSIS
'        chunk = FindChunk( iff, chunkname )
'
'   FUNCTION
'        Find a specific chunk in an IFF file
'
'   INPUTS
'        iff       - IFF file handle, from OpenIFF()
'        chunkname - 4 characters packed ASCII ('BODY', 'VHDR' ...)
'                    if chunkname is 0, FindChunk() returns a pointer to the
'                    first byte after the end of the current FORM. This can
'                    be used by ANIM readers for jumping from FORM to FORM.
'
'   RESULTS
'        Pointer to the beginning of the chunk (that means to the chunk
'        name itself, followed by the chunk size); zero if chunk not found
'
'   BUGS
'        none known
'
'   SEE ALSO
'        GetBMHD(), GetColorTab()


DECLARE FUNCTION IFFLGetBMHD& LIBRARY

'    GetBMHD -- find a BitMapHeader of an IFF-file
'
'    SYNOPSIS
'        header = GetBMHD( iff )
'
'    FUNCTION
'        Returns a pointer to a BMHD (BitMapHeader) structure as defined
'        in iff.h and iff.i
'
'    INPUTS
'        iff - IFF file handle, from OpenIFF()
'
'    RESULTS
'        Pointer to the BitMapHeader, or NULL if no BMHD chunk found
'
'    SEE ALSO
'        FindChunk(), GetColorTab()


DECLARE FUNCTION IFFLGetColorTab& LIBRARY

'    GetColorTab -- find a CMAP and convert it to a ColorTable
'
'    SYNOPSIS
'        count = GetColorTab( iff, colortable )
'
'    FUNCTION
'        Searches the CMAP chunk of an IFF file and converts it, if it's
'        there, to an Amiga color table structure. This colortable can
'        directly be used as a parameter for the LoadRGB4() function.
'
'    INPUTS
'        iff        - IFF file handle, from OpenIFF()
'        colortable - Pointer to a block of memory which must be large
'                     enough to hold the colortable (2 bytes per color).
'                     Must be WORD aligned.
'
'    RESULT
'        Number of colors actually found, or zero if the file has no
'        CMAP chunk
'
'    SEE ALSO
'        FindChunk(), GetBMHD()


DECLARE FUNCTION IFFLGetViewModes& LIBRARY

'    GetViewModes() -- Get Amiga-specific ViewModes
'
'    SYNOPSIS
'        viewmodes = GetViewModes( iff )
'
'    FUNCTION
'        Searches the IFF file for a 'CAMG' chunk which holds the view modes
'        information. If there is no CAMG chunk, the view modes are calcu-
'        lated using the information in the BitMapHeader structure.
'        You can directly put the low WORD of the result of a call to
'         GetViewModes() into the ns_ViewModes field of a NewScreen
'        structure, or you can use the whole ULONG for the SA_DisplayID tag
'        under OS 2.x.
'
'    INPUTS
'        iff - IFF file handle, from OpenIFF()
'
'    RESULT
'        viewmodes - ULONG containing the view modes (HAM, LACE, HIRES ...)
'        All forbidden bits are masked out, as suggested by CBM.
'        Under Kickstart V1.3, only the lower WORD is used.
'
'    BUGS
'        If the IFF file has no CAMG chunk and 6 bitplanes, the HAM bit
'        will be set. This is not always correct since the picture could
'        be in the Extra Halfbrite mode. You can load such Halfbrite
'        pictures into DPaint III and save them again, DPaint will generate
'        the correct CAMG chunk.
'
'    SEE ALSO
'        <graphics/displayinfo.bc>


DECLARE FUNCTION IFFLIFFError& LIBRARY

'    IFFError -- Get detailed error descrpition after an error
'
'    SYNOPSIS
'        error = IFFError()
'
'    FUNCTION
'        If one of the iff.library functions returns zero, you can call
'        IFFError() to know the reason for the failure. An error
'        code is returned, please refer to the files 'iff.h' or 'iff.i'
'        for the complete list of errors.
'
'    INPUTS
'        none
'
'    RESULT
'        Error-number generated by the latest function call, or zero if
'        no error.
'
'    BUGS
'        If you don't close the IFF library at the end of your program
'        (using CloseLibrary()) the error node will not be freed. The
'        same task will then not be able to re-open the iff.library.
'        (This is not a bug, it's a feature ;-))
'
'    SEE ALSO
'        <iff.bc>


DECLARE FUNCTION IFFLModifyFrame& LIBRARY

'    ModifyFrame -- Modify an anim frame using a DLTA chunk
'
'    SYNOPSIS
'        success = ModifyFrame( modifyform, bitmap )
'
'    FUNCTION
'        Uses the DLTA chunk of the supplied FORM to modify the planes-data
'        of the bitmap. Usually, playback of ANIMs will require two buffers,
'        and double-buffering between them. So the data in the bitmap must
'        be two frames back, and the DLTA chunk is used to modify the hidden
'        frame to the next frame to be shown.
'
'    INPUTS
'        modifyform - pointer to the FORM containing the actual DLTA chunk
'        bitmap     - Pointer to a properly initialized BitMap structure,
'                     the planes must contain the image which was displayed
'                     to frames back (using double-buffering)
'
'    RESULT
'        Non-zero if OK, 0 if error; call IFFError() to know the reason
'        of the failure
'
'    RESTRICTIONS
'        Currently, only compression type 5 (Byte Vertical Delta Mode) is
'        implemented. If you have animations which use modes 1 to 4, try
'        loading them with DPaint III and saving them again.
'        Sculpt-Animate ('J' type ANIM, Movie format) support will be
'        added soon.
'        I will implement some more compression types upon request.
'
'    NOTE
'        This routine needs at least 820 bytes of stack.
'        The size of the bitmap is not checked by this routine, the planes
'        must have at least the size described in the BMHD of the anim
'        file.
'
'    SEE ALSO
'        IFFError()


DECLARE FUNCTION IFFLOpenIFF& LIBRARY

'   OpenIFF -- Open an IFF file for reading or writing
'
'   SYNOPSIS
'        iff = OpenIFF( filename, mode )
'
'   FUNCTION
'        If mode == MODE_READ:
'          This function opens a file on a disk and looks whether it's an IFF
'          file or not. If it is an IFF file, memory is allocated and the file
'          is read into memory.
'
'         New for V22:
'          If xpkmaster.library is installed in your system, OpenIFF()
'          will be able to read and decompress compressed IFF files, if they
'          use one of the xpk standard compression schemes.
'
'         If mode == MODE_WRITE:
'          Initializes an IFF file handle for writing. You may create chunks
'          with PushChunk() and PopChunk(), and you can write data
'          using the WriteChunkBytes() routine.
'
'   INPUTS
'        filename - Pointer to a null-terminated string
'        mode     - MODE_READ:  Open file for reading
'                   MODE_WRITE: Open file for writing
'
'   RESULT
'        iff - IFF handle. Making assumptions about the internal structure
'              of this handle is unwise, and may break in the future.
'              If this function fails, NULL will be returned, and you may
'              call IFFError() to know the reason of the failure.
'
'   SEE ALSO
'        CloseIFF(), PushChunk(), PopChunk(),
'        WriteChunkBytes(), IFFError()
'
'   BUGS
'        None known


DECLARE FUNCTION IFFLPopChunk& LIBRARY

'    PopChunk -- Pop top context node off context stack.
'
'    SYNOPSIS
'        success = PopChunk( iff )
'
'    FUNCTION
'        Pops top context chunk and updates the file accordingly.
'        The function is normally called only for writing files and signals
'        the end of a chunk.
'
'    INPUTS
'        iff - IFF handle
'
'    RESULTS
'        Non-zero  if successful or 0 if not successful (call IFFError()
'        to get an ERROR_... error code.
'
'    SEE ALSO
'        PushChunk(), WriteChunkBytes()


DECLARE FUNCTION IFFLPushChunk& LIBRARY

'    PushChunk -- Push a new context node on the context stack.
'
'    SYNOPSIS
'        success = PushChunk( iff, type, id )
'
'    FUNCTION
'        Pushes a new context node on the context stack by reading it from the
'        stream if this is a read file, or by creating it from the passed
'        parameters if this is a write file.  Normally this function is only
'        called in write mode, where the type and id codes specify the new
'        chunk to create.  If this is a leaf chunk, i.e. a local chunk inside
'        a FORM or PROP chunk, then the type argument is ignored.
'
'    INPUTS
'        iff  - IFF handle
'        type - chunk type specifier (ex. ILBM) (ignored for read mode or
'               leaf chunks).
'        id   - chunk id specifier (ex. CMAP) (ignored for read mode).
'
'    RESULTS
'        Non-zero if successful or 0 if not successful (call IFFError()
'        to get an ERROR_... error code.
'
'    SEE ALSO
'        PopChunk(), WriteChunkBytes()


DECLARE FUNCTION IFFLSaveBitMap& LIBRARY

'    SaveBitMap -- save the planes of a BitMap as an IFF-file
'
'    SYNOPSIS
'        result = SaveBitMap( filename, bitmap, colortable, flags )
'
'    FUNCTION
'        Save the planes of a BitMap as an IFF-file, optionally with a
'        colortable. The IFF file will contain the following chunks:
'
'        FORM  -  The IFF header, with the type ILBM
'        BMHD  -  The BitMap Header structre
'        CMAP  -  The color map, this chunk is omitted if colortable is zero
'        CAMG  -  The Amiga ViewModes word, contains the special ViewModes
'                 information (HAM, LACE, HIRES ...)
'        BODY  -  The (crunched or uncompressed) picture
'
'    INPUTS
'        filename    - Name of the IFF file to create
'        bitmap      - Pointer to the BitMap holding your picture
'        colortable  - Pointer to an Amiga ColorTable structure or zero
'                      (if colortable = 0, no CMAP chunk will be generated).
'        flags       - Bit 0: 1 = Use the "CmpByteRun1" compression algorythm,
'                             0 = Save the file uncompressed
'                      Bit 7: 1 = This is a HAM (Hold and modify) picture
'                             0 = This is a normal or Extra-Halfbrite picture
'
'    RESULT
'        Non-zero if successful, 0 if an error occurred. You can then call
'        IFFError() to know more about the reason of the failure.
'
'    NOTE
'        Up to V19 this routine needs at least 650 bytes of stack space
'
'    SEE ALSO
'        SaveClip()


DECLARE FUNCTION IFFLSaveClip& LIBRARY

'    SaveClip -- save a part of a BitMap as an IFF-file
'
'    SYNOPSIS
'        result = SaveClip( filename, bitmap, coltab, flags, xoff, yoff, width, height )
'
'    FUNCTION
'        Save a part of a BitMap as an IFF file
'
'    INPUTS
'        filename    - Name of the IFF file to create
'        bitmap      - Pointer to the BitMap holding your picture
'        colortable  - Pointer to an Amiga ColorTable structure or zero
'                      (if colortable = 0, no CMAP chunk will be generated).
'        flags       - Bit 0: 1 = Use the "CmpByteRun1" compression algorythm,
'                             0 = Save the file uncompressed
'                     Bit 7: 1 = This is a HAM (Hold and modify) picture
'                             0 = This is a normal or Extra-Halfbrite picture
'        xoff        - X offset of the clip to be saved (bytes from the left)
'        yoff        - Y offset of the clip to be saved (lines from the top)
'        width       - width in bytes of the rectangle
'        height      - height in lines of the rectangle
'
'    RESULTS
'        Non-zero if successful, 0 if an error occurred. You can then call
'        IFFError() to know more about the reason of the failure.
'
'    NOTE
'        Up to V19 this routine needs at least 650 bytes of stack space
'
'    BUGS
'        The width of the rectangle will be truncated to WORD boundaries,
'        because DPAINT wants it!
'
'    SEE ALSO
'        SaveBitMap()


DECLARE FUNCTION IFFLWriteChunkBytes& LIBRARY

'    WriteChunkBytes -- Write data into the current chunk
'
'    SYNOPSIS
'        success = WriteChunkBytes( iff, buf, size )
'
'    FUNCTION
'        Writes "size" bytes from the specified buffer into the current chunk.
'
'    INPUTS
'        iff   - IFF file handle, from OpenIFF().
'        buf   - pointer to buffer area with bytes to be written.
'        size  - number of bytes to write.
'
'    RESULT
'        Non-NULL if the write was successful, or NULL if an error
'        occurred. Call IFFError() to know what's going on.
'
'    SEE ALSO
'        PushChunk(), PopChunk(), IFFError()


DECLARE FUNCTION IFFLNewOpenIFF& LIBRARY

'    OldNewOpenIFF -- allocate memory for an IFF-file and read it
'
'    SYNOPSIS
'        ifffile = OldNewOpenIFF( filename, memattr )
'
'    FUNCTION
'        THIS FUNCTION IS OBSOLETE. USE OpenIFF() INSTEAD.
'
'    INPUTS
'        filename - Pointer to a null-terminated string
'        memattr  - Memory requirements as used for Exec's AllocMem(),
'                   such as MEMF_CHIP, MEMF_PUBLIC ...
'                   (MEMF_CLEAR is not necessary)
'
'    RESULT
'        ifffile - 'FileHandle', points to the beginning of the IFF file
'        ("FORM...."), Zero if unsuccessful. Call IFFError() to get
'        the reason of the failure.
'
'    SEE ALSO
'        OpenIFF(), CloseIFF(), IFFError()
'
'    BUGS
'        None known


DECLARE FUNCTION IFFLOldOpenIFF& LIBRARY

'    OldOpenIFF -- allocate memory for an IFF-file and read it
'
'    SYNOPSIS
'        ifffile = OldOpenIFF( filename )
'
'    FUNCTION
'        THIS FUNCTION IS OBSOLETE. USE OpenIFF() INSTEAD.
'
'    INPUTS
'        filename - Pointer to a null-terminated string
'
'    RESULT
'        ifffile - 'FileHandle', points to the beginning of the IFF file
'        ("FORM...."), 0 if unsuccessful. Call IFFError() to get the
'        reason of the failure.
'
'    BUGS
'        None
'
'    SEE ALSO
'        OpenIFF(), CloseIFF(), IFFError()