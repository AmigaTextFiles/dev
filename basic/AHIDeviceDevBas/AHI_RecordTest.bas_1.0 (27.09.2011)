' *********************************************************************
'                           AHI_RecordTest.bas
'                 by/de Copyright 2011 Dámaso D. Estévez
'                    {correoamidde-aminet000,yahoo,es}
'           AmiSpaTra - http://www.xente.mundo-r.com/amispatra/
'
'            Based over the RecordTest.c code by Martin Blom.
'             All rights reserved over this derivative work:
'                  my Hisoft Basic developpers package.
'        Forbidden to remove ALL legal/copyrights remarks included
'             in this package: if you create a derivate work,
'                  you MUST to include all legal notes.
'
'                Records sound via AHI to the default output
'    (use the redirection symbol as here: RecordTest > mysample.raw).
'                                  ----
'           Basado en el código de RecordTest.c de Martin Blom.
'       Todos los derechos reservados sobre este trabajo derivado:
'     mi paquete para desarrolladores que programen con Hisoft Basic.
'           Está prohibido eliminar cualquier comentario o nota
'     de autoría/legal de este paquete: si crea un trabajo derivado
'         HA DE INCLUIR OBLIGATORIAMENTE TODAS LAS NOTAS LEGALES.
'
'               Digitaliza sonido a través de AHI enviándolo
'                   a la salida por defecto del sistema
'          (o sea, ha de utilizar el operador de redirección,
'            algo así como "AHI_RecordText > mimuestra.raw").
' *********************************************************************

OPTION BASE 1

' ---------------------------------------------------------------------
'        Compiler's metacommands (see the Hisoft Basic Manual)
' Metacomandos para el compilador (consulte el manual del Hisoft Basic)
' ---------------------------------------------------------------------
REM $NOWINDOW
REM $NOLIBRARY
REM $NOBREAK

' ---------------------------------------------------------------------
'                Include files / Ficheros de inclusión
' ---------------------------------------------------------------------

'         OS / SO
' ------------------------
REM $include exec.bh
REM $include dos.bh

' AHI system / Sistema AHI
' ------------------------
REM $include ahi.bh

' ---------------------------------------------------------------------
'    From/De:  http://aminet.net/package/dev/basic/AST_HBRoutines
'
'            Obtain a command line interface's argument
'                  and the program name (Shell).
'
'     Obtiene un argumento de la interfaz de línea de comandos
'                 y el nombre del programa (Shell).
' ---------------------------------------------------------------------
REM $include BLib_AST/SGetArg.bas
REM $include BLib_AST/ArgvZero.bas

' ---------------------------------------------------------------------
'              C= string version / Cadena de versión de C=
' ---------------------------------------------------------------------

vstring$ = "$VER: AHI_RecordTest 1.0 (27.09.2011) by Dámaso 'AmiSpaTra' Domínguez based over the C code wrote by Martin Blom "+CHR$(0)

' ---------------------------------------------------------------------
'             (Global) constants / Constantes (globales)
' ---------------------------------------------------------------------

CONST FREQUENCY&    =   8000&
CONST BUFFERSIZE&   =  20000&

' ---------------------------------------------------------------------
'                  Global vars / Variables globales
' ---------------------------------------------------------------------

AHIDevice& = -1&

'     Pointers' table
'    Tabla de punteros
' ------------------------
DIM ptr&(5)

'  Constants for to identify the elements
' Constantes para identificar los elementos
' -----------------------------------------
CONST AHIRT_MSGPORT% = 1%
CONST AHIRT_IO%      = 2%
CONST AHIRT_BUFFER1% = 3%
CONST AHIRT_BUFFER2% = 4%

' ---------------------------------------------------------------------
'              Opening libraries / Abriendo bibliotecas
' ---------------------------------------------------------------------
LIBRARY OPEN "exec.library"
LIBRARY OPEN "dos.library", 36&

' *********************************************************************
'               Functions and subroutines's declarations
'                Declaración de funciones y subrutinas
' *********************************************************************

DECLARE FUNCTION init&(AHIDevice&, ptr&())
DECLARE FUNCTION main&(ptr&())
DECLARE SUB      clean(AHIDevice&, ptr&())

' ********************************************************************
'                     Main code / Código principal
' ********************************************************************

BREAK STOP

' Allocating resources
' Reservando recursos
' --------------------

IF init&(AHIDevice&, ptr&()) = RETURN_OK& THEN

	'    The real main code
	' El código principal real
	' ------------------------
	rc& = main&(ptr&())

END IF

' Point of exit / Punto de salida
' --------------------------------
Salida:

'       Releasing resources
'       Liberando recursos
' --------------------------------
clean AHIDevice&, ptr&()

BREAK ON

LIBRARY CLOSE

STOP rc&

' ***************************************************************************

FUNCTION init&(AHIDevice&, ptr&())

	' I'm a pesimist... the routine will fail
	'  Soy un pesimista... la rutina fallará
	' ---------------------------------------
	init& = RETURN_ERROR&

	' Creating the port / Creación del puerto
	' ---------------------------------------
	ptr&(AHIRT_MSGPORT%) = CreateMsgPort&

	IF ptr&(AHIRT_MSGPORT%) = NULL& THEN
		PRINT "Failed to create the MsgPort!"
		PRINT "¡Se ha fracasado el crear el puerto de mensajes!"
		EXIT FUNCTION
	END IF

	' Creating the IORequest / Creación de la petición E/S
	' ----------------------------------------------------
	ptr&(AHIRT_IO%) = CreateIORequest&(ptr&(AHIRT_MSGPORT%), AHIRequest_sizeof%)

	IF ptr&(AHIRT_IO%) = NULL& THEN
		PRINT "Failed to create the IORequest!"
		PRINT "¡Se ha fracasado el crear la petición E/S!"
		EXIT FUNCTION
	END IF

	POKEW ptr&(AHIRT_IO%)+ahir_Version%, 4%

	' Opening the device / Apertura del dispositivo
	' ---------------------------------------------
	AHIDevice& = OpenDevice&(SADD("ahi.device"+CHR$(0)), 0, ptr&(AHIRT_IO%), 0)

	IF AHIDevice& = -1& THEN
		PRINT "Failed to open 'ahi.device' v4+!"
		PRINT "¡Se ha fracasado al abrir el dispositivo 'ahi.device' v4+!"
		EXIT FUNCTION
	END IF

	' Allocating memory blocks / Reserva de bloques de memoria
	' --------------------------------------------------------
	ptr&(AHIRT_BUFFER1%) = AllocMem&(BUFFERSIZE&, MEMF_ANY&)
	ptr&(AHIRT_BUFFER2%) = AllocMem&(BUFFERSIZE&, MEMF_ANY&)

	IF ptr&(AHIRT_BUFFER1%) = NULL& OR ptr&(AHIRT_BUFFER2%) = NULL& THEN
		PRINT "Failed to allocate free mem!"
		PRINT "¡Se ha fracasado al reservar memoria!"
		EXIT FUNCTION
	END IF

	' All done! / ¡Todo hecho!
	' ------------------------
	init& = RETURN_OK&

END FUNCTION

' *********************************************************************

FUNCTION main&(ptr&())
	LOCAL dummy&, signals&, long&
	LOCAL p1&, p2&

	' I'm a pesimist... the routine will fail
	'  Soy un pesimista... la rutina fallará
	' ---------------------------------------
	main& = RETURN_ERROR&

	'               Only from CLI
	' Sólo desde la interfaz de línea de comandos
	' -------------------------------------------
	IF PEEKL(SYSTAB+8) <> 0 THEN
		BEEP
		EXIT FUNCTION
	END IF

	' Some vars / Algunas variables
	' -----------------------------
	p1&       = ptr&(AHIRT_BUFFER1%)
	p2&       = ptr&(AHIRT_BUFFER2%)

	signals&  = NULL&
	long&     = NULL&

	'      Filling the struct for first read
	' Rellenando la estructura para la primera lectura
	' ------------------------------------------------
	POKEW ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Command%,  CMD_READ&
	POKEL ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Data%,     ptr&(AHIRT_BUFFER1%)
	POKEL ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Length%,   BUFFERSIZE&
	POKEL ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Offset%,   0&
	POKEL ptr&(AHIRT_IO%)+ahir_Frequency%,                FREQUENCY&
	POKEL ptr&(AHIRT_IO%)+ahir_Type%,                     AHIST_M8S&

	IF NOT(DoIO&(ptr&(AHIRT_IO%))) THEN

		dummy& = SetIoErr&(0&)

		DO

			long& = PEEKL(ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Actual%)

			' For second read / Para la segunda lectura
			' -----------------------------------------
			POKEL ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Data%,   p2&
			POKEL ptr&(AHIRT_IO%)+ahir_Std%+IOStdReqio_Length%, BUFFERSIZE&
			POKEL ptr&(AHIRT_IO%)+ahir_Frequency%,              FREQUENCY&
			POKEL ptr&(AHIRT_IO%)+ahir_Type%,                   AHIST_M8S&

			SendIO ptr&(AHIRT_IO%)

			'         Writing the first buffer to stdout,
			'            while the second is filled
			'
			'     Escribiendo el contenido del primer tampón
			' en la salida estándar, mientras se rellena el segundo
			' -----------------------------------------------------
			IF xWrite&(xOutput&, p1&, long&) <> long& THEN
				EXIT LOOP
			END IF

			' Wait until the last buffer is finished (=>the new buffer is started)
			'
			'            Aguarda a que el último tampón haya terminado,
			'        lo que implica que se haya comenzado con el nuevo tampón
			' -------------------------------------------------------------------
			signals& = xWait&(SIGBREAKF_CTRL_C& OR (1& << PEEKB(ptr&(AHIRT_MSGPORT%)+mp_SigBit%)))

			'                   Break support via AmigaOS
			' Soporte de la interrupción del usuario a través del AmigaOS
			' -----------------------------------------------------------
			IF (signals& AND SIGBREAKF_CTRL_C&) THEN
				dummy& = SetIoErr&(ERROR_BREAK&)
				EXIT FUNCTION
			END IF

			'     Remove the reply
			'  Se borra la respuesta
			' -----------------------
			IF WaitIO&(ptr&(AHIRT_IO%)) THEN
				dummy& = SetIoErr&(ERROR_WRITE_PROTECTED&)
				EXIT LOOP
			END IF

			SWAP p1&, p2&

		LOOP

		AbortIO ptr&(AHIRT_IO%)
		dummy& = WaitIO&(ptr&(AHIRT_IO%))

	END IF

	IF IoErr& THEN
		dummy& = PrintFault&(IoErr&, SADD(ArgvZero$+CHR$(0)))
	ELSE
		main& = RETURN_OK&
	END IF

END FUNCTION

' *********************************************************************

SUB clean(AHIDevice&, ptr&())

	IF ptr&(AHIRT_BUFFER2%) THEN
		FreeMem ptr&(AHIRT_BUFFER2%), BUFFERSIZE&
		ptr&(AHIRT_BUFFER2%)  = NULL&
	END IF

	IF ptr&(AHIRT_BUFFER1%) THEN
		FreeMem ptr&(AHIRT_BUFFER1%), BUFFERSIZE&
		ptr&(AHIRT_BUFFER1%)  = NULL&
	END IF

	IF AHIDevice& = NULL& THEN
		CloseDevice ptr&(AHIRT_IO%)
		AHIDevice& =   -1&
	END IF

	IF ptr&(AHIRT_IO%) THEN
		DeleteIORequest ptr&(AHIRT_IO%)
		ptr&(AHIRT_IO%)       = NULL&
	END IF

	IF ptr&(AHIRT_MSGPORT%) THEN
		DeleteMsgPort ptr&(AHIRT_MSGPORT%)
		ptr&(AHIRT_MSGPORT%)  = NULL&
	END IF

END SUB

' *********************************************************************
