@DATABASE BitMap V1.00
$VER: PureBasic - BitMap library V1.00 (21.09.1999) © Fantaisie Software
@NODE MAIN "BitMap V1.00"

  @{b}PureBasic - BitMap library V1.00@{ub}

    Un 'BitMap' est une zone de mémoire utilisée pour stocker
    et/ou pour afficher des informations graphiques. Sur Amiga,
    le système natif d'affichage (OCS/ECS/AGA) utilise ce mode
    d'affichage dit par plans ('Planar') car chaque pixel est
    codé sur plusieurs plans (Si l'ecran a plus de 2 couleurs).
    Dans un 'BitMap', on peut trouver 1 ou plusieurs 'BitPlanes'.
    Chaque 'BitPlane' a une surface equivalente à la taille
    de l'écran (example: 320*200) et peut contenir pour chaque
    point, soit 0, soit 1 (un bit est un booléen, ne pouvant
    prendre que les valeurs 0 ou 1). Si on superpose plusieurs
    'BitPlanes' les uns sur les autres, on peut avoir plus de
    possibilités pour chaque point: Pour 4 'BitPlanes' on aura
    2^4 possibilité soit 16 valeurs differentes par points
    (dans notre cas, 16 couleurs differentes).

  @{b}Commandes disponibles:@{ub}

    @{" AllocateBitMap        " LINK AllocateBitMap}
    @{" AllocateLinearBitMap  " LINK AllocateLinearBitMap}
    @{" BitMapID              " LINK BitMapID}
    @{" BitMapRastPort        " LINK BitMapRastPort}
    @{" FreeBitMap            " LINK FreeBitMap}
    @{" InitBitMap            " LINK InitBitMap}
    @{" UseBitMap             " LINK UseBitMap}
    @{" ShowBackBitMap        " LINK ShowBackBitMap}
    @{" ShowBitMap            " LINK ShowBitMap}

  @{b}Exemple:@{ub}

    @{"Double buffering " LINK "PureBasic:Examples/Sources/BitMap&Drawing.pb/Main"}

@ENDNODE


@NODE AllocateBitMap

    @{b}Syntaxe@{ub}
  BitMapID.l = AllocateBitMap(#BitMap, Width, Height, Depth)

    @{b}Résumé@{ub}
  Alloue une zone mémoire definie par la largeur, la hauteur
  et la profondeur du BitMap. Cette fonction est compatible
  avec les cartes graphiques (CyberGFX et Picasso 96).
  Si la valeur retournée par cette function est NULLE, alors
  le BitMap n'a pas pu être créé et par conséquent aucune
  opération ne doit être effectué par la suite sur ce BitMap.

  #BitMap: Identifiant numérique qui servira à reconnaitre ce
  bitmap ultérieurement

  Width : Largeur du BitMap en pixels

  Height: Hauteur du BitMap en pixels

  Depth : Profondeur du BitMap (nombre de BitPlanes). Cela definit
          le nombre de couleur que pourra supporter ce BitMap.
          Le calcul est le suivant: Nombre de couleurs = 2^Depth
          Donc un BitMap de Depth=5 pourra gérer 32 couleurs.

@ENDNODE


@NODE AllocateLinearBitMap

    @{b}Syntaxe@{ub}
  BitMapID.l = AllocateLinearBitMap(#BitMap, Width, Height, Depth)

    @{b}Résumé@{ub}
  Créé un nouveau bitmap en accord avec les paramètres donnés. Ce
  bimap est un peu spécial, car il est composé que d'un seul bloc
  de mémoire. Il est alloué obligatoirement en mémoire CHIP et
  ne devrait servir que pour les conversions Chunky/Planar. C'est
  d'ailleur dans ce seul but que cette fonction a été créée. Ce bitmap
  n'est pas compatible avec les cartes graphiques, donc si vous ne
  faites pas de chunky/planar utilisez la fonction @{" AllocateBitMap() " LINK AllocateBitMap}.

  Si le résultat est NULL, il n'y a plus assez de mémoire pour allouer
  le bitmap.


  #BitMap: Identifiant numérique qui servira à reconnaitre ce
  bitmap ultérieurement

  Width : Largeur du BitMap en pixels

  Height: Hauteur du BitMap en pixels

  Depth : Profondeur du BitMap (nombre de BitPlanes). Cela definit
          le nombre de couleur que pourra supporter ce BitMap.
          Le calcul est le suivant: Nombre de couleurs = 2^Depth
          Donc un BitMap de Depth=5 pourra gérer 32 couleurs.
@ENDNODE


@NODE FreeBitMap

    @{b}Syntaxe@{ub}
  FreeBitMap(#BitMap)

    @{b}Résumé@{ub}
  Libère l'espace memoire occupé par le BitMap. Aucune référence sur ce
  bitmap ne peut être faite ultérieurement.

  #BitMap: Identifiant numérique representant le BitMap précédement
  créé par la fonction @{" AllocateBitMap() " LINK AllocateBitMap}

@ENDNODE


@NODE InitBitMap

    @{b}Syntaxe@{ub}
  Resultat.l = InitBitMap(#NumBitMapMax)

    @{b}Résumé@{ub}
  Initialise l'environnement nécessaire pour la gestion du nombre
  de BitMap passé en paramètre. Si la valeur retournée est NULLE,
  alors l'environnement ne peut pas être créé et vous ne devez
  en aucun cas utiliser une des functions de la bibliothèque 'BitMap'.

  #NumBitMapMax: Nombre maximum de BitMap à gérer.

@ENDNODE


@NODE BitMapID

    @{b}Syntaxe@{ub}
  BitMapID.l = BitMapID()

    @{b}Résumé@{ub}
  Retourne l'addresse mémoire du BitMap courant, qui sera parfois
  nécessaire pour les autre fonctions du PureBasic.


  @{b}Note pour les programmeurs expérimentés:@{ub} ce pointeur permet d'accéder
  aux informations sur le BitMap grâce à la structure 'BitMap' qui est
  definie dans les RKM du Rom3.0+.
  Exemple: *MyBitMap.BitMap = BitMapID()

@ENDNODE


@NODE BitMapRastPort

    @{b}Syntaxe@{ub}
  RastPort.l = BitMapRastPort()

    @{b}Résumé@{ub}
  Retourne l'adresse du 'RastPort' du BitMap courant. Cette adresse est
  nécessaire pour certaines autre fonctions du PureBasic comme par exemple
  les fonctions de la bibliothèque '2D Drawing'. Ne vous inquiétez pas si
  vous ne savez pas ce qu'est réellement un RastPort, ca n'a que peu
  d'importance. Il faut juste retenir que c'est un identifiant permettant
  de savoir où les graphiques vont être dessinés. Utilisez cette fonctions
  dès que vous avez besoin d'un 'RastPort'.

@ENDNODE


@NODE UseBitMap

    @{b}Syntaxe@{ub}
  UseBitMap(#BitMap)

    @{b}Résumé@{ub}
  Change le BitMap courant par le nouveau BitMap passé en paramètre.

  #BitMap: Identifiant numérique représentant le nouveau BitMap à
           définir comme courant.

@ENDNODE


@NODE ShowBackBitMap

    @{b}Syntaxe@{ub}
  ShowBackBitMap(#BitMap, ScreenID, x, y)

    @{b}Résumé@{ub}
  Affiche le contenu du BitMap (#BitMap) dans le fond d'un écran
  de type 'DualPlayfield'. Si cet écran n'est pas 'DualPlayfield'
  alors utilisez la commande ShowBitMap(). Pour plus d'information
  sur le mode 'DualPlayfield' reportez vous à la documentation
  sur les @{" Ecrans " LINK "PureBasic:Help/Screen.guide/Main"}.


  #BitMap: Identifiant du BitMap à afficher.

  ScreenID: Identifiant de l'écran qui doit afficher le BitMap. Cette valeur
            peut être obtenue rapidement et simplement par la fonction ScreenID().

  x,y : Position à laquelle doit être affiché le BitMap par rapport à l'écran
        (en pixels). La valeur 0,0 se situe en haut à gauche de l'écran.

@ENDNODE

@NODE ShowBitMap

    @{b}Syntaxe@{ub}
  ShowBitMap(#BitMap, ScreenID, x, y)

    @{b}Résumé@{ub}
  Affiche le contenu du BitMap (#BitMap) sur l'écran (ScreenID) à la
  position x, y. Cette fonction est respecte le système Amiga et
  permet de faire du 'double buffering' (ou même du 'triple buffering'
  si nécessaire) très rapide.


  #BitMap: Identifiant du BitMap à afficher.

  ScreenID: Identifiant de l'écran qui doit afficher le BitMap. Cette valeur
            peut être obtenue rapidement et simplement par la fonction ScreenID().

  x,y : Position à laquelle doit être affiché le BitMap par rapport à l'écran
        (en pixels). La valeur 0,0 se situe en haut à gauche de l'écran.

@ENDNODE
