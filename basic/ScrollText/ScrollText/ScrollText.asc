

; $VER: ScrollText.bb2 v1.1 (29.08.2000)

; Author: Damir Arh
; E-mail: damir.arh@telesat.si
; WWW:    http://damir.gajba.net/

; This source code is completely free. You can redistribute
; and/or modify it without any restrictions whatsoever.

;-------------------------------------------------------------

; These functions easily enable you to include some
; scrolling text into your program.

; At the end of this source ('main' label) there's a small
; demo to show you, how they should be used. You don't need
; to include this part into your program, but you should
; include everything else.

; Before compiling you have to convert a picture with font
; data into the appropriate format with the program ST_Font.
; You need 'ST_Font.iff' where the characters are sorted from
; left till the right border and then from up to down like:

;  0  1  2  3  4  5  6
;  7  8  9 10 11 12 13
; ...

; The characters are set in following order:
;  0-25: letters of English alphabet (A-Z)
; 26-35: numbers (0-9)
;    36: (.)
;    37: (!)
;    38: (?)
;    39: (,)
;    40: empty space

; The final executable doesn't need any external files but
; at compilation time you need 'ST_Font.dat' (made with
; ST_Font) and ST_Font.col (palette file).

;-------------------------------------------------------------


;-------------------------------------------------------------
.ST_Const's:
;-------------------------------------------------------------

; First group of constants can be changed to suit the routines
; to personal needs.
; Don't touch the others, if you don't know, what you're
; doing!!

#ST_Width=320
#ST_OffSet=0       ; first shape to fill with characters
#ST_Y=120          ; y position of the text
#ST_Size=16        ; size of the font (square!)
#ST_Speed=1        ; amount of pixels moved in one step
#ST_TextSize=50    ; maximal length of text

#ST_Characters=41  ; number of supported characters
#ST_Fullstop=36    ;\
#ST_Exclamation=37 ; positions
#ST_Question=38    ; of
#ST_Branch=39      ; punctuation
#ST_Space=40       ;/
#ST_Numbers=26     ; starting position of 'number' shapes

Dim ST_Shapes.b(#ST_TextSize)     ; make the array

Goto ST_Init       ; skip the decoding part

;-------------------------------------------------------------
.ST_Load:
;-------------------------------------------------------------

; Include and decode the needed data. Must be called before
; ST_Update. Palette will be put in slot 0, shapes from
; #ST_OffSet above.

DecodePalette 0,?ST_Palette
DecodeShapes #ST_OffSet,?ST_Font

Return

ST_Font:
  IncBin "ST_Font.dat"

ST_Palette:
  IncBin "ST_Font.col"


;-------------------------------------------------------------
.ST_Init:
;-------------------------------------------------------------

; This function makes the necessary initialization.
; ST_Update won't work without it.

; Parameter:
; text$ - text to scroll

Statement ST_Init {text$}

  SHARED ST_Shapes.b(), ST_Length.w, ST_Pos.w

  ST_Length=Len(text$)      ; get the length of text
                                     ; properly
  For i=1 To ST_Length
                                     ; convert the text to
    c$=Mid$(text$,i,1)               ; internal format
    a.b=Asc(c$)                      ;

    If a>=Asc("A") AND a<=Asc("Z")   ; upper-case letters
      ST_Shapes(i-1)=a-Asc("A")
    EndIf

    If a>=Asc("a") AND a<=Asc("z")   ; lower-case letters
      ST_Shapes(i-1)=a-Asc("a")
    EndIf

    If a>=Asc("0") AND a<=Asc("9")   ; numbers
      ST_Shapes(i-1)=#ST_Numbers+a-Asc("0")
    EndIf

    ; punctuation marks
    If a=Asc(".") Then ST_Shapes(i-1)=#ST_Fullstop
    If a=Asc("!") Then ST_Shapes(i-1)=#ST_Exclamation
    If a=Asc("?") Then ST_Shapes(i-1)=#ST_Question
    If a=Asc(",") Then ST_Shapes(i-1)=#ST_Branch
    If a=Asc(" ") Then ST_Shapes(i-1)=#ST_Space

  Next i

  ST_Pos=0                         ; initialize the position

End Statement


;------------------------------------------------------------
.ST_Update:
;------------------------------------------------------------

; This function draws the next position of the scrolling
; text to the active bitmap

Statement ST_Update{}

  SHARED ST_Shapes(), ST_Length, ST_Pos

  Boxf 0,#ST_Y,#ST_Width,#ST_Y+#ST_Size,1 ; clear previous step

  ; update the position of the text
  ST_Pos=ST_Pos+#ST_Speed
  If ST_Pos>ST_Length*#ST_Size+#ST_Width Then ST_Pos=0

  pos=ST_Pos              ; position of the current character
  char=0                  ; current character

  While pos>0             ; if the text already appeared

    If pos<#ST_Width+#ST_Size         ; if it's on the screen

      If char<ST_Length              ; if the text isn't over

        If pos<#ST_Size OR pos>#ST_Width
          ClipBlit ST_Shapes(char)+#ST_OffSet,#ST_Width-pos,#ST_Y
        Else
          Blit ST_Shapes(char)+#ST_OffSet,#ST_Width-pos,#ST_Y
        EndIf

      EndIf

    EndIf

    pos=pos-#ST_Size  ; next character
    char=char+1       ;/

  Wend

End Statement


;------------------------------------------------------------
.main:
;------------------------------------------------------------

; This is just a short program to test the above functions.

; It shows, how to use the functions correctly and shouldn't
; be directly copied into your program.

#_Width=$80000023                   ;\
#_Height=$80000024                  ; some tags
#_Depth=$80000025                   ; to open
#_BitMap=$8000002E                  ; the screen
#_Exclusive=$8000003F               ;/

text$="A small routine for scrolling text..." ; test text

; Decode the data and initialize the text.
; Call these two before ST_Update.

WBStartup

Gosub ST_Load
ST_Init{text$}

BitMap 0,320,256,5                  ; open screen
Cls 0
BitMap 1,320,256,5                  ; and bitmaps
Cls 0
ScreenTags 0,"ScrollText V1.0",#_Width,320,#_Height,256,#_Depth,5,#_BitMap,Addr BitMap(0),#_Exclusive,True

db=0    ; start double buffering

Repeat

  db=1-db         ; change bitmap
  Use BitMap db
  Use Palette 0

  ST_Update{}     ; call the update function

  ShowBitMap db   ; show the bitmap
  VWait

Until Joyb(0)<>0  ; wait mouseclick

End

