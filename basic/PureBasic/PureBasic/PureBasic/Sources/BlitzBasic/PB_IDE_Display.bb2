; --------------------------------------------------------------------------------------
;
; This source file is part of PureBasic
; For the latest info, see http://www.purebasic.com/
; 
; Copyright (c) 1998-2006 Fantaisie Software
;
; This program is free software; you can redistribute it and/or
; modify it under the terms of the GNU General Public License
; as published by the Free Software Foundation; either version 2
; of the License, or (at your option) any later version.
;
; This program is distributed in the hope that it will be useful,
; but WITHOUT ANY WARRANTY; without even the implied warranty of
; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; GNU General Public License for more details.
;
; You should have received a copy of the GNU General Public License
; along with this program; if not, write to the Free Software
; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
;
; --------------------------------------------------------------------------------------
;
; PureBasic Editor Display functions...
;
; Doobrey: Replaced the Joyb(0).. hits the hardware, Bad for OS4+MorphOS
;       .. replaced with a NWindowEvent=#IDCMP_MOUSEBUTTONS
;
; --------------------------------------------------------------------------------------

Statement ChangeBoopsiTags{GadgetID.w, TagITEM.l, TagDATA.l}
  SHARED  *Boopsi(), NbBoopsi, *TagList

  Gadget.l = 0
  For k.w=0 To NbBoopsi
    If *Boopsi(k)\GadgetID = GadgetID
      Gadget = *Boopsi(k)
      k = NbBoopsi          ; Reach the end of for quickly ;-)
    EndIf
  Next

  If Gadget
    NResetTagList    TagITEM, TagDATA
    SetGadgetAttrsA_ Gadget, NWindowID, 0, *TagList
  EndIf

End Statement

;---------------------------------------------------------------------------



Statement UpdateBoopsi{}
  SHARED PBCursor,PBMainWindow
  ChangeBoopsiTags{#BO_VerticalSlider, #PGA_Total  , PBMainWindow\NbLines}
  ChangeBoopsiTags{#BO_VerticalSlider, #PGA_Top    , PBCursor\OffsetY}
  ChangeBoopsiTags{#BO_VerticalSlider, #PGA_Visible, PBMainWindow\NbWindowLines}

  ChangeBoopsiTags{#BO_HorizontalSlider, #PGA_Total  , PBMainWindow\MaxNbChars}
  ChangeBoopsiTags{#BO_HorizontalSlider, #PGA_Top    , PBCursor\OffsetX}
  ChangeBoopsiTags{#BO_HorizontalSlider, #PGA_Visible, PBMainWindow\NbWindowChars}
End Statement

 ; ---------------------------------------------------------------------------

  Statement DisplayNewCursor{}
   SHARED  Old_Cursor.s, Source(),PBMainWindow
   SHARED  PBCursor,PBOld_Cursor,SelectedZone

   Bad.b=0
   PBCursor\SelectedMode = 0

   Y.w = PBMainWindow\TopText+(PBCursor\Y*PBMainWindow\FontHeight)

   NBackColour 3


   If PBCursor\OffsetX+PBCursor\X >= Len(Source()\Text)
     Old_Cursor = " "
   Else
     Old_Cursor = Mid$(Source()\Text,PBCursor\OffsetX+PBCursor\X+1,1)
   EndIf

   RealX.w = PBCursor\OffsetX+PBCursor\X
   RealY.w = PBCursor\OffsetY+PBCursor\Y

   If RealY >= SelectedZone\Y AND RealY <= SelectedZone\EndY
     If RealY = SelectedZone\Y AND RealX < SelectedZone\X
       Bad = 1
     EndIf

     If RealY = SelectedZone\EndY AND RealX > SelectedZone\EndX
       Bad = 1
     EndIf

     If Bad = 0
       NBackColour 2
       PBCursor\SelectedMode = 1
     EndIf
   EndIf

   NLocate 10+(PBCursor\X*PBMainWindow\FontWidth), Y
   NDPrint Old_Cursor

   NBackColour 0

   PBOld_Cursor\X = PBCursor\X
   PBOld_Cursor\Y = PBCursor\Y

   PBOld_Cursor\OffsetX = PBCursor\OffsetX
   PBOld_Cursor\OffsetY = PBCursor\OffsetY

  End Statement

;---------------------------------------------------------------------------

Statement DeleteOldCursor{}
  SHARED  Old_Cursor.s, Source(),PBMainWindow
  SHARED  PBCursor,PBOld_Cursor


  If PBCursor\OffsetY+PBCursor\Y >= PBMainWindow\NbLines
    Old_Cursor = " "
  EndIf

  If (PBOld_Cursor\Y < PBMainWindow\NbWindowLines) AND (PBOld_Cursor\X <= PBMainWindow\NbWindowChars)

    If PBCursor\SelectedMode
      NBackColour 3
    Else
      NBackColour 0
    EndIf

    NLocate 10+PBOld_Cursor\X*PBMainWindow\FontWidth, PBMainWindow\TopText+PBOld_Cursor\Y*PBMainWindow\FontHeight
    NDPrint Old_Cursor

    NBackColour 0
  EndIf

End Statement


;---------------------------------------------------------------------------

Statement DisplayLine{UpdateCursor.w}
  SHARED  Old_Cursor.s, Source(),LineLength()
  SHARED  PBMainWindow
  SHARED  PBCursor,PBOld_Cursor,SelectedZone

  IsSelected.b=0

  If UpdateCursor
    DeleteOldCursor{}
  EndIf

  Y.w = PBMainWindow\TopText+(PBCursor\Y*PBMainWindow\FontHeight)

  Text.s = Mid$(Source()\Text,PBCursor\OffsetX+1,PBMainWindow\NbWindowChars+1)
  ActLineLength.w = Len(Text)

  RealY.w = PBCursor\OffsetY+PBCursor\Y
  If (RealY >= SelectedZone\Y) AND (RealY <= SelectedZone\EndY)
    ActLineLength = PBMainWindow\NbWindowChars+1
    If SelectedZone\EndY<>-1
     IsSelected = 1
    EndIf
  EndIf

  OldLineLength.w = LineLength(PBCursor\Y)

  If OldLineLength > PBMainWindow\NbWindowChars+1
    OldLineLength = PBMainWindow\NbWindowChars+1
  EndIf

  If OldLineLength > ActLineLength
    NFrontColour 0
    NBoxFill 10+ActLineLength*PBMainWindow\FontWidth, Y, 10+OldLineLength*PBMainWindow\FontWidth-1, Y+PBMainWindow\FontHeight-1
    NFrontColour 1
  EndIf

  ;
  ; If the displayed line is inside the 'SelectedZone' we have to
  ; do many stuffs...
  ;

  If IsSelected
      TextLength.w     = Len(Text)

      NLocate 10, Y

      If RealY = SelectedZone\Y AND SelectedZone\X > 0     ; Draw upper right corner of
        a.s = Left$(Text, SelectedZone\X)                 ; the box.
        NDPrint a                                       ;
        Text = Right$(Text, Len(Text)-SelectedZone\X)  ;
      EndIf                                              ;

      NBackColour 3


      If RealY = SelectedZone\EndY
          SelectLength.w = SelectedZone\EndX+1

          If RealY = SelectedZone\Y
            SelectLength - SelectedZone\X
          EndIf
          NDPrint LSet$(Left$(Text, SelectLength), SelectLength)

          If SelectLength > TextLength
            TextLength = SelectLength
          EndIf

          Text = Right$(Text, Len(Text)-SelectLength)
          NBackColour 0
          BlockColour.w = 0
      Else
          BlockColour.w = 3
      EndIf

      NDPrint Text

      NFrontColour BlockColour

      If TextLength < PBMainWindow\NbWindowChars+1
        NBoxFill 10+TextLength*PBMainWindow\FontWidth, Y, 10+(PBMainWindow\NbWindowChars+1)*PBMainWindow\FontWidth-1, Y+PBMainWindow\
tHeight-1
      EndIf
      NFrontColour 1
      NBackColour 0
  Else
    NLocate 10, Y
    NDPrint Text
  EndIf

  If UpdateCursor
    DisplayNewCursor{}
  EndIf

  LineLength(PBCursor\Y) = ActLineLength

End Statement




;---------------------------------------------------------------------------

; This can be given an overhaul.. cut down on all those Nwindow commands!

Statement ReCalcDisplay{}
  SHARED  *MainWin, Source(), WindowCenterW, WindowCenterH
  SHARED  PBMainWindow,PBCursor

  OFW.w = PBMainWindow\FontWidth
  OFH.w = PBMainWindow\FontHeight

  PBMainWindow\FontWidth  = *MainWin\RPort\Font\tf_XSize
  PBMainWindow\FontHeight = *MainWin\RPort\Font\tf_YSize

  If (PBMainWindow\Old_WindowWidth <> NWindowWidth) OR (PBMainWindow\Old_WindowHeight <> NWindowHeight) OR( OFW <> PBMainWindow\FontWidth) OR (OFH <
BMainWindow\FontHeight)

    NFrontColour 0

    If (OFW <> PBMainWindow\FontWidth) OR( OFH <> PBMainWindow\FontHeight)
      NBoxFill NWBorderLeft+1, NWBorderTop+1, NWBorderLeft+NWInnerWidth-1, NWBorderTop+NWInnerHeight-1
    EndIf

    PBMainWindow\Old_WindowWidth  = NWindowWidth
    PBMainWindow\Old_WindowHeight = NWindowHeight

    PBMainWindow\NbWindowChars  = (NWInnerWidth -6)/PBMainWindow\FontWidth-1
    PBMainWindow\NbWindowLines = (NWInnerHeight-5)/PBMainWindow\FontHeight


    a.w = NWindowHeight-*MainWin\BorderBottom
    b.w = NWBorderLeft+NWInnerWidth-1

    c.w = (NWInnerHeight-5)-PBMainWindow\NbWindowLines*PBMainWindow\FontHeight
    If c>0
      NBoxFill 5, a-c, b, a-1
    EndIf

    c = (NWInnerWidth-6)-(PBMainWindow\NbWindowChars+1)*PBMainWindow\FontWidth
    If c>0
      NBoxFill b-c, NWBorderTop+1, b, NWBorderTop+NWInnerHeight-1
    EndIf

    NFrontColour 1

    While PBCursor\Y > PBMainWindow\NbWindowLines-1
      PBCursor\Y-1
      PrevItem Source()
    Wend

    If PBCursor\X >PBMainWindow\NbWindowChars
      PBCursor\X = PBMainWindow\NbWindowChars
    EndIf

  EndIf
End Statement

;---------------------------------------------------------------------------

Statement RefreshLines{StartLine.w, UpdateCursor.w}
  SHARED  Source(),PBMainWindow, PBCursor,PBOld_Cursor
  SHARED  LineLength()

  ReCalcDisplay{}


  !DPrint{2,"StartLine>"+Str$(StartLine)}

  PBOld_Cursor\Y = PBCursor\Y

  If UpdateCursor = 1
    DeleteOldCursor{}
  EndIf

   PushItem Source()

  ResetList Source()
  If PBCursor\OffsetY
    For k.w=1 To PBCursor\OffsetY  ;WAS \Y
      ;!DPrint{2,"OffsetY>"+Str$(k)}
      ;If PrevItem(Source())
      ;Else
      ;  ResetList Source()
      ;EndIf
      NextItem Source()
    Next
  EndIf

  PBCursor\Y=StartLine
  If PBCursor\Y
   For k.w=1 To StartLine
      NextItem Source()     ; Must be a simpler way..
   Next
  EndIf


  For k.w=StartLine To PBMainWindow\NbWindowLines-1

    If NextItem(Source())
      DisplayLine{0}
    Else
      ActLineLength.w = 0            ; Not sure..added below..!
      Y.w = PBMainWindow\TopText+PBCursor\Y*PBMainWindow\FontHeight

      OldLineLength.w = LineLength(PBCursor\Y)

      If OldLineLength > PBMainWindow\NbWindowChars+1
        OldLineLength = PBMainWindow\NbWindowChars+1
      EndIf

      If OldLineLength > ActLineLength
        NFrontColour 0
        NBoxFill 10+ActLineLength*PBMainWindow\FontWidth, Y, 10+OldLineLength*PBMainWindow\FontWidth, Y+PBMainWindow\FontHeight-1
        NFrontColour 1
      EndIf

      LineLength(PBCursor\Y) = 0
    EndIf

    PBCursor\Y+1
  Next

  PopItem Source()

  PBCursor\Y = PBOld_Cursor\Y

  If UpdateCursor = 1
    DisplayNewCursor{}
  EndIf

End Statement

;------------------------------------------------------------------------------------
Statement SetupDisplay{}
  ReCalcDisplay{}
  UpdateBoopsi{}
  RefreshLines{0, 1}
End Statement

;---------------------------------------------------------------------------
Statement UpdateStatus{Text.s}
  SHARED  PBGlobals,PBCursor,PBScreenInfo
  SHARED  FilePart.s, Language(),ScreenTitle.s

  CutPath{PBGlobals\SaveFileName}

  USEPATH PBScreenInfo

  If FilePart = ""
    a.s = Language(64)
  Else
    a.s = FilePart
  EndIf

  If Text = ""
    \Status = Language(65)+" "+Str$(PBCursor\Y+PBCursor\OffsetY+1)+" - "+Language(66)+" "+Str$(PBCursor\X+PBCursor\OffsetX+1)+\Quic
lp
  Else
    \Status = Text
  EndIf

  If a <> \Old_ScreenTitle
    \Old_ScreenTitle = a
    \ScreenTitle = ScreenTitle+" - "+a ;"PureBasic V2.90 - "+a
    SetWindowTitles_ NWindowID, &\Status, &\ScreenTitle
  Else
    SetWindowTitles_ NWindowID, &\Status, -1
  EndIf
End Statement


;---------------------------------------------------------------------------------------
Statement GotoLine{}
 SHARED Source(),PBMainWindow
 SHARED PBCursor

 ResetList Source()

 For k.w=0 To PBCursor\Y
   NextItem Source()
 Next

 If PBCursor\Y => PBMainWindow\NbWindowLines
   a.w = PBMainWindow\NbWindowLines/2
   PBCursor\OffsetY = PBCursor\Y-a
   PBCursor\Y = a
 Else
   PBCursor\OffsetY = 0
 EndIf

 If PBCursor\X > PBMainWindow\NbWindowChars
   a.w = PBMainWindow\NbWindowChars/2
   PBCursor\X = PBCursor\X-a
   PBCursor\X = a-1
 Else
   PBCursor\OffsetX = 0
 EndIf

 If PBCursor\X > 0
   PBCursor\X-1
 EndIf

 NUseWindow #Window_Main

 UpdateStatus{""}

 RefreshLines{0, 1}

End Statement

;---------------------------------------------------------------------------------------

Function.s GetCurrentWord{Position.w}
  SHARED ValidCharacters(), Source(),PBCursor, CurrentWordPosition

  Result.s=""  ; setup result var.
  WordLen.w=0  ; was Length.. but it`s a command name!

  *TCursor.Byte   = &Source()\Text
  LineAddress.l = *TCursor

  If Position = -1
    Position = PBCursor\OffsetX+PBCursor\X
    If Position > Len(Source()\Text)
      Position = Len(Source()\Text)
    EndIf
  EndIf

  *TCursor+Position


  ; Get the right part
  ;
  While ValidCharacters(*TCursor\b)
    *TCursor+1
    WordLen+1
  Wend

  *TCursor = LineAddress+Position
  ; Get the left part
  ;
  While ValidCharacters(*TCursor\b) AND (*TCursor > LineAddress)
    *TCursor-1
    WordLen+1
  Wend


  If (*TCursor > LineAddress) OR (*TCursor\b =32)
    *TCursor+1
    WordLen-1
  EndIf


  If WordLen > 0
    CurrentWordPosition = *TCursor-LineAddress
    Result = PeekS(*TCursor, WordLen)
  EndIf

  Function Return Result
End Function



;---------------------------------------------------------------------------

Statement UpdateCursor{}
  DeleteOldCursor{}
  DisplayNewCursor{}
End Statement

;----------------------------------------------------

Statement PreviousLine{}
  SHARED Source(),PBCursor,Old_Cursor.s

  If PrevItem(Source())
    If PBCursor\Y > 0
      PBCursor\Y-1
      UpdateCursor{}

    Else
      !DPrint{1,"No Prev.."}
      PBCursor\OffsetY-1
      RefreshLines{0, 1}
    EndIf

  EndIf
End Statement

;----------------------------------------------------

Statement NextLine{}
  SHARED Source(), PBCursor,PBMainWindow
  ;--DeleteOldCursor{}
  If NextItem(Source())
    If PBCursor\Y < PBMainWindow\NbWindowLines-1
      PBCursor\Y+1
      UpdateCursor{}
    Else
      PBCursor\OffsetY+1
      RefreshLines{0, 1}
    EndIf
  EndIf
End Statement


;---------------------------------------------------------------------------
Function.b InsideSelectedZone{}
  SHARED   PBCursor,SelectedZone

  RealX.l = PBCursor\OffsetX+PBCursor\X
  RealY.l = PBCursor\OffsetY+PBCursor\Y
  Result.b=0

  If (RealY >= SelectedZone\Y) AND (RealY <= SelectedZone\EndY)
    Result = 1

    If (RealY = SelectedZone\Y) AND (RealX < SelectedZone\X)
      Result = 0
    EndIf

    If (RealY = SelectedZone\EndY) AND (RealX > SelectedZone\EndX)
      Result = 0
    EndIf
  EndIf

  Function Return Result
End Function

;---------------------------------------------------------------------------

Statement LocateMouse{}
  SHARED  Source(),PBCursor,PBOld_Cursor
  SHARED  SelectedZone,PBMainWindow

  PBOld_Cursor\Y = PBCursor\Y
  SelectZone.b=0

  ; Clear old selected area..
  If SelectedZone\EndY<>-1
    SelectedZone\EndY=-1
    RefreshLines{0,1}
  EndIf

  X.w=NWMouseX
  Y.w=NWMouseY

  NewX.w = (X-10)/PBMainWindow\FontWidth
  NewY.w = (Y-PBMainWindow\TopText)/PBMainWindow\FontHeight

  InitY.w       = NewY
  InitX.w       = NewX
  InitOffsetY.w = PBCursor\OffsetY
  InitOffsetX.w = PBCursor\OffsetX

  If (NewY < PBMainWindow\NbLines-PBCursor\OffsetY AND NewY >= 0 AND NewY < PBMainWindow\NbWindowLines) AND (NewX>=0 AND NewX<=PBMa
indow\NbWindowChars)
    PBCursor\X = NewX
    PBCursor\Y = NewY

    For k.w=1 To PBOld_Cursor\Y
      PrevItem Source()
    Next

    For k.w=1 To PBCursor\Y
      NextItem Source()
    Next

    UpdateCursor{}
  EndIf

  Repeat
    VWait
    IDCMP.l=NWindowEvent
    ;If IDCMP ;= #IDCMP_MOUSEBUTTONS
    ; !DPrint{2,"MOUSE >"+Hex$(IDCMP)+" >ID"+Str$(NEventID)}
    ;EndIf
                                                          ;
    X.w = NWMouseX                                            ;  Wait loop to see if it's only a click
    Y.w = NWMouseY                                            ;  or a selection.
                                                              ;
    ActX.w = (X-10)/PBMainWindow\FontWidth                    ;
    ActY.w = (Y-PBMainWindow\TopText)/PBMainWindow\FontHeight ;
                                                              ;
    If (ActX <> InitX) OR (ActY <> InitY)                     ;
      SelectZone = 1                                          ;
    EndIf                                                     ;
                                                              ;
  Until (IDCMP=#IDCMP_MOUSEBUTTONS) OR (SelectZone = 1)                     ;

  If SelectZone

    ; This loop needs to be changed to only refresh when the actx or acty change!
    NeedRefresh.b=0
    PBMainWindow\MouseDown=1    

    Repeat
      OrgX.w = ActX  
      OrgY.w = ActY  
      NeedBoopsiUpdate.b = 0 

      Delay_ 1
      IDCMP.l = NWindowEvent
      X = NWMouseX
      Y = NWMouseY

      ActX = (X-10)/PBMainWindow\FontWidth
      ActY = (Y-PBMainWindow\TopText)/PBMainWindow\FontHeight

       If (OrgX<>ActX) OR (OrgY<>ActY)
        ;- Set limits...
        If ActX < 0 Then ActX = 0
        If ActX > PBMainWindow\NbWindowChars Then ActX = PBMainWindow\NbWindowChars
        If ActY < 0 Then ActY = 0
        If ActY > PBMainWindow\NbWindowLines Then ActY = PBMainWindow\NbWindowLines

        If (Y < PBMainWindow\TopText) AND (PBCursor\OffsetY > 0)  ; Scroll up...
          PBCursor\OffsetY-1            ;
          NeedBoopsiUpdate=1            ;
          PrevItem Source()             ;
        EndIf                           ;

        If (Y > PBMainWindow\TopText+PBMainWindow\NbWindowLines*PBMainWindow\FontHeight) AND( PBMainWindow\NbLines > PBMainWindo
bWindowLines-1)
          If ActY+PBCursor\OffsetY < PBMainWindow\NbLines
            PBCursor\OffsetY+1
            NeedBoopsiUpdate=1
            NextItem Source()
          EndIf
        EndIf

        SelectedZone\X    = InitOffsetX+InitX
        SelectedZone\Y    = InitOffsetY+InitY

        SelectedZone\EndX = PBCursor\OffsetX+ActX
        SelectedZone\EndY = PBCursor\OffsetY+ActY


        ;Swap Y for reverse selection.
        If SelectedZone\Y > SelectedZone\EndY
          Exchange SelectedZone\Y, SelectedZone\EndY
          Exchange SelectedZone\X, SelectedZone\EndX
        Else
          If (SelectedZone\Y=SelectedZone\EndY) AND (SelectedZone\X>SelectedZone\EndX)
            Exchange SelectedZone\X, SelectedZone\EndX
          EndIf
        EndIf

        RefreshLines{0, 0}

        If NeedBoopsiUpdate
         UpdateBoopsi{}
        EndIf

      Else
       NeedRefresh=1
      EndIf
    Until IDCMP=#IDCMP_MOUSEBUTTONS

    PBMainWindow\MouseDown=0     ;
    If NeedRefresh               ; Doobrey: Remove old selection ?
      RefreshLines{0,0}
    EndIf

    PBCursor\SelectedMode = 1  ; Tell the system than the cursor was in a selected area
  EndIf

End Statement




;----------------------------------------------------
Statement ChangeGadgetText{Text.s}
  SHARED  *Gad, *TagList

  NResetTagList #GTTX_Text, &Text
  GT_SetGadgetAttrsA_ *Gad, NWindowID, 0, *TagList

End Statement

;----------------------------------------------------

Statement CreateArrowGadget{GadgetID.w, ArrowType.w}
  SHARED  *dri, sis, *gad, NbBoopsi, NbArrows, *Boopsi(), *Arrows(), *TagList
  SHARED  sizew, sizeh, SliderX, SliderY

  ; Create image for an arrow button
  ;
  NResetTagList #SYSIA_DrawInfo, *dri
        NAddTag #SYSIA_Which   , ArrowType
        NAddTag #SYSIA_Size    , sis
  *Arrow.Image = NewObjectA_(0, "sysiclass", *TagList)

  If *Arrow

    NbArrows+1
    *Arrows(NbArrows) = *Arrow

    ImageHeight.w = *Arrow\Height
    ImageWidth.w  = *Arrow\Width

    If (ArrowType = #UPIMAGE) OR (ArrowType = #DOWNIMAGE)
      SliderY+ImageHeight

      x.w = -ImageWidth + 1

      If ArrowType = #DOWNIMAGE
        y.w = -ImageHeight + 1 - sizeh
      Else
        y.w = -2*ImageHeight + 1 - sizeh
      EndIf

    Else
      SliderX+ImageWidth

      y.w = -ImageHeight + 1

      If ArrowType = #RIGHTIMAGE
        x.w = -ImageWidth + 1-sizew
      Else
        x.w = -2*ImageWidth + 1-sizew
      EndIf
    EndIf

    NResetTagList #GA_ID          , GadgetID                      ; Gadget ID must be unique
          NAddTag #GA_Image       , *Arrow                        ; Tell what graphics to use for gadget
          NAddTag #GA_Previous    , *gad                          ; Must specify previous gadget in list

          If (ArrowType = #LEFTIMAGE) OR (ArrowType = #RIGHTIMAGE)
            NAddTag #GA_BottomBorder, 1                           ; this gadget appears in the bottom window border
          Else
            NAddTag #GA_RightBorder, 1                            ; this gadget appears in the bottom window border
          EndIf

          NAddTag #GA_RelRight    , x                             ; the position (relative to right edge of window)
          NAddTag #GA_RelBottom   , y                             ; the position (relative to bottom edge of window)
          NAddTag #ICA_TARGET     , #ICTARGET_IDCMP               ; this gadget produces an IDCMP event when activated

    *gad = NewObjectA_(0, "buttongclass", *TagList)

    If *gad
      NbBoopsi+1
      *Boopsi(NbBoopsi) = *gad
    Else
      NPrint "Error2"
    End If
  Else
    NPrint "Error3"
  End If

End Statement

;----------------------------------------------------------------------

Statement CreateSlider{SliderID.w, SliderType.w}
  SHARED  *TagList, *gad, *MyScreen, sizew, sizeh, *Boopsi(), NbBoopsi
  SHARED  SliderX, SliderY

  ; Create a scrollbar
  ;

  NResetTagList #GA_ID          , SliderID
        NAddTag #PGA_Freedom    , SliderType                        ; set it to horizontal scrollbar
        NAddTag #PGA_NewLook    , 1
        NAddTag #PGA_Borderless , 1
        NAddTag #PGA_Top        , 0                                 ; can show between pos. 0 and 10 with 2 pos. always v
        NAddTag #PGA_Visible    , 0
        NAddTag #PGA_Total      , 0
        NAddTag #GA_Previous    , *gad

        If SliderType = #FREEHORIZ
          NAddTag #GA_Left        , *MyScreen\WBorLeft + 1                 ; Start position straight after left window border
          NAddTag #GA_RelBottom   , 3 - sizeh                         ; top of gadget is 2 down from top of bottom border
          NAddTag #GA_RelWidth    , -sizew - 2 - *MyScreen\WBorLeft - SliderX
          NAddTag #GA_Height      , sizeh-4
          NAddTag #GA_BottomBorder, 1                               ; scrollbar goes in bottom border
        Else
          NAddTag #GA_RelRight    , -sizew+4
          NAddTag #GA_Top         , *MyScreen\WBorTop+*MyScreen\Font\ta_YSize+1+1       ; top is titlebar height + 1
          NAddTag #GA_Width       , sizew-6
          NAddTag #GA_RelHeight   , -(*MyScreen\WBorTop+*MyScreen\Font\ta_YSize+1)-SliderY-sizeh-2
          NAddTag #GA_RightBorder , 1                               ; scrollbar goes in right border
        EndIf

        NAddTag #ICA_TARGET,#ICTARGET_IDCMP                         ; gives us IDCMP events

  *gad = NewObjectA_(0, "propgclass", *TagList)
  If *gad
    NbBoopsi+1
    *Boopsi(NbBoopsi) = *gad
  Else
    NPrint "Error1"
  End If

End Statement

;----------------------------------------------------------------------

Function.l GetBoopsiTag{GadgetID.w, TagITEM.l}
  SHARED   *Boopsi(), NbBoopsi

  value.l =10

  Gadget.l = 0
  For k.w=0 To NbBoopsi
    If *Boopsi(k)\GadgetID = GadgetID
      Gadget = *Boopsi(k)
      k = NbBoopsi          ; Reach the end of for quickly ;-)
    EndIf
  Next

  If Gadget
    GetAttr_ TagITEM, Gadget, &value
  EndIf

  Function Return value
End Statement

;---------------------------------------------------------------------------

Statement Rect{x.w, y.w, long.w, haut.w, Style.w}
  SHARED  *TagList, *MyScreen

  visinfo.l = GetVisualInfoA_(*MyScreen, 0)
  NResetTagList #GT_VisualInfo, visinfo
  If Style
        NAddTag #GTBB_Recessed, Style
  EndIf
  DrawBevelBoxA_ NWindowRastPort, x, y, long, haut, *TagList
  FreeVisualInfo_ visinfo

End Statement

;---------------------------------------------------------------------------
Function.l OpenStandardWindow{Number.l, WindowW.w, WindowH.w, TitleNumber.w}
  SHARED   Language(), *MyScreen, *TagList


  WindowCenterW.w = NWindowX+(NWindowWidth/2)
  WindowCenterH.w = NWindowY+(NWindowHeight/2)

  NResetTagList #WA_Title, &Language(TitleNumber)
        NAddTag #WA_Flags, #FLAGS2 | #WFLG_DRAGBAR
        NAddTag #WA_CustomScreen, *MyScreen
        #OTHER_IDCMP = #LISTVIEWIDCMP | #IDCMP_GADGETUP | #IDCMP_GADGETDOWN | #IDCMP_IDCMPUPDATE
        ;;;#OTHER_IDCMP =  #IDCMP_GADGETUP | #IDCMP_GADGETDOWN | #IDCMP_IDCMPUPDATE


        NAddTag #WA_IDCMP, #IDCMP_CLOSEWINDOW | #IDCMP_RAWKEY | #IDCMP_VANILLAKEY | #OTHER_IDCMP

  MyWindow.l = NWindow(Number, WindowCenterW-(WindowW+20)/2, WindowCenterH-WindowH/2, WindowW, WindowH, *TagList)

  If MyWindow
    NAttachGadgetList Number,NWindowID
    Rect{NWBorderLeft,NWBorderTop,NWInnerWidth,NWInnerHeight,0}

    Function Return NWindowID
  EndIf

 Function Return MyWindow
End Function

