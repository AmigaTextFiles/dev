@DATABASE Commodity V1.00
$VER: Pure Basic - Commodity V1.00 (26.09.1999) (c) Fantaisie Software
@NODE MAIN "Commodity V1.00"

  @{b}Pure Basic - Commodity V1.00@{ub}

     A Commodity is a way to manage an application under
     the AmigaOS. This program must follow etablished
     rules to become a commodity: its window can be
     hided/showed, the application can be disabled,...
     All these actions can be done via the 'Exchange'
     program. A commodity can have several advantages:
     HotKeys, Break C signals and more.

  @{b}Commands summary:@{ub}

    @{" ActivateCommodity           " LINK ActivateCommodity}
    @{" ActivateCommodityObject     " LINK ActivateCommodityObject}
    @{" ActivateCommodityTranslater " LINK ActivateCommodityTranslater}
    @{" AddCommodityInputEvent      " LINK AddCommodityInputEvent}
    @{" ChangeCommodityFilter       " LINK ChangeCommodityFilter}
    @{" ChangeCommodityFilterIX     " LINK ChangeCommodityFilterIX}
    @{" ChangeCommodityTranslater   " LINK ChangeCommodityTranslater}
    @{" CommodityCtrlCSignal        " LINK CommodityCtrlCSignal}
    @{" CommodityEvent              " LINK CommodityEvent}
    @{" CommodityID                 " LINK CommodityID}
    @{" CommoditySignal             " LINK CommoditySignal}
    @{" CommodityType               " LINK CommodityType}
    @{" CreateCommodityObject       " LINK CreateCommodityObject}
    @{" FreeCommodityObject         " LINK FreeCommodityObject}
    @{" InitCommodity               " LINK InitCommodity}
    @{" WaitCommodityEvent          " LINK WaitCommodityEvent}


    @{" Commodity Demo 1 " LINK PureBasic:Examples/Sources/Commodity1.pb/Main}
    @{" Commodity Demo 2 " LINK PureBasic:Examples/Sources/Commodity2.pb/Main}

@ENDNODE


@NODE ActivateCommodity

    @{b}SYNTAX@{ub}
  ActivateCommodity(@{b}Status@{ub}.l)

    @{b}STATEMENT@{ub}
  Enable or Disable the Commodity, which include all created Objects.

  When the Commodity is disabled it will only receive CxMessages of
  Command Type, from Commdities Exchange, CxMessages of Event Type
  are not processed.

  @{b}Status@{ub}
  Enable the Commodity by setting status to TRUE and Disable Commodity
  by setting it to FALSE.
@ENDNODE


@NODE ActivateCommodityObject

    @{b}SYNTAX@{ub}
  ActivateCommodityObject(@{b}#Obj@{ub}.l,@{b}Status@{ub}.l)

    @{b}STATEMENT@{ub}
  Disable or Enable an Object created by CreateCommodityObject().

  A disabled Object is kind of sleeping, it won't process any
  CxMessages until ActivateCommodityObject(#Obj, TRUE) wakes it up.

  This statement doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  Object to Disable or Enable.

  @{b}Status@{ub}
  Disable the Object by setting status to FALSE and Enable Object
  by setting status to TRUE.
@ENDNODE


@Node ActivateCommodityTranslater

    @{b}SYNTAX@{ub}
  ActivateCommodityTranslater(@{b}#Obj@{ub}.l,@{b}Status@{ub}.l)

    @{b}STATEMENT@{ub}
  Disable or Enable the Translater in an Object.

  An enabled Translater changes the CxMessage input event in two ways,
  it could be eliminated or replaced by a new input event. When none
  of this is useful just disable the Translater.

  This statement doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  Object to use.

  @{b}Status@{ub}
  Disable the Translater by setting status to FALSE and Enable
  Translater by setting status to TRUE.
@EndNode


@NODE AddCommodityInputEvent

    @{b}SYNTAX@{ub}
  AddCommodityInputEvent(@{b}*InputEvent@{ub})

    @{b}STATEMENT@{ub}
  Add a new InputEvent or a chain of InputEvents to the
  input eventstream.

  @{b}*InputEvent@{ub}
  This is a pointer to an InputEvent Structure or a chain of
  InputEvent Structures and it is free to use again after this call.
@ENDNODE


@NODE ChangeCommodityFilter

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.b = ChangeCommodityFilter(@{b}#Obj@{ub}.l,@{b}Filter$@{ub})

    @{b}FUNCTION@{ub}
  Change the Filter conditions for an Object.

  This function doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  The Object to change the Filter for.

  @{"Filter$" LINK FilterStrings}
  The string that describes the new Filter conditions.

  @{b}Result@{ub}
  If it's TRUE the input description string is bad and the Object does
  not process any CxMessages until either: this function, or
  ChangeCommodityFilterIX() succeeds the next time.
@ENDNODE


@NODE ChangeCommodityFilterIX

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.b = ChangeCommodityFilterIX(@{b}Obj@{ub}.l,@{b}*InputXpression@{ub})

    @{b}FUNCTION@{ub}
  Change the Filter conditions with an InputXpression Structure.

  This function doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  The Object to change the Filter for.

  @{b}*InputXpression@{ub}
  A pointer to a InputXpression Structure that describes the new Filter
  conditions, the Structure is free to use again after this call.

  @{b}Result@{ub}
  If it's TRUE there was something that didn't make sense in the
  InputXpression and the Object won't process any CxMessage until either:
  this function, or ChangeCommodityFilter() succeeds the next time.
@ENDNODE


@NODE ChangeCommodityTranslater

    @{b}SYNTAX@{ub}
  ChangeCommodityTranslater(@{b}#Obj@{ub}.l,@{b}*InputEvent@{ub})

    @{b}STATEMENT@{ub}
  Change the Translater's InputEvent which replaces every CxMessage
  input event received.

  This statement doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  Object to use.

  @{b}*InputEvent@{ub}
  This is a pointer to an InputEvent Structure or a chain of InputEvent
  Structures and it is free to use again after this call.
@ENDNODE


@NODE CommodityCtrlCSignal

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.w = CommodityCtrlCSignal()

    @{b}FUNCTION@{ub}
  When a Commodity event has occured this function checks to see if
  the Ctrl C keys were pressed.

  @{b}Result@{ub}
  This is TRUE if Ctrl C was pressed else it's FALSE.
@ENDNODE


@NODE CommodityEvent

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.w = CommodityEvent()

    @{b}FUNCTION@{ub}
  This function checks if any Commodity event has occurred.

  A Commodity event can be one of the following: if any enabled Object
  receives the CxMessage it's looking for; if the user presses a button
  in Commodities Exchange; or, if the user presses Ctrl C in a CLI
  environment.

  CommodityEvent() doesn't wait for events to happen, unlike
  WaitCommodityEvent() - this is useful when the eventloop
  should go on.

  @{b}Result@{ub}
  This is TRUE for any Commodity event else it's FALSE.

  @{"EventLoop" LINK EventLoop1}
@ENDNODE


@NODE CommodityID

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.w = CommodityID()

    @{b}FUNCTION@{ub}
  This function return the ID of the Object that received a CxMessage
  or a command from Commoditites Exchange.

  @{b}Result@{ub}
  This is the same as #param1 in CreateCommodityObject() when the
  Object is created, but it could also be a command from Commodities
  Exchange if the result from CommodityType() is of Command Type.
@ENDNODE


@NODE CommoditySignal

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.w = CommoditySignal()

    @{b}FUNCTION@{ub}
  When a Commodity event has occured this function checks if the
  signal came from an Object or from Commodities Exchange.

  @{b}Result@{ub}
  This is TRUE if an Object signaled the Commodity or if
  Commodities Exchange send a command, else it's FALSE.
@ENDNODE


@NODE CommodityType

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.w = CommodityType()

    @{b}FUNCTION@{ub}
  This function return the Message Type of a CxMessage.

  The CxMessage is either of Command Type or Event Type, the Command Type
  comes when the user presses a button in the Commodities Exchange
  and the Event Type when an Object receives a CxMessage.

  @{b}Result@{ub}
  This is the Message Type.
@ENDNODE


@NODE CreateCommodityObject

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.b = CreateCommodityObject(@{b}#Obj@{ub}.l,@{b}Filter$@{ub},@{b}*InputEvent@{ub})

    @{b}FUNCTION@{ub}
  This function creates an Object. The Object is created in enabled state
  and starts to process CxMessages immediately if the Commodity is enabled.

  If the Object is already in use the function doesn't care and just creates
  a new Object without deleting the old one, after that there is no way to
  delete or change the old Object.

  An Object consists of three parts.

  * The Filter, whose only purpose is to filter out the kind of CxMessage
    the Object is interested in.  The Filter can be changed at runtime.

  * The Sender, whose only purpose is to signal the Commodity when it
    receives a CxMessage.

  * The Translater, whose only purpose is to translate every CxMessage
    input event this Object receives, into a new one - the Translater
    needs to be enabled to do this.  The Translater can be changed at
    runtime.

  @{b}#Obj@{ub}
  This is the Object number required and should not be higher then #param1
  in InitCommodity().

  @{"Filter$" LINK FilterStrings}
  This string sets the Filter conditions, a description of what this Object
  wants to know about.

  @{b}*InputEvent@{ub}
  This is a pointer to an InputEvent Structure or a chain of InputEvent
  Structures, the real input event is deleted and replaced by this new one.

  If the pointer is zero the real input event is just deleted, no other
  Commodity or the OS will know about it.

  @{b}Result@{ub}
  If this is #COERR_ISNULL (1) then the Object could not be created
  but if it's #COERR_BADFILTER (4) the Object is created but it
  doesn't process any CxMessages until the Filter is changed with
  ChangeCommodityFilter() or ChangeCommodityFilterIX().
@ENDNODE


@NODE FreeCommodityObject

    @{b}SYNTAX@{ub}
  FreeCommodityObject(@{b}#Obj@{ub}.l)

    @{b}STATEMENT@{ub}
  Free a Disabled or Enabled Object.

  This statement doesn't care if the Object is unused.

  @{b}#Obj@{ub}
  The Object to free.
@ENDNODE


@NODE InitCommodity

    @{b}SYNTAX@{ub}
  @{b}Result@{ub}.b = InitCommodity(@{b}Objects@{ub}.l,@{b}Name$@{ub},@{b}Title$@{ub},@{b}Description$@{ub},
                           @{b}Flag@{ub}.w,@{b}Priority@{ub}.b)

    @{b}FUNCTION@{ub}
  This function creates the basic stuff for a Commodity.

  The Commodity is created in a disabled state so after you've
  created some Objects, enable it with ActivateCommodity(TRUE).

  This is the Initroutine and should always be called first and
  can only be called once, at the moment, so if there is a failure
  with this call, then the program should always @{b}quit@{ub}.

  @{b}Objects@{ub}
  The number of Objects required,  Max Objects is 2046.

  @{b}Name$@{ub}
  This string describes the name of the Commodity and should be unique
  for each Commodity.

  @{b}Title$@{ub}
  This string describes the title that shows up in the window of
  Commodities Exchange when the Commodity is running.

  @{b}Description$@{ub}
  This string describes the description of the Commodity that shows up
  in the window of Commodities Exchange when the Commodity is running.

  @{b}Flag@{ub}
  If this is set to #COF_SHOW_HIDE then the Commodity should show/hide
  a GUI when the user presses show interface/hide interface buttons in
  Commodities Exchange and even let the GUI pop up when the Commodity
  is started more than once, instead of letting it quit as a none
  GUI Commodity should do.

  To do it properly the Commodity should read ToolType CX_POPUP and see
  if the user wants the GUI to pop up when the Commodity is started for
  the first time.

  @{b}Priority@{ub}
  The Commodity is inserted in the commoditys list and the place depends
  on the priority - ranging between -128 and 127. - A higher priority
  givs the Commodity a earlyer place in commoditys list and by that it
  gets the CXMessages earlyer.

  To do it properly the Commodity should read the ToolType CX_PRIORITY
  and use the priority specified by the user.

  @{b}Result@{ub}
  If the Commodity could not be created this is FALSE and the only
  thing is to @{b}quit@{ub}.
@ENDNODE


@NODE WaitCommodityEvent

    @{b}SYNTAX@{ub}
  WaitCommodityEvent()

    @{b}STATEMENT@{ub}
  This function checks if any Commodity event has occured.

  A Commodity event is one of the following: if an enabled Object
  receives the CxMessage it's looking for; if the user presses a button
  in Commodities Exchange; or, if the user presses Ctrl C in a CLI
  environment.

  WaitCommodityEvent() would wait for events to happen, unlike
  CommodityEvent(), - this is useful for saving CPU time.

  @{"EventLoop" LINK EventLoop2}
@ENDNODE



@NODE FilterStrings

    [Class]  {[-] (Qualifier|Synonym)}  [[-] upstroke]  [highmap|ANSICode]


    @{"       Class       " LINK Class}
    @{" Qualifier|Synonym " LINK Qualifier|Synonym}
    @{"     upstroke      " LINK upstroke}
    @{" highmap|ANSICode  " LINK highmap|ANSICode}


  Some simple input description strings.
  -------------------------------------
  "rawkey upstroke a"

  "rawkey -upsroke f1"

  "timer"

  "diskremoved"

  "rawkey leftbutton f2"
@ENDNODE

@NODE Class

 Class can be any one of the class strings in the table below.

    Class String
    ------------
    rawkey
    timer
    diskremoved
    diskinserted
@ENDNODE

@NODE Qualifier|Synonym

 Qualifier is one of the qualifier strings from the table below.
 A dash preceding the qualifier string tells the filter object not
 to care if that qualifier is present in the input event.
 Notice that there can be more than one qualifier (or none at all) in the
 input description string.

    Qualifier String
    ----------------
    lshift
    rshift
    capslock
    control
    lalt
    ralt
    lcommand
    rcommand
    numericpad
    repeat
    midbutton
    rbutton
    leftbutton
    relativemouse

 Synonym is one of the synonym strings from the table below.  These
 strings act as synonyms for groups of qualifiers. A dash preceding
 the synonym string tells the filter object not to care if that
 synonym is present in the input event.  Notice that there can be more
 than one synonym (or none at all) in the input description string.

    Synonym String
    --------------
    shift        look for either shift key
    caps         look for either shift key or capslock
    alt          look for either alt key
@ENDNODE

@NODE upstroke

 Upstroke is the literal string "upstroke".  If it is present alone the
 filter considers only upstrokes, if it's absent the filter considers only
 downstrokes and if preceded by a dash the filter considers both upstrokes
 and downstrokes.
@ENDNODE

@NODE highmap|ANSICode

 Highmap is one of the following strings:

    space , backspace , tab , enter , return , esc , del , help,
    up , down , right , left,
    f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10.

 For some reason commodities.library accept f11 and f12 as
 valid keys.

 ANSICode is a single character for example 'a' .

@ENDNODE


@NODE EventLoop1

  Repeat

    VWait()  ; - to slow down the loop.

    If CommodityEvent()

      If CommoditySignal()
        Other code...
        ... ...
      EndIf

      If CommodityCtrlCSignal()
        quit=1
      EndIf

    EndIf

  Until quit = 1
@ENDNODE


@NODE EventLoop2

  Repeat

    WaitCommodityEvent()

    If CommoditySignal()
      Other code...
      ... ...
    EndIf

    If CommodityCtrlCSignal()
      quit=1
    EndIf

  Until quit = 1
@ENDNODE

