@DATABASE "ACEImageLib.guide"
@MASTER "ACEImageLib"

@NODE MAIN "Main Menu"


                      +-------------------------------+
                      | ACE Image link library V0.26  |
                      +-------------------------------+



                      @{" Introduction                 " link 1introduction}
                      @{" Available functions          " link 2functions}
                      @{" Getting started              " link 3started}
                      @{" History                      " link 4history}
                      @{" Contact the author           " link 6contactme}
                      @{" Distribution                 " link 7distribution}
                      @{" The future...                " link 8future}
                      @{" Stop bits                    " link 5stop}

@ENDNODE

@NODE 1introduction "Introduction"



                      @{"What is this all about?  " link 1whatis}
                      @{"Who is it for?           " link 1who}
                      @{"System requirements.     " link 1whatos}
@ENDNODE

@NODE 1whatis "What is this?"

 A collection of OS-friendly functions enabling programmers to grab
 portions of Windows, called Images, that can be pasted afterwards
 on a Window or BitMap.
 These Images can be used as building blocks for game backgrounds or
 as the imagery of a Bob.
 These functions take care of the Image bitmap allocations, mask creation
 and Bob handling.

 You no longer need the AMOS/Pro and BLITZ packages!

 In fact, the Bob routines are even faster and better than the ones I made
 for AMOS/Pro.
 I know for sure, because I'm also the author of the TURBO_Plus and PowerBobs
 extensions available for the AMOS addicts.


@ENDNODE

@NODE 1who "Who is it for?"

 The ACEImageLib has been developped specially for the @{"ACE BASIC " link 1david}
 package wich is © David Benn.
 This does not mean that the ACEImageLib can't be used with another package.
 Some things to keep in mind...
 All parameters are passed onto the stack.
 Registers D0-D7/A0-6 must be preserved by the caller.

@ENDNODE

@NODE 1whatos "System requirements."


 All functions except, PasteScaledImageBM, will run under Wb 1.3 but
 all ACEImageLib functions will run a lot faster with Wb 2.x and up.
 This is because the Wb 2.x/3.x graphics library functions have been
 completely rewritten, giving a noticeable speedup.

@ENDNODE

@NODE 1david "David Benn"

 David Benn is the creator of the excellent ACE BASIC package.

 ACE is a freely distributable, recursive descent, peephole-optimising
 Amiga BASIC compiler which produces A68K-compatible assembly source code.
 ACE runs under Wb 1.3, 2.x and up, as do the executables it produces. ACE
 will run in 512K, but more than this is required for programs beyond about
 250 lines.

 ACE supports a large subset of AmigaBASIC. It also provides a variety of 
 commands, functions and features not found in AmigaBASIC.

 In many cases, ACE programs produce results which are similar or identical 
 to programs written in AmigaBASIC.

 To get more information on the ACE BASIC package contact David Benn:

 e-mail: D.Benn@appcomp.utas.edu.au

 snail-mail address:

 	9 Mayne Street,
	Invermay, Tasmania,
	7248, Australia.

@ENDNODE 

@NODE 2functions "Available functions."


                      @{"AllocImageList           " link 2allocimagelist}
                      @{"FreeImages               " link 2freeimages}
                      @{"FreeImage                " link 2freeimage}
                      @{"FreeImageMasks           " link 2freeimagemasks}
                      @{"FreeImageMask            " link 2freeimagemask}
                      @{"GrabImage                " link 2grabimage}
                      @{"PasteImageWd             " link 2pasteimagewd}
                      @{"PasteImageBM             " link 2pasteimagebm}
                      @{"PasteMaskImageBM         " link 2pastemaskimagebm}
                      @{"PasteScaledImageBM       " link 2pastescaledimagebm}
                      @{"GetImageAttr             " link 2getimageattr}
                      @{"MakeImageMask            " link 2makeimagemask}
                      @{"AllocClonedScreen        " link 2allocclonedscreen}
                      @{"FreeClonedScreen         " link 2freeclonedscreen}
                      @{"SwapClonedScreen         " link 2swapclonedscreen}
                      @{"ResetClonedScreen        " link 2resetclonedscreen}
                      @{"Bob                      " link 2bob}
                      @{"EraseBobs                " link 2erasebobs}
                      @{"EraseBob                 " link 2erasebob}
                      @{"BobDraw                  " link 2bobdraw}
                      @{"BobClear                 " link 2bobclear}
                      @{"BobSwap                  " link 2bobswap}
                      @{"CustomBlit               " link 2usecustomblitter}


@ENDNODE

@NODE 2allocimagelist "AllocImageList"


 =AllocImageList(Images)

 ULONG AllocImageList(UWORD )

 FUNCTION 
      Allocates enough memory to hold the pointers of the Images
      and their masks.
      Allocates Images<<3 bytes of memory.

 INPUT
      The maximum amount of Images (0 to 32767) you will need in your program.
      This function must be called before calling any of the other
      routines.
      When passed 0, it will erase all Images/Masks and free the
      memorylist that used to hold the pointers.

 RESULT
      The start address of the ImageList or FALSE if something went wrong.

@ENDNODE

@NODE 2freeimages "FreeImages"


 =FreeImages()

 UWORD FreeImages()

 FUNCTION
      Erase all Images in one go.
      Their associated pointers in the list will be cleared.
      Depending on the graphics library version it will use
      FreeBitmap (V39+) or FreeRaster + FreeMem bm_SIZEOF (<V39).
		It will also free all masks, if any, attached to the Images.

 RESULT
      The maximum amount of Images in the ImageList, see @{"AllocImageList" link 2allocimagelist}, or
      FALSE if no Images to free.

@ENDNODE

@NODE 2freeimage "FreeImage"


 =FreeImage(ImageID)

 UWORD FreeImage(UWORD )

 FUNCTION
      Free a particular Image. (0 to 32767)
      The associated pointer in the list will be cleared.
      Depending on the graphics library version it will use
      FreeBitmap (V39+) or FreeRaster + FreeMem bm_SIZEOF (<V39).
		It will also free it's mask if defined.

 RESULT
      ImageID being erased, even if not existing.
      Returns FALSE when ImageID >= Images

@ENDNODE

@NODE 2freeimagemasks "FreeImageMasks"


 =FreeImageMasks()

 UWORD FreeImageMasks()

 FUNCTION
      Erase all ImageMasks in one go.
      Their associated pointers in the list will be cleared and the
      memory used to contain the mask will be returned to the system.

 RESULT
      The maximum amount of Masks in the ImageList, see @{"AllocImageList" link 2allocimagelist}, or
      FALSE if no Masks to free.

@ENDNODE

@NODE 2freeimagemask "FreeImageMask"


 =FreeImageMask(ImageID)

 UWORD FreeImageMask(UWORD )

 FUNCTION
      Erase a particular ImageMask. (0 to 32767)
      The associated pointer in the list will be cleared.
      The memory used to hold the mask will be returned to the system.

 RESULTS
      ImageID erased even if none was defined.
      Returns FALSE when ImageID >= Images

@ENDNODE

@NODE 2grabimage "GrabImage"


 =GrabImage(ImageID,WindowPtr,X1,Y1,X2,Y2)
	
 ULONG GrabImage(UWORD, struct Window *, UWORD, UWORD, UWORD, UWORD )

 FUNCTION
      Grab a portion of the window to be used as a Image.
      ImageID	: the ImageID that will have this Image. (0 to 32767)
      Window	: pointer to the window where the Image will be grabbed from.
      X1/Y1 	: the upper left coordinates.
      X2/Y2 	: the bottom right coordinates of the Image to be grabbed.
      	Beware! It will grab an Image from X1,Y1 to X2,Y2 inclusive.
        	So from X1=0 to X2=15 is 16 pixels wide!


 RESULT
      TRUE if Image grabbed or FALSE if something went wrong.

@ENDNODE

@NODE 2pasteimagewd "PasteImageWd"


 =PasteImageWd(ImageID,WindowPtr,X,Y)

 ULONG PasteImageWd(UWORD, struct Window *, WORD, WORD )

 FUNCTION
      Paste the Image ImageID onto the window at coordinates X,Y.
      If the Image has a mask, it will call BltMaskBitMapRastPort else
      BltBitMapRastPort from the graphics library.
      You are able to use interleaved screens/bitmaps whithout any problem.
      When the Image has no mask, it will be rendered approx. 3 times
      faster.

 RESULT
      TRUE if Image has been pasted or FALSE if something went wrong.

 NOTES
      An Image pasted outside the window will be clipped or totally invisible.
      The result will only be FALSE if the Image doesn't exist.

@ENDNODE

@NODE 2pasteimagebm "PasteImageBM"


 =PasteImageBM(ImageID,BitMapPtr,X,Y)

 ULONG PasteImageBM(UWORD, struct BitMap *, WORD, WORD )

 FUNCTION
      Paste the Image ImageID into the bitmap at coordinates X,Y.
      It will do it's own mini-clipping, so that memory outside the
      bitmap is left untouched.
      Uses BltBitMap to blit the Image in the bitmap.
      This routine is approx. 3 times faster than the PasteImageWd when a
      mask has been defined and about 20% faster with no mask.
      It can be used in games for very fast background drawing.

 RESULT
      TRUE if Image has been pasted or FALSE if something went wrong.

 NOTES
      An Image pasted outside the bitmap will be clipped or totally invisible.
      The result will only be FALSE if the Image doesn't exist or pasted
      entirely outside the bitmap.

@ENDNODE

@NODE 2pastemaskimageBM "PasteMaskImageBM"


 =PasteMaskImageBM(ImageID,BitMapPtr,X,Y)

 ULONG PasteMaskImageBM(UWORD, struct BitMap *, WORD, WORD )

 FUNCTION
      Paste the Image ImageID into the bitmap at coordinates X,Y with masking
      of source image.
      It will do it's own mini-clipping, so that memory outside the
      bitmap is left untouched.
      Uses 3 BltBitMap calls to blit the Image with masking onto the bitmap.
      No 'standard' graphics call is able to blit to a BitMap with masking of
      the source image.
      Therefore I had to construct it myself.


 RESULT
      TRUE if Image has been pasted or FALSE if something went wrong.

 NOTES
      An Image pasted outside the bitmap will be clipped or totally invisible.
      The result will only be FALSE if the Image doesn't exist or pasted
      entirely outside the bitmap.
      The PasteMaskImageBM function will also work if no mask has been assigned
      to the image to be pasted.

@ENDNODE

@NODE 2pastescaledimagebm "PasteScaledImageBM"


 =PasteScaledImageBM(ImageID,BitMapPtr,X,Y,ScaledWidth,ScaledHeight)

 ULONG PasteScaledImageBM(UWORD, struct BitMap *, WORD, WORD, UWORD, UWORD )

 FUNCTION
      Paste the Image ImageID into the bitmap at coordinates X,Y.
      The Image will be scaled to the new ScaledWidth and ScaledHeight.
      This function uses the graphics library BitMapScale function.

 RESULT
      TRUE if Image has been scaled or FALSE if something went wrong.

 NOTES
      The bsa_SrcWidth/bsa_Height/bsa_XSrcFactor/bsa_YSrcFactor fields
      are set to the Image width/height.
      The bsa_XDestFactor and YDestFactor are set to the ScaledWidth and 
      ScaledHeight requested.
      The resulting scaled Width and Height are calculated by the BitMapScale
      function as follows:
      The Width : Image Width*ScaledWidth/Image Width
      The Height: Image Height*ScaledHeight/Image Height
      No check is made to ensure destbitmap is big enough to hold the
      scaled Image.
      Clipping may be added in a future release.

@ENDNODE

@NODE 2getimageattr "GetImageAttr"


 =GetImageAttr(ImageID,attribute_number)

 ULONG GetImageAttr(UWORD ,UWORD )

 FUNCTION
      Determines information about an image.

 INPUTS
      ImageID = the image to get an attribute from.
      attribute_number = A number telling which attribute of the Image should be
 		 returned:
 			 NBI_HEIGHT (0) returns the height in pixels.
 			 NBI_WIDTH  (1) returns the width in pixels.
 			 NBI_DEPTH  (2) returns the depth in bitplanes.
 			 NBI_BITMAP (3) returns the image his own BitMap.

 NOTES
      Size values returned by this function will reflect the exact size in pixels.
      They may differ from the values returned by GetBitMapAttr(V39+) function when
      examining the images bitmap.

@ENDNODE

@NODE 2makeimagemask "MakeImageMask"


 MakeImageMask(ImageID)

 ULONG MakeImageMask(UWORD )

 FUNCTION

 RESULT
      Undefined at this moment, but not FALSE if mask created.


 Still have to clean up this routine!!!
 It works allright, don't worry :-)
 Still have to find a way to make it completely OS-legal, so that
 it works with GFX boards.

 Custom routine that OR's all bits from all bitplanes.
 Uses the Blitter for maximum speed.
 It can handle normal Bitmaps as well as Interleaved Bitmaps(V39+).
 There is a small catch though with Interleaved Bitmaps.
 Instead of having only 1 bitplane, Interleaved Mask Bitmaps have bm_Depth
 number of planes!
 
@ENDNODE

@NODE 2allocclonedscreen "AllocClonedScreen"


 AllocClonedScreen(CloneID, ScreenPtr)

 ULONG AllocClonedScreen(UWORD , struct Screen *)

 FUNCTION
      Allocate a bitmap with the same caracteristics of this screen's
      BitMap.
      CloneID is a number from 0 to 7.

 RESULT
      TRUE if bitmap could be allocated and has same caracteristics as
      the screen bitmap to be cloned.
      FALSE if anything went wrong.

 NOTES
      The name of this function may be a bit misguiding since only a new
      BitMap and display memory, the alternate buffer, is allocated.


@ENDNODE

@NODE 2freeclonedscreen "FreeClonedScreen"


 FreeClonedScreen(CloneID)

 ULONG FreeClonedScreen(UWORD)

 FUNCTION
      Return the memory back to the system that was used by this cloned
      screen.

 RESULT
      TRUE if screen was cloned, FALSE if not.

 NOTES
      Before freeing a cloned screen, you have to call the @{"ResetClonedScreen" link 2resetclonedscreen}
      function.

@ENDNODE

@NODE 2swapclonedscreen "SwapClonedScreen"


 SwapClonedScreen(CloneID, ScreenPtr)

 BitMapPtr SwapClonedScreen(UWORD, struct Screen *)

 FUNCTION
      Changes the bitmapptr which will be used for this screen and viewport.
      Also all RastPort->BitMap ptrs of all windows opened in this screen
      get this new bitmapptr.
      ScrollVPort is used to make the changes visible.
      This function can be used to implement double buffering.

 RESULT
      The bitmapptr that was used by this screen's viewport.
      FALSE if cloned screen is not available.

 NOTES
      All window RastPort->BitMap ptrs are also changed so that any
      graphics output is redirected.
      I know of no other double buffering system that is offering such
      great flexibility.


@ENDNODE

@NODE 2resetclonedscreen "ResetClonedScreen"


 ResetClonedScreen(CloneID, ScreenPtr)

 BitMapPtr ResetClonedScreen(UWORD, struct Screen *)

 FUNCTION
      Reset the cloned screen bitmapptr to its original bitmapptr.
      Also all RastPort->BitMap ptrs of all windows opened in this screen
      get their original bitmapptr.

 RESULT
      The original BitMapPtr if screen was cloned, FALSE if not.

 NOTES
      This function will most likely be incorporated in the FreeClonedScreen
      function in the next version.

@ENDNODE

@NODE 2bob "Bob"


 Bob(BobID, BitMapPtr, X, Y, ImageID)

 ULONG Bob(UWORD, struct BitMap *, WORD, WORD, UWORD)

 FUNCTION
      Define a bob.  It will allocate a bob structure and a bitmap that will
      be used for background saving/restoring.
      BobID   : a number from 0 to 63
      ImageID : a number from 0 to 32767

 RESULT
      TRUE if bob has been defined succesfully.
      FALSE if out of memory or Image that will be used for this bob doesn't
      exist.

 NOTES
      The Image assigned to a bob doesn't have to have a mask.


@ENDNODE

@NODE 2erasebobs "EraseBobs"


 EraseBobs()

 VOID EraseBobs()

 FUNCTION
      Erase all defined bobs in one go and return the used memory to the
      system.


@ENDNODE

@NODE 2erasebob "EraseBob"


 EraseBob(BobID)

 VOID EraseBob(UWORD)

 FUNCTION
      Erase a particular bob and return the used memory to the system.


@ENDNODE

@NODE 2bobdraw "BobDraw"


 BobDraw(FirstBobID, LastBobID)

 VOID BobDraw(UWORD, UWORD)

 FUNCTION
      First of all, for every bob, save the area where it will be displayed.
      After this background saving, paste the bob's into the screen bitmap.


@ENDNODE

@NODE 2bobclear "BobClear"


 BobClear(FirstBobID, LastBobID)

 VOID BobClear(UWORD, UWORD)

 FUNCTION
      Restore the background where the bob has been pasted.


@ENDNODE

@NODE 2bobswap "BobSwap"


 BobSwap()

 VOID BobSwap()

 FUNCTION
      Use this function in conjunction with the @{"SwapClonedScreen" link 2resetclonedscreen} function
      to allow double buffering.


@ENDNODE

@NODE 2usecustomblitter "UseCustomBlitter"


 OldMode CustomBlit(BlitterMode)

 WORD CustomBlit(WORD)

 FUNCTION
      This function allows for switching between OS-friendly and custom hardware
      bob blitting routines.
      Bob Drawing and Clearing is about 200% faster when set to TRUE if using
      displays with 3+ bitplanes.

 RESULT
      TRUE if custom blitter routines were enabled, FALSE if not.

 NOTES
      When switching mode, all bobs have to be erased.
      When set to TRUE and the screen bitmap is interleaved (V39+), the
      image used for a bob must have the same depth (amount of planes) as
      the screen bitmap where it will be pasted.

@ENDNODE


@NODE 3started "Getting started."


 This section is intended for @{"ACE" link 1david} users only.


                      @{" Installation.          " link 3installation}
                      @{" Compiling the example. " link 3example}

@ENDNODE

@NODE 3installation "Installation."


 The ACEImageLib package can be installed very easy.
 It is best to copy the binary, AceImage.lib, into the ACE/lib drawer wich is
 normally assigned as ACELIB:

 To install the include files, a new drawer called LinkLibs, has to be created
 in the ACE/include drawer.
 Copy both files, ace_images.h and ace_image_funcs.h, into this newly created
 drawer.

 Having done this, you are now ready to @{"compile the example. " link 3example}

@ENDNODE

@NODE 3example "Compiling the example."


 The easiest way, is to first load the excellent Aide program.

 Select the Pogram menu and set the Source to the BobStars.b program.

 Select the Linker menu and Add the AceImage.lib to the list of currently
 added Modules.

 Select Program menu and Make the program Executable or Build an Application.

 If everything worked out, you should now be able to Run the executable.

 I hope this wasn't too difficult... ;-)

 The example has been compiled successfully with ACE V2.37.

 Use the SuperOptimizer V1.42 for more speed.

@ENDNODE

@NODE 4history "History."



                          History
                          =======

 13-18 March   1996 Starting the development of the AceImage.lib.

    19 March   1996 First working version send to David Benn for testing.

    29 March   1996 Started the development of the Bob commands.

    30 March   1996 Found a bug in the clipping section of the PasteImageBM
                    routine. Right and bottomedge clipping corrected.

    02 April   1996 Added the PasteMaskImageBM function.
                    This function makes it possible to paste an Image
                    with masking onto a BitMap.
                    It will also work if no Mask has been defined for
                    the Image.
                    I've opted for a separate function so that the user can 
                    decide if the mask has to be used or not.
                    This is analog to the BltBitMapRastPort and 
                    BltMaskBitMapRastPort graphics library calls.
                    The PasteMaskImageBM function will probably be used for
                    the OS-friendly Bobs.

                    Started the creation of the guide you are reading...

    03 April   1996 Added the PasteScaledImageBM function.

                    Added version string.

 09-17 April   1996 Completed the Bob routines

    20 April   1996 Added double buffered screens.

    21 April   1996 Added Bob double buffering

    23 April   1996 Completed the docs.

 10-17 May     1996 Finally, after a long break, I managed to complete
                    the first beta version.
                    It still has a bug! Do not use Bob 63.
                    Seems to be an offsetting problem, but don't have the
                    time to solve it now. Holiday time 8-) until June 3 !!!

 11-15 June    1996 After a well deserved holiday I managed to track down
                    the bug.  The BobClear and BobDraw routines had some
                    serious bugs.
                    Cleaned up the code a bit.
                    Everything seems to work well now.
                    Corrected the guide version number and made some small
                    modifications to the guide.


    01 January 2020 @{"The future..." link 8future}

@ENDNODE

@NODE 5stop "Stop bits..."


 I hope you will find the ACEImageLib functions useful.

 I've tried to make the ACEImageLib as OS-friendly and legal as
 possible.
 There is only 1 function that uses custom blitter code, the MakeImageMask
 function.
 I haven't found a way (yet) to create an Image mask using graphics library
 calls.

 The assembler source is available on special request, ie you want to
 participate in the development of the ACEImageLib.

 Bugreports or useful additions and comments are highly appreciated and
 can be sent to @{"me" link 6contactme}.

@ENDNODE

@NODE 6contactme "How to contact me."


 I can only be contacted by 'snail-mail' or phone.
 A postcard would be nice ;-)

 Address:

 Manuel ANDRE
 Arbeidersstraat 9
 2600   BERCHEM
 BELGIUM

 PHONE: 32-3-230-66-10

@ENDNODE

@NODE 7distribution "Distribution."


 The ACEImageLib may be distributed freely without my notice.
 The cost of the package may not exceed the normal fees, about 3 USD,
 when distributed by a PD-library.
 The only exception to this is when the ACEImageLib is included on
 a CD like, for example, the Aminet series.

@ENDNODE

@NODE 8future "The future..."


 The docs are far from perfect, it's easier to write the routines than
 to explain them...
 At this moment I don't have the time to write a more detailed version.

 Other routines to expect in newer releases are:

 Bob collision routines, with the blitter or Cpu.
 Image flipping routines. X/Y axis or both.
 Game background drawing routines, ie map drawing, loading.
 It would also be nice to convert it into a shared library, but I don't
 have the knowledge (yet) to do that. :(

 Any useful addition requested...

@ENDNODE
