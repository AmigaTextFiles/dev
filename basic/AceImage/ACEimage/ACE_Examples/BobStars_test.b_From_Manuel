/* Do not forget to edit line 159, the path to the graphics... */

LIBRARY "graphics.library"
LIBRARY "exec.library"

DECLARE FUNCTION WaitTOF() LIBRARY graphics

#include <intuition/Intuition.h>
#include <funcs/exec_funcs.h>
#include <LinkLibs/ace_images.h>


/* To be compiled with ACE V2.37/2.40 */

/* Newly improved version!!! Uses arithmetic shifts for multiplications
   and divisions. */

/* Use the SuperOptimizer V2.28 for best speed!
   Make sure you have -> V2.28 <- of the SuperOptimizer. */

SUB LDecArray(ADDRESS TheArray, LONGINT Value,SHORTINT StartIndex, SHORTINT EndIndex)

ASSEM
	MOVEQ.L	#0,D1
	MOVE.L	-4(A5),A0	; The arrayptr
	MOVE.L	-8(A5),D0	; The value
	BLE.S	ExitLDecArray
	CMP.L	#8,D0
	BGT.S	ExitLDecArray
	MOVE.W	-10(A5),D1	; The startindex
	MOVE.W	-12(A5),D2	; The endindex
	SUB.W	D1,D2		; LoopCounter
	BMI.S	ExitLDecArray
	ADD.W	D1,D1
	ADD.W	D1,D1		; startindex * 4. (Array of LONGS...)
	ADD.L	D1,A0		; point to first element in the array we want.
	ADD.W	D0,D0		; Value*2 for jumptable indexing.
	MOVE.W	LDecJmpTable(PC,D0.W),D0
	JMP	LDecJmpTable(PC,D0.W)
LDecJmpTable:
	DC.W	ExitLDecArray-LDecJmpTable
	DC.W	Dec1-LDecJmpTable
	DC.W	Dec2-LDecJmpTable
	DC.W	Dec3-LDecJmpTable
	DC.W	Dec4-LDecJmpTable
	DC.W	Dec5-LDecJmpTable
	DC.W	Dec6-LDecJmpTable
	DC.W	Dec7-LDecJmpTable
	DC.W	Dec8-LDecJmpTable
ExitLDecArray:
END ASSEM
	EXIT SUB
ASSEM
Dec1:
	SUBQ.L	#1,(A0)+
	DBRA	D2,Dec1
END ASSEM
	EXIT SUB
ASSEM
Dec2:
	SUBQ.L	#2,(A0)+
	DBRA	D2,Dec2
END ASSEM
	EXIT SUB
ASSEM
Dec3:
	SUBQ.L	#3,(A0)+
	DBRA	D2,Dec3
END ASSEM
	EXIT SUB
ASSEM
Dec4:
	SUBQ.L	#4,(A0)+
	DBRA	D2,Dec4
END ASSEM
	EXIT SUB
ASSEM
Dec5:
	SUBQ.L	#5,(A0)+
	DBRA	D2,Dec5
END ASSEM
	EXIT SUB
ASSEM
Dec6:
	SUBQ.L	#6,(A0)+
	DBRA	D2,Dec6
END ASSEM
	EXIT SUB
ASSEM
Dec7:
	SUBQ.L	#7,(A0)+
	DBRA	D2,Dec7
END ASSEM
	EXIT SUB
ASSEM
Dec8:
	SUBQ.L	#8,(A0)+
	DBRA	D2,Dec8
END ASSEM

END SUB
	

SUB SHORTINT GetTheBobs

	DECLARE STRUCT _Window *WindowPointer

	SHORTINT N
	SHORTINT X

	WindowPointer=WINDOW(7)

	IF AllocImageList(20) THEN

		N=0
		For X=0 To 304 Step 16
			IF GrabImage(N,WindowPointer,X,64%,X+15%,79%)=0 THEN
				PRINT "Image not grabbed! ";N
				Repeat:SLEEP:Until Inkey$<>""
			END IF
			IF MakeImageMask(N)=0 THEN
				PRINT "Mask not set! ";N
				Repeat:SLEEP:Until Inkey$<>""
			END IF
			++N
		Next X 
		GetTheBobs=-1

	ELSE

		GetTheBobs=0

END IF

END SUB

DECLARE STRUCT _Window *WindowPointer
DECLARE STRUCT BitMap *BobBitMap
ADDRESS ScreenPointer

SHORTINT N,K,Cnt,BobInit

DIM LONGINT SPEED(64)
DIM LONGINT R(64)
DIM LONGINT T(64)
DIM LONGINT MX(64)
DIM LONGINT MY(64)
DIM LONGINT TEMP_MX(64)
DIM LONGINT TEMP_MY(64)
DIM LONGINT X(64)
DIM LONGINT Y(64)
DIM LONGINT C(64)
DIM SHORTINT G(64)
DIM SHORTINT OX(64)
DIM SHORTINT OY(64)

/* Set to your own directory... */

IFF Open #1,"BobStars.iff"

SCREEN 1,IFF(1,1),IFF(1,2),IFF(1,3),1

REPEAT
	INPUT "Number of balls (max 64): ";N
UNTIL N>0 AND N<65

IFF Read #1,1

BobInit=GetTheBobs


IF BobInit=0 THEN
	STOP
END IF

--N

CLS

SetTaskPri(FindTask(0),127)
WindowPointer=WINDOW(7)
BobBitMap=Screen(4)
ScreenPointer=WindowPointer->WScreen

FOR K=0 TO N
	C(K)=1
NEXT K

AllocClonedScreen(0,ScreenPointer)

CustomBlit(-1)

BobBitMap=SwapClonedScreen(0,ScreenPointer)
Repeat

	LDecArray(VARPTR(C(0)),1,0,N)
	LDecArray(VARPTR(T(0)),1,0,N)

	For Cnt=0 To N

'		C(Cnt)=C(Cnt)-1
'		T(Cnt)=T(Cnt)-1
		X(Cnt)=X(Cnt)+MX(Cnt)
		Y(Cnt)=Y(Cnt)+MY(Cnt)

	Next Cnt

	For Cnt=0 To N


		IF C(Cnt)=0 THEN
			MX(Cnt)=(Rnd*2048)-1024&
			MY(Cnt)=(Rnd*2048)-1024&
			X(Cnt)=81920+SHL(MX(Cnt),4)
			Y(Cnt)=65535+SHL(MY(Cnt),4)
			SPEED(Cnt)=(Rnd*1024)+1&
			C(Cnt)=INT((Rnd*20))+25
			R(Cnt)=SHR(C(Cnt),4)
			T(Cnt)=R(Cnt)
			G(Cnt)=16
		END IF

		TEMP_MX(Cnt)=MX(Cnt)\SPEED(Cnt)
		TEMP_MY(Cnt)=MY(Cnt)\SPEED(Cnt)

		IF T(Cnt)=-1 THEN
			G(Cnt)=G(Cnt)-1%
/*			IF G(Cnt)<0 THEN
				PRINT "Bob Image out of Range!"
				Repeat:SLEEP:Until Inkey$<>""
			END IF */
			T(Cnt)=R(Cnt)
		END IF

		OX(Cnt)=SHR(X(Cnt),9)
		OY(Cnt)=SHR(Y(Cnt),9)

	NEXT Cnt

	For Cnt=0 To N

		MX(Cnt)=MX(Cnt)+TEMP_MX(Cnt)
		MY(Cnt)=MY(Cnt)+TEMP_MY(Cnt)
		Bob(Cnt,BobBitMap,OX(Cnt),OY(Cnt),G(Cnt))
	Next

	BobClear(0,N)
	BobDraw(0,N)
	BobSwap

	Call WaitTOF()
	BobBitMap=SwapClonedScreen(0,ScreenPointer)

Until INKEY$<>""

ResetClonedScreen(0,ScreenPointer)
FreeClonedScreen(0)
EraseBobs
AllocImageList(0)

SCREEN CLOSE 1
IFF Close #1

END
