'**
'**	dignet.library include
'**	Copyright © 1997 by Kenneth "Kenny" Nilsen/Digital Surface
'**
'**	$VER: DIGNET.BC 1.
'**
'**	converted by steffen.leistner@styx.in-chemnitz.de
'** TABWIDTH = 4


'* Error codes

CONST DNETERROR_OK& 			=  0&	'everything is ok
CONST DNETERROR_OVERFLOW&		= -1&	'buffer overflow (your string buffer)
CONST DNETERROR_WRONGNET&		= -2&	'you tried TO free wrong net structure
CONST DNETERROR_TIMEOUT&		= -3&	'timed out waiting TO receivce chars
CONST DNETERROR_POINTERERROR&	= -4&	'wrong pointer (null ptr.)
CONST DNETERROR_OUTOFMEMORY&	= -5&	'NOT enough memory (Send/ReceiveNet())
CONST DNETERROR_FILEERROR&		= -6&	'file not found (Send/ReceiveNet())
CONST DNETERROR_PROTOCOL&		= -7&	'protocol error (not a protocol in
										'the other end?)
CONST DNETERROR_ABORTED&		= -8&	'protocol was aborted

'* IOEXT

CONST DNIOEXT_SIZEOF&			= 80&	'max size for IOEXT structure

'* InitModem buffer size

CONST INITMODEMBUFFER&			= 16&	'length of initmodem's buffer

'* Resource tracking public structure

'DIGNETRT fields
CONST DNRT_ID% 				=  0%		'net ID
CONST DNRT_NET%				=  4%		'ptr. TO netstructure
CONST DNRT_TASK%			=  8%		'ptr. TO task structure USING the net
CONST DNRT_TASKNAME%		= 12%		'ptr. TO task NAME of that task
CONST DNRT_DEVICENAME%		= 16%		'ptr. TO device NAME in use
CONST DNRT_UNIT%			= 20%		'unit number in use
CONST DNRT_SP%				= 22%		'RETURN address
CONST DNRT_MESSAGEPORT%		= 26%		'ptr. TO message port of device
CONST DNRT_MESSAGESTRUCT%	= 30%		'ptr. TO IO message of device
CONST DNRT_LASTCOMMAND%		= 34%		'command number ON last librarycall
CONST DNRT_TASKSTATUS%		= 38%		'BOOL ON the tasks existance (true=ok)
										'20 reserved FOR future extensions
CONST DNRT_SIZEOF%			= 60%

' NOTE WELL: The public structure is NOT compatible with the private structure!

'* Command numbers:

CONST CMDALLOCNET&				=	1&
CONST CMDREADNET&				=	2&
CONST CMDWRITENET&				=	3&
CONST CMDQUERYNET&				=	4&
CONST CMDABORTNET&				=	5&
CONST CMDINITIOEXT&				=	6&
CONST CMDREADIOEXT&				=	7&
CONST CMDSENDNET&				=	8&
CONST CMDRECEIVENET&			=	9&
CONST CMDTIMEOUT&				=	10&
'** new from v2
CONST CMDREADSTRING&			=	11&
CONST CMDWRITESTRING&			=	12&
CONST CMDGETNETPORT&			=	13&
'** new from v3
CONST CMDINITMODEM&				=	14&
CONST CMDCALLMODEMDT&			=	15&
CONST CMDCALLMODEMDP&			=	16&
CONST CMDWAITMODEM&				=	17&
CONST CMDHANGUPMODEM&			=	18&
CONST CMDSTOPWAITING&			=	19&
CONST CMDFLUSHNET&				=	20&
CONST CMDSETBAUD&				=	21&
CONST CMDCONVERTMODEMSTRING&	=	22&
CONST CMDGETIOMSG&				=	23&
CONST CMDGETMODEMSTATUS&		=	24&
CONST CMDGETCURRENTDEVICE&		=	25&
CONST CMDGETCURRENTUNIT&		=	26&
CONST CMDGETBAUDRATE&			=	27&
CONST CMDPARSECONNECT&			=	28&
CONST CMDSETDEFAULT&			=	29&
CONST CMDCONVERTTOPC&			=	30&
CONST CMDCONVERTTOAMIGA&		=	31&
CONST CMDFREECONVERT&			=	32&
CONST CMDOBTAINNET&				=	33&
'** new from v4
CONST CMDWAITTEXT&				=	34&
CONST CMDCONVERSETEXT&			=	35&
CONST CMDCAPTURETEXTSTART&		=	36&
CONST CMDCAPTURETEXTEND&		=	37&
CONST CMDSETPARITY&				=	38&
CONST CMDSETHANDSHAKE&			=	39&
CONST CMDSETSTOPBITS&			=	40&
CONST CMDSETBITWIDTH&			=	41&
CONST CMDGETPARITY&				=	42&
CONST CMDGETHANDSHAKE&			=	43&
CONST CMDGETSTOPBITS&			=	44&
CONST CMDGETBITWIDTH&			=	45&

'* New from 3.1:

' Update structure for the DigNet protocol:

'DNUPDATE fields
CONST DNU_FILENAME% = 0% 	'name of file without path
CONST DNU_FILESIZE% = 108%	'size of file in bytes
CONST DNU_RATE%		= 112%	'transfer rate bytes/s
CONST DNU_EXPECTED%	= 116%	'expected time on transfer
CONST DNU_USED%		= 128%	'time used on transfer
CONST DNU_STATUS%	= 140%	'status flags
CONST DNU_HOOK%		= 142%	'hook to be called after each block transfer
CONST DNU_SIZEOF%	= 146%

CONST DNUSTATUS_OK&			=	&H0		'everything IS ok
CONST DNUSTATUS_ERROR&		=	&H1		'transfer had an ERROR
CONST DNUSTATUS_RESENDING&	=	&H2		'resending block/file
CONST DNUSTATUS_WAITING&	=	&H4		'waiting TO receive/send file
CONST DNUSTATUS_ABORT&		=	&H8		'was aborted
										'(if you set this flag the
										'protocol will be aborted)
CONST DNUSTATUS_END&		=	&H10	'END of file (done)

'To let user abort a protocol transfer you need to create a subtask that will
'check for user input such as keypress/mousebutton/gadget etc. If user want to
'abort transfer you must set the _abort flag. The other end of the protocol
'will read  this as user abort and end. If not this flag can be interacted the
'protocol will not stop until the whole file is transfered/resent error free.

'*** CaptureTextStart modes:

CONST DNCAPTURENEW&		=	0&
CONST DNCAPTUREAPPEND&	=	-1&

'*** Modes for SetParity

CONST DNPARITYNONE&		=	0&
CONST DNPARITYEVEN&		=	1&
CONST DNPARITYODD&		=	2&
CONST DNPARITYMARK&		=	3&
CONST DNPARITYSPACE&	=	4&

'*** Modes for SetHandshake

CONST DNHANDSHAKENONE&	=	0&
CONST DNHANDSHAKE7WIRE&	=	1&		'RTS/CTS
CONST DNHANDSHAKEX&		=	2&		'XON/XOFF
