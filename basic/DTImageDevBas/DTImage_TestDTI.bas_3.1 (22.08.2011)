' *********************************************************************
'                          DTImage_TestDTI
'      by/de Dámaso D. Estévez {correoamidde-aminet000,yahoo,es}
'         AmiSpaTra - http://www.xente.mundo-r.com/amispatra/
'
'                   based over TestDTI.c source code
'              basado sobre el código fuente de TestDTI.c
'             (C) Copyright 2007-2008 Andreas R. Kleinert
'                             ------------
'            All rights reserved over this derivative work:
'               my Hisoft Basic developpers package.
'      Forbidden to remove ALL legal/copyrights remarks included
'          in this package: if you create a derivate work,
'                 you MUST to include all legal notes.
'
'     El programa carga una imagen a través de los tipos de datos
'           y separa los datos gráficos RVA del canal alfa 
'          y los guarda en ficheros separados P6 PGM/P5 PPM.
'                             ------------
'  The program loads an image via DT and splits the RGB graphic data
'  from alpha channel and save both in separate files P6 PGM/P5 PPM.
'
'      Todos los derechos reservados sobre este trabajo derivado:
'   mi paquete para desarrolladores que programen con Hisoft Basic.
'         Está prohibido eliminar cualquier comentario o nota
'    de autoría/legal de este paquete: si crea un trabajo derivado
'       HA DE INCLUIR OBLIGATORIAMENTE TODAS LAS NOTAS LEGALES.
' *********************************************************************

'        Compiler's metacommands (see the Hisoft Basic Manual)
' Metacomandos para el compilador (consulte el manual del Hisoft Basic)
' ---------------------------------------------------------------------
REM $NOWINDOW
REM $NOLIBRARY
REM $NODEBUG
REM $NOVARCHECKS
REM $NOBREAK

'     Include files declaring functions, subroutines and constants
' Ficheros de inclusión que declaran funciones, subrutinas y contantes
' ---------------------------------------------------------------------
REM $include exec.bh
REM $include dos.bh
REM $include utility.bc
REM $include dtimage.bh

'    From/De:  http://aminet.net/package/dev/basic/AST_HBRoutines
'         Obtain a command line interface's argument (Shell)
'   Obtiene un argumento de la interfaz de línea de comandos (Shell)
' ---------------------------------------------------------------------
REM $include BLib_AST/SGetArg.bas

'                 C= string version / Cadena de versión de C=
' ---------------------------------------------------------------------
ver_text$ = "$VER: DTImage_TestDTI 3.1 (22.08.2011) by Dámaso 'AmiSpaTra' Domínguez based over TestDTI.c source wrote by Andreas R. Kleinert "+CHR$(0)

'            Opening the libraries / Abriendo las bibliotecas
' ---------------------------------------------------------------------
LIBRARY OPEN "exec.library"
LIBRARY OPEN "dos.library"
LIBRARY OPEN "utility.library"
LIBRARY OPEN "dtimage.library", 3&

'        Template, but it dont follow the AmigaOS rules B'^(
'        Sintaxis, pero no según las normas del AmigaOS B'^(
' ---------------------------------------------------------------------
usage$ = "USAGE: TestDTI 32|8 from_FILE to_RGB_FILE.P6 to_ALPHA_GRAY_FILE.P5"

'                   Example for to use only from CLI
'    Ejemplo para utilizar sólo de la interfaz de línea de comandos
' ---------------------------------------------------------------------
IF PEEKL(SYSTAB+8) = 0 THEN

	'          Obtaining the args / Obteniendo los argumentos
	' ---------------------------------------------------------------
	a&   = VAL(SGetArg$(1%,usage$))
	fi$  =     SGetArg$(2%,usage$)
	fo1$ =     SGetArg$(3%,usage$)
	fo2$ =     SGetArg$(4%,usage$)

	'           First arg not correct or insuficient args
	'  Primer argumento incorrecto o no hay argumentos suficientes
	' ---------------------------------------------------------------
	IF (a& <> 32 AND a& <> 8) AND (fi$ = "" OR fo1$ = "" OR fo2$ = "") THEN

		PRINT usage$		
		Goto Salida

	END IF

	'            Declaring some vars with initial values
	'   (btw, a pointer for every data type is always a long :D).
	'
	'    Declarando algunas variables con sus valores iniciales
	'      (a propósito, un puntero de cualquier tipo de dato
	'    es siempre un entero largo, como por ejemplo UBYTE * :D).
	' ---------------------------------------------------------------
	w& = 0&
	h& = 0&
	d& = 0&
	retval& = 0&
	transcolor& = 0&

	image& = 0&
	transmap& = 0&

	' ==============================================================
	'                 32 bits option: reading as RGBA
	'              Opción de 32 bits: lectura como RVAN
	' ==============================================================

	IF a& = 32& THEN

		retval& = DTI_ReadPic32&(SADD(fi$+CHR$(0)), VARPTR(image&), VARPTR(w&), VARPTR(h&), 0&)

		IF retval& THEN

			' -------------------------------------------------------------
			' Kleinert uses two loops... I think what one is more fast O:)
			' Kleinert utiliza dos bucles... Creo que uno es más rápido O:)
			' -------------------------------------------------------------

			' Opening the destination / Abriendo los ficheros de destino
			' ----------------------------------------------------------
			fileh1& = xOpen&(SADD(fo1$+CHR$(0)), MODE_NEWFILE&)
			fileh2& = xOpen&(SADD(fo2$+CHR$(0)), MODE_NEWFILE&)

			IF fileh1& AND fileh2& THEN

				' RGB file / Fichero RVA
				' ----------------------
				header$ = "P6"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
				dummy& = FWrite&(fileh1&, SADD(header$), LEN(header$), 1&)

				' Alfa channel file / Fichero con el canal alfa
				' ---------------------------------------------
				header$ = "P5"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
				dummy& = FWrite&(fileh2&, SADD(header$), LEN(header$), 1)

				s& = image&

				' Writing the data in the files / Escribiendo los datos en los ficheros
				' ---------------------------------------------------------------------
				FOR i% = 0% TO h&-1&

					FOR j% = 0% TO w&-1&

						dummy& = FWrite&(fileh1&, s&, 3, 1)
						s& = s& + 3&	' Updating the pointer / Actualizando el puntero

						dummy& = FWrite&(fileh2&, s&, 1, 1)
						s& = s& + 1&	' Updating the pointer / Actualizando el puntero

					NEXT j%

				NEXT i%

				' Closing the destination files / Cerrando los ficheros de destino
				' ----------------------------------------------------------------
				dummy& = xClose&(fileh2&)
				dummy& = xClose&(fileh1&)

			' ------------------
			' file1& and fileh2&
			' ------------------
			END IF

			'    Releasing this mem chunk allocated with DTI_ReadPic32&
			' Liberando este bloque de memoria reservado con DTI_ReadPic32&
			' -------------------------------------------------------------
			FreeVec image&

		' -------
		' retval&
		' -------
		ELSE

			PRINT CHR$(10);"Error (DOS code";RTRIM$(STR$(IoErr&));")!";CHR$(10)

		' -------
		' retval&
		' -------
		END IF

	' --
	' a&
	' --
	END IF

	' ==============================================================
	'             8 bits option: includes the colomap
	'      Opción de 8 bits: incluye el mapa o paleta de color
	' ==============================================================

	IF a& = 8& THEN

		retval& = DTI_ReadPic&(SADD(fi$+CHR$(0)), VARPTR(image&), VARPTR(w&), VARPTR(h&), VARPTR(d&), VARPTR(transcolor&), VARPTR(transmap&), 0&)

		IF retval& THEN

			IF d& <= 8 THEN

				fileh1& = xOpen&(SADD(fo1$+CHR$(0)), MODE_NEWFILE&)
				fileh2& = xOpen&(SADD(fo2$+CHR$(0)), MODE_NEWFILE&)

				IF fileh1& AND fileh2& THEN
	
					' RGB file (8 > 24) / Fichero RVA (8 > 24)
					' ----------------------------------------
					header$ = "P6"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
					dummy& = FWrite&(fileh1&, SADD(header$), LEN(header$), 1)

					' RGB index / Índice RVA
					' -----------------------
					header$ = "P5"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
					dummy& = FWrite&(fileh2&, SADD(header$), LEN(header$), 1)

					s& = image&

					FOR i% = 0% TO h&-1&

						FOR j% = 0% TO w&-1&

							dummy& = FWrite&(fileh1&, transmap&+PEEKB(s&)*3&, 3, 1)
							dummy& = FWrite&(fileh2&, s&, 1, 1)
							s& = s& + 1&

						NEXT j%

					NEXT i%

					dummy& = xClose&(fileh2&)
					dummy& = xClose&(fileh1&)

				' -------------------
				' fileh1& and fileh2&
				' -------------------
				END IF

			' --
			' d&
			' --
			ELSE

				fileh1& = xOpen&(SADD(fo1$+CHR$(0)), MODE_NEWFILE&)

				' There are an alpha channel? / Hay un canal alfa?
				' ------------------------------------------------
				IF (transcolor& = -2 AND transmap&) THEN
					fileh2& = xOpen&(SADD(fo2$+CHR$(0)), MODE_NEWFILE&)
				END IF

				IF fileh1& THEN

				
					' RGB file (32 or 24 bits) / Fichero RVA (32 o 24 bits)
					' -----------------------------------------------------
					header$ = "P6"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
					dummy& = FWrite&(fileh1&, SADD(header$), LEN(header$), 1)

					' Alpha channel, if this exists (file opened) / Canal alfa, si existe (fichero abierto)
					' -------------------------------------------------------------------------------------
					IF fileh2& THEN
						header$ = "P5"+CHR$(10)+LTRIM$(STR$(w&))+" "+LTRIM$(STR$(h&))+CHR$(10)+"255"+CHR$(10)
						dummy& = FWrite&(fileh2&, SADD(header$), LEN(header$), 1)
					END IF

					s& = image&

					FOR i% = 0% TO h&-1&

						FOR j% = 0% TO w&-1&

							dummy& = FWrite&(fileh1&, s&, 3, 1)
							s& = s& + 3&

							'      Writing alpha channel data, if this exists (file opened)
							' Escribiendo los datos del canal alfa, si existen (fichero abierto)
							' ------------------------------------------------------------------
							IF fileh2& THEN
								dummy& = FWrite&(fileh2&, s&, 1, 1)
								s& = s& + 1&
							END IF

						NEXT j%

					NEXT i%

					dummy& = xClose&(fileh1&)

					IF fileh2& THEN
						dummy& = xClose&(fileh2&)
					END IF
			
				' -------
				' fileh1&
				' -------
				END IF

			' --
			' d&
			' --
			END IF


			IF transmap& THEN
				FreeVec transmap&
			END IF

			FreeVec image&

		' -------
		' retval&
		' -------
		ELSE

			PRINT CHR$(10);"Error (DOS code";LTRIM$(STR$(IoErr&));")!)";CHR$(10)

		' -------
		' retval&
		' -------
		END IF

	' --
	' a&
	' --
	END IF

ELSE

	BEEP

' -------
' PEEKW()
' -------
END IF

' -----
Salida:
' -----
LIBRARY CLOSE

END
