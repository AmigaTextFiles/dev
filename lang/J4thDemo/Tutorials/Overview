
                     INTRODUCTION TO JFORTH
    
    (Note that features followed by (*) are not provided in the 
    demo)
    
    JForth is a programming language that allows you to interact 
    with your Amiga.  When you are programming in JForth, you 
    are "inside" the language. You can access any data 
    structure, test any routine, or use any development tool, 
    right from the keyboard.  This direct communication with the 
    computer can improve your productivity, giving you 
    additional time to improve the quality of your software 
    products.
    
    JForth is based on the 1983 standard Forth language.  Forth 
    was first conceived by Charles Moore when he wanted a new 
    language for controlling telescopes.  He developed a 
    language based on a dictionary of words.  This dictionary 
    can be extended by writing new words based on the old ones. 
    Since Mr. Moore's original version, Forth has been 
    translated to almost every type of computer from the biggest 
    mainframes to the smallest microcomputers.
    
    Since a minimal Forth can be implemented in just a few 
    kilobytes of memory, it is often used in very small embedded 
    computer systems for process control and robotics.  Forth, 
    however, is equally appropriate for larger, more advanced, 
    computers like the Amiga.  Forth is a very flexible language 
    and can be adapted to larger computers without losing the 
    flavor of the original language. 
    
    JForth is an implementation of Forth designed specifically 
    for the Commodore Amiga.  JForth uses a 32-bit stack and 
    compiles directly to 68000 machine code.  This makes JForth 
    faster than most Forths.  JForth also provides an extensive 
    set of tools for accessing the special features of the 
    Amiga.  You can call any Amiga Library routine by name (*) and 
    reference any Amiga structure using constructs similar to 
    'C'.  JForth also has some special toolboxes that support 
    simple graphics, Intuition menus, IFF files, and other Amiga 
    features.  These toolboxes can be used directly to simplify 
    your Amiga programming.  In the product release, the source 
    code for all these toolboxes is provided (*) so you can 
    customize them if needed or study them as examples of Amiga 
    programming.  JForth also provides over a dozen small sample 
    programs for those, like me, who learn best by example.
    (This demo includes a few of them).  
    
    JForth also allows you to do things that are unique in the 
    Forth experience, the most dramatic being CLONE (*).  This 
    exeptional utility allows you to create a totally 
    independant, standalone version of your program of minimal 
    size that is entirely royalty free! 
    
    
                   MAJOR FUNCTIONAL SYSTEMS
    
    Amiga Library Calls
    
    JForth provides a system for easily calling any Amiga 
    Library routine by name (*).  It will figure out what 68000 
    registers the parameters go into and build the appropriate 
    code.  Thus you can simply pass parameters on the stack in 
    the order described in the Amiga documentation.  A number of 
    toolboxes have been written for supporting specific parts of 
    the Amiga Library including EZMENUS, Graphics, the Serial 
    Device, ANSI codes, and much more.  In this demo, while you
    can't create new calls to Amiga libraries, it DOES include
    many in pre-compiled form.  To see a list, in JForth type:
    
       WORDS-LIKE ()
    
    Amiga Structure Support  
    
    JForth provides the equivalent to all of the ".h" include 
    files from 'C' (*). These ".j" files define all of the 
    necessary structures and constants for passing information 
    to the Amiga Library routines.  Structures can be dumped 
    interactively with all members shown by name and value for 
    debugging by using DST.  Again, while the JForth include 
    files are not provided with the demo, many structures exist 
    in pre-compiled form.
    
    ARexx Support
    
    ARexx is a language that helps various applications 
    communicate with each other.  A spread sheet program, for 
    example, could communicate with a data base program.  These 
    tools help you write ARexx compatible programs.  The demo 
    JForth does include the AREXX interface and itself opens an 
    AREXX port.  This port can be used to form an integrated 
    text editor environment with Textra.
    
    Assembler
    
    JForth supports two 68000 assemblers, one with Reverse 
    Polish Notation (RPN) and one with Motorola-like syntax.  
    The RPN assembler can be used to create macros but the 
    Motorola assembler is easier to read.  We also offer a 
    Disassembler.
    
    Block Support and SCRED  (*)
    
    For those who prefer the old fashioned BLOCK or SCREEN 
    environment, we provide LIST, LOAD and the standard line 
    editor.  We also provide a WYSIWYG SCREEN editor called 
    SCRED.  (We recommend the use of normal text files with 
    JForth).
    
    Clone  (*)
    
    Clone can be used to generate small, royalty free, 
    executable images of your JForth programs.  Clone will take 
    a compiled JForth program, extract out all of the code and 
    data needed to run it, and reassemble a smaller version of 
    it.  All of the JForth development tools, the name fields 
    and link fields and any other unused words are left behind.  
    The final image size is comparable to images created using a 
    'C' compiler and linker. Images can be saved with a symbol 
    table for use with WACK or other debuggers (if needed).  The 
    JForth Source Level Debugger can also be used with Cloned 
    programs.  Most programs will Clone without modification if 
    they follow a few simple rules regarding run time 
    initialization of variables or arrays containing Forth 
    addresses.
    
    Debugger
    
    JForth provides a source level debugger that allows you to 
    single step through your code.  At every step you can see 
    what is on the stack.  You can also examine the return 
    stack, dump memory, set breakpoints, control execution, or 
    even enter Forth commands.
    
    Floating Point  (*)
    
    JForth supports both the single precision Fast Floating 
    Point and the IEEE double precision.  These words conform to 
    the Forth Vendors Group Standard.
    
    IFF Support  
    
    JForth provides general purpose tools for reading and 
    writing IFF files.  It also provides a toolbox specifically 
    for ILBM graphics files.  This allows you to use pictures, 
    brushes, anims and animbrushes from a paint program, or 
    other source, in your programs.  JForth also provides tools 
    for animation and presentation such as, blit, wipe, fade in, 
    fade out, etc.  Powerful graphics and animation programs can 
    be created using these tools.
    
    Local Variables  
    
    Local variables can simplify the definition of complex words 
    by eliminating much of the stack manipulation.  Local 
    variables are fast self fetching variables that allow 
    reentrant recursive code to be written.  Using regular 
    VARIABLEs can make a word non reentrant.
    
    Modules  (*)
    
    JForth's precompiled modules provide a method for rapidly 
    accessing code that is used during compilation.  This 
    includes the Assemblers and Disassembler, and the Amiga 
    include files.  These modules are dynamically linked into 
    the dictionary when needed.  This way, they do not take up 
    space in your normal dictionary, yet are instantly 
    available.
    
    MultiStandard  (*)
    
    This system allows you to switch easily between JForth and 
    the major standards - FIG , '79 , and '83.  This is handy 
    for compiling code written using other Forths.
    
    ODE  (*)
    
    ODE is an Object Oriented Development Environment similar in 
    concept to SmallTalk.  It allows you to define classes of 
    intelligent data structures, then create as many copies of 
    these data structures as needed.  This technique can 
    simplify programming immensely by making it easier to write 
    reusable code.
    
    Profiler  (*)
    
    This optimization tool monitors the operation of a program 
    to find out where it is spending its time.  Most programs 
    spend most of their time in a small portion of the code By 
    identifying this code, one can focus efforts at optimization 
    where they are most needed.
    
    Textra
    
    Textra is a powerful, yet easy to use, multi-window text 
    editor designed for programmers.  It uses the mouse to 
    select text and allows Cut, Copy and Paste, operations 
    between its windows.  It also incorporates ARexx hooks that 
    allows you to use provided macros (.textra files) for text 
    processing (or write your own).  Textra can communicate with 
    JForth such that you can compile directly from the editor.  
    If an error is encountered while compiling, Textra will 
    highlight the error so the you can fix it quickly.  The 
    documentation for Textra may be found in the JTX:DOCS 
    directory.
    
    To access the '.textra' REXX scripts, they must reside 
    in your 'rexx:' directory.  An ICONX-type script is 
    provided to put them there with the click of a mouse.
    (They will use about 25K of disk space).
    	
    
               JFORTH COMPARED TO OTHER FORTHS
    
    This section describes some of the ways in which JForth 
    differs from other Forths.
    
    32 Bit Stack
    
    Forth uses what is called a "data stack" for passing values 
    between words. It is a place to put numbers, addresses or 
    other values.  Values can be added to the stack and removed 
    just like on a stack of plates.  Most Forth implementations 
    use a 16 bit stack.  This means that the numeric range in a 
    standard Forth is -32,768 to 32,767.  JForth and a few other 
    Forths, use a 32 bit stack which gives you a numeric range 
    of -2,147,483,648 to 2,147,483,647.  Since JForth addresses 
    are also 32 bit, you can address a much larger memory space 
    than a 16 bit Forth.
    
    Jump Subroutine Threading
    
    Another major difference between JForth and most other 
    Forths is that JForth is a true compiler.  In most 
    Forths,when you "compile" a word, you actually end up 
    creating a table of tokens or pointers to the other words 
    that are called.  If your word calls '+' it will put a 
    pointer to the plus function in your word.  When you execute 
    your word, a program called the inner interpreter examines 
    these pointers and then executes the appropriate functions 
    That is the traditional method.
    
    In JForth we use what is called Jump Subroutine, or JSR, 
    Threading.  That is where the 'J' in JForth comes from.  In 
    JSR threading, actual 68000 machine code is compiled into 
    your word.  If you call a word, JForth will compile a 68000 
    JSR instruction to make that call.  This eliminates the need 
    for an inner interpreter.  If the subroutine is small 
    enough, JForth will copy the called routine inline into your 
    routine thus avoiding the small overhead of the JSR 
    instruction.  Since the 68000 executes code directly, JForth 
    will run 2-3 times faster than a traditional Forth on the 
    same machine.
    
    Relative Addressing
    
    In JForth, addresses are expressed as offsets relative to 
    the base of the JForth image in memory.  This is important 
    because AmigaDOS will load JForth at different places in 
    memory at different times.  Despite this, your programs can 
    use the same relative addresses at different times.  This 
    can simplify Forth programming because variables, CFAs, 
    dictionary links, and other addresses keep the same relative 
    addresses even thought their absolute addresses may change.
    
    Amiga Libraries uses absolute addresses.  You will, 
    therefore,  have to convert relative addresses to absolute 
    before passing them to the Amiga.  This is a simple 
    operation.  On the whole, we feel using relative addressing 
    is an advantage over absolute addressing.  Here are the 
    words used to convert addresses:
    
    	>REL  ( absolute-address -- relative-address , convert )  
    	>ABS  ( relative-address -- absolute-address , convert )
    	
    (Also remember that the addresses on the return stack will 
    be absolute as well.)
    
    Text File Input  
    
    JForth will compile programs from "normal" ASCII text files 
    created using standard Amiga text editors.  Thus you can use 
    you favorite editor with JForth instead of the TEXTRA editor 
    provided.  (Traditional Forths use a system of 1024 byte 
    source code blocks. We provide support for this system for 
    those who want it. (*))  
    
    NOT versus 0=  
    
    In the Forth '83 standard, NOT performs a 1's complement 
    operation.  Since NOT is usually used for negating a logical 
    value, this can sometimes give surprising results.  In 
    Forth, any non zero value will be considered true by IF and 
    other conditional words.  The traditional NOT only works 
    with a true value of -1.  For that reason, JForth defines 
    NOT as 0= which negates any true value.  In Forth '83:
    
    	-1 NOT ( is false ) 
    	1 NOT ( is true!!, = -2 ) 
    	1 0=  ( is false ) 
    
    In JForth:
    
    	-1 NOT ( is false ) 
    	1 NOT ( is false ) 
        1 0=  ( is false )
        
    The JForth word COMP will perform a 1's complement operation 
    like the '83 NOT.  If you want the traditional NOT you can 
    redefine it or use the Multistandard package which gives you 
    strict conformance with '83, FIG or '79 standards.
    
    If you have not already done so, please refer to the Tutorial
    while following it in JForth.
