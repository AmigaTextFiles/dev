This is a port of Icon 9.1 using amiga gcc.

Installation

	this port uses the ixemul compatibility library,
	so you need to obtain it. Preferably a recent version.
	(This port tested with ixemul44.0)

	Just install icont and icon.runtime somewhere in your
	path, and assign iconx: to the location of icon.runtime
	(e.g., if icon.runtime is installed as 
	work:languages/bin/icon.runtime, you need
		assign iconx: work:languages/bin/icon.runtime
	)

New features
	Icon 9.1's memory-handling is less unix-specific than was
	Icon 8's. As a result, icon no longer uses fixed-sizes regions:
	everything will grow as needed. You probably need about 2 Megs
	of memory to achieve anything useful with icon.

	This port uses the high level of compatibility of ixemul with
	unix. As a result, all standard features work. Pipes do work.
	m4 preprocessing will work if you install m4 on your amiga.
	Co-expressions work, compiled programs are executable.

	This port does NOT feature any graphic extension, unfortunately.
	It passes all tests succesfully.
	The executable are NOT pure. My peculiar version of gcc might be
	the culprit. You can try to recompile it with -resident and see the
	result, I got bus-errors myself. This would be of great interest
	for icon.runtime, obviously.

Startup code
	This is a very small (600 bytes) binary stub. To find the runtime
	system, it first checks the ICONX variable, then the iconx: assign,
	so you can override the assign locally if need be.
	The runtime is called icon.runtime on the amiga. You won't ever
	need to call it directly if iconx: is assigned correctly, which is
	fine as there already is a system command called iconx on the amiga.

Rexx interface
   This amiga port does feature ONE supplementary function
   rexxcmd(s1, s2)

   if s2 is null, it just checks whether the named port s1 exists or not.
   
	If s2 is not null, it sends the arexx command s2 to the named port s1.
	rexxcmd suspends with the command result. If you resume rexxcmd, it
	returns with the numeric code of the command.

Keyboard functions
   ixemul 44.0 mostly supports termio control, though with some
   problems. Some console handlers don't work that great with ixemul
	(for instance, KingCon), but the original handler works quite correctly.
   getch() and getche() work, kbhit() is half-broken.

Co-expressions
	Work correctly. All the caveats about the stack size being very small
	in coexpressions apply. The default coexpression stack is 4K, which
	is the same as the amiga standard stack size. You might wish to increase
	this if you get unexplained crashes (I haven't).

The icon compiler
   has not been ported. As you should be aware, this is an
   experimental venue from the icon project which is not really
   supported any longer (though you can send bug-fixes).
   As it does NOT support separate compilation, it is of little
   interest on the amiga, anyway, as it needs tremendous amounts
   of memory and of cpu... last time I used it on a sparc station,
   I ended up with an intermediate C-source of 90,000 lines, and
   took over 30 Megabytes of memory to compile. The end executable
   was slightly faster than the original icon program, but it was
   over 1,500,000 megabytes in size, even though my rttlib is a
   shared library.

Implementation details
   implementation is called AMIGA_GCC.
   As gcc works almost like Unix, the system dependent
   code is almost always the Unix code.
   
   NOTE that there are LOTS of places where system-dependent
   code was not flagged, the port fixes that.
   
   This release fixes lots of prototypes minor mishaps as well.

   It should compile like a charm with gcc 2.7.0 or later.
   
Startup code.
   We use the specific properties of amiga overlays (namely,
   the loader does not check the remaining of the file) to
   have magic startable code. As gcc can not build overlays,
   this specific part is built with SAS/C, and linked with
   blink, due to a bug in slink.
   It uses a minimal startup code in order to achieve a very small size.
   See src/runtime/amigahdr.c for details.

Rebuilding icon
   There should be no major problem, provided you do have gcc
   correctly installed, and enough memory. 4 Megs is a bit too
   tight, 8 Megs should work like a charm.
   Some people say that gcc works with vmm. Myself,
   I haven't had any chance.

	You need the original icon 9.1 source code. Unpack it, apply the
	patch in this archive (you need a port of unix patch for that),
	and modify the few files which are not compatible with the 
	unix files.

   As far as include files are concerned, you might need some
   very minor changes, like finding a sys/termio.h (sys/termios.h
   is a good candidate).

   In case this matters, I've built icon using gcc 2.7.0, the 3.1
   os-includes, and ixemul 44.0... Weird combination, but I don't
   have access to my amiga that often, so a more recent gcc I did
   not have.

   As far as stack is concerned, unix cp is the likely offender.
   Everything should compile with 100K stack.

   The makefile does need some specific unix commands (well, not
   really...) Personnally, I've aliased strip and ed to echo:
   innocuous, and works correctly.

   It should not be too difficult to port the icon compiler and
   the variant translator as well. I have not tried running the
   icon grammar through bison, though.

   If you want to recompile the startup code, you do need a
   working sas/c system as well, as gcc does not support amiga
   overlays (yet). Otherwise, use the amigahdr.hdr binary file
	supplied in this archive.

	The coexpression code is somewhat of a hack, as it just modifies
	the a7 register WITHOUT using the StackSwap system call. There
	does not seem to be any problem with stack checking code as well.
	A proper coexpression switch would need more context and would 
	stuff some information into the task user-data. Looking closely
	at gcc stack-extension code, it should be possible to get automatic
	stack extension for coexpressions !

   The runtime amiga code WON'T compile correctly without -O, as
   the amiga functions must be inlined... In case you do need to
   compile without -O, you'll have to muck with the library opening
   code and lauto to make it work.

	I need roughly one hour to build everything on my A3000.
   
