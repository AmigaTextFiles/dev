// Ah, `complete graphs'.
// Fun to draw in real life when bored.
// First written March 16 2011, 21:38

// The first argument is the number of nodes
// of the regular polygon used to make the
// graph. Second argument in radius in
// pixels.
#maparg NODE_COUNT 1
#maparg RADIUS 2

// Node coordinates storage
array node_x(100);
array node_y(100);
node_id = 0;

// Arbitrarily defined constants
center_x = 640 / 2;
center_y = 480 / 2;
radius = RADIUS;

// Compute the nodes' cartesian
// coordinates
deg = 0.0;
node = 0;
while(node++<= NODE_COUNT)
{
    // degrees -> radians
    rad = (deg/360.0) * 2 * 3.141;

    // store cartesian-converted coordinates
    node_x[node_id] = center_x + (radius * cos(rad));
    node_y[node_id] = center_y + (radius * sin(rad));

    // "iterate"
    node_id++;
    deg += (360.0 / NODE_COUNT);
}


// Draw a white backround
@DrawRect (0) (0) (640) (480) (255) (255) (255);

// Draw the nodes !
node_id = 0;
while(node_id++<NODE_COUNT)
{
    @DrawRect node_x[node_id] node_y[node_id] (2) (2) (0) (0) (0);
}

// Swap screen-buffers
@FlipVideo;

// From each node draw a line to every other node
node_id = 0;
while(node_id++<NODE_COUNT)
{
    sub_node_id = 0;
    while(sub_node_id++<NODE_COUNT)
    {
        if(sub_node_id != node_id)
        {
            // "manually" draw a line,
            // SDLClown doesn't currently
            // offer a line drawing routine
            // (yes, this is slow)
            x = node_x[node_id];
            y = node_y[node_id];
            x2 = node_x[sub_node_id];
            y2 = node_y[sub_node_id];
            my = (y2 - y) / 1000.0;
            mx = (x2 - x) / 1000.0;

            c = 0;
            while(c++<1000)
            {
                @DrawRect x y (1) (1) (0) (0) (0);
                x += mx;
                y += my;
            }

            // Swap screen-buffers - show progress :)
            @FlipVideo;
        }
    }
}

print("dear user: your complete graph is complete");


// SDL_Clown manages quit-events
while(1)
{
}
