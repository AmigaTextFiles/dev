\documentstyle[a4,fleqn]{article}
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}
\makeatletter
\def\@dottedtocline#1#2#3#4#5{\ifnum #1>\c@tocdepth \else
  \vskip \z@ plus .2pt
  {\leftskip #2\relax \rightskip \@tocrmarg \parfillskip -\rightskip
    \parindent #2\relax\@afterindenttrue
   \interlinepenalty\@M
   \leavevmode 
   \@tempdima #3\relax \advance\leftskip \@tempdima \hbox{}\hskip -\leftskip
    \mbox{#4}\nobreak%
    \mbox{{\sl ~~~#5}}
    \hfill{ }
   \par
}\fi}

  \def\l@section#1#2{\pagebreak[3]
   \vskip 1.0em plus 1pt \@tempdima 1.5em \begingroup
   \parindent \z@ \leftskip\@tempdima \rightskip \@pnumwidth
   \hspace{6mm}
   \bf \leavevmode \hbox{}\hskip-\@tempdima\relax #1 %\hfil
   {\sl ~~~#2}\hfil
   \endgroup}
\makeatother

\begin{document}

\newcommand{\T}[1]{\fbox{\rule[-0.5ex]{0ex}{2ex}\tt #1}}
\newcommand{\I}[1]{\mbox{{\it #1}}}
\newcommand{\C}[1]{\mbox{{\sc #1}}}

\thispagestyle{empty}
\vspace*{15mm}
\begin{center}
{\Huge\bf GOFER}
\vspace{5mm}

{\Large\bf Gofer 2.30a release notes}
\vspace{5cm}

{\Large Mark P.~Jones}
\vspace{10mm}

{\Large June 1994}
\vspace{3cm}

\end{center}
\setcounter{page}{0}
\newpage
\tableofcontents

\setlength{\parindent}{0pt}
\setlength{\parskip}{3pt}
\newpage
This document is intended to be used as a supplement to the original
user manual ``An introduction to Gofer version 2.20'' and release
notes for Gofer 2.21 and Gofer 2.28.  These notes replace the
preliminary version distributed with Gofer 2.30.

This \LaTeX\ version of the release notes was prepared
by Torsten Poulin, \verb"torsten@diku.dk".

\subsubsection*{Acknowledgments}
A lot of people have contributed to the development of Gofer 2.30a
with their support, encouragement, suggestions, comments and bug
reports.  There are a lot of people to thank:

       Jim Blandy,        Jonathan Bowen,           Rodney Brown,
      Nick Chapman,          Derek Charleston,      Stuart Clayman,
     Terry Dineen,             Luc Duponcheel,        Dirk Dussart,
 Sebastian Egner,          Stephen Eldridge,        Jeroen Fokker,
      Jeff Fried,             Andy Gill,           Michial Gunter,
     Kevin Hammond,         Daniel Harris,          Barney Hilken,
     Steve Hill,               Ian Holyer,         Richard Jones,
   Fumiaki Kamiya,             Eak Khoon,         Hiroyuki Matsuda,
      Sava Mintchev,        Torben Mogensen,          Dirk Nehring,
      Chin Wei Ngan,          Kurt Olender,          Palle Nielsen,
       Ian Poole,          Bambang Prastowo,          Jaan Priisalu,
  Giuliano Procida,          Jerry Prothero,       Laurenz Pruessner,
    Niklas R\"ojemo,    Kristoffer Rose,          Bernhard Rumpe,
     David Rushall,        Carsten Schultz,          Viren Shah,
      Dave Sherratt,           Guy Steele Jr.,      Donald Smith,
   Matthew Smith,          Michael Stout,          Bernard Sufrin,
     Peter Thiemann,       Stephen Thomas,            Bert Thompson,
   Ignacio Trejos-Zelaya,   G\"oran Uddeborg,         Robin Watts,
     Gavin Wraith,           David Wright,            Isii Yuuitirou.

This also includes the names of people who sent comments and bug
reports after the release of version 2.28 and who may not have been
credited in previous release notes.  The list probably isn't complete,
and I apologize if I have inadvertently left your name out.

Enjoy! \\
Mark\footnote{\verb"jones-mark@cs.yale.edu" (until mid-July 1994),
\verb"mpj@cs.nott.ac.uk" (from September/October 1994).}
\newpage

\section{Minor enhancements and bugfixes}

The following sections list the minor enhancements and bugfixes that
have been made to Gofer since the release of version 2.28.  More
significant changes are described in Section 2.


\subsection{Enhancements}

\begin{itemize}
\item A new command, \verb":gc", has been added, making it possible
to force the interpreter to carry out a garbage collection.

\item The infamous `too many variables in type checker' message that has
caused problems with some programs, particularly machine generated
Gofer scripts like the parsers produced by Ratatosk, should now be a
thing of the past.  The message may still appear when running such
programs on smaller machines where the amount of free memory available
for such things is very limited.

\item It is now possible to compile Gofer without support for old
style \verb"Dialogue" based I/O and, independently, without support
for $(n+k)$ and $(c*n)$ patterns.  You may take this as a
hint that these features may not be supported in future versions,
although no firm decisions have been made just yet.

\item As a convenience, the parser allows constructor expressions of
the form \verb"(t ->)" as an abbreviation for \verb"((->) t)".

\item Tuple patterns (with irrefutable components) are now treated as
irrefutable patterns, but without changing the previous lifted
semantics.  This is marginallly more efficient.  It also means
that it is no longer necessary to use \verb"~" for generators of the form
\verb"(x,y) <- expr" in monad comprehensions, too avoid restricting the
enclosing comprehension to monads with a zero.

\item Type expressions appearing in primitive declarations may now
include synonyms, classes etc.\ defined in the same script.

\item Other minor tweaks and improvements.
\end{itemize}


\subsection{Bug fixes}

Nobody really likes to dwell on bugs, especially when they have been
eliminated.  But for those of you who want to know, here is a summary of
the bugs discovered and fixed in Gofer 2.30:
\begin{itemize}

\item  Test programs \verb"apr*.gs" that were included in previous distributions
     are no longer included in the src directory.  These programs were
     intended only for quick tests, not for public distribution.  The
     fact that some of the test programs (intentionally) caused errors,
     was a source of unnecessary concern for some since the expected
     behaviour was not documented.

\item  Some minor fixes to the parser/grammar to give better error
     messages.

\item  Fixed problems with the \verb":edit" command on some machines,
     particularly noticable on the RISCOS version.

\item  Large integer constants that are outside the range for \verb"Int"
     values are no longer implicitly coerced to type \verb"Float".

\item  The implementations of assignment in the \verb"LAMBDAVAR" and
     \verb"LAMBDANU"
     extensions, and the implementation of the system primitive for
     \verb"LAMBDANU" contained subtle bugs that have now been fixed.  Note however
     that these extensions are now regarded as obsolete, and will probably
     not be supported in future versions.  (\verb"LAMBDAVAR" and
     \verb"LAMBDANU" where
     never formally included as an official feature of Gofer anyway.)

\item  Infix data constructors can now be used in a datatype definition
     such as:
\begin{verbatim}
         data  Tree a  =   Empty  |  Tree a `Fork` Tree a
\end{verbatim}

\item  A very subtle bug in the unification algorithm has been fixed.

\item  Some bugs in mildly complicated examples involving pattern
     matching of integer constants and singleton lists have been
     fixed.

\item  Fixed some small problems with a couple of the demonstration
     programs.

\item  Modified prelude definitions of the index function (in class \verb"Ix")
     to include a bounds check.

\item  Other minor bug fixes and tweaks.

\end{itemize}

Someone is bound to find a new one within hours of the release of 2.30,
if past experience is anything to go by.  If that someone is you,
please let me know!



\section{Language differences}

This section outlines a number of more substantial extensions that are
supported in Gofer 2.30.  One of the most important motivations for
some of these extensions, and part of an ongoing process, is to provide
greater compatibility with standard Haskell.


\subsection{Contexts in datatype definitions}

For greater compatibility with Haskell, it is now possible to include
contexts in datatype definitions.  These are treated in exactly the
same way as in Haskell.  For example, the only effect of using a
context in the datatype definition:
\begin{verbatim}
    data Eq a => Set a = NilSet | ConsSet a (Set a)
\end{verbatim}
is to treat the ConsSet constructor function as having type:
\begin{verbatim}
    ConsSet :: Eq a => a -> Set a -> Set a
\end{verbatim}

See Section 4.2.1 of the Haskell report, version 1.2, for further
details.


\subsection{Contexts in member function types}

For greater compatibility with Haskell, it is now possible to include
contexts in the type of member function definitions in a class
specification.  For example, you can now try out the class definition
for pseudo monads given in the Yale Research Report YALEU/DCS/RR-1004
entitled `Composing Monads' by myself and Luc Duponcheel:
\begin{verbatim}
    class Premonad m => Pseudomonad m where
      pbind :: Monad m => p a -> (a -> m (p b)) -> m (p b)
\end{verbatim}

Unlike Haskell, Gofer does not make the restriction that the additional
constraints on the types of the member functions should not mention any
of the types in the first line of the class declaration.  This appears
to have been a consequence of the formal system underlying the original
theoretical work on type classes by Blott.  For the qualified type
system that is used as a basis for Gofer, such restrictions are
unnecessary, although one might argue that they should be retained on
stylistic grounds\dots{}

See Section 4.3.1 of the Haskell report, version 1.2, for further
details.


\subsection{Haskell arrays}

For closer compatibility with Haskell, Gofer now supports a built-in
implementation of Haskell style arrays.  To include support for these
arrays, Gofer must be compiled with the \verb"HASKELL_ARRAYS" flag set to 1.
This is the default for all but the very smallest PC version of Gofer.

The implementation includes is based on new primitive datatype:
\begin{verbatim}
    data Array a b
\end{verbatim}


The array primitives are not currently incorporated into any of the
preludes supplied with Gofer.  However a separate script file,
\verb"array.gs", is included in the same directory with the following
interface:
\begin{verbatim}
    data Assoc a b =  a := b  deriving (Eq, Ord, Text)

    array      :: Ix a => (a,a) -> [Assoc a b] -> Array a b
    listArray  :: Ix a => (a,a) -> [b] -> Array a b
    (!)        :: Ix a => Array a b -> a -> b
    bounds     :: Ix a => Array a b -> (a,a)
    indices    :: Ix a => Array a b -> [a]
    elems      :: Ix a => Array a b -> [b]
    assocs     :: Ix a => Array a b -> [Assoc a b]
    accumArray :: Ix a => (b -> c -> b) -> b -> (a,a)
                            -> [Assoc a c] -> Array a b
    (//)       :: Ix a => Array a b -> [Assoc a b] -> Array a b
    accum      :: Ix a => (b -> c -> b) -> Array a b
                            -> [Assoc a c] -> Array a b
    amap       :: Ix a => (b -> c) -> Array a b -> Array a c
    ixmap      :: (Ix a, Ix b) => (a,a) -> (a -> b)
                                    -> Array b c -> Array a c

    instance (Ix a, Eq [Assoc a b]) => Eq (Array a b)
    instance (Ix a, Ord [Assoc a b]) => Ord (Array a b)
    instance (Ix a, Text (a,a), Text [Assoc a b])
               => Text (Array a b)

    instance (Ix a, Ix b) => Ix (a,b)
    rangeSize :: (Ix a) => (a,a) -> Int
\end{verbatim}
For example, to use these primitives in a Gofer session, just include
\verb"array.gs" as the first file that you load, or as the one of the first
file names in a project file.

Arrays, and the primitives above are supported in both the interpreter
and the compiler.  Because of restrictions in memory management, the
current implementation does not provide true O(1) lookup/indexing in
the interpreter or the compiler using the markscan garbage collector.
True O(1) access is supported when the twospace collector is used for
compiled programs.

See Section 6.9 of the Haskell report, version 1.2, for further details
about the use of arrays and the primitives described above.  Please
bear in mind that the current implementation is still preliminary, and
may contain bugs.  Please let me know if you encounter any problems
with it!  A few short demo programs are included in \verb"demos/arrayEx.gs".


\subsection{Monadic I/O}

A preliminary implementation of the monadic I/O is supported, built on
top of the framework for lazy functional state threads that has been
proposed by John Launchbury and Simon Peyton Jones (PLDI '94).  The
details of monadic I/O can be expected to change in future releases as
a new standard for monadic I/O is established.  For the time being, the
primitives described here will be of most interest to those looking to
experiment with simple monadic I/O and the Launchbury/Peyton Jones
system.  To include support for monadic I/O, Gofer must be compiled
with the \verb"IO_MONAD" flag set to 1.  This is the default for all but the
very smallest PC version of Gofer.

The current implementation provides several new primitive types:
\begin{verbatim}
    data ST s a        -- lazy state threads monad
    data World         -- representation of `the world'
    type IO = ST World -- the I/O monad proper
    data MutVar s a    -- a mutable variable
\end{verbatim}
An interface to monadic I/O can be obtained by loading the file
\verb"iomonad.gs" which may be found in the same directory as the prelude
files.  This provides the following operations:
\begin{verbatim}
    returnST     :: a -> ST s a
    thenST       :: ST s a -> (a -> ST s b) -> ST s b
    thenST_      :: ST s () -> ST s b -> ST s b
    seqST        :: [ST s ()] -> ST s ()

    newVar       :: a -> ST s (MutVar s a)
    readVar      :: MutVar s a -> ST s a
    writeVar     :: MutVar s a -> a -> ST s ()
    mutvarEq     :: MutVar s a -> MutVar s a -> Bool

    instance Eq (MutVar s a)

    getch        :: IO Char
    getchar      :: IO Char
    putchar      :: Char -> IO ()
    putString    :: String -> IO ()
    thenIO       :: ST s a -> (a -> ST s b) -> ST s b
    interleaveST :: ST s a -> ST s a
\end{verbatim}
The \verb"thenIO" function is a stricter version of \verb"thenST" that is suitable
only for computations in the IO monad.  See the Launchbury and
Peyton Jones paper referenced below for further details.

There is also a built-in special form, \verb"runST expr", which is typed
using the rule:
\begin{quote}
\begin{tabular}{cr}
\verb"expr :: forall s. ST s a" & (\verb"s" not appearing in \verb"a") \\
\cline{1-1}
\verb"runST expr :: a" & \\
\end{tabular}
\end{quote}
This special form is used for encapsulating state based computations
within a purely functional program.  See references below for more
details.

If the version of Gofer being used also includes support for arrays, as
described above, you can also use the definitions in \verb"ioarray.gs" to
support monadic array operations:
\begin{verbatim}
    newArr    :: Ix a => (a,a) -> b -> ST s (MutArr s a b)
    readArr   :: Ix a => MutArr s a b -> a -> ST s b
    writeArr  :: Ix a => MutArr s a b -> a -> b -> ST s ()
    freezeArr :: Ix a => MutArr s a b -> ST s (Array a b)
\end{verbatim}
Some sample programs using the functions described here may be found in
the \verb"demos/IO" directory.  For further details about monadic I/O, please
consult the papers:
\begin{quote}
    {\sl Imperative Functional Programming}, S.L. Peyton Jones and
    P. Wadler, POPL '93.
\end{quote}
\begin{quote}
    {\sl Lazy Functional State Threads}, J. Launchbury and S.L. Peyton
    Jones, PLDI '94.
\end{quote}
See also:
\begin{quote}
    {\sl Lazy depth-first search and linear graph algorithms in
    Haskell}, D. King and J. Launchbury, 1993.
\end{quote}
For some very nice applications of lazy functional state threads.
All of these papers are currently available by anonymous ftp from
the University of Glasgow, \verb"ftp.dcs.glasgow.ac.uk".

Monadic I/O as described above is supported in both the Gofer
interpreter and compiler.  No special optimizations are used in
the current implementation which should still be treated as
preliminary, and may contain bugs.  Please let me know if you
encounter any problems with it!


\subsection{Trace primitive}

A simple trace function, inspired by the original implementation in
LML, can now be accessed by including the primitive definition:
\begin{verbatim}
    primitive trace "primTrace" :: String -> a -> a
\end{verbatim}
in a Gofer script.  When called, \verb"trace" prints the string in its first
argument, then returns the second argument as its result.  The \verb"trace"
function is not referentially transparent, and should only be used for
debugging, or monitoring execution.  That is why it is not included in
any of the preludes.  Be warned also that, unless you understand
something about the way that Gofer programs are actually executed,
results obtained using \verb"trace" may be rather confusing.

Because of it's intended use, the \verb"trace" primitive is not supported
by the Gofer compiler, \verb"gofc".  It is however possible to `hack' in
a version of trace for \verb"gofc" using the external function call
mechanism described below with the following C program:
\begin{verbatim}
    #include <stdio.h>
    #include "/usr/local/lib/Gofer/gofc.h"
   
    #define emptyList mkCfun(0)
   
    extern Cell primTrace(str,val)
    Cell str, val; {
        eval(str);
        while (whnf!=emptyList) {
            eval(pop());
            putchar(charOf(whnf));
            eval(pop());
        }
        fflush(stdout);
        return val;
    }
\end{verbatim}
See Section 2.7 below for further details.


\subsection{Constructor synonyms}

Type synonym definitions have been generalized to allow arbitrary
constructor synonyms such as:
\begin{verbatim}
    type List     = []
    type Function = (->)
    type Infer    = StateM Int Error
\end{verbatim}
Previously, it was assumed that both the constructors on the left and
right hand sides were types, i.e.\ constructors of \verb"kind *".  This
restriction has now been lifted, although both sides are still required
to have the same kind.  However, the restriction that all arguments to
a synonym must be given is still imposed.


\subsection{External function calls}

The \verb"gofc" compiler, translating Gofer programs to C provides a simple
external function calling mechanism.

External functions are specified using a primitive declaration of the
form:
\begin{verbatim}
    primitive foo "bar" :: a1 -> a2 -> a3 -> ... -> an -> r
\end{verbatim}
where \verb"foo" is the Gofer name for the function, \verb"bar" is the
name of the corresponding C function (which must not be a string
referring to one of the built in primitives \dots\ if you avoid the
`\verb"prim'" prefix, this should not be a problem), the \verb"ai" are
the argument types, and \verb"r" is the result type.  Arguments of
type \verb"Int", \verb"Bool", \verb"Char" and \verb"Float" are
evaluated before the \verb"bar" function is invoked, and their results passed
to \verb"bar" in parameters of suitable types.  All other values are passed
as unevaluated \verb"Cell" values.  (Special treatment is also provided for
arrays, mutable variables, and mutable arrays for versions of Gofer
that support these facilities.)

Results of type \verb"Int", \verb"Bool", \verb"Char" and \verb"Float"
returned from an external function are automatically converted to
suitable representations for Gofer.  Values of any other type should
be passed back as \verb"Cell" values by the C code for the external function.

A result type of the form \verb"IO r" should be used for external functions
that may have some side effects.  A result type of the form \verb"IO ()" can
be used to call a function that does not return any useful value and is
executed only for its effect.

Here is a simple example using the external function mechanism.  It
involves the following short Gofer and C programs:
\begin{verbatim}
(gix1.gs):    primitive howdy "sayHello" :: Int -> IO ()

              main = howdy (length (filter even [1..5]))

(cix1.c):     #include <stdio.h>
              #include "gofc.h"

              Void sayHello(i)
              Int i; {
                  while (i-- > 0)
                      printf("hello, world\n");
              }
\end{verbatim}
First, we compile \verb"gix1.gs" to get a C program \verb"gix1.c":
\begin{verbatim}
    machine% gofc gix1.gs
    Gofer->C Version 1.02 (2.30) ...

    Reading script file "/usr/local/lib/Gofer/standard.prelude":
    Reading script file "gix1.gs":
                   
    Writing C output file "gix1.c":
    [Leaving Gofer->C]
\end{verbatim}
Now we compile the C programs, and link them into a single executable
file, \verb"ix1":
\begin{verbatim}
    machine% cc -O -o ix1 gix1.c cix1.c runtime.o
\end{verbatim}

Finally, we get to run the program:
\begin{verbatim}
    machine% ix1
    hello, world
    hello, world
\end{verbatim}
See Section 2.5 above for another example using the external function
mechanism, and also illustrating how values of type \verb"String" can be
evaluated and used in a C function.  You will probably need to refer
to the report described in Section 3 below if you plan to do anything
very ambitious with external function calls.

Note that the external function call mechanism described here cannot be
used in the Gofer interpreter.  The external function call mechanism is
a prototype only.  It should also be emphasized that we do not, in
general, regard the Gofc compiler as suitable for serious applications
development.  If you want to do something along those lines, try one of
the full Haskell systems available (e.g.\ the Lisp or C interfaces for
Yale Haskell, or the C interface for Glasgow Haskell).


\subsection{The {\tt do} notation}

Gofer 2.30 supports a new, experimental syntax for monad
comprehensions which we will refer to as `\verb"do {...} notation"'.
To maintain compatibility with previous releases of Gofer, the
\verb"do" notation is only supported if the system is compiled with
the \verb"DO_COMPS" flag in \verb"prelude.h" set to 1, and the
\verb"DO_COMPS" section of \verb"parser.y" included.  See the comments
in these files and in \verb"src/Readme" for further details.

The \verb"do" notation is useful for monadic programming.  It requires the
\verb"cc.prelude", and provides the following syntax:

\begin{tabular}{p{2cm}cp{6.5cm}l}
\C{expr}   & ::= & \T{do} \T{\char123} \C{dquals} \C{expr}
                          \T{\char125}              &uses layout rule \\
\C{dquals} & ::= & \{ \C{dqual} \T{;} \} \\
\C{dqual}  & ::= & \C{expr} \T{<-} \I{pat}          &generator \\
           & $|$ & \C{expr}                         &command \\
           & $|$ & \T{let} \T{\char123} \I{decls}
                           \T{\char125}             &local definitions \\
           & $|$ & \T{if} \C{expr}                  &guard \\
\end{tabular}

With this notation, a guard is written as if \C{expr}, while a
single expression of the form \C{expr} is treated as a command,
i.e.\ a generator of the form \verb"_ <-"~\C{expr}.  For example, a
general version of the \verb"filter" function can be defined as:
\begin{verbatim}
    myFilter     :: Monad0 m => (a -> Bool) -> m a -> m a
    myFilter p xs = do x <- xs
                       if p x
                       result x
\end{verbatim}
If you prefer, this can be written as follows, using explicit layout:
\begin{verbatim}
    myFilter p xs = do { x <- xs;
                         if p x;
                         result x
                       }
\end{verbatim}
In standard comprehension notation, this would be written:
\begin{verbatim}
    myFilter p xs = [ x | x <- xs, p x ]
\end{verbatim}
Perhaps the most significant difference between these two examples is
the fact that the call to \verb"result" must be written explicitly in the
first case.  In fact, if the comprehension is interpreted in a monad,
\verb"m", then any expression of type \verb"(m a)" can be used as the final
expression in a \verb"do" comprehension.  This is useful for describing `tail
recursive' procedures.  For example, compare:
\begin{verbatim}
    echo' = do c <- getchar
               if c==EOF
                 then result ()
                 else do putchar c
                         echo'
\end{verbatim}
with:
\begin{verbatim}
    echo' = [ () | c  <- getchar,
                   () <- if c==EOF then result ()
                                   else [ () | _ <- putchar c,
                                               () <- echo' ] ]
\end{verbatim}
It is, of course, a matter of personal opinion which of these you
prefer.  The intention of \verb"do" notation is to provide a more attractive
syntax for monadic programming, to be compared with programs using
\verb"`bind`" in which the example above would be written:
\begin{verbatim}
    echo' = getchar `bind` \c ->
            if c==EOF then result ()
                      else putchar c  `bind` \_ ->
                           echo'
\end{verbatim}
See which notation you prefer for practical programming, and let me
know!


\section{The implementation of gofer}

For those interested in the actual implementation of Gofer, there is
a (relatively new) technical report available that describes the
implementation of Gofer 2.30:
\begin{quote}
{\sl The implementation of the Gofer functional programming system},
Mark P. Jones,
Research Report YALEU/DCS/RR-1030,
Yale University, Department of Computer Science,
May 1994.
\end{quote}
Copies of this report are currently available by anonymous ftp from
\verb"nebula.cs.yale.edu" in the directory \verb"pub/yale-fp/reports", together
with a number of other recent reports by members of the Yale Haskell
project.
\end{document}
