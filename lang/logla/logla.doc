  _________  ________   __   __   __  ________  _______  __   __
 /\___  ___\/\______ \ /\ \ /\ \ /\ \/\  _  _ \/\_____ \/\ \ /\ \
 \/__/\ \__/\/______\ \\ \ \\ \ \\ \ \ \ \\_\\ \/_____\ \ \ \\_\ \
     \ \ \    /\  _____\\ \ \\ \ \\ \ \ \ \__/\ \/\  ____\ \  ___ \
      \ \ \   \ \ \____/_\ \ \\ \ \\_\ \ \ \ \ \ \ \ \___/\ \ \_/\ \
       \ \_\   \ \_\  /\_\\ \_\\ \______\ \_\ \ \_\ \_\    \ \_\\ \_\
        \/_/    \/_/  \/_/ \/_/ \/______/\/_/  \/_/\/_/     \/_/ \/_/


                       ------------------------
                       Logla-1 - 7 January 1996
                       ------------------------


======================================================================
   CONTENTS
======================================================================

1. INTRODUCTION

   1.1 What is it? Why?
   1.2 Disclaimer -legal information - distribution
   1.3 Development info
   1.4 Credits
   1.5 How to contact the author
   1.6 Revision history
   1.7 Equipment needed to run Logla


2. DOCUMENTATION

   2.1 The compiler interface
   2.2 Concepts


======================================================================
1. INTRODUCTION
======================================================================

1.1 What is it? Why?
--------------------

Logla-1  is  a  compiler  for  the  language  with the same name.  The
language  has  a  very  simple  definition and not very many available
commands.   It's  main  features  are  to  demonstrate  the  power  of
functions within functions and LL(1) parsing of files.

I  did  this mainly as an exercise for myself, and so that I could say
"yes, I have in fact written my own compiler" :-).

The  main  reason  for  using this compiler and the source is probably
that  you  want to learn some compiler theory.  Do not expect it to be
anything  revolutionary  or  new  in any way.  It produces pretty crap
code.


1.2 Disclaimer - Legal information - Distribution
-------------------------------------------------

This  program  and  the source may be freely distributed in any way as
long as no money is charged.

It  may  of  course  be put on CD ROMs like Fresh Fish, AmiNet and the
like.

You  may  use  the  Logla-1  compiler  to generate commercial programs
without  any  special  permission.   Why  you would want to do that is
another question ;).


1.3 Development info
--------------------

Programs used:

     GoldEd reg.   - editor
     SAS/C 6.51    - C++ compiler
     Devpac 3.04   - assembler


1.4 Credits
-----------
I wish to thank the following persons for their help and support:

     Olav Kalgraf - for writing most of the initial version of
                    the interpreter and pseudo-code generator.


1.5 How to contact the author
-----------------------------
I welcome bugreports and comments about this compiler, the source
and the documentation! You can reach me by the following means:

Snail mail: Nils Corneliusen
            Ranviksvingen 7a   (this is not my current address,
            3212  Sandefjord    but it will always be valid :-)
            Norway

Internet:   nilsco@ifi.uio.no

BBS:        INTERFERENCE BBS, Sweden
            +46 525 13136/13091/13092/13094/13095/13098/13137


1.6 Revision history
--------------------

Release 0.2 - 7 January 1996

  - First public prerelease without source.


1.7 Equipment needed to run Logla
---------------------------------

If you intend to just use the executable compiler, you must have:

   an Amiga computer
   OS 2.04 or newer


However,  you  may  of course recompile the source code.  It uses only
standard ANSI and Un*x calls, so this should not be a problem.

If  there  is  any point in doing this, is another question.  Remember
that only Amiga 68k assembler code is generated, and that the produced
code should be compiled with Devpac for Amiga.

If  you  have another 68k based machine, you should be able to port it
without any big problems.


======================================================================
2. DOCUMENTATION
======================================================================

2.1 The compiler interface
--------------------------

The compiler is invoked with the following template:

  > logla [options] <source file>

It is a good idea to call the source files <basename>.logla.
You are not required to do this however.

This means that if you do not specify any arguments, you will get:

     - no debug output
     - an assembler source file called <basename>.s
     - an executable generated by the system call "genam <basename>.s"

In other words, it is assumed that you have the genam (DevPac) assembler.
If you don't, check the options below.

Smart sets of options are:

  > logla -rc <source>

  This will just generate pseudo-code and run it.
  This is wise if you just want a quick test of your code.

  > logla -sc <source>

  This will just generate pseudo-code and run it in the debugger.
  This is wise for more in-depth debugging.
  You should read the other sections of the documentation before
  doing this.

Examples:

  > logla -rc fakultet.logla
  > logla "-ggenam -oram:test %s" hanoi.logla


The assorted options are:

-p (Debug: Parser dump)
-----------------
Show every procedure entered during parsing.

-m (Debug: Pseudo code dump)
----------------------------
Dump pseudo-code after parsing.

-s (Debug: Single step)
-----------------------
Single step pseudo-code.
This sets option "-r" automatically.

-r (Debug: Run)
---------------
Run generated pseudo-code.

-c (no68k)
----------
Do not generate 68k assembler code.

-n (nocompile)
--------------
Do not compile generated 68k assembler code.
Ignored if option "-c" is specified.

-g (assembler)
--------------
Specifies the command to run to compile 68k code.
%s in the string means that the source name should
be inserted.
Default is "genam %s".
Ignored if option "-c" or "-s" is specified.
Example: "-ggenam -oram:test %s"


2.2 The source
--------------

...


2.3 The language
----------------

Datatypes:

   VAR - signed int

...
