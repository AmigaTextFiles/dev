@database Iaio_DOC POLISH
@author "Benji_haOma/nA!"
@index Main

@node Main "Iaio doc!"





       (nie)Peîna dokumentacja do programu "Iaio - The PackMaker" v0.7ß
                                                  Benji_HaOma/nEGATIVE!

                             @{"    CO TO JEST?    " link coto}
                             @{"    OPIS KOMEND    " link spis}
                             @{"    REJESTRACJA    " link rejestracja}
                             @{"    AUTOR          " link autor}

                             @{"    IAIO PRODS     " link iaioprods}

@endnode

@node iaioprods

                     znane mi produkty napisane w Iaio'u


          pack:  instant #1/appendix

    crazy demo:  pamela/8bits
                 8bs-vzy-murderer/8bits
                 o.s.w./8bits


@endnode

@node coto

   Iaio  - The PackMaker to jak najbardziej multimedialny jëzyk programowania
skryptowego,  z  poîoûonym  naciskiem  na  tworzenie  tzw.   packów scenowych
(patrz:  Instant/Appendix), z tymûe Iaio zostaîo juû uûyte takûe do tworzenia
crazy  dem,  oraz  skryptów do tzw.  bootowania systemu (w stylu Syspi*, oraz
Examples/boot_amiga/).

   Iaio  odznacza sië pracâ z systemem, jednak pozostaje jeszcze wiele rzeczy
do zrobienia.

   Program ma status *SHAREWARE* (patrz @{"REJESTRACJA" link rejestracja}.)

@endnode

@node rejestracja

   Program posiada status *SHAREWARE*, róûnice pomiëdzy wersjâ zarejestrowanâ
i nie sâ ûadne, poza imiennâ rejestracjâ oraz usuniëciem procedury 'jay'.

   Aby jâ otrzymaê naleûy wysîaê na mój adres @{"e-mailowy lub domowy (+znaczek)" link autor}
list   zawierajâcy  3  przykîadowe  skrypty  Iaio'a  wîasnego  autorstwa  lub
jakikolwiek   program   swojego   autorstwa   zarejestrowany  na  uûytkownika
Benji_haOma/Negative!.  UWAGA:  zastrzegam sobie prawo doîâczenia skryptów do
pakietu Iaio, oraz ewentualnych poprawek!

   OSTRZEÛENIE!:    próba   uruchomienia  zcrackowanej  wersji  Iaio'a,  moûe
spowodowaê  reset  komputer'a, oraz ewentualny pad walidacji dysku!  Zostaîeô
ostrzeûony ;)

@endnode

@node autor

              -iaio- by BENji_haOma/
              nEGATIVE!

              Pawel Nowak
              ul.Szpitalna 7/13
              31-024 Krakow
              Poland

              juen@tl.krakow.pl

@endnode

@node spis

@{B}[KOMENDA]@{UB} - nazwa komendy wraz z argumentami
@{B}[UÛYCIE ]@{UB} - przykîadowe uûycie komendy
@{B}[FUNKCJA]@{UB} - opis komendy

                                 Spis komend:

                             @{"#(text)             " link komentarz}
                             @{"-(proc):            " link proc}
                             @{"jump                " link jump}
                             @{"quit                " link quit}
                             @{"debug               " link debug}
                             @{"sumpalblack         " link sumpalblack}
                             @{"lamelmb             " link lamelmb}
                             @{"lamermb             " link lamermb}
                             @{"closescreen         " link closescreen}
                             @{"fadetowhite         " link fadetowhite}
                             @{"fadetoblack         " link fadetoblack}
                             @{"loadpal             " link loadpal}
                             @{"fadetopal           " link fadetopal}
                             @{"copypal             " link copypal}
                             @{"tofront             " link tofront}
                             @{"hidescreen          " link hidescreen}
                             @{"exec                " link exec}
                             @{"checkaudio          " link checkaudio}
                             @{"print               " link print}
                             @{"onloaderror         " link onloaderror}
                             @{"onkey               " link onkey}
                             @{"digiplay            " link digiplay}
                             @{"digistop            " link digistop}
                             @{"digifadedown        " link digifadedown}
                             @{"loadraw             " link loadraw}
                             @{"inc                 " link inc}
                             @{"dec                 " link dec}
                             @{"case                " link case}
                             @{"nocase              " link nocase}
                             @{"loadbank            " link loadbank}
                             @{"countpages          " link countpages}
                             @{"bintoascii          " link bintoascii}
                             @{"textpage            " link textpage}
                             @{"backpage            " link backpage}
                             @{"freegadget          " link freegadget}
                             @{"addgadget           " link addgadget}
                             @{"checkgadget         " link checkgadget}
                             @{"ongadget            " link ongadget}
                      v0.5:  @{"checkfont           " link checkfont}
                      v0.6:  @{"reset               " link reset}
                             @{"freefree            " link freefast}
                             @{"freepublic          " link freepublic}
                             @{"freechip            " link freechip}

                      v0.7:    Uwaga, komendy od wersji 0.7+ majâ poprawionâ
                             skîadnie:

                             np.: delay[100]
                                  =
                                  set[0,100]
                                  delay[!0]    (!nr_komorki)
                                  =
                                  set[0,100] : delay[!0]
                                  =
                                  delay[$64]   ($wartosc_hex)

                               Stara  skîadnia  oczywiôcie  dalej  aktualna.
                               Uwaga:   komendy  dla,  których  sâ  podawane
                             argumenty w postaci =(text) muszâ znajdowaê sië
                             w linii jako ostatnie!

                             @{"&file               " link _file}
                             @{"&digi               " link _digi}
                             @{"iaiochicken         " link iaiochicken}
                             @{"delay               " link delay}
                             @{"add                 " link add}
                             @{"sub                 " link sub}
                             @{"setcol              " link setcol}
                             @{"chled               " link chled}
                             @{"onlmb               " link onlmb}
                             @{"onrmb               " link onrmb}
                             @{"text                " link text}
                             @{"openscreen          " link openscreen}
                             @{"rectfill            " link rectfill}
                             @{"setfont             " link setfont}
                             @{"setpen              " link setpen}
                             @{"set                 " link set}
                             @{"draw                " link draw}
                             @{"move                " link move}
                             @{"writepixel          " link writepixel}
                             @{"readpixel           " link readpixel}
                             @{"getmouse            " link getmouse}
                             @{"return              " link return}
                             @{"flood               " link flood}
                             @{"deletefile          " link deletefile}
                             @{"findcol             " link findcol}
                             @{"div                 " link div}
                             @{"mul                 " link mul}
                             @{"digigetpattpos      " link digigetpattpos}
                             @{"digigetsongpos      " link digigetsongpos}
                             @{"putraw              " link putraw}
                             @{"neg                 " link neg}
                             @{"hipget              " link hipget}
                             @{"hipcloseport        " link hipcloseport}
                             @{"hipopenport         " link hipopenport}
                             @{"do                  " link do}
                             @{"loop                " link loop}
                             @{"freebank            " link freebank}
                             @{"digiplug            " link digiplug}




	Pozostajâ  takûe  funkcje  takie  jak  (których  z wiadomych dla mnie
przyczyn nie opisuje):

clearpointer[]
cmp[]
high[]
low[]
same[]
initrnd
rnd[]
random[]

@endnode

@node iaiochicken

KOMENDA: iaiochicken
UÛYCIE : #sprawdzam audio, czy nie zajete, jezeli nie:
         iaiochicken
         #...
FUNKCJA: iaio mówi :)

@endnode

@node komentarz

KOMENDA: #(komentarz)
UÛYCIE : #tutaj nastëpuje odczyt artykuîów:
         ...
         #tu jest gîówna pëtla...
         ...
FUNKCJA: komentarz ;]
@endnode
@node proc

KOMENDA: -(nazwa_procedury):(enter)
UÛYCIE : -moja_procedura:
UÛYCIE : -inna_procedura:
UÛYCIE : -loop:
         jump[loop]
FUNKCJA: etykieta procedury, która nastëpuje wîaônie w miejscu jej zapisania
@endnode

@node jump

KOMENDA: jump[(procedura)]
UÛYCIE : -loop:
         ...
         jump[loop] ;zapëtlenie
FUNKCJA: skok do podanej procedury
@endnode
@node quit

KOMENDA: quit
UÛYCIE : quit
FUNKCJA: zakoïczenie wykonywania programu
@endnode
@node debug

KOMENDA: debug
UÛYCIE : debug
FUNKCJA: zwrócenie wartoôci rejestrów do okna (expert)

@endnode
@node sumpalblack

KOMENDA: sumpalblack[(ekran)]
UÛYCIE : sumpalblack[0]
FUNKCJA: ustawia czarnâ paletë dla podanego ekranu (od 0 do 9)

@endnode
@node lamelmb

KOMENDA: lamelmb
UÛYCIE : lamelmb
FUNKCJA: zawieszenie wykonywania programu do czasu naciôniëcia lewego
         przycisku myszy

@endnode
@node lamermb

KOMENDA: lamermb
UÛYCIE : lamermb
FUNKCJA: zawieszenie wykonywania programu do czasu naciôniëcia prawego
         przycisku myszy

@endnode
@node closescreen

KOMENDA: closescreen[(ekran)]
UÛYCIE : closescreen[0]
FUNKCJA: zamknij ekran (wczeôniej otwart przez openscreen), gdzie ekran
         to numer od 0 do 9 (max 10 ekranów na raz)

@endnode
@node fadetowhite

KOMENDA: fadetowhite[(ekran),(delay)]
         fadetoblack[(ekran),(delay)]
UÛYCIE : fadetoblack[0,1]
FUNKCJA: fejduje palete ekranu (od 0 do 9), przy opóûnieniu podanym jako
         delay, ustawiony na 1 daje nam opóûnieje 1/50s, moûna ustawiê takûe 0

@endnode
@node fadetoblack

KOMENDA: fadetowhite[(ekran),(delay)]
         fadetoblack[(ekran),(delay)]
UÛYCIE : fadetoblack[0,1]
FUNKCJA: fejduje palete ekranu (od 0 do 9), przy opóûnieniu podanym jako
         delay, ustawiony na 1 daje nam opóûnieje 1/50s, moûna ustawiê takûe 0

@endnode
@node loadpal

KOMENDA: loadpal[(ekran)]=(plik_z_paleta);
UÛYCIE : loadpal[0]=progdir:data/pal/main.pal;
FUNKCJA: komenda odczytuje z pliku podanego na podany ekran (0-9) palete,
         format pliku z paleta to 32-u bitowa paleta, by uzyskaê takowâ
         z pliku ilbm iff, naleûy uûyê doîâczonego programu tools/savecmap,
         podajemy dla niego jako argument nazwe iffu, paleta jest zapisywana
         do ram:cmap.pal

@endnode
@node fadetopal

KOMENDA: fadetopal[(ekran),(delay)]=(plik_z_paleta);
UÛYCIE : loadpal[0,1]=progdir:data/pal/main.pal;
FUNKCJA: zasada dziaîania ta sama co w przypadku fadetoblack i loadpal,
         z tâ ûe róûnicâ iû fejdowana jest paleta do podanej w argumentach

@endnode
@node delay

KOMENDA: delay[(ile*1/50sekundy)]
UÛYCIE : delay[50]
FUNKCJA: odczekuje okreôlony czas, w przypadku podania 50 bëdzie to 1 sek.

@endnode
@node copypal

KOMENDA: copypal[(ekran1),(ekran2)]
UÛYCIE : copypal[0,1]
FUNKCJA: kopiuje palete z ekranu, do ekranu, pamiëtaj ûe max. wartoôê ekranu
         to 9 (od 0)

@endnode
@node tofront

KOMENDA: tofront[(ekran)]
UÛYCIE : tofront[0]
FUNKCJA: wystawienie podanego ekranu do przodu

@endnode
@node hidescreen

KOMENDA: hidescreen[(ekran)]
UÛYCIE : hidescreen[0]
FUNKCJA: schowanie ekranu podanego pod wszystkie inne

@endnode
@node exec

KOMENDA: exec=(program_wykonywalny);
UÛYCIE : exec=c:dir DF0: >CON:0/0/640/256/Zawartoôê DF0:;
UÛYCIE : exec=reset;
FUNKCJA: wykonuje podany program

@endnode
@node checkaudio

KOMENDA: checkaudio[(procedura)]
UÛYCIE : checkaudio[audioerror]
         ...
         -audioerror:
         print=Nie mogë zarezerwowaê kanaîów audio!
         quit
FUNKCJA: testuje kanaîy audio, jeûeli sâ juû zarezerwowane skacze do podanej
         procedury

@endnode
@node print

KOMENDA: print=(text)
UÛYCIE : print=Script by Lolek
FUNKCJA: wypisanie do wyjôcia textu (stdout, np. do cli)

@endnode
@node onloaderror

KOMENDA: onloaderror[(procedura)]
UÛYCIE : onloaderror[load_error]
         ...
         -load_error:
         print=Nie mogë wczytaê danych!
         quit
FUNKCJA: ustala do jakiej procedury program ma przejôê podczas problemów
         z wczytywaniem jakichkolwiek plików

@endnode
@node onkey

KOMENDA: onkey[(key),(proc)]
UÛYCIE : onkey[117,koniec]   ;117=ESC
FUNKCJA: sprawdza kod raw wciôniëtego przycisku, jeûeli zostaî podany
         naciôniëty przechodzi do podanej procedury

@endnode
@node digiplay

KOMENDA: digiplay=(nazwa_modulu_digiboostera);
UÛYCIE : digiplay=progdir:data/music/voyager.digi;
FUNKCJA: wczytuje i zaczyna odtwarzaê podany moduî, który musi byê w formacie
         digiboostera =< 1.7

@endnode
@node digistop

KOMENDA: digistop
UÛYCIE : digistop
FUNKCJA: zatrzymuje odtwarzanie moduîu digiboostera, oraz usuwa go z pamiëci

@endnode
@node digifadedown

KOMENDA: digifadedown[(delay)]
UÛYCIE : digifadedown[1]
FUNKCJA: ôcisza aû do 0 gîoônoôê odtwarzania moduîu digiboostera, delay
         jest to wartoôê co jakâ bëdzie zmniejszana gîoônoôê (1=1/50 sek),
         podajâc tu jeden moduî zostanie caîkowicie wyciszony po:
         64*(1*1/50) sek ;]

@endnode
@node text

KOMENDA: text[(ekran),(x),(y)]=(text)
UÛYCIE : text[0,10,10]=Super! Mój wîasny tekst ;]
FUNKCJA: wypisuje na podanym ekranie, o podanych wspóîrzëdnych podany text :] 

@endnode
@node setpen

KOMENDA: setpen[(ekran),(kolor_tekstu),(kolor_podkladu),(spec)]
UÛYCIE : setpen[0,1,0,0]
FUNKCJA: ustala kolor pisanego textu i jego podkladu dla podanego ekranu,
         podajâc dla _spec_ wartoôê 0, tekst bëdzie pisany na podkîadzie,
         w przypadku 1, podkîad bëdzie koloru _kolor_podkladu_

@endnode
@node openscreen

KOMENDA: openscreen[(ekran)]=(szerokoôê)/(wysokoôê)/(bitplanes)/(typ)/(fonts)
         (+size)/(spec);
UÛYCIE : openscreen[0]=640/256/8/h/thingpl.font/;
UÛYCIE : openscreen[0]=640/256/8/h/topaz.font+11/;
UÛYCIE : openscreen[0]=640/512/1/s//bakg;
FUNKCJA: otwiera (ekran) o szerokoôêi i wysokoôci podanej, o i liczbie
         podanych bitplaneów (1=2 kolory, 2=4 kolory, 3=8 kolorów, 4=16
         kol., 5=32 kol., 6=64 kol., 7=128 kol., 8=256 kolorów), w typ
         podajemy h dla ekranu hires, l dla ekranu lowres, lub s dla
         hires + lace, w fonts podajemy fonty (np. topaz.font), ew. nic
         nie podajemy (jak na przykîadzie), a takûe + i wielkoôê (domyôlnie
         8!), w spec moûna podaê argument bakg, który to otworzy nam ekran
         pod wszystkimi innymi, ew. teû nic nie podajemy.

@endnode
@node loadraw

KOMENDA: loadraw[(ekran),(szer),(wys),(bitplanes),(x),(y)=(plik_raw);
UÛYCIE : loadraw[0,640,256,8,0,0]=progdir:data/gfx/panel640x256x8.raw;
FUNKCJA: wczytuje obrazek w formacie RAW (format ten moûna uzyskaê na
         takich programach jak AgaIFF, czy Personal Paint) o podanej
         szerokoôci, wysokoôci i iloôci bitplaneów, na podany ekran,
         o podanych wspóîrzëdnych

@endnode
@node set

KOMENDA: set[(komorka),(wartoôê)]
UÛYCIE : set[0,10]  ;ustawi komorke 0 na 10
UÛYCIE : set[89,10] ;ustawi komorke 89-wiâtâ na numer 10
FUNKCJA: ustawia podanâ komórke na podanâ wartoôê, maxymalny numer komórki
         to 1000, kaûda komórka moûe przechowywaê maxymalnâ wartoôê 32bity

@endnode
@node inc

KOMENDA: inc[(komorka),(o_ile)]
UÛYCIE : inc[0,10] ;zwiëkszy wartoôê komórki 0 o 10
FUNKCJA: zwiëksza wartoôê podanej komórki o podanâ wartoôê

@endnode
@node dec

KOMENDA: dec[(komorka),(o_ile)]
UÛYCIE : dec[0,10] ;zmniejszy wartoôê komórki 0 o 10
FUNKCJA: zmniejsza wartoôê podanej komórki o podanâ wartoôê

@endnode
@node case

KOMENDA: case[(komorka),(wartosc),(procedura)]
UÛYCIE : case[0,10,proc_kom0_ma_wartosc_10]
         ...
         -proc_kom0_ma_wartosc_10:
         ...
FUNKCJA: sprawdza czy podana komorka ma podana wartosc, jak tak to skacze
         do podanej procedury

@endnode
@node nocase

KOMENDA: nocase[(komorka),(wartosc),(procedura)]
UÛYCIE : case[0,10,proc_kom0_nie_ma_wartosci_10]
         ...
         -proc_kom0_nie_ma_wartosci_10:
         ...
FUNKCJA: sprawdza czy podana komorka nie ma podanej wartosci, jezeli wlasnie
         tak jest to skacze do podanej procedury

@endnode
@node loadbank

KOMENDA: loadbank[(numer_banku),(typ_pamieci)]=(plik);
UÛYCIE : loadbank[0,p]=progdir:data/text/introduction.txt;
FUNKCJA: wczytuje do banku podanego (od 0 do 9), podany plik, typ pamieci
         to p dla public c dla chip, oraz f dla fast, UWAGA: UÛYWAJ p !

@endnode
@node freebank

KOMENDA: freebank[(bank)]
UÛYCIE : freebank[0]
FUNKCJA: usuwa z pamiëci podany bank (0-100)

@endnode
@node countpages

KOMENDA: countpages[(bank),(enters),(komorka)]
UÛYCIE : countpages[0,18,30]
FUNKCJA: w enters podajemy ilosc enterów na strone, jako bank podajemy
         wczytany bank z !PLIKIEM TEXTOWYM! jako komorka podajemy numer
         komorki, w której chcemy otrzymaê wynik, którym jest juû caîkowita
         przeliczona iloôê stron (uûyteczne np. do licznika stron)

@endnode
@node bintoascii

KOMENDA: bintoascii[(ekran),(komorka),(x),(y)]
UÛYCIE : bintoascii[0,30,20,10]
FUNKCJA: zapisuje w postaci tekstu wartosc z podanej komorki na x i y
         podanego ekranu

@endnode
@node textpage

KOMENDA: textpage[(ekran),(komorka1),(bank),(x),(y),(linie),(kom2),(kom3)]
UÛYCIE : textpage[0,100,0,20,20,18,101,102]
FUNKCJA: funkcja wypisuje text, od aktualnego jego polozenia (po wczytaniu
         do banku textu, jestesmy zawsze na jego poczatku),
         (ekran) - na tym ekranie wypiszemy text,
         (komorka1) - tej komorki bedzie program uzywal, nie nalezy jej
         pozniej zmieniac,
         (bank) - numer banku z textem,
         (x),(y) - x i y ekranu no i dla textu,
         (linie) - ilosc linii textu jaka ma zapisac (ta sama wartosc
         podajemy jako argument (enters) dla countpages[]),
         (kom2) - tu podajemy nastepny numer komorki do uzywania dla funkcji,
         tez nie nalezy jej pozniej samemu zmieniac, jednak mozna ja
         sprawdzac: 1=tekst jeszcze nie doszedl do ostatniej strony,
         2=tekst juz doszedl do konca (eof),
         (kom3) - ostatnia juz komorka jaka tu ustawiamy, a nastepnie jej
         juz nie ruszamy, nalezy o tym pamietac, ze raz juz podane numery
         komorek podajemy juz za kazdym razem te same dla funkcji textpage
         jak i zarazem backpage!

@endnode
@node backpage

KOMENDA: backpage[(komorka1),(bank),(kom2),(kom3),(linie)]
UÛYCIE : backpage[100,0,101,102,18]
FUNKCJA: cofa o caîâ strone text w banku (bank), uzywajac podanych trzech
         komorek (bardzo scisle zwiazanych z textpage[]), (linie) to ta
         sama iloôê linii podana w textpage[] takze jako (linie) (zobacz!)

@endnode
@node freegadget

KOMENDA: freegadget[(ekran),(numer_gadgetu)]
UÛYCIE : freegadget[0,1]
FUNKCJA: usuwa gadget z listy gadgetow dla podanego ekranu

@endnode
@node addgadget

KOMENDA: addgadget[(ekran),(numer_gadgetu),(x),(y),(szer),(wys)]
UÛYCIE : addgadget[0,1,20,20,50,10]
FUNKCJA: dodaje gadget do podanego ekranu, o podanym numerze, o wspolrzednych
         x i y, oraz podanej szerokosci i wysokosci

@endnode
@node checkgadget

KOMENDA: checkgadget[(ekran)]
UÛYCIE : checkgadget[0]
FUNKCJA: sprawdza status gadgetow dla podanego ekranu, nastëpnie moûna
         uûyê komendy ongadget

@endnode
@node ongadget

KOMENDA: ongadget[(gadget),(procedura)]
UÛYCIE : ...
         -proc_retry:
         ...
         checkgadget[0]
         ongadget[1,proc_abort]
         ongadget[2,proc_retry]
         ...
         -proc_abort:
         quit
FUNKCJA: sprawdza czy podany numer gadgetu zostal wcisniety, jak tak
         to skacze do podanej procedury, przed uzyciem komendy ongadget[],
         naleûy uûyê komendy checkgadget[], która pobiera stan gadgetów
         dla podanego ekranu!
@endnode
@node checkfont

KOMENDA: checkfont[(nazwa_fontow)]
UÛYCIE : checkfont[thingpl.font]
         ...
FUNKCJA: sprawdza czy mozna otworzyc podane fonty, w wypadku nie udanej
         proby wyswietla do cli blad o otwarciu podanych liter i zakancza
         wykonywanie programu.
@endnode
@node reset

KOMENDA: reset
UÛYCIE : ...
         reset
FUNKCJA: wykonuje najzwyklejszy (soft) reset.
         ( move.l 4.w,a6
           jsr    -726(a6) )
@endnode
@node freefast

KOMENDA: freefast[(komorka)]
UÛYCIE : freefast[20]
         text[0,50,42]=Ilosc wolnej pamieci fast:
         bintoascii[0,20,50,50]
         ...
FUNKCJA: zwraca do podanej komorki wartosc wolnej pamieci fast.
@endnode
@node freepublic

KOMENDA: freepublic[(komorka)]
UÛYCIE : freepublic[20]
         text[0,50,42]=Ilosc wolnej pamieci (total):
         bintoascii[0,20,50,50]
         ...
FUNKCJA: zwraca do podanej komorki wartosc calkowitej (chip+fast) wolnej
         pamieci.
@endnode
@node freechip

KOMENDA: freechip[(komorka)]
UÛYCIE : freechip[20]
         text[0,50,42]=Ilosc wolnej pamieci chip:
         bintoascii[0,20,50,50]
         ...
FUNKCJA: zwraca do podanej komorki wartosc wolnej pamieci chip.
@endnode
