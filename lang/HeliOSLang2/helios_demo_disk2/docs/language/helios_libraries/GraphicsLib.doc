                   *********************************
                   HeliOS Graphics accessory library
                   *********************************

                   --------------------------------
                   HeliOS graphics library routines
                   --------------------------------

  Here is the list of functions in the HeliOS Graphic Library, with
  library call numbers and stack diagrams.

  See below for documentation on each function.

WAITBEAM       0                           RasterLine(w) - - -
OPENGELSYS     1                                RPort(l) - - - GelsInfo(l)
CLOSEGELSYS    2                                RPort(l) - - -
FREEVSBOB      3                              VSprite(l) - - -
MAKEVSPRITE    4                           Various...... - - - VSprite(l)
MAKEBOB        5                           Various...... - - - BOB(l)
SORTGLIST      6                                RPort(l) - - -
GETBOB         7                   BOB#(w), BOBSTRUCT(l) - - - BOB(l)
GETVS          8                    VS#(w), BOBSTRUCT(l) - - - VSprite(l)
SETBOBPOS      9       X(w), Y(w), BOB#(w), BOBSTRUCT(l) - - -
ADDBOB         10        BOB#(w), BOBSTRUCT(l), RPort(l) - - -
REMBOB         11  BOB#(w),B'STRUCT(l),RPort(l),VPort(l) - - -
DOCOLLISION    12                               RPort(l) - - -
DISPLAYGELS    13                     RPort(l), VPort(l) - - -
OPENBOBSTRUCT  14                       BOBPARAMTABLE(l) - - - BOBSTRUCT(l)
CLOSEBOBSTRUCT 15                           BOBSTRUCT(l) - - -
REMALLBOBS     16       BOBSTRUCT(l), RPort(l), VPort(l) - - -
ADDALLBOBS     17                 BOBSTRUCT(l), RPort(l) - - -
DRAWGLIST      18                     RPort(l), VPort(l) - - -
BLITWAIT       19                                        - - -
OWNBLIT        20                                        - - -
DISOWNBLIT     21                                        - - -
GETCURRENTVP   22                              Window(l) - - - VPort(l)
BLITBMAP       23       l1 n1 n2 n3 n4 n5 n6 n7 n8 l2 l3 - - -
GFXLIBBASE     24                                        - - - GFXLIBBASE(l)
BLITMASKBMAP   25 l1 n1 n2 n3 n4 n5 n6 n7 n8 l2 l3 n9 n10 n11 n12 - - -
MAKESHADOW     26                              BitMap(l) - - - ShadowPlane(l)
SWAPBOBIMAGE   27 BOBSTRUCT(l), n1, BOBPARAMTABLE(l), n2 - - -
ADDIEHANDLER   28          IEHandlerCode(l), Priority(w) - - -
FREEIEHANDLER  29                                        - - -
IEIOREQ        30                                        - - - IORequest(l)
SETUPSCROLL    31                        SCROLLSTRUCT(l) - - - SCROLLDATA(l)
SCROLLIT       32  SCROLLDATA(l), Num(w),HPix(w),VPix(w) - - -
FREESCRLDATA   33                          SCROLLDATA(l) - - -
GETWORDOFFSET  34          BMap(l), HPixel(w), VPixel(w) - - - Off(w), Bit(w)
FMAKEBLIT      35       l1 n1 n2 n3 n4 n5 n6 n7 n8 l2 l3 - - - FBlit(l)
FSMAKEBLIT     36                             BlitDef(l) - - - FBlit(l)
FASTBLIT       37                               FBlit(l) - - -
FCPUCLRRECT    38 Pln(l), BPR(w), LEdge(w), TEdge(w), Wid(w), Hgt(w) - - -
FBMCPUCLRRECT  39 BMap(l), LEdge(w), TEdge(w), Wid(w), Hgt(w) - - -
FCPURECTFILL   40 BMap(l), LEdge(w), TEdge(w), Wid(w), Hgt(w),Pen(w) - - -
FCPUBLITBMAP   41       l1 n1 n2 n3 n4 n5 n6 n7 n8 l2 l3 - - -
FSCPUBLITBMAP  42                             BlitDef(l) - - -
FASTBLITRECT   43                 PlaneMask(w), FBlit(l) - - -
MAKESHADOWBM   44                              BitMap(l) - - - ShadowBMap(l)
FSBLITBMAP     45                             BlitDef(l) - - -

  Note:

  The names of the routines are for reference in this documentation only,
  and are NOT used as HeliOS Words.  The routines are all called by using
  the KeyWord GraphicsLib along with the function number.

*************************************************************************

  ------------------
  HeliOS GraphicsLib
  ------------------

  This library of routines implements many useful functions for handling
  graphical operations.

  These functions include several very fast rendering/scrolling functions
  as well as a set of routines for handling the Amiga "Gels" system and a
  few general purpose "toolkit" commands.

  One or two of the functions in GraphicsLib are included for non-obvious
  "historical backward compatibility" reasons and are strictly speaking not
  graphical functions at all: such as the input event handler routines.

  ----------------------------------------
  Calling HeliOS Graphics Library routines
  ----------------------------------------

  As with all HeliOS internal libraries, each Graphics library routine
  has an associated reference number.

  In this documentation the functions are all given names for ease of
  reference, but you must remember that the names used here are NOT HeliOS
  command names, and all these functions are accessed from HeliOS by their
  library number alone.

  To call any routine simply use the command GraphicsLib preceded by the
  reference number of the routine you want to call.

  The calling parameters for any routine should be placed on the stack
  immediately before the reference number of the routine.

  For example, WAITBEAM is routine number "0" in the HeliOS Graphics
  library and requires a RasterLine specification as its sole parameter:

  WAITBEAM     ( RASTERLINE(w) - - - )

  where RASTERLINE is the vertical beam position for which you wish to wait.

  So, to call WAITBEAM you simply say:

  RASTERLINE      0                GRAPHICSLIB

  which expression is constructed as follows:

  RASTERLINE      0                GRAPHICSLIB
  ^^^^^^^^^^      ^                ^^^^^^^^^
  Parameter       Routine number   HeliOS internal library call


  -------------------------------------------------------
  Notes on using the HeliOS Amiga OS Sprite/Gels routines
  -------------------------------------------------------

  To allow limited animation capabilities under the Amiga operating system
  the HeliOS GraphicsLib includes various simple functions to help you to
  access the Amiga operating system's built in graphic object functions.

  These functions are nothing like so sophisticated as the HeliOS operating
  system's facilities, but they do have the advantage that you can use them
  while still running the Amiga operating system.

  To understand these functions properly you need to study documentation
  on the Amiga operating system's graphics GELS system.  Having done this
  you will see that the HeliOS GraphicsLib functions help take the hard
  work out of accessing the operating system by providing simple functions
  to help you with all the messy "housekeeping" involved.

  This documentation is NOT a discussion of the Amiga operating system,
  and merely summarises the HeliOS routines available, the use of which
  will be obvious once you understand how the Amiga OS works.

  *********************************************************************
  Functions for loading and setting up Amiga OS style VSprites and BOBs
  *********************************************************************

  -------------
  Creating BOBs
  -------------

  You can make individual BOBs and VSPrites by supplying the appropriate set
  of parameters to MAKEBOB and MAKEVSPRITE.  These functions closely follow
  the Amiga OS definitions of BOBs and VSPRITEs by allocating memory for an
  appropriate structure and initialising it according to your parameters.

  To free a BOB/VSprite made in this way use the GraphicsLib function
  FREEVSBOB with a pointer to the VSprite: this frees both the VSprite and
  its associated BOB structure (if any).

  HeliOS also allows you to automate the whole process of BOB creation and
  generate a whole set of BOBs in one simple process.

  HeliOS GraphicsLib makes it easy to create BOBs and get the BOB imagery
  into your software all in one fully automated function as follows:

  The BOB graphical imagery must first be created in a painting program
  such as DPaint with the imagery for all your BOBs stored together in one
  page, then saved as an IFF file.

  This imagery "source" IFF file can then be loaded into a storage bitmap,
  from where HeliOS allows you to turn each of the individual BOB images
  into completed BOBs by using simple automated functions.

  To tell HeliOS where your images are, and what size they are, you must
  create and initialise a BOBPARAMTABLE definition structure.

  This structure defines the position and size of all BOB images within
  the storage bitmap, as well as containing a pointer to the BitMap.  Having
  created this definition table all images may subsequently be defined in
  terms of an image number as specified sequentially in the BOBPARAMTABLE
  structure.

  You must create, initialise, and remove the imagery storage BitMap and
  BOBPARAMTABLE in your own code code external to GraphicsLib routines.

  The BOBPARAMTABLE format is as follows:

  Number_of_Bobs(w)
  BitMapPointer(l)

  BOB1X(w)         <-|  There must be one instance of these 4 definitions
  BOB1Y(w)           |  for each BOB being specified.  Each 8-byte section
  BOB1WID(w)         |  of data is stored sequentially in memory.
  BOB1HGT(w)       <-|

  BOB2X(w)         <-|  There must be one instance of these 4 definitions
  BOB2Y(w)           |  for each BOB being specified.  Each 8-byte section
  BOB2WID(w)         |  of data is stored sequentially in memory.
  BOB2HGT(w)       <-|

  etc. etc. for all BOBs in table........

  Thus, the size of the whole structure is:  6 + [8*Number_of_Bobs] bytes.

  As you can see, the BOBPARAMTABLE structure identifies the number, size
  and position of all the BOBS within the image storage BitMap, as well as
  including a pointer to the BitMap structure itself.

  The routine OPENBOBSTRUCT converts this BOBPARAMTABLE information into
  a set of initialised BOBS/VSprites and a creates a controlling BOBSTRUCT
  which HeliOS uses to organise and access all the newly created objects.

  HeliOS creates a set of linked BOB and VSprite structures automatically.

  Each BOB/VSprite has an associated BitMap structure used to control its
  graphical imagery bitplanes.

  When you have finished you must use CLOSEBOBSTRUCT to deallocate the
  BOBS and BOBSTRUCT which you created using OPENBOBSTRUCT.

  The BOBSTRUCT format is as follows:

  Number_of_Bobs(w)

  BOBBMap1(l)
  BOB1(l)

  BOBBMap2(l)
  BOB2(l)

  etc. etc. for all BOBs in table........

  Thus, the size of the whole structure is:  2 + [8*Number_of_Bobs] bytes.

  Any individual BOB or VSprite structure can be derived from the BOBSTRUCT
  using GETVS or GETBOB.

  ----------------------------------
  Setting up the Amiga "Gels" system
  ----------------------------------

  The HeliOS GraphicsLib has two routines, OPENGELSYS and CLOSEGELSYS, to
  set up and close down a GELS system for a RASTPORT.

  Having initialised a GELS system you can use ADDBOB and REMBOB to install
  and remove BOBS from the GELS system.

  There are more powerful generalised functions ADDALLBOBS and REMALLBOBS
  to operate on whole set of BOBS at once.

  The Amiga GELS system requires objects to be sorted before they are
  displayed, and GraphicsLib contains the command SORTGLIST to do this.

  The BOBs can then be displayed using the GraphicsLib DRAWGLIST function.

  GraphicsLib also has a more powerful function DISPLAYGELS which sorts
  and displays a set of BOBs in one operation.

  The position of any BOB can be set using SETBOBPOS to set position data
  into a BOB structure.

  The Amiga OS collision detection system is supported by GraphicLib with
  the DOCOLLISION routine.

  Note that the GELS system will do collision detection for you even if
  you actually display BOBS using your own Blitter routines.

  One more function, SWAPBOBIMAGE, allows you to change the imagery
  associated with any BOB.

  *******************************
  GraphicsLib "blitting" routines
  *******************************

  The HeliOS GraphicsLib has several useful blitter routines, including
  simple "toolkit" routines like OWNBLIT, DISOWNBLIT and BLITWAIT.

  The HeliOS GraphicsLib blitter function BLITBMAP is faster and more
  efficient than the Amiga operating system equivalent, and can be used 
  for many general purpose blitting tasks.  All HeliOS graphical objects
  have an associated BitMap to make blitting functions easy to access.

  The BLITMASKBMAP function is a more specialised function which allows
  you to blit dual-layered objects through a mask: useful in some games
  applications.

  MAKESHADOW allows you to create a shadow mask plane for any given BitMap
  and MAKESHADOWBM allows you to create a shadow mask BitMap.

  There is a very powerful and fast multi-directional blitter-scroller
  which allows precalculation of all blitter parameters for speed: this is
  implemented by the functions SETUPSCROLL, SCROLLIT, and FREESCRLDATA.
  This blit-scroller implements auto-fill and user defined fill along with
  many other sophisticated options.  The efficiency of this scroller can be
  demonstrated easily since it is used for the fast smooth scrolling of the
  HeliOS Editors.

  For fast and optimised blits which are suitable for pre-calculation there
  are routines which allow all blitter parameters to be precalculated and
  stored in a data structure ready for directly loading into the blitter
  hardware.  These functions are FMAKEBLIT, FSMAKEBLIT, and FASTBLIT.

  For applications where blitter-type operations might be more efficiently
  or appropriately performed by the CPU, HeliOS GraphicsLib includes CPU
  blitter emulation.  This allows you to run CPU equivalents of blitter
  functions such as BLITBMAP, as well as rectangular area fill and area
  clear routines.


**************************************************
A detailed description of the GraphicsLib routines
**************************************************

Below is a detailed description of all the GraphicsLib routines.

At the start of each description is the routine number followed by the
documentation name for the function.

***************************************************************************

  [ 0 ]

  --------
  WAITBEAM     ( RasterLine(w) - - - )
  --------

  Where:

  RasterLine = Video beam position.

  This function waits for the specified raster line to be reached by the
  video beam before proceeding.

****************************************************************************

  [ 1 ]

  ----------
  OPENGELSYS    ( RPort(l) - - - GelsInfo(l) or null )
  ----------

  Set up RPort ready for use with Amiga Gels routines.

  This function creates and initialises a GelsInfo structure and sets up
  dummy collision routines etc.

  Failure returns null.

****************************************************************************

  [ 2 ]

  -----------
  CLOSEGELSYS    ( RPort(l) - - - )
  -----------

  Remove Gels system from RPort and deallocates GelsInfo structure etc.


****************************************************************************

  [ 3 ]

  ---------
  FREEVSBOB     ( VSprite(l) - - - )
  ---------

  Frees VSprite and BOB structures.

****************************************************************************

  [ 4 ]

  -----------
  MAKEVSPRITE ( User3(w), User2(w), User1(w), Cols(l), Img(l), ImgDpth(w),
  -----------   WordWdth(w), Hgt(w), InitX(w), InitY(w), Flags(w)
                - - - VSprite(l) or null )

  Allocates a VSprite and initialises it according to the parameters you
  supply, including the initialisation of a collision mask.

  Failure returns null.

****************************************************************************

  [ 5 ]

  -------
  MAKEBOB     ( PlnPick(w), PlnOnOff(w), BitWidth(w), User3(w), User2(w),
  -------       User1(w), Cols(l), Img(l), ImgDpth(w), WordWdth(w), Hgt(w),
                InitX(w), InitY(w), Flags(w)  - - - BOB(l) or null )

  Allocates a BOB and initialises it according to the parameters you
  supply, including the initialisation of a collision mask and creation
  of associated VSprite.

  Failure returns null.

****************************************************************************

  [ 6 ]

  ---------
  SORTGLIST   ( RPort(l) - - - )
  ---------

  Performs the Amiga OS SortGList function.

****************************************************************************

  [ 7 ]

  ------
  GETBOB     ( BOB#(w), BOBSTRUCT(l) - - - BOB(l) )
  ------

  Returns a pointer to the BOB structure of BOB number BOB# with reference
  to a HeliOS BOBSTRUCT reference table.

  See OPENBOBSTRUCT, CLOSEBOBSTRUCT etc.

****************************************************************************

  [ 8 ]

  -----
  GETVS      ( VS#(w), BOBSTRUCT(l) - - - VSprite(l) )
  -----

  Returns a pointer to the VSprite structure of VS/BOB number VS# with
  reference to a HeliOS BOBSTRUCT reference table.

  See OPENBOBSTRUCT, CLOSEBOBSTRUCT etc.

****************************************************************************

  [ 9 ]

  ---------
  SETBOBPOS  ( X(w), Y(w), BOB#(w), BOBSTRUCT(l) - - - )
  --------

  Sets the X and Y coordinates of BOB number BOB# with reference to a
  HeliOS BOBSTRUCT reference table.

  See OPENBOBSTRUCT, CLOSEBOBSTRUCT etc.

****************************************************************************

  [ 10 ]

  ------
  ADDBOB     ( BOB#(w), BOBSTRUCT(l), RPort(l) - - - )
  ---------

  Performs the Amiga OS AddBob function.

****************************************************************************

  [ 11 ]

  ------
  REMBOB     ( BOB#(w), BOBSTRUCT(l), RPort(l), VPort(l) - - - )
  ------

  Performs the Amiga OS RemBob function.

****************************************************************************

  [ 12 ]

  -----------
  DOCOLLISION  ( RPort(l) - - - )
  -----------

  Performs the Amiga OS DoCollision function.

****************************************************************************

  [ 13 ]

  -----------
  DISPLAYGELS  ( RPort(l), VPort(l) - - - )
  -----------

  Performs the Amiga OS SortGlist, WaitBOVP, and DrawGlist functions.

****************************************************************************

  [ 14 ]

  -------------
  OPENBOBSTRUCT  ( BOBPARAMTABLE(l) - - - BOBSTRUCT(l) )
  -------------

  Opens and initialises a BOBSTRUCT and a series of BOBS, storing pointers
  to the BOB structures and associated BitMap structures for each BOB in
  the BOBSTRUCT.

  The BOBSTRUCT is then used by the HeliOS Gels interface as a reference
  structure from which BOBs can be selected by number.

  The BOBPARAMTABLE contains information about how many BOBs to create
  and the position of BOB graphical imagery within a source bitmap.

  See notes above and example software.

****************************************************************************

  [ 15 ]

  --------------
  CLOSEBOBSTRUCT  ( BOBSTRUCT(l) - - - )
  --------------

  Frees up everything allocated by OPENBOBSTRUCT.

****************************************************************************

  [ 16 ]

  ----------
  REMALLBOBS  ( BOBSTRUCT(l), RPort(l), VPort(l) - - - )
  ----------

  Performs the Amiga OS RemBob function for all BOBs in BOBSTRUCT.

****************************************************************************

  [ 17 ]

  ----------
  ADDALLBOBS  ( BOBSTRUCT(l), RPort(l) - - - )
  ----------

  Performs the Amiga OS AddBob function for all BOBs in BOBSTRUCT.

****************************************************************************

  [ 18 ]

  ---------
  DRAWGLIST   ( RPort(l), VPort(l) - - - )
  ---------

  Performs the Amiga OS DrawGlist function.

****************************************************************************

  [ 19 ]

  --------
  BLITWAIT    ( - - - )
  --------

  Waits for blitter to complete previous operation.

  Can be used under Amiga or HeliOS operating systems.

****************************************************************************

  [ 20 ]

  -------
  OWNBLIT     ( - - - )
  -------

  Gets blitter for our use.

  Can be used under Amiga or HeliOS operating systems.

****************************************************************************

  [ 21 ]

  ----------
  DISOWNBLIT  ( - - - )
  ----------

  Frees blitter for use by other software.

  Can be used under Amiga or HeliOS operating systems.

****************************************************************************

  [ 22 ]

  ------------
  GETCURRENTVP   ( Window(l) - - - VPort(l) )
  ------------

  Returns ViewPort for Window.

****************************************************************************

  [ 23 ]

  --------
  BLITBMAP   ( MaskBmap(l), PlaneOnOff(w), Minterm(w), SizeX(w), SizeY(w),
  --------     SrcX(w), SrcY(w), TgtX(w), TgtY(w), SrcBmap(l), TgtBmap(l)
               - - - )

  Where:

  MaskBmap     = A BitMap structure specifying a shadow mask plane.

  PlaneOnOff   = A bit mask specifying which planes to blit.

  Minterm      = Blitter minterm.

  SizeX        = Horizontal pixel size of blit.

  SizeY        = Vertical pixel size of blit.

  SrcX         = Source top left corner horizontal pixel position.

  SrcY         = Source top left corner vertical pixel position.

  TgtX         = Target top left corner horizontal pixel position.

  TgtY         = Target top left corner vertical pixel position.

  SrcBmap      = Source BitMap.

  TgtBmap      = Target BitMap.

  Carries out a blit between two bitmaps as specified.

  If MaskBMap is non-zero this operation will blit through a mask plane
  specified by the mask BitMap structure supplied.

  Blitter channel useage is as follows:

  Source  -> A
  Target  -> C
  Mask    -> B

  Note that this function has an exact equivalent in terms of parameters
  passed and functionality except that the CPU is used.

  The CPU version is called CPUBlitBMap and is useful for manipulating
  images in fast memory.

  See also FSBLITBMAP, FMAKEBLIT and FSMAKEBLIT.

****************************************************************************

  [ 24 ]

  ----------
  GFXLIBBASE   ( - - - GraphicsLib(l) )
  ----------

  Used to run GraphicsLib routines from machine code.

  Returns a pointer to the GraphicsLib driver code which requires the
  current GraphicsLib command and parameters to be on the HeliOS stack
  (pointed to by A5) before performing a "jsr" to "GraphicsLib".

****************************************************************************

  [ 25 ]

  ------------
  BLITMASKBMAP   ( MaskBMap(l), PlaneOnOff(w), BGMinterm(w), SizeX(w),
  ------------     SizeY(w), BGSrcX(w), BGSrcY(w), TgtX(w), TgtY(w),
                   SrcBmap(l), TgtBmap(l), FGSrcX(w), FGSrcY(w),
                   FGMinterm(w), Flag(w) - - - )

  Where:

  MaskBMap     = Pointer to BitMap structure specifying source shadow mask.

  PlaneOnOff   = A bit mask specifying which planes to blit.

  BGMinterm    = Minterm for background layer blit.

  SizeX        = Horizontal pixel size of blit.

  SizeY        = Vertical pixel size of blit.

  BGSrcX       = Source background top left corner horizontal pixel position.

  BGSrcY       = Source background top left corner vertical pixel position.

  TgtX         = Target top left corner horizontal pixel position.

  TgtY         = Target top left corner vertical pixel position.

  SrcBmap      = Source BitMap.

  TgtBmap      = Target BitMap.

  FGSrcX       = Source foreground top left corner horizontal pixel position.

  FGSrcY       = Source foreground top left corner vertical pixel position.

  FGMinterm    = Minterm for foreground layer blit.

  Flag         = 0 -> Blit both layers.
                 1 -> Blit foreground layer only.
                 2 -> Blit background layer only.

  This is a simple to use but powerful function which allows dual-layered
  blitting between two bitmaps.

  Using this function you can render graphics which appear to be composed
  of two graphical layers in which you can choose to render:

  1. Target = Source background layer alone.

  2. Target = Source foreground layer alone.

  3. Target = Source background layer viewed through a masked source
              foreground layer: the background layer is blitted first,
              followed by the foreground layer blitted through the mask.

  The two layers are both of identical size and are blitted into the
  same target area.

  The foreground and background source images must come from the same
  source BitMap.

  Blitter channel useage is as follows:

  Source  -> A
  Target  -> C
  Mask    -> B

  This function allows you to combine foreground and background imagery
  with transparency effects all in one simple blitter operation.

  For example you might have a set of background blocks which formed your
  target display backdrop according to some form of mapped array.

  You could then have some foreground characters with shapes surrounded by
  colour zero areas.

  You could then simultaneously render both graphics layers together, with
  the colour zero areas of the foreground being transparent.

  If you had a display rendered as above you could use the "flag" parameter
  of this function to determine whether background, foreground, or both
  were to be visible when you rendered the graphics display.

****************************************************************************

  [ 26 ]

  ----------
  MAKESHADOW   ( BitMap(l) - - - ShadowPlane(l) )
  ----------

  Allocates and initialises a shadow mask bitplane for BitMap.

****************************************************************************

  [ 27 ]

  ------------
  SWAPBOBIMAGE  ( BOBSTRUCT(l), n1 , BOBPARAMTABLE(l), n2 - - - )
  ------------

  Gets a new image for BOB number n1 of BOBSTRUCT.

  The new image is fetched from the BOB imagery source BitMap position
  specified by BOB number n2 in the BOBPARAMTABLE.


****************************************************************************

  [ 28 ]

  ------------
  ADDIEHANDLER  ( IEHandlerCode(l), Priority(w) - - - )
  ------------

  Where:

  IEHandlerCode  = Pointer to machine code to be run by handler

  Priority       = Handler priority

  This function installs an input event handler into the Amiga's input
  handler chain.

  You must specify your own handler code and the handler priority.

  If you need a pointer to the IORequest structure, use the IOREQ function.

  N.B.

  This code only provides a facility for using ONE event handler!

  You can only run this code once in any program unless you have used
  FREEIEHANDLER to deallocate an earlier installed handler.

  See the Amiga ROM Kernel manuals for information on adding input handlers.

  This function allows you to add a single handler in a very simple manner.

****************************************************************************

  [ 29 ]

  -------------
  FREEIEHANDLER  ( - - - )
  -------------

  Removes and deallocates an input event handler created using ADDIEHANDLER.

****************************************************************************

  [ 30 ]

  -------
  IEIOREQ     ( - - - IORequest(l) )
  -------

  Returns a pointer to the current IORequest block created by ADDIEHANDLER.

****************************************************************************

  [ 31 ]

  -----------
  SETUPSCROLL  ( SCROLLSTRUCT(l) - - - SCROLLDATA(l) )
  -----------

  This function allocates and initialises a SCROLLDATA structure which
  contains a full set of precalculated parameters for multi-directional
  scrolling blits.

  Subsequently the SCROLLDATA structure can be used by SCROLLIT to perform
  very fast precalculated scroll-blits with user definable horizontal and
  vertical scroll increments.

  A very flexible after-fill control allows you to specify what happens
  to the area left behind by the scroll, and by employing the user defined
  fill option you can create circular "barrel" scrolls, pattern fills etc.

  The predefined SCROLLDATA specifies the position and size of the scroll
  area, but the final SCROLLIT routines specifies the user definable scroll
  amounts, allowing flexible variable scrolls in many directions.

  Here is the definition of the SCROLLSTRUCT which you supply initialised
  with your scroll parameters.

  SCROLLSTRUCT:

  SCRLRPort(l)        = Pointer to the RastPort containing the scroll area.
  SCRLLEdge(w)        = Scroll top left corner horizontal pixel position.
  SCRLTEdge(w)        = Scroll top left corner vertical pixel position.
  SCRLWidth(w)        = Scroll pixel width.
  SCRLHeight(w)       = Scroll pixel height.
  SCRLPlaneOnOff(w)   = Scroll plane useage mask.
  SCRLHClear(w)       = Horizontal background fill flag.
  SCRLVClear(w)       = Vertical background fill flag.
  SCRLHXClear(w)      = External user-code horizontal fill for 1st scroll.
  SCRLVXClear(w)      = External user-code vertical fill for 1st scroll.
  SCRLHRptXClear(w)   = External user-code horizontal fill for repeat scrolls.
  SCRLVRptXClear(w)   = External user-code vertical fill for repeat scrolls.
  SCRLFontSize(w)     = Reserved.
  SCRLBeamPos(w)      = Specifies blitwait video beam position.
  SCRLFlags(w)        = Reserved.

  Here is a more detailed discussion of each field in SCROLLSTRUCT:


  SCRLRPort           This is simply a pointer to the RastPort containing
                      the scroll area.

  SCRLLEdge           This is the top left corner horizontal pixel position
                      of the scroll area.

  SCRLTEdge           This is the top left corner vertical pixel position
                      of the scroll area.

  SCRLWidth           This is the scroll area width in pixels.

  SCRLHeight          This is the scroll area height in pixels.

  SCRLPlaneOnOff      This is the scroll blit plane selection bitmask,
                      specifying which planes will be scrolled.

  SCRLHClear          This is a flag which specifies whether or not HeliOS
                      should perform an automatic horizontal background fill
                      after the first scroll iteration.

                      If you do not specify any fill at all, the scroll
                      area will exhibit a "trail" as the edge of the area
                      is repeatedly redrawn displaced across the screen.

  SCRLVClear          This is a flag which specifies whether or not HeliOS
                      should perform an automatic vertical background fill
                      after the first scroll iteration.

                      If you do not specify any fill at all, the scroll
                      area will exhibit a "trail" as the edge of the area
                      is repeatedly redrawn displaced across the screen.

  SCRLHXClear         This field can be left null, or can point to the CFA
                      of a HeliOS command which defines the fill operation
                      performed for the initial horizontal fill.

                      This only operates on the first scroll iteration.

                      One example of the use of user defined fills would be
                      if you wanted to replace the area scrolled off one
                      side back on the other edge of the scroll area to
                      give a "barrel scroll" effect.

                      Another example might be to create a one-off fill
                      pattern along the trailing edge of the first scroll
                      iteration.  This pattern would then be automatically
                      repeated for all subsequent scroll iterations.

  SCRLVXClear         This field can be left null, or can point to the CFA
                      of a HeliOS command which defines the fill operation
                      performed for the initial vertical fill.

                      This only operates on the first scroll iteration.

                      One example of the use of user defined fills would be
                      if you wanted to replace the area scrolled off one
                      side back on the other edge of the scroll area to
                      give a "barrel scroll" effect.

                      Another example might be to create a one-off fill
                      pattern along the trailing edge of the first scroll
                      iteration.  This pattern would then be automatically
                      repeated for all subsequent scroll iterations.

  SCRLHRptXClear      This field can be left null, or can point to the CFA
                      of a HeliOS command which defines the fill operation
                      performed for repeated horizontal fills.

                      This operates on all repeat-scroll iterations.

                      One example of the use of user defined fills would be
                      if you wanted to replace the area scrolled off one
                      side back on the other edge of the scroll area to
                      give a "barrel scroll" effect.

                      Another example for repeated fills might be to create
                      a varying fill pattern along the trailing edge of the
                      scroll, changing with each iteration.

  SCRLVRptXClear      This field can be left null, or can point to the CFA
                      of a HeliOS command which defines the fill operation
                      performed for repeated vertical fills.

                      This operates on all repeat-scroll iterations.

                      One example of the use of user defined fills would be
                      if you wanted to replace the area scrolled off one
                      side back on the other edge of the scroll area to
                      give a "barrel scroll" effect.

                      Another example for repeated fills might be to create
                      a varying fill pattern along the trailing edge of the
                      scroll, changing with each iteration.

  SCRLReserved        This is a reserved field: do not use it.

  SCRLBeamPos         This field specifies a beam position which is used
                      to synchronise the scroll blit with the display to
                      avoid flicker.

                      The blit will not begin until the video beam is at
                      the specified raster line.

  SCRLFlags           This is a reserved field: do not use it.

  A further note on trailing area fills:

  The scrolling function has two distinct phases during which you can
  control the fill function applied, with a sequence of operations like
  this:

  1 iteration of the initial scroll

  1 (possible) iteration of User_Defined_Initial_VClear
  1 (possible) iteration of User_Defined_Initial_HClear
  1 (possible) iteration of Automatic_Background_Fill_VClear
  1 (possible) iteration of Automatic_Background_Fill_HClear

  ...followed by:

  Multiple iterations of continuation scroll
  Multiple iterations of User_Defined_Repeated_VClear
  Multiple iterations of User_Defined_Repeated_HClear

  Use FREESCRLDATA to de-allocate SCROLLDATA when you are finished.

  See SCROLLIT for more information.

****************************************************************************

  [ 32 ]

  --------
  SCROLLIT  ( SCROLLDATA(l), Num(w), HPix(w), VPix(w) - - - )
  --------

  Where:

  SCROLLDATA = Data structure created by SETUPSCROLL which contains all
               the precalculated blitter parameters used to do the scroll.

  Num        = Number of sub-scroll iterations. (0=Do nothing)

  HPix       = Horizontal displacement index for each sub-scroll

               0 = 0  Pixels horizontal movement
               1 = 1  Pixels horizontal movement
               2 = 2  Pixels horizontal movement
               3 = 4  Pixels horizontal movement
               4 = 8  Pixels horizontal movement
               5 = 16 Pixels horizontal movement

               HPix = +ve for Move-Right
               HPix = -ve for Move-Left

  VPix       = Vertical displacement index for each sub-scroll.

               0 = 0  Pixels vertical movement
               1 = 1  Pixels vertical movement
               2 = 2  Pixels vertical movement
               3 = 4  Pixels vertical movement
               4 = 8  Pixels vertical movement
               5 = 16 Pixels vertical movement

               VPix = +ve for Move-Down
               VPix = -ve for Move-Up

  N.B.

  See the SCROLLSTRUCT structure which is used by SETUPSCROLL for the other
  scroll control parameters.


  The SCROLLIT function can do multiple iterations of precalculated fast
  scroll blits which shift a rectangular area a specified fixed distance
  Left/Right/Up/Down with each iteration.

  You can specify whether the area "left behind" is cleared, or filled using
  your own specified "clear-fill" routine, or simply left as it was.

  The fill routines have two phases of operation:

  1. The first fill which is done once after the first blit.

  2. A repeated fill which is done after each succeeding blit.

  If you perform a simple "clear" fill on the first iteration of the scroll,
  subsequent iterations do not need any specific fill operation to simply
  clear the trailing area: the original blank area will automatically be
  repeatedly recopied with each blit.  Thus the automatic "clear" fill only
  operates on the first scroll iterartion.

  You can also supply your own custom fill routines, and in this case the
  fill can be carried out for every iteration of the scroll if you wish.

  This means that the SCROLLIT function has two distinct phases during which
  you can control the fill function applied, with a sequence of operations
  something like this:

  1 iteration of the initial scroll

  1 (possible) iteration of User_Defined_Initial_VClear
  1 (possible) iteration of User_Defined_Initial_HClear
  1 (possible) iteration of Automatic_Background_Fill_VClear
  1 (possible) iteration of Automatic_Background_Fill_HClear

  ...followed by:

  Multiple iterations of continuation scroll
  Multiple iterations of User_Defined_Repeated_VClear
  Multiple iterations of User_Defined_Repeated_HClear

  The SCROLLIT routine does nothing if number or scrolls is specified as 0.

  See SETUPSCROLL for more information.

****************************************************************************

  [ 33 ]

  ------------
  FREESCRLDATA   ( SCROLLDATA(l) - - - )
  ------------

  Frees all allocations made by SETUPSCROLL.

  This function can safely accept a null parameter.

****************************************************************************

  [ 34 ]

  -------------
  GETWORDOFFSET    ( BMap(l), HPixel(w), VPixel(w) - - - Off(w), Bit(w) )
  -------------

  This function returns:

  1. The byte offset from the start of a BitMap plane to the start of the
     data WORD (16-bit) which contains the specified pixel position.

  2. The bit offset from the start of the data word to the actual pixel
     position specified.

****************************************************************************

  [ 35 ]

  ---------
  FMAKEBLIT   ( MaskBmap(l), PlaneOnOff(w), Minterm(w), SizeX(w), SizeY(w),
  ---------     SrcX(w), SrcY(w), TgtX(w), TgtY(w), SrcBmap(l), TgtBmap(l)
                - - - FBlit(l) )

  (This routine returns null for failure, which will only occur in the
  unlikely event that the small memory allocation used internally fails.)

  Where:

  MaskBmap     = A BitMap structure specifying a shadow mask plane.

  PlaneOnOff   = A bit mask specifying which planes to blit.

  Minterm      = Blitter minterm.

  SizeX        = Horizontal pixel size of blit.

  SizeY        = Vertical pixel size of blit.

  SrcX         = Source top left corner horizontal pixel position.

  SrcY         = Source top left corner vertical pixel position.

  TgtX         = Target top left corner horizontal pixel position.

  TgtY         = Target top left corner vertical pixel position.

  SrcBmap      = Source BitMap.

  TgtBmap      = Target BitMap.

  If MaskBMap is non-zero the final operation will blit through a mask
  plane specified by the mask BitMap structure supplied.

  This function allows you to set up an FBlit structure which contains
  a full set of precalculated parameters for a blitter operation.

  The FBlit structure is allocated automatically and initialised from the
  parameters you supply on the stack.

  Subsequently the FBlit structure can be used by the FASTBLIT function
  to perform very fast blits without any calculation being required.

  The FBlit structure can be deallocated using FREEMEMORY.

  See also FASTBLIT and FSMAKEBLIT.

****************************************************************************

  [ 36 ]

  ----------
  FSMAKEBLIT  ( BlitDef(l) - - - FBlit(l) )
  ----------

  (This routine returns null for failure, which will only occur in the
  unlikely event that the small memory allocation used internally fails.)

  Where BlitDef is a structure which you allocate and initialise with the
  parameters for your blitter operation.

  BlitDef structure:

  TgtBMap(l)  = Pointer to target BitMap.
  SrcBMap(l)  = Pointer to Source BitMap.
  TgtTEdge(w) = Top left vertical pixel position for target.
  TgtLEdge(w) = Top left horizontal pixel position for target.
  SrcTEdge(w) = Top left vertical pixel position for source.
  SrcLEdge(w) = Top left horizontal pixel position for source.
  Height(w)   = Height if blit in pixels.
  Width(w)    = Width of blit in pixels.
  MinTerm(w)  = Blitter MinTerm.
  POnOff(w)   = Plane On/Off bit mask.
  MaskBMap(l) = Pointer to BitMap structure defining shadow mask plane.

  This function allows you to set up an FBlit structure which contains
  a full set of precalculated parameters for a blitter operation.

  The FBlit structure is allocated automatically and initialised from the
  parameters you supply in the form of a BlitDef structure.

  Subsequently the FBlit structure can be used by the FASTBLIT function
  to perform very fast blits without any calculation being required.

  See also FASTBLIT and FMAKEBLIT.

****************************************************************************

  [ 37 ]

  --------
  FASTBLIT   ( FBlit(l) - - - )
  --------

  Performs a fast pre-calculated blitter operation as defined by FBlit.

  The precalulations are done using FMAKEBLIT and FSMAKEBLIT.

****************************************************************************

  [ 38 ]

  -----------
  FCPUCLRRECT  ( Pln(l), BPR(w), LEdge(w), TEdge(w), Wid(w), Hgt(w) - - - )
  -----------

  Where:

  Pln   = Pointer to the start of a bitplane (or any memory area).

  BPR   = How many bytes in each "row" of the specified plane.

  LEdge = Horizontal pixel offset of rectangle top left corner.

  TEdge = Vertical pixel offset of rectangle top left corner.

  Wid   = Width of rectangle in pixels.

  Hgt   = Height of rectangle in pixels.

  This function uses the CPU to clear a rectangular area in any bitplane
  or pseudo-bitplane in chip or fast memory.

  Bitplanes in fast memory can be used by HeliOS for storing graphical
  imagery which can be CPU-Blitted to chip memory bitplanes for display.

  This is a fast and efficent operation which may sometimes be quicker or
  more convenient than using the blitter.

  The BPR value can be specified "incorrectly" for any given real bitplane
  to create line-by-line offset cleared areas with sloping edges.

****************************************************************************

  [ 39 ]

  -------------
  FBMCPUCLRRECT  ( BMap(l), LEdge(w), TEdge(w), Wid(w), Hgt(w) - - - )
  -------------

  Where:

  BMap  = Pointer to a BitMap defining the "target" bitplanes.

  LEdge = Horizontal pixel offset of rectangle top left corner.

  TEdge = Vertical pixel offset of rectangle top left corner.

  Wid   = Width of rectangle in pixels.

  Hgt   = Height of rectangle in pixels.

  This function uses the CPU to clear a rectangular area in all bitplanes
  in the specified BitMap.

  These bitplanes can be stored in chip or fast memory.

  Bitplanes in fast memory can be used by HeliOS for storing graphical
  imagery which can be CPU-Blitted to chip memory bitplanes for display.

  This is a fast and efficent operation which may sometimes be quicker or
  more convenient than using the blitter.

****************************************************************************

  [ 40 ]

  ------------
  FCPURECTFILL ( BMap(l), LEdge(w), TEdge(w), Wid(w), Hgt(w), Pen(w) - - - )
  ------------

  Where:

  BMap  = Pointer to a BitMap defining the "target" bitplanes.

  LEdge = Horizontal pixel offset of rectangle top left corner.

  TEdge = Vertical pixel offset of rectangle top left corner.

  Wid   = Width of rectangle in pixels.

  Hgt   = Height of rectangle in pixels.

  Pen   = Colour pen number for rectangle fill.

  This function uses the CPU to set a rectangular area in all bitplanes
  of the specified BitMap to the specified pen colour.

  These bitplanes can be stored in chip or fast memory.

  Bitplanes in fast memory can be used by HeliOS for storing graphical
  imagery which can be CPU-Blitted to chip memory bitplanes for display.

  This is a fast and efficent operation which may sometimes be quicker or
  more convenient than using the blitter.

****************************************************************************

  [ 41 ]

  ------------
  FCPUBLITBMAP ( MaskBmap(l), PlaneOnOff(w), Minterm(w), SizeX(w), SizeY(w),
  ------------   SrcX(w), SrcY(w), TgtX(w), TgtY(w), SrcBmap(l), TgtBmap(l)
                 - - - )

  Where:

  MaskBmap     = A BitMap structure specifying a shadow mask plane.

  PlaneOnOff   = A bit mask specifying which planes to blit.

  Minterm      = Blitter minterm.

  SizeX        = Horizontal pixel size of blit.

  SizeY        = Vertical pixel size of blit.

  SrcX         = Source top left corner horizontal pixel position.

  SrcY         = Source top left corner vertical pixel position.

  TgtX         = Target top left corner horizontal pixel position.

  TgtY         = Target top left corner vertical pixel position.

  SrcBmap      = Source BitMap.

  TgtBmap      = Target BitMap.

  If MaskBMap is non-zero this operation will blit through a mask plane
  specified by the mask BitMap structure supplied.

  Carries out a CPU-blit between two bitmaps as specified: this function is
  a full implementation of BlitBMap using the CPU instead of the blitter.

  Since this function uses the CPU it can be used to transfer data between
  bitplanes in chip or fast memory.

  This is a fast and efficent operation which may sometimes be quicker or
  more convenient than using the blitter.

  Note that this function is an exact equivalent in terms of parameters
  passed and functionality to BlitBMap.

****************************************************************************

  [ 42 ]

  -------------
  FSCPUBLITBMAP  ( BlitDef(l) - - - )
  -------------

  Where BlitDef is a structure which you allocate and initialise with the
  parameters for your blitter operation.

  BlitDef structure:

  TgtBMap(l)  = Pointer to target BitMap.
  SrcBMap(l)  = Pointer to Source BitMap.
  TgtTEdge(w) = Top left vertical pixel position for target.
  TgtLEdge(w) = Top left horizontal pixel position for target.
  SrcTEdge(w) = Top left vertical pixel position for source.
  SrcLEdge(w) = Top left horizontal pixel position for source.
  Height(w)   = Height if blit in pixels.
  Width(w)    = Width of blit in pixels.
  MinTerm(w)  = Blitter MinTerm.
  POnOff(w)   = Plane On/Off bit mask.
  MaskBMap(l) = Pointer to BitMap structure defining shadow mask plane.

  If MaskBMap is non-zero this operation will blit through a mask plane
  specified by the mask BitMap structure supplied.

  Carries out a CPU-blit between two bitmaps as specified: this function is
  a full implementation of BlitBMap using the CPU instead of the blitter.

  Since this function uses the CPU it can be used to transfer data between
  bitplanes in chip or fast memory.

  This is a fast and efficent operation which may sometimes be quicker or
  more convenient than using the blitter.

****************************************************************************

  [ 43 ]

  ------------
  FASTBLITRECT   ( PlaneMask(w), FBlit(l) - - - )
  ------------

  Where:

  PlaneMask = Bit mask defining which planes you wish to be affected.

  FBlit     = Pre-calculated blitter parameter structure created using
              the FMAKEBLIT or FSMAKEBLIT functions.

  This function uses the precalculated parameters stored in FBlit to
  generate a very fast blitter rectangle fill operation.

  No source bitmap is required for this operation, and the FMAKEBLIT or 
  FSMAKEBLIT functions used to set up this function should use the Target 
  bitmap and position parameters as the source parameters also.


****************************************************************************

  [ 44 ]

  ------------
  MAKESHADOWBM   ( BitMap(l) - - - ShadowBMap(l) )
  ------------

  Allocates and initialises a shadow mask for a BitMap in the form of a
  mask plane and fully initialised control ShadowBitMap.

****************************************************************************

  [ 45 ]

  ----------
  FSBLITBMAP  ( BlitDef(l) - - - )
  ----------

  Where BlitDef is a structure which you allocate and initialise with the
  parameters for your blitter operation.

  BlitDef structure:

  TgtBMap(l)  = Pointer to target BitMap.
  SrcBMap(l)  = Pointer to Source BitMap.
  TgtTEdge(w) = Top left vertical pixel position for target.
  TgtLEdge(w) = Top left horizontal pixel position for target.
  SrcTEdge(w) = Top left vertical pixel position for source.
  SrcLEdge(w) = Top left horizontal pixel position for source.
  Height(w)   = Height if blit in pixels.
  Width(w)    = Width of blit in pixels.
  MinTerm(w)  = Blitter MinTerm.
  POnOff(w)   = Plane On/Off bit mask.
  MaskBMap(l) = Pointer to BitMap structure defining shadow mask plane.

  If MaskBMap is non-zero this operation will blit through a mask plane
  specified by the mask BitMap structure supplied.

  This function accesses BLITBMAP using a data structure for parameters
  rather than supplying them on the stack.  This can be faster and more
  convenient in some circumstances.

************************************************************************
End
************************************************************************
