
***********************************************
Hardware Sprites and Software Sprites in HeliOS
***********************************************

A "hardware" sprite is so called because it is created using a dedicated
sprite generation function of the Amiga hardware: it is a separate entity
which is maintained as part of the hardware video display and is not in any
way dependent on the video display bitplanes stored in memory.

Software sprites, on the other hand, are merely "logical" entities which
are rendered as part of the display bitplanes.  A software sprite has
a bitmapped image which a program causes to be mapped into the display
bitplanes in memory: once this operation has been performed the software
sprite image is an integral part of the display bitplanes.  The so-called
"software sprite" is effectively a set of parameters which define how a
program projects a "sprite" sub-image onto the main display bitplanes.

The Amiga display hardware constructs the actual visible screen image from
display bitplanes stored in memory and superimposes the 8 hardware sprites,
if they are activated, in front of the bitmapped imagery.  As far as the
video hardware is concerned hardware sprites are separate video objects,
but software sprites do not exist as independent entities and are simply
part of the main display bitmapped imagery.

Software sprites require considerable CPU processing time to manage the
way they are drawn into the display bitplanes and to restore and redraw
the display as they are moved.  They are often (usually) rendered into the
display bitplanes using the blitter, and because of this they are often
referred to as "Bobs", which name is a shortened form of the expression
"Blitter OBjectS".  Because "Bobs" make use of the blitter, they also
suffer constraints of speed and timing resulting from the limited capacity
and speed of the blitter.  The fact that there is only one blitter which
has to process all Bob operations sequentially can result in rather severe
timing restrictions, so software sprites need to be carefully planned.

In summary:

Software sprites are very flexible but tend to be slow and require careful
administration in terms of the heavy system overhead involved in their use.

Hardware sprites are generated by special hardware, therefore they can be
moved around and displayed with very little system overhead.  Hardware
sprites are restricted in many ways but are very fast and efficient.

Here are a few important specific points to consider:

1.  Hardware sprites take slightly more CPU time and NO blitter useage.

2.  Software sprites take slightly less CPU time and a lot of blitter useage.

3.  The efficiency and practicability of using software sprites depends on
    how many sprites are to be used and how many colours you are displaying.

4.  You are restricted in how many software sprites you can use by all the
    usual constraints of processing time, memory useage, and program speed.

5.  The efficiency of hardware sprites inevitably depends to some degree
    on how many sprites are used, so you must consider speed, as always, in
    some circumstances.  Nevertheless the very efficient HeliOS multiplexing
    system allows up to 255 hardware sprites to be maintained on screen at
    one time quite easily, and there is NO blitter overhead at all.

6.  You are restricted to a maximum of 255 AutoHSprites by the HeliOS system.

7.  Hardware sprites suffer colour limitations: they must be 4 or 16 colours.

8.  Hardware sprites suffer resolution limitations (see Amiga documentation).

9.  Hardware sprites suffer positional limitations (see below).

10. Hardware sprites suffer restriction of available channels, especially
    when using 16 colour sprites.


********************************************************
Programming techniques for hardware and software sprites
********************************************************

Software sprites are implemented by placing bitmapped imagery into the
display bitplanes either by using the blitter or the CPU.  Individual
implementations of software sprites differ, since the Amiga has no built
in software sprite support within its video hardware.  Although the
Amiga does have software sprite support routines within its ROM based
operating system, few programmers use these routines because they are
rather limited and inefficient.

Hardware sprites, by definition, use the Amiga hardware to generate sprite
objects.  No matter how many sophisticated routines are available to help
program hardware sprites, ultimately the actual sprites are displayed by
the same simple mechanism.  To display a hardware sprite you first create
a sprite definition in chip memory, then store a pointer to this data
definition in one of the Amiga hardware sprite channels, then you tell the
Amiga to switch on that sprite.

Because hardware sprites and software sprites are so very fundamentally
different in the way they are implemented, the programming of each of these
sprite types tends to be treated as a separate operation.

Usually, even though the requirement of moving a coloured object around
the screen may be identical in both cases, the actual program code to do
this will be totally different when using hardware and software sprites.

This situation, a result of machine hardware considerations, imposes real
constraints on the freedom and creativity of the programmer, and in many
cases it is hard to make optimum use of both types of sprite object.

HeliOS uses many "tricks" and a lot of carefully designed support code to
allow the use of software and hardware sprites in virtually identical ways.

Never before in any Amiga high level programming language have hardware
sprites been so well supported in terms of "multiplexing", animations,
programmable motion, collision detection, and general "equal status" in
general programming terms with software sprites.

Hardware sprites inevitably have some restrictions (and some advantages
of course), but HeliOS will allow you to program hardware sprite in a way
which makes them virtually interchangeable with software sprites.


******************************
Hardware Sprite "Multiplexing"
******************************

The term "multiplexing" refers to a technique whereby a particular hardware
sprite can be used for multiple different images in one display frame.

The Amiga only has 8 hardware sprites, but this apparently quite severe
limitation can be circumvented to some extent because of a "trick" which
allows you to "re-use" a hardware sprite in certain circumstances.

Hardware sprites are limited in width but unlimited in height, and once the
hardware has finished displaying a hardware sprite image in the vertical
dimension, after a wait of one raster line, the sprite channel becomes
"free" to be reused for another sprite image.

This feature means that a sprite can effectively be reused, provided its
further use places the new image in a position starting more than one raster
line below the lowest point of the earlier image.

This process can be repeated as often as required, and results in the
following general rules:

1. You can only have 8 hardware sprites in the same horizontal zone.

2. You can re-use any hardware sprite to generate multiple images provided
   that you allow one vertical pixel "gap" between the lowest point of
   a previous image and the topmost point of the new one.

As you can imagine, multiplexing can get complicated, and if you use this
technique without careful management of sprite positioning you can end
up with sprites "disappearing" or behaving in a peculiar fashion.

The HeliOS system allows you to specify a hardware sprite ID which can
can be associated with a particular sprite image.  The same image can be
allocated, if required, to several actual hardware sprite channels, and
then you can specify up to 255 different simultaneous positions for your
hardware sprite image specified by its ID.

The ID must be a NON-ZERO 8-bit number.

The HeliOS system will, fully automatically, attempt to multiplex all the
available hardware sprites which match your ID specification, and will
effectively maintain 255 hardware sprite images simultaneously on screen.

Of course, any such automatic multiplexing scheme is restricted by the fact
that on any one horizontal line only 8 sprites can co-exist.  Nevertheless,
if carefully used, this is a very powerful facility, and is particularly
useful when you want to maintain and move around many small "particle-like"
objects.

Because hardware sprites are very fast to render, you may wish to use the
HeliOS hardware sprite multiplexing facility to support "particle" systems
which consist of many small identical objects.

This is a very appropriate use for hardware sprites because:

1. Hardware sprites are fast and therefore allow a much larger number of
   small particles to be used than would a software sprite system.

2. Using identical particle imagery allocated to different hardware sprite
   channels allows the multiplexing process to be used very efficiently.

3. Using small objects (in the vertical dimension) allows more sprites
   to be re-used very often, again helping the multiplexing process.


***************************************************
Hardware Sprite colour depth and "attached sprites"
***************************************************

Standard Amiga hardware sprites are essentially limited to four colours,
one of which is transparent.

This is a fairly severe restriction, but there is a useful facility built
into the Amiga hardware whereby two sprites can be used together to form
a "combined" sprite with 16 colours.

Two sprites which are linked together to give a 16-colour sprite are called
"attached" sprites.

Of course you effectively only have 4 hardware sprites available to use as
16 coloured objects, but in spite of this restriction attached sprites do
have many uses.

To create attached sprites you must initialise two separate sets of sprite
data and tell the Amiga hardware to treat the two as one combined object.

The sprite data definition itself contains information which tells the
Amiga whether or not a sprite is "single" or one part of a double "attached
sprite".  In the latter case 2 adjacent sprite channels are linked together
to generate the 16-colour sprite, and each of these channels will contain
"half" of the sprite's colour imagery definition.

There are particular Amiga hardware requirements with respect to attached
sprites, but these are very simple and easy to comply with, as follows:

1.  Sprites can only be attached in pairs:

    Sprite 1 to Sprite 0
    Sprite 3 to Sprite 2
    Sprite 5 to Sprite 4
    Sprite 7 to Sprite 6

2.  An "attachment" flag must be set in the data definition of the ODD 
    numbered sprite of each pair, namely sprites 1, 3, 5, or 7.

Once installed, you must move attached sprites together around the screen,
and it is your responsibility to ensure that the two objects are always
correctly superimposed.

Even the simplest HeliOS hardware sprite control methods contain automatic
support to help you use attached sprites, and the higher level HeliOS
functions will allow you to automatically create and use attached sprites
as if they were single entities.


***********************
Hardware sprite colours
***********************

Hardware sprites use the Amiga colour registers numbered from 16 to 31,
in the following scheme:

Sprites 0 and 1 use colour registers 16-19
Sprites 2 and 3 use colour registers 20-23
Sprites 4 and 5 use colour registers 24-27
Sprites 6 and 7 use colour registers 28-31

Each single sprite has 4 colours, with colour 0 always transparent.

Attached sprites can be defined in 16 colours, again with colour 0 always
transparent, and in this case the full range of colour registers from 16
to 31 are used for each attached sprite.


*******************************************************
A summary of the simple use of hardware sprite channels
*******************************************************

There are 8 Amiga hardware sprite channels, each of which can display a
4-colour sprite image.

Standard sprites have only four colours, with "Colour 0" being transparent.

There are a few extra details, but basically to display a single hardware
sprite image all that is required is to install a pointer to an initialised
sprite data definition into one of the 8 Amiga hardware sprite channels and
then switch on "sprite generation" for that channel.  Each active channel
must have a pointer to a sprite data definition.

Somewhat simplistically, this procedure defines what we need to do for a
single sprite image displayed in one sprite channel, and of course we can
do the same for all the 8 sprite channels, giving us 8 hardware sprites.

We can generate 16-colour sprites, but in order to do this we need to use
two sprite channels for each sprite we display, so we can have 4 compound
"attached" 16-colour sprites using adjacent pairs of channels.  Each of the
two channels contains a pointer to a sprite data definition supplying half
of the colour imagery information.


*****************************************
A summary of hardware sprite multiplexing
*****************************************

The above scheme relates to the use of single sprite images using each of
the sprite channels to generate one image only for each video frame.  This
comparatively simple situation would not give us a very useful or powerful
hardware sprite system, since we have not yet considered any mechanism to
generate "multiplexed" sprites by repeatedly reusing sprite channels.

We know that to define multiple sprites in any channel we need to create
multiple successive instances of sprite definitions placed sequentially
in the sprite channel data block.

In order to actually display and manage multiple sprites in one channel we
need to analyse the overall situation within our display and decide which
sprite images appear higher in the display than others.  The constraint
that further sprites in any channel can only be generated after the last
vertical line of the previous sprite can be rather awkward to deal with.

A little consideration will reveal that fairly complex programming would
normally be required to manage multiple position-dependent sprite images,
and indeed the programming "overhead" to do this can be so excessive as
to make the use of multiple hardware sprites impractical except in certain
circumstances for all but very experienced programmers.

HeliOS provides a very sophisticated and fast automatic hardware sprite
multiplexing system, but even this still has to obey the all the usual
constraints imposed by the Amiga hardware.  This situation means that
you have to plan your software carefully before using the hardware sprite
multiplexing techniques available within HeliOS.

In general it is worth considering that the best and most efficient use
of multiplexing techniques can be achieved when the following simple
conditions are met:

1. All sprites defined using any one sprite channel MUST have the same
   imagery.

   - This absolute requirement allows the multiplexer to simply associate
     one image with each channel, without which its task is impossible.

2. More than one sprite channel should ideally have the same sprite imagery.

   - This allows the multiplexer to have additional "choices" when trying
     to allocate an available sprite for a particular image.

3. Sprites should ideally be kept small - especially in vertical extent.

   - This allows each channel to be reused more frequently

4. You need sufficient sprite definitions IN TOTAL, including all the
   sprite channels, to maintain the number of sprites you wish to display.

   - Because the multiplexing process often results in sprites not being
     useable because of positional constraints, more sprites need to be
     available than are really to be displayed.  This depends on the type
     of object distribution implemented, and in some cases (e.g. regularly
     expanding particle explosions) it is possible to predict exactly how
     many sprite images will be required.


**************************************
The data format for sprite definitions
**************************************

The Amiga requires hardware sprite image and position definitions to be
stored in a particular data format.  This data format can be readily found
in any Amiga reference book on the subject, and its exact definition is
not really important for the purposes of the present discussion.

A sprite data definition contains information about the screen position
of the sprite together with imagery information which defines the sprite
in terms of only 4 colours for a standard single normal sprite.

For any one sprite channel all the sprite position, imagery, and status
information is stored together in one data definition, and a pointer to
this data definition must then be supplied to the Amiga sprite generation
hardware in order to display the sprite on screen.

Attached sprites use two data definition blocks each installed in adjacent
sprite channels (see above and below for more information about this).

In any one video frame, once the sprite hardware has read the information
to display one instance of a sprite, that channel will immediately become
available to generate a new sprite image.  The sprite hardware reads the
data definition block sequentially, so if you want to display a further
sprite you must place another sprite data definition after the first one.

Each further sprite image generated by any channel must be specified by a
data definition stored immediately after the previous sprite definition in
the sprite data defintion block.

Thus, any sprite channel which is used to display several images must have
data definitions for all these images stored one after the other in a
continuous unstructured data block.  We say "unstructured" because these
definitions have no special linkage system or delimiting apparatus: they
are simple instances of ordinary sprite data definitions stored end to end
in memory.

Because HeliOS performs several extra control functions it requires a more
elaborate data structure than a standard Amiga sprite data definition, so
the HeliOS automatic hardware sprite routines actually create an extended
version of the Amiga sprite data definition block with a special "header".

It is important to understand that both HeliOS and the Amiga hardware have
sprite "channels" containing pointers to sprite definition blocks, but in
each case these definition blocks are different.  Remember that the HeliOS
sprite definition is an extended version of the standard Amiga definition,
and HeliOS handles the Amiga hardware installation for you automatically
when you "install" a HeliOS hardware sprite definition.

When you install a hardware sprite using HeliOS the Amiga hardware sprite
data definition will be supplied to the Amiga hardware automatically by the
HeliOS system, and a separate "handler" will be installed into the HeliOS
system which includes the additional information required by HeliOS.

The HeliOS system associates a unique ID with each data definition block,
and this ID is used by the multiplexing and animation systems (see below).
There are other additional "extras" within the extended HeliOS hardware
sprite definition, but for now it is only necessary to remember that HeliOS
does in fact use a special non-standard hardware sprite data definition.

                               *********
                               IMPORTANT
                               *********

  Remember that you cannot install a standard Amiga hardware sprite data
  definition into HeliOS, and you cannot install a HeliOS hardware sprite
  data structure directly into an Amiga hardware sprite channel!


******************************************
Creating sprite data definitions in HeliOS
******************************************

HeliOS has special functions which allow you to automatically create single
or multiple image  hardware sprite data definitions, ready for installation
into a sprite channel.

Since sprites always need imagery, the HeliOS sprite data creation routines
require that sprite imagery is supplied as the data definition is created.

Hardware sprite imagery can be supplied to the HeliOS sprite data definition
creation routines in various ways:

1. As a data statement within a program.

   The sprite data may be defined within the HeliOS dictionary if you wish,
   and then a special HeliOS function is used to convert the image into a
   full sprite definition in CHIP memory.

2. By "copying" the imagery from a software sprite.

   HeliOS has several special routines to do this automatically, which
   include automatic management of attached sprites.

3. By "copying" the imagery from any bitmapped imagery in memory.

   HeliOS has several special routines to do this automatically, which
   include automatic management of attached sprites.

The HeliOS hardware sprite definition routines all require you to identify
each image with an ID, and whilst it is not obligatory if you are not using
multiplexing, it is a good idea to have each unique image always associated
with a unique ID.

If you are intending to use sprite multiplexing you MUST always have each
individual different sprite image associated with its own unique ID.

The careful allocation of image IDs is important because most of the HeliOS
routines refer to hardware sprites by their IDs, and will assume that all 
sprite data definitions with a certain ID will have identical imagery.

Using its ID system HeliOS manages a sprite multiplexing scheme whereby
several channels can hold sprite data definitions with the same ID (and
imagery, hopefully!).  The HeliOS system can then check and use whatever
channel is available to display a sprite with a particular ID at a certain
place on the screen: this allows a very fluent multiplexing facility.


*************************************************************
A note on traditional "low-level" hardware sprite programming
*************************************************************

Traditionally hardware sprites have often been defined by the method of
including data statements within programs, and although this is a somewhat
clumsy technique it can sometimes be the simplest way of doing things.

HeliOS will allow you to "do-it-yourself" and program the hardware directly,
but remember that if you try to build a sprite definition block within the
HeliOS dictionary you must copy it to CHIP memory before trying to use it.

Although HeliOS provides full support for handling hardware sprites in
the "traditional" manner by manually programming the data within sprite
definition blocks, this method is not recommended.  Especially when using
attached sprites, manual hardware sprite programming is very clumsy indeed
when compared with the more sophisticated tools which HeliOS provides.

However, if you really do want, or need, to program hardware sprites the 
hard way, HeliOS will allow you to do so, and even help you a little by 
managing as much of the tedious work as possible for you automatically.  
With this in mind, HeliOS provides one or two simple tools to help make
low-level hardware sprite programming easier.

HeliOS has special functions which allow you to define sprite imagery
within the HeliOS dictionary and then convert this imagery into a full
sprite definition block in CHIP memory.

HeliOS also provides simple tools for the installation and removal of
hardware sprites, and for positioning sprites on screen, along with a
simple method of controlling 16-colour attached sprites.

Remember that in this section we are describing methods which involve
very low level use of the Amiga hardware and you should read more about
Amiga hardware sprite programming if you intend to use these techniques.


**********************
Background information
**********************

This document will assume that you are familiar with most general Amiga
hardware sprite concepts and will not go into extreme low-level detail.

You can easily use the HeliOS automated functions to program hardware
sprites without detailed knowledge of the Amiga sprite hardware, but some
of the details given in the discussion below will probably not be fully
comprehensible unless you do have some degree of in-depth knowledge.

It would certainly be worthwhile to augment the information given below
with further study of this subject in the Amiga ROM Kernel manuals or
some other similar detailed text.


***********************************************************
An overview of hardware sprite functions provided by HeliOS
***********************************************************

HeliOS provides many facilities for programming hardware sprites, and these
vary from simple Amiga hardware interface routines to a sophisticated fully
automatic hardware sprite animation handler.

Those who are already familiar with Amiga hardware sprite programming will
probably feel quite at home with the simple HeliOS commands which allow you
to define and control sprites using data definition structures which are
installed directly into the Amiga sprite handling hardware.

Although this technique can be used for simple applications it is rather
tedious to program and very limited in power.  HeliOS also provides another
level of software which gives hardware sprites the same functionality as
software sprites and provides the most powerful multiplexing capacity yet
available in any Amiga programing language.

Here, in approximate order of sophistication, is a list of the facilities
provided by HeliOS for the definition and control of hardware sprites.

1.  Automatic creation of sprite data definitions from data statements.

2.  Simple installation and maintenance.

3.  Automatic HSprite creation from bitmapped imagery or software sprites.

4.  Easy installation and control of automatic hardware sprites

5.  Automatic multiplexing.

6.  Easy control of multi-colour "attached" sprites.

7.  Pixel perfect bitmapped "shadowmask" collision detection between any
    combination of hardware and software sprites and display background.

8.  Complex motion controls which are exactly equivalent to software sprite
    controls, including zone-detection, auto-wrap, auto-acceleration etc.

9.  Fully automated animation facilities exactly equivalent to software
    sprite animation routines.

10. Easy switching between software and hardware sprites for same object.

11. Sophisticated path generation functions to support complex dynamics
    with multi-hardware-sprite "particle" systems.

12. Switchable motion "relativity" so that position can be specified with
    respect to visible screen display or full bitmapped playfield.

13. Dual status system allowing simple "manual" operation with low system
    overhead or complete automatic complex motion system with full software
    sprite equivalent capability.

These topics will be described in detail in the text below.


******************************************************************
Creation of sprite data definitions from HSImage data structures
******************************************************************

---------------------------------------------------------------------
Defining hardware sprite imagery as a data statement within a program
---------------------------------------------------------------------

HeliOS has a simple data structure which it uses to define a hardware
sprite image in terms of a program data statement.

There is no specific HeliOS include file symbolic name for this structure
but in the HeliOS documentation we refer to it as an "HSImage".

The HSImage structure format is as follows:

The 1st data word = Image width in pixels
The 2nd data word = Image height in pixels

These two words are followed by Depth*Width/4 bytes defining the image in
the usual Amiga hardware sprite image format with each row of the image
defined by two successively stored single colour-bit representations.

Two zero bits always indicate a transparent pixel.

Here is a coded example:

CREATEL MyHSImage

16 ,                \ Width
5  ,                \ Height

BIN

0000111111110000 , \ Row 1 first colour definition bits
0000111111110000 , \ Row 1 second colour definition bits

0000110000110000 , \ Row 2 first colour definition bits
0000110000110000 , \ Row 2 second colour definition bits

0000100110010000 , \ Row 3 first colour definition bits
1110100000010111 , \ Row 3 second colour definition bits

0000110000110000 , \ Row 4 first colour definition bits
0000110000110000 , \ Row 4 second colour definition bits

0000111111110000 , \ Row 5 first colour definition bits
0000111111110000 , \ Row 5 second colour definition bits

DECIMAL

The above data would give an image looking something like this:

        ********
        **    **
    xxx *  oo  * xxx
        **    **
        ********

The HSImage structure does not itself have to be in CHIP memory because
it still has to be converted into a full sprite definition and the command
which does this will always build the full sprite definition in CHIP memory.

-------------------------------------------------------------------
Automatic creation of HSImage sprite definitions
-------------------------------------------------------------------

HeliOS provides simple methods of generating "HSImage" structures from
existing bitmapped sprite graphics.

Using the functions outlined below you can "clone" a software sprite
image into a hardware sprite HSImage or even a pair of HSImages for
use as attached hardware sprites.

COPYHSPRITE

( SpriteCtrl(l) - - -  HSImage(l) )

Generates a single HSImage structure from a software sprite,

N.B.

This routine ALWAYS assumes, and uses, 2 bitplanes from the source
software sprite bitmap structure.  You MUST supply a sprite with at 
least 2 bitplanes or your output imagery will be corrupt.

COPYATTHSPRITE

( SpriteCtrl(l) - - - HSImage(l), HSImage(l) )

Generates a pair of HSImage structures, for use as an "attached"
hardware sprite, from a software sprite.

N.B.

This routine ALWAYS assumes, and uses, four bitplanes from the
source software sprite bitmap structure.  You MUST supply a sprite
with at least 4 bitplanes or your output imagery will be corrupt.

-------------------------------------------------------------------
Generating hardware sprite definitions from HSImage data structures
-------------------------------------------------------------------

Once we have created a hardware sprite image as above, we can use it to
generate a data definition block using the MAKEHSPRITEBLOCK function, which
automatically creates single or multiple definitions for the same image:

MAKEHSPRITEBLOCK

( ImageID(w), NumberOfSpriteDefinitions(w), HSImage(l) - - - HSpriteBlock(l) )

  Makes an HSpriteBlock image block with:

  ImageID = Unique ID for this image
  Images# = Number of hardware sprite imagery/ctrl sections.

  The number of image/ctrl sections (Images#) can be up to 255, and
  the ImageID can be any non-zero number.

  The imagery and dimensions of the hardware sprite are taken from the
  HSImage data definition.

  Each HSpriteBlock with a different image should have a different ID, but
  you can have several HSpriteBlocks with the same ID if you wish.  HeliOS
  will try to allocate an HSpriteBlock for use when multiplexing hardware
  sprites according to a specific ID.  If you have 4 HSpriteBlocks with
  identical IDs and imagery you will be able to have 4 sprites on the same
  horizontal line.  If you have only 1 HSpriteBlock for a given image/ID,
  the sprite will only be able to appear in multiple vertical positions
  according to how many image/ctrl sections it has.

  The HSpriteBlock should be freed when no longer required by using the
  FREEHSPRITEBLOCK command.


Notice here that we supply an ID and have the possiblity of generating
multiple instances of the sprite so that we can have several vertical
repetitions of the image.  The number of sprite definitions which we
create will determine how many multiple instances of that sprite image
we can generate on screen simultaneously.

Remember that an ID should uniquely specify a particular image, and should
be a non-zero number in the range 1-255.

The HSpriteBlock structure generated by MAKEHSPRITEBLOCK consists of an
Amiga sprite data definition block with a special HeliOS header containing
extra information such as the ID, image size etc.

---------------------------------
The HSpriteBlock header structure
---------------------------------

Here is the format of the HeliOS HSpriteBlock header:

   STRUCTURE HSB,0

   APTR    HSB_Img
   BYTE    HSB_Id
   BYTE    HSB_TotImgs
   BYTE    HSB_ThisImgN
   BYTE    HSB_LastVPos
   WORD    HSB_ImgDepth
   WORD    HSB_ImgSize
   APTR    HSB_ThisImage
   APTR    HSB_SCtrl

   LABEL   HSB_SIZEOF

We include this definition for the sake of completeness, but please do not
attempt to program this structure directly.

-----------------------------------------
Installing HeliOS simple hardware sprites
-----------------------------------------

A sprite definition block can be installed into the HeliOS hardware sprite
driver using the command HSPRITE_INSTALL, which has the definition:

  HSPRITE_INSTALL

  ( HSpriteBlock(l), Channel(w) - - - )

  Installs an HSpriteBlock imagery/ctrl block into one of the 8 hardware
  sprite channels (Channel = 0-7).


----------------------
Setting sprite colours
----------------------

At, or before, the stage of sprite installation you might wish to set up
the hardware colour registers for the sprites you are using.

To do this you could use the function SETSLICECOLOURS as specified below:

  SETSLICECOLOURS

  ( Slice(l), ColourTable(l), Start(w), Count(w) - - - )

  Sets a sequence of "Count" colour values into the colour registers
  for "Slice", starting at colour number "Start".

  The colours are read sequentially from the start of a "ColourTable"
  which consists of a series of 12-bit RGB values stored in sequential
  16-bit cells in the standard Amiga fashion.

For example, to set colours 16 to 31, you might use the following code:

CREATEL MySpriteColourTable

HEX

0000 ,  \ Colour 16
0FFF ,  \ Colour 17
0AAA ,  \ Colour 18
0666 ,  \ Colour 19
0000 ,  \ Colour 20
000F ,  \ Colour 21
00F0 ,  \ Colour 22
0F00 ,  \ Colour 23
0000 ,  \ Colour 24
0004 ,  \ Colour 25
0040 ,  \ Colour 26
0400 ,  \ Colour 27
0000 ,  \ Colour 28
0008 ,  \ Colour 29
0080 ,  \ Colour 30
0800 ,  \ Colour 31

MySpriteSlice MySpriteColourTable 16 16 SETSLICECOLOURS

---------------------------------------
Removing HeliOS simple hardware sprites
---------------------------------------

When you finally wish to remove the hardware sprites, HeliOS has a simple
command to do this:

  HSPRITE_REMOVE

  ( HSpriteBlock(l) - - - )

  Removes an HSpriteBlock imagery/ctrl block from its installation in one
  of the 8 hardware sprite channels.


-------------------------------------------------------------
A few problems with controlling simple Amiga hardware sprites
-------------------------------------------------------------

The methods explained above may seem easy, but this way of maintaining
a hardware sprite is the most primitive of the several options available
within HeliOS, and has many disadvantages which we need to consider.

These disadvantages generally lie in the control and placement of the
hardware sprite once it has been installed.

This section will list some of the potential difficulties and explain how
using another simple HeliOS commands can help make things easier.

Here are a few of the difficulties of low-level hardware sprite control:

----------------------------
Controlling attached sprites
----------------------------

One of the main disadantages of the simple manual method of using hardware
sprites is the trouble involved with maintaining 16-colour attached sprites
using this method rather than the special automatic HeliOS routines.

As you will see later, HeliOS has methods of automatically creating and
controlling multi-colour attached sprites, but the crude method being
described here would merely create simple image data blocks.

If you want to create a multi-colour attached sprite pair using low-level
control techniques you have to define the image data for each one of the
sprite pair using data statements as above for two separate data blocks.

You then need to install the two data blocks into two adjacent channels,
and then you need to manually set up sprite data headers with positional
data and control bits to tell the Amiga that these two sprites are attached
and where to place them on screen.

All the above can indeed be done, if you wish, and this is the way you
would NEED to do things if you did not have the more sophisticated HeliOS
functions to be described later.  In fact this is the "traditional" way of
handling hardware sprites and many programmers may be thinking "So what?
Why not just do it like this?".  The answer is simply that HeliOS has much
better ways of handling hardware sprites than this, but we include support
functions to help anyone who really needs to use "low-level" methods.

----------------------------
Attached sprite status flags
----------------------------

To use attached sprites by direct programming of sprite data definitions
you need to simultaneously store positional information as well as special
attachment "flags" into your sprite data structures, and you also need to
manually maintain the two sprites in a fully superimposed position.

-----------------------
Setting VStop positions
-----------------------

If you already know about Amiga hardware sprites you may recall that you
need to specify the vertical stop position for the sprite as a parameter
within the sprite control data.  This is a programming chore dictated by
the way the Amiga reads hardware sprite data, and is required whenever
you place any sprite image on screen.

--------------------------------
Sprite/screen coordinate offsets
--------------------------------

As far as the Amiga hardware is concerned it is always necessary to specify
position coordinates in terms of offsets from an Amiga hardware screen
origin which is not the same as the visible screen origin.  This involves
another stage of programming to convert sprite coordinates before setting
up the sprite data.

------------------------------------------------------------
Combining positional and status information into sprite data
------------------------------------------------------------

Hardware sprite control information has to be computed by fairly complicated
methods, such as:

 a. Adding a special hardware "offset" to the screen coordinates required

 b. Calculating the sprite vertical stop position information

 c. Setting (if required) the attach flag bit

 d. Encoding all this information into a special format

 e. Finding the control data address of a specific sprite definition

 f. Writing the pre-prepared information

 g. Doing this for every sprite, every frame (twice for attached sprites!)

----------------------------------------------------------
HeliOS help with controlling simple Amiga hardware sprites
----------------------------------------------------------

HeliOS can use the information stored in HeliOS extended sprite definition
blocks to calculate and to set up most data parameters for you: all you
have to do is supply simple screen-relative "X" and "Y" coordinates and
specify whether or not the sprite is to be attached.

In the case of attached sprites you still need to specify sprite control
information for two separate sprite channels, but at least much of the
work is done for you automatically.

There is an easy HeliOS command, called "HSPRITE_PLACE", to help you set
up the control data section of any individual hardware sprite image within
a multiple image block.

                               *********
                               Important
                               *********

  Remember that this sprite control word only works for sprites installed
  with extended HeliOS sprite definitions and not simple Amiga hardware
  channel sprite definitions.

Here is the definition of this useful function:

  HSPRITE_PLACE

  ( AttachFlag(w), XPos(w), YPos(w), Image#(w), HSpriteBlock(l) - - - )

  Places a hardware sprite image on screen, using the Image# numbered
  image of the HSpriteBlock sprite set.

  The Image# parameter starts from 0 (= first image) etc.

  The "AttachFlag" parameter allows you to specify whether or not HeliOS
  should set the sprite's attach bit for you.  Remember that you only need
  set the attachment flag in ODD numbered sprites.

  The "X" and "Y" coordinates are specified from pixel "0,0" at the top
  left hand corner of the visible screen display.

Having placed your hardware sprites on screen initially you can move them
around using repeated HSPRITE_PLACE commands for as long as you like.

-----------------------------------------------
Using multiple images generated from one sprite
-----------------------------------------------

Remember that these simple techniques do not have any automatic support
for multiplexing, and it is up to you to ensure that sprites are correctly
positioned.

If you are not careful when using multiple sprites in "free" motion you
can get periodic overlapped sprite positioning which can lead to flickering
or disappearing sprites.

In general it is best to only use this method for simple single sprites or
sprites with easily calculated regular motion.


----------------------------------------------------------------------
A summary of simple methods of hardware sprite generation using HeliOS
----------------------------------------------------------------------

1. Create an HSImage definition

2. Create an HSpriteBlock structure using MAKEHSPRITEBLOCK

3. Set up sprite colour registers (16-31)

4. Install the HSpriteBlock structure using HSPRITE_INSTALL

5. Control the sprite using HSPRITE_PLACE

6. Remove the HSpriteBlock structure using HSPRITE_REMOVE

7. Remember that you can define multiple images using an HSpriteBlock
   structure, and you can place several images on screen using the same
   channel, provided that:

   a. The sprites are vertically separated by at least one raster line

   b. There are sufficient multiple individual sprite definitions within
      the HSpriteBlock structure.

*******************
Example source code
*******************

In the HeliOS "Source" directory there is source code for two simple
example programs which demonstrate the above low-level sprite techniques.


The first program is called "SimpleHSprite.src".

This program generates a simple single hardware sprite


The second program is called "SimpleAttHSprite.src".

This program generates a simple attached hardware sprite


The main sprite generation code from the first example is repeated here,
followed by a similar extract from the second example:


  \ ****************************
  \ Create hardware sprite image
  \ ****************************

  \ This image uses the standard Amiga hardware sprite convention with
  \ respect to the way bits are interpreted as colour information.

  CREATEL MyHSImage

  16 ,                   \ Width
  5  ,                   \ Height

  BIN

  0000111111110000 ,     \ Row 1 first colour definition bits
  0000111111110000 ,     \ Row 1 second colour definition bits

  0000110000110000 ,     \ Row 2 first colour definition bits
  0000110000110000 ,     \ Row 2 second colour definition bits

  0000100110010000 ,     \ Row 3 first colour definition bits
  1110100000010111 ,     \ Row 3 second colour definition bits

  0000110000110000 ,     \ Row 4 first colour definition bits
  0000110000110000 ,     \ Row 4 second colour definition bits

  0000111111110000 ,     \ Row 5 first colour definition bits
  0000111111110000 ,     \ Row 5 second colour definition bits

  DECIMAL

  \ ***********************************
  \ Create hardware sprite colour table
  \ ***********************************

  \ This colour table simply specifies a few arbitrary colours which we
  \ will then set into colour registers 16 to 31

  CREATEL MySpriteColourTable

  HEX

  0000 ,  \ Colour 16
  0FFF ,  \ Colour 17
  0AA0 ,  \ Colour 18
  000F ,  \ Colour 19
  0000 ,  \ Colour 20
  000F ,  \ Colour 21
  00F0 ,  \ Colour 22
  0F00 ,  \ Colour 23
  0000 ,  \ Colour 24
  0004 ,  \ Colour 25
  0040 ,  \ Colour 26
  0400 ,  \ Colour 27
  0000 ,  \ Colour 28
  0008 ,  \ Colour 29
  0080 ,  \ Colour 30
  0800 ,  \ Colour 31

  DECIMAL

  \ ************************
  \ Allocate a pointer store
  \ ************************

  0. DPOINTER  MyHSpriteBlock

  \ **********************
  \ Set up hardware sprite
  \ **********************

  \ First we set sprite colours 16 to 31
  \ Then we create a hardware sprite definition block
  \ Then we install the hardware sprite

  : SetupHSprite

  Slice1 MySpriteColourTable 16 16 SETSLICECOLOURS

  1 1 MyHSImage MAKEHSPRITEBLOCK MyHSpriteBlock MAKEPOINTER

  MyHSpriteBlock 1 HSPRITE_INSTALL
  ;

  \ **************************
  \ Close down hardware sprite
  \ **************************

  \ First we remove the hardware sprite
  \ Then we de-allocate the sprite definition

  : CloseHSprite

  MyHSpriteBlock HSPRITE_REMOVE

  MyHSpriteBlock  DDUP FREEHSPRITEBLOCK  CLEARPOINTER
  ;

  \ ********************************
  \ Display and move hardware sprite
  \ ********************************

  \ Switch on mouse position reporting
  \ Switch off the HeliOS mouse pointer image
  \ Repeatedly set the sprite to the current mouse pointer position

  : TestHSprite

  1 REPORTMOUSE
  0 HELIOSMPOINTER

  BEGIN
    0 MOUSEX MOUSEY 0 MyHSpriteBlock HSPRITE_PLACE
    ?TERMINAL 32 =
  UNTIL
  ;

 \ **************
 \ End of example
 \ **************

---------------------------------------------------------------------

The main sprite generation code from the second example, using attached
sprite techniques is repeated here:

  \ **************************************
  \ Create attached hardware sprite images
  \ **************************************

  \ These images use the standard Amiga hardware sprite convention with
  \ respect to the way bits are interpreted as colour information.

  \ Note that we need two image definitions for an attached sprite

  CREATEL MyHSImage1

  16 ,                   \ Width
  5  ,                   \ Height

  BIN

  0000111111110000 ,     \ Row 1 first colour definition bits
  0000111111110000 ,     \ Row 1 second colour definition bits

  0000110000110000 ,     \ Row 2 first colour definition bits
  0000110000110000 ,     \ Row 2 second colour definition bits

  0000100110010000 ,     \ Row 3 first colour definition bits
  1110100000010111 ,     \ Row 3 second colour definition bits

  0000110000110000 ,     \ Row 4 first colour definition bits
  0000110000110000 ,     \ Row 4 second colour definition bits

  0000111111110000 ,     \ Row 5 first colour definition bits
  0000111111110000 ,     \ Row 5 second colour definition bits

  DECIMAL

  CREATEL MyHSImage2

  16 ,                   \ Width
  5  ,                   \ Height

  BIN

  1110111111110111 ,     \ Row 1 first colour definition bits
  0000110000110000 ,     \ Row 1 second colour definition bits

  0000110000110000 ,     \ Row 2 first colour definition bits
  0000110000110000 ,     \ Row 2 second colour definition bits

  0000100110010000 ,     \ Row 3 first colour definition bits
  1110100000010111 ,     \ Row 3 second colour definition bits

  0000110000110000 ,     \ Row 4 first colour definition bits
  0000110000110000 ,     \ Row 4 second colour definition bits

  0000110000110000 ,     \ Row 5 first colour definition bits
  1110111111110111 ,     \ Row 5 second colour definition bits

  DECIMAL

  \ ***********************************
  \ Create hardware sprite colour table
  \ ***********************************

  \ This colour table simply specifies a few arbitrary colours which we
  \ will then set into colour registers 16 to 31

  CREATEL MySpriteColourTable

  HEX

  0000 ,  \ Colour 16
  0FFF ,  \ Colour 17
  0AA0 ,  \ Colour 18
  000F ,  \ Colour 19
  0F0F ,  \ Colour 20
  000F ,  \ Colour 21
  00F0 ,  \ Colour 22
  0F00 ,  \ Colour 23
  00FF ,  \ Colour 24
  0004 ,  \ Colour 25
  0040 ,  \ Colour 26
  0400 ,  \ Colour 27
  00F0 ,  \ Colour 28
  0008 ,  \ Colour 29
  0080 ,  \ Colour 30
  0800 ,  \ Colour 31

  DECIMAL

  \ ***************************
  \ Allocate two pointer stores
  \ ***************************

  0. DPOINTER  MyHSpriteBlock1
  0. DPOINTER  MyHSpriteBlock2

  \ **********************
  \ Set up hardware sprite
  \ **********************

  \ First we set sprite colours 16 to 31
  \ Then we create two hardware sprite definition blocks
  \ Then we install the two hardware sprite definitions

  : SetupHSprite

  Slice1 MySpriteColourTable 16 16 SETSLICECOLOURS

  1 1 MyHSImage1 MAKEHSPRITEBLOCK MyHSpriteBlock1 MAKEPOINTER
  1 1 MyHSImage2 MAKEHSPRITEBLOCK MyHSpriteBlock2 MAKEPOINTER

  MyHSpriteBlock1 0 HSPRITE_INSTALL
  MyHSpriteBlock2 1 HSPRITE_INSTALL
  ;

  \ **************************
  \ Close down hardware sprite
  \ **************************

  \ First we remove the hardware sprite
  \ Then we de-allocate the sprite definition

  : CloseHSprite

  MyHSpriteBlock1 HSPRITE_REMOVE
  MyHSpriteBlock2 HSPRITE_REMOVE

  MyHSpriteBlock2  DDUP FREEHSPRITEBLOCK  CLEARPOINTER
  MyHSpriteBlock1  DDUP FREEHSPRITEBLOCK  CLEARPOINTER
  ;

  \ ********************************
  \ Display and move hardware sprite
  \ ********************************

  \ Switch on mouse position reporting
  \ Switch off the HeliOS mouse pointer image
  \ Repeatedly set the sprite to the current mouse pointer position

  : TestHSprite

  1 REPORTMOUSE
  0 HELIOSMPOINTER

  BEGIN
    0 MOUSEX MOUSEY 0 MyHSpriteBlock1 HSPRITE_PLACE
    1 MOUSEX MOUSEY 0 MyHSpriteBlock2 HSPRITE_PLACE
    ?TERMINAL 32 =
  UNTIL
  ;

 \ **************
 \ End of example
 \ **************

---------------------------------------------------------------------------

***************************************************
Simple hardware sprite installation and maintenance
***************************************************

As we have seen above, HeliOS has a very simple method of installation and
removal for hardware sprites using HSPRITE_INSTALL and HSPRITE_REMOVE.

These two convenient functions assume that you have created special HeliOS
sprite definition blocks, and they are the fundamental method by which
HeliOS handles ALL hardware sprites installed for use with any HeliOS
hardware sprite control routine.

Once you have installed a sprite into the HeliOS system, you can handle its
motion and general dynamics either using the low level functions described
above, or the more sophisticated functions described later.

Whatever your subsequant plans for handling the sprite, the fundamental
installation and removal process is the same: you merely use the simple
HSPRITE_INSTALL and HSPRITE_REMOVE functions.

Once you have installed a HeliOS hardware sprite definition you can use a
variety of methods to maintain the image on screen, either as a single
object or an animation.

As you have seen above, even the "messy" low-level HeliOS hardware sprite
control functions are very easy to use, and the more sophisticated routines
which handle automatic motion, animation etc. are also very easy to learn
because they are exactly like the HeliOS software animation functions.

Later in this document we will describe how to use the more sophisticated
HeliOS hardware sprite functions, but for now we will simply mention the
fact that ALL methods of using hardware sprites via the HeliOS internal
routines are much easier than programming the hardware directly yourself.

If you intend to use the Amiga hardware functions at a low level and you
want to program the hardware directly for yourself, you must do EVERYTHING
yourself, including sprite installation and removal.

We will assume that you are intending to install hardware sprites using the
HeliOS system functions, and next we will discuss some new slightly more
sophisticated methods for creating HeliOS hardware sprite definitions.


*********************************************************************
Automatic HSprite creation from bitmapped imagery or software sprites
*********************************************************************

HeliOS has specialised functions which allow the creation of a hardware 
sprite definition block directly from bitmapped imagery in one very easy
automatic process.

The bitmapped imagery must be supplied in the form of a bitmap structure
in memory, and for standard sprites the imagery should be in 4 colours if
you require colour-correct image mapping.

HeliOS also provides easy routines whereby IFF ILBM picture files can be
loaded into memory as bitmaps ready for use, and using these techniques it
is a simple matter to load and convert any bitmapped graphic image into a
hardware sprite.

HeliOS also provides routines which can perform the above operation with
16 colour imagery: these routines will automatically create two sprite data
definitions fully prepared for use as attached sprites.

There is also a set of HeliOS functions which can take a HeliOS software
sprite and use it as a generative imagery pattern for a hardware sprite.
Using these routines you can very easily "clone" a software sprite as a
hardware sprite if required and once again attached sprites can be created
automatically.

Here are definitions of the HeliOS routines relating to the creation of
hardware sprite definition blocks from bitmapped imagery:

-------------------------------------------------------------------
Creating a single hardware sprite definition from bitmapped imagery
-------------------------------------------------------------------

MAKEHSPRITEBLOCK_BMAP

( ImageID(w), NumberOfSpriteDefinitions(w),
  BMap (l), XStart(w), YStart(w), Width(w), Height(w)
   - - - HSpriteBlock(l) )

Where:    XStart = Top left corner horizontal pixel offset of image start
          YStart = Top left corner vertical pixel offset of image start
          Width  = Pixel width of image
          Height = Pixel height of image

This function reads imagery from any bitmap and creates a hardware sprite
definition.  Ideally the bitmap should be of 2-bitplanes depth (4-colours)
but the function will automatically handle other bitmap depths, albeit with
colours mapped to a standard 4-colour hardware sprite specification.

The result will be null if the function fails.

Here is a fragment of code which uses MAKEHSPRITEBLOCK_BMAP to create a
hardware sprite definition from an IFF ILBM file.

  CREATEL MYFILE $ HeliOS:Source/Data/4ColourHSTestBrush$

  \ MAKEHSPRITE  - - - HSpriteBlock(l) or null for failure

  : MAKEHSPRITE

  MYFILE  2 3 DOSLIB
  2 =
  IF
    1 1  DOVER  5 5 9 9 MAKEHSPRITEBLOCK_BMAP
    DSWAP CLOSEBMAP
  ELSE
    0.
  THEN
  ;

----------------------------------------------------------------------
Creating an attached hardware sprite definition from bitmapped imagery
----------------------------------------------------------------------

MAKEATTHSPRITEBLOCK_BMAP

( ImageID1(w), ImageID2(w), NumberOfSpriteDefinitions(w),
  BMap (l), XStart(w), YStart(w), Width(w), Height(w)
  - - - HSpriteBlock1(l), HSpriteBlock2(l) )

Where:    XStart = Top left corner horizontal pixel offset of image start
          YStart = Top left corner vertical pixel offset of image start
          Width  = Pixel width of image
          Height = Pixel height of image

This function reads imagery from any bitmap and creates a pair of attached
hardware sprite definitions.  Ideally the bitmap should be of 4-bitplanes
depth (16-colours) but the function will automatically handle other bitmap
depths, albeit with colours mapped to a standard 16-colour attached hardware
sprite specification.

The results will both be null if the function fails.

Here is a fragment of code which uses MAKEATTHSPRITEBLOCK_BMAP to create a
pair of attached hardware sprite definition blocks from an IFF ILBM file.

  CREATEL MYFILE $ HeliOS:Source/Data/16ColourHSTestBrush$

  \ MAKEATTHSPRITE  ( - - - HSpriteBlock1(l), HSpriteBlock2(l) )
  \                         or two 32-bit nulls for failure

  : MAKEATTHSPRITE

  MYFILE  2 3 DOSLIB
  2 =
  IF
    D>R                       \ Save BitMap pointer
    1 2                       \ IDs
    1                         \ Number of images
    DI                        \ BitMap
    5 5                       \ X and Y offsets
    9 9                       \ Width and height
    MAKEATTHSPRITEBLOCK_BMAP  \ Make HSprite definition blocks
    DR> CLOSEBMAP             \ Restore BitMap pointer and close BitMap
  ELSE
    0.
    0.
  THEN
  ;

*******************
Example source code
*******************

In the HeliOS "Source" directory there is source code for two simple
example programs which demonstrate the above methods of creating hardware
sprites from bitmapped imagery.


The first program is called "SimpleHSpriteFromIFF.src".

This program generates a simple single hardware sprite from a bitmapped
image created from an automatically loaded IFF file.


The second program is called "AttachedHSpriteFromIFF.src".

This program generates a simple attached hardware sprite from a bitmapped
image created from an automatically loaded IFF file.

-------------------------------------------------------------------------

Here are definitions of the HeliOS routines relating to the creation of
hardware sprite definition blocks from existing software sprites:

-------------------------------------------------------------------
Creating a single hardware sprite definition from a software sprite
-------------------------------------------------------------------

MAKEHSPRITEBLOCK_SCTL

( ImageID(w), NumberOfSpriteDefinitions(w), SpriteCtrl(l)
   - - - HSpriteBlock(l) )

This function clones the imagery from any software sprite and creates a
hardware sprite definition.  Ideally the software sprite bitmap should be
of 2-bitplanes depth (4-colours) but the function will automatically handle
other bitmap depths, albeit with colours mapped to a standard 4-colour
hardware sprite specification.

The result will be null if the function fails.

Here is a fragment of code which uses MAKEHSPRITEBLOCK_SCTL to create a
hardware sprite definition from a software sprite.


  \ MAKEHSPRITE  - - - HSpriteBlock(l) or null for failure

  : MAKEHSPRITE

    1 1  MySpriteCtrl MAKEHSPRITEBLOCK_SCTL
  ;

----------------------------------------------------------------------
Creating an attached hardware sprite definition from a software sprite
----------------------------------------------------------------------

MAKEATTHSPRITEBLOCK_SCTL

( ImageID1(w), ImageID2(w), NumberOfSpriteDefinitions(w), SpriteCtrl(l)
  - - - HSpriteBlock1(l), HSpriteBlock2(l) )

This function clones the imagery from any software sprite and creates a
pair of attached hardware sprite definitions.  Ideally the sprite bitmap
should be 4-bitplanes deep (16-colours) but the function will automatically
handle other bitmap depths, albeit with colours mapped to a standard
16-colour attached hardware sprite specification.

The results will both be null if the function fails.

Here is a fragment of code which uses MAKEATTHSPRITEBLOCK_SCTL to create a
pair of attached hardware sprite definition blocks from a software sprite.


  \ MAKEATTHSPRITE  ( - - - HSpriteBlock1(l), HSpriteBlock2(l) )
  \                         or two 32-bit nulls for failure

  : MAKEATTHSPRITE

    1 2                       \ IDs
    1                         \ Number of images
    MySpriteCtrl              \ SpriteCtrl
    MAKEATTHSPRITEBLOCK_SCTL  \ Make HSprite definition blocks
  ;

*******************
Example source code
*******************

In the HeliOS "Source" directory there is source code for two simple
example programs which demonstrate the above methods of creating hardware
sprites automatically by "cloning" software sprite imagery.


The first program is called "SimpleHSpriteFromSCtrl.src".

This program generates a simple single hardware sprite from a bitmapped
image derived from a software sprite control structure.


The second program is called "AttachedHSpriteFromSCtrl.src".

This program generates a simple attached hardware sprite from a bitmapped
image derived from a software sprite control structure.

-------------------------------------------------------------------------

--------------------------------------------------------
Creating special auto-controlled HeliOS hardware sprites
--------------------------------------------------------

We have described above methods for handling hardware sprites in a simple
manner by manual positional placement and without taking account of any
special motion controls or collision detection etc..

However, HeliOS has many functions which allow control of hardware sprites
in a manner exactly like the control of HeliOS software sprites, including
pixel perfect collision detection via bitmapped collision masks.

To enable software and hardware sprites to be as functionally similar as 
possible HeliOS uses the same control structure (the "SpriteCtrl" structure)
to control both types of object.

All sophisticated HeliOS hardware sprite functions use a "SpriteCtrl"
structure associated with each hardware sprite, and this structure is
programmable in virtually exactly the same way as it is used for software
sprites (please see the "SoftwareSprites.doc" file for more information).

We refer to these special extended hardware sprites as "AutoHSprites".

Later in this document we will consider the ways in which the extended
HeliOS hardware sprite functions can be used, but for now we are merely
concerned with methods of hardware sprite creation which facilitate the
use of the extended HeliOS control functions.

When we create special controlled HeliOS hardware sprites we need to
generate hardware sprite definitions along with associated (and linked)
"SpriteCtrl" structures.  This can be done easily using one of several
special HeliOS "AutoHSprite" creation functions.

--------------------------------------------
Using multiple self-similar hardware sprites
--------------------------------------------

The mechanism by which the hardware sprites and the SpriteCtrl structures
are associated is via their ID numbers.  This use of IDs allows HeliOS
to operate a powerful multiplexing facility whereby multiple (up to 255)
copies of identical hardware sprite images can be simultaneously presented
on screen.

Much of the system explained below is best suited for use with multiple
identical images, as in particle systems.

Any particular "image" is given a unique ID, and can have several sets of
hardware sprite definitions installed in different hardware sprite channels.

This means that multiple copies of this "ID image" can be generated by the
hardware sprite system, but all these copies are merely "logical" entities
generated by the multiplexing process.

The actual HeliOS "AutoHSprite" objects associated with a given ID are real
instances of SpriteCtrl structures, each of which generates its image by
"asking" the hardware sprite system to multiplex an image corresponding
to its ID displayed in the appropriate position.

The actual hardware sprite definition or channel which generates any single
image is totally irrelevant to an AutoHSprite, which merely requests any
available channel to provide an appropriate "ID image" at a certain place.

When we are creating AutoHSprites we need to consider how many hardware
"images" we might need altogether (taking into account whether we are going
to need multiple images on one horizontal line) and also how many "real"
AutoHSprite objects we are wishing to create and manipulate.

The general philosophy for creating multiple similar AutoHSprites is:

1. Create and fully initialise a software sprite as a "master" image.

2. Decide on how many real AutoHSprite objects you want to use.

3. Decide on maximum simultaneous horizontal and vertical display useage,
   based on what type of motion pattern is to be used and the size of the
   objects.

4. Allocate (more than!) sufficient hardware sprite definitions to generate
   the maximum estimated number of simultaneous images.

5. Allocate the special SpriteCtrl structures which you will use to control
   your new AutoHSprites: you need only as many of these as the maximum
   number of the sprites to be seen on screen at any one time.

---------------------
Creating AutoHSprites
---------------------

Here are definitions of the HeliOS routines relating to the creation of
hardware sprite definition blocks associated with a predefined and fully
initialised software sprite control structure:

-------------------------------------------------------------------
Creating a single hardware sprite associated with a software sprite
-------------------------------------------------------------------

MAKEAUTOHSPRITEBLOCK

( ImageID(w), NumberOfSpriteDefinitions(w), SpriteCtrl(l)
  - - - HSpriteBlock(l) )

  Makes an HSpriteBlock with:

  ImageID = Unique ID for this image
  Images# = Number of hardware sprite imagery/ctrl sections.

  The hardware and software sprites are given mutual pointers within their
  structures which are used internally by some of the HeliOS AutoHSprite
  functions.

  The "parent" SpriteCtrl structure should be initialised before calling
  this function.

  The imagery and dimensions of the hardware sprite are taken from
  the SpriteControl structure.

  The number of image/ctrl sections (Images#) can be up to 255, and
  the ImageID can be any non-zero number.

  Each HSpriteBlock with a different image should have a different ID, but
  you can have several HSpriteBlocks with the same ID if you wish.  HeliOS
  will try to allocate an HSpriteBlock for use when multiplexing hardware
  sprites according to a specific ID.  If you have 4 HSpriteBlock blocks
  with identical IDs and imagery you will be able to have 4 sprites
  on the same horizontal line.  If you have only 1 HSpriteBlock block for
  a given image/ID, the sprite will only be able to appear in multiple
  vertical positions according to how many image/ctrl sections it has.

  The HSpriteBlock should be freed when no longer required by using the
  FREEHSPRITEBLOCK command.

---------------------------------------------------------------------------
Creating an attached hardware sprite pair associated with a software sprite
---------------------------------------------------------------------------

MAKEAUTOATTHSPRITEBLOCKS

( ImageID1(w), ImageID2(w), NumberOfSpriteDefinitions(w), SpriteCtrl(l)
  - - - HSpriteBlock1(l), HSpriteBlock2(l) )

As above for MAKEAUTOHSPRITEBLOCK but this time creating a pair of attached
hardware sprite definition blocks.

--------------------------------------------------------------------

Here are definitions of the HeliOS routines relating to the creation of
sets of identical AutoHSprite "SpriteCtrl" structures:

-------------------------------------------------------------------------
Creating sets of identical AutoHSprites from a hardware sprite definition
-------------------------------------------------------------------------

   MAKEAUTOHSPRITECTRLSET

  ( HSpriteBlock(l), Sprite#(w) - - - SpriteSet(l) )

  Makes a set of Sprite# SpriteControl structures to correspond with
  the hardware sprites defined by HSpriteBlock.

  This function MUST ONLY be used to operate on HSpriteBlock structures
  created using MAKEAUTOHSPRITEBLOCKS and MAKEAUTOATTHSPRITEBLOCKS, since
  it requires information about the original software sprite from which
  these functions derived the hardware sprite definition.

  The new SpriteCtrl structures are used by HeliOS to control motion and
  collision detection for the associated hardware sprites.

  The new SpriteSet must be initialised using INITSPRITESET before use.

  The number of sprites defined by Sprite# determines how many virtual
  hardware sprites the HeliOS system will use.  This number can be as
  great as 255, but only those images which can find a spare actual
  hardware sprite available at the right position will be displayed.

  The availability of hardware sprites depends on the number of images
  in the HSpriteBlock (affecting vertical availability), as well as the
  number of HSpriteBlocks installed (affecting horizontal availability).

------------------------------------------------------
Creating sets of single "different image" AutoHSprites
------------------------------------------------------

Sometimes you might not want to create lots of identical multiplexed images,
but you may wish to create unique AutoHSprites or sequences of AutoHSprites
for use in a hardware sprite animation.

HeliOS has automatic functions for creating sequences (or single) hardware
sprites complete with control structures from bitmapped imagery.

The general philosophy for creating these unique-image AutoHSprites is:

1. Design your imagery in bitmapped format and load it into memory.

2. Use the automatic functions below to create associated sets of hardware
   sprite definitions and AutoHSprite SpriteCtrl structures.

The functions below generate "sets" of AutoHSprites and store pointers to
the newly created AutoHSpriteData structures in special storage structures
called "AutoHSpriteSets", defined below.  Note that the special SpriteCtrl
structures created in association with each hardware sprite are NOT stored
in the AutoHSpriteSet structure, but are referenced by a pointer within
their associated AutoHSpriteData structure.

 AutoHSpriteSet definition:

 Sprites#(w)       -> Number of AutoHSprites in set
 Width(w)          -> Sprite image pixel width
 Height(w)         -> Sprite image pixel height
 Depth(w)          -> Original bitmap image bitplane depth
 AutoHSpriteData1  -> Sprite data definition linked to its own "SpriteCtrl"
 AutoHSpriteData2  -> Sprite data definition linked to its own "SpriteCtrl"
 AutoHSpriteData3  -> Sprite data definition linked to its own "SpriteCtrl"
 etc. etc.

Note that the routines below generate a hardware sprite definition AND a
SpriteCtrl structure for EACH sprite, and each of the AutoHSpriteData
definitions contains a pointer to the associated SpriteCtrl structure.

Because the allocations of memory etc. are quite complex, and because all
sub-elements are referenced from the AutoHSpriteSet structure, it is very
important to use the supplied FREEAUTOHSPRITESET function to close down
everything when you are finished.

-----------------------------------------------------------------
Gaining access to each of the AutoHSprite control data structures
-----------------------------------------------------------------

There are times when you need to access either of the two main elements of
an AutoHSprite from the other.

This is simple to do by accessing the appropriate fields of their mutual
data structures.

Here are the structure field offsets in the AutoHSprite's SpriteCtrl
structure which refer to the hardware sprite definition block (or both
blocks in the case of attached sprites):

SpriteCtrl_HSprite1 -> References the main hardware sprite definition block.

SpriteCtrl_HSprite2 -> References the 2nd hardware sprite definition block
                       of an attached sprite.

Here is the structure field offset in the AutoHSprite's AutoHSpriteData
structure which refers to the SpriteCtrl structure:

HSB_SCtrl -> References the SpriteCtrl structure of an AutoHSprite from
             the AutoHSpriteData structure

-------------
Code Examples
-------------

To get SpriteCtrl from AutoHSpriteData:

  MyAutoHSpriteData HSB_SCtrl INDEXD@L

To get AutoHSpriteData from SpriteCtrl:

  MyAutoHSpriteCtrl SpriteCtrl_HSprite1 INDEXD@L

---------------------------------------------------------------
Creating sets of single hardware sprites from bitmapped imagery
---------------------------------------------------------------

MAKEAUTOHSPRITESET

( BMap(l), XStart(w), YStart(w), Width(w), Height(w), HSprites#(w)
  ImageId(w), NumberOfImages(w) - - -  AutoHSpriteSet(l) )

  This function extracts from the bitmap a series of similar sized but
  possibly different images, read successively from left to right, as
  might be used for an animation sequence.  This is directly analogous to
  the MAKESPRITESET function used for creating software sprites.

  This function can be used to generate single sprites, but if used for
  multiple sprites all the images are given the same ID and can only be
  used in animations such that only one is "on screen" at any one time.

  The new SpriteSet must be initialised by using using INITSPRITE on the
  SpriteCtrl structure of each AutoHSprite before use.  You might use the
  following type of code construct, for example, to initialise the first
  sprite of the set:

  MySliceControl
  MyAutoHSpriteSet 8. INDEXD@L HSB_SCtrl INDEXD@L
  INITSPRITE

  Of course you may initialise different sprites for use in different
  display slices.

-----------------------------------------------------------------
Creating sets of attached hardware sprites from bitmapped imagery
-----------------------------------------------------------------

MAKEAUTOATTHSPRITESET

( BMap (l), XStart(w), YStart(w), Width(w), Height(w), HSprites#(w)
  ImageId1(w), ImageId2(w), NumberOfImages(w)
  - - - AutoHSpriteSet1(l), AutoHSpriteSet2(l) )

  This function extracts from the bitmap a series of similar sized but
  possibly different images, read successively from left to right, as
  might be used for an animation sequence.  This is directly analogous to
  the MAKESPRITESET function used for creating software sprites.

  This function can be used to generate single sprites, but if used for
  multiple sprites all the images are given the same ID and can only be
  used in animations such that only one is "on screen" at any one time.

  The new SpriteSet must be initialised by using using INITSPRITE on the
  SpriteCtrl structure of each AutoHSprite before use.  You might use the
  following type of code construct, for example, to initialise the first
  sprite of the set:

  MySliceControl
  MyAutoHSpriteSet 8. INDEXD@L HSB_SCtrl INDEXD@L
  INITSPRITE

  Of course you may initialise different sprites for use in different
  display slices.

  This initialisation operation only needs to be done for the first of the
  two AutoHSpriteSets.

----------------------------
Freeing sets of AutoHSprites
----------------------------

FREEAUTOHSPRITESET

( AutoHSpriteSet - - - )

Frees a complete set of AutoHSprites as created by MAKEAUTOHSPRITESET and
MAKEAUTOATTHSPRITESET.

Note that the FREEAUTOHSPRITESET will need to be called twice to free each
of the two individual AutoHSpriteSets created by MAKEAUTOATTHSPRITESET.


***********************************************************
Easy installation and control of automatic hardware sprites
***********************************************************

As we have discussed above, AutoHSprites consist of special SpriteCtrl
structures linked to special hardware sprite definition blocks installed
via the HeliOS system.

----------------------------
Installation of AutoHSprites
----------------------------

In order to install AutoHSprites you must carry out 3 simple operations:

1. Install the hardware sprite definition blocks associated with the
   AutoHSprite into the appropriate hardware sprite channels.

   To do this you use HSPRITE_INSTALL as described above.

2. Install the SpriteCtrl structures associated with the AutoHSprite into
   the HeliOS AutoHSprite handler.

   To do this you use the function ADDAUTOHSPRITECTRL which takes as its
   only parameter a pointer to the SpriteCtrl structure of an AutoHSprite.

3. Switch on the HeliOS automatic sprite control and multiplexing system.

   To do this you should use HSPRITE_AUTO_ON.

   Note that you can use the HeliOS low-level hardware sprite operations
   such as HSPRITE_PLACE without having the automatic sprite control and
   multiplexing system switched on.

   In general you should keep the automatic sprite control and multiplexing
   system switched off (to save CPU time) whenever you are not using it.

-------
Removal
-------

In order to remove an AutoHSprite you must carry out the reverse of the
installation procedures outlined above.

1. When you have finished using them, remove the hardware sprite definition
   blocks associated with the AutoHSprite.

   To do this you use HSPRITE_REMOVE as described above.

2. To remove any individual AutoHSprite SpriteCtrl structure from the
   HeliOS AutoHSprite handler you must use the special HeliOS function
   REMOVEAUTOHSPRITECTRL, which takes as its only parameter a pointer to
   the SpriteCtrl structure to be removed.

3. When you have finished with ALL HeliOS AutoHSprite operations you
   should ALWAYS switch off the HeliOS automatic sprite control system.

   To do this you should use HSPRITE_AUTO_OFF.

   Note that you can use the HeliOS low-level hardware sprite operations
   such as HSPRITE_PLACE without having the automatic sprite control and
   multiplexing system switched on.

   In general you should keep the automatic sprite control and multiplexing
   system switched off (to save CPU time) whenever you are not using it.

---------------------------------------------------------
Automatic installation and removal of single AutoHSprites
---------------------------------------------------------

HeliOS has an automatic function which installs a single-image AutoHSprite
hardware sprite definition block and SpriteCtrl structure in one operation.

This easy-install function also has a corresponding easy-removal function.

Here are the definitions of these functions:

INSTALLAUTOHSPRITE

( SpriteCtrl(l), Slot(w) - - - )

This function automatically installs the hardware sprite definition block
and SpriteCtrl structure for an AutoHSprite in one operation.

Attached sprites are handled automatically, and in this case you should
specify the LOWER of the two slot (hardware sprite channel) positions.


REMOVEAUTOHSPRITE

( SpriteCtrl(l) - - - )

This function automatically removes the hardware sprite definition block
and SpriteCtrl structure for an AutoHSprite in one operation.

Attached sprites are handled automatically.

----------------------------------------
Automatic clearing of AutoHSprite system
----------------------------------------

There is a function called CLEARAUTOHSPRITES (taking no parameters) which
clears ALL SpriteCtrl structures from the HeliOS AutoHSprite handler and
re-initialises this system.

Note that this function does not reset any fields in individual sprite
control structures and sprites will be removed "as is".  This means that
fields such as "SpriteCtrl_Running" within each object will still be left
as set when the system was last functioning.  If you use this function it
is up to you to reset all object parameters as required by your own code.

This function ONLY clears the SpriteCtrl handler and does NOT clear the
hardware sprite definition channels: if you need to clear these also you
must use HSPRITE_REMOVE on occupied channels.


**********************
Automatic multiplexing
**********************

HeliOS handles all its automated hardware sprite functions, such as the
multiplexing facility, by operating on the SpriteCtrl structure of an
installed AutoHSprite.

Each SpriteCtrl references its hardware sprite imagery via an ID number.

When the HeliOS system tries to "render" an AutoHSprite it will determine
the position from the SpriteCtrl structure and then it will search all the
available hardware sprite "slots" to find an "available" hardware sprite
definition block with the required ID.

It is important to understand that by "available" we mean that the hardware
sprite channel must be able to support the production of an image in the
particular display position requested.

If you are wanting to handle multiplexed hardware sprites you must first:

 1. Create appropriate hardware sprite definition blocks (see above)

 2. Create as many AutoHSprite SpriteCtrl structures as required (see above)

 3. Install the hardware sprite definition blocks (see above)

 4. Install the SpriteCtrl structures (see above)

 5. Remember that the HeliOS AutoHSprite handler must be switched on!

Once you have installed your AutoHSprites (and made sure that the HeliOS
AutoHSprite handler is switched on, of course!) all you have to do is
write parameters into the SpriteCtrl structure of each AutoHSprite, just
as if it were a software sprite.

The HeliOS system will automatically multiplex the available hardware
sprite channels and try to render imagery for your sprite: we say "try"
because it may be the case that hardware sprite conflict may leave no
channel available at a particular screen position at any one time.

This matter of positional "conflict" is one which you need to address very
carefully when you are deciding how many hardware sprite definitions you
need to make available.  You must also take into account whether sprite
motions can be made "predictable" so that positional conflict can be made
potentially restricted and therefore more manageable.

See the software sprite documentation for details of how to program the
various fields of a SpriteCtrl structure to control motion, collisions etc..


***********************************************
Easy control of multi-colour "attached" sprites
***********************************************

The documentation above explains how to create and install AutoHSprites,
and, as you will have seen, HeliOS handles the creation and installation
of attached sprites via easy and automated functions.

In fact an "attached" 16-colour AutoHSprite is controlled by HeliOS exactly
like a normal "single" sprite.

All you need do to control your attached AutoHSprites is to program the
single installed SpriteCtrl structure as usual: it really is that simple!


********************************************************
Pixel perfect bitmapped "shadowmask" collision detection
********************************************************

Collision detection is handled for HeliOS AutoHSprites in exactly the same
way that collision detection is performed for software sprites.

The collision detection system has its own documentation, and the software
sprite documentation explains specifically how to use the fields of the
SpriteCtrl structure to program collision detection functions.

This system does not use the built-in Amiga hardware sprite collision
detection system, but instead uses a more flexible "shadow-mask" system
which allows you to define shadow masks of any shape as collision templates
for any object.

HeliOS runs a collision handler system which treats all graphical objects
equally, whether software or hardware sprites, so you have a completely
consistent system which is easy to learn and program.


***********************
Complex motion controls
***********************

All HeliOS graphical objects, whether based on software or hardware sprites,
have a consistent programming interface with respect to dynamic behaviour.

The SpriteCtrl structure is used for both software and hardware sprite
dynamic control, and as far as the programmer is concerned both types of
object are controlled identically.

The only difference between using AutoHSprites and software sprites lies
in the initialisation and installation processes, and the fact that each
type of object has different operational constraints, as described above.

See the software sprite documentation for more details on specific aspects
of dynamic sprite object control.


************************************
Fully automated animation facilities
************************************

HeliOS has a sophisticated AutoHSprite animation handler which allows you
to control hardware sprite animations in a manner very similar to the way
you control software sprite animations.

There is one important concept relating to hardware sprite animations which
needs to be considered before you set up your animation:

HeliOS can animate hardware sprites by using two different methods to swap
imagery as the frames change:

1. Swapping hardware sprite definition blocks within a channel slot.

2. Referencing alternative sprite IDs to access different images.

Obviously you need to consider which of the above strategies is best for
any given application, and this will influence the way you approach the task
of setting up and installing your hardware sprites.  Once again you need 
to take account of the limitations of the hardware sprite display mechanism 
and the usual constraints of the multiplexing process.

Once everything is set up you need to specify which method HeliOS should
use for image switching, after which you can control the animation using
a control data structure which is very similar indeed to the one used for
software sprite animations.

Please read the extended documentation on animation of software sprites
before reading the rest of this section, which merely details differences
when using the hardware sprite animation system.

Here is the current definition of an "HSAnim" hardware sprite animation
control structure:

   STRUCTURE HSAnim,0
   WORD    HSAnim_Flags         -> Control Flags

   WORD    HSAnim_Speed         -> Animation speed
   WORD    HSAnim_Skip          -> Frame skip
   WORD    HSAnim_Count         -> Internal counter
   WORD    HSAnim_Current       -> Current frame
   WORD    HSAnim_Frames        -> Total frames
   WORD    HSAnim_Channel       -> Hardware sprite channel / ID-Control
   WORD    HSAnim_AnimControl   -> Animation type
   APTR    HSAnim_Image         -> Pointer to image array

   WORD    HSAnim_RemForth      -> HeliOS CFA executed at closedown
   APTR    HSAnim_RemCode       -> Assembler code executed at closedown
   WORD    HSAnim_BeforeForth   -> HeliOS CFA executed "Before" anim
   APTR    HSAnim_BeforeCode    -> Assembler code executed "Before" anim
   WORD    HSAnim_AfterForth    -> HeliOS CFA executed "After" anim
   APTR    HSAnim_AfterCode     -> Assembler code executed "After" anim
   WORD    HSAnim_CollForth     -> HeliOS CFA executed at collision
   APTR    HSAnim_CollCode      -> Assembler code executed at collision
   WORD    HSAnim_Status        -> Status flag

   WORD    HSAnim_AutoRemove    -> Auto-self-removal flag

   WORD    HSAnim_CountDown     -> Length of countdown in "frames"
   WORD    HSAnim_CDFlags       -> Control Flags set at end of CountDown
   WORD    HSAnim_CDForth       -> HeliOS CFA executed at countdown
   APTR    HSAnim_CDCode        -> Assembler code executed at countdown
   APTR    HSAnim_ThisFrame     -> Pointer to current Sprite controller

   WORD    HSAnim_XPos          -> Logical X-coordinate
   WORD    HSAnim_YPos          -> Logical Y-coordinate
   WORD    HSAnim_RenderXPos    -> Display X-coordinate
   WORD    HSAnim_RenderYPos    -> Display Y-coordinate
   APTR    HSAnim_XPosPtr       -> Pointer to logical X-coordinate
   APTR    HSAnim_YPosPtr       -> Pointer to logical Y-coordinate
   APTR    HSAnim_XAdd          -> Pointer to X-additive value
   APTR    HSAnim_YAdd          -> Pointer to Y-additive value
   WORD    HSAnim_XOrigin       -> Coordinate origin X-offset
   WORD    HSAnim_YOrigin       -> Coordinate origin Y-offset

   APTR    HSAnim_CollHandler   -> Pointer to collision handler
   APTR    HSAnim_CollTable     -> Pointer to collision routine table
   LONG    HSAnim_HitMask       -> Hitmask
   LONG    HSAnim_MeMask        -> MeMask
   WORD    HSAnim_CollFlag      -> Collision flag
   WORD    HSAnim_CollideAlways -> Off screen collision flag
   WORD    HSAnim_DummyFlag     -> Dummy anim flag
   LONG    HSAnim_ID            -> Internal ID

   LONG    HSAnim_FrameMask     -> Frame on/off mask
   WORD    HSAnim_Flash         -> Flash flag
   WORD    HSAnim_FlashBit      -> Flash bit definition
   WORD    HSAnim_Relativity    -> Relativity flag
   WORD    HSAnim_WrapCorrect   -> Wrap correction flag
   WORD    HSAnim_PtrUpdate     -> External pointer update flag

   WORD    HSAnim_VisiZone      -> Visibility zone flag
   WORD    HSAnim_VisiHit       -> Visibility zone hit flag
   WORD    HSAnim_VisiForth     -> HeliOS CFA executed at VisiZone hit
   APTR    HSAnim_VisiCode      -> Assembler code executed at VisiZone hit
   WORD    HSAnim_LeftZone      -> Left VisiZone boundary
   WORD    HSAnim_RightZone     -> Right VisiZone boundary
   WORD    HSAnim_UpZone        -> Top VisiZone boundary
   WORD    HSAnim_DownZone      -> Bottom VisiZone boundary
   WORD    HSAnim_DispZone      -> Display zone flag
   WORD    HSAnim_DispForth     -> HeliOS CFA executed at DispZone hit
   APTR    HSAnim_DispCode      -> Assembler code executed at DispZone hit
   WORD    HSAnim_Running       -> Activity status flag
   WORD    HSAnim_OnScreen      -> OnScreen status flag

   APTR    HSAnim_UserDataPtr   -> User data pointer
   WORD    HSAnim_UserData1     -> User data
   WORD    HSAnim_UserData2     -> User data
   WORD    HSAnim_UserData3     -> User data
   WORD    HSAnim_UserData4     -> User data
   WORD    HSAnim_UserData5     -> User data
   WORD    HSAnim_UserData6     -> User data
   WORD    HSAnim_UserStatus    -> User status flag

   LONG    HSAnim_CollHitMask   -> Collision HitMask
   LONG    HSAnim_CollMeMask    -> Collision MeMask
   APTR    HSAnim_SCtrlList     -> List of related AutoHSprite SpriteCtrls

   LABEL   HSAnim_SIZEOF

As you can see this structure is very similar to the SpriteAnim structure.

----------------------------------------------
Allocating an animation control data structure
----------------------------------------------

A HeliOS animation is defined by first allocating an appropriate data
structure which then must be initialised by setting it up with the various
parameters you require (see below).

You might use code something like this:

  HSAnim_SIZEOF MAKESTRUCTURE
  DFLAG0= ERROR" Fail: MyNewAnim"
  MyNewAnim MAKEPOINTER

The animation data structure can be allocated however you choose and can be
in chip or fast memory (fast is best).

The animation will be fully controlled when "on screen" by the data which
you store in this structure: you could regard the animation structure as a
"control panel" for the animation, with a series of switches and dynamic
settings which you can change at any time to generate your required effects.

--------------------------------------------------------------------------
Determining whether to use ID or Sprite definition switching for animation
--------------------------------------------------------------------------

Which of the two strategies you employ will depend on availability of
sprite channels and the usual positional constraints when multiplexing 
hardware sprites.

It is impossible to give advice to help in all circumstances except to
say, somewhat negatively perhaps, that you really do need to read carefully
all the above documentation on sprite multiplexing, until you are really
comfortable with all the various complications and constraints.

The actual procedure of programming hardware sprite animations in HeliOS 
is very simple, but you do need to thoroughly understand the way in which 
considerations of sprite positions and numbers influence the strategy of 
setting up hardware sprite channel allocations etc..

Once you have made the decision on whether to use ID animation or channel 
data swapping, there is a difference in the setting up of the animation 
control structure to use each strategy.

------------------------------------
Setting up an ID switching animation
------------------------------------

The HSAnim_Channel field of the HSAnim structure should be set to the
hardware sprite channel number (0-7) to be used for this anim.

The HSAnim_Image field of the HSAnim structure should be initialised to
point to a sequential table of 32-bit hardware sprite definition block
pointers.

These hardware sprite definition blocks will be switched in and out of the
hardware sprite channel to give the frame switching for the animation.

The HSAnim_SCtrlList field of the HSAnim structure should be set to null.

--------------------------------------------------
Setting up a sprite definition switching animation
--------------------------------------------------

The HSAnim_Channel field of the HSAnim structure should be set to any
negative value.

The HSAnim_Image field of the HSAnim structure should be initialised to
point to a sequential table of 8-bit ID values.

These ID values will be used to select hardware sprites images to be
switched for the animation.

The HSAnim_SCtrlList field of the HSAnim structure should be initialised
to point to a sequential table of 32-bit AutoHSprite SpriteCtrl structure
pointers.  These SpriteCtrl structures should be placed in correct order
to match the ID table representing the animation image frame sequence.

-----------------------------------------------------
Installing and removing HeliOS AutoHSprite animations
-----------------------------------------------------

Once you have created and initialised an animation structure you need to
install it into the HeliOS interrupt driven AutoHSprite animation handler.

This is done by using the function INSTALLHSPRITEANIM which is defined as
follows:

  INSTALLHSPRITEANIM

  ( HSAnim(l) - - - )

  Installs a hardware sprite animation into the HeliOS AutoHSprite
  animation control system.

You might use code something like this:

  MyNewAnim INSTALLHSPRITEANIM

From now on the animation will be processed under interrupt control while
ever and whenever the HeliOS game operating system is switched on.

The animation may be stopped or rendered invisible by using the control
parameters within its data structure, but it will always be processed by
the HeliOS animation handler until it is specifically removed.

To remove an AutoHSprite anim you can use the function REMOVEHSPRITEANIM:

  REMOVEHSPRITEANIM

  ( HSAnim(l) - - - )

  Removes a hardware sprite animation from the HeliOS AutoHSprite
  animation control system.

You might use code something like this:

  MyNewAnim REMOVEHSPRITEANIM

Another (sometimes more useful) method of removing a sprite animation is
to store the value "-3" into the "HSAnim_Flags" field of the animation
control structure.


********************************************************************
Easy switching between software and hardware sprites for same object
********************************************************************

Because it is easy to "clone" a hardware sprite from a software sprite,
it is also easy to arrange to switch between the two methods of sprite
generation for the same image.

This parallel facility is made even more easy to accomplish because even
things like collision detection and motion control dynamics are programmed
identically in the two different systems.

This facility is not something you would need often, but it comes "for
free" as a result of the way HeliOS is designed, so it is worth remembering
for the odd occasion where it will be helpful.

Only HeliOS has this direct correspondence between the two types of sprites
so it will possibly lead to a few new interesting game techniques.


*************************************
Support for complex particle dynamics
*************************************

Because of the unusually powerful and efficient HeliOS hardware sprite
multiplexing system it is possible to have a lot of small particles on
screen together.

To do this with software sprites would be very inefficient, and to do
it even with hardware sprites would normally require a considerable amount
of dedicated and specialised assembler code.

Not only does HeliOS provide this multiplexing facility in very fast and
efficient easy-to-use form, but there is even better news:

1. HeliOS provides a uniquely powerful hardware sprite collision detection
   system which is very easy to program.

2. HeliOS provides very sophisticated set of dynamic motion controls which
   are uniquely flexible and capable of easy generation of all kind of
   motion effects.

3. HeliOS has a dedicated "motor" system which allows ultra-fast generation
   of simple mathematical equations, linked motion paths etc.

All these things together mean that dynamic particle systems are more
easily programmed using HeliOS than in any other programming language.


******************************
Switchable motion "relativity"
******************************

Normally, hardware sprite positions are defined as "screen relative".

It is usually the task of the main program to calculate the screen offset
for a hardware sprite from its position relative to "game space" or the
main bitmapped playfield.

HeliOS has fully automatic maintenance of either screen or playfield
relative coordinate systems for hardware sprites.  This means that you
can specify hardware sprite coordinates in playfield-relative terms and
HeliOS will automatically place the sprite correctly on screen.


***********************************************************
Dual status system allowing manual/autocontrolled operation
***********************************************************

The HeliOS automatic hardware sprite support routines are very powerful
but they do have an inevitable processing time overhead as well as an
increased memory useage etc..

Sometimes you might wish to use the simpler HeliOS routines, or even
switch between the two systems.

HeliOS is designed to give you maximum freedom of choice in this matter.

HeliOS uses a "three level" hardware sprite system, as follows:

1. Low level     -> Amiga hardware sprite mechanism

2. Middle level  -> HeliOS hardware sprite control mechanism

                    This can be programmed directly for simple sprite
                    operations by using HSPRITE_PLACE

3. High level    -> Automatic HeliOS "AutoHSprite" multiplexing system

                    This uses the lower level HeliOS hardware sprite
                    control mechanism and provides a sophisticated
                    additional set of control functions

In effect this design gives a "dual status" system whereby the Amiga
hardware sprite mechanism can be controlled by either the middle/low level
HeliOS sprite control system or by using high level AutoHSprite functions.

What is more, you can easily switch between the two HeliOS systems to
control the same set of installed sprites.

This allows you to have the best of both worlds, using the automatic
routines for complex dynamic motion and animation but switching to the
manual control system whenever required.

When switching to the manual system you must always use HSPRITE_AUTO_OFF
to remove the unwanted processing overhead and to prevent the automatic
system from automatically changing your sprite position settings.

When switching to the automatic system you must always use HSPRITE_AUTO_ON
to switch on the interrupt driven HeliOS hardware sprite controller.

***************************************************************************
End
***************************************************************************
