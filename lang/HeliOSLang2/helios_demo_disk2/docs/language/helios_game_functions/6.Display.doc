
       *************************************************************
       Setting up a screen display under the HeliOS operating system
       *************************************************************

Before launching into a general explanation of HeliOS displays we give
first a list, for "quick reference" purposes, of the stages involved in
creating a display to run under the HeliOS operating system.

As another useful "quick reference", at the end of this document you will
find a description of the general purpose HeliOS commands which relate to
display creation and maintenance.

************************************************************
A summary of the steps involved in creating a HeliOS display
************************************************************

1.  Define all display parameters, preferably as named constants
2.  Allocate all required Display/Slice data structures
3.  Allocate all required RasInfo structures using OPENRASINFO
4.  Possibly allocate ColourMap structures (Optional)
5.  Possibly load or create imagery for display (Optional)
6.  Link all display structures by setting up mutual pointers etc.
7.  Initialise all display structures by storing parameters in fields
8.  Generate copper lists for slices using MAKECOPSTRIP
9.  Generate copper lists for display using MAKEDISPLAY
10. Possibly make SliceControl structures using MAKESLICECONTROL (Optional)
11. Possibly generate a collision mask using MAKESLICEMASK (Optional)
12. Possibly install SliceControls using INSTALLSLICECONTROL (Optional)
13. Switch on HeliOS operating system using HELIOS_ON
14. Install the display using SHOWDISPLAY
15. Use the display.......
16. Switch off HeliOS operating system using HELIOS_OFF
17. Deallocate everything in reverse order


************
Introduction
************

This document gives quite a long and detailed discussion on Amiga displays,
along with code examples and explanations of basic concepts.

If all the concepts mentioned here are unfamiliar to you, you may get the
impression that programming displays is a very complex subject, but this
is not really the case.

In fact, setting up any particular HeliOS display is very simple indeed,
but the versatility of the Amiga's display capabilities means that you
need to know a little background information in order to be able to make
decisions on how to select the parameters to set up your displays.

We recommend that having read through this document you look at the example
source code provided to see how simple it is to set up a HeliOS display!


**********************
Background information
**********************

First of all we must point out that the main text below assumes that the
reader is familiar with general concepts relating to Amiga displays, such
as View/ViewPort/RastPort/RasInfo/BitMap etc.  If you are not familiar
with these concepts you will still be able to program HeliOS displays,
but the explanations below will not be so easily comprehensible.

We cannot here enter into a full tutorial on standard Amiga programming
concepts, information on which is readily available from many sources.

The Amiga ROM Kernel Reference Manuals are the standard source of this
type of information, but there are many other good (cheaper!) books, as
well as plenty of material available on disk from PD libraries.

For those who know nothing at all about the Amiga operating system (yet!)
here is a brief and simplistic overview of Amiga OS display programming.


***************************************************************
A quick journey through Amiga operating system display concepts
***************************************************************

All Amiga displays are bit-mapped and use RAM memory based bitplanes.

This means that imagery information is represented by areas of memory
(bitplanes) which use each "bit" of information to represent one pixel
on the video display screen.

Multiple colours are generated by using a number of bitplanes, effectively
"stacked" one after the other, with corresponding "bits" in each plane
treated as a group of bits to define a "colour number".  This means that
the group of bits which defines the "colour number" of any one pixel is
actually composed of separate single bits each one of which is located in
a different bitplane.

The set of pixel "bits" derived from the bitplanes are used to compose a
binary value which defines the "colour number" for that pixel.

One bitplane gives two colours          -> 0 or 1 (Binary 0,1)
Two bitplanes give four colours         -> 00 01 10 11 (Binary 0,1,2,3)
Three bitplanes give eight colours      -> 000 001 010 011 100 101 110 111
Four bitplanes give sixteen colours     -> 0001 0010 0011 0100 0101 etc.
Five bitplanes give thirty-two colours  -> 00001 00010 00011 00100 etc.
Six bitplanes give sixty-four colours   -> 000001 000010 000011 etc.
etc. etc.

The colour "number" refers to one of the Amiga "hardware colour registers",
which in turn specifies a particular RGB ("red-green-blue") value which
defines the proportion of the primary colours making up the colour in
question.

All Amiga "displayable" bitplanes (you can create "background storage"
bitplanes which are not themselves displayable) must be stored in what
is called "chip memory".

The term "chip memory" refers to memory which is accessible to the Amiga
custom hardware chips, and in general this type of memory is reserved for
use by graphics and sampled sounds.  Programs may be loaded into and run
from chip memory, but they will do so more slowly that if they were run
in "fast memory".

The term "fast memory" refers to memory which is NOT accessible to the
Amiga custom chips.  The reason it is called "fast" is that the CPU can
get quicker access to this memory because the Amiga custom chips cannot
"interfere" with CPU memory access.

Having established that the Amiga "in some way" generates a video picture
which corresponds to bitplanes stored in Chip RAM, we need to know how this
process can be accessed and controlled within a program.

The Amiga generates a display, from the point of view of the programmer,
by using a number of data structures which contain the various parameters
defining every aspect the display.

From the point of view of the machine, the display is maintained by values
stored in certain hardware "control registers", and these registers in turn
are mainly controlled by a special "program" called a "copper list".

The "copper list" is a primitive program (or "list") run by the Amiga's
video co-processor (known as the "copper").  This "copper list" tells the
Amiga, among other things, just where in memory to look for its bitplanes
and also usually specifies what RGB values are stored in colour registers.

The Amiga has ROM based operating system software which "translates" the
information in the display data structures (which is relatively "readable"
and "comprehensible" to the programmer) into the "machine instructions"
which make up the copper list.

Having created a copper list, the Amiga system software allows you to
"install" and modify this copper list using relatively "high level"
software routines which insulate the programmer from very much (if any)
contact with the Amiga hardware itself.  In normal circumstances you would
never need to program a copper list directly, either under the Amiga or
the HeliOS operating systems, but facilities are provided within both
systems to do so if required for certain "special effects" (such as the
well known "rainbow" background effects).

From a practical point of view, before you can fully understand how to 
program Amiga displays you need to know a little more about all the data 
structures which provide the "programmer's interface" to the main display 
hardware.

An Amiga OS display is organised by reference to data structures which
define the display in a hierarchical manner.

* At the top of the hierarchy is a View structure (defining the whole
  display) which contains pointers to "lower-level" ViewPort structures.

* The ViewPort structures define all the horizontal "sub-slices" of the
  display", and in turn contain pointers to RasInfo structures.

* The RasInfo structures define the actual raster bitplanes in memory and
  the positioning of the visible area within possibly oversized bitplanes.

  RasInfo structures in turn contain pointers to BitMap structures.

* The BitMap structures define the dimensions and number of the actual
  raster bitplanes in memory.

  IMPORTANT NOTE:

  The BitMap is a general purpose structure not solely connected with
  the definition of the display itself.

  A BitMap structure can also be used to define any set of bitplanes which
  are not necessarily even visible or connected to the display structures.

  Small BitMaps can be used to define individual sets of bitplanes which
  contain general imagery, and there are functions which allow the easy
  transference of these "small" images into the main display bitplanes.

  This is basically how "software sprites" or "Bobs" (blitter objects) work.

  A BitMap can define ANY set of bitplanes, and is merely a method of
  conveniently bringing together into one easily accessible unit all
  information relating to a particular bitmapped image.  It is a good idea
  to standardise your code and handle all bitplanes by reference to BitMap
  structures.  This provides a consistent method of accessing bitplanes
  which is much more efficient to work with than having bitplanes strewn
  around in memory with miscellaneous reference pointers.

  While on this topic there is one other important structure which augments
  the standard BitMap structure, and this is the "RastPort" structure.

  A RastPort is a "higher level" structure which contains a full BitMap
  structure as well as many parameters defining the current state of
  the BitMap with respect to various graphical rendering functions.

  A RastPort is really an extension of the BitMap information to include
  a whole host of details concerning rendering operations connected with
  the BitMap.

  For example, a RastPort contains information such as the last drawing
  "pen position", as well as "pen colours" and text rendering information.
  This allows any particular RastPort to "remember" details concerning
  rendering operations and thus saves the programmer from the necessity
  of maintaining any separate record.

  RastPorts are used "in the background" by the Amiga operating system as
  vital components in the maintenance of the multi-tasking GUI, and there
  are many graphical operators which work with RastPorts within both the
  Amiga and HeliOS operating systems.

  Because there are so many Amiga operating system and HeliOS commands
  which use both RastPorts and BitMaps to define graphical operations,
  it is absolutely essential that you understand and are comfortable with
  these concepts.

The Amiga Intuition system has its own slightly more "high level" data
structures called Screens and Windows which can also be used to generate
an Amiga display.

In reality the Intuition display is just an elaborated version of the
display system outlined above, and merely rests on an underlying system
of Views, ViewPorts, RasInfos etc.

An Intuition "Screen" is very roughly equivalent, in terms of its role in
the display, to a ViewPort.  The Screen also has extra features relating
to the maintenance of the multi-tasking user interface.

An Intuition "Window" is a sub-area of a Screen which has as its basis a
RastPort structure but once again has additional functions relating to
its use as a component of the GUI.

-----------------------
Priorities for learning
-----------------------

Generally speaking, as far as general game display functions are concerned,
the Intuition structures mentioned above are not very important, and are
only mentioned as background information.

It is, however, important to know more about the View, ViewPort and RasInfo
data structures than we have been able to give here.

It is especially important to be familiar with RastPorts and BitMaps and
all the various functions which are provided to manipulate them.

The "lowest level" concepts are the building blocks from which your whole
HeliOS programming knowledge will stem, and it is absolutely essential
to be well informed about all concepts relating to bitplanes, CHIP memory
versus FAST memory, and the way the Amiga colour system functions.


---------------------------
CHIP memory and the blitter
---------------------------

Normally BitMaps must refer to bitplanes stored in CHIP memory, for two
reasons:

1. Only bitplanes in CHIP memory can be accessed as video information.

2. Only bitplanes in CHIP memory can be accessed and manipulated by the
   blitter (which is a vital foundation of the Amiga's ability to transfer
   and transform graphics quickly).


-----------------
Blitter emulation
-----------------

It is of interest with respect to the creation and storage of bitmapped
imagery to know that HeliOS has a unique and very useful ability to
emulate the blitter using the CPU. (see the HeliOS "GraphicsLib")

The CPU blitter emulation allows you to effectively "blit" imagery to
and from "FAST" memory, allowing you to store graphical imagery in FAST
memory based BitMaps.

This allows you to make use of FAST memory for graphical purposes in ways
which would not normally be possible, and in particular many "background"
graphical imagery operations can now be carried out in FAST memory to
free CHIP memory and the blitter for other purposes.


-----------------------------
BitMaps for everything......!
-----------------------------

One final interesting point is that HeliOS makes much use of BitMaps for
ALL its graphical imagery, and has many custom functions for manipulating
BitMaps.  In particular all sprites, and indeed ALL imagery used by HeliOS,
have an associated BitMap structure.

This means that ANY HeliOS graphical operation can be performed on ANY
HeliOS graphical object, and ALL HeliOS graphical objects have exactly
equal status and a facility for manipulation via BitMap structures.


***********************************************
General concepts behind the HeliOS game display
***********************************************

The problem with using the Amiga operating system to run fast games is
largely one of speed and the inability of the OS to support some of the
specialised techniques necessary.  This functional shortfall is a result
of many different factors, some of which lie in the way the Amiga screen
display is maintained by the OS, and others of which relate to the many
constraints of providing a sophisticated multi-tasking operating system.

Once the Amiga operating system is closed down, all the overheads and
constraints involved in providing a general purpose multi-tasking user
interface are removed, and we can concentrate on producing a much faster
system specialised for game production.  The HeliOS game operating system
is designed with the sole purpose of making it easy to write fast games:
it provides an efficient interface with the Amiga hardware including many
functions designed to facilitate fast graphical displays.

In designing HeliOS we have not deliberately set out to be different for
the sake of it, but on the contrary we have attempted to retain as much
similarity to the Amiga operating system as possible, to help programmers
who are accustomed to traditional Amiga concepts.  HeliOS does many things
differently in its "inner" operation, but as far as general programming is
concerned the ideas and techniques will hopefully not be too unfamiliar.

HeliOS provides an alternative screen display system which stays as close
to the Amiga operating system in terms of concepts and data structures as
possible: in fact HeliOS uses many identical data structures to the Amiga
operating system.

HeliOS uses a very similar conceptual framework to the Amiga OS, to create
a flexible main display with as many vertically stacked display "Slices" as
you like, each having its own display mode.

The Amiga operating system has a comprehensive set of functions and data
structures which control and define the screen display and its associated
imagery.  Many of the Amiga operating system concepts and data structures
which are used in the manipulation of display imagery are well known to
all Amiga programmers and need not be "reinvented".  For example, many of
the low-level structures used to define the imagery and bitplanes of Amiga
displays, such as BitMaps and RastPorts, are retained by HeliOS and used in
a virtually identical manner.

This close relationship between the low level structures of the HeliOS and
Amiga screen display systems make HeliOS easy to use for experienced Amiga
programmers and has the additional benefit that it is easy to transfer
displays, complete with imagery, between the two operating environments.

HeliOS displays work with BitMaps just like Amiga displays, and the general
manipulation of display imagery and bitplanes is identical except that
HeliOS provides rather more specialised (and faster) imagery manipulation
functions.

Display imagery can be set up and manipulated either in the Amiga operating
system or the HeliOS operating system, but generally you will be initially
preparing your HeliOS display while still running the Amiga operating system
prior to entering HeliOS mode.  Because HeliOS works with standard BitMap
and RastPort structures all the Amiga operating system blitter functions
which operate on these entities can be used to prepare your HeliOS display
imagery.

Because HeliOS is designed for different purposes it contains some rather
interesting new functions which make life easier for games programmers.
Some of the standard Amiga operating system blitter functions have been
provided by HeliOS in a faster and slightly more powerful form, so check
out the available HeliOS functions before using the Amiga OS ones.

Many of the HeliOS imagery manipulation tools are collected together in
HeliOS "GraphicsLib" and it is worth looking there to familiarise yourself
with the currently available functions.

Creating and manipulating imagery and storage bitplanes is only one aspect
of display maintenance and you also need somehow to define and generate a
copperlist which maintains your multi-slice display by regularly updating
the video display hardware control registers.

The HeliOS operating system creates and maintains its displays in a manner
very similar to the Amiga operating system from the point of view of the
programmer.  HeliOS requires you to initialise data structures very similar
to those used by the Amiga OS and then you use a similar series of commands
to automatically generate and install the display copperlist.

The actual form of the display copperlist and the way in which the display
is maintained by HeliOS is totally different to the Amiga OS, but this need
not concern you when creating displays to run under HeliOS.  The good news
is that in terms of overall programming concepts HeliOS and the Amiga OS
are very similar, so familiarity with standard Amiga display programming
techniques will help you adapt easily to the HeliOS system.

One new concept (or terminology) which is used in HeliOS is the display
"Slice", which is conceptually related to the Amiga "ViewPort" or Intuition
"Screen", in the sense that it defines a horizontal strip of the screen
display which has its own display parameters.

Whereas the Intuition "Screen" relates in terms of functionality to the
requirements of maintaining a multi-tasking graphical user interface, the
HeliOS "Slice" is designed to implement a host of specialised game display
requirements.

Once established, a HeliOS "Slice" is controlled by installing a special
control data structure, called "SliceControl",into the HeliOS operating
system.  This "SliceControl" structure controls things such as scrolling,
double buffering, mapping, wrapping, and a whole lot of other very vital
functions required to run an arcade game display.

Slices really are very easy to work with because the HeliOS operating system
does an incredible amount of the "hard work" for you automatically.  The
complexity of the underlying functions performed by HeliOS require that
quite a large amount of data is stored in a SliceControl structure, but
most of its fields are for private use by the HeliOS system and those which
you program yourself are very simple to use.

It is important to emphasise that you should make no attempt to program
the SliceControl structure directly except in the ways described explicitly
in the documentation.  Certainly you should not worry about trying to study
the SliceControl structure itself, but merely use the functions provided to
achieve your desired effects.


***************************
Setting up a HeliOS display
***************************

----------------------------------
Display definition data structures
----------------------------------

The first step in creating a HeliOS display is to decide on the various
characteristics of your new display, such as resolution, number of colours,
and "ViewMode" (incidentally, HeliOS uses an identical ViewMode definition
system to the Amiga OS).

Then you need to allocate and initialise data structures, incorporating
your display parameters into appropriate fields within the structures.

The data structures which define a HeliOS display are organised in a manner
very similar to an Amiga OS display.  We will present an overview of each
system here to help you understand the similarities which will help you
transfer imagery between the two systems when required

Incidentally, if all this is new to you, you may soon be thinking that all
these structures and sub-structures are just too much trouble......why not
have just one command (with a few parameters) to make a screen display?

Well, the answer is that the Amiga (and HeliOS) display structures are
very well designed to allow enormous flexibility in the way displays are
set up and controlled.

Without going into detail, suffice it to say that when we set out to create
a no-compromise display system for HeliOS we ended up with something quite
close in concept to the way the original Amiga designers had done things.

This is simply because it is a GOOD way of doing the job, and works very
well, so please have patience with all the apparently over-complicated
things you are about to read - they really are necessary and worthwhile.

Below is a brief overview of the way Amiga and HeliOS displays are organised
in terms of control data structures.

--------------
Amiga Display:
--------------

The Amiga OS display contains a hierarchy of control structures:

1.  The "View" is a single master control structure which organises and
    brings together the multiplicity of data which makes up the display.

    Specifically, the View structure contains a list of ViewPort structures
    which are explained below....

    Here is an Amiga OS View structure:

    STRUCTURE View,0
    LONG    v_ViewPort
    LONG    v_LOFCprList
    LONG    v_SHFCprList
    WORD    v_DyOffset
    WORD    v_DxOffset
    WORD    v_Modes
    LABEL   v_SIZEOF

2.  The "ViewPort" structures which are listed within the "View" are each
    responsible for defining a horizontal slice of the screen display in
    terms of colour depth, display resolution etc.

    Interestingly a ViewPort can have very large allocated bitplanes which
    are far wider and deeper than the ViewPort visible display area.  Thus
    there may be only a small portion of a large imagery bitplane visible
    on screen at any one time, and this small viewing area may be scrolled
    around the larger bitplane area using simple hardware smooth scrolling.

    Each ViewPort contains a pointer to a RasInfo structure which is used
    to define the raster bitplanes in memory which contain imagery for the
    ViewPort's display slice.

    Here is an Amiga OS ViewPort structure:

    STRUCTURE  ViewPort,0
    LONG    vp_Next
    LONG    vp_ColorMap
    LONG    vp_DspIns
    LONG    vp_SprIns
    LONG    vp_ClrIns
    LONG    vp_UCopIns
    WORD    vp_DWidth
    WORD    vp_DHeight
    WORD    vp_DxOffset
    WORD    vp_DyOffset
    WORD    vp_Modes
    BYTE    vp_SpritePriorities
    BYTE    vp_ExtendedModes
    APTR    vp_RasInfo
    LABEL   vp_SIZEOF

3.  The "RasInfo" structure contains information relating to the actual
    memory locations where the bitplanes are stored, and this information
    is stored in yet another sub-structure, called a "BitMap" structure.

    The Rasinfo structure also has one more important function......

    We mentioned above that a ViewPort can have "oversized" bitplanes which
    can be wider and deeper than the ViewPort visible display area.  Thus
    there may be only a small portion of a large imagery bitplane visible
    on screen at any one time, and this small viewing area may be scrolled
    around the larger bitplane area using simple hardware smooth scrolling.

    The other important function of the RasInfo structure is to specify
    at which point within a possibly "oversized" set of bitplanes the
    visible screen display begins and ends.

    Here is an Amiga OS RasInfo structure:

    STRUCTURE  RasInfo,0
    APTR    ri_Next
    LONG    ri_BitMap
    WORD    ri_RxOffset
    WORD    ri_RyOffset
    LABEL   ri_SIZEOF

4.  The "BitMap" structure contains information about the actual memory
    locations of the bitplanes, how many bitplanes there are, and also the
    dimensions of the bitplanes.

    Here is an Amiga OS BitMap structure:

    STRUCTURE  BitMap,0
    WORD    bm_BytesPerRow
    WORD    bm_Rows
    BYTE    bm_Flags
    BYTE    bm_Depth
    WORD    bm_Pad
    STRUCT  bm_Planes,8*4
    LABEL   bm_SIZEOF

---------------
HeliOS Display:
---------------

The HeliOS display contains a hierarchy of control structures:

1.  Instead of a "View" structure HeliOS has a "Display" structure which
    performs a similar (but not quite identical!) role and is almost the
    same in definition.

    The "Display" is a single master control structure which organises and
    brings together the multiplicity of data which makes up the display.

    Specifically, the Display structure contains a list of "Slice"
    structures, which are explained below....

    Here is a HeliOS Display structure (Roughly equivalent to a "View"):

    STRUCTURE Display,0
    LONG    DS_Slice
    LONG    DS_LOFCop
    LONG    DS_SHFCop
    WORD    DS_XOff
    WORD    DS_YOff
    WORD    DS_Modes
    LABEL   DS_SIZEOF


2.  Instead of a "ViewPort" structure HeliOS has a "Slice" structure which
    performs a similar (but not quite identical!) role and is almost the
    same in definition.

    The "Slice" structures which are listed within the "Display" are each
    responsible for defining a horizontal slice of the screen display in
    terms of colour depth, display resolution etc.

    Each "Slice" contains a pointer to a RasInfo structure which is used
    to define the raster bitplanes in memory which contain imagery for the
    Slice's display slice.

    Here is a HeliOS Slice structure (Roughly equivalent to a "ViewPort"):

    STRUCTURE  Slice,0
    LONG    SL_Next
    LONG    SL_ColorMap
    LONG    SL_DspIns
    LONG    SL_SprIns
    LONG    SL_ClrIns
    LONG    SL_DSControl
    WORD    SL_DWidth
    WORD    SL_DHeight
    WORD    SL_DxOffset
    WORD    SL_DyOffset
    WORD    SL_Modes
    BYTE    SL_SpritePriorities
    BYTE    SL_Flags
    APTR    SL_RasInfo
    LABEL   SL_SIZEOF


3.  The "RasInfo" structure contains information relating to the actual
    memory locations where the bitplanes are stored, and this information
    is stored in yet another sub-structure, called a "BitMap" structure.

    The Rasinfo structure also has one more important function......

    Interestingly a Slice can have very large allocated bitplanes which
    are far wider and deeper than the Slice visible display area.  Thus
    there may be only a small portion of a large imagery bitplane visible
    on screen at any one time, and this small viewing area may be scrolled
    around the larger bitplane area using simple hardware smooth scrolling.

    The other important function of the RasInfo structure is to specify
    at which point within a possibly "oversized" set of bitplanes the
    visible screen display begins and ends.

    Here is a HeliOS RasInfo structure, which you will see is identical to
    the Amiga version:

    STRUCTURE  RasInfo,0
    APTR    ri_Next
    LONG    ri_BitMap
    WORD    ri_RxOffset
    WORD    ri_RyOffset
    LABEL   ri_SIZEOF

4.  The "BitMap" structure contains information about the actual memory
    locations of the bitplanes, how many bitplanes there are, and also the
    dimensions of the bitplanes.

    Here is a HeliOS BitMap structure, which you will see is identical to
    the Amiga version:

    STRUCTURE  BitMap,0
    WORD    bm_BytesPerRow
    WORD    bm_Rows
    BYTE    bm_Flags
    BYTE    bm_Depth
    WORD    bm_Pad
    STRUCT  bm_Planes,8*4
    LABEL   bm_SIZEOF

----------------------------
Similarities and differences
----------------------------

As you can see from the above, HeliOS and Amiga displays are very similar
in overall organisation.

Do not push the analogy too far in terms of the way the display is finally
created, but please do note that the RasInfo and BitMap structures used
to define the actual display planes are totally identical in both systems.

This is very important because it means that you can freely interchange
these entities between the two systems and use similar manipulation tools.

Above all, this means that you can just as easily "cross-transfer" graphic
imagery between Amiga and HeliOS displays as you can manipulate imagery
within each system.  This is a very useful facility, as you will see.

------------------
Display parameters
------------------

It is a good idea to collect all "display-specific" parameters together
in one place within your program code: collecting these together makes
it easier to adjust things at any time without having to search source
code to replace values individually.

If you create a set of "named" constants for the display parameters it
makes references to these parameters within your program easier than
simply using numeric values.

You might find it useful to set up your display parameters using a table
of CONSTANTs, something like this example:

  256                      CONSTANT DisplayHeight      \ Full PAL display
  320                      CONSTANT DisplayWidth       \ Lores display
  44                       CONSTANT DisplayTopLine     \ Display start

  DisplayWidth             CONSTANT Slice1Width        \ Lores width
  DisplayWidth 32 +        CONSTANT Slice1RasterWidth  \ Raster=SWidth+32
  DisplayHeight            CONSTANT Slice1Height       \ Slice height
  DisplayHeight 32 +       CONSTANT Slice1RasterHeight \ Slice Raster=DHgt+32
  0                        CONSTANT Slice1Mode         \ Lores
  3                        CONSTANT Slice1Planes       \ Slice bitplanes
  2 Slice1Planes 1- LSL    CONSTANT Slice1Colours      \ A-slice colours

  etc. etc.

-------------------------------------------------------------
A short digression on calculating colours from bitplane depth
-------------------------------------------------------------

Look at this line in the above example code:

  2 Slice1Planes 1- LSL    CONSTANT Slice1Colours      \ A-slice colours

Here we are calculating the number of colours from the number of bitplanes
using a simple method:

Number_Of_Colours = 2  (Number_Of_Planes-1)  LSL

This simple method using the LSL (Logical_Shift_Left) function may not be
obvious at first glance, so if you are not sure about how this works here
is a very brief explanation:

Let us assume that we have a "3 bitplane" display slice as above.

One bitplane would give 2 colours.

Each additional bitplane multiplies the number of colours by 2, so for each
extra plane after the first we need to multiply our initial value of 2 by 2.

Performing a single LSL operation on any number multipies by 2, so we have
a quick method of multiplying by two for our colour calculation.

In this case, we need "2 to the power 3", which is 2*2*2 (=8).

e.g.  2*2*2
      ^ ^ ^
      | | |
      ----- << Total number of planes = 3

So, we take the first value 2......

      2*2*2
      ^
      |
      - << Initial start value of 2

.....and we now need to multiply it by 2 "the_number_of_planes minus_one"
more times.

      2*2*2
        ^ ^
        | |
        - - << Total planes minus one

So, Number of colours = 2 operated on by LSL "NumberOfPlanes-1" times.


---------------------------------
Allocating and linking structures
---------------------------------

Because there are many fields which you need to initialise in the Display
and Slice structures it would be clumsy to use a single allocation function
with lots of parameters.  Instead, in the case of these structures, it is
easier to simply allocate (or declare within your code) a set of the data
structures required to define the Display and Slice structures.

On the other hand, the RasInfo and BitMap structures do have an easy single
allocation command provided within HeliOS, called OPENRASINFO, and you are
advised to use this command rather than undertake manual allocation of the
RasInfo and BitMap structures.

The OPENRASINFO command simultaneously allocates and initialises both the
RasInfo and associated BitMap structures in one automatic operation.

You can define the Display and Slice structures using the MAKESTRUCTURE
command, or you can use ALLOCMEMORY, or you can simply define each of the
structures within the HeliOS dictionary using the "," or "ALLOT" functions.

Whatever methods you use, you will end up with:

1. 32-bit pointers to a set of blank uninitialised Display and Slice
   structures.

2. 32-bit pointers to a set of fully initialised RasInfo structures which
   are already set up with pointers to BitMap structures etc.

All these structures then need to be linked together:

1. The Slice structures need to be linked together into a "list"

2. The Slice structures list must be linked into the Display structure

3. The Slice structures must point to their associated RasInfo structures

   Note that the RasInfo structures are already initialised and set up with
   their associated BitMap structures.

-------------------------------------------------
Initialising structures and creating copper lists
-------------------------------------------------

Once the display structures are linked together they need to be initialised
with all the appropriate parameters and then used to generate master slice
and main display copperlists.

Initialising the display structures is simply a matter of storing parameters
into the data structure fields.

In the HeliOS system each display slice has its own small copper list and
these must be created before generating the master display copper list.

Once the individual slice copper lists have been created the main display
structure is used to create a "master" copper list which maintains the whole
display and runs each of the individual slice copper lists.

To create copper lists for each of the display slices use the HeliOS command
MAKECOPSTRIP for each of the slices: this function takes a pointer to a
Slice structure as its sole parameter.

Having created slice copper lists you then need to use the HeliOS command
MAKEDISPLAY to create a master display copper list.

Once all this has been done, you have an assemblage of data structures and
copper lists which together totally define a display.  Your display is now
completely prepared, but will not be active until you install it into the
HeliOS system.

To install an initialised display into the HeliOS system as the current
active display use the command SHOWDISPLAY which takes a fully initialised
Display data structure as its sole parameter.

------------------------------
Optional additional structures
------------------------------

The structures defined above will allow you to set up a basic display, but
you will probably also need to set up colour palettes for your slices, and
you may well wish certain slices to be scrolled, or double buffered, or have
some other special dynamic attribute.

In these cases you will need to allocate additional structures.

To set up a colour palette you need to allocate and initialise a ColourMap
structure, and to set up complex slice dynamic effects you need to allocate
and initialise a SliceControl structure.

Note that the example code below assumes, for the sake of simplicity, that
a ColorMap has already been allocated and initialised.  In many cases this
will be done using HeliOS DOSLIB functions which automatically load IFF
files containing display imagery and palette information.

---------------------------------------------------
Creating SliceControl structures for special slices
---------------------------------------------------

SliceControl structures are used to control any display slices which perform
mapping or scrolling functions, or which require double or triple playfield
buffering etc.

These structures are created, initialised, and installed into the HeliOS
system, upon which special interrupt code will automatically handle the
special functions allocated to the associated slices.

The HeliOS SLICECONTROL functions are extremely powerful, since they handle
all the double buffering and scrolling with automatic wrap.

There is a HeliOS function called MAKESLICECONTROL which creates and
initialises a SliceControl structure.  (There is also a "dual-playfield"
version of this command: for more details see below).

Here is the stack diagram for the MAKESLICECONTROL function:

 MAKESLICECONTROL

 ( Slice(l), Width(w), Height(w) _ _ _ SliceControl(l) or null )

The MAKESLICECONTROL function is very powerful, and intelligently creates
all the system resources required to carry out maintenance of the special
Slice features requested.  For example, all extra display structures,
bitplanes etc. are allocated and initialised automatically as required.

Because this function allocates resources, it is possible for it to fail:

  On success a pointer to the new SliceControl structure is returned.

  On failure null is returned.

After making a SliceControl structure all you need to do is INSTALL this
control structure using INSTALLSLICECONTROL, upon which all double/triple
buffering and scroll functions in this display slice will be carried out
automatically by the HeliOS operating system.

The parameters supplied to MAKESLICECONTROL are not as simple as they
appear, since the function attributes special meanings to the parameters
according to certain conventions:

The width and height parameters determine whether this will be a single, 
double, or triple buffered slice by interpreting their values as follows:

  1. If Width and Height are both zero.

     This slice is a double buffered slice, which means that two
     complete display buffers as defined by the Slice structure will
     be allocated.

     All graphic operations will be rendered into a background display
     and automatic display buffer switching is performed, ensuring
     flicker-free sprites.

     Each sprite/BOB must have its background saved and restored for
     each frame.

     The double buffered display area may be mapped from 16x16 blocks
     or it may be a complete single section display area.

     This mode is useful when there are NOT so many sprites on screen
     that it becomes more efficient to redraw the whole background
     with a single "blit" than to save and restore the background for
     each sprite individually.  If there are many sprites on screen
     a triple buffered display may be more efficient.  See below.

     In terms of memory useage, this mode allocates twice the memory
     required for a single display as defined in the display Slice
     structure.

  2. If Width and Height are both negative.

     No further display buffers are allocated since this slice is a
     single buffered slice, so all graphic rendering will be drawn
     immediately into the bitplanes being displayed.

     This can result in flickery graphics and is not recommended for
     games with many moving objects.

     Each sprite/BOB must have its background saved and restored for
     each frame.

     The single buffer display area may be mapped from 16x16 blocks
     or it may be a complete single section display area.

     In terms of memory useage, this mode allocates just the memory
     required for a single display as defined in the display Slice
     structure.

  3. If Width and Height are both positive.

     This slice is a triple buffered slice, which means that a double
     buffered display will be created, as well as a third oversized
     display buffer with "Width x Height" size parameters.

     The double buffered screen, into which sprite graphics etc. are
     rendered has dimensions as specified in the Slice structure.

     The third "triple" buffer contains the full background graphics
     which are always kept fully intact, so when each double buffered
     frame is redrawn the background graphics can be restored as a
     complete single-blit area from the third buffer.

     The third buffer may be "oversize" so that the display can scroll
     around it horizontally and vertically.

     The third buffer may be mapped from 16x16 blocks or it may be a
     complete single section display area.

     All graphic operations will be rendered into a background display
     and automatic display buffer switching is performed, ensuring
     flicker-free sprites.

     The display background is fully redrawn from the third buffer
     each frame, saving the necessity for each sprite to have its
     background restored.

     This mode is useful when there are so many sprites on screen that
     it becomes more efficient to redraw the whole background with a
     single "blit" than to save and restore each sprite individually.
     With just a few sprites on screen a double buffered display would
     usually be more efficient.

     In terms of memory useage, this mode allocates twice the memory
     required for a single display as defined in the display Slice
     structure PLUS the third display buffer which will usually be
     oversize.  Although the third oversize buffer takes extra memory,
     the display double buffered system need not be oversize.  This
     means that it depends on particular dimesions as to whether triple
     buffering takes more memory then double buffering.

---------------------------
SliceControl collision mask
---------------------------

If you are intending to perform collision detection on the background
display in any slice you need to use the MAKESLICEMASK (see below) command
to automatically generate a collision mask plane.


************************************************************
A summary of the steps involved in creating a HeliOS display
************************************************************

1.  Define all display parameters, preferably as named constants
2.  Allocate all required Display/Slice data structures
3.  Allocate all required RasInfo structures using OPENRASINFO
4.  Possibly allocate ColourMap structures (Optional)
5.  Possibly load or create imagery for display (Optional)
6.  Link all display structures by setting up mutual pointers etc.
7.  Initialise all display structures by storing parameters in fields
8.  Generate copper lists for slices using MAKECOPSTRIP
9.  Generate copper lists for display using MAKEDISPLAY
10. Possibly make SliceControl structures using MAKESLICECONTROL (Optional)
11. Possibly generate a collision mask using MAKESLICEMASK (Optional)
12. Possibly install SliceControls using INSTALLSLICECONTROL (Optional)
13. Switch on HeliOS operating system using HELIOS_ON
14. Install the display using SHOWDISPLAY
15. Use the display.......
16. Switch off HeliOS operating system using HELIOS_OFF
17. Deallocate everything in reverse order

*************************************************************
Short code examples for allocating and initialising a display
*************************************************************

--------------
Simple display
--------------

Here is a fragment of code which sets up and links together a full set of
display definition data structures for a single slice display:

  \ ****************************************
  \ Create display pointer storage variables
  \ ****************************************

  \ Here we create a set of "pointers", initially set to a "null" value.
  \
  \ These "pointers" are set up as "long addresses" when various components
  \ of the display system are allocated and initialised.
  \
  \ Note that initially these are all set to zero, and we clear them back
  \ to zero when we de-allocate the associated resource.
  \
  \ These DPOINTERs are all initially set to "null" by using '0.'.
  \
  \ When we allocate memory or Amiga system resources in the program at
  \ run-time, these pointers are updated to contain the 32-bit address
  \ of the newly allocated resource.
  \
  \ Subsequently the symbolic DPOINTER name can be used in your code to
  \ represent the associated address.

  0. DPOINTER Display1             \ Main Display structure pointer
  0. DPOINTER Slice1               \ Slice 1 Slice structure pointer

  0. DPOINTER Slice1_RasInfo       \ Slice 1 RasInfo structure pointer

  0. DPOINTER Slice1_BMap          \ Slice 1 BitMap structure pointer

  0. DPOINTER Slice1_ColorMap      \ Slice 1 ColourMap structure pointer

  0. DPOINTER Slice1_SliceControl  \ Slice 1 SliceControl structure pointer

  \ ***********************************
  \ Create Display and Slice structures
  \ ***********************************

  : CREATE_DSLICES

  \ Allocate structures

  DS_SIZEOF MAKESTRUCTURE Display1 MAKEPOINTER  \ Main "Display" structure

  SL_SIZEOF MAKESTRUCTURE Slice1   MAKEPOINTER  \ Display "Slice" structure

  ;

  : FREE_DSLICES

  Slice1    DDUP FREEMEMORY   CLEARPOINTER
  Display1  DDUP FREEMEMORY   CLEARPOINTER
  ;

  \ ******************************
  \ Create RasInfo structures etc.
  \ ******************************

  : CREATE_RASINFO

  \ First allocate and initialise complete RasInfo structures.
  \
  \ This routine automatically allocates all BitMaps etc.
  \

  Slice1RasterWidth Slice1RasterHeight Slice1Planes  OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo1"
  Slice1_RasInfo MAKEPOINTER

  \ Set invisible area "sprite margins" for slice RasInfo, which allows
  \ software sprites to be rendered partially "off-screen".
  \
  \ Setting the RasInfo offset parameters effectively sets the position
  \ of the visible display offset 16 pixels in each direction within a
  \ larger bitplane area, as explained above.

  16              Slice1_RasInfo         ri_RxOffset    INDEX!L
  16              Slice1_RasInfo         ri_RyOffset    INDEX!L

  \ Store BitMap pointer - often useful for later reference

  Slice1_RasInfo  ri_BitMap INDEXD@L Slice1_BMap MAKEPOINTER
  ;

  \ ********************************
  \ Create Display/Slice Copperlists
  \ ********************************

  \ This function builds the main display copperlist by:
  \
  \ 1. Initialising the Slice data structure with its working parameters
  \ 2. Calling MAKECOPSTRIP for the slice, to build a copperlist
  \ 3. Calling MAKEDISPLAY to build the master Display copperlist
  \

  : CREATE_DISPLAY

  \ Initialise structures

  Slice1                           Display1  DS_Slice     INDEXD!L

  Slice1Width                      Slice1    SL_DWidth    INDEX!L
  Slice1Height                     Slice1    SL_DHeight   INDEX!L
  DisplayTopLine                   Slice1    SL_DyOffset  INDEX!L
  Slice1_RasInfo                   Slice1    SL_RasInfo   INDEXD!L
  Slice1_ColorMap                  Slice1    SL_ColorMap  INDEXD!L
  Slice1Mode                       Slice1    SL_Modes     INDEX!L

  \ Generate copper list information for each of the display slices

  Slice1 MAKECOPSTRIP
  D0= ERROR" Fail: Slice1CopStrip"

  \ Generate copper list information for main display

  Display1 MAKEDISPLAY
  D0= ERROR" Fail: Display1"
  ;

  : FREE_DISPLAY

  Display1                 FREEDISPLAY
  Slice1                   FREECOPSTRIP
  ;

  \ **************************************************************
  \ Actually set up the display, start HeliOS and show the display
  \ **************************************************************

  CREATE_DSLICES
  CREATE_RASINFO
 \ CREATE_IMAGERY    (Optional - this function should set up ColorMap)
  CREATE_DISPLAY

  HeliOS_On

  Display1 SHOWDISPLAY

---------------
Complex display
---------------

Here is a fragment of code which sets up and links together a full set of
display definition data structures for a complex multi-slice display with
one dual-playfield slice:

  \ **************************************
  \ Create display configuration constants
  \ **************************************
  \
  \ Collect all "display-specific" parameters here and generate "named"
  \ constants which make references easier than using numeric values.
  \
  \ Collecting these together here makes it easier to adjust things at any
  \ time without having to search source code to replace values individually.
  \

  256                      CONSTANT DisplayHeight      \ Full PAL display
  44                       CONSTANT DisplayTopLine     \ Display start

 \ The top slice is a scrolling display area with two 8-colour playfields
 \
 \ A-slice = foreground playfield and B-slice = background playfield
 \
 \ The B-slice has extra-wide horizontal raster size (640 pixels) to allow
 \ for horizontal scrolling, with an additional 320 pixels width to allow
 \ for horizontal smooth wrapping.
 \
 \ The A-slice does not scroll.
 \

  320                      CONSTANT Slice1Width        \ Lores width
  30                       CONSTANT Slice1Height       \ Top slice height
  30                       CONSTANT Slice1RasterHeight \ Raster=sliceheight
  WORDINCLUDE
  V_DUALPF                 CONSTANT Slice1Mode         \ Top slice screenmode
  LONGINCLUDE

  320                      CONSTANT Slice1ARasterWidth \ Raster=screenwidth
  3                        CONSTANT Slice1APlanes      \ A-slice bitplanes
  2 Slice1APlanes 1- LSL   CONSTANT Slice1AColours     \ A-slice colours

  640 320 +                CONSTANT Slice1BRasterWidth \ Scroll plane width
  3                        CONSTANT Slice1BPlanes      \ B-slice bitplanes
  2 Slice1BPlanes 1- LSL   CONSTANT Slice1BColours     \ B-slice colours

 \ The middle slice is a scrolling play area and has two 8 colour playfields
 \
 \ A-slice = foreground playfield and B-slice = background playfield
 \
 \ Both these slices have extra-wide horizontal raster size to allow for
 \ horizontal scrolling (1280 pixels), and an additional 320 pixels for
 \ horizontal smooth wrapping.
 \
 \ These slices both also have 16 pixel extra border areas to allow
 \ rendering of partially off-screen BOBs, since this would normally be
 \ a main game play area.
 \

  320                      CONSTANT Slice2Width        \ Lores width
  170                      CONSTANT Slice2Height       \ Middle slice height
  170 32 +                 CONSTANT Slice2RasterHeight \ Middle bitplane height
  WORDINCLUDE
  V_DUALPF                 CONSTANT Slice2Mode         \ Middle screenmode
  LONGINCLUDE

  1280 320 + 32 +          CONSTANT Slice2ARasterWidth \ A-slice scroll-raster
  3                        CONSTANT Slice2APlanes      \ A-slice planes
  2 Slice2APlanes 1- LSL   CONSTANT Slice2AColours     \ A-slice colours

  640 320 + 32 +           CONSTANT Slice2BRasterWidth \ B-slice scroll-raster
  3                        CONSTANT Slice2BPlanes      \ B-slice planes
  2 Slice2BPlanes 1- LSL   CONSTANT Slice2BColours     \ B-slice colours

 \ The bottom slice is an ordinary single playfield with 32 colours

  640                      CONSTANT Slice3Width        \ Hires width
  640                      CONSTANT Slice3RasterWidth  \ Raster=screenwidth

  DisplayHeight
  Slice1Height -
  Slice2Height -           CONSTANT Slice3Height       \ Bottom slice height

  4                        CONSTANT Slice3Planes       \ Bottom slice planes
  2 Slice3Planes 1- LSL    CONSTANT Slice3Colours      \ Bottom slice colours
  WORDINCLUDE
  V_HIRES                  CONSTANT Slice3Mode         \ Bottom slice screenmode
  LONGINCLUDE

  \ ********************************
  \ Create pointer storage variables
  \ ********************************

  \ Here we create a set of "pointers", initially set to a "null" value.
  \
  \ These "pointers" are set up as "long addresses" when various components
  \ of the display system are allocated and initialised.
  \
  \ Note that initially these are all set to zero, and we clear them back
  \ to zero when we de-allocate the associated resource.
  \
  \ These DPOINTERs are all initially set to "null" by using '0.'.
  \
  \ When we allocate memory or Amiga system resources in the program at
  \ run-time, these pointers are updated to contain the 32-bit address
  \ of the newly allocated resource.
  \
  \ Subsequently the symbolic DPOINTER name can be used in your code to
  \ represent the associated address.

  0. DPOINTER Display1             \ Main Display structure pointer
  0. DPOINTER Slice1               \ Slice 1 Slice structure pointer
  0. DPOINTER Slice2               \ Slice 2 Slice structure pointer
  0. DPOINTER Slice3               \ Slice 3 Slice structure pointer

  0. DPOINTER Slice1_ColorMap      \ Slice 1 ColourMap structure pointer
  0. DPOINTER Slice2_ColorMap      \ Slice 2 ColourMap structure pointer
  0. DPOINTER Slice3_ColorMap      \ Slice 3 ColourMap structure pointer

  0. DPOINTER Slice1A_RasInfo      \ Slice 1A RasInfo structure pointer
  0. DPOINTER Slice1B_RasInfo      \ Slice 1B RasInfo structure pointer
  0. DPOINTER Slice2A_RasInfo      \ Slice 2A RasInfo structure pointer
  0. DPOINTER Slice2B_RasInfo      \ Slice 2B RasInfo structure pointer
  0. DPOINTER Slice3_RasInfo       \ Slice 3  RasInfo structure pointer

  0. DPOINTER Slice1A_BMap         \ Slice 1A BitMap structure pointer
  0. DPOINTER Slice1B_BMap         \ Slice 1B BitMap structure pointer
  0. DPOINTER Slice2A_BMap         \ Slice 2A BitMap structure pointer
  0. DPOINTER Slice2B_BMap         \ Slice 2B BitMap structure pointer
  0. DPOINTER Slice3_BMap          \ Slice 3  BitMap structure pointer

  0. DPOINTER Slice1A_SliceControl \ Slice 1A SliceControl structure pointer
  0. DPOINTER Slice1B_SliceControl \ Slice 1B SliceControl structure pointer
  0. DPOINTER Slice2A_SliceControl \ Slice 2A SliceControl structure pointer
  0. DPOINTER Slice2B_SliceControl \ Slice 2B SliceControl structure pointer


  \ ***********************************
  \ Create Display and Slice structures
  \ ***********************************

  \ This routine simple makes blank structures, which then need to be
  \ initialised in the CREATE_DISPLAY routine below.

  : CREATE_DSLICES

  DS_SIZEOF MAKESTRUCTURE Display1 MAKEPOINTER  \ Main "Display" structure

  SL_SIZEOF MAKESTRUCTURE Slice1   MAKEPOINTER  \ Top    "Slice" structure
  SL_SIZEOF MAKESTRUCTURE Slice2   MAKEPOINTER  \ Middle "Slice" structure
  SL_SIZEOF MAKESTRUCTURE Slice3   MAKEPOINTER  \ Bottom "Slice" structure
  ;

  : FREE_DSLICES

  Slice3    DDUP FREEMEMORY   CLEARPOINTER
  Slice2    DDUP FREEMEMORY   CLEARPOINTER
  Slice1    DDUP FREEMEMORY   CLEARPOINTER
  Display1  DDUP FREEMEMORY   CLEARPOINTER
  ;

  \ ******************************
  \ Create RasInfo structures etc.
  \ ******************************

  : CREATE_RASINFO

  \ First allocate and initialise complete RasInfo structures.
  \
  \ This routine automatically allocates all BitMaps etc.
  \

  Slice1ARasterWidth Slice1RasterHeight  Slice1APlanes   OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo1A"
  Slice1A_RasInfo MAKEPOINTER

  Slice1BRasterWidth Slice1RasterHeight  Slice1BPlanes   OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo1B"
  Slice1B_RasInfo MAKEPOINTER

  Slice2ARasterWidth Slice2RasterHeight Slice2APlanes    OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo2A"
  Slice2A_RasInfo MAKEPOINTER

  Slice2BRasterWidth Slice2RasterHeight Slice2BPlanes    OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo2B"
  Slice2B_RasInfo MAKEPOINTER

  Slice3RasterWidth  Slice3Height  Slice3Planes          OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo3"
  Slice3_RasInfo MAKEPOINTER

  \ Set invisible area "sprite margins" for middle slice RasInfo

  16              Slice2A_RasInfo         ri_RxOffset    INDEX!L
  16              Slice2A_RasInfo         ri_RyOffset    INDEX!L

  16              Slice2B_RasInfo         ri_RxOffset    INDEX!L
  16              Slice2B_RasInfo         ri_RyOffset    INDEX!L

  \ Link Dual Playfield RasInfo structures

  Slice1B_RasInfo Slice1A_RasInfo         ri_Next        INDEXD!L
  Slice2B_RasInfo Slice2A_RasInfo         ri_Next        INDEXD!L

  \ Store BitMap pointers - often useful for later reference

  Slice1A_RasInfo  ri_BitMap INDEXD@L Slice1A_BMap MAKEPOINTER

  Slice1B_RasInfo  ri_BitMap INDEXD@L Slice1B_BMap MAKEPOINTER

  Slice2A_RasInfo  ri_BitMap INDEXD@L Slice2A_BMap MAKEPOINTER

  Slice2B_RasInfo  ri_BitMap INDEXD@L Slice2B_BMap MAKEPOINTER

  Slice3_RasInfo   ri_BitMap INDEXD@L Slice3_BMap  MAKEPOINTER
  ;

  : FREE_RASINFO

  Slice3_RasInfo    DDUP CLOSERASINFO   CLEARPOINTER
  Slice2B_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice2A_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice1B_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice1A_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  ;

  \ ************************
  \ Create Slice Copperlists
  \ ************************

  \ This function builds the main display copperlist by:
  \
  \ 1. Initialising the individual Slice data structures
  \ 2. Calling MAKECOPSTRIP for each slice, to build Slice copperlists
  \ 3. Calling MAKEDISPLAY to build the master Display copperlist
  \

  : CREATE_DISPLAY

  \ First initialise main display structures

  Slice1                           Display1  DS_Slice     INDEXD!L

  Slice2                           Slice1    SL_Next      INDEXD!L
  Slice1Width                      Slice1    SL_DWidth    INDEX!L
  Slice1Height                     Slice1    SL_DHeight   INDEX!L
  DisplayTopLine                   Slice1    SL_DyOffset  INDEX!L
  Slice1A_RasInfo                  Slice1    SL_RasInfo   INDEXD!L
  Slice1_ColorMap                  Slice1    SL_ColorMap  INDEXD!L
  Slice1Mode                       Slice1    SL_Modes     INDEX!L

  Slice3                           Slice2    SL_Next      INDEXD!L
  Slice2Width                      Slice2    SL_DWidth    INDEX!L
  Slice2Height                     Slice2    SL_DHeight   INDEX!L
  Slice1Height DisplayTopLine + 1+ Slice2    SL_DyOffset  INDEX!L
  Slice2A_RasInfo                  Slice2    SL_RasInfo   INDEXD!L
  Slice2_ColorMap                  Slice2    SL_ColorMap  INDEXD!L
  Slice2Mode                       Slice2    SL_Modes     INDEX!L

  Slice3Width                      Slice3    SL_DWidth    INDEX!L
  Slice3Height                     Slice3    SL_DHeight   INDEX!L

  Slice1Height Slice2Height +
  DisplayTopLine + 2+              Slice3    SL_DyOffset  INDEX!L

  Slice3_RasInfo                   Slice3    SL_RasInfo   INDEXD!L
  Slice3_ColorMap                  Slice3    SL_ColorMap  INDEXD!L
  Slice3Mode                       Slice3    SL_Modes     INDEX!L

  \ Generate copper list information for each of the display slices

  Slice1 MAKECOPSTRIP
  D0= ERROR" Fail: Slice1CopStrip"
  Slice2 MAKECOPSTRIP
  D0= ERROR" Fail: Slice2CopStrip"
  Slice3 MAKECOPSTRIP
  D0= ERROR" Fail: Slice3CopStrip"

  \ Make display

  Display1 MAKEDISPLAY
  D0= ERROR" Fail: Display1"
  ;

  : FREE_DISPLAY

  Display1                 FREEDISPLAY
  Slice3                   FREECOPSTRIP
  Slice2                   FREECOPSTRIP
  Slice1                   FREECOPSTRIP
  ;

  \ ***************************************************
  \ Create SliceControl structures for scrolling slices
  \ ***************************************************

  \
  \ In this case we have two slices which scroll horizontally, each with
  \ automatic wrap.
  \
  \ The front middle slice playfield in this case is double buffered to
  \ allow smooth BOB rendering as a game main playfield.
  \

  : CREATE_SLICECONTROLS

  \ Make two top Dual-Playfield SliceControls, each playfield with standard
  \ single buffered bitmap displays, as indicated by "-1" parameters

  Slice1  -1 -1 -1 -1 MAKEDPSLICECONTROL
  DFLAG0= ERROR" Fail: SliceControl1"
  Slice1A_SliceControl MAKEPOINTER

  \ Get second dual playfield SliceControl pointer

  Slice1A_SliceControl SliceControl_DPSControl2 INDEXD@L
  Slice1B_SliceControl MAKEPOINTER

  \ Set BPLCON2 control value

  [ BIN ] 100100 [ DECIMAL ]
  Slice1A_SliceControl    SliceControl_BPLCON2     INDEX!L

  \ Set up rear playfield for automatic horizontal smooth wrapping

  1 Slice1B_SliceControl  SliceControl_HWrapFlag   INDEX!L

  \ Make middle two Dual-Playfield SliceControls, the rear playfield with
  \ a standard single buffered bitmap display, configured by "-1" parameters,
  \ and the front one with a double buffered display, configured by the 0
  \ parameters.

  Slice2  0  0 -1 -1 MAKEDPSLICECONTROL
  DFLAG0= ERROR" Fail: SliceControl2"
  Slice2A_SliceControl MAKEPOINTER

  \ Get second dual playfield slice control

  Slice2A_SliceControl    SliceControl_DPSControl2 INDEXD@L
  Slice2B_SliceControl MAKEPOINTER

  \ Set BPLCON2 control value

  [ BIN ] 100100 [ DECIMAL ]
  Slice2A_SliceControl    SliceControl_BPLCON2     INDEX!L

  \ Set up both playfields for automatic horizontal smooth wrapping

  1 Slice2A_SliceControl  SliceControl_HWrapFlag   INDEX!L
  1 Slice2B_SliceControl  SliceControl_HWrapFlag   INDEX!L

  \ Install display movement control word

  (MoveDisplay) @ Slice2A_SliceControl SliceControl_BeforeForth INDEX!L

  \ Install slice controls into HeliOS display control system

  Slice1A_SliceControl  INSTALLSLICECONTROL
  Slice1B_SliceControl  INSTALLSLICECONTROL
  Slice2A_SliceControl  INSTALLSLICECONTROL
  Slice2B_SliceControl  INSTALLSLICECONTROL
  ;

  : FREE_SLICECONTROLS

  CLEARSLICECONTROLS
  Slice2B_SliceControl  CLOSESLICECONTROL
  Slice2A_SliceControl  CLOSESLICECONTROL
  Slice1B_SliceControl  CLOSESLICECONTROL
  Slice1A_SliceControl  CLOSESLICECONTROL
  ;

  \ **************************************************************
  \ Actually set up the display, start HeliOS and show the display
  \ **************************************************************

  CREATE_DSLICES
  CREATE_RASINFO
 \ CREATE_IMAGERY    (Optional - this function should set up ColorMap)
  CREATE_DISPLAY
  CREATE_SLICECONTROLS

  HeliOS_On

  Display1 SHOWDISPLAY

*********************************************************
A summary of the commands used to set up a HeliOS display
*********************************************************

  MAKECOPSTRIP

  ( Slice(l) _ _ _ Slice(l) or null )

  Takes the display parameters defined within the Slice structure and
  creates an appropriate copper list.  The copper list is installed in
  the Slice structure if successful and the Slice pointer is returned.

  On failure null is returned.


  FREECOPSTRIP

  ( Slice(l) _ _ _  )

  Removes and frees a Slice structure's copper list which was created
  by using the HeliOS MAKECOPSTRIP function.

-----------------------------------------------------------------------

  MAKEDISPLAY

  ( Display(l) _ _ _ Display(l) or null )

  Takes the display parameters defined within the Display and all its
  associated Slice structures and creates a master display copperlist.

  The copper list is installed in the Display structure if successful
  and the Display pointer is returned.

  On failure null is returned.


  FREEDISPLAY

  ( Display(l) _ _ _  )

  Removes and frees a Display structure's copper list which was created
  by using the HeliOS MAKEDISPLAY function.


  SHOWDISPLAY

  ( Display(l) _ _ _  )

  Installs this display as the current HeliOS active display.

-----------------------------------------------------------------------

  MAKESLICECONTROL

  ( Slice(l), Width(w), Height(w) _ _ _ SliceControl(l) or null )

  Makes a SliceControl structure to be used in double/triple buffering
  and scroll functions.

  All extra display structures, bitplanes etc. are allocated and
  initialised fully automatically as required.

  On success a pointer to the new SliceControl structure is returned.

  On failure null is returned.

  After making a SliceControl structure all you need to do is INSTALL
  this control structure using INSTALLSLICECONTROL, upon which all
  double/triple buffering and scroll functions in this display slice
  will be carried out automatically by the HeliOS operating system.

  The width and height parameters determine whether this will be a
  single, double, or triple buffered slice, as follows:

  1. If Width and Height are both zero.

     This slice is a double buffered slice, which means that two
     complete display buffers as defined by the Slice structure will
     be allocated.

     All graphic operations will be rendered into a background display
     and automatic display buffer switching is performed, ensuring
     flicker-free sprites.

     Each sprite/BOB must have its background saved and restored for
     each frame.

     The double buffered display area may be mapped from 16x16 blocks
     or it may be a complete single section display area.

     This mode is useful when there are NOT so many sprites on screen
     that it becomes more efficient to redraw the whole background
     with a single "blit" than to save and restore the background for
     each sprite individually.  If there are many sprites on screen
     a triple buffered display may be more efficient.  See below.

     In terms of memory useage, this mode allocates twice the memory
     required for a single display as defined in the display Slice
     structure.

  2. If Width and Height are both negative.

     No further display buffers are allocated since this slice is a
     single buffered slice, so all graphic rendering will be drawn
     immediately into the bitplanes being displayed.

     This can result in flickery graphics and is not recommended for
     games with many moving objects.

     Each sprite/BOB must have its background saved and restored for
     each frame.

     The single buffer display area may be mapped from 16x16 blocks
     or it may be a complete single section display area.

     In terms of memory useage, this mode allocates just the memory
     required for a single display as defined in the display Slice
     structure.

  3. If Width and Height are both positive.

     This slice is a triple buffered slice, which means that a double
     buffered display will be created, as well as a third oversized
     display buffer with "Width x Height" size parameters.

     The double buffered screen, into which sprite graphics etc. are
     rendered has dimensions as specified in the Slice structure.

     The third "triple" buffer contains the full background graphics
     which are always kept fully intact, so when each double buffered
     frame is redrawn the background graphics can be restored as a
     complete single-blit area from the third buffer.

     The third buffer may be "oversize" so that the display can scroll
     around it horizontally and vertically.

     The third buffer may be mapped from 16x16 blocks or it may be a
     complete single section display area.

     All graphic operations will be rendered into a background display
     and automatic display buffer switching is performed, ensuring
     flicker-free sprites.

     The display background is fully redrawn from the third buffer
     each frame, saving the necessity for each sprite to have its
     background restored.

     This mode is useful when there are so many sprites on screen that
     it becomes more efficient to redraw the whole background with a
     single "blit" than to save and restore each sprite individually.
     With just a few sprites on screen a double buffered display would
     usually be more efficient.

     In terms of memory useage, this mode allocates twice the memory
     required for a single display as defined in the display Slice
     structure PLUS the third display buffer which will usually be
     oversize.  Although the third oversize buffer takes extra memory,
     the display double buffered system need not be oversize.  This
     means that it depends on particular dimesions as to whether triple
     buffering takes more memory then double buffering.


  MAKEDPSLICECONTROL

  ( Slice(l), Wid(w), Hgt(w), Wid(w), Hgt(w)_ _ _SliceCtrl(l) or null )

  Makes a pair of cross-linked SliceControl structures to be used in
  double/triple buffering for dual playfield slices.

  See documentation for MAKESLICECONTROL for general useage.

  The difference with MAKEDPSLICECONTROL is that you have two sets of
  Width and Height parameters, each of which sets up one of the two
  dual playfield slices.

  The SliceControl structure returned is the control structure for the
  first playfield, using the first two Width and Height parameters.

  A second SliceControl structure is also allocated and cross-linked
  into the first structure.  This means that each dual playfield
  SliceControl structure contains a pointer to the corresponding
  SliceControl for the other playfield:

  * The "SliceControl_DPSControl2" field of the first SliceControl
    structure holds a pointer to the second SliceControl structure.

  * The "SliceControl_DPSControl1" field of the second SliceControl
    structure holds a pointer to the first SliceControl structure.

  If you need to gain access to the second structure, simply extract
  the pointer from the first structure, like this:

  SliceControl1A D@
  SliceControl_DPSControl2 INDEXD@L
  SliceControl1B D!


  CLEARSLICECONTROLS

  ( - - - )

  Removes any remaining active slice control structures from the HeliOS
  game system interrupt handler.


  CLOSESLICECONTROL

  ( SliceControl(l) - - - )

  Closes down a SliceControl structure, deallocating all resources
  created using MAKESLICECONTROL.

  Note that dual playfield slices need to have this function called
  for BOTH of the dual playfield SliceControl structures individually.


  INSTALLSLICECONTROL

  ( SliceControl(l) - - - )

  Installs a SliceControl structure into the HeliOS operating system.

  Having done this all sprite rendering will be automatically double
  or triple buffered as requested, and scrolling can be carried out
  using simple scroll commands or by setting appropriate fields in
  the SliceControl structure.

  The SliceControl structure should be deactivated by using the
  REMOVESLICECONTROL command.


  REMOVESLICECONTROL

  ( SliceControl(l) - - - )

  Removes a SliceControl structure from the HeliOS operating system.

  See also INSTALLSLICECONTROL.


  MAKESLICEMASK

  ( SliceControl(l) - - - BitMap(l) or null )

  Makes and installs a collision mask for the SliceControl structure,
  allowing Object-to-Display collision detection for that slice.

  On failure null is returned.

  The collision mask is a "shadow" mask constructed from all bits set
  in all bitplanes.

  This function installs the collision mask into the SliceControl
  structure automatically and any previous collision mask is first
  automatically deallocated.

  The function also returns a pointer to a BitMap structure which
  defines the mask plane: this allows you to perform any operations
  you wish on the collision mask.

  You must deallocate the mask BitMap using CLOSEBMAP when you have
  finished with it.

***************************************************************************
End
***************************************************************************
