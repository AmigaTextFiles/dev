
                    *******************************
                    HeliOS Path generation routines
                    *******************************

************
Introduction
************

The HeliOS path generation routines are part of the interrupt-driven game
operating system and function as one of the HeliOS "motor" routines.

These are fast optimised machine coded routines which can be controlled
entirely by pre-defined data structures.

These functions only work in HeliOS mode.

HeliOS path functions allow fast and efficient generation of numeric
sequences derived from pre-defined data lists, and run synchronously with
other functions performed by the interrupt driven HeliOS system.

The basic idea is that the path functions step backwards or forwards
along a set of data values under programmable control, generating and
(optionally) distributing derived results to definable target locations.

Using pre-defined control data structures, along with direct programmability
if required, you can generate a number of different path control functions.

These routines have many applications, in particular they allow easy and
accurately timed generation of motion paths for graphical objects which
may be cross-linked to allow the motion of one object to control or affect
that of another object.  There are many other applications for paths.

It is impossible to list all the possible ways of using these highly
flexible routines, and it will be easier to see the potential of this
system after examining how it works.

It is worth pointing out that all HeliOS motor functions are not only
pre-programmable, but they operate in a mutually self-programming way by
allowing "modifiers" and "results" to operate on other motors.  In other
words input and output from motor programs do not only work with parameters 
stored in their own "private" data structures: motors can also read inputs
and distribute results by interacting with control data structure fields
of other motors or any other computed objects.

This INDIRECTION of input and output, a feature common to ALL HeliOS
data objects, allows complex interlinking and self-programmability.

The mutual self-programmability of HeliOS objects means that the results
of one operation can be used to automatically program another, which in
turn can (re)act on the first....and so on.

All this can be set up to work automatically without you having to do any
intermediate programming to manage all the interactions.

This means, in other words, that all HeliOS motors can PROGRAM EACH OTHER,
so that input or output data can be modified by other motor functions and
can in turn program other motors.

This mutual programmability combined with the BEFORE and AFTER functions
give the HeliOS motor functions considerable power from ultra fast and very
simple routines.


******
Timing
******

It is an important consideration that all motor functions are fully
synchronised with all other HeliOS internally automated functions and
with the display frame rate.

Motors are run in the order in which they are installed: you must remember
this if you are using one motor function to modify another.


******************
Control structures
******************

The main PATH control structure is as follows:

----------------------
PATH control structure
----------------------

Path_BeforeForth(w) = HeliOS CFA to run BEFORE each path calculation
Path_BeforeCode(l)  = Machine code to run BEFORE each path calculation
Path_AfterForth(w)  = HeliOS CFA to run AFTER each path calculation
Path_AfterCode(l)   = Machine code to run AFTER each path calculation
Path_Flags(w)       = Control flags word ( See below)
Path_CountDown(w)   = Countdown time (If non-zero sets countdown)
Path_CDFlags(w)     = Countdown flags word (-> "Flags" at CountDown time)
Path_CDForth(w)     = Countdown HeliOS function CFA (optional)
Path_CDCode(l)      = Countdown machine code function pointer (optional)
Path_SkipTimer(w)   = Path skip internal timer register
Path_SkipCount(w)   = Path skip count = How many "ticks" to skip (0=Do all)
Path_ID(w)          = Motor handler ID = 1 for PATH
Path_Count(w)       = Number of path positions
Path_Pos(w)         = Current path position
Path_PosSkip(w)     = Path position skip value for each iteration (+ or -)
Path_DataCount(w)   = Number of sub-path data sections
Path_Data(l)        = Path sub-path data list pointer
Path_UserDataPtr(l) = Free user data pointer
Path_UserData1(w)   = Free user data1
Path_UserData2(w)   = Free user data2
Path_UserData3(w)   = Free user data3
Path_UserData4(w)   = Free user data4
Path_UserData5(w)   = Free user data5
Path_UserData6(w)   = Free user data6
Path_UserStatus(w)  = Free user status


Here is an amplified description of each field:

Path_BeforeForth   This field, if non-null, contains the CFA af a HeliOS
                   command which will be run BEFORE each iteration of the
                   Path function.

                   A 32-bit pointer to the Path control structure will
                   be placed on the stack when the HeliOS BEFORE command
                   is called, so you must take care to clear the stack.

Path_BeforeCode    This field, if non-null, contains a pointer to a machine
                   code routine which will be run BEFORE each iteration of
                   the Path function.

                   A 32-bit pointer to the Path control structure will
                   be placed in address register A0 when the BEFORE
                   command code is called.

Path_AfterForth    This field, if non-null, contains the CFA af a HeliOS
                   command which will be run AFTER each iteration of the
                   Path function.

                   A 32-bit pointer to the Path control structure will
                   be placed on the stack when the HeliOS AFTER command
                   is called, so you must take care to clear the stack.

Path_AfterCode     This field, if non-null, contains a pointer to a machine
                   code routine which will be run AFTER each iteration of
                   the Path function.

                   A 32-bit pointer to the Path control structure will
                   be placed in address register A0 when the AFTER command
                   code is called.

Path_Flags         This field contains the Path function control flags.

                   The following function control flags are available:

                   -3  = SelfRemove at once

                   0   = Skip Path function
                   "Before" functions still run in "Skip" mode.

                   1  = Go to path beginning and stop
                   2  = Go to path end and stop
                   3  = Go to path start
                   4  = Go to path end
                   5  = Reverse current path direction
                   6  = Set "Loop" mode
                   7  = Set "Shuttle" mode
                   8  = Stop at end of pass
                   9  = At end of pass reset to end and stop running
                   10 = At end of pass reset to start and stop running

                   e.g.

                   A flags value of "6" would give a free running cyclic
                   path motion which simply restarts at the beginning after
                   each complete sequence.

Path_CountDown     Sets up a CountDown, so that after the number of "ticks"
                   specified in this field the CDFlags value will be stored
                   into the Flags field of the path command structure.

                   This function is switched off after each CountDown.

Path_CDFlags       If a CountDown is being done, the value in this field
                   will be placed in the "Flags" field of the path command
                   structure when the CountDown is complete.

Path_CDForth       This field contains either null or the CFA of a HeliOS
                   function which you wish to be executed after CountDown
                   has completed.

Path_CDCode        This field contains either null or a pointer to a machine
                   code routine which you wish to be executed after CountDown
                   has completed.

Path_SkipTimer     This field is used to store the internal timer status
                   of the path.

Path_SkipCount     This value gives the time delay between each iteration
                   of the path function.  The path will skip however many
                   "ticks" are specified here between each active cycle.

                   A SkipCount value of "0" gives full speed operation.

Path_ID            This MUST be set to "1", to identify the PATH function.

Path_Count         This is the number of data items constituting this path.

Path_Pos           This is the current position along the set of data items

Path_PosSkip       This is how many data items are "jumped" each time the
                   path function operates.

                   A PosSkip value of "1" gives one-by-one operation.

Path_DataCount     This specifies how many separate paths are processed by
                   the control structure.

                   Each control structure can drive an unlimited number of
                   individual paths, all of which must have similar size,
                   but each of which has different path data and outputs.

                   This means, for example, that one 20-position cyclic path
                   could be set working to generate values for 50 different
                   object paths.  The overall function control would step
                   through each of the 50 paths synchronously, generating
                   50 different values at each iteration.

                   More commonly, you might set up a twin path which could
                   generate X and Y coordinates for a moving object.

Path_Data          A pointer to the start of a table of path data structures
                   (defined below) each placed one after the other.

                   If the DataCount value were "4", for example, this field
                   would point to the first of 4 path data structures placed
                   one after the other in memory.

Path_UserDataPtr   This is a "free" field which you can use as you wish.
Path_UserData1     This is a "free" field which you can use as you wish.
Path_UserData2     This is a "free" field which you can use as you wish.
Path_UserData3     This is a "free" field which you can use as you wish.
Path_UserData4     This is a "free" field which you can use as you wish.
Path_UserData5     This is a "free" field which you can use as you wish.
Path_UserData6     This is a "free" field which you can use as you wish.
Path_UserStatus    This is a "free" field which you can use as you wish.

                   N.B.

                   These USER fields can be used in a very powerful way.

                   For example, fields here can store "modifiers" which in
                   turn affect path calculation and can affect other path
                   modifiers.  Some paths might be used to program directly
                   the modifiers for other paths, to give complex effects.


----------------
PathData structure
------------------

PathData_List(l)        = Pointer to a set of path data
PathData_ModifierPtr(l) = Pointer to a memory location to be added in
PathData_Result(w)      = Place where path result is stored
PathData_ResultPtr(l)   = Pointer to memory location where result is stored

Here is an amplified description of each field:

PathData_List          This field points to a simple linear array of 16-bit
                       data values along which the path function will step.

                       If the path length is 20, this data array would
                       consist of 20 16-bit values stores sequentially.

PathData_ModifierPtr   This field is either null, or contains a 32-bit
                       pointer to a value which will be added to the result
                       of the path evaluation.

PathData_Result        This field is where the 16-bit result of the path
                       calculation will be stored.

PathData_ResultPtr     This field is either null, or contains a 32-bit
                       pointer to a memory location where the result of
                       the path evaluation will be stored.

------------------
PathList structure
------------------

The path list is a simple linear array of 16-bit values.

Note that the same list can be used for any number of different paths.

PathList_Data(w)
PathList_Data(w)
PathList_Data(w)
PathList_Data(w)
PathList_Data(w)
etc. etc.
Up to Path_Count items


*********************************
HeliOS PATH control command words
*********************************

There are NO words specifically to control path functions.

All control is via the data structures detailed above.

Paths are started by using the expression:

  MyPath INSTALLMOTOR

Paths are stopped by using the expression:

  MyPath REMOVEMOTOR

**************
A path example
**************

  0. DPOINTER  ControlPath
  0. DPOINTER  ControlPathData

  0  VARIABLEL ControlPathResult
  -1 VARIABLEL ControlPathModifier

  \ Set up path data list

  CREATEL PathList

  0   ,
  4   ,
  8   ,
  12  ,
  16  ,
  20  ,
  24  ,
  28  ,
  32  ,
  36  ,
  40  ,
  44  ,
  48  ,
  52  ,
  56  ,
  60  ,
  64  ,
  68  ,
  72  ,
  76  ,
  80  ,
  84  ,
  88  ,
  92  ,
  96  ,
  100 ,
  104 ,
  108 ,
  112 ,
  116 ,

  \ -----------------
  \ Make Control Path
  \ -----------------

  Path_SIZEOF MAKESTRUCTURE
  DFLAG0= ERROR" Fail: ControlPath"
  DDUP ControlPath MAKEPOINTER
  SETSTRUCTURE1

  7                 Path_Flags     STRUCTURE1 !L   \ Set "shuttle" mode
  1                 Path_ID        STRUCTURE1 !L   \ ID = 1 for PATH
  28                Path_Count     STRUCTURE1 !L   \ 28 data items
  1                 Path_PosSkip   STRUCTURE1 !L   \ One at a time
  8                 Path_SkipCount STRUCTURE1 !L   \ Once every 8 ticks
  1                 Path_DataCount STRUCTURE1 !L   \ One path implemented

  PathData_SIZEOF MAKESTRUCTURE
  DFLAG0= ERROR" Fail: ControlPathData"

  DDUP Path_Data STRUCTURE1 D!L                    \ Install data pointer

  DDUP ControlPathData MAKEPOINTER
  SETSTRUCTURE1

  PathList             PathData_List         STRUCTURE1 D!L
  ControlPathModifier  PathData_ModifierPtr  STRUCTURE1 D!L
  0                    PathData_Result       STRUCTURE1 !L
  ControlPathResult    PathData_ResultPtr    STRUCTURE1 D!L

  ControlPath INSTALLMOTOR

  \ From now on the "PathData_Result" field and the "ControlPathResult"
  \ variable will be constantly updated according to path calculations.
  \
  \ Remember that this will only work in HeliOS mode.

*********************************************************************
End
*********************************************************************
