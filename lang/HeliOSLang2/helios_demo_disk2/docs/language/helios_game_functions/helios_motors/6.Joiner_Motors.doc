
                     ****************************
                     HeliOS JOINER motor routines
                     ****************************

************
Introduction
************

The HeliOS JOINER routines are part of the interrupt-driven game operating
system and function as one of the HeliOS "motor" routines.

These are fast optimised machine coded routines which can be controlled
entirely by pre-defined data structures.

These functions only work in HeliOS mode.

HeliOS JOINER functions allow fast and efficient performance of simple
calculations synchronously with other functions performed by the interrupt
driven HeliOS system.

JOINERs are designed to allow pairs of numbers specified by pointers to be
combined in various ways: by addition, subtraction, and simple "additive"
multiplication.

These JOINER functions allow interactions between data structures to be set
up which will run fully automatically in the background.

Using pre-defined control data structures, along with direct programmability
if required, you can generate a number of different control functions.

These routines have many applications, in particular they allow linkage
between events occurring in different sub-systems.

It is impossible to list all the possible ways of using these highly
flexible routines, and it will be easier to see the potential of this
system after examining how it works.

It is worth pointing out that all HeliOS motor functions are not only
pre-programmable, but they operate in a mutually self-programming way by
allowing "modifiers" and "results" to operate on other motors.  In other
words input and output from motor programs do not only work with parameters 
stored in their own "private" data structures: motors can also read inputs
and distribute results by interacting with control data structure fields
of other motors or any other computed objects.

This INDIRECTION of input and output, a feature common to ALL HeliOS
data objects, allows complex interlinking and self-programmability.

The mutual self-programmability of HeliOS objects means that the results
of one operation can be used to automatically program another, which in
turn can (re)act on the first....and so on.

All this can be set up to work automatically without you having to do any
intermediate programming to manage all the interactions.

This means, in other words, that all HeliOS motors can PROGRAM EACH OTHER,
so input or output data can be modified by other motor functions and can
in turn program other motors.

This mutual programmability combined with the BEFORE and AFTER functions
give the HeliOS motor functions considerable power from ultra fast and very
simple routines.

******
Timing
******

It is an important consideration that all motor functions are fully
synchronised with all other HeliOS internally automated functions and
with the display frame rate.

Motors are run in the order in which they are installed: you must remember
this if you are using one motor function to modify another.

******************
Control structures
******************

The main JOINER control structure is as follows:

------------------------
JOINER control structure
------------------------

Joiner_BeforeForth(w) = HeliOS CFA to run BEFORE each JOINER calculation
Joiner_BeforeCode(l)  = Machine code to run BEFORE each JOINER calculation
Joiner_AfterForth(w)  = HeliOS CFA to run AFTER each JOINER calculation
Joiner_AfterCode(l)   = Machine code to run AFTER each JOINER calculation
Joiner_Flags(w)       = Control flags word ( See below)
Joiner_CountDown(w)   = Countdown time (If non-zero sets countdown)
Joiner_CDFlags(w)     = Countdown flags word (-> "Flags" at CountDown time)
Joiner_CDForth(w)     = Countdown HeliOS function CFA (optional)
Joiner_CDCode(l)      = Countdown machine code function pointer (optional)
Joiner_SkipTimer(w)   = Joiner skip internal timer register
Joiner_SkipCount(w)   = Joiner skip count = How many "ticks" to skip (0=Do all)
Joiner_ID(w)          = Motor handler ID = 3 for JOINER
Joiner_Count(w)       = Number of JOINER data blocks
Joiner_Data(l)        = JOINER data list pointer
Joiner_UserDataPtr(l) = Free user data pointer
Joiner_UserData1(w)   = Free user data1
Joiner_UserData2(w)   = Free user data2
Joiner_UserData3(w)   = Free user data3
Joiner_UserData4(w)   = Free user data4
Joiner_UserData5(w)   = Free user data5
Joiner_UserData6(w)   = Free user data6
Joiner_UserStatus(w)  = Free user status

Here is an amplified description of each field:

Joiner_BeforeForth  This field, if non-null, contains the CFA af a HeliOS
                    command which will be run BEFORE each iteration of the
                    JOINER function.

                    A 32-bit pointer to the JOINER control structure will
                    be placed on the stack when the HeliOS BEFORE command
                    is called, so you must take care to clear the stack.

Joiner_BeforeCode   This field, if non-null, contains a pointer to a machine
                    code routine which will be run BEFORE each iteration of
                    the JOINER function.

                    A 32-bit pointer to the JOINER control structure will
                    be placed in address register A0 when the BEFORE
                    command code is called.

Joiner_AfterForth   This field, if non-null, contains the CFA af a HeliOS
                    command which will be run AFTER each iteration of the
                    JOINER function.

                    A 32-bit pointer to the JOINER control structure will
                    be placed on the stack when the HeliOS AFTER command
                    is called, so you must take care to clear the stack.

Joiner_AfterCode    This field, if non-null, contains a pointer to a machine
                    code routine which will be run AFTER each iteration of
                    the JOINER function.

                    A 32-bit pointer to the JOINER control structure will
                    be placed in address register A0 when the AFTER command
                    code is called.

Joiner_Flags        This field contains the JOINER function control flags.

                    The following function control flags are available:

                    -3  = SelfRemove at once
                    0   = Skip JOINER function

                    "Before" functions still run in "Skip" mode.

Joiner_CountDown    Sets up a CountDown, so that after the number of "ticks"
                    specified in this field the CDFlags value will be stored
                    into the Flags field of the JOINER command structure.

                    This function is switched off after each CountDown.

Joiner_CDFlags      If a CountDown is being done, the value in this field
                    will be placed in the "Flags" field of the JOINER
                    command structure when the CountDown is complete.

Joiner_CDForth      This field contains either null or the CFA of a HeliOS
                    function which you wish to be executed after CountDown
                    has completed.

Joiner_CDCode       This field contains either null or a pointer to a machine
                    code routine which you wish to be executed after the
                    CountDown has completed.

Joiner_SkipTimer    This field is used to store the internal timer status
                    of the JOINER motor.

Joiner_SkipCount    This value gives the time delay between each iteration
                    of the JOINER function.  The JOINER will skip however
                    many "ticks" are specified here between each active
                    cycle.

                    A SkipCount value of "0" gives full speed operation.

Joiner_ID           This MUST be set to "3", to identify the JOINER function.

Joiner_Count        The number of data items constituting this JOINER.

Joiner_Data         A pointer to the start of the sequence of JOINER data
                    structures associated with this control structure, as
                    defined below, each placed one after the other.

                    Each master JOINER control structure can drive an
                    unlimited number of individual JOINERs, each of which
                    has a different data structure.

Joiner_UserDataPtr  This is a "free" field which you can use as you wish.
Joiner_UserData1    This is a "free" field which you can use as you wish.
Joiner_UserData2    This is a "free" field which you can use as you wish.
Joiner_UserData3    This is a "free" field which you can use as you wish.
Joiner_UserData4    This is a "free" field which you can use as you wish.
Joiner_UserData5    This is a "free" field which you can use as you wish.
Joiner_UserData6    This is a "free" field which you can use as you wish.
Joiner_UserStatus   This is a "free" field which you can use as you wish.


--------------------
JoinerData structure
--------------------

JoinerData_Source1(l)   = Pointer to first source address
JoinerData_Source2(l)   = Pointer to second source address
JoinerData_Target(l)    = Pointer to target address
JoinerData_Length(w)    = Data length of operation
JoinerData_Modifier(w)  = Modifier

Here is an amplified description of each field:

JoinerData_Source1(l)   This field contains a pointer to the first source
                        address which holds the first of the two numbers
                        which will be combined by this JOINER.

JoinerData_Source2(l)   This field contains a pointer to the second source
                        address which holds the second of the two numbers
                        which will be combined by this JOINER.

JoinerData_Target(l)    This field contains a pointer to the target address
                        where the result of this JOINER calculation will be
                        placed.

JoinerData_Length(w)    This field specifies whether this operation is on
                        1, 2, or 4 byte values and should be set accordingly
                        to "1", "2", or "4".

JoinerData_Modifier(w)  This field specifies the JOINER "modifier", which
                        determines whether the JOINER will add or subtract
                        the two source numbers, and how many times etc.

                        Here are the actions of the modifier:

                        Modifier 0  -> Place 0 value into target
                        Modifier n  -> Add source numbers n times
                        Modifier -n -> Subtract source numbers n times


***********************************
HeliOS JOINER control command words
***********************************

There are NO words specifically to control JOINER functions.

All control is via the data structures detailed above.

JOINERs are started by using the expression:

  MyJoiner INSTALLMOTOR

JOINERs are stopped by using the expression:

  MyJoiner REMOVEMOTOR


*************
Using JOINERs
*************

Joiners are VERY easy to use and to set up.

First you need to allocate a master JOINER structure:

    Joiner_SIZEOF MAKESTRUCTURE  MyJoiner D!

or something similar......

Then you need to allocate at least one JOINER data structure:

    JoinerData_SIZEOF MAKESTRUCTURE MyJoinerData D!

Then you must set up the pointers and data structure values:

    MyJoinerData D@  MyJoiner D@ Joiner_Data INDEXD!L

    MyJoiner D@ SETSTRUCTURE1

    1    Joiner_Count     STRUCTURE1  !L
    1    Joiner_Flags     STRUCTURE1  !L
    1    Joiner_SkipCount STRUCTURE1  !L
    3    Joiner_ID        STRUCTURE1  !L

 \  Set up JOINER to subtract 4 x Source2 from Source1 and store in
 \  Target (16-bit).

    MyJoinerData D@ SETSTRUCTURE1

    Source1  JoinerData_Source1  STRUCTURE1 D!L
    Source2  JoinerData_Source2  STRUCTURE1 D!L
    Target   JoinerData_Target   STRUCTURE1 D!L
    2        JoinerData_Length   STRUCTURE1 !L
    -4       JoinerData_Modifier STRUCTURE1 !L

Then you must use INSTALLMOTOR when you want to start the JOINER process:

    MyJoiner D@ INSTALLMOTOR

...and REMOVEMOTOR when you want to stop the JOINER process:

    MyJoiner D@ REMOVEMOTOR

*********************************************************************
End
*********************************************************************
