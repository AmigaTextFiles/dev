
                        *******************
                        Collision Detection
                        *******************

           Collision detection ONLY functions in HeliOS mode!


  ************
  Introduction
  ************

  The HeliOS collision detection system is very powerful and flexible,
  and it is necessary to have a good overview of the whole scheme to
  make best use of all the functions available.  Please read the whole
  of this file at least once to get a good idea of how all the various
  functions fit together.

  HeliOS incorporates a pixel-to-pixel collision detection system which
  operates using single plane collision "shadow-masks" for all objects.

  In other words simple monochrome "shadow" images of all potentially
  colliding objects are compared with respect to relative positions to
  see if the "solid" parts of the shadow images overlap.

  Collision detection relies upon appropriate collision masks being
  available for all colliding objects.

  For sprite objects, normally, collision masks are generated for you
  fully automatically when objects are created and initialised, but for
  special applications you can supply your own masks if you wish to do so.

  Screen collision detection always requires the explicit creation of a
  shadow mask for each display slice you set up for collision detection.

  Object-to-object collisions always require the allocation of an automatic
  collision handler for each colliding object, but object-to-screen
  collisions require no collision handler allocation.

  Collision detection for any object is switched on and off using the
  "CollFlag" field in the object's data structure.  Placing any non-zero
  value in CollFlag will enable collision detection for that object, but
  see below for several further necessary conditions.

  Specific collision capability is controlled via two 32-bit collision
  masks, called the HitMask and MeMask.  These are similarly named to
  concepts used in the Amiga operating system, but the HeliOS functions
  are extended and work slightly differently.

  The HitMask/MeMask system allows you to set up specific different
  outcomes for 32 different types of collision for every object by
  selecting from a set of collision routines which you provide.

  As well as (or instead of!) setting up specific types of collison you
  can also set up a single general purpose object collision routine if
  you wish.  In some cases this is easier and quite adequate.

  Collisions ALWAYS require appropriate bits to be set in the HitMask
  and MeMask fields of an object: the HitMask and MeMask specify whether
  or not objects can hit other particular objects or the screen background.

  The object's HitMask bit-0 always refers to object-to-screen collisions,
  and the remaining 31 bits are free for your own use to determine which
  objects can hit each other, and with what consequences.

  Objects can only collide if individual bits of their HitMask/MeMask pairs
  coincide, and each bit position in the mask determines the particular
  collision routine selected from a 31-entry collision routine table which
  is uniquely specified for each colliding object.

  ******************
  General principles
  ******************

  ---------------------------
  Object-to-screen collisions
  ---------------------------

  Object-to-screen collision detection is enabled whenever ALL the
  following conditions are met:

  1. The "CollFlag" field of any HeliOS graphical object is non-null.

     This is a simple On/Off switch which either enables or disables
     ALL types of collision detection for the object.

  2. There are collision masks available for the screen and the object.

     Object collision mask creation is normally handled for you fully
     automatically when you use HeliOS automatic object initialisation
     routines, so generally speaking you can assume this condition to be
     always satisfied for graphical objects such as sprites.

     You MUST explicitly create a collision mask for any display slice
     which requires screen collision detection.

     There is a special HeliOS function to do this, as explained below.

     It is possible, for advanced applications, to set up different screen
     collision masks for different objects, but generally speaking each
     object will use the standard screen collision "shadow" mask.

  3. The object has Bit-0 of its HitMask set.

     Bit-0 of the HitMask determines whether any object is tested for
     collision with the screen background.

     If CollFlag is switched on, enabling collisions, you might want to
     have object-to-object collisions without object-to-screen collisions:
     if this is the case simply clear Bit-0 of the object's HitMask.

     Note that the object's MeMask Bit-0 does NOT have the same effect of
     switching on screen collision detection: you MUST use the HitMask.

  4. If you want to use specific different collision routines there MUST
     be a collision table set up for the object.

     Otherwise you can use a single general collision routine (see below).
     In this case you still need to set up HitMasks and MeMasks, but you
     can simply leave the CollTable field of the object null.

     The collision table is a list of collision functions, one of which
     will be called when an object collides.

     In the case of object-to-screen collision detection it is always the
     first collision routine in the table which is called.

  ---------------------------------------
  Generating screen slice collision masks
  ---------------------------------------

  There is a special function which automatically generates a single
  plane shadow mask for any HeliOS display slice, and you need to use this
  function to generate a collision mask for any display slice in which you
  require object-to-screen collision detection.  This function is called
  MAKESLICEMASK, and has the following stack diagram:

  MAKESLICEMASK   ( SliceControl(l) - - -  BitMap(l) )

  As you can see, this function returns a pointer to a BitMap structure
  which defines a single plane in which has been created a shadow mask
  for the screen slice graphics.

  By calling MAKESLICEMASK you automatically initialise that slice for
  collision detection: you do not need to do anything further with the
  returned BitMap pointer except to perform CLOSEBMAP on it when you
  are finished with it.

  However, you can, if you wish, gain access to the screen collision mask
  plane via this BitMap if you wish to change it in any way.

  ---------------------------
  Object-to-object collisions
  ---------------------------

  Object-to-object collision detection is enabled whenever ALL the
  following conditions are met:

  1. The "CollFlag" field of any HeliOS graphical object is non-null.

     This is a simple On/Off switch which either enables or disables
     ALL types of collision detection for the object.

  2. There is a collision mask available for the object.

     This is normally handled fully automatically when you use HeliOS
     automatic object initialisation routines, so generally speaking
     you can assume this condition to be always satisfied.

  3. The object has at least one of the upper 31 bits of its HitMask or
     MeMask set.

     The upper 31 bits of the HitMask and MeMask control the actual
     operation of the collision outcome.  If there is a collision, one
     of 31 different collision routines may be called.  Each object has
     a table of collision routines, each one of which is directly switched
     by one of the HitMask/MeMask bit positions.

  4. There MUST be a collision handler set up for the object.

     Any object which requires object-to-object collision detection must
     have a collision handler installed in the CollHandler field of its
     control data structure.

     There is a HeliOS function GETCOLLHANDLER which allocates an automatic
     collision handler.

     Collision handlers are identical for all types of HeliOS objects, and
     the process of collision detection is handled entirely automatically
     for you by the interrupt driven collision handler system.

  5. If you want to use specific different collision routines there MUST
     be a collision function table set up for the object.

     Otherwise you can use a single general collision routine (see below).
     In this case you still need to set up HitMasks and MeMasks, but you
     can simply leave the CollTable field of the object null.

     The collision table is a list of collision functions, one of which
     will be selected and called when an object collides.

     Which of these collision routines is called depends on which bits
     are set in the object's HitMask and MeMask, and it is only necessary
     to supply collision routines to correspond to the bits you HAVE set
     in the HitMask and MeMask.

**********************************************
HitMask and MeMask collision routine selection
**********************************************

  This section refers to the running of specific collision routines using
  the HitMask/MeMask collision table selection system.

  You do not have to do this, and you can use a single general collision
  routine if you like (see below).

  In this case you still need to set up HitMasks and MeMasks, but you can
  simply leave the CollTable field of the object null.

  Collisions can only occur between objects which have coincident bits
  set in HitMask-MeMask or MeMask-HitMask pairs, like this:

    00000000000000000000000000000010.  = Object A HitMask
    00000000000000000000000000000011.  = Object B MeMask
                                  ^
                                  Coincident bit

  or

    00000000000000000000000001001000.  = Object A MeMask
    00000000000000000000000000101000.  = Object B HitMask
                                ^
                                Coincident bit

  The reason we have two pairs of collision masks is to give far greater
  versatility than would be afforded by a single mask.

  It does not matter which of the two pairs have matching bits: the two
  HitMask/MeMask combinations for each pair of objects are equivalent in
  function.

  Each bit of the HitMask/MeMask pair have a corresponding position in
  a collision table which stores an array of collision routines.

  e.g.

    00000000000000000000000001001000.  = Object A MeMask
    00000000000000000000000000101000.  = Object B HitMask
                                ^
                                | Coincident bit = Bit 3
  CollRoutine0                  |
  CollRoutine1                  | Selects collision routine 3
  CollRoutine2                  |
  CollRoutine3<-----------------
  CollRoutine4
  etc. etc.

    00000000000000000000000001000010.  = Object A MeMask
    00000000000000000000000000100010.  = Object B HitMask
                                  ^
                                  | Coincident bit = Bit 1
  CollRoutine0                    |
  CollRoutine1<-------------------  Selects collision routine 1
  CollRoutine2
  CollRoutine3
  CollRoutine4
  etc. etc.

  Bit 0 is always associated with screen collisions:

    00000000000000000000000001000010.  = Object A HitMask
                                   ^
                                   No screen collision (Bit0 = 0)

    00000000000000000000000001000011.  = Object A HitMask
                                   ^
                                   | Screen collision (Bit0 = 1)
  CollRoutine0<--------------------
  CollRoutine1
  CollRoutine2
  CollRoutine3
  CollRoutine4
  etc. etc.

  So, the first collision routine is always for screen collisions.

  Here are two examples:

    00000000000000000000000000000010.  = Object A HitMask
    00000000000000000000000000000000.  = Object B HitMask
    00000000000000000000000000000001.  = Object C HitMask

    00000000000000000000000000000000.  = Object A MeMask
    00000000000000000000000000000011.  = Object B MeMask
    00000000000000000000000000000000.  = Object C MeMask

  Would allow A and B to collide, B and C to collide, but not A and C.

  B and C colliding runs the routine at position 1 in the collision table
  A and B colliding runs the routine at position 2 in the collision table
  Only object C can collide with the screen.

  -----------------------------------------------------------

    00000000000000000000000000000011.  = Object A HitMask
    00000000000000000000000000000001.  = Object B HitMask
    00000000000000000000000000000001.  = Object C HitMask

    00000000000000000000000000000000.  = Object A MeMask
    00000000000000000000000000000000.  = Object B MeMask
    00000000000000000000000000000010.  = Object C MeMask

  Would allow just A and C to collide

  A and C colliding runs the routine at position 2 in the collision table
  Objects A, B and C can collide with the screen.

  -------------------------
  Multiple bit-coincidences
  -------------------------

  You should avoid having ambiguous HitMasks and MeMasks which contain
  multiple possible bit-coincidences.

  If more than one bit-coincidence occurs, only one collision routine
  will be called, corresponding to the lowest order bit coincidence.

******************************
Collision routine table format
******************************

  Collision routine tables can consist of either machine code or HeliOS
  routines, and depending on which you choose the format of the table is
  slightly different

  The first 16-bit value in a collision table gives the number of routines
  in the table: this value is expressed as negative if the table consists
  of HeliOS code, and positive if the table is machine code routines.

  The length of each entry in thetable is 16-bit for HeliOS functions, and
  32-bit for machine code functions.

  Here is how collision routine tables of each kind are organised, expressed
  as simple sections of HeliOS code:

  ---------------------------------------------
  HeliOS routine collision table with 5 entries
  ---------------------------------------------

  CREATEL CollTable               \ 32-bit CollTable pointer to store in
                                  \ object structure's CollTable field.

  -5 ,                            \ 5 routines in table (-ve for HeliOS)

  FIND ScreenCollFunction ,       \ CFA of screen collision routine
  FIND CollFunction1      ,       \ CFA of object collision routine
  FIND CollFunction2      ,       \ etc.
  FIND CollFunction3      ,       \
  FIND CollFunction4      ,       \
  FIND CollFunction5      ,       \

  ---------------------------------------------------
  Machine Code routine collision table with 5 entries
  ---------------------------------------------------

  CREATEL CollTable               \ 32-bit CollTable pointer to store in
                                  \ object structure's CollTable field.

  5 ,                             \ 5 routines in table (+ve = machine code)

  ScreenCollFunction     D,       \ Machine code pointer to screen routine
  CollFunction1          D,       \ Machine code object collision routine
  CollFunction2          D,       \ etc.
  CollFunction3          D,       \
  CollFunction4          D,       \
  CollFunction5          D,       \

************************************
Collision routine table minimum size
************************************

  You only need provide a collision table with just sufficient entries
  to match the bits you have set in the HitMask/MeMask pair.

  Because the table is scanned in strict order, you need at least as
  many entries as determined by the HIGHEST bit set in HitMask/MeMask.

  e.g.

    00000000000000000000000001000010.  = Object A MeMask
    00000000000000000000000000100010.  = Object B HitMask
                             ^^^^^^^
     Highest bit set = Bit 6 |||||||
                             |||||||
                             |||||| ->CollRoutine0   Bit = 0, so not used
                             ||||| -->CollRoutine1   Bit = 1, so used
                             |||| --->CollRoutine2   Bit = 0, so not used
                             ||| ---->CollRoutine3   Bit = 0, so not used
                             || ----->CollRoutine4   Bit = 0, so not used
                             | ------>CollRoutine5   Bit = 1, so used
                              ------->CollRoutine6   Bit = 1, so used

  See how some of the routines in the table can never be called because
  the associated HitMask/MeMask bit is not set.  These table entries can
  be stored as simple null values, but must still be in the table.

  No bits above bit 6 are set, so no routines after CollRoutine6 will
  ever be called: these routines can be omitted from the table.

**********************************
Using different collision routines
**********************************

  Each bit position in the HitMask/MeMask has a different collision routine,
  and this allows you to set up different outcomes for different collisions.

  For example, if in a game your "ship" flies into a "power pickup" object
  or an enemy, you might want to associate different pickups and enemies
  with different collision bits.  Thus you could easily have different
  things happen for each type of collision.


**************************
Writing Collision routines
**************************

  Collision routines often need to work with the control structures of
  the colliding objects.

  In the case that your collision routine is a general purpose routine
  used in several places it is also useful to know what collision bit
  represents the current collision.

  HeliOS provides you with these parameters when it passes control to your
  collision routines.

  In the case of moving graphical objects the structure presented is the
  SpriteCtrl structure.

  N.B.

      If the main object were to be a SpriteAnim, the collision routines
      still present the SpriteCtrl structure pointer for the particular
      frame which collided - NOT the SpriteAnim structure!

      If you need to get the SpriteAnim structure itself you need to get
      this from the SpriteCtrl_Anim field of the SpriteCtrl structure.


  In the case of screen collisions the data structure which defines the
  screen collison object is the SliceControl structure for the colliding
  area of the screen.

  The collision mask passed to your collision routine is a 32-bit logical
  AND of the colliding objects' HitMask and MeMask.


  --------------------------
  HeliOS collision functions
  --------------------------

  In the event of a collision, a HeliOS routine in an object's Collision
  Table corresponding to the HitMask-MeMask bit coincidence will be called
  with 3 parameters: the two colliding objects and the collision HitMask

  The stack on a collision call looks like this:

  CollisionHitMask(l) = Top 32-bit value on stack
  CollidingObject(l)  = 2nd 32-bit value on stack
  This Object(l)      = 3rd 32-bit value on stack

  You MUST take care to handle these stack values correctly.

  --------------------------------
  Machine code collision functions
  --------------------------------

  In the event of a collision, a machine code routine in an object's
  Collision Table corresponding to the HitMask-MeMask bit coincidence
  will be called with 3 parameters: the two colliding objects and the
  collision HitMask.

  These parameters are stored in data and address registers as follows:

  CollisionHitMask(l) -> D0
  CollidingObject(l)  -> A1
  This Object(l)      -> A0


********************************************
Summary of how to set up collision detection
********************************************

  The step-by-step information below assumes the most complex case where
  you are setting up individual collision functions for different types
  of collision.

  If you do not want to do this, you will still need to set up HitMasks
  and MeMasks, but you do not need to set up a CollTable, and you can
  just leave the CollTable field in your collision objects blank.

  If you don't use the specific collision routine system you will probably
  want to use a general purpose single collision routine.  This needs to
  be constructed exactly like the specific collision routines described
  below, and it receives exactly the same input parameters when called by
  HeliOS.  Simply store a pointer to this function in the CollForth or
  CollCode fields of your object.


  ---------------------------------------
  Setting up specific collision detection
  ---------------------------------------

  1. Make sure that you have initialised the object/screen in such a way
     as to have prepared collision mask planes.

     This is normally done automatically by HeliOS graphic object (sprite)
     initialisation routines, so in ordinary circumstances you need not
     bother about it for simple object to object collisions.

     For screen collision you need to use MAKESLICEMASK to set up any
     particular slice for collision detection, as follows:

     MySlice_SliceControl MAKESLICEMASK
     DFLAG0= ERROR" Fail: SliceControl Mask"
     MySliceMask D!

     and later, when you are closing down.....

     MySliceMask D@     CLOSEBMAP

  2. Initialise 32-bit masks and store them in the object's HitMask and
     MeMask fields.

     BINARY
     00000000000000000000000000000010.  DCONSTANT  HitMask
     00000000000000000000000000000101.  DCONSTANT  MeMask
     DECIMAL

     HitMask  MySprite SpriteCtrl_HitMask  INDEXD!L
     MeMask   MySprite SpriteCtrl_MeMask   INDEXD!L

  3. Create your collision routines.

     In this example we have created separate but identical routines
     for screen and object collision detection in order to emphasize
     the way they are stored in the collision table etc.

     Normally you could use just one routine for both types of collision
     if you wanted to.

     : MyScrCollision

     2 DDROPS                   \ Drop collisionmask and hit-object pointer

     DDUP
     SpriteCtrl_CollFlag D+ 0!L \ Disable further collisions
     REMOVESPRITE               \ Remove sprite
     ;

     : MyObjCollision

     2 DDROPS                   \ Drop collisionmask and hit-object pointer

     DDUP
     SpriteCtrl_CollFlag D+ 0!L \ Disable further collisions
     REMOVESPRITE               \ Remove sprite
     ;

     N.B.

     If you are using the HeliOS generalised, non-specific, collision
     return function you simple need one routine similar to the above.

  4. Create a collision table.

     CREATEL CollTable
     -3 ,                     \ -3 = The 3 means there are 3 table entries
                              \      The "-" signifies that these are
                              \      HeliOS words rather than machine code            4. Switch on the object's CollFlag to enable collision detection.

     FIND MyScrCollision ,    \ Find routine and store HeliOS word CFA         e.g.
     FIND MyObjCollision ,    \ Find routine and store HeliOS word CFA         e.g.
     FIND MyObjCollision ,    \ Find routine and store HeliOS word CFA         e.g.

     N.B.

     If you are using the HeliOS generalised, non-specific, collision
     return function you do not need to do this.

  5. Store collision table pointer in object's CollTable field.

     CollTable  MySprite SpriteCtrl_CollTable   INDEXD!L

     N.B.

     If you are using the HeliOS generalised, non-specific, collision
     return function you do not need to do this.

     Instead, set your object's CollTable field to zero:

     0.  MySprite SpriteCtrl_CollTable   INDEXD!L

  6. Allocate a collision handler and put it into the object's CollHandler
     field if you want to do sprite-to-sprite collision detection.

     This is not required for sprite-to-screen collision detection.

     GETCOLLHANDLER
     DFLAG0= ERROR" Fail: CollHandler"
     DDUP MyCollHandler D!
     MySprite SpriteCtrl_CollHandler  INDEXD!L

  7. Switch on collision detection by placing a non-zero value in the
     object's CollFlag field.

     1  MySprite SpriteCtrl_CollFlag   INDEX!L

  8. Once you have done this all collisions will be handled completely
     automatically by the HeliOS system calling your collision routines.


*****************************************************
The HeliOS "generalised" collision detection function
*****************************************************

  HeliOS has a simple collision detection facility available, and this
  allows you to set up a single HeliOS or machine code (or both) routine
  which runs WHENEVER an object collides with ANYTHING.

  You still need to set CollFlag, HitMasks and MeMasks, but you simply
  store null in the object's CollTable field..

  The non-specific routines are called with exactly the same parameters
  as the ordinary collision routines described above.

  These general purpose functions can be installed by placing pointers to
  the required routines in the object's CollForth or CollCode fields:

  Find MyCollision    MySprite SpriteCtrl_CollForth  INDEX!L

  or

  MyCollision         MySprite SpriteCtrl_CollForth  INDEXD!L

*********************
Off-Screen collisions
*********************

In normal circumstances you would probably only want to perform collision
detection for objects which are visible on screen.

HeliOS will, however, allow you to perform collision detection for objects
which are part of the HeliOS dynamic object control system but are not at
present visible on screen.

If HeliOS is moving several objects under automatic control, once an object
goes off screen it will no longer be rendered but it will still, if you so
wish, continue to be moved around in "virtual" space.

There is a method of forcing HeliOS to do collision detection on these
"invisible" off-screen virtual objects.

If you set an object's CollideAlways field to a non-zero value, that object
will have collision detection performed at all times, even when off screen:

  1  MySprite SpriteCtrl_CollideAlways  INDEX!L

In general this is NOT a good idea, since collision detection takes up
quite a lot of CPU time.

ONLY USE "COLLIDEALWAYS" WHEN ABSOLUTELY NECESSARY!

See next note......

***********************************
Collision detection system overhead
***********************************

The HeliOS collision detection system provides ultra reliable and pixel
perfect collision detection for every frame of your game.

Because collision detection requires EACH collision object to be tested
against ALL other collision objects, increasing the number of collision
objects rapidly multiplies the amount of collision checking required.

This means that it is desirable to reduce the number of collision objects
as much as possible, so plan your games carefully and always use collision
detection sparingly.

*******************************************
Using DUMMY objects for collision detection
*******************************************

It is possible to set up any number of "dummy" objects which are never
rendered to the screen but which behave like normal objects for the
purpose of collision detection, motion, dynamics etc..

This can be very useful indeed, and merely requires that you create an
absolutely standard object, such as a sprite, and store a non zero value
in its DummyFlag field, like this:

  1  MySprite SpriteCtrl_DummyFlag  INDEX!L

This object will from then on be "invisible" but "collideable".

***********************************
Hardware sprite collision detection
***********************************

HeliOS treats hardware sprites exactly like software sprites for the
purposes of collision detection as well as general dynamics and motion.

Only the method of rendering the sprite image to the screen distinguishes
hardware sprites from software sprites in HeliOS.

You can even interchange between the two types of sprite very easily.

All HeliOS hardware sprites run a "dummy" software sprite which controls
general dynamics and collision detection.

HeliOS does NOT implement Amiga hardware collision detection, which is
a somewhat clumsy system in many ways, but you could implement this for
yourself, if you really wished to do so within, the HeliOS system.

AS far as the normal HeliOS system is concerned ALL graphical objects
run an identical pixel-perfect frame by frame collison detection method.

This allows you to have one universally applicable and efficient system,
and you handle hardware sprite collisions exactly like software sprites.

****************************************************
Field in objects which relate to collision detection
****************************************************

Here are the fields in a SpriteCtrl structure which relate to collision
detection (other graphic objects have similar fields):

SpriteCtrl_MaskBMap           This object mask BitMap pointer
SpriteCtrl_CollPlane          This object mask plane pointer
SpriteCtrl_TgtMaskPlane       Screen slice mask plane pointer
SpriteCtrl_CollHitMask        Logical AND of HitMask/MeMask on collision
SpriteCtrl_CollForth          HeliOS general collision routine
SpriteCtrl_CollCode           Machine code general collision routine
SpriteCtrl_CollHandler        Collision handler pointer
SpriteCtrl_CollTable          Collision routine table pointer
SpriteCtrl_HitMask            HitMask
SpriteCtrl_MeMask             MeMask
SpriteCtrl_CollFlag           Collision enable flag
SpriteCtrl_CollideAlways      Collide always flag
SpriteCtrl_DummyFlag          Dummy collision object flag

************************************************************************
End
************************************************************************
