
*********************************
HeliOS software sprite animations
*********************************

HeliOS runs animations using an interrupt controlled animation handler
which processes a series of animation data structures defining the imagery
and dynamics of each animation frame.

The HeliOS animation handler runs under the HeliOS game operating system
and does not function when the Amiga operating system is active.

The animation control structures used by HeliOS are very similar in terms
of dynamic parameters to HeliOS sprite control structures, but with extra
fields to specify things like imagery and framerate changes.  In fact each
animation "image" in the HeliOS animation is specified by a full sprite
control structure and each frame of an animation is actually a full dynamic
sprite object in its own right.

This close correspondence between sprites and animations means that the
task of learning to control the dynamics of each type of object is greatly
simplified.  For example, you will find that it is very easy to set up the
dynamics of a game using non-animated sprites, then later translate this
simple model into a final fully animated version with a minimum of effort.

**************************
Defining HeliOS animations
**************************

----------------------------------------------
Allocating an animation control data structure
----------------------------------------------

A HeliOS animation is defined by first allocating an appropriate data
structure which then must be initialised by setting it up with the various
parameters you require (see below).

You might use code something like this:

  SpriteAnim_SIZEOF MAKESTRUCTURE
  DFLAG0= ERROR" Fail: MyNewAnim"
  MyNewAnim MAKEPOINTER

The animation data structure can be allocated however you choose and can be
in chip or fast memory (fast is best).

The animation will be fully controlled when "on screen" by the data which
you store in this structure: you could regard the animation structure as a
"control panel" for the animation, with a series of switches and dynamic
settings which you can change at any time to generate your required effects.

----------------------------------------
Allocating sprites for animation imagery
----------------------------------------

A major part of the preliminary data required for setting up the animation
structure is the set of sprites which form the imagery for the animation.

Each frame of a HeliOS animation is a normal software sprite with a complete
sprite control structure fully initialised.

You MUST set up and initialise a set of sprites for your animation and
create a sprite table which consists of a simple linear sequence of sprite
control structure pointers.  A pointer to the start of this sprite table
must be stored in the "SpriteAnim_Image" field of the animation control
structure (see below).

The set of sprites specified in the sprite table will be rendered onto the
screen in order, and swapped as required to present your animation sequence.

-------------------------------------------
Setting up animation dynamic control fields
-------------------------------------------

Here are the other fields which you will generally want to initialise as a
minimum requirement before installing an animation:

SpriteAnim_Flags         -> Set to "1" when installing a normal anim
                            Set to "-1" to make anim initially immobile
                            Set to "-2" to make anim initially invisible
SpriteAnim_Speed         -> Animation speed
SpriteAnim_Skip          -> Frame skip
SpriteAnim_Current       -> Current frame
SpriteAnim_Frames        -> Total frames
SpriteAnim_AnimControl   -> Animation type
SpriteAnim_XPos          -> Logical X-coordinate
SpriteAnim_YPos          -> Logical Y-coordinate

See below for more details.

You might use code something like this:

      MyNewAnim SETSTRUCTURE1

                         SpriteAnim_Flags        STRUCTURE1 1!L
      MyAnimFrameSpeed   SpriteAnim_Speed        STRUCTURE1 !L
                         SpriteAnim_Skip         STRUCTURE1 1!L
                         SpriteAnim_Current      STRUCTURE1 0!L
      MyAnimFrames       SpriteAnim_Frames       STRUCTURE1 !L
      6                  SpriteAnim_AnimControl  STRUCTURE1 !L
      MyAnimStartXPos    SpriteAnim_XPos         STRUCTURE1 0!L
      MyAnimStartYPos    SpriteAnim_YPos         STRUCTURE1 0!L

*****************************************
Installing and removing HeliOS animations
*****************************************

Once you have created and initialised an animation structure you need to
install it into the HeliOS interrupt driven animation handler.

This is done by using the function INSTALLSPRITEANIM which is defined as
follows:

  INSTALLSPRITEANIM

  ( SpriteAnim(l) - - - )

  Installs a "software" sprite (BOB) animation into the HeliOS sprite
  animation control system.

You might use code something like this:

  MyNewAnim INSTALLSPRITEANIM

From now on the animation will be processed under interrupt control while
ever and whenever the HeliOS game operating system is switched on.

The animation may be stopped or rendered invisible by using the control
parameters within its data structure, but it will always be processed by
the HeliOS animation handler until it is specifically removed.

To remove a HeliOS animation you can use the function REMOVESPRITEANIM:

  REMOVESPRITEANIM

  ( SpriteAnim(l) - - - )

  Removes a "software" sprite (BOB) animation from the HeliOS sprite
  animation control system.

You might use code something like this:

  MyNewAnim REMOVESPRITEANIM

Another (sometimes more useful) method of removing a sprite animation is
to store the value "-3" into the "SpriteAnim_Flags" field of the animation
control structure (see below).

*******************************************************
Using the fields in HeliOS Animation control structures
*******************************************************

HeliOS animations are controlled entirely be storing parameters into
control structures either before the animation is installed or while
the animation is running.

The name of the structure which controls HeliOS sprite animations is
"SpriteAnim".

The SpriteAnim structure is quite large, and has several "private" fields
and other fields which you do not need to learn about initially for the
purposes of creating simple animations.

Do not worry about the size of this structure, and do not try to learn
what everything does all at once: learn each function as you need it.

--------------------
Future compatibility
--------------------

The "SpriteAnim" structure may be extended in the future, so always refer
to fields within this structure by their symbolic names rather than using
numerically coded offsets to avoid compatibility problems.

--------------------
Structure definition
--------------------

Here is the current definition of the "SpriteAnim" structure:

   WORD  SpriteAnim_Flags         -> Control Flags

   WORD  SpriteAnim_Speed         -> Animation speed
   WORD  SpriteAnim_Skip          -> Frame skip
   WORD  SpriteAnim_Count         -> Internal counter
   WORD  SpriteAnim_Current       -> Current frame
   WORD  SpriteAnim_Frames        -> Total frames
   WORD  SpriteAnim_Channel       -> Controller channel number
   WORD  SpriteAnim_AnimControl   -> Animation type
   APTR  SpriteAnim_Image         -> Pointer to Image array

   WORD  SpriteAnim_RemForth      -> HeliOS CFA executed at closedown
   APTR  SpriteAnim_RemCode       -> Assembler code executed at closedown
   WORD  SpriteAnim_BeforeForth   -> HeliOS CFA executed "Before" anim
   APTR  SpriteAnim_BeforeCode    -> Assembler code executed "Before" anim
   WORD  SpriteAnim_AfterForth    -> HeliOS CFA executed "After" anim
   APTR  SpriteAnim_AfterCode     -> Assembler code executed "After" anim
   WORD  SpriteAnim_CollForth     -> HeliOS CFA executed at collision
   APTR  SpriteAnim_CollCode      -> Assembler code executed at collision
   WORD  SpriteAnim_Status        -> Status flag

   WORD  SpriteAnim_AutoRemove    -> Auto-self-removal flag

   WORD  SpriteAnim_CountDown     -> Length of countdown in "frames"
   WORD  SpriteAnim_CDFlags       -> Control Flags set at end of CountDown
   WORD  SpriteAnim_CDForth       -> HeliOS CFA executed at countdown
   APTR  SpriteAnim_CDCode        -> Assembler code executed at countdown
   APTR  SpriteAnim_ThisFrame     -> Pointer to current Sprite controller

   WORD  SpriteAnim_XPos          -> Logical X-coordinate
   WORD  SpriteAnim_YPos          -> Logical Y-coordinate
   WORD  SpriteAnim_RenderXPos    -> Display X-coordinate
   WORD  SpriteAnim_RenderYPos    -> Display Y-coordinate
   APTR  SpriteAnim_XPosPtr       -> Pointer to logical X-coordinate
   APTR  SpriteAnim_YPosPtr       -> Pointer to logical Y-coordinate
   APTR  SpriteAnim_XAdd          -> Pointer to X-additive value
   APTR  SpriteAnim_YAdd          -> Pointer to Y-additive value
   WORD  SpriteAnim_XOrigin       -> Coordinate origin X-offset
   WORD  SpriteAnim_YOrigin       -> Coordinate origin Y-offset

   APTR  SpriteAnim_CollHandler   -> Pointer to collision handler
   APTR  SpriteAnim_CollTable     -> Pointer to collision routine table
   LONG  SpriteAnim_HitMask       -> Hitmask
   LONG  SpriteAnim_MeMask        -> MeMask
   WORD  SpriteAnim_CollFlag      -> Collision flag
   WORD  SpriteAnim_CollideAlways -> Off screen collision flag
   WORD  SpriteAnim_DummyFlag     -> Dummy anim flag
   LONG  SpriteAnim_ID            -> Internal ID

   LONG  SpriteAnim_FrameMask     -> Frame on/off mask
   WORD  SpriteAnim_Flash         -> Flash flag
   WORD  SpriteAnim_FlashBit      -> Flash bit definition
   WORD  SpriteAnim_Relativity    -> Relativity flag
   WORD  SpriteAnim_WrapCorrect   -> Wrap correction flag
   WORD  SpriteAnim_PtrUpdate     -> External pointer update flag

   WORD  SpriteAnim_VisiZone      -> Visibility zone flag
   WORD  SpriteAnim_VisiHit       -> Visibility zone hit flag
   WORD  SpriteAnim_VisiForth     -> HeliOS CFA executed at VisiZone hit
   APTR  SpriteAnim_VisiCode      -> Assembler code executed at VisiZone hit
   WORD  SpriteAnim_LeftZone      -> Left VisiZone boundary
   WORD  SpriteAnim_RightZone     -> Right VisiZone boundary
   WORD  SpriteAnim_UpZone        -> Top VisiZone boundary
   WORD  SpriteAnim_DownZone      -> Bottom VisiZone boundary
   WORD  SpriteAnim_DispZone      -> Display zone flag
   WORD  SpriteAnim_DispForth     -> HeliOS CFA executed at DispZone hit
   APTR  SpriteAnim_DispCode      -> Assembler code executed at DispZone hit
   WORD  SpriteAnim_Running       -> Activity status flag
   WORD  SpriteAnim_OnScreen      -> OnScreen status flag
   APTR  SpriteAnim_UserDataPtr   -> User data pointer
   WORD  SpriteAnim_UserData1     -> User data
   WORD  SpriteAnim_UserData2     -> User data
   WORD  SpriteAnim_UserData3     -> User data
   WORD  SpriteAnim_UserData4     -> User data
   WORD  SpriteAnim_UserData5     -> User data
   WORD  SpriteAnim_UserData6     -> User data
   WORD  SpriteAnim_UserStatus    -> User status flag

---------------------------------------------------------------------
A detailed description of each field of the SpriteAnim data structure
---------------------------------------------------------------------

Here is an expanded and commented definition of the "SpriteAnim" structure:

   WORD  SpriteAnim_Flags         -> Control Flags

   This field is used internally by the HeliOS animation handler and can
   also be specified by the user-program which is running the animation.

   Note that ALL active sprites may be have their "Flags" control fields
   overridden by storing a non-zero value in the HeliOS "SPRITEFLAGS"
   variable.

   The behaviour of the "Flags" value thus imposed will be exactly the same
   as the normal "Flags" values detailed below.

   e.g.

   7 SPRITEFLAGS !L

   Would cause ALL sprites to skip display updating until you restored
   the SPRITEFLAGS variable to 0.

   and

   8 SPRITEFLAGS !L

   Would cause ALL sprites to skip display updating for one frame, after
   which the SPRITEFLAGS variable would be automatically reset to 0.


   Currently the only control flag values which can be specified by the
   user are:

   * 6 -> Do not save or restore background at all

     This would be used if you wanted the animation to be continually rendered
     into the display bitmap without restoring the display, thus leaving a
     "trail" of animation images.

   * 7 -> Do not restore background ALREADY SAVED by a "normal" animation

     This would be used if you wanted a normal animation to stop restoring the
     display backdrop for a continuous period.

     An example of when this might be used is if you were in the process of
     modifying the backdrop behind the animation for a number of frames and
     you wanted to retain the new backdrop imagery without the animation
     restoring old imagery.

   * 8 -> Do not restore background ALREADY SAVED by an animation for the next
          frame

     This is like using a "Flags" value of 7 except that it only applies for
     a single frame, after which normal background restoration is restored.

     Note that in this case the "Flags" value is reset automatically to 1,
     so if you do not want this outcome you will need to provide your own
     custom control code.

     An example of when this might be used is if you have made a one-off
     modification of the display background and you do not want animations to
     restore the old imagery for the first subsequent frame.  Once the "false"
     redraw with the old imagery has been avoided, normal sprite updating and
     background restoration is recommenced.

   * 9 -> Do not restore background ALREADY SAVED by an animation for the
          next 2 frames

     This is like using a "Flags" value of 8 except that it applies for 2
     frames as required for double buffered animation displays.

   * -1 -> Causes the animation to stop moving by not adding the XAdd and YAdd
           field values to the position coordinates.

   * -2 -> Causes the animation to become invisible and immobile.

   * -3 -> Causes the animation to stop and auto-remove itself at once.

     This is a very useful and efficient way of removing an animation: it
     is slightly more efficient than using the REMOVESPRITEANIM function
     and can often be implemented more usefully.

   WORD  SpriteAnim_Speed         -> Animation speed

   The sprite animation "speed" is a count of how many game frames will be
   allowed to elapse between actual imagery frame changes in the animation.

   A value of zero will give full (maximum) speed animation.

   This parameter specifies the frame rate of the animation: it acts as a
   simple count which is checked against the number of elapsed frames.

   Each "frame" is defined as the processing of an animation structure by
   the interrupt driven animation handler: this may not in fact coincide
   with the video frame refresh rate.  For example, the video frame rate
   might be 50 cps but the game frame rate (and hence the animation frame
   processing rate) may be only 25 cps.

   WORD  SpriteAnim_Skip          -> Frame skip

   This defines how many frames (if any) of the animation will be skipped
   when the imagery frame is advanced.

   A value of "1" here will give a normal "frame-by-frame" display of the
   full animation sequence, a value of "0" will give a static animation
   with no frame advance, and values greater than "1" will cause the
   specified number of animation frame images to be skipped at each change.

   If the number of frames skipped is not an exact fraction of the total
   frames in the animation you can set up special "strobe" effects.

   WORD  SpriteAnim_Count         -> Internal counter

   This field is used internally by HeliOS to keep track of the animation
   frame count.

   WORD  SpriteAnim_Current       -> Current frame

   This specifies the frame which will next be rendered: the imagery frames
   are numbered from "0" upwards.

   Set this to "0" to cause the animation to display the first imagery
   sprite as the next frame.

   WORD  SpriteAnim_Frames        -> Total frames

   This specifies how many frames the animation controller will process
   before returning to the first frame.

   Note that the number of sprites in the imagery table (see below) can
   be greater than the total frames specified, in which case only the first
   few frames (as specified by this field) will be displayed.

   WORD  SpriteAnim_Channel       -> Controller channel number

   This field is used internally by HeliOS and should not be changed by
   user programs.

   WORD  SpriteAnim_AnimControl   -> Animation type

   This field specifies the type of animation as follows:

   1 -> Stop animation at next end of frame sequence
   6 -> Set animation to "loop" mode (normal cyclic animation)
   7 -> Set animation to "shuttle" mode (back/forward repeat motion)

   APTR  SpriteAnim_Image         -> Pointer to Image array

   This field MUST be initialised as a pointer to a table of sprite control
   structures which define the sprites to be used for the animation imagery.


   WORD  SpriteAnim_RemForth      -> HeliOS CFA executed at closedown

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed when the animation is removed.

   APTR  SpriteAnim_RemCode       -> Assembler code executed at closedown

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed when the animation is removed.

   WORD  SpriteAnim_BeforeForth   -> HeliOS CFA executed "Before" anim

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed before each animation frame is processed.

   APTR  SpriteAnim_BeforeCode    -> Assembler code executed "Before" anim

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed before each animation frame is processed.

   WORD  SpriteAnim_AfterForth    -> HeliOS CFA executed "After" anim

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed after each animation frame is processed.

   APTR  SpriteAnim_AfterCode     -> Assembler code executed "After" anim

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed after each animation frame is processed.

   WORD  SpriteAnim_CollForth     -> HeliOS CFA executed at collision

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed when an animation collision is processed.

   APTR  SpriteAnim_CollCode      -> Assembler code executed at collision

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed when an animation collision is processed.

   WORD  SpriteAnim_Status        -> Status flag

   This field is used internally by HeliOS.

   WORD  SpriteAnim_AutoRemove    -> Auto-self-removal flag

   This field is used internally by HeliOS.

   WORD  SpriteAnim_CountDown     -> Length of countdown in "frames"

   If this field is set to a non-null value it will act as an automatic
   countdown timer to allow you to implement functions which execute after
   a chosen elapsed time.

   The timer counts animation processing frames and after the specified
   number of frames has elapsed three possible functions will be carried
   out:

   1.  The "SpriteAnim_CDFlags" value will be stored into the
       "SpriteAnim_Flags" field.

   2.  If non-null the CFA stored in the "SpriteAnim_CDForth" field will
       be executed.

   3.  If non-null the pointer stored in the "SpriteAnim_CDCode" field
       will be executed as machine code.

   WORD  SpriteAnim_CDFlags       -> Control Flags set at end of CountDown

   This field only functions when the CountDown function has been activated
   by setting the "SpriteAnim_CountDown" field of the animation structure
   to a non-null value.

   The "SpriteAnim_CDFlags" field contains a 16-bit "flags" value which will
   be placed in the "SpriteAnim_Flags" field of the animation structure when
   the CountDown has been completed.

   WORD  SpriteAnim_CDForth       -> HeliOS CFA executed at countdown

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed after a "CountDown" has completed.

   APTR  SpriteAnim_CDCode        -> Assembler code executed at countdown

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed after a "CountDown" has completed.

   APTR  SpriteAnim_ThisFrame     -> Pointer to current Sprite controller

   This field is used internally by HeliOS.

   WORD  SpriteAnim_XPos          -> Logical X-coordinate

   This field is contains the current animation object X-Coordinate.

   This is the "logical" X-coordinate and may not be the same as the bitmap
   pixel position, for example in the case of auto-wrapping displays which
   have a "doubled" first screen.

   WORD  SpriteAnim_YPos          -> Logical Y-coordinate

   This field is contains the current animation object Y-Coordinate.

   This is the "logical" Y-coordinate and may not be the same as the bitmap
   pixel position, for example in the case of auto-wrapping displays which
   have a "doubled" first screen.

   WORD  SpriteAnim_RenderXPos    -> Display X-coordinate

   This field is contains the current animation object X pixel position in
   the display bitmap.

   In auto-wrapping displays this may not be the same as the XPos value.

   WORD  SpriteAnim_RenderYPos    -> Display Y-coordinate

   This field is contains the current animation object Y pixel position in
   the display bitmap.

   In auto-wrapping displays this may not be the same as the YPos value.

   APTR  SpriteAnim_XPosPtr       -> Pointer to logical X-coordinate

   If non-null this field contains a pointer to a 16-bit value which will
   be used instead of the "XPos" field to specify the X-coordinate.

   APTR  SpriteAnim_YPosPtr       -> Pointer to logical Y-coordinate

   If non-null this field contains a pointer to a 16-bit value which will
   be used instead of the "YPos" field to specify the Y-coordinate.

   APTR  SpriteAnim_XAdd          -> Pointer to X-additive value

   If non-null this field contains a pointer to a 16-bit value which will
   be added accumulatively to the X-coordinate at each animation frame.

   APTR  SpriteAnim_YAdd          -> Pointer to Y-additive value

   If non-null this field contains a pointer to a 16-bit value which will
   be added accumulatively to the Y-coordinate at each animation frame.

   WORD  SpriteAnim_XOrigin       -> Coordinate origin X-offset

   If non-null this field contains a 16-bit offset value which will be
   added to the X-coordinate non-accumulatively for each frame.

   This field allows you to position an object on screen offset by the
   specified amount.

   WORD  SpriteAnim_YOrigin       -> Coordinate origin Y-offset

   If non-null this field contains a 16-bit offset value which will be
   added to the Y-coordinate non-accumulatively for each frame.

   This field allows you to position an object on screen offset by the
   specified amount.

   APTR  SpriteAnim_CollHandler   -> Pointer to collision handler

   If you are using HeliOS automatic collision detection for this object
   this field must point to a previously initialised collision handler.

   See also "CollisionDetection.doc".

   APTR  SpriteAnim_CollTable     -> Pointer to collision routine table

   If you are using HeliOS automatic collision detection for this object
   this field must point to a previously initialised collision table.

   See also "CollisionDetection.doc".

   LONG  SpriteAnim_HitMask       -> Hitmask

   If you are using HeliOS automatic collision detection for this object
   this field must contain a HitMask.

   See also "CollisionDetection.doc".

   LONG  SpriteAnim_MeMask        -> MeMask

   If you are using HeliOS automatic collision detection for this object
   this field must contain a MeMask.

   See also "CollisionDetection.doc".

   WORD  SpriteAnim_CollFlag      -> Collision flag

   This flag enables or disables collision detection for an animation.

   WORD  SpriteAnim_CollideAlways -> Off screen collision flag

   This flag enables or disables full off-screen collision detection for
   an animation.

   Off screen collision detection would normally be disabled, since it
   causes the HeliOS system to check the object for collisions even when
   it is positioned off screen.

   Only use this when necessary since collision detection takes quite a
   lot of CPU time.

   WORD  SpriteAnim_DummyFlag     -> Dummy anim flag

   This field causes the animation to be run "in the background" as an
   invisible "dummy animation".

   The animation can still be moved and processed and may also be used for
   collision detection.

   LONG  SpriteAnim_ID            -> Internal ID

   This field is used internally by HeliOS.

   LONG  SpriteAnim_FrameMask     -> Frame on/off mask

   This field, if non-null, contains a 32-bit mask longword which is used
   to specify "active" and "dead" frames within the animation sequence.

   This bitmask, if specified, will have its bits read sequentially and will
   only allow animation frames to be processed when the current bit is set.

   The bits of the mask are automatically rotated on each frame.

   WORD  SpriteAnim_Flash         -> Flash flag

   If non-null this field specifies the duration (in animation frames) of
   a "flash" event during which the on-screen sprite may be switched on
   and off rapidly to simulate a "flashing" effect.

   The "SpriteAnim_Flash" field is automatically decremented by "1" each
   frame (down to a final value of zero) by the HeliOS system.

   WORD  SpriteAnim_FlashBit      -> Flash bit definition

   If a "flash" event has been specified this field contains a value which
   specifies a particular bit in the "SpriteAnim_Flash" field which will
   be tested and used to specify whether this frame is "On" or "Off".

   The on-screen sprite image will be switched "Off" whenever the specified
   "flashbit" is set.

   WORD  SpriteAnim_Relativity    -> Relativity flag

   This flag specifies whether animation position coordinates are defined
   with respect to the display top left corner or the playfield (which may
   be larger than the screen display) top left corner:

   0 -> Coordinates are relative to playfield

   1 -> Coordinates are relative to display

   WORD  SpriteAnim_WrapCorrect   -> Wrap correction flag

   This flag uses bits 0 and 1 to control X and Y wrap correct functions.

   If no bits are set (i.e. flag = 0) there is no wrap correction in either
   X or Y direction.

   If bit 0 is set there is wrap correction in the X direction.

   If bit 1 is set there is wrap correction in the Y direction.

   If bits 0 and 1 are set there is wrap correction in both X and Y
   direction.

   This flag specifies whether animation position coordinate calculation
   performs automatic wrapping when an object reaches the edge of the
   playfield.

   The auto-wrap function is usually used in conjunction with over sized
   displays to perform automatic "barrel" scrolling.  To use this function
   you MUST create a special display bitmap with the first visible screen
   area repeated exactly at the far end of the display, like this:


   -------------------------------------------------------------------
   ^           ^   Several more screens..... ^           ^           ^
     1st screen                               Last screen  1st screen
                                                            repeated

   If you use this function HeliOS will always fully automatically set
   your object coordinates to a legal on-playfield value: if you specify
   a coordinate which is larger than the playfield dimension the object
   will be "wrapped" back onto the start of the playfield.

   WORD  SpriteAnim_PtrUpdate     -> External pointer update flag

   This flag specifies whether or not you want the HeliOS system to write
   any recalculated position coordinates originally specified by a pointer
   to an external location back to that location.

   In other words, you can specify whether HeliOS should either update or
   leave alone XPosPtr and YPosPtr locations if it recalculates coordinates
   for "wrapping" etc.

   WORD  SpriteAnim_VisiZone      -> Visibility zone flag

   If non-null this field specifies that HeliOS should automatically check
   object coordinates against a user-defined "visibility" zone.

   The way zone checking works is specified as follows by the "VisiZone"
   parameter:

   VisiZone = -4

         The supplied VisiZone coordinates are used as limiting values
         and object coordinates are automaticaly reset to remain within
         the specified boundary.  The VisiForth and VisiCode fields are
         not executed in this mode.

   Visi-Zone = -2 or -3

         When the object hits the specified boundary of the "VisiZone" the
         "VisiZone" value is stored into the "Flags" field of the object
         and then the VisiForth and VisiCode fields are executed (if non-
         null).

         The VisiHit field specifies which boundary was hit.

         The specified "VisiZone" values have the following effects:

         -2 -> The object becomes instantly invisible

         -3 -> The object instantly auto-removes itself

   Visi-Zone = Any other non-null value

         When the object hits the specified boundary of the "VisiZone" the
         VisiForth and VisiCode fields are executed (if non-null).

         The VisiHit field specifies which boundary was hit.


   WORD  SpriteAnim_VisiHit       -> Visibility zone hit flag

         This field specifies which boundary was hit in the event of a
         VisiZone collision, as follows:

         Bit 0 set -> Left boundary hit
         Bit 1 set -> Right boundary hit
         Bit 2 set -> Top boundary hit
         Bit 3 set -> Bottom boundary hit

         Two bits can be set in the event of an exact corner collision.

         You can use this field within your VisiForth or VisiCode routines
         to determine which boundary was hit and perform an appropriate
         action (such as motion-reflection, for example).

   WORD  SpriteAnim_VisiForth     -> HeliOS CFA executed at VisiZone hit

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed when a "VisiZone hit" occurs.

   APTR  SpriteAnim_VisiCode      -> Assembler code executed at VisiZone hit

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed when a "VisiZone hit" occurs.

   WORD  SpriteAnim_LeftZone      -> Left VisiZone boundary

   This field specifies the left VisiZone boundary in terms of the size
   of the zone measured from the left edge of the display.

   This value is always a positive number and specifies a distance in pixels
   from the edge of the display - remember that this field does NOT specify
   a coordinate, but an offset!

   WORD  SpriteAnim_RightZone     -> Right VisiZone boundary

   This field specifies the right VisiZone boundary in terms of the size
   of the zone measured from the right edge of the display.

   This value is always a positive number and specifies a distance in pixels
   from the edge of the display - remember that this field does NOT specify
   a coordinate, but an offset!

   WORD  SpriteAnim_UpZone        -> Top VisiZone boundary

   This field specifies the top VisiZone boundary in terms of the size
   of the zone measured from the top edge of the display.

   This value is always a positive number and specifies a distance in pixels
   from the edge of the display - remember that this field does NOT specify
   a coordinate, but an offset!

   WORD  SpriteAnim_DownZone      -> Bottom VisiZone boundary

   This field specifies the bottom VisiZone boundary in terms of the size
   of the zone measured from the bottom edge of the display.

   This value is always a positive number and specifies a distance in pixels
   from the edge of the display - remember that this field does NOT specify
   a coordinate, but an offset!

   WORD  SpriteAnim_DispZone      -> Display zone flag

   When an object moves beyond the display boundaries HeliOS does not
   render the object to the display bitmap, but you can also use the
   "DispZone" functions to specify other actions.

   This field, if set to a value of "-2" or "-3", specifies that HeliOS
   should store the DispZone value into the "Flags" field of the object
   and carry out the specified action of "invisibility" or "auto-removal"
   when an object moves off-screen.

   The specified "DispZone" values have the following effects:

         -2 -> The object becomes instantly invisible

         -3 -> The object instantly auto-removes itself

   WORD  SpriteAnim_DispForth     -> HeliOS CFA executed at DispZone hit

   When an object moves beyond the display boundaries HeliOS does not
   render the object to the display bitmap, but you can also use the
   "DispZone" functions to specify other actions.

   This field contains either null or the CFA of a HeliOS function which
   you wish to be executed when an object moves off screen.

   APTR  SpriteAnim_DispCode      -> Assembler code executed at DispZone hit

   When an object moves beyond the display boundaries HeliOS does not
   render the object to the display bitmap, but you can also use the
   "DispZone" functions to specify other actions.

   This field contains either null or a pointer to a machine code routine
   which you wish to be executed when an object moves off screen.

   WORD  SpriteAnim_Running       -> Activity status flag

   This field is set by the HeliOS system and tells you whether or not an
   object is currently still operating and installed into its interrupt
   driven HeliOS handler.

   WORD  SpriteAnim_OnScreen      -> OnScreen status flag

   This field is set by the HeliOS system and tells you whether or not an
   object is currently on screen.

   APTR  SpriteAnim_UserDataPtr   -> User data pointer

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData1     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData2     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData3     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData4     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData5     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserData6     -> User data

   This is a "free" field which you can use as you wish.

   WORD  SpriteAnim_UserStatus    -> User status flag

   This is a "free" field which you can use as you wish.

   The "User" fields are entirely for your own use, and allow you to
   maintain object-specific data areas which can be used in a variety
   of ways: for example, to specify coordinate addition pointers etc.
