
;  ***************************************************************

( system 2 * 15 8192 )     ;  Set amount of memory reserved by LOGO.

;  ***************************************************************
;  ***   Utilities
;  ***************************************************************

pr [ Initializing LOGO - Please Wait ]

; *** say   speech

make "say [
   procedure [ [ :s-text ] :s-optext [ :s-sh ] ]
   make "s-sh gprop "startup-data "speak-handle
   if memberp :s-sh filelist [ ]
   [  make "s-sh open "SPEAK:
      pprop "startup-data "speak-handle :s-sh ]
   while [ not emptyp :s-optext ]
   [  make "s-text se :s-text first :s-optext
      make "s-optext bf :s-optext ]
   fprint :s-sh :s-text ]


; *** ed    edit names

make "ed [
   procedure [ [ :edit-names ] ]
   if wordp :edit-names
   [  if existp :edit-names [ ]
      [  make :edit-names [ procedure [ ] ] ] ] [ ]
   prosave gprop "startup-data "work-file :edit-names
   if or = @0 findport "REXX
         = @0 findport "QED1
   [  doscommand se "C:ED gprop "startup-data "work-file
      load gprop "startup-data "work-file ]
   [  command "ToQED
      ( intuition 6 @0 )
      if emptyp :edit-names [ ]
      [  command se "LoadQED gprop "startup-data "work-file ] ] ]


; *** edit  switch to editor.

make "edit [
   procedure [ [ ] [ :edit-names ] ]
   ed :edit-names ]

; *** edf

make "edf [
   procedure [ [ :file-name ] ]
   if emptyp :file-name
   [  make "file-name ( filerequest [ Edit File ] )
      ( intuition 6 gprop "startup-data "screen ) ] [ ]
   if emptyp :file-name [ ]
   [  if or    = @0 findport "REXX
               = @0 findport "QED1
      [  doscommand se "C:ED :file-name
         load :file-name ]
      [  command "ToQED
         ( intuition 6 @0 )
         command se "LoadQED :file-name ] ] ]

; *** from-editor

make "from-editor [
   procedure [ [ ] [ :file-name ] ]
   if emptyp :file-name [ ] [ load :file-name ]
   ( intuition 6 getprop "startup-data "screen )
   ( intuition 12 @0 )
   ( intuition 11 @0 ) ]

; *** Output list of all variable names.

make "all [
   procedure [ ]
   op se namelist burylist ]

; *** Output list of names that contain procedures.

make "allprocs [
   procedure [ ]
   op filter-quick "procedurep se namelist burylist ]

; *** Output list of names that contain something other than procedures.

make "allnames [
   procedure [ ]
   op filter-quick [ not procedurep ] se namelist burylist ]

; *** Output list of unprotected names that do not contain procedures.

make "names [
   procedure [ ]
   op    filter-quick   [ not procedurep ]
                        remove-quick   gprop "startup-data "keepers
                                       namelist ]

; *** Output list of unprotected names that contain procedures.

make "procs [
   procedure [ ]
   op    filter-quick   [ procedurep ]
                        remove-quick   gprop "startup-data "keepers
                                       namelist ]

; *** Ignores the output from operations.

make "ignore [ procedure [ [ :x ] :y ] ]

; *** See if variable name exists.

make "existp [
   procedure [ [ :name ] ]
   op or namep :name buriedp :name ]

; *** Print out contents of lists verticaly.

make "vpr [
   procedure [ [ :l ] [ :i ] ]
   if emptyp :i [ make "i 0 ] [ ]
   if listp :l
   [  while [ not emptyp :l ]
      [  ( vpr first :l + 1 :i )
         make "l bf :l ]
      pr [ ] ]
   [  repeat :i [ type "\  ] 
      pr :l ] ]

; *** Print out contents of lists verticaly.

make "spr [
   procedure [ [ :l ] ]
   vpr sort "alphap :l ]

; *** Print out procedure titles.

make "pots [
   procedure [ [ :po-names ] ]
   if listp :po-names
   [  while [ not emptyp :po-names ]
      [  pots first :po-names
         make "po-names bf :po-names ] ]
   [  type :po-names
      if or namep :po-names buriedp :po-names
      [  if procedurep :po-names
         [  if emptyp item 2 thing :po-names
            [  pr [ [ ] ] ]
            [  ( type "[ first item 2 thing :po-names "] )
               if < 1 count item 2 thing :po-names
               [  show item 2 item 2 thing :po-names ]
               [  pr [ ] ] ] ]
         [  pr [ is not a procedure name. ] ] ]
      [  pr [ is not a name. ] ] ] ]

; *** flush

make "flush [
   procedure [ ]
   erase names
   erase procs ]

; *** reset

make "reset [
   procedure [ [ ] [ ] [ :names-list ] ]
   closeall
   whenmessage [ host-port-demon ]
   whenmenu [ comm-menu-demon getmenu ]
   setmenu @0 :comm-menu
   make "names-list remove-quick    se    :startup-names
                                          "startup-data
                                    se    namelist
                                          burylist
   unbury :names-list
   erase :names-list
   pprop "startup-data "keepers [ startup-data result1 result2 ]
   recycle
   toplevel ]

; *** closeall

make "closeall [
   procedure [ ]
   while [ not emptyp filelist ] [ close first filelist ]
   while [ not emptyp screenlist ] [ closescreen first screenlist ]
   while [ not emptyp windowlist ] [ closewindow first windowlist ]
   while [ not emptyp system 6 ] [ freemem first system 6 ]
   pprop "startup-data "screen @0
   remprop "startup-data "speak-handle
   closepalette false
   setmenu @0 [ ]
   whenmenu [ ]
   whenclose [ ]
   whenmouse [ ]
   whenchar [ ]
   whenmessage [ ]
   whenreply [ ] ]

;  *** interupt

make "interrupt [
   procedure [ ]
   pr [ INTERRUPT type 'stop' to resume. ]
   while [ true ]
   [  catch "error [
      while [ true ]
      [  type "-->
         while [ not linep ] [ sleep ]
         run rl ] ]
   poerror ] ]

; *** Save names, their bindings, and their protection status to file.

make "prosave [ 
   procedure [ [ :ps-file-name :ps-names ] [ ] [ :ps-buried :ps-file ] ] 
   if listp :ps-names 
   [  make "ps-buried filter-quick "buriedp :ps-names ] 
   [  if buriedp :ps-names 
      [  make "ps-buried se :ps-names [ ] ] 
      [  make "ps-buried [ ] ] ] 
   if emptyp :ps-buried 
   [  save :ps-file-name :ps-names ] 
   [  make "ps-file open :ps-file-name 
      catch "error 
      [  fprint :ps-file [ ] 
         ( fshow :ps-file "unbury :ps-buried ) 
         fprint :ps-file [ ] 
         fprintout :ps-file :ps-names 
         fprint :ps-file [ ] 
         ( fshow :ps-file "bury :ps-buried ) 
         fprint :ps-file [ ] ] 
      close :ps-file
      saveicon :ps-file-name ] ]


; SORT *****************************************************************
;    MergeSort an object according to a test criterion.
;  sort test object

make "sort [
  procedure [ [ :_sr_cmp :_sr_obj ] [ ] [ :_sr_x :_sr_a :_sr_b ] ]
  make "_sr_x count :_sr_obj
  if <= :_sr_x 1  [ op :_sr_obj ]  [ ]
  make "_sr_a sort :_sr_cmp items 1 / :_sr_x 2 :_sr_obj
  make "_sr_b sort :_sr_cmp restof int / :_sr_x 2 :_sr_obj
  make "_sr_x emptyof :_sr_obj
  while [ true ] [
    if run se :_sr_cmp [ first :_sr_a first :_sr_b ]
       [ make "_sr_x fput first :_sr_a :_sr_x
         make "_sr_a bf :_sr_a
         if emptyp :_sr_a  [ op combine reverse :_sr_x :_sr_b ]  [ ] ]
       [ make "_sr_x fput first :_sr_b :_sr_x
         make "_sr_b bf :_sr_b
         if emptyp :_sr_b  [ op combine reverse :_sr_x :_sr_a ]  [ ] ] ] ]

; COMBINE **************************************************************
;    Contatenates using either `se' or `word' based on second input.
;  combine obj1 obj2

make "combine [
  procedure [ [ :_cb_obj1 :_cb_obj2 ] ]
  op if wordp :_cb_obj2
    [ word :_cb_obj1 :_cb_obj2 ]
    [ se :_cb_obj1 :_cb_obj2 ] ]

; EMPTYOF **************************************************************
;    Returns empty word or empty list depending on the input object.
;    Note:  The input object must be a quoted word -- the name of the
;     object to be tested.  E.g., `emptyof "obj'; not `emptyof :obj'
;  emptyof word

make "emptyof [
  procedure [ [ :_em_obj ] ]
  op if listp :_em_obj  [ [ ] ]  [ " ]  ]

; REVERSE **************************************************************
;    Reverse the order of the items in an object.
;  reverse object

make "reverse [
  procedure [ [ :_rv_obj ] [ ] [ :_rv_res ] ]
  make "_rv_res emptyof :_rv_obj
  while [ not emptyp :_rv_obj ] [
    make "_rv_res fput first :_rv_obj :_rv_res
    make "_rv_obj bf :_rv_obj ]
  op :_rv_res ]

; FILTER ***************************************************************
;    Output object containing items satisfying the test.
;  filter test-func input-obj

make "filter [
  procedure [ [ :_fl_func :_fl_obj ] ]
  op reverse filter-quick :_fl_func :_fl_obj ]

; *** Like 'filter', but does not preserve order. 

make "filter-quick [
  procedure [ [ :_fl_func :_fl_obj ] [ ] [ :_fl_res ] ]
  make "_fl_func se :_fl_func [ first :_fl_obj ]
  make "_fl_res emptyof :_fl_obj
  while [ not emptyp :_fl_obj ] [
    if run :_fl_func
       [ make "_fl_res fput first :_fl_obj :_fl_res ]
       [ ]
    make "_fl_obj bf :_fl_obj ]
  op :_fl_res ]

; REMOVE ***************************************************************
;    Output second object after removing any items that are also in the
;     first object.
;  remove remove-items input-obj

make "remove [
  procedure [ [ :_rm_rmvs :_rm_obj ] ]
  op reverse remove-quick :_rm_rmvs :_rm_obj ]

; *** Like 'remove', but does not preserve order. 

make "remove-quick [
  procedure [ [ :_rm_rmvs :_rm_obj ] [ ] [ :_rm_res ] ]
  make "_rm_res emptyof :_rm_obj
  while [ not emptyp :_rm_obj ] [
    if memberp first :_rm_obj :_rm_rmvs
       [ ]
       [ make "_rm_res fput first :_rm_obj :_rm_res ]
    make "_rm_obj bf :_rm_obj ]
  op :_rm_res ]


;  ***************************************************************
;  ***   ARexx support
;  ***************************************************************

;  This allows LOGO to act as a command host and function host for ARexx.
;  LOGO gets a list from the message and 'run's it.

make "host-port-demon [
   procedure [ [ ] [ ]
      [  :m-packet :m-action :m-text :rc1 :rc2 :m-cc :m-cf :i ] ]
   make "m-packet getmessage
   make "m-action ( peek 4 :m-packet 7 )
   make "m-text convertstring ( peek 0 :m-packet 10 )
   make "rc1 0
   make "rc2 0
   make "m-cc  if and   >= :m-action 16777216         ; *** command code
                        < :m-action 33554432
               [  make "m-action - :m-action 16777216
                  "COMM ]
               [  if and   >= :m-action 33554432
                           < :m-action 50331648
                  [  make "m-action - :m-action 33554432
                     "FUNC ]
                  [  "ERROR ] ]
   if >= :m-action 262144 [ make "m-action - :m-action 262144 ] [ ]
   make "m-cf  if and   >= :m-action 131072           ; *** command flag
                        < :m-action 262144
               [  make "m-action - :m-action 131072
                  "RESULT ]
               [  0 ]
   if >= :m-action 65536 [ make "m-action - :m-action 65536 ] [ ]
   if ( and    >= :m-action 0
               < :m-action 16
               not = :m-cc "ERROR )
   [  if = :m-cc "FUNC           ; *** if function process argstrings
      [  make "i 11
         repeat :m-action
         [  make "m-text   se    :m-text
                                 convertstring ( peek 0 :m-packet :i )
            make "i + 1 :i ]
         make "m-text lput ") :m-text
         make "m-text fput "( :m-text ] [ ]
      repeat 1
      [  catch "error
         [  if = :m-cf "RESULT   ; *** run the message
            [  make "rc2 ( allocstring run :m-text false ) ]
            [  run :m-text ]
            break ]
         make "rc1 10            ; *** process errors?
         make "rc2 first error ] ]
   [  make "rc1 10
      make "rc2 100 ]
   if =0 :rc1 [ ]
   [  mp-error    [ *** WARNING! Incoming message error! *** ]
                  hostport :m-text :rc1 :rc2
      ( pr [ Action code: ] ( peek 4 :m-packet 7 ) )
      if = :rc2 100 [ pr [ ] ] [ poerror ] ]
   ( poke 4 :m-packet :rc1 8 )   ; *** send reply 
   ( poke 4 :m-packet :rc2 9 )
   replymessage :m-packet ]


;  ***************************************************************

;  Procedures to communicate with ARexx, or any other program with
;  an ARexx compatible message port.

;  LOGO command to send an ARexx command.

;  command        text ( port-name host-name file-ext )
;           text =   Word or list containing instruction to be run
;                    by the command destination.
;           port-name = Name of destination port, default 'REXX'.
;           host-name = Name of port to get commands back from ARexx,
;                       default output of 'hostport'.
;           file-ext =  File name extension ARexx will use to find
;                       command, default 'LOGO'.

make "command [
   procedure [    [ :m-text ]
                  [ :port-name :host-name :file-ext ]
                  [ :m-packet ] ]
   make "m-packet create-message :m-text [ ] :host-name :file-ext 16777216
   if emptyp :port-name [ make "port-name "REXX ] [ ]
   send-sync :port-name :m-packet
   make "result1 ( peek 4 :m-packet 8 )
   make "result2 ( peek 4 :m-packet 9 )
   delete-message :m-packet ]


;  ***************************************************************


make "clean-quit [
   procedure [ ]
   while [ messagep ] [ replymessage getmessage ]
   while [ replyp ] [ pr getreply ]
;   remove-function-host
   quit ]


make "send-sync [
   procedure [ [ :port-name :m-packet ] [ ] [ :r-packet ] ]
   whenreply [ ]
   sendmessage :port-name :m-packet
   while [ true ]
   [  sleep
      if replyp
      [  make "r-packet getreply
         if = :r-packet :m-packet [ ]
         [  reply-port-demon :m-packet ]
         break ] [ ] ] ]
   whenreply [ reply-port-demon getreply ]


make "mp-error [
   procedure [ [ :e :port-name :m-text :r1 :r2 ] ]
   pr [ ]
   pr :e
   ( pr [ Port:\  \  \  \   ] :port-name )
   ( pr [ Message: \  \  ] :m-text )
   ( pr [ Error level: ] :r1 )
   ( pr [ Error code:\  ] :r2 ) ]


make "create-message [
   procedure [    [ :m-text :m-args
                    :host-name :file-ext :action ] [ ]
                  [ :m-packet :i ] ]
   if emptyp :host-name [ make "host-name hostport ] [ ]
   if emptyp :file-ext [ make "file-ext "LOGO ] [ ]
   make "m-packet allocmem 128
   ( poke 2 :m-packet 128 9 )
   make "i 0
   while [ and    not emptyp :m-args
                  < :i 15 ]
   [  ( poke 4 :m-packet allocstring first :m-args + 11 :i )
      make "m-args bf :m-args
      make "i + 1 :i ]
   ( poke 4 :m-packet ( + :action :i ) 7 )
   ( poke 4 :m-packet allocstring :m-text 10 )
   ( poke 4 :m-packet allocstring :host-name 27 )
   ( poke 4 :m-packet allocstring :file-ext 28 )
   make "result1 0
   make "result2 0
   output :m-packet ]


make "delete-message [
   procedure [ [ :m-packet ] [ ] [ :i ] ]
   make "i 10
   repeat 16
   [  freemem ( peek 0 :m-packet :i )
      make "i + 1 :i ]
   freemem ( peek 0 :m-packet 27 )
   freemem ( peek 0 :m-packet 28 )
   freemem :m-packet ]


;  ***************************************************************
;  ***************************************************************


make "set-turtle [
   procedure [ [ ] [ :v :d ] ]
   if buriedp "turtle-names
   [  ( turtle :v :d ) ]
   [  pr [ ]
      pr [ Loading Turtle Shell - Please Wait ]
      load "Utilities/Turtle-Shell
      ( turtle :v :d )
      pr [ Turtle Shell - Ready ] ] ]


; *********************************************************************

make "comm-menu [

   \ LOGO\ 
      [ \ Load ]
      [ \ Save ]
      [ \ Edit E ]
      [ \ Edit\ File ]
      [ \ Turtle ]
      [ \ Interrupt ]
      [ \ Top\ Level G ]
      [ \ Quit ]
]


; *********************************************************************

make "switch [
   procedure [ [ :s-item :s-list ] ]
   if =0 :s-item [ ] [ run item :s-item :s-list ] ]

make "comm-menu-demon [
   procedure [ [ :menu-data ] [ ] [ :menu-temp ] ]
   if = 1 item 2 :menu-data
   [  switch item 3 :menu-data
      [  [  make "menu-temp ( filerequest "Load\ File\ \ -\  )
            if emptyp :menu-temp [ ] [ load :menu-temp ] ]
         [  make "menu-temp ( filerequest "Save\ File\ \ -\  )
            if emptyp :menu-temp [ ]
            [  save  :menu-temp
                     remove-quick   se    gprop "startup-data "keepers
                                          [  s-item s-list
                                             menu-data menu-temp ]
                                    namelist ] ]
         [ edit ]
         [ edf [ ] ]
         [ set-turtle type "? ]
         [ system 11 interrupt ]
         [ toplevel ]
         [ clean-quit ] ] ] [ ] ]


; *********************************************************************

; *** Initialize ***

   ( seedrand seconds )       ;  Scramble random number generater.

   pprop "startup-data "screen @0
   pprop "startup-data "work-file "RAM:LOGO-Workspace

   pprop "startup-data "keepers [ startup-data result1 result2 ]

   whenmessage [ host-port-demon ]
   whenmenu [ comm-menu-demon getmenu ]
   setmenu @0 :comm-menu

   make "startup-names [ startup-names
      say edit ed edf from-editor all allnames allprocs names procs 
      ignore existp vpr spr pots flush reset closeall interrupt
      prosave sort combine emptyof
      reverse filter filter-quick remove remove-quick host-port-demon
      command clean-quit send-sync mp-error create-message delete-message
      set-turtle switch comm-menu-demon comm-menu ]
   
   bury :startup-names

   make "args argslist

   make "arg first :args      ;  Set current directory.
   while [ not emptyp :arg ] [
      if or  = "/ last :arg  = ": last :arg
      [ break ]
      [ make "arg bl :arg ] ]
   if emptyp :arg [ ] [ ( cd bl :arg ) ]

launch [

   while                      ;  Load startup argument files.
   [  make "args bf :args
      not emptyp :args ]
   [  make "arg first :args
      make "c count :arg
      if if >= :c 12
         [  not = restof - :c 12 :arg "LOGO-Startup ]
         [  true ]
      [  ( pr "LOADING\ FILE:\ \  :arg )
         load :arg ]
      [ ] ]

   erase [ args arg c ]

   ( recycle 1 )

   pr [ Initialize Complete ]

]
