
   Words-Lists.doc

Some procedures for processing words and lists. Some of these procedures
require sub-procedures defined in the default 'LOGO-Startup' file.


col-print      object ( margin spacing )
         object = Any list or word.
         margin = Integer.
         spacing = Integer.
   Prints the contents of a (flat) list in vertical columns.  `margin'
   is the number of spaces from the left to start the first column
   (default is 0).  `spacing' is the minimum number of spaces required
   between columns (from end of longest item to start of next column)
   (default is 4).

dr             ( path pattern )
               ( path pattern-list )
         path = An AmigaDOS directory name (word or list).
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
   Print out contents of directory.

dra            ( path pattern )
               ( path pattern-list )
         path = An AmigaDOS directory name (word or list).
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
   Print out contents of directory, and all sub directories.

eval          run-object
         run-object = Word, or list of LOGO instructions.
   Similar to `run', but can be used on words as well as lists.

for           word n1 n2 n3 run-list
         word = Name of the loop variable.
         n1 = Number; initial value.
         n2 = Number; final value.
         n3 = Number; stepping value.
         run-list = List of LOGO instructions.
   The `for loop' executes the run list repeatedly, while assigning
   values to the loop variable.  On the first iteration, the loop variable
   is assigned the value of `n1'.  On subsequent iterations, the loop
   variable is adjusted `n3'.  When the loop variable "goes beyond" `n2',
   the loop stops.  The loop variable should be local to calling
   procedure.  The run list should not produce an output.  Use `ignore',
   if necessary.  See examples below.

foreach       word object run-list
         word = Name of the loop variable.
         object = Any word or list.
         run-list = List of LOGO instructions.
   The `foreach loop' executes the run list repeatedly, while assigning
   values to the loop variable.  On each iteration, the loop variable is
   assigned, in order, an item from `object'.  The loop variable should be
   local to calling procedure.  The run list should not produce an output.
   Use `ignore', if necessary.  See examples below.

lcase          object
         object = Any word or list.
   Output is just like input with all upper case letters converted to
   lower case.

link           name
         name = Word, a procedure name.
   Output list of all procedures needed to run the named procedure.

list->word     list
         list = Any non-nested (flat) list.
   Concatenates the words in the list into a single word.

map            procedure object
         procedure = A word that is a procedure name or list of commands
                     that will operate on a single argument.
         object = Any list or word.
   Output object after applying the procedure to each item.  Example,
   `map [ + 1 ] [ 1 2 3 4 ]' produces `[ 2 3 4 5 ]'.

map2           procedure object object
         procedure = A word that is a procedure name or list of commands
                     that will operate on two arguments.
         object = Any list or word.
   Output object that results from applying the procedure to items taken,
   in order, from objects.  The objects would normally be of the same
   length, but may be of different lengths, in which case the "extra" is
   appended to the result.  See examples below.

matchp         pattern word
               pattern-list word
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
         word = Any word.
   Output true if word fits pattern.

patfilter      pattern list
               pattern-list list
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
         list = A list of words.
   Output list of all words in the list that fit the pattern.

reduce        procedure obj1 obj2
         procedure = A word that is a procedure name or list of commands
                     that will operate on two arguments.
         obj1 = Any list or word that will serve as the `zero case'.
         obj2 = Any list or word that is to be operated on.
   Output the result of recursively applying the procedure to `obj2' with
   `obj1' serving as the base or `zero' case.  See examples below.

sdir           ( path pattern )
               ( path pattern-list )
         path = An AmigaDOS directory name (word or list).
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
   Output sorted directory list.

sdira          ( path pattern )
               ( path pattern-list )
         path = An AmigaDOS directory name (word or list).
         pattern = Word, a match pattern. Within a pattern the asterisk
                   (*) is a wild card and will match any group of zero
                   or more characters. A pattern that starts with a
                   tilde (~) will match anything that does not match the
                   rest of the pattern.
         pattern-list = A list of patterns.
   Output sorted directory list.

ucase          object
         object = Any word or list.
   Output is just like input with all lower case letters converted to
   upper case.

word->ascii    word
         word = Any word.
   Converts a word into a list of ASCII values for each characters.

word->list     word
         word = Any word.
   Converts a word into a list of single character words.

Examples:

The following procedure illustrates the use of `for':

   make "countdown [
     procedure [ [ ] [ ] [ :cnt ] ]
     for "cnt 10 1 -1 [
       pr :cnt
       wait 1 ]
     pr "Blast-off! ]

The following procedure illustrates the use of `foreach':

   make "vertical-word [
     procedure [ [ :wrd ] [ ] [ :chr ] ]
     foreach "chr :wrd [ pr :chr ] ]

The following are examples of using map2:

   map2 "+ [ 1 2 3 ] [ 4 5 6 ]
   [ 5 7 9 ]

   map2 [ * 2 + ] [ 1 2 3 ] [ 2 3 4 5 ]
   [ 6 10 14 5 ]

   map2 "fput "xxx [ a b c ]
   [ xa xb xc ]

   map2 "fput "xxx [ a b c d ]
   [ xa xb xc d ]

   map2 "fput "xxxx [ a b c ]
   xaxbxcx

Reduce is a powerful, advanced programming construct for operating on
lists and words.  Several procedures in this file make use of it (see
list->word, word->list and word->ascii).  (There are others that could have
used reduce, but were "hard-coded" for speed.)  Reduce recursively applies
a function to the elements of an object.  When the "end" of the object is
reached, the `zero case' is used to complete the process.  To sum the
numbers in a list, for example:

   reduce "+ 0 [ 1 2 3 4 ]
   10

`reduce' effective produces the following:

   + 1 + 2 + 3 + 4 0

Similarly,

   reduce "* 1 [ 2 3 4 5 ]
   120

is equivalent to:

   * 2 * 3 * 4 * 5 1

To reverse a list, we could use:

   make "rev-list [
     procedure [ [ :lst ] ]
     output reduce "lput [ ] :lst ]

which would work as follows:

   rev-list [ a b c ]
   [ c b a ]

which is equivalent to:

   lput a lput b lput c [ ]

