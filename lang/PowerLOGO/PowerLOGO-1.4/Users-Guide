
   Power LOGO
   Release 1.4
   Copyright 1994
   by Gary Teachout

This program is freeware, and may be distributed freely. It may be
distributed along with other freely distributable software. All other
rights reserved. It may not be sold for profit, or included as part of a
commercial product without my permission. Power LOGO should be distributed
together with the entire contents of the 'PowerLOGO' directory. No
donations are required but they are accepted and appreciated.

THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO ITS FITNESS FOR ANY
PARTICULAR PURPOSE. This software is experimental and IT HAS DEFECTS, if
you do not accept all of the risks and responsibilities of using defective
software, then DO NOT USE THIS.

[1mTable of Contents

Preface

Acknowledgments

Chapter 1  Power LOGO[0m
      Features
      The Power LOGO dialect

[1mChapter 2  Getting started[0m
      Running LOGO
      Startup file
      Command window
      Project Files

[1mChapter 3  Programming[0m
      Words and Lists
      Instructions
      Procedures
      Recursion

[1mChapter 4  Advanced Topics[0m
      Files
      Graphics
      Turtles
      Sound
      Demons
      Messages and Ports
      System Memory
      User Memory

[1mChapter 5  Primitives

Appendix A  Errors

Appendix B  Limits

Appendix C  Compatibility

Appendix D  Recommended Reading

Preface[0m

Programming languages have evolved, and improved a great deal. Modern
versions of BASIC, for example, bare little resemblance to those available
ten years ago. Numbered lines are gone, subprograms have been added, and
they now include support for modern hardware and user interfaces. Most of
this progress has left LOGO behind. Because of its early success with
elementary students, it has acquired a reputation as a toy language for
kiddies. Most versions of LOGO have no modern improvements, like support
for modern hardware or user interfaces.

As a dialect of LISP, LOGO is actually a very powerful and versatile
programming language. Power LOGO is an atempt to bring LOGO up to date, by
adding the kind of features you would expect from any modern language. My
priorities for Power LOGO are simplicity, and versatility, before
compatibility.

This file covers the details of Power LOGO, but it is not intended to teach
the LOGO programming language. For learning LOGO I recommend Computer
Science Logo Style, Volume 1, by Brian Harvey (see appendix D Recommended
Reading).

You can help me to improve this version of LOGO. Please contact me with any
comments or bug reports. I am also interested in how you use LOGO, and
would like to see your program examples, demos, tutorials, etc.

      Gary Teachout 
      10532  66 Place, W
      Mukilteo, WA  98275
      USA


[1mAcknowledgments[0m

I would like to thank the following for helping to make PowerLOGO work as
well as it does, and for saving me a lot of work:

 * Justin V. McCormick, for the PathMaster file selector (filerequest).

 * Software Dissidents, for the ILBM.Library (loadimage, saveimage).

[1mChapter 1  Power LOGO[0m

Power LOGO is an experimental dialect of the LOGO programming language. It
is a very high level language, easy to use, and easy to learn. Yet it has
some low level power as well.

[1mFeatures[0m

 * Power LOGO uses the simplest subset of LOGO syntax, and is defined by
   the simplest rules.

 * User defined procedures are not limited to a fixed number of inputs,
   they may be defined with required inputs, optional inputs, and local
   variables.

 * Much of the Amiga graphics capability is supported. Primitives are
   provided to open custom Intuition screens and windows, draw lines,
   patterned lines, text, flood fills, copy regions, etc.

 * Turtle graphics with multiple turtles. Each turtle may have its own
   sense of distance, direction, home, line pattern, etc.

 * A universal host message port for inter process communication,
   including ARexx support.

 * Demons (high-level interrupts) may be programmed to respond to events
   from the keyboard, menus, left mouse button, host message port, reply
   message port, and window close gadgets.

 * Menus may be attached to any window. Along with menu demons this allows
   LOGO programs to have friendly user interfaces. You may customize the
   LOGO user interface by attaching your own menus to the LOGO command
   window.

 * All arithmetic uses the Amiga 'mathieeedoubbas.library', this includes
   automatic support for 68881.

 * Sounds may be played on all four of the Amiga audio channels.

 * Power LOGO provides many primitives not typically found in LOGO.
   Primitives for arithmetic (frac, log, power...), flow of control (cond,
   dowhile, whenmenu, while...), words and lists (alphap, items,
   restof...), and more.

[1mThe Power LOGO dialect[0m

Power LOGO differs from traditional LOGO in these important ways:

 * It is case sensitive. All primitives and keywords are lower case, all
   names and data defined may be any case.

 * Spaces are sacred. All LOGO objects (words, lists, list brackets, and
   parenthesis) must be separated by white space (a space, or a linefeed).

 * It uses prefix (polish) notation only. Inputs to a procedure follow to
   the right of the procedure name. There are no infix operations, no
   implied spaces, and no special delimiters.

 * It has no 'TO' or 'END' primitive. User defined procedures are just
   variables that contain a special type of list, and are defined using the
   'make' primitive. This idea of programs as data is unusual but can be
   very useful.

 * There is no built-in text editor. Project files may be created and
   edited almost any text editor.

 * Other differences relate to the name, spelling, inputs, and behavior of
   individual primitives.

While some of the above may seem restricting, it keeps Power LOGO simple,
and should not be difficult to learn.

[1mChapter 2  Getting started

Running LOGO[0m

LOGO may be run in the usual way from the WorkBench or the CLI. You may
exit LOGO by entering the quit command.

Power LOGO should run on most Amiga computers, it requires about 250 K
bytes, but can use all available memory if needed. To use the 'saveimage',
and 'loadimage' commands, your LIBS: directory must contain the
'ILBM.Library' by Software Dissidents. Your LIBS: directory must also
contain the Amiga 'mathieeedoubbas.library'.


[1mStartup file[0m

If a file called LOGO-Startup is found in the same directory with LOGO it
will be loaded to initialize LOGO. This file should contain LOGO code that
will load any project files in the 'argslist'. It may also be used to
configure LOGO the way you like, and to load your own frequently used
procedures, and data.

The default 'LOGO-Startup' file will define some useful procedures, install
a menu user interface, and load any project files selected, or named as
arguments.


[1mCommand window[0m

LOGO opens a window on the workbench screen as its command input and output
window. You may enter and edit LOGO commands with these special keys.

   Backspace            Delete character to the left of the cursor.
   Cursor Right         Move cursor right one space.
   Cursor Left          Move cursor left one space.
   Cursor Up            Move backward through the command history.
   Cursor Down          Move forward through the command history.
   Control-G            Stop program, return to top level.
   Control-K            Delete from cursor to end of line.
   Control-U            Delete from cursor to start of line.
   Control-X            Delete the line.
   Delete               Delete character under the cursor.
   Return               Enter list or instructions.
   Shift Cursor Right   Move cursor to end of line.
   Shift Cursor Left    Move cursor to start of line.

The '? ' prompt means LOGO is waiting for a command. If the command line
contains an open list (an open bracket '[' without a closing bracket ']')
you will see the '1 > ' prompt allowing you to continue the list on another
line.

   ? repeat 20 [
   1 > setcursor list random 40 random 20
   1 > pr "HELLO! ]

[1mProject Files[0m

There is no built-in text editor. LOGO stores programs as ASCII text files,
which may be created and modified using any text editor. Some text editors
remove trailing blank spaces from the ends of lines, if this removes a
space following a backslash it will cause problems.

The 'save' primitive will save the contents of variables in the LOGO
workspace, as 'make' commands. The 'load' primitive will execute the
instructions in a file just as if typed into the command window. 'load',
and 'save' complement one another. Comments may be included in project
files by prefixing them with a semicolon (;), the semicolon and everything
from it to the end of the line will be ignored (note that the semicolon
must be surrounded by white space to be recognized as a comment character).

[1mChapter 3  Programming

Words and Lists[0m

In the Power LOGO programming environment, everything is either a word or a
list. Words can be any sequence of characters. Words are separated from
each other by blank spaces, to include a space (or a backslash) in a word
it must be preceded by a backslash (\). Numbers are just a special type of
word. Numbers prefixed with an '@' symbol will be recognized by some
procedures as pointers. Lists can be any sequence of objects, which may be
ether words or lists. Lists are identified by enclosing them in brackets
'[]'.

   This-is-a-word!
   [ This is a list! ]


[1mInstructions[0m

Words and lists may be either data or instructions. An instruction is a
procedure name followed by any inputs the procedure may require. When LOGO
tries to evaluate a word it may treat it in one of three ways, as a
literal, as a variable, or as a procedure. Words preceded by a quote (")
character (called quoted words) are literal and evaluate as the word
itself. For words that happen to be numbers or pointers the quote is not
needed. Words preceded by a colon (:) character (called dotted words) refer
to the contents (binding) of a variable name. A word by itself (no dots or
quote) is evaluated as a procedure (unless it is a number or pointer).

   ? print 123
   123

Here 'print' is a procedure, and the number '123' is its input. The 'print'
procedure simply prints its inputs on next line in the command window.

   ? print [ This is a list! ]
   This is a list!

In this example the list (everything between the brackets) is the input to
the 'print' command. 

   ? print "This-is-a-word!
   This-is-a-word!

In this example the quote (") identifies the input as a literal word.

The inputs to a procedure need not be literal, they may be the contents of
a variable, or the output of another instruction. Instructions may be
nested as inputs within other instructions.

   ? pr * 7 6
   42

Here '*' is another procedure '6' and '7' are its inputs. '*' outputs the
product of its inputs to pr ('pr' is just an abbreviation for 'print')
which prints it on the next line. It is important to note that the
sub-instruction '* 7 6' is not the input to 'pr', but is evaluated, and its
output is the input to 'pr'.

   ? make "x 100
   ? pr :x
   100

In the first line the 'make' procedure assigns 100 as the contents of the
variable 'x'. In the second line ':x' refers to the contents of 'x'.

Each procedure has some number of required inputs (zero or more), and some
number of optional inputs (zero or more). To include optional inputs the
entire instruction must be enclosed in parenthesis. If only the required
inputs are used, the parenthesis are not needed. Print requires one input
but may have many.

   ? ( pr "PI "= 3.1415 )
   PI = 3.1415

In this instruction 'pr' has three inputs.

   ? ( pr [ And the answer is ] * 4 ( + 1 2 3 ) )
   And the answer is 24

This entire line is one instruction where 'pr' has two inputs, the first 
is the list '[ And the answer is ]', the second is the instruction
'* 4 ( + 1 2 3 )'. This second instruction '*' has two inputs '4' and
another instruction '( + 1 2 3 )'.  


[1mProcedures[0m

Primitives are the procedures that are built-in to LOGO. You may define
your own procedures and add them to LOGO. In Power LOGO a procedure is just
a variable that contains a special type of list, and may be defined using
the 'make' primitive. The first item in a procedure definition list is the
word procedure. The second item is a list of lists of names of the inputs
and local variables used by the procedure (the names list). The rest of the
items in the definition are the instructions executed by the procedure.

   ? make "hello [ procedure [ ] pr [ Hello World ! ] ]
   ? hello
   Hello World !

Because this example procedure uses no inputs or local variables the names
list may be empty.

The first item of the variable names list is a list of required inputs. The
second item is a list of optional inputs or a name to receive a list of
optional inputs. The third item is a list of names of local variables.
Local variables and unused optional inputs contain the empty list at the
start.

   ? make "hello [
   1 > procedure [ [ ] [ :n ] ]
   1 > repeat if numberp :n [ :n ] [ 1 ] [
   2 > pr [ Hello World ! ] ] ]

   ? hello
   Hello World !

   ? ( hello 3 )
   Hello World !
   Hello World !
   Hello World !

   ? ( hello 0 )

This example uses one optional input. See the example files for other forms
of names lists.

Global, free, and local variables all work as they would in lisp. All
variable names in a procedure names list are local within each call to that
procedure. They are free variables to all procedures called from within
that procedure or at a lower level.


[1mRecursion[0m

A procedure that includes a call to itself is called a recursive procedure.

   ? make "factorial [
   1 > procedure [ [ :f ] ]
   1 > output if < 1 :f [ * :f factorial - :f 1 ] [ :f ] ]
   ? factorial 5
   120

This procedure uses recursion to compute the factorial of its input.

A procedure in which the recursive call is the last instruction is called
tail recursive. Tail recursion is handled differently by LOGO because the
local variables need not be preserved. Two cases are recognized as tail
recursion, a recursive operation as the input to an 'output' command, or a
recursive command followed by a 'stop' command.

   ? make "count100 [
   1 > procedure [ [ :x ] ]
   1 > pr :x
   1 > if < :x 100 [ output count100 + :x 1 ] [ output :x ] ]

   ? make "count-up [
   1 > procedure [ [ :x ] ]
   1 > pr :x
   1 > count-up + :x 1
   1 > stop ]

In the second example the 'stop' command is never executed, but it is
necessary for LOGO to recognize the call to 'count-up' as tail recursion,
without it 'count-x' would run out of memory.

[1mChapter 4  Advanced Topics

Files[0m

Primitives are provided to save and load the contents of variables
(including procedures), read and write data, save and load IFF images,
attach icons to files, and get a filename through a file requester.

The 'save' primitive saves the contents of variables to a file as 'make'
commands. The 'load' command executes a text file as if it were typed at
the command window except that comments are ignored (a comment is
everything from a semicolon ';' to the end of the line).

The 'saveimage', and 'loadimage' primitives copy the contents of a window
to or from an IFF ILBM file. For these to work the 'ILBM.Library' by
Software Dissidents must be in the LIBS: directory.

The 'filerequest' primitive outputs an AmigaDOS file name selected with the
PathMaster file selector by Justin V. McCormick. 'filerequest' may be used
as input to any procedure that requires a file name.

   make "file-name filerequest
   load :file-name

To read or write a data file it must first be opened with 'open' (a new
file to be written), or 'openold' (an existing file to be read or
appended). Each of these outputs a file pointer (a BCPL pointer to an
AmigaDOS file handle) which must later be closed using 'close'. The
primitives for reading and writing files accept a file-pointer as input and
work much like their command window counterparts. This example will create
or overwrite a file:

   make "file-handle open filerequest
   fprint :file-handle [ The quick brown fox... ]
   close :file-handle

This example will read an existing text file into a list of lists:

   make "text-list [ ]
   make "file-handle openold filerequest
   while [
      make "line freadlist :file-handle
      not wordp :line
      ] [ 
      make "text-list lput :line :text-list ]
   close :file-handle

[1mGraphics[0m

Much of the Amiga graphics capability is available in Power LOGO.
Primitives are provided to open custom intuition screens and windows, draw
lines, patterned lines, text, flood fills, and copy regions.

Graphics are rendered into windows which must first be opened with
'openwindow'.

   make "myscreen ( openscreen 3 2 [ My Screen ] )
   make "mywindow ( openwindow :myscreen 3 [ My Window ] 50 30 500 150 )

The window graphics primitives require a pointer to a window as an input.
Coordinates within windows start with (0,0) in the upper left corner and
count pixels to the right and down.

   setpen :mywindow 1
   move :mywindow 20 20
   draw :mywindow 400 80
   text :mywindow [ Window Graphics ]

   closescreen :myscreen

Windows may be closed using 'closewindow', 'closescreen' will also close
any windows that were open on that screen.


[1mTurtles[0m

Turtles are graphics tools based on relative movement. You may open many
turtles, each is opened onto a window, has its own coordinate system, and
has its own sense of location, distance, and direction, as well as its own
foreground pen, background pen, draw mode, and line pattern.

Turtles must be opened onto a window with 'openturtle' (the 'Turtle-Shell'
file will do this for you).

   make "myscreen ( openscreen 3 2 [ My Screen ] )
   make "mywindow openwindow :myscreen
   make "myturtle openturtle :mywindow

By default the turtle commands control all active turtles, but may be
directed to control specific turtles (active or not).

   repeat 32 [ fd 50 rt 170 ]

Turtle operations output information about one specified turtle.

   make "pos tpos :myturtle
   make "head heading :myturtle

Turtles may be closed with 'closeturtle', but 'closewindow, and
'closescreen' will also close any turtles that were open on that window or
screen.

[1mSound[0m

Sounds may be played on all four of the Amiga audio channels. Audio
waveform data is an array of one byte signed numbers (-127 to 127) and must
first be placed into chip ram. This will create a simple sound:

   make "sound-data allocchip 16
   make "i 0
   make "x 120
   repeat 16 [
      poke 1 psum :sound-data :i :x
      make "i + :i 1
      make "x - :x 16 ]

   sound ( se :sound-data 16 250 64 100 ) [ ] [ ] [ ]
   sound ( se :sound-data 16 240 64 100 ) [ ] [ ] [ ]
   sound ( se :sound-data 16 300 64 100 ) [ ] [ ] [ ]

The 'sound' command may then be played repeatedly.


[1mDemons[0m

A demon may be thought of as a process separate from your main program,
that keeps testing for a particular kind of event. When the event is
detected the demon interrupts the main program and runs a special
procedure. When the procedure is complete the main program will resume.

There are six types of events that may trigger demons, menu selection, left
mouse button, key stroke, window close gadget, host message port, and reply
message port. For each of these there is an event queue, when the event
queue is not empty, the demon procedure will be run. The demon procedure
must execute the appropriate get operation to remove the event from the
queue, or the demon will run again and again.

make "m-window openwindow [ @0 131 [ Mouse Paint ] 320 ]
whenmouse [
   while [ mousep ] [ make "m-d getmouse ]      ;  Remove mouse event.
   if = :m-window first :m-d [                  ;  Correct window?
      move :m-window item 2 :m-d item 3 :m-d    ;  Move cursor.
      make "m-d mouse :m-window                 ;  Check mouse.
      while [ = 1 item 3 :m-d ] [               ;  While button is down
         draw :m-window first :m-d item 2 :m-d  ;  Draw to pointer.
         make "m-d mouse :m-window              ;  Check mouse.
      ]
   ] [ ]
]

This simple example of demons in action is from the example file
'Mouse-Paint'. For more examples of demons see the 'LOGO-Startup',
'Turtle-Shell', and 'ARexx-Support' files.

[1mMessages and Ports[0m

A general purpose message port is available for inter process
comunication.

A message is just an area of memory, sending a message is just a way of
telling another Amiga program that it can look at or change this message.
When the other program is through with the message it should reply to it.
After sending a message a program must not alter the message until the
reply is received.

To receive messages programs must have a message port. Ports are
identified by name, the default name for LOGOs host port is 'LOGO' (it can
be changed). If more than one copy of LOGO is running, they will have names
'LOGO 2', 'LOGO 3', etc. 

A message must be at least twenty bytes long, the first twenty bytes are
used by the Amiga system to keep track of the message when sent. Run two
copies of LOGO, and this example will send lines typed into one copy of
LOGO, and print them on the other:

In the first copy of LOGO:

   while [ true ] [
      make "message getmessage
      pr convertstring ( peek 0 :message 5 )
      replymessage :message ]

In the second copy of LOGO:

   make "message allocmem 24
   ( poke 2 :m-packet 24 9 )
   while [ true ] [
      type "message?
      ( poke 0 :message allocstring rl 5 )
      sendmessage "LOGO :message
      make "x getreply
      freemem ( peek 0 :message 5 ) ]

The 'host-port-demon' in the 'LOGO-Startup', and 'ARexx-Support' files
allows other programs to send commands to LOGO. These files also include
procedures for sending messages to ARexx, another copy of LOGO, or other
programs.


[1mSystem Memory[0m

For its own internal use LOGO allocates memory in even 8K byte blocks, and
divides these blocks into small pieces called nodes. When out of nodes,
LOGO runs the garbage collector to search all allocated blocks, and recycle
any nodes that are no longer in use. if the collector finds less than a
certain amount of free memory, it will allocate more blocks. All of this is
dynamic and automatic, and need not be considered when programming in LOGO.
However it is sometimes useful to be able to control this process.

How often the collector runs depends on the amount of extra memory it tries
to hold in reserve. The operation:

   system 1

will output this amount in bytes. The command:

   ( system 2 bytes )

will set this amount (where 'bytes' is a number). When this number is
large, the collector will run less often, but more slowly.

When the garbage collector runs you may notice a brief pause. The command:

   ( recycle 1 )

will force a normal recycle, and may be used to reduce the chance of the
collector causing a pause at a bad time. The command:

   recycle

will also force a recycle, but will also deallocate most of the extra
memory LOGO would normally hold in reserve. This may be used prior to
'openscreen', 'openwindow', or other memory hungry actions. Note that LOGO
will soon reallocate most of this memory.


[1mUser Memory[0m

Sometimes you may need an area of memory for a special purpose (see the
Sound, and Messages sections above). The 'allocmem', 'allocchip', and
'allocstring' primitives each allocate a block of memory and output a
pointer.

   make "block allocmem :size
   make "chip allocchip :size
   make "string allocstring [ The frog sat on the log. ]

'allocmem' and  'allocchip' output a pointer to a block of memory of the
size specified. 'allocstring' outputs a pointer to a null-terminated string
compatible with both C and ARexx.

When you are through with it you may return the memory with 'freemem'.

   freemem :block
   freemem :chip
   freemem :string

LOGO also keeps a list of all these blocks and will free them when you give
the command 'new' or 'quit'. If you do not want LOGO to free a block
automatically use 'false' as an optional input (this is used for reply
strings to ARexx).

   make "string ( allocstring [ function reply ] false )

Or to free a block not in LOGOs user memory list (this is used for reply
strings from ARexx).

   ( freemem :string false )

To help keep track LOGO allways allocates eight bytes more than needed,
stores the total size in the first four bytes, and outputs a pointer to the
ninth byte instead of the first. 'freemem' requires a pointer of this type.

[1mChapter 5  Primitives[0m

Format for descriptions of primitives:

NAME           INPUTS ( OPTIONAL-INPUTS )
SYNONYM        ALTERNATIVE INPUTS
         INPUT = DESCRIPTION OF INPUT.
   FUNCTION DESCRIPTION.

The Power LOGO primitive set:

+              number number ( number... )
sum
         number = Any number.
   Addition, output the sum of all inputs.

-              number number ( number... )
difference
         number = Any number.
   Subtraction, output first input minus all of the other inputs.

*              number number ( number... )
product
         number = Any number.
   Multiplication, output product of all inputs.

/              number number ( number... )
quotient
         number = Any number.
   Division, output first input divided by each of the other inputs.

+-             number
negate
         number = Any number.
   Change sign, output opposite of input.

>              number number ( number... )
         number = Any number.
   Output true if first input is more than all others.

<              number number ( number... )
         number = Any number.
   Output true if first input is less than all others.

>=             number number ( number... )
         number = Any number.
   Output true if first input is more than or equal to all others.

<=             number number ( number... )
         number = Any number.
   Output true if first input is less than or equal to all others.

=0             number ( number... )
         number = Any number.
   Output true if all inputs are equal to zero.

<0             number ( number... )
         number = Any number.
   Output true if all inputs are less than zero.

>0             number ( number... )
         number = Any number.
   Output true if all inputs are more than zero.

>>             number number number ( number ... )
         number = Any number.
   Output true if the rest of the inputs are between the first two.

>>=            number number number ( number ... )
         number = Any number.
   Output true if the rest of the inputs are between or equal to
   the first two.

abs            number
         number = Any number.
   Output absolute value of number.

acos           cosine
         cosine = Number between -1 and 1.
   Inverse cosine, output angle of cosine.

activelist
   Output list of pointers to active turtles.

allocchip      bytes ( predicate )
         bytes = Number of bytes.
         predicate = true or false.
   Allocate chip memory, output pointer, for sound waveform data, etc. This
   allocates eight bytes more than specified, stores the total size in the
   first long-word, and outputs a pointer to the eighth byte. If
   'predicate' is 'true' (or absent) memory will be placed in the user
   memory list for LOGO to keep track of so it can be deallocated
   automatically. If 'predicate' is 'false' LOGO keeps no record of this
   memory.
   See Also:   freemem

allocmem       bytes ( predicate )
         bytes = Number of bytes.
         predicate = true or false.
   Allocate memory, output pointer, for messages, arrays, etc. This
   allocates eight bytes more than specified, stores the total size in the
   first long-word, and outputs a pointer to the eighth byte. If
   'predicate' is 'true' (or absent) memory will be placed in the user
   memory list for LOGO to keep track of so it can be deallocated
   automatically. If 'predicate' is 'false' LOGO keeps no record of this
   memory.
   See Also:   freemem

allocstring    object ( predicate )
         object = Any word or list.
         predicate = true or false.
   Create an ARexx argstring out of object, output pointer. This allocates
   eight bytes more than is needed for the string, stores the total size in
   the first long-word, and outputs a pointer to the eighth byte (the first
   byte of the NULL terminated string). If 'predicate' is 'true' (or
   absent) memory will be placed in the user memory list for LOGO to keep
   track of so it can be deallocated automatically. If 'predicate' is
   'false' LOGO keeps no record of this memory.
   See Also:   freemem

alphap         word word
         word = Any word.
   Output true if words are in alphabetical order.

and            predicate predicate ( predicate... )
         predicate = true or false.
   Output true if all inputs are true.

argslist
   Output list of startup arguments, the first item in the argslist is the
   file name of LOGO, the rest are the args from Workbench, or CLI.

ascii          word
         word = Any word.
   Output ASCII number of first character in word.

asin           sine
         sine = Number between 1 and -1.
   Inverse sine, output angle of sine.

atan           tangent
         tangent = Any number.
   Inverse tangent, output angle for tangent.

back           distance ( turtle ... )
bk             distance ( turtle-list )
         distance = Number, distance in turtle steps.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Move turtles backward distance.

break
   Jump out of looping primitives ('repeat', 'while', and 'dowhile').

buriedp        object
         object = Any word or list.
   Output true if input is a buried variable name.

burylist
   Output list of names that are buried.

bury           name ( name... )
               name-list ( name-list... )
         name = Word, a variable name.
         name-list = List of names.
   Hide and protect input variable names (hide from make,
   erase, namelist, etc.).
   See Also:   unbury

butfirst       object
bf
         object = Any word or list.
   Output all but the first item of the input object.

butlast        object
bl
         object = Any word or list.
   Output all but the last item of the input object.

catch          label run-list
         label = Any word.
         run-list = List of LOGO instructions.
   Execute run-list, set trap for matching throw. The label 'error' may be
   used to trap errors.
   See Also:   throw

cd             ( path )
         path = An AmigaDOS directory name (word or list).
   Set the current directory to the specified path, or output the current
   directory.

char           ascii
         ascii = Any number from 1 to 255.
   Output word containing one ASCII character.

clean          ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Blank turtles windows without otherwise affecting the turtles.

cleartext
   Blank the command window and set the cursor position to the upper
   left corner.

close          file ( file... )
         file = BCPL pointer to AmigaDOS file handle.
   Close files.
   See Also:   open, openold

closep
   Output true if window-close queue is not empty.
   See Also:   getclose

closepalette   predicate
         predicate = true or false.
   Close the palette tool. If predicate is true, any color changes are kept
   (same as the close or 'OK' gadgets). If predicate is false, the colors
   are reset (same as the 'CANCEL' gadget). 
   See Also:   openpalette, palettep

closescreen    screen ( screen... )
         screen = Pointer to an intuition screen.
   Close screens.
   See Also:   openscreen

closeturtle    turtle ( turtle... )
               turtle-list
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Close turtles.
   See Also:   openturtle

closewindow    window ( window... )
         window = Pointer to an intuition window.
   Close windows.
   See Also:   openwindow

conditional    conditional-list
cond
         conditional-list = A list: [ predicate-list run-list ... ]
            predicate-list = A run-list that outputs true or false.
            run-list = List of LOGO instructions.
   Execute the run-list following the first true predicate-list.

continue
   Skip to next pass in looping primitives ('repeat', 'while',
   and 'dowhile').

convertstring  string
         string = Pointer to an ARexx argstring, or any NULL terminated
                  text string.
   Output list of contents from a string. Reads a list from a NULL
   terminated text string.
   See Also:   allocstring

copyrect       window X Y window X Y width height ( minterm )
         window = Pointer to an intuition window.
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
         width = Number, width of region in pixels.
         height = Number, height of region in pixels.
         minterm = Number, 0 to 255:
                  192   plain copy (default)
                  80    ignore source invert destination
                  48    invert copy
            See the Amiga Hardware Refrence Manual for more about minterms.
   Copy a rectangular region from window to window.

cos            angle
         angle = Number representing an angle.
   Output cosine of angle.

cosh           number
         number = Any number.
   Output hyperbolic cosine of number.

count          object
         object = Any word or list.
   Output number of items in object.

cursor
   Output position-list of command window text cursor.

dec            name
         name = Word, a variable name that contains a number.
   Decrement variable. Subtract one from the number contained by name.

degrees
   Interpret angles as degrees.
   See Also:   radians

dir            ( path )
         path = An AmigaDOS directory name (word or list).
   Output list of contents of the specified path, or the current directory.

doscommand     command-line
         command-line = List containing an AmigaDOS command line.
   Run list as AmigaDOS command (as if typed at the CLI).

dot            ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Mark one pixel at turtles position.

dowhile        run-list predicate-list
         run-list = List of LOGO instructions.
         predicate-list = A run-list that outputs true or false.
   Execute run-list while predicate-list is true.
   See Also:   break, continue

downp          turtle
         turtle = Pointer to a turtle.
   Output true if turtles pen is down.

draw           window X Y
         window = Pointer to an intuition window.
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Draw from a windows graphics cursor position to position X Y.

emptyp         object
         object = Any word or list.
   Output true if object is the empty list or the empty word.

eqp            object object ( object... )
         object = Any word or list.
   Output true if all inputs refer to the same object. This is a special
   purpous operation, and is of limited usefulness.
   See Also:   repitem, represt

equalp         object object ( object... )
=
         object = Any word or list.
   Output true if objects are identical.

erase          name ( name... )
               name-list ( name-list... )
         name = Word, a variable name.
         name-list = List of names.
   Remove bindings (contents) of input names that are not buried.
   See Also:   make

error
   Output list containing the error number, procedure name, primitive name,
   and the offending input from the most recent error.

exor           predicate predicate
         predicate = true or false.
   Output true if one input is true and one is false.

filelist
   Output list of pointers to all open files.

filerequest    ( title )
         title = Word, title bar text.
   Output file path name selected from file requester (or empty word if
   `cancel' is selected). This uses the PathMaster file selector
   by Justin V. McCormick.

findport       port-name
         port-name = Word or list, name of public message port.
   Output pointer to the message port if it exists. Output null pointer
   (@0) if the port does not exist.

first          object
         object = Any word or list.
   Output first item of object.

firstput       object object
fput
         object = Any word or list.
   Output object made by adding first input to beginning of second input.

floodol        window X Y
         window = Pointer to an intuition window.
         Y = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Flood fill to outline. Recolor in all directions from X, Y to a border
   in the outline pen.

floodpc        window X Y
         window = Pointer to an intuition window.
         Y = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Flood fill pixel color. Recolor in all directions from X, Y all
   adjacent pixels the same color as X, Y.

forward        distance ( turtle ... )
fd             distance ( turtle-list )
         distance = Number, distance in turtle steps.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Move turtles forward distance.

fprint         file object ( object... )
         file = BCPL pointer to AmigaDOS file handle.
         object = Any word or list.
   Print object to file, followed by a linefeed. If object is a list
   outermost brakets will be removed.
   See Also:   freadlist

fprintout      file name ( name... )
               file name-list ( name-list... )
         file = BCPL pointer to AmigaDOS file handle.
         name = Word, a variable name.
         name-list = List of names.
   Print names and their bindings file. Prints a 'make' command that may
   then be 'load'ed.
   See Also:   load, make

frac           number
         number = Any number.
   Output fractional portion of number.

freadbyte      file
         file = BCPL pointer to AmigaDOS file handle.
   Output one byte number read from file, Output the empty list if end
   of file.
   See Also:   fwritebyte

freadlist      file
         file = BCPL pointer to AmigaDOS file handle.
   Output list read from file (or the empty word if end of file).
   See Also:   fprint

freemem        pointer ( predicate )
         pointer = Pointer to allocated memory.
         predicate = true or false.
   Deallocate memory allocated by 'allocchip', 'allocmem', or
   'allocstring'. If 'predicate' is 'true' (or absent) memory will only be
   deallocated if it is found in the user memory list. If 'predicate' is
   'false' memory will be deallocated even if not found in the user memory
   list. This may be used to deallocate an ARexx argstring result.
   See Also:   allocchip, allocmem, allocstring

fshow          file object ( object... )
         file = BCPL pointer to AmigaDOS file handle.
         object = Any word or list.
   Print object to file, followed by a linefeed.

ftype          file object ( object... )
         file = BCPL pointer to AmigaDOS file handle.
         object = Any word or list.
   Print object to file, not followed by a linefeed.

fwritebyte     file number ( number... )
         file = BCPL pointer to AmigaDOS file handle.
         number = Any number from 0 to 255.
   Write one byte numbers to file.
   See Also:   freadbyte

getclose
   Output a pointer to a window from the window close event queue, wait if
   the event queue is empty.
   See Also:   closep, whenclose

getmenu
   Output list containing a pointer to the window, the menu number, item
   number, and subitem number of the next item from the menu event queue,
   wait if the menu event queue is empty.
   See Also:   menup, whenmenu

getmessage
   Output pointer to next message at the host port, wait if its empty.
   See Also:   messagep, whenmessage, replymessage

getmouse
   Output list containing a pointer to the window, the X position, and Y
   position where the mouse was when the button was pressed, wait if the
   mouse event queue is empty.
   See Also:   mousep, whenmouse

getprop        name property
gprop
         name = Word, name of a variable containing a property list.
         property = Word, label of an object in a property list.
   Output specified object from a property list.  If `name' does not
   exist, the empty list is returned.  If `property' does not exist for
   that `name', the empty list is returned.
   See Also:   putprop, remprop

getreply
   Output pointer to next message at the reply port, wait if its empty.
   See Also:   replyp, whenreply

heading        turtle
         turtle = Pointer to a turtle.
   Output a turtles heading.

home           ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Move turtles to position (0,0) set heading to 0.

hostport       ( port-name )
         port-name = Word or list, name for host message port.
   Without an input, outputs the name of the host port.
   With an input, changes the name of the host port.

if             predicate run-list run-list
         predicate = true or false.
         run-list = List of LOGO instructions.
   If predicate is true execute first run-list, if false execute second
   run-list. Both run-lists are required, if one case is not used, use the 
   empty list [ ].

inc            name
         name = Word, a variable name that contains a number.
   Increment variable. Add one to the number contained by name.

int            number
         number = Any number.
   Output integer portion of number.

intuition      action pointer ( ?... )
         action = A number from 1 to 11, specifying action to be taken.
         pointer = A pointer to an intuition screen or window.
         ? = Listed below.
   Fourteen primitives in one, to modify screens, windows, and menus.

               1 screen X Y
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Move screen (screen = @0 for workbench screen).

               2 window X Y
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Move window (window = @0 for command window).

               3 window menu item subitem
         menu, item, subitem = Numbers specifying a menu or item.
   Off menu (window = @0 for command window).

               4 window menu item subitem
         menu, item, subitem = Numbers specifying a menu or item.
   On menu (window = @0 for command window).

               5 screen
   Screen to back (screen = @0 for workbench screen).

               6 screen
   Screen to front (screen = @0 for workbench screen).

               7 screen showit
         showit = Number.
   Show screen title (number <> 0) hide title (number = 0).

               8 window width height
         width = Number, width of window in pixels.
         height = Number, height of window in pixels.
   Size window (window = @0 for command window).

               9 window MinWidth MinHeight MaxWidth MaxHeight
         MinWidth   \
         MinHeight   \
         MaxWidth    /  = Numbers, sizes in pixels.
         MaxHeight  /
   Set window limits (window = @0 for command window).

               10 window
   Window to back (window = @0 for command window).

               11 window
   Window to front (window = @0 for command window).

               12 window
   Make window, the active window.

               13 window menu item subitem
         menu, item, subitem = Numbers specifying a menu or item.
   Set menu checkmark.

               14 window menu item subitem
         menu, item, subitem = Numbers specifying a menu or item.
   Clear menu checkmark.

item           element object
         element = Number, index to item. 
         object = Any word or list.
   Output specified item from object.

items          first count object
         first = Number, index to first item.
         count = Number of items.
         object = Any word or list.
   Output specified items from object.

keyp
   Output true if character queue is not empty.
   See Also:   readchar, whenchar

last           object
         object = Any word or list.
   Output last item from object.

lastput        object object
lput
         object = Any word or list.
   Output object made by adding first input to end of second input.

launch         run-list
         run-list = List of LOGO instructions.
   Add run-list to a queue to be executed once prior to returning to top
   level.

left           angle ( turtle ... )
lt             angle ( turtle-list )
         angle = Number representing an angle.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Rotate turtle left.

linep
   Output true if command window input line queue is not empty.
   See Also:   readlist

listp          object
         object = Any word or list.
   Output true if object is a list.

list           object object ( object... )
         object = Any word or list.
   Output list containing input objects.

load           file-name ( file-name... )
         file-name = An AmigaDOS file name (word or list).
   Load file, runs a text file as if it were typed at the keyboard.
   See Also:   fprintout, save

loadimage      window file-name
         window = Pointer to an intuition window.
         file-name = An AmigaDOS file name (word or list).
   Load a window from an IFF ILBM file. Requires 'ilbm.library' from
   Dissidents Software. BUG: sometimes loads entire screen.

log            base number
         base = Positive number.
         number = Positive number.
   Output logarithm of the number to the base.

make           name object
         name = Word, a variable name.
         object = Any word or list.
   Make object the contents of name (bind object to name). Make is the LOGO
   variable assignment operator. 
   See Also:   erase, bury

memberp        object object
         object = Any word or list.
   Output true if the second object contains the first object. If both
   objects are words, only the first character of the first object is
   considered.

menup
   Output true if menu queue is not empty.
   See Also:   getmenu, whenmenu

messagep
   Output true if the host port is not empty. 
   See Also:   getmessage, whenmessage

mousep
   Output true if mouse-button queue is not empty.
   See Also:   getmouse, whenmouse

mouse          window
         window = Pointer to an intuition window.
   Output list containing the X position, Y position and button position of
   the mouse relative to the window.

move           window X Y
         window = Pointer to an intuition window.
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Move a windows graphics cursor to position X Y.

movecommand    screen ( le te w h )
         screen = Pointer to an intuition screen, @0 for workbench screen.
         le = Number, left edge. \
         te = Number, top edge.   \ _ Dimensions for command window.
         w  = Number, width.      /
         h  = Number, height.    /
   Move the LOGO command window to another screen.

namelist
   Output list of variable names in use.

namep          object
         object = Any word or list.
   Outputs true if `object' is a word that is the name of an unburied
   variable. Outputs false if it is a list, buried name, procedure
   name, or non-existant name.

ncequalp       object object (object)
         object = Any word or list.
   Non case sensitive version of 'equalp'.

ncmemberp      object object
         object = Any word or list.
   Non case sensitive version of 'memberp'.

ncwhich        object object
         object = Any word or list.
   Non case sensitive version of 'which'.

new
   Remove bindings of all names (erase), close all files, close all
   turtles, close all windows, close all screens, clear all menus, clear
   all demons, flush all input queues (eccept message ports), return
   to top level.  

not            predicate
         predicate = true or false.
   Output true if input is false output false if input is true.

numberp        object
         object = Any word or list.
   Output true if object is a number.

open           file-name
         file-name = An AmigaDOS file name (word or list).
   Create or open file to be written, output BCPL pointer to an AmigaDOS
   file handle.
   See Also:   close, openold

openold        file-name
         file-name = An AmigaDOS file name (word or list).
   Open existing file to be read or written, output BCPL pointer to an
   AmigaDOS file handle.
   See Also:   close, open

openpalette    predicate screen ( le te )
         predicate = true or false.
         screen = Pointer to an intuition screen, @0 for workbench screen.
         le = Number, left edge.
         te = Number, top edge.
   Open the palette tool, output window pointer. If palette was allready
   open, it will first be closed based on predicate. Note that the palette
   is a window and can have menus.
   See Also:   closepalette, palettep

openscreen     vm ( d t le te w h dp bp )
               screen-data-list
         vm = Number, viewport modes, sum of: 
                  1     hires
                  2     lace
                  4     extra half brite
         d = Number of bit planes.
         t = List, title bar text.
         le = Number, left edge.
         te = Number, top edge.
         w = Number, width.
         h = Number, height.
         dp = Number, detail pen.
         bp = Number, block pen.
         screen-data-list = List containing some or all of the above.
            Default screen-data-list = [ 0 2 [ ] 0 0 320 200 0 1 ]
               if view modes = hires then default width = 640
               if view modes = lace then default height = 400
               if view modes = extra half brite then default depth = 6
   Open an intuition graphics screen, output pointer to the screen.
   See Also:   closescreen

openturtle     window ( mag ar X Y h t )
               turtle-data-list
         window = Pointer to an intuition window.
         mag = Number, scale or magnification.
         ar = Number, aspect ratio, pixel width / height.
         X = Number, pixel x coordinate of home.
         Y = Number, pixel y coordinate of home.
         h = Number, heading of home.
         t = Number, turning direction, >= 0 clockwise,
             < 0 counterclockwise (right and left are reversed).
         turtle-data-list = List containing some or all of the above.
            Defaults:
               mag   lores    1.8
                     hires    3.2
                     This means it takes 200 steps to go from the
                     left edge to the right edge of a full screen.
               ar    lores          0.88
                     hires          0.44
                     lores lace     1.76
                     hires lace     0.88
                     This makes circles look round and squares look
                     square.
               X, Y  The current center of the window.
               h     0  Straight up.
               t     0  Clockwise.
   Open a turtle, output pointer to the turtle.
   See Also:   closeturtle

openwindow     screen ( f t le te w h dp bp minw minh maxw maxh )
               window-data-list
         screen = Pointer to an intuition screen, @0 for workbench screen.
         f = Number, flags, sum of:
                  1     drag gadget
                  2     depth gadget
                  4     close gadget
                  8     size gadget
                  16    give me zero zero
                  32    backdrop
                  64    borderless
                  128   activate
         t = List, title bar text.
         le = Number, left edge.
         te = Number, top edge.
         w = Number, width.
         h = Number, height.
         dp = Number, detail Pen.
         bp = Number, block Pen.
         minw = Number, minimum width.
         minh = Number, minimum height.
         maxw = Number, maximum width.
         maxh = Number, maximum height.
         window-data-list = List containing some or all of the above.
            Default window-data-list WorkBench screen:
                  [ @0 3 [ ] 0 0 320 200 0 1 30 30 640 400 ]
            Default window for custom screen:
                  Backdrop borderless window to fit the screen.
   Open an intuition graphics window, output pointer to the window.
   See Also:   closewindow

or             predicate predicate ( predicate... )
         predicate = true or false.
   Output true if any inputs are true.

output         object
op
         object = Any word or list.
   Exit procedure, return object as the procedures output.

palettep       ( window )
         window = Pointer to an intuition window (the palette tool ?).
   Test to see if window is the palette tool (is palette open ?), or wait
   for it to be closed, and or output how it was closed.
   See Also:   openpalette, closepalette

pd             ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Pen down, lower the turtles pen.

peek           bytes address ( offset )
         bytes = Number, one of:
                  0     32 bit pointer
                  1     8 bit unsigned integer
                 -1     8 bit signed integer
                  2     16 bit unsigned integer
                 -2     16 bit signed integer
                  4     32 bit unsigned integer
                 -4     32 bit signed integer
                  8     64 bit IEEE double floating point number
         address = Number, or pointer, a memory address.
         offset = Number, offset in data items.
   Output number contained at memory address
   (address + (offset * (data size in bytes))).
   See Also:   poke, psum

pen            window ( type )
         window = Pointer to an intuition window (@0 for command window).
         type = Number, which pen:
                  0     foreground pen (default)
                  1     background pen
                  2     area outline pen
   Output the windows pen number.

poerror
   Print out error message.

pointerp       object
         object = Any word or list.
   Output true if object is a pointer.

poke           bytes address number ( offset )
         bytes = Number of bytes:
                  1     8 bit integer
                  2     16 bit integer
                  4     32 bit integer or pointer
                  8     64 bit IEEE double floating point number
         address = Number, or pointer, a memory address.
         number = Number, or pointer, limited in size by number of bytes.
         offset = Number, offset in data items.
   Deposit number at memory address
   (address + (offset * (data size in bytes))).
   Compatibility note as of release 1.3 'poke' no longer allows multiple
   numbers.
   See Also:   peek, psum

power          base exponent
         base = Any number.
         exponent = Number, if base < 0 then exponent must be an integer.
   Output base to the power of exponent.

precision      ( digits )
         digits = Number from 0 to 15.
   Sets or outputs precision used by print, fprint, type, ftype, and text
   when printing numbers.

primitivep     object
         object = Any word or list.
   Output true if object is a primitive.

print          object ( object... )
pr
         object = Any word or list.
   Print object to command window, followed by a carriage return, with
   outer brackets removed.

printout       name ( name... )
po             name-list ( name-list... )
         name = Word, a variable name.
         name-list = List of names.
   Print names and their bindings (i.e., the entire `make' command) to
   the command window.

procedurep     object
         object = Any word or list.
   Output true if object is a user defined procedure.

psum           address number ( number... )
         address = Number, or pointer, a memory address.
         number = Any number.
   Output pointer equal to sum of address and numbers.
   See Also:   peek, poke

pu             ( turtle... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Pen up, raise the turtles pen.

putprop        name property object
pprop
         name = Word, name of a variable containing a property list.
         property = Word, label of an object in a property list.
         object = Any word or list.
   Place object into a property list.
   See Also:   getprop, remprop

quit
   Exit LOGO, return to WorkBench or CLI. LOGO cleans up after itself by
   closing all screens, windows, turtles, and files, and freeeing allocated
   memory in the user memory list.

radians
   Interpret angles as radians.
   See Also:   degrees

rand
   Output random fraction from zero to less than one.

random         range
         range = Number, positive integer.
   Output random integer from zero to less than number.

readchar
rc
   Output one character word typed at keyboard. Reads characters from
   windows other than the command window. Waits if character event queue
   is empty.
   See Also:   keyp, whenchar

readlist
rl
   Output line typed at keyboard as a list. Reads lines from the command
   window. Waits if line queue is empty.
   See Also:   listp

readpixel      window X Y
         window = Pointer to an intuition window.
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Output pen number of pixel at position (X,Y).

rectfill       window l t r b
         window = Pointer to an intuition window.
         l = Number, left edge of rectangle in pixels.
         t = Number, top edge of rectangle in pixels.
         r = Number, right edge of rectangle in pixels.
         b = Number, bottom edge of rectangle in pixels.
   Fill rectangle from (l,t) to (r,b).

recycle        ( number )
         number = Any number.
   Without an input, recycles memory and frees what is normaly held in
   reserve. With an input, just recycles memory.

remainder      number number
         number = Any number.
   Output remainder after division.

remprop        name property
         name = Word, name of a variable containing a property list.
         property = Word, label of an object in a property list.
   Remove object from a property list.
   See Also:   getprop, putprop

repeat         number run-list
         number = Number, positive integer.
         run-list = List of LOGO instructions.
   Execute run-list number of times.
   See Also:   break, continue

repitem        item list object
         item = Number, index into list.
         list = Any list.
         object = Any word or list.
   Replace specified item of list with object. This special purpous command
   should NOT be used by any but the most experienced programmers. 
   WARNING: repitem destructively changes an existing list and you may
   obtain unexpected results if there is more than one reference to the
   list. This is similar to 'rplaca' in Lisp.
   See Also:   eqp, represt


replymessage   message
         message = Pointer to an Exec message.
   Return a message received at the host port.
   See Also:   getmessage

replyp
   Output true if the reply port is not empty. 
   See Also:   getreply, whenreply, sendmessage

represt        item list object
         item = Number, index into list.
         list = Any list.
         object = Any word or list.
   Replace rest of list after specified item with object. This special
   purpous command should NOT be used by any but the most experienced
   programmers.  WARNING: represt destructively changes an existing list
   and you may obtain unexpected results if there is more than one
   reference to the list. This is similar to 'rplacd' in Lisp.
   See Also:   eqp, repitem

restof         item object
         item = Number, index into object.
         object = Any word or list.
   Output rest of object following specified item.

rgb            screen index
         screen = Pointer to an intuition screen (@0 for workbench screen).
         index = Number, index into the screens color table.
   Output list containing red, green, and blue value of the screens
   specified color.

right          angle ( turtle ... )
rt             angle ( turtle-list )
         angle = Number representing an angle.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Rotate turtle right.

round          number
         number = Any number.
   Output number rounded to nearest integer.

run            run-list
         run-list = List of LOGO instructions.
   Execute run-list.

save           file-name name ( name... )
               file-name name-list ( name-list... )
         file-name = An AmigaDOS file name (word or list).
         name = Word, a variable name.
         name-list = List of names.
   Save variable names and their contents to file with a project icon.
   See Also:   load

saveicon       file-name ( default-tool tool-types )
         file-name = An AmigaDOS file name ('.info' will be added).
         default-tool = Word.
         tool-types = List of up to three words.
   Attach icon to file.

saveimage      window file-name
         window = Pointer to an intuition window.
         file-name = An AmigaDOS file name (word or list).
   Save a window to an IFF ILBM file. Requires 'ilbm.library' from
   Dissidents Software. BUG: sometimes saves entire screen.

screenlist
   Output list of pointers to all open screens.

seconds
   Output system clock time in seconds.

seedrand       ( number )
         number = Any number.
   Re-seed random number generator.

seekend        file
         file = BCPL pointer to AmigaDOS file handle.
   Move to end of file.

seekstart      file
         file = BCPL pointer to AmigaDOS file handle.
   Move to start of file.

sendmessage    port-name message ( predicate )
         port-name = Word or list, name of public message port.
         message = Pointer to an Exec message.
         predicate = true or false.
   Send a message to the specified message port. 'predicate' indicates
   whether or not you want a reply.
   See Also:   getreply, replyp

sentence       object object ( object... )
se
         object = Any word or list.
   Output list of input objects. Lists in the input to sentence will have
   their outer brackets removed. 'sentence' always creates a new list.

setafpt        window pattern-list
         window = Pointer to an intuition window.
         pattern-list = A list of up to 16 words, each 16 characters long
                        where 'x' is an on pixel, any other character is an
                        off pixel.
   Set area fill pattern.

setcursor      position
         position = List of two numbers, X, and Y coordinates.
   Set command window text cursor position.

setdrmode      window mode
         window = Pointer to an intuition window (@0 for command window).
         mode = Number, sum of:
                  0     JAM1
                  1     JAM2
                  2     COMPLEMENT
                  4     INVERSVID
   Set a windows draw mode.

setfont        window font-name font-height
         window = Pointer to an intuition window (@0 for command window).
         font-name = Word.
         font-height = Number.
   Set a windows text font.

seth           angle ( turtle ... )
               angle ( turtle-list )
         angle = Number representing an angle.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Set turtles heading.

setlinept      window pattern
         window = Pointer to an intuition window.
         pattern = Word 16 characters long where 'x' is an on pixel, any
                   other character is an off pixel.
   Set a windows line pattern.

setmenu        window menu-list ( front-pen back-pen )
         window = Pointer to an intuition window (@0 for command window).
         menu-list = List of menu text:
                           [ menu-name-1 [ item-1-1 K ]
                                         [ item-1-2 [ subitem-1-2-1 K ]
                                                    [ subitem-1-2-2 K ] ]
                             menu-name-2 [ item-2-1 ]
                                         [ item-2-2 ] ]
                     (where 'K' is a keyboard short cut)
         front-pen = Number, pen for menu text.
         back-pen = Number, pen for menu background.
   Attach a menu strip to the window.

setpen         window pen ( type )
         window = Pointer to an intuition window (@0 for command window).
         pen = Number of pen.
         type = Number, which pen:
                  0     foreground pen (default)
                  1     background pen
                  2     area outline pen
   Set a windows pen number.

setrgb         screen index rgb-list
         screen = Pointer to an intuition screen (@0 for workbench screen).
         index = Number, index into color registers table.
         rgb-list = List of three numbers, containing red, green, and blue
                    value of the color.
   Set a screens color register.

setstyle       window style
         window = Pointer to an intuition window (@0 for command window).
         style = Number, sum of:
                  0     plain
                  1     underlined
                  2     bold
                  4     italic
   Set the text rendering style.

settdm         mode ( turtle ... )
               mode ( turtle-list )
         mode = Number, sum of:
                  0     JAM1
                  1     JAM2
                  2     COMPLEMENT
                  4     INVERSVID
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Set turtles draw mode.

settlp         pattern ( turtle ... )
               pattern ( turtle-list )
         pattern = Word 16 characters long where 'x' is an on pixel, any other
                   character is an off pixel.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Set turtle line pattern.

settpn         pen type ( turtle ... )
               pen type ( turtle-list )
         pen = Number of pen.
         type = Number, which pen:
                  0     foreground pen
                  1     background pen
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Set turtles pen number.

settpos        position ( turtle ... )
               position ( turtle-list )
         position = List of two numbers, X, and Y coordinates.
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Set turtles position.

show           object ( object... )
         object = Any word or list.
   Print object to command window, followed by a carriage return, with
   outer brackets intact.

sin            angle
         angle = Number representing an angle.
   Output sine of angle.

sinh           number
         number = Any number.
   Output hyperbolic sine of number.

sleep
   Wait for an input event (mouse, menu, keyboard, window close, host port,
   or reply port).

sound          sound-list sound-list sound-list sound-list
         sound-list = list containing:
            sound data, pointer to an array of bytes (in chip ram).
            length, number of bytes of sound data.
            period, number, (microseconds per sample)/0.279.
            volume, number, loudness 0-64.
            cycles, number of times to repeat the sound.
   Play sounds and music on all four of the Amiga audio channels. Sound
   data must be prepared prior to use.

sqrt           number
         number = Positive number.
   Output square root of number.

stick
   Output list containing the X position, Y position and button position of
   a joystick in port number two.

stop
   Exit procedure.

system         action ( ? )
         action = A number from 1 to 14, specifying action to be taken.
         ? = Listed below.
   Fourteen primitives in one, to control memory, libraries, and demons. 

               1
   Output the amount of memory LOGO tries to hold in reserve.

               2 bytes
         bytes = Number of bytes.
   Set the amount of memory LOGO tries to hold in reserve.

               3 bytes
         bytes = Number of bytes.
   Allocate memory, this has been replaced by 'allocmem'.
   See Also:   allocmem

               4 bytes
         bytes = Number of bytes.
   Allocate chip memory, this has been replaced by 'allocchip'.
   See Also:   allocchip

               5 pointer
         pointer = Pointer to allocated memory.
   Free memory, this has been replaced by 'freemem'.
   See Also:   allocchip, allocmem, allocstring, freemem

               6
   Output list of pointers to allocated memory blocks.
   See Also:   allocchip, allocmem, allocstring, freemem

               7
   Open Diskfont library.

               8
   Close Diskfont library.

               9
   Open ILBM library.

               10
   Close ILBM library.

               11
   Enable demons.

               12
   Disable demons.

               13
   Open Icon library.

               14
   Close Icon library.

               15
   Output a real pointer to the command window.

               16
   Output a real pointer to the workbench screen.

               17
   Output launch list.

               18
   Output char demon list.

               19
   Output close demon list.

               20
   Output menu demon list.

               21
   Output mouse demon list.

               22
   Output host port demon list.

               23
   Output reply port demon list.

               24 primitive
         primitive = Word, the name of a primitive.
   Userp the name of 'primitive' for some other purpose. This removes the
   primitive from LOGO.

               25 primitive synonym
         primitive = Word, the name of a primitive.
   Install 'synonym' as another name for 'primitive'.

tan            angle
         angle = Number representing an angle.
   Output tangent of angle.

tanh           number
         number = Any number.
   Output hyperbolic tangent of number.

tell           turtle ( turtle... )
               turtle-list
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Make these the active turtles, deactivate any other turtles.

text           window object
         window = Pointer to an intuition window.
         object = Any word or list.
   Print text to a custom window.

thing          name
         name = Word, a variable name.
   Output object bound to name (contents of variable).

throw          label
         label = Any word.
   Escape to catch with matching label.

toplevel
   Stop all LOGO processing and return to the top level prompt.

toward         position turtle
         position = List of two numbers, X, and Y coordinates.
         turtle = Pointer to a turtle.
   Output heading to point turtle toward position.

tpen           turtle ( type )
         turtle = Pointer to a turtle.
         type = Number, which pen:
                  0     foreground pen (default)
                  1     background pen
   Output the turtles pen number.

tpos           turtle
         turtle = Pointer to a turtle.
   Output a list containing the turtles position.

turtlelist
   Output list of pointers to all open turtles.

turtleoff      ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Deactivate turtles.

turtleon       ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Activate turtles.

twpos          turtle
         turtle = Pointer to a turtle.
   Output Turtles position in window coordinates.

type           object ( object... )
         object = Any word or list.
   Print the object (followed by a space) to the command window with
   outer brackets removed, and not followed by a carriage return.

unbury         name ( name... )
               name-list ( name-list... )
         name = Word, a variable name.
         name-list = List of names.
   Make variable names accessible.
   See Also:   bury

wait           seconds
         seconds = Positive number.
   Pause for a number of seconds.

whenchar       run-list
         run-list = List of LOGO instructions.
   Set demon to run when key stroke is detected. Run-list must execute a
   'readchar' to clear the character queue.
   See Also:   keyp, readchar

whenclose      run-list
         run-list = List of LOGO instructions.
   Set demon to run when window-close is detected. Run-list must execute a
   'getclose' to clear the window-close queue.
   See Also:   closep, getclose

whenmenu       run-list
         run-list = List of LOGO instructions.
   Set demon to run when menu item is selected. Run-list must execute a
   'getmenu' to clear the menu-selection queue.
   See Also:   getmemu, menup

whenmessage    run-list
         run-list = List of LOGO instructions.
   Set demon to run when the host port is not empty. Run-list must
   execute a 'getmessage' to clear the host message port.
   See Also:   getmessage, messagep, replymessage

whenmouse      run-list
         run-list = List of LOGO instructions.
   Set demon to run when mouse-button is pressed. Run-list must execute a
   'getmouse' to clear the mouse-button queue.
   See Also:   getmouse, mousep

whenreply      run-list
         run-list = List of LOGO instructions.
   Set demon to run when the reply port is not empty. Run-list must
   execute a 'getreply' to clear the reply port.
   See Also:   getreply, replyp, sendmessage

which          object object
         object = Any word or list.
   If the second object contains the first object output item number. If
   the second object does not contain the first object output zero.

while          predicate-list run-list
         predicate-list = A run-list that outputs true or false.
         run-list = List of LOGO instructions.
   While predicate-list is true, repeat run-list.
   See Also:   break, continue

window         ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Allow turtle to move beyond edges of window.

windowlist
   Output list of pointers to all open windows.

word           word word ( word... )
         word = Any word.
   Output word made by concatenating the input words.

wordp          object
         object = Any word or list.
   Output true if object is a word.

wrap           ( turtle ... )
               ( turtle-list )
         turtle = Pointer to a turtle.
         turtle-list = List of turtle pointers.
   Make turtle wrap around at edges of window.

writepixel     window X Y
         window = Pointer to an intuition window.
         X = Number, pixel x coordinate.
         Y = Number, pixel y coordinate.
   Set pixel (X,Y) to the pen color.

wtpos          turtle
         turtle = Pointer to a turtle.
   Output windows position in turtle coordinates.

[1mAppendix A  Errors[0m

Errors in syntax, or anything the interpreter does not recognize as valid
LOGO instructions, should produce meaningful error messages.

Primitives that expect a pointer as input may cause LOGO to crash (guru) if
passed a bad pointer.

The primitives 'repitem', and 'represt' destructively change an existing
list and must be used carefully. If there is more than one reference to the
list all references will be changed. They can also result in circular lists
which appear infinite, and may cause LOGO to get stuck in a loop.

[1mAppendix B  Limits[0m

 * Lines typed at the command window are limited to 250 characters.

 * Lines in files being loaded are limited to 1000 characters.

 * Words may be no longer than 500 characters.

 * Primitives are limited to a maximum of 200 inputs.

 * Internally lists may be nested to any depth. But stack size will limit
   list depth for input and output. This is rare but if LOGO crashes while
   entering, printing, saving, loading, writing, or reading, a deeply
   nested list, try increasing the stack size.

[1mAppendix C  Compatibility[0m

Though there is no official standard for LOGO, two dialects form the de
facto standard: Those from LOGO Computer Systems Inc. (LCSI) (Apple LOGO
II, Atari LOGO, Sprite LOGO), and what is called MIT LOGO (Krell, PC,
Terrapin, Amiga). These are both good, and similar enough to both be called
standard.

With the following important exceptions Power LOGO follows the LCSI
standard:

Power LOGO is case sensitive. All primitives and keywords are lower case,
all names and data defined may be any case.

Spaces are sacred. All LOGO objects (words, lists, list brackets, and
parenthesis) must be separated by a space, or a linefeed. Other dialects
may accept lists like this:

   make "x [abc[12 3 45]ef g]

In Power LOGO it would be:

   make "x [ abc [ 12 3 45 ] ef g ]

Power LOGO uses prefix (polish) notation only. There are no infix
operations, no implied spaces, no special delimiters, and no exceptions.
Other dialects may accept arithmetic in this form:

   pr 5+2*7

In Power LOGO:

   pr + 5 * 2 7

Power LOGO has no 'TO' or 'END' primitive. User defined procedures are just
variables that contain a special type of list, and are defined using the
'make' primitive. Here is a simple procedure that will work in most
traditional dialects of LOGO:

1  TO HELLO
2  PR [ HELLO WORLD ]
3  END

And a line by line translation into PowerLOGO:

1  make "hello [ procedure [ ]
2  pr [ Hello World ]
3  ]

The word 'procedure' identifies this list as a procedure definition. Inputs
and local variables are declared in a list following the word 'procedure'
(the empty list indicates that this procedure has no inputs and no local
variables). The names list is followed by the instructions that make up the
procedure.

The first item of the variable names list is a list of names of required
inputs. The second item is a list of names of optional inputs. The third
item is a list of names of local variables.

   TO COUNTUP :FROM :TO
   LOCAL :X
   MAKE "X 0
   REPEAT :TO - :FROM [ PR :FROM + :X MAKE "X :X + 1 ]
   END

In Power LOGO:

   make "countup [ procedure [ [ :from :to ] [ ] [ :x ] ]  
   make "x 0
   repeat - :to :from [ pr + :from :x make "x + :x 1 ] ]

For most procedures the first line and the variable declarations will look
very different. but the instructions that make up the body of the procedure
will need little change.

Other differences relate to the name, spelling, inputs, and behavior of
individual primitives:

In many dialects the 'if' primitive may have either two, or three inputs,
the third input is the else action:

   if equalp :a :b [ pr true ]
   if equalp :a :b [ pr true ] [ pr false ]

In Power LOGO the 'if' primitive always has three inputs. If the third
input is not needed, use the empty list:

   if equalp :a :b [ pr true ] [ ]
   if equalp :a :b [ pr true ] [ pr false ]

Turtle graphics commands should be compatible with most other dialects, but
a window and a turtle must have been opened first (the startup, and turtles
files will do this for you).

Because of multiple turtles, operations that output data about a turtle
must have a turtle-pointer as input. If you are using the provided turtle
package, this will output the heading of the turtle:

   heading :tg-turtle

Power LOGO has special primitives for reading and writing data files (open,
close, fprint, freadlist, ect.).

[1mAppendix D  Recommended Reading[0m

This document file describes the differences between Power LOGO and
traditional versions of LOGO, these books will provide more background
about LOGO. Two of these books, Computer Science Logo Style volume 1, and
Visual Modeling with LOGO, include sections that may be helpful to
beginners.

Computer Science Logo Style
   Volume 1:   Intermediate Programming, 1985.
   Volume 2:   Projects, Styles, and Techniques, 1986.
   Volume 3:   Advanced Topics, 1987.
   Brian Harvey
   MIT Press.
      These are excellent books for anyone interested in programming, and
   computer science.

Mindstorms:   Children, Computers, and Powerful Ideas.
   Seymour Papert
   Basic Books, 1980
      This book is about education and how computers and programming may be
   used by children, parents, and teachers. Required reading for parents,
   and teachers interested in how children can make use of computers.

Turtle Geometry:   The Computer as a Medium for Exploring Mathematics.
   Harold Abelson, and Andrea diSessa
   MIT Press 1981
      About turtles as a tool for the study of mathematics, geometry, and
   topology.

Visual Modeling with LOGO:   A Structural Approach to Seeing.
   James Clayson
   MIT Press, 1988
      About using LOGO and turtle graphics for exploring visual ideas and 
   relationships.
