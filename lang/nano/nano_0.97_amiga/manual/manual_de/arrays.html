<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>Nano vm - manual arrays</title>
    </head>
	<body bgcolor="white" text="black" link="#1025C3" vlink="red" alink="green">
        <center>
            <table border="0" width="640">
				<tr>
					<td align="center">
						<h1>Felder</h1>
					</td>
				</tr>
				<tr>
                    <td align="left">
Felder werden wie normale Variablen deklariert. Der einzige Unterschied <br>
sind die Dimensionsangaben: <br><br>

    <pre>
	int a[10];
	</pre>

Dieses Feld kann "10" short Zahlen speichern. Um in ein Feld zu schreiben <br>
verwenden wir einen speziellen move Befehl: <br><br>

    <pre>
	move_i_a    L0, a, L1;
	</pre>

Das erste Argument ist der zu schreibende Wert, der zweite ist das Feld und <br>
der dritte ist der Feldindex. <br><br>

Aus einem Feld lesen: <br><br>

    <pre>
	move_a_i    a, L1, L0;
	</pre>

    <pre>
        array.na

     1| int a[10];
     2|
     3| push_i    0, L0;
     4| push_i    9, L1;
     5|
     6| lab init_a;
     7|     move_i_a    L0, a, L0;
     8|     inc_l       L0;
     9|     lseq_l      L0, L1, L2;
    10|     jmp_l       L2, init_a;
    11|
    12| push_i    0, L0;
    13| push_i    1, L2;
    14|
    15| lab print_a;
    16|     move_a_i    a, L0, L3;
    17|     print_l     L3;
    18|     print_n     L2;
    19|     inc_l       L0;
    20|     lseq_l      L0, L1, L4;
    21|     jmp_l       L4, print_a;
    22|
    23| push_i    0, L0;
    24| exit      L0;
    </pre>
    
    <h2>Befehle</h2>
    
    <pre>
    L = long Register, D = double Register
    BV = byte Variable, IV = int Variable, LV = long int Variable
    DV = double Variable
    LI = array index
    </pre>

    <h3>Register zu Feld</h3>
    
    <pre>
    move_i_a        L, IV, LI;
    move_l_a        L, LV, LI;
    move_d_a        D, DV, LI;
    move_b_a        L, BV, LI;
    </pre>
    
    <h3>Feld zu Register</h3>
    
    <pre>
    move_a_i        IV, LI, L;
    move_a_l        LV, LI, L;
    move_a_d        DV, LI, D;
    move_a_b        BV, LI, L;
    </pre>

    <h2>Feld freigeben</h2>

Um den Speicher, den ein Feld belegt freizugeben, kann "dealloc" verwendet werden. <br>
Wenn ein Programm versucht ein freigegebenes Feld zu lesen oder zu schreiben, dann wird <br>
ein "overflow" Fehler ausgegeben. <br><br>

    <pre>
    dealloc         a;      Feld "a" freigeben
    </pre>

Nano gibt alle Variablen am Programmende frei. <br>
Man kann es dazu verwenden um die Feldgrösse zu verändern. <br><br><br>


    <h2>Feldgrösse verändern</h2>

Um die Feldgrösse zu verändern, müssen wir es zuerst freigeben. Danach deklarieren wir es <br>
mit einer neuen Grösse. <br>
Das sieht wie folgt aus: <br><br>

    <pre>
    int size;

    push_i          10, L0;
    pull_i          L0, size;
    
    int a[size];                       Platz für 10 int Variablen

    ...
    
    dealloc         a;                 Feld freigeben

    push_i          20, L0;
    pull_i          L0, size;
    
    int a[size];                       Platz für 20 int Variablen
    </pre>



<a href="jumps.html" target="page">Prev: Sprünge</a> | <a href="strings.html" target="page">Next: Strings</a>
                    </td>
                </tr>
			</table>
		</center>
    </body>
</html>

