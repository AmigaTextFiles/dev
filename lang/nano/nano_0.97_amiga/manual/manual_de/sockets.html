<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Nano vm - manual tcp/ip sockets</title>
    </head>
    <body bgcolor="white" text="black" link="#1025C3" vlink="red" alink="green">
        <center>
            <table border="0" width="640">
                <tr>
                    <td align="center">
                        <h1>TCP/IP Sockets</h1>
                    </td>
                </tr>
                <tr>
                    <td align="left">
<h2>Einführung</h2>

Sockets sind die Standardschnittstelle für TCP/IP. Sie werden verwendet, um Daten <br>
durch das Netzwerk zu senden. Jeder Rechner im Netzwerk hat eine Adresse, vergleichbar <br>
mit einer Telefonnumer. Um Daten zu senden, müssen wir die richtige Adresse und <br>
Portnummer kennen. <br><br>

Die Portnummer indentifiziert den Service. Wenn du durchs Web surfst dann benutzt du <br>
80, http. Der download einer Datei vom FTP Server geht über Port 21, etc. <br><br>

Die Portnummern haben einen Bereich von 0 - 65535. Die Nummern bis 1023 sind Reserviert
für Standarddienste. Deshalb sollten wir nur Nummern von 1024 aufwärts verwenden. <br><br>

<h2>Client/Server</h2>

Es gibt zwei Arten von Sockets: Client und Server. <br>
Jetzt ist es Zeit für ein kleines Beispiel. Nehmen wir mal an, wir haben zwei Rechner <br>
in einem Netzwerk: <br><br>

foo (192.168.1.1), bar (192.168.1.2) <br><br>

Wir möchten, dass foo der Server ist und bar der Client. <br>
Foo wartet an Port 2000 auf eine eingehende Nachricht. Der Client fragt nach einer <br>
Nachricht und sendet sie an den Server. <br><br><br>


<pre>
//  simple server ---------------------------------------------------

    #setreg_l       L0, null;
    #setreg_l       L1, one;
    #setreg_l       L2, port;
    #setreg_l       L3, len;

    string buf[256];

    push_i          0, null;
    push_i          1, one;
    push_i          2000, port;

    ssopen          null, "192.168.1.1", port;
    ssopenact       null;

    sread_l         null, len;
    sread_s         null, buf, len;
    
    print_s         "message: ";
    print_s         buf;
    print_n         one;
    
    sscloseact      null;
    ssclose         null;
    
    exit            null;
    

//  simple client ---------------------------------------------------

    #setreg_l       L0, null;
    #setreg_l       L1, one;
    #setreg_l       L2, port;
    #setreg_l       L3, len;

    string buf[256];

    push_i          0, null;
    push_i          1, one;
    push_i          2000, port;

    print_s         "message? ";
    input_s         buf;
    strlen          buf, len;

    scopen          null, "192.168.1.1", port;
    
    swrite_l        null, len;
    swrite_s        null, buf;

    scclose         null;

    exit            null;
</pre>

<h2>Befehle</h2>

<pre>
    L = long Register, D = double Register, BV = byte Variable, SV = string Variable
</pre>

<h3>open/close</h3>

<pre>
    ssopen          L (Socketnummer), SV (ip), L (Port); Server Socket öffnen
    ssopenact       L (Socketnummer);                    auf Clients warten
    sscloseact      L (Socketnummer);                    Verbindung schliessen
    ssclose         L (Socketnummer);                    Server Socket schliessen

    scopen          L (Socketnummer), SV (ip), L (Port); Client Socket öffnen
    scclose         L (Socketnummer);                    Client Socket schliessen
</pre>

<h3>read/write</h3>

<pre>
    sread_b         L (Socketnummer), L;                 lese byte
    sread_ab        L (Socketnummer), BV, L (Länge)      lese byte array
    sread_i         L (Socketnummer), L;                 lese int
    sread_l         L (Socketnummer), L;                 lese lint
    sread_d         L (Socketnummer), D;                 lese double
    sread_s         L (Socketnummer), SV, L (Länge);     lese string
    sread_ls        L (Socketnummer), SV;                lese line

    swrite_b        L (Socketnummer), L;                 schreibe byte
    swrite_ab       L (Socketnummer), BV, L (Länge)      schreibe byte array
    swrite_i        L (Socketnummer), L;                 schreibe int
    swrite_l        L (Socketnummer), L;                 schreibe lint
    swrite_d        L (Socketnummer), D;                 schreibe double
    swrite_s        L (Socketnummer), S;                 schreibe string

    swrite_sl       L (Socketnummer), L;                 schreibe lint als String
    swrite_sd       L (Socketnummer), D;                 schreibe double als String

    swrite_n        L (Socketnummer), L;                 schreibe "L" neue Zeilen
    swrite_sp       L (Socketnummer), L;                 schreibe "L" Leerzeichen
</pre>

<h3>Sonstige</h3>

<pre>
    hostname        SV (Name);                           gibt den lokalen Hostnamen zurück
    hostbyname      SV (Name), SV (ip);                  gibt die ip zurück
    hostbyaddr      SV (ip), SV (Name);                  gibt den Namen zurück

    clientaddr      L (Socketnummer), SV (ip);           gibt die Client ip, bei
                                                         einem Server Socket, zurück
</pre>

<h3>Fehlercodes</h3>

Die Socket Befehle geben einen Fehlercode in der Variablen "_sock" zurück. <br>
Sehe dir dazu die Beispiele "client.na" und "server.na" für mehr an. <br><br><br>


<h3>line feed (neue Zeile)</h3>

Der line feed kann mit der Variablen "_fnewline" gesetzt werden. <br>
Benutze nur LF oder CRLF bei Sockets. <br><br>


<a href="files.html" target="page">siehe Dateien</a> <br><br><br><br>



<a href="memory_error.html" target="page">Prev: Speicher Fehlercodes</a> | <a href="process.html" target="page">Next: Prozesse</a>
                    </td>
                </tr>
            </table>
        </center>
    </body>
</html>
