<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Nano vm - manual tcp/ip sockets</title>
    </head>
    <body bgcolor="white" text="black" link="#1025C3" vlink="red" alink="green">
        <center>
            <table border="0" width="640">
                <tr>
                    <td align="center">
                        <h1>TCP/IP Sockets</h1>
                    </td>
                </tr>
                <tr>
                    <td align="left">
<h2>Introduction</h2>

Sockets are the standard interface for TCP/IP. They are used to send data <br>
through a network. Every computer on a network has a address like a phone number. <br>
To send data we have to know the right address and port number. <br><br>

The port number is to identify the service. If you browse the web then you use <br>
80, http. Downloading a file from a FTP server goes over port 21, and so on. <br><br>

The port numbers are going from 0 - 65535. The numbers up to 1023 are reserved <br>
for standard services. So we should use numbers from 1024 upwards. <br><br>

<h2>Client/Server</h2>

There are two kinds of sockets: client and server. <br>
Now it's time for a little example. Let's say we have two computers in a network: <br><br>

foo (192.168.1.1), bar (192.168.1.2) <br><br>

We want foo to be the server and bar is the client. <br>
Foo waits on port 2000 for a incoming message. The client asks for a message and <br>
sends it to the server. <br><br><br>


<pre>
//  simple server ---------------------------------------------------

    #setreg_l       L0, null;
    #setreg_l       L1, one;
    #setreg_l       L2, port;
    #setreg_l       L3, len;

    string buf[256];

    push_i          0, null;
    push_i          1, one;
    push_i          2000, port;

    ssopen          null, "192.168.1.1", port;
    ssopenact       null;

    sread_l         null, len;
    sread_s         null, buf, len;
    
    print_s         "message: ";
    print_s         buf;
    print_n         one;
    
    sscloseact      null;
    ssclose         null;
    
    exit            null;
    

//  simple client ---------------------------------------------------

    #setreg_l       L0, null;
    #setreg_l       L1, one;
    #setreg_l       L2, port;
    #setreg_l       L3, len;

    string buf[256];

    push_i          0, null;
    push_i          1, one;
    push_i          2000, port;

    print_s         "message? ";
    input_s         buf;
    strlen          buf, len;

    scopen          null, "192.168.1.1", port;
    
    swrite_l        null, len;
    swrite_s        null, buf;

    scclose         null;

    exit            null;
</pre>

<h2>Opcodes</h2>

<pre>
    L = long register, D = double register, BV = byte variable, SV = string variable
</pre>

<h3>open/close</h3>

<pre>
    ssopen          L (socket number), SV (ip), L (port); opens a server socket
    ssopenact       L (socket number);                    waits for clients
    sscloseact      L (socket number);                    closes connection
    ssclose         L (socket numner);                    closes a server socket

    scopen          L (socket number), SV (ip), L (port); opens a client socket
    scclose         L (socket number);                    closes a client socket
</pre>

<h3>read/write</h3>

<pre>
    sread_b         L (socket number), L;                 read byte
    sread_ab        L (socket number), BV, L (length)     read byte array
    sread_i         L (socket number), L;                 read int
    sread_l         L (socket number), L;                 read lint
    sread_d         L (socket number), D;                 read double
    sread_s         L (socket number), SV, L (length);    read string
    sread_ls        L (socket number), SV;                read line

    swrite_b        L (socket number), L;                 write byte
    swrite_ab       L (socket number), BV, L (length)     write byte array
    swrite_i        L (socket number), L;                 write int
    swrite_l        L (socket number), L;                 write lint
    swrite_d        L (socket number), D;                 write double
    swrite_s        L (socket number), S;                 write string

    swrite_sl       L (socket number), L;                 write lint as string
    swrite_sd       L (socket number), D;                 write double as string

    swrite_n        L (socket number), L;                 write "L" newlines
    swrite_sp       L (socket number), L;                 write "L" spaces
</pre>

<h3>other</h3>

<pre>
    hostname        SV (name);                            returns the local hostname
    hostbyname      SV (name), SV (ip);                   returns the ip
    hostbyaddr      SV (ip), SV (name);                   returns the name

    clientaddr      L (socket number), SV (ip);           returns the client ip
                                                          on a server socket
</pre>

<h3>error codes</h3>

The socket opcodes return a error code to the variable "_sock". <br>
Take a look at the examples "client.na" and "server.na" for more info. <br><br><br>


<h3>line feed</h3>

The line feed can be set with the variable "_fnewline". <br>
Use only LF or CRLF with sockets. <br><br>

<a href="files.html" target="page">See files</a> <br><br><br><br>



<a href="memory_error.html" target="page">Prev: Memory error codes</a> | <a href="process.html" target="page">Next: Processes</a>
                    </td>
                </tr>
            </table>
        </center>
    </body>
</html>
