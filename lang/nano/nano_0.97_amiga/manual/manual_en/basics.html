<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
        <title>Nano vm - manual the basics</title>
    </head>
    <body bgcolor="white" text="black" link="#1025C3" vlink="red" alink="green">
        <center>
            <table border="0" width="640">
                <tr>
                    <td align="center">
                        <h1>The Basics</h1>
                    </td>
                </tr>
                <tr>
                    <td align="left">
The nano virtual machine is register based. The're 32 registers for long int <br>
and 32 registers for double numbers. The math opcodes use the registers. <br>
So a variable or constant has to be pushed into a register before a operation. <br><br>

To do this we need the "push" opcode: <br><br>

    <pre>
    push_i  10, L0;
    </pre>

Pushes the constant "10" into register "L0". <br><br>

To write a register to a variable, we need the "pull" opcode: <br><br>

    <pre>
    pull_i  L0, x;
    </pre>

Pulls register "L0" into the short int variable "x". <br><br>

Lets see this in an example. We want to calculate "77 * 88" and store <br>
the result in variable "x". The line numbers are for reference only, they are <br>
not a part of the program. <br><br>

    <pre>
        calc_1.na

     1| int x;
     2|
     3| push_i  77, L0;
     4| push_i  88, L1;
     5| mul_l   L0, L1, L2;
     6| pull_i  L2, x;
     7|
     8| push_i  0, L4;
     9| exit    L4;
    </pre>

The first line declares the variable "x" as "int". <br><br>

In line 5 we do the multiplication: "L2 = L0 * L1". Note the "L" before <br>
a register means "long int". So we need the "mul_l" opcode there. <br><br>

Line 9 exits the program and sets a return value for the shell environment. <br>
We set "0", so it means no error. <br><br>

<b> Note: NEVER FORGET THE "exit" OPCODE! <br>
THIS IS IMPORTANT! <br>
You also have to take care that the program flow reaches the "exit" opcode! </b> <br><br>

This example has some drawback, we can't see the result. We need to print it <br>
on the screen. Here comes the "print" opcode into play: <br><br>

    <pre>
    print_l	L2;
    </pre>

As you can see, it's simple to use. Only the right register is needed. <br>
But we want to print a "new line" after the result, to get a formatted output: <br><br>

    <pre>
    push_i	1, L3;
    print_n	L3;
    </pre>

The "print_n" opcode prints the number of newlines as set in the register. <br>
Here's the new program: <br><br>

    <pre>
        calc_2.na

     1| int x;
     2|
     3| push_i  77, L0;
     4| push_i  88, L1;
     5| mul_l   L0, L1, L2;
     6| pull_i  L2, x;
     7|
     8| print_l L2;
     9| push_i	1, L3;
    10| print_n L3;
    11|
    12| push_i  0, L4;
    13| exit    L4;
    </pre>
    
    <h2>Opcodes</h2>

    <pre>
    L = long register, D = double register
    BV = byte variable, IV = int variable, LV = long int variable
    DV = double variable, SV = string variable
    V = variable, N = integer variable
    
    {} = optional (arrays)
    </pre>

    <h3>variable declaration</h3>

    <pre>
    byte            BV{[NV]};
    int             IV{[NV]};
    lint            LV{[NV]};
    double          DV{[NV]};
    string          SV[NV];
    </pre>
    
    <h3>variable, constant to register</h3>
    
    <pre>
    push_b          BV, L;
    push_i          IV, L;
    push_l          LV, L;
    push_d          DV, D;
    </pre>
    
    <h3>register to variable</h3>
    
    <pre>
    pull_b          L, BV;
    pull_i          L, IV;
    pull_l          L, LV;
    pull_d          D, DV;
    </pre>
    
    <h3>register to register</h3>
    
    <pre>
    move_l          L1, L2;         L1 to L2
    move_d          D1, D2;         D1 to D2
    </pre>



<a href="console_input.html" target="page">Next: Console Input</a>
                    </td>
                </tr>
            </table>
        </center>
    </body>
</html>

