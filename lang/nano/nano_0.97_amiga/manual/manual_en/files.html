<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
		<title>Nano vm - manual files</title>
    </head>
	<body bgcolor="white" text="black" link="#1025C3" vlink="red" alink="green">
        <center>
            <table border="0" width="640">
				<tr>
					<td align="center">
						<h1>Files</h1>
					</td>
				</tr>
				<tr>
                    <td align="left">
To work with a file, it must be opened first: <br><br>

    <pre>
    fopen    L0, "file", "r";
    </pre>

Register "L0" contains the filenumber, the name is "file", and the mode <br>
is read "r". Other modes are: "a" append and "w" write. <br><br>

Close a file: <br><br>

    <pre>
    fclose    L0;
	</pre>

To read from a file: <br><br>

    <pre>
    fread_s    L0, string;
    </pre>

As you may have guessed "string" is a string variable and "L0" is the filenumber. <br><br><br>


    <h2>Opcodes</h2>

    <pre>
    L = long register, D = double register, BV = byte variable, SV = string variable
    </pre>

    <h3>open/close</h3>

    <pre>
    fopen              L (file number), SV (name), SV (type);  opens a file
	
    types are:         "r"      read
                       "w"      write
                       "a"      append
                       "rw"     read/write
                       "wr"     write/read
                       "ar"     append/read

    fclose             L (file number);                        closes a file
	</pre>
	
	<h3>read/write</h3>
	
	<pre>
    fread_b            L (file number), L;                   read byte
    fread_ab           L (file number), BV, L (length);      read byte array
    fread_i            L (file number), L;                   read int
    fread_l            L (file number), L;                   read lint
    fread_d            L (file number), D;                   read double
    fread_s            L (file number), SV, L (length);      read string
    fread_ls           L (file number), SV;                  read line

    fwrite_b           L (file number), L;                   write byte
    fwrite_ab          L (file number), BV, L (length);      write byte array
    fwrite_i           L (file number), L;                   write int
    fwrite_l           L (file number), L;                   write lint
    fwrite_d           L (file number), D;                   write double
    fwrite_s           L (file number), SV;                  write string

    fwrite_sl          L (file number), L;                   write lint as string
    fwrite_sd          L (file number), D;                   write double as string

    fwrite_n           L (file number), L;                   write "L" newlines
    fwrite_sp          L (file number), L;                   write "L" spaces
	</pre>
	
	<h3>other</h3>

	<pre>
    fsetpos            L (file number), L;                   set stream position
    fgetpos            L (file number), L;                   get stream position

    frewind            L (file number);                      rewind stream
    fsize              L (file number), L;                   get file size in bytes

    fremove            L (file number), SV (name);           remove file
    frename            L (file number), SV (old), SV (new);  rename file
	</pre>

Here is an example: <br><br>

    <pre>
        txtsave.na

     1| string file[256];
     2| string line[256];
     3|
     4| print_s    "file to save text? ";
     5| input_s    file;
     6|
     7| push_i     0, L0;
     8| fopen      L0, file, "w";
     9|
    10| push_i     1, L1;
    11| print_s    "Enter the text. Empty line to exit...";
    12| print_n    L1;
    13|
    14| lab input;
    15|     print_s   ": ";
    16|     input_s   line;
    17|     fwrite_s  L0, line;
    18|     fwrite_n  L0, L1;
    19|     neq_s     line, "", L2;
    20|     jmp_l     L2, input;
    21|
    22| fclose    L0;
    23| push_i    0, L0;
    24| exit      L0;
    </pre>

    <h3>line feed</h3>
    
The "line feed" marks the end of a line in a textfile. The two chars to mark this are: <br>

    <pre>
    CR (carriage return, ASCII code: 13)
    LF (line feed,       ASCII code: 10)
    </pre>

The terms "carriage return" and "line feed" are from the good old typewriter age. <br><br>

Every operating system uses a different code:

    <pre>
    DOS, Windows:           CRLF
    Mac OS:                 CR
    Amiga OS, Unix, Linux:  LF
    ?:                      LFCR (Yes! Even this weird thing seems to be around!)
    </pre>

If we read a line with "fread_ls", nano takes care of all codes. It can handle all line feeds. <br>
Writing a line feed with "fwrite_n" is different. We have to choose a code. <br>
This can be done with some code like this: <br>

    <pre>
    string cr[2];
    string lf[2];
    
    push_i          13, L0;
    char            L0, cr;
    push_i          10, L0;
    char            L0, lf;
    
    move_s          cr, _fnewline;
    add_s           _fnewline, lf, _fnewline;
    </pre>
    
This sets "_fnewline" to CRLF. The "fwrite_n" opcode uses CRLF now. <br>
There is a default setting for "_fnewline". It's the host code. <br>
On a windows machine "_fnewline" is set to CRLF, and so on. <br><br><br>


    <h3>binary files</h3>
    
There are two ways to store binary numbers in a file: <br>
- little endian <br>
- big endian <br><br>

If we write the long int "76543" to a file, we get this hex code: <br><br>

    <pre>
    little endian:  FF 2A 01 00
    big endian:     00 01 2A FF
    </pre>
    
The long int is four bytes long. Each number pair is one byte. <br>
The difference is: "little endian" is the other way round as "big endian". <br><br>

We have to know the endianess of a binary file, to read and write numbers. <br>
Otherwise we would read and write false numbers. <br><br>

The endianess is set by the variable "_fendian". An example: <br>

    <pre>
    #include &lt;file.nah&gt;

    #setreg_l       L0, null;
    #setreg_l       L1, file;
    #setreg_l       L2, n;
    #setreg_l       L3, endian;

    push_i          0, null;
    push_i          0, file;
    push_l          76543L, n;
    
    push_i          ENDIAN_BIG, endian;
    pull_i          endian, _fendian;

    fopen           file, "big_endian", "w";
    fwrite_l        file, n;
    fclose          file;
    
    exit            null;
    </pre>



<a href="internal_variables.html" target="page">Prev: Internal variables</a> | <a href="files_error.html" target="page">Next: Files error codes</a>
                    </td>
                </tr>
			</table>
		</center>
    </body>
</html>


