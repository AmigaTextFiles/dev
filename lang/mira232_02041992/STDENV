
abs x	= - x,	if x <= 0
	= x,	if x>0


and = foldr (&) True

|| arctan	defined internally

cjustify n s =	spaces lmargin++s++spaces rmargin
		where
		margin = n - # s
		lmargin = margin div 2
		rmargin = margin - lmargin

|| code		defined internally

concat = foldr (++) []
const x y = x
converse f x y = f y x

|| cos		defined internally

|| NEW
curry f x y = f(x,y)

digit x
	= '0' <= x <= '9'

drop (n+1) (x:xs) = drop n xs
drop n x
	= x, if integer n


dropwhile p [] = []
dropwhile p (x:xs)
	= dropwhile p xs, if p x
	= x:xs, otherwise
		     
e = exp 1

|| entier	defined internally
|| error	is missing
|| exp		defined internally
|| filemode	is missing

filter p (x1:x2)
	= x1:filter p x2, if p x1
	= filter p x2,	  otherwise
filter p [] = []

foldl op r (a:x) = foldl op (op r a) x
foldl op x [] = x
foldl1 op (a:x) = foldl op a x

foldr op x1 (x2:x3) = op x2 (foldr op x1 x3)
foldr op x1 [] = x1
foldr1 op [x] = x
foldr1 op (a:b:x) = a $op foldr1 op (b:x)

|| force	defined internally

fst (x,y) = x

|| getenv	is missing

hd (x:xs) = x

|| hugenum	is missing

id x = x

index x =
	index_hlp 0 x
	where
	index_hlp x (y:xs) = x:index_hlp (x + 1) xs
	index_hlp x [] = []

init (a:b:r) = a: init(b:r)
init [x] = []

inits (x:xs) = [x] : map (x:) (inits xs)
inits [] = []

|| The version of `integer' below reflects the current implementation of num's,
|| i.e. all num's are internally floating point numbers.
|| It is NOT equivalent to `integer x = x = entier x',
|| because Miracula is untyped and even `integer []' is okay and `False'.
integer x
	= True, if x = entier x
	= False, otherwise

|| NEW
|| ischar	defined internally
|| `ischar x 'is True if it evaluates to a character
|| it supports a do-it-yourself type-check

iterate f x = x:iterate f (f x)

last (a:b:r) = last (b:r)
last [a] = a

lay = foldr ((++).(++ "\n")) []

|| layn		is missing

letter c
	= 'a' <= c <= 'z' \/ 'A' <= c <= 'Z'


limit (a:b:xs)
	= a,		if a = b
	= limit (b:xs), otherwise

lines [] = []
lines (a:x)
	= []:lines x,	if a='\n'
	= (a:x1):xrest,	otherwise
	  where
	  (x1:xrest)
		= lines x, if x~=[]
		= [[]], otherwise
				
ljustify x0 x1 = x1 ++ spaces (x0 -  # x1)

|| log10	defined internally

map f [] = []
map f (x:xs) = f x : map f xs

map2 f x y = map (uncurry f) (zip2 x y)

max = foldl1 max2
max2 a b
	= a, if a>=b
	= b, otherwise

member xs x = or (map (= x) xs)

merge [] y = y
merge (a:x) [] = a:x
merge (a:x) (b:y)
	= a:merge x (b:y), if a<=b
	= b:merge (a:x) y, if a>b
	
min = foldl1 min2
min2 x y
	= x, if x<=y
	= y, otherwise

mkset (x:xs) = x:filter (~= x) (mkset xs)
mkset [] = []

neg x =  - x

|| numval	is missing

or = foldr (\/) False

|| NEW, partitions of a list
parts = foldr op [[]]
	where
	op x [[]] = [[[x]]]
	op x xss = s' (++) (map (glue x)) (map ([x]:)) xss
	s' b f g x = f x $b g x
	glue x = s' (:) ((x:).hd) tl

pi = 4 * arctan 1

postfix x xs = xs ++ [x]

product = foldl (*) 1

|| read		is missing

rep 0 x0 = []
rep (n+1) it = it : rep n it

repeat x = x:repeat x

reverse = foldl (converse (:)) []

rjustify x0 x1 = spaces (x0 -  # x1) ++ x1

scan op =
	g
	where
	g r [] = [r]
	g r (a:x) = r: g (r $op a) x
		
|| seq		defined internally

|| show, shownum, ...		are missing

snd (a,b) = b

sort x	= x, if n<=1
	= merge (sort (take n2 x)) (sort (drop n2 x)), if n>1
		where
		n = #x
		n2 = n div 2
		
spaces x = rep x ' '

subtract = converse (-)

sum = foldr (+) 0

|| system, sysmessage, ...	are missing

|| NEW
tails (a:b) = (a:b) : tails b
tails [] = [[]]

take (n+1) (x:ls) = x:take n ls
take n ls
	= [], if integer n
		
takewhile p [] = []
takewhile p (x:xs)
	= x:takewhile p xs, if p x
	= [], otherwise

tl (x:xs) = xs

transpose x
	= [], x' = []
	= map hd x' : transpose (map tl x'), otherwise
	      where
	      x' = takewhile (~=[]) x

|| NEW
uncurry f (x,y) = f x y

|| undef	is missing

until p f x
	= until p f (f x), if ~p x
	= x, otherwise

zip2 (x0:x1) (x2:x3) = (x0, x2):zip2 x1 x3
zip2 x0 x1 = []

zip3 (x0:x1) (x2:x3) (x4:x5) = (x0, x2, x4):zip3 x1 x3 x5
zip3 x0 x1 x2 = []

zip4 (x0:x1) (x2:x3) (x4:x5) (x6:x7) = (x0, x2, x4, x6):zip4 x1 x3 x5 x7
zip4 x0 x1 x2 x3 = []

zip5 (x0:x1) (x2:x3) (x4:x5) (x6:x7) (x8:x9) =
     (x0, x2, x4, x6, x8):zip5 x1 x3 x5 x7 x9
zip5 x0 x1 x2 x3 x4 = []

zip6 (x0:x1) (x2:x3) (x4:x5) (x6:x7) (x8:x9) (x10:x11) =
     (x0, x2, x4, x6, x8, x10):zip6 x1 x3 x5 x7 x9 x11
zip6 x0 x1 x2 x3 x4 x5 = []

zip (x,y) = zip2 x y

|| the following definitions are used for implementing the ..-notation
|| DO NOT change names nor definitions!!

upto from to
	= from:upto (from+1) to, if from<=to
	= [], otherwise

upfrom n = n: upfrom (n+1)

uptoby a1 a2 to
	= upwards a1, if a1<a2
	= downwards a1, if a1>a2
	= repeat a1, otherwise
		where
		inc = abs (a1-a2)
		upwards x
			= x : upwards (x+inc), if x<=to
			= [], otherwise
		downwards x
			= x : downwards (x-inc), if x>=to
			= [], otherwise

upfromby a1 a2
	= upwards a1, if a1<a2
	= downwards a1, if a1>a2
	= repeat a1, otherwise
		where
		inc = abs (a1-a2)
		upwards x = x: upwards(x+inc)
		downwards x = x: downwards(x-inc)
		

