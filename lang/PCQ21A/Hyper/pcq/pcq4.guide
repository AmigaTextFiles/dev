@database Contents
@master PCQ:Hyper/pcq/pcq4.guide
@$VER: 1.0
@author "Nils Sjoholm"
@(c) "@ Nils Sjoholm"
@remark Created with Heddley v1.1 (c) Edd Dumbill 1994

@node "Main" "PCQ/Internal"




                             PCQ/Internal

                           SizeOf to Writeln

                              @{" SizeOf   " link "sizeof" 0}
                              @{" Sqr      " link "sqr" 0}
                              @{" Sqrt     " link "sqrt" 0}
                              @{" Succ     " link "succ" 0}
                              @{" Tan      " link "tan" 0}
                              @{" Trap     " link "trap" 0}
                              @{" Trunc    " link "trunc" 0}
                              @{" VA_Arg   " link "va_arg" 0}
                              @{" VA_Start " link "va_start" 0}
                              @{" Write    " link "write" 0}
                              @{" Writeln  " link "writeln" 0}













@endnode

@node "sizeof" "PCQ/SizeOf"

    PCQ/SizeOf

    NAME
        SizeOf - return the size of a type

    SYNOPSIS
        FUNCTION SizeOf(TP : Any TYPE identifier) : Integer;

    DESCRIPTION
        This function returns the size of the specified type
        in bytes.  Using this function never generates any
        code - it is simply replaced by the actual number of
        bytes, as if it were a constant.  Therefore it is a
        good idea to use this function wherever it's
        appropriate.

        Note that although the size of a type might be odd,
        if the size is greater than 1 any variable of that
        type will always begin on an even word boundary.
        This applies within records, arrays, or anywhere the
        variable can occur.

    EXAMPLE

        PROGRAM ShowSizes;
        BEGIN
            Writeln('SizeOf(Real)    = ', SizeOf(Real));
            Writeln('SizeOf(Integer) = ', SizeOf(Integer));
            Writeln('SizeOf(Word)    = ', SizeOf(Word));
            Writeln('SizeOf(Short)   = ', SizeOf(Short));
            Writeln('SizeOf(Byte)    = ', SizeOf(Byte));
            Writeln('SizeOf(Address) = ', SizeOf(Address));
            Writeln('SizeOf(Boolean) = ', SizeOf(Boolean));
            Writeln('SizeOf(Char)    = ', SizeOf(Char));
            Writeln('SizeOf(Text)    = ', SizeOf(Text));
            Writeln('SizeOf(String)  = ', SizeOf(String));
        END.

    INPUTS

        TP    : Any type identifier.  This must be a simple
                identifier, not a complete type specification.

    RESULTS
        The size of the specified type in bytes

    BUGS

    SEE ALSO

@endnode

@node "sqr" "PCQ/Sqr"


    PCQ/Sqr

    NAME
        Sqr - return the expression squared

    SYNOPSIS
        FUNCTION Sqr(Expr : Any numeric TYPE) : The same TYPE

    DESCRIPTION
        This function returns the square of the value, i.e.
        Expr * Expr.

    EXAMPLE

        PROGRAM ShowSqr;
        VAR
            Value : Real;
        BEGIN
            Write('Please enter a value: ');
            Readln(Value);
            Writeln(Value:0:3, ' squared is ', Sqr(Value):0:3);
        END.

    INPUTS

        Expr : Any numeric expression

    RESULTS
        The square of the expression, (Expr * Expr), in the
        same type.

    BUGS

    SEE ALSO

        @{" Sqrt " link "sqrt" 0}

@endnode

@node "sqrt" "PCQ/Sqrt"

    PCQ/Sqrt

    NAME
        Sqrt - return the square root of an expression

    SYNOPSIS
        FUNCTION Sqrt(Expr : Real) : Real;

    DESCRIPTION
        The Sqrt function returns the approximate square root
        of the specified expression, i.e. Sqrt(Expr) * Sqrt(Expr)
        is close to Expr.

    EXAMPLE

        PROGRAM ShowSqrt;
        VAR
            Value : Real;
        BEGIN
            Write('Please enter a value: ');
            Readln(Value);
            Writeln('The square root OF ', Value:0:3,
                        ' is ', Sqrt(Value):0:3);
        END.

    INPUTS

        Expr : Any Real type expression

    RESULTS
        An approximation of the square root of the expression

    BUGS

    SEE ALSO

        @{" Sqr " link "sqr" 0}

@endnode

@node "succ" "PCQ/Succ"

    PCQ/Succ

    NAME
        Succ - return the next ordinal value

    SYNOPSIS
        FUNCTION Succ(Expr : Any ordinal TYPE) : The same TYPE;

    DESCRIPTION
        Succ returns the successor to an ordinal value, i.e.
        the value plus 1.  If the value is already at its maximum
        value, in an enumerated type for example, the returned
        value has no meaning.

    EXAMPLE

        PROGRAM ShowSucc;
        VAR
            i : (sunday,monday,tuesday,wednesday,
                 thursday,friday,saturday);
        BEGIN
            i := sunday;
            WHILE i < saturday DO
                i := Succ(i);
        END.

    INPUTS

        Expr  : Any ordinal expression

    RESULTS
        A value of the same type

    BUGS

    SEE ALSO

        @{" Pred " link "PCQ:Hyper/pcq/pcq2.guide/pred" 0} @{" Inc  " link "PCQ:Hyper/pcq/pc12.guide/inc" 0}

@endnode

@node "tan" "PCQ/Tan"

    PCQ/Tan

    NAME
        Tan - computes the tangent of the specified angle in radians

    SYNOPSIS
        FUNCTION Tan(Radians : Real) : Real;

    DESCRIPTION
        This function computes the tangent of the angle, which must
        be specified in radians.  The tangent function is not defined
        at odd multiples of PI/2, so neither is this function.

        If you are using the $N+ option, this function is computed by
        the mathtrans.library.  Otherwise, it is computed by internal
        PCQ routines.

    EXAMPLE

        PROGRAM ShowTan;
        VAR
            Angle : Real;
        BEGIN
            Write('Enter an angle IN radians: ');
            Readln(Angle);
            Writeln('The tangent of ', Angle:0:3, ' is ',
                                Tan(Angle):0:3);
        END.

    INPUTS

        Radians : The radian measure of the angle

    RESULTS
        The tangent of the specified angle

    BUGS

    SEE ALSO

        @{" Sin    " link "PCQ:Hyper/pcq/pcq3.guide/sin" 0} @{" Cos    " link "PCQ:Hyper/pcq/pcq1.guide/cos" 0} @{" ArcTan " link "PCQ:Hyper/pcq/pcq1.guide/arctan" 0}

@endnode

@node "trap" "PCQ/Trap"

    PCQ/Trap

    NAME
        Trap - issue a 68000 TRAP instruction

    SYNOPSIS
        PROCEDURE Trap(TrapNum : Integer);

    DESCRIPTION
        This routine inserts a 68000 TRAP instruction into your
        code.  In some cases (you'll have to experiment) the
        trap will act as a breakpoint for a debugger.

    EXAMPLE

        PROGRAM TryTrap;
        BEGIN
            Trap(4); { Will GURU if not in a debugger }
        END.

    INPUTS

        TrapNum : The trap number to generate

    RESULTS
        None

    BUGS

    SEE ALSO

@endnode

@node "trunc" "PCQ/Trunc"

    PCQ/Trunc

    NAME
        Trunc - convert a Real value into an Integer

    SYNOPSIS
        FUNCTION Trunc(Expr : Real) : Integer;

    DESCRIPTION
        The Trunc function returns the whole number portion
        of a Real expression.  In other words, it rounds the
        Real value down and returns the Integer part.

        This routine is somewhat faster than the Round
        function.

        Note that this function is automatically invoked by
        the compiler to convert Real values to Integers,
        whenever that is appropriate.

    EXAMPLE

        PROGRAM ShowTrunc;
        VAR
            FloatValue : Real;
        begin
            Write('Please enter a Real value: ');
            Readln(FloatValue);
            Writeln(FloatValue:0:3, ' becomes ', Trunc(FloatValue));
        END.

    INPUTS

        Expr  : Any Real type expression

    RESULTS
        The whole number portion of Expr, i.e. Expr with the
        fractional digits truncated.

    BUGS

    SEE ALSO

        @{" Round " link "PCQ:Hyper/pcq/pcq3.guide/round" 0} @{" Float " link "PCQ:Hyper/pcq/pcq2.guide/float" 0}

@endnode

@node "va_arg" "PCQ/VA_Arg"

    PCQ/VA_Arg

    NAME
        VA_Arg - return the next unnamed parameter

    SYNOPSIS
        FUNCTION VA_Arg(VAR ArgPtr : Address;
                        Simple Type Spec) : Simple Type;

    DESCRIPTION
        The VA_Arg routine retrieves the next unnamed parameter
        from the stack.  You should first call VA_Start to
        initialize ArgPtr, an Address variable, then call this
        routine to get each of the parameters.  The type returned
        by this function is the simple type specified as the
        second argument.

    EXAMPLE

        PROGRAM Unnamed;
        {$C+ use C calling conventions }
            PROCEDURE WriteAll(Num : Short; ... );
            VAR
                ArgPtr : Address;
                i      : Short;
            BEGIN
                VA_Start(ArgPtr);
                FOR i := 1 TO Num DO
                    Writeln(VA_Arg(ArgPtr,Integer));
            END;
        BEGIN
            WriteAll(1,45);
            WriteAll(3,56,12,12345);
        END.

    INPUTS

        ArgPtr           : A variable of type Address that will be
                           used to point to the next argument.
        Simple Type Spec : The type specification of a simple
                           type.

    RESULTS
        The value from the stack, of the type specified as the
        second parameter.

    BUGS

    SEE ALSO

        @{" VA_Start " link "va_start" 0}

@endnode

@node "va_start" "PCQ/VA_Start"

    PCQ/VA_Start

    NAME
        VA_Start - initialize an argument pointer

    SYNOPSIS
        PROCEDURE VA_Start(VAR ArgPtr : Address);

    DESCRIPTION
        The VA_Start procedure initializes ArgPtr to point to the
        first of the routine's unnamed parameters.  It must be
        called before any calls to VA_Arg.

    EXAMPLE

        PROGRAM Unnamed;
        {$C+ use C calling conventions }
            PROCEDURE WriteAll(Num : Short; ... );
            VAR
                ArgPtr : Address;
                i      : Short;
            BEGIN
                VA_Start(ArgPtr);
                FOR i := 1 TO Num DO
                    Writeln(VA_Arg(ArgPtr,Integer));
            END;
        BEGIN
            WriteAll(1,45);
            WriteAll(3,56,12,12345);
        END.

    INPUTS

        ArgPtr           : A variable of type Address that will be
                           used to point to the next argument.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" VA_Arg " link "va_arg" 0}

@endnode

@node "write" "PCQ/Write"

    PCQ/Write

    NAME
        Write - send data to a PCQ file

    SYNOPSIS
        PROCEDURE Write([VAR OutputFile,] Arguments );

        Each argument can take the form: e:m:n, where e is an
        expression and m and n are integer expressions.

    DESCRIPTION
        The standard procedure Write outputs data to the
        specified PCQ file, or to the standard output file
        Output if no file is specified.

        If OutputFile is a typed file, the data is written as
        a direct binary representation, just as it exists in
        memory.  In that case, the extra values m and n in
        the argument definition above are not allowed.

        If the output file is a Text file, the data is first
        converted to a character representation before it is
        written.  The results of the conversion depend on the
        type of the expression e.

        If e is an Integer, Word, Short or Byte type, the
        number is converted into its decimal representation,
        preceded by a minus sign if appropriate.  If the
        character representation is less than m characters
        long, the field is filled with spaces.  The parameter
        n is not allowed.

        If e is a Real value, the integer part of the value
        is converted to a character representation and printed
        according to the rules for an Integer.  If the parameter
        n is greater than zero, a decimal point is written and
        n fractional digits follow.

        If e is a String, the characters in the string up to,
        but not including, the final null byte are written.  If
        there are less than m characters in the string, spaces
        are written before the string to fill out the field.  The
        parameter n is not allowed.

        If e is an Array of Char, the entire array is written
        to the file, possibly preceded by enough space characters
        to fill out the field.  Again the parameter n is not
        allowed.

        If e is a Char type, the single character is written,
        possibly preceded by m-1 space characters.  The parameter
        n is not allowed.

        If e is a Boolean type, the string TRUE or the string
        FALSE is written, preceded by spaces as necessary to fill
        out the field.  The parameter n is not allowed.

        No other types can be written to a text file.

        If an error occurs during the write, IOResult will be set
        to a non-zero value.  If IOResult is not zero when you
        call Write, no output will occur.

    EXAMPLE

        PROGRAM ShowWrite;
        BEGIN
            Write(56);          (* Writes '56'         *)
            Write(Output,56:4); (* Writes '  56'       *)
            Write(98.6:5:4);    (* Writes '   98.6000' *)
            Write(45 > 32);     (* Writes 'TRUE'       *)
            Write(32 > 45:8);   (* Writes '   FALSE'   *)
        END.

    INPUTS

        OutputFile : The destination file, which must have been
                     opened for output using Rewrite or Open.
        Arguments  : Any number of expressions.  If the output
                     file is a typed file, these expressions
                     must each match the file type, and cannot
                     use field width specifiers.  If the file
                     is a Text file, they can be any of the
                     types mentioned above, and can have at
                     least one field width specifier.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Writeln " link "writeln" 0} @{" Read    " link "PCQ:Hyper/pcq/pcq3.guide/read" 0} @{" Readln  " link "PCQ:Hyper/pcq/pcq3.guide/readln" 0}
        @{" Rewrite " link "PCQ:Hyper/pcq/pcq3.guide/rewrite" 0} @{" Open    " link "PCQ:Hyper/pcq/pcq2.guide/open" 0} @{" Put     " link "PCQ:Hyper/pcq/pcq2.guide/put" 0}

@endnode

@node "writeln" "PCQ/Writeln"

    PCQ/Writeln

    NAME
        Writeln - write arguments, then append a newline character

    SYNOPSIS
        PROCEDURE Writeln([VAR OutputFile : Text;] Arguments );

    DESCRIPTION
        Writeln outputs values to a PCQ file like Write, but with
        two differences: it only works with Text files, and it
        appends a newline character after writing all of the
        arguments.

        Writeln only works on Text files because typed files,
        which are unlimited sequences of a single type, don't
        have lines.

        The newline character on the Amiga is a line feed, or
        Chr(10), but since on other machines it can be quite
        different (on MS-DOS machines, for example, it is a
        carraige return/line feed pair), you should use this
        routine rather than writing line feeds directly.

    EXAMPLE

        PROGRAM ShowWriteln;
        BEGIN
            Writeln(50:3, 100.0:5:2); { Writes ' 50  100.00' }
        END.

    INPUTS

        OutputFile : A PCQ Text file, already open for output.  If
                     OutputFile is not supplied, PCQ used the
                     standard output file Output.
        Arguments  : A series of arguments exactly like those of
                     Write, which will be written the same way.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Write   " link "write" 0} @{" Read    " link "PCQ:Hyper/pcq/pcq3.guide/read" 0} @{" Readln  " link "PCQ:Hyper/pcq/pcq3.guide/readln" 0}
        @{" Rewrite " link "PCQ:Hyper/pcq/pcq3.guide/rewrite" 0} @{" Open    " link "PCQ:Hyper/pcq/pcq2.guide/open" 0} @{" Put     " link "PCQ:Hyper/pcq/pcq2.guide/put" 0}

@endnode



