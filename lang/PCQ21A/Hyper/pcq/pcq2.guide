@database Contents
@master PCQ:Hyper/pcq/pcq2.guide
@$VER: 1.0
@author "Nils Sjoholm"
@(c) "@ Nils Sjoholm"

@node "Main" "PCQ/Internal"




                         PCQ/Internal

                         Exit to Put

                          @{" Exit  " link "exit" 0}
                          @{" Exp   " link "exp" 0}
                          @{" Float " link "float" 0}
                          @{" Floor " link "floor" 0}
                          @{" Get   " link "get" 0}
                          @{" Inc   " link "inc" 0}
                          @{" Ln    " link "ln" 0}
                          @{" New   " link "new" 0}
                          @{" Open  " link "open" 0}
                          @{" Ord   " link "ord" 0}
                          @{" Pred  " link "pred" 0}
                          @{" Put   " link "put" 0}













@endnode

@node "exit" "PCQ/EXIT"
@next "exp"
@prev "Main"

    PCQ/Exit

    NAME
        Exit - quit the program

    SYNOPSIS
        PROCEDURE Exit [ (ReturnCode : Integer) ] ;

    DESCRIPTION
        The standard procedure Exit terminates the program.  If
        you supply a return code, it is passed back to AmigaDOS.
        If not, a return code of 0 is passed back.

        Calling exit invokes all the exit procedures, as if the
        program had ended normally.  It is therefore the
        recommending way to end a program early.  You should not
        call the AmigaDOS procedure DOSExit(), since the exit
        procedures will not be able to take effect.

    EXAMPLE

        PROGRAM Reader;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str : String;
        BEGIN
            Str := AllocString(256);
            REPEAT
                Readln(Str);
                IF StrIeq(Str,"quit") THEN
                    Exit;
                Writeln(Str);
            UNTIL FALSE;
        END.

    INPUTS

        ReturnCode : An optional AmigaDOS return code.

    RESULTS
        None

    BUGS

    SEE ALSO

@endnode

@node "exp" "PCQ/Exp"
@next "float"
@prev "exit"

    PCQ/Exp

    NAME
        Exp - compute e raised to the specified power

    SYNOPSIS
        FUNCTION Exp(Power : Real) : Real;

    DESCRIPTION
        This value computes the exponential value of the argument,
        i.e. the value e (about 2.71) raised to the power of the
        argument.  If you have used the $N+ directive, this is
        computed by the mathtrans.library.  Otherwise, internal
        PCQ routines handle it.

    EXAMPLE

        PROGRAM ShowExp;
        VAR
            Power : Real;
        BEGIN
            Write('Enter an exponent: ');
            Readln(Power);
            Writeln('e raised to the ', Power:0:3, ' power is ',
                                Exp(Power):0:3);
        END.

    INPUTS

        Power : A Real type expression

    RESULTS
        e raised to the specified power

    BUGS

    SEE ALSO

        @{" Ln " link "ln" 0}

@endnode

@node "float" "PCQ/Float"

    PCQ/Float

    NAME
        Float - convert an Integer to a Real value.

    SYNOPSIS
        FUNCTION Float(Expr : Integer) : Float;

    DESCRIPTION
        This function converts the Integer expression into its
        Real type counterpart.  Float is called automatically
        by the compiler to "promote" Integer values in expressions
        when necessary.

    EXAMPLE

        PROGRAM ShowFloat;
        VAR
            IntValue : Integer;
        BEGIN
            Write('Please enter an Integer: ');
            Readln(IntValue);
            Writeln(IntValue, ' becomes ', Float(IntValue):0:5);
        END.

    INPUTS

        Expr : Any Integer type expression

    RESULTS
        The expression converted to a Real value

    BUGS

    SEE ALSO

        @{" Trunc " link "PCQ:Hyper/pcq/pcq4.guide/trunc" 0} @{" Round " link "PCQ:Hyper/pcq/pcq3.guide/round" 0}

@endnode

@node "floor" "PCQ/Floor"
@next "get"
@prev "float"

    PCQ/Floor

    NAME
        Floor - return the greatest whole number less than or equal

    SYNOPSIS
        FUNCTION Floor(Expr : Real) : Real;

    DESCRIPTION
        The Floor function returns the greatest whole number (still
        in Real format, however) less than or equal to the value
        passed in.

    EXAMPLE

        PROGRAM ShowFloor;
        VAR
            FloatValue : Real;
        BEGIN
            Write('Please enter a Real value: ');
            Readln(FloatValue);
            Writeln(FloatValue:0:3, ' becomes ',
                          Floor(FloatValue):0:3);
        END.

        Floor(5.4) = 5.0
        Floor(-5.4) = -6.0

    INPUTS

        Expr  : Any Real type expression

    RESULTS
        A Real value less than or equal to the original expression

    BUGS

    SEE ALSO

        @{" Ceil  " link "PCQ:Hyper/pcq/pcq1.guide/ceil" 0} @{" Round " link "PCQ:Hyper/pcq/pcq3.guide/round" 0} @{" Trunc " link "PCQ:Hyper/pcq/pcq4.guide/trunc" 0} @{" Float " link "float" 0}

@endnode

@node "get" "PCQ/Get"
@next "inc"
@prev "floor"

    PCQ/Get

    NAME
        Get - advance the input file pointer

    SYNOPSIS
        PROCEDURE Get(VAR F : Any FILE TYPE);

    DESCRIPTION
        Get advances the file pointer to the next record.  In
        a Text file, it advances it to the next character.

        Get is normally used by programs that access the file
        buffer directly through the F^ syntax.  It lets you
        examine the contents of a file without reading values
        into an extra variable.

    EXAMPLE

        PROGRAM TypeFiles;
        {$I "Include:Utils/Parameters.i"}
        {$I "Include:Utils/StringLib.i"}
        VAR
            InFile   : Text;
            FileName : String;
            ParamNum : Integer;
        BEGIN
            FileName := AllocString(256);
            ParamNum := 1;
            REPEAT
                GetParam(ParamNum,FileName);
                IF StrLen(FileName) > 0 THEN BEGIN
                    IF ReOpen(FileName, InFile) THEN BEGIN
                        WHILE NOT EOF(InFile) DO BEGIN
                            Write(InFile^);
                            Get(InFile);
                        END;
                        Close(InFile);
                    END ELSE
                        Writeln('Could NOT open ', FileName);
                END;
                Inc(ParamNum);
            UNTIL StrLen(FileName) = 0;
        END.

    INPUTS

        F     : Any PCQ file variable open for input

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Reopen " link "PCQ:Hyper/pcq/pcq3.guide/reopen" 0} @{" Reset  " link "PCQ:Hyper/pcq/pcq3.guide/reset" 0} @{" Put    " link "PCQ:Hyper/pcq/pcq2.guide/put" 0}
        @{" Read   " link "PCQ:Hyper/pcq/pcq3.guide/read" 0} @{" Readln " link "PCQ:Hyper/pcq/pcq3.guide/readln" 0}

@endnode

@node "inc" "PCQ/Inc"
@next "ln"
@prev "get"

    PCQ/Inc

    NAME
        Inc - increment a variable

    SYNOPSIS
        PROCEDURE Inc(VAR v : Any Integer OR pointer TYPE
                        [ ; Amount : Integer ] );

    DESCRIPTION
        The Inc procedure is normally used to add to an Integer
        type.  If v is an integer type and there is no amount
        specified, Inc will add 1.  Otherwise, it will add Amount.
        Note that this is somewhat faster than v := v + Amount.

        For pointer types, Inc advances the pointer to the next
        element.  For example, if v is a pointer to Real, Inc(v)
        will actually add 4 (the size of a Real) to v.  If you
        used an Amount, Inc would add Amount*4 to v.  This lets
        you move a pointer along an array of items.

    EXAMPLE

        PROGRAM ShowInc;
        VAR
            i : Integer;
            s : Short;
            p : ^Integer;
            q : ^Short;
        BEGIN
            Inc(i);    { i := i + 1 }
            Inc(s,45); { s := s + 45 }
            Inc(p,3);  { p := p + 3*4 }
            Inc(q);    { q := q + 2 }
        END.

    INPUTS

        v      : Any Integer or pointer type.
        Amount : An amount to add to v.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Dec " link "PCQ:Hyper/pcq/pcq1.guide/dec" 0}

@endnode

@node "ln" "PCQ/Ln"
@next "new"
@prev "inc"

    PCQ/Ln

    NAME
        Ln - compute the natural logarithm

    SYNOPSIS
        FUNCTION Ln(Expr : Real) : Real;

    DESCRIPTION
        The Ln function computes the natural logarithm of the
        argument.  If you have used the $N+ directive, this
        value is computed by the mathtrans.library.  Otherwise,
        it is calculated by internal PCQ routines.

    EXAMPLE

        PROGRAM ShowLn;
        VAR
            Value : Real;
        BEGIN
            Write('Please enter a value: ');
            Readln(Value);
            Writeln('Natural logarithm is ', Ln(Value):0:3);
        END.

    INPUTS

        Expr  : A Real type expression

    RESULTS
        The natural logarithm of Expr

    BUGS

    SEE ALSO

        @{" Exp " link "PCQ:Hyper/pcq/pcq2.guide/exp" 0}

@endnode

@node "new" "PCQ/New"
@next "open"
@prev "ln"

    PCQ/New


    NAME
        New - allocate space for a record

    SYNOPSIS
        PROCEDURE New(VAR p : Any pointer TYPE);

    DESCRIPTION
        The New procedure allocates memory for an instance of the
        type referenced by the pointer.  The memory is allocated
        through the PCQ memory allocation mechanism, which means
        that each allocation will have between 12 and 19 bytes of
        overhead (compared to 0 to 7 bytes for direct Exec calls).

        If the memory is not available, the HeapError function is
        called, and it determines the action taken from that point.
        By default, the program terminates with runtime error 54,
        but it could simply assign Nil to the variable p.

        PCQ memory is always allocated with the flags MEMF_PUBLIC
        and MEMF_CLEAR.  If you need any other flags, you'll need
        to call AllocMem directly.

    EXAMPLE

        PROGRAM ShowNew;
        TYPE
            Rec = RECORD
                      Field1, Field2 : Integer;
                  END;
        VAR
            Ptr : ^Rec;
        BEGIN
            New(Ptr);
            Writeln('Ptr allocated at ', Integer(Ptr));
        END.

    INPUTS

        p     : Any pointer variable.  You should not use the
                Address type, since Address does not point to a
                specific type.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Dispose     " link "PCQ:Hyper/pcq/pcq1.guide/dispose" 0} @{" GetMem      " link "PCQ:Hyper/utils/pcqmemory.guide/getmem" 0} @{" AllocString " link "PCQ:Hyper/utils/stringlib.guide/allocstring" 0} @{" AllocMem    " alink "Include:Exec/Memory.i/main" 111}

@endnode

@node "open" "PCQ/Open"
@next "ord"
@prev "new"

    PCQ/Open

    NAME
        Open - open a Pascal file for writing

    SYNOPSIS
        FUNCTION Open(  FileName   : String;
                        FileVar    : VAR Any file type
                    [ ; BufferSize : Integer ] ) : Boolean;

    DESCRIPTION
        The Open function opens a file for output, erasing any
        existing file of the same name.  If the file opens
        correctly, Open returns True.  If anything goes wrong,
        it returns False.  The Open function is provided for
        convenience only - you can do the same job by calling

        Rewrite and checking IOResult.

        The BufferSize parameter determines how large the file
        buffer will be (i.e. how many bytes you can write before
        the program has to call AmigaDOS).  It is optional - if
        you don't specify a value, 128 is used.

        Open does not affect IOResult, so you never need to
        check it after calling Open.  The downside of that is
        you can't find out exactly why the file could not be
        opened - to do that, use Rewrite and check IOResult.

    EXAMPLE

        PROGRAM ConToCon;
        VAR
            OutFile : Text;
            c       : Char;
        BEGIN
            IF Open("CON:100/50/200/100/Copy OutPut",OutFile) THEN BEGIN
                REPEAT
                    Read(c);
                    Write(OutFile, c);
                UNTIL c = '!';
                Readln;
                Close(OutFile);
            END ELSE
                Writeln('Could not open console window');
        END.

    INPUTS

        FileName   : A String containing the AmigaDOS file name and
                     optional path.
        FileVar    : Any PCQ file type.
        BufferSize : The number of bytes to allocate as a buffer.  If
                     no value is given, 128 will be used.

    RESULTS
        TRUE if the file opened correctly, or
        FALSE if anything at all went wrong.

    BUGS

    SEE ALSO

        @{" Rewrite  " link "PCQ:Hyper/pcq/pcq3.guide/rewrite" 0} @{" ReOpen   " link "PCQ:Hyper/pcq/pcq3.guide/reopen" 0} @{" Reset    " link "PCQ:Hyper/pcq/pcq3.guide/reset" 0} @{" Close    " link "PCQ:Hyper/pcq/pcq1.guide/close" 0}

@endnode

@node "ord" "PCQ/Ord"
@next "pred"
@prev "open"

    PCQ/Ord

    NAME
        Ord - return the ordinal value of an expression

    SYNOPSIS
        FUNCTION Ord(Expr : Any ordinal expression) : Integer;

    DESCRIPTION
        The Ord function returns the Integer value of any ordinal
        type.

    EXAMPLE

        PROGRAM ShowOrd;
        VAR
            Ch : Char;
        BEGIN
            Write('Enter a character: ');
            Readln(Ch);
            Writeln('The ordinal value OF ', Ch, ' is ', Ord(Ch));
        END.

    INPUTS

        Expr  : Any ordinal expression

    RESULTS
        The Integer corresponding to its ordinal value within
        the type.

    BUGS

    SEE ALSO

@endnode

@node "pred" "PCQ/Pred"
@next "put"
@prev "pred"

    PCQ/Pred

    NAME
        Pred - return the predecessor of an expression

    SYNOPSIS
        FUNCTION Pred(Expr : Any ordinal TYPE) : The same TYPE;

    DESCRIPTION
        The Pred function returns the previous value within an
        ordinal type.  If the expression is already at its
        minimum value, it will wrap around.  In the case of
        enumerated types, that will almost always produce
        nonsense results.

    EXAMPLE

        PROGRAM ShowPred;
        VAR
            month : (january,february,march,april,may,
                     june,july,august,september,october,
                     november,december);
        BEGIN
            month := december;
            WHILE month > january DO
                month := Pred(month);
        END.

    INPUTS

        Expr  : Any ordinal expression

    RESULTS
        A value of the same ordinal type

    BUGS

    SEE ALSO

        @{" Dec  " link "PCQ:Hyper/pcq/pcq1.guide/dec" 0} @{" Succ " link "PCQ:Hyper/pcq/pcq4.guide/succ" 0}

@endnode

@node "put" "PCQ/Put"
@prev "pred"

    PCQ/Put

    NAME
        Put - advance an output file pointer

    SYNOPSIS
        PROCEDURE Put(VAR F : Any TYPE OF FILE);

    DESCRIPTION
        The Put procedure advances the file pointer on an
        output file past the current record.  If the file
        pointer is advanced to the end of the file buffer,
        the buffer is flushed.

        This routine is normally used in conjunction with
        the file pointer to write information to a file
        directly.

    EXAMPLE

        PROGRAM ShowPut;
        BEGIN
            Output^ := 'z';
            Put(Output);  { Same as Write(Output, 'z'); }
        END.

    INPUTS

        F     : A PCQ file open for output

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" Get     " link "get" 0} @{" Write   " link "PCQ:Hyper/pcq/pcq4.guide/write" 0} @{" Writeln " link "PCQ:Hyper/pcq/pcq4.guide/writeln" 0}
        @{" Open    " link "open" 0} @{" Rewrite " link "PCQ:Hyper/pcq/pcq3.guide/rewrite" 0}
@endnode


