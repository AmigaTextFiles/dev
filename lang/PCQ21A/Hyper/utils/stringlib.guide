@database Contents
@master PCQ:Hyper/utils/stringlib.guide
@$VER: 1.0
@author "Nils Sjoholm"
@(c) "@ Nils Sjoholm"

@node "Main" "Utils/StringLib"




                          Utils/StringLib

                          @{" AllocString " link "allocstring" 0}
                          @{" FreeString  " link "freestring" 0}
                          @{" Hash        " link "hash" 0}
                          @{" IntToStr    " link "inttostr" 0}
                          @{" IsAlnum     " link "isalnum" 0}
                          @{" IsAlpha     " link "isalpha" 0}
                          @{" IsDigit     " link "isdigit" 0}
                          @{" IsLower     " link "islower" 0}
                          @{" IsSpace     " link "isspace" 0}
                          @{" IsUpper     " link "isupper" 0}
                          @{" StrCat      " link "strcat" 0}
                          @{" StrCmp      " link "strcmp" 0}
                          @{" StrCpy      " link "strcpy" 0}
                          @{" StrDup      " link "strdup" 0}
                          @{" StrEq       " link "streq" 0}
                          @{" StrICmp     " link "stricmp" 0}
                          @{" StrIEq      " link "strieq" 0}
                          @{" StrLen      " link "strlen" 0}
                          @{" StrnCat     " link "strncat" 0}
                          @{" StrnCmp     " link "strncmp" 0}
                          @{" StrnCpy     " link "strncpy" 0}
                          @{" StrnEq      " link "strneq" 0}
                          @{" StrnICmp    " link "strnicmp" 0}
                          @{" StrnIEq     " link "strnieq" 0}
                          @{" StrPos      " link "strpos" 0}
                          @{" StrRPOs     " link "strrpos" 0}
                          @{" ToLower     " link "tolower" 0}
                          @{" ToUpper     " link "toupper" 0}





@endnode

@node "allocstring" "Utils/StringLib/AllocString"

    Utils/StringLib/AllocString

    NAME
        AllocString - allocate memory for a string

    SYNOPSIS
        FUNCTION AllocString(Size : Integer) : String;

    DESCRIPTION
        AllocString allocates a block of memory at least Size
        bytes, and returns a pointer to it.  This memory is
        allocated using PCQ's memory allocator, which means
        that HeapError could come into play, and that the
        memory will automatically be returned to the system
        at the end of the program.

        Since AllocString uses PCQ memory allocation, each
        allocation will use from 12 to 20 extra bytes.  Thus
        if you are allocating lots of strings and can keep
        track of them through some other means, you might
        want to call AllocMem directly.

    EXAMPLE

        PROGRAM Allocator;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str : String;
        BEGIN
            Str := AllocString(256);
        END. { The memory is automatically freed }

    INPUTS

        Size : The number of bytes to allocate.

    RESULTS
        A pointer to the newly allocated memory, or possibly
        Nil if you have set up HeapError appropriately.

    BUGS

    SEE ALSO

        @{" GetMem   " link "PCQ:Hyper/utils/PCQMemory.guide/getmem" 0} @{" AllocMem " alink "Include:Exec/Memory.i/main" 111}

@endnode

@node "freestring" "Utils/StringLib/FreeString"

    Utils/StringLib/FreeString

    NAME
        FreeString - free memory allocated by AllocString

    SYNOPSIS
        PROCEDURE FreeString(Str : String);

    DESCRIPTION
        FreeString returns memory allocated through PCQ's
        memory allocation routines to the system.  You need
        not supply the length of the string, since it is
        recorded when the block is allocated.

        Note that PCQ memory is automatically freed at the
        end of the program, but this routine lets you use
        the memory earlier.

    EXAMPLE

        PROGRAM Deallocator;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str : String;
        BEGIN
            Str := AllocString(256);
            Writeln('Allocated space at ', Integer(Str));
            FreeString(Str);
            Str := AllocString(256);
            Writeln('Allocated space at ', Integer(Str));
        END.

    INPUTS

        Str   : The address of the block to free, as returned by
                AllocString.  Str must point to the beginning of
                the block, and the entire block will be freed.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" AllocString " link "allocstring" 0} @{" GetMem      " link "PCQ:Hyper/utils/pcqmemory.guide/getmem" 0} @{" FreePCQMem  " link "PCQ:Hyper/utils/pcqmemory.guide/freepcqmem" 0}
        @{" AllocMem    " alink "Include:Exec/Memory.i/main" 111} @{" FreeMem     " alink "Include:Exec/Memory.i/main" 129}

@endnode

@node "hash" "Utils/StringLib/Hash"

    Utils/StringLib/Hash

    NAME
        Hash - calculate the AmigaDOS hash value of a string

    SYNOPSIS
        FUNCTION Hash(Str : String) : Short;

    DESCRIPTION
        This function calculates a hash value for a given string
        the same way they are calculated for DOS0 (the original
        file system) directories.  This method looks like this:

                FUNCTION Hash(Str : String) : Short;
                VAR
                    i, Result : Short;
                BEGIN
                    Result := StrLen(Str);
                    FOR i := 0 TO StrLen(Str) DO
                        Result := ((Result * 13) +
                                   Ord(ToUpper(Str[i]))) AND $07FF;
                END;

    EXAMPLE

        PROGRAM CalculateHash;
        {$I "Include:Utils/StringLib.i"}
        BEGIN
            Writeln('The hash value OF the command line is: ',
                    Hash(CommandLine));
        END.

    INPUTS

        Str   : The string to examine

    RESULTS
        A hash value between 0 and 16383

    BUGS

    SEE ALSO

@endnode

@node "inttostr" "Utils/StringLib/IntToStr"

    Utils/StringLib/IntToStr

    NAME
        IntToStr - convert an integer to its character representation

    SYNOPSIS
        FUNCTION IntToStr(Dest : String; Int : Integer) : Integer;

    DESCRIPTION
        IntToStr converts the integer Int to its string form in the
        Dest string.  It returns the number of characters in the
        new string, from 0 to 11.  If Int is negative, the string
        will start off with a minus sign, but there will be no
        extra spaces before or after the number.  The string will
        be null-terminated.

    EXAMPLE

        PROGRAM ShowInts;
        {$I "Include:Utils/StringLib.i"}
        VAR
            MyInt : Integer;
            Str   : String;
        BEGIN
            Str := AllocString(12);
            Write('Enter an Integer: ');
            Readln(MyInt);
            MyInt := IntToStr(Str, MyInt);
            Writeln('That looks like "', Str, '"');
        END.

    INPUTS

        Str   : The destination string, which must be long enough
                to hold the result, which will be no more than
                11 characters.
        Int   : The number to represent.

    RESULTS
        The number of characters, from 1 to 11, in the character
        representation.

    BUGS

    SEE ALSO

@endnode

@node "isalnum" "Utils/StringLib/IsAlnum"

    Utils/StringLib/IsAlnum

    NAME
        isalnum - check if the character is a letter or digit

    SYNOPSIS
        FUNCTION IsAlnum(c : Char) : Boolean;

    DESCRIPTION
        This function checks whether the character is in the
        range a..z, A..Z or '0'..'9'.  In other words, it returns
        TRUE if isalpha(c) or isdigit(c) is TRUE.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsAlnum(c) THEN
                    Write('NOT ');
                Writeln('alphanumeric');
            END;
        END.

    INPUTS

        c     : The character to check.

    RESULTS
        TRUE if the character is in the range a..z, A..Z or 0..9, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsAlpha " link "isalpha" 0} @{" IsDigit " link "isdigit" 0}

@endnode

@node "isalpha" "Utils/StringLib/IsAlpha"

    Utils/StringLib/IsAlpha

    NAME
        IsAlpha - check IF character is IN a..z OR A..Z

    SYNOPSIS
        FUNCTION IsAlpha(c : Char) : Boolean;

    DESCRIPTION
        This function checks whether the character is an
        alphabetic character, i.e. in the range a..z or
        A..Z.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsAlpha(c) THEN
                    Write('NOT ');
                Writeln('a letter');
            END;
        END.

    INPUTS

        c     : The character to check

    RESULTS
        TRUE if the character is in a..z or A..Z, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsAlnum " link "isalnum" 0} @{" IsUpper " link "isupper" 0} @{" IsLower " link "islower" 0}

@endnode

@node "isdigit" "Utils/StringLib/IsDigit"

    Utils/StringLib/IsDigit

    NAME
        isdigit - check if character is in the range '0'..'9'

    SYNOPSIS
        FUNCTION IsDigit(c : Char) : Boolean;

    DESCRIPTION
        isdigit returns TRUE if the character is a digit character,
        i.e. it's in the range Chr(48) to Chr(57), or '0'..'9'.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsDigit(c) THEN
                    Write('NOT ');
                Writeln('a digit');
            END;
        END.

    INPUTS

        c     : The character to check

    RESULTS
        TRUE if the character is in the range '0'..'9', or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsAlnum " link "isalnum" 0} @{" IsAlpha " link "isalpha" 0}

@endnode

@node "islower" "Utils/StringLib/IsLower"

    Utils/StringLib/IsLower

    NAME
        islower - check if character is in a..z

    SYNOPSIS
        FUNCTION IsLower(c : Char) : Boolean;

    DESCRIPTION
        This function returns TRUE if the character is a lower
        case letter, i.e. a..z.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsLower(c) THEN
                    Write('NOT ');
                Writeln('a lower CASE letter');
            END;
        END.

    INPUTS

        c     : The character to check

    RESULTS
        TRUE if the character is in the range a..z, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsUpper " link "isupper" 0}

@endnode

@node "isspace" "Utils/StringLib/IsSpace"

    Utils/StringLib/IsSpace

    NAME
        isspace - check if character is 'white space'

    SYNOPSIS
        FUNCTION IsSpace(c : Char) : Boolean;

    DESCRIPTION
        This function checks whether the character is a white
        space character, which is either a space, carraige
        return, line feed, tab, or form feed.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsUpper(c) THEN
                    Write('NOT ');
                Writeln('white space');
            END;
        END.

    INPUTS

        c     : The character to check.

    RESULTS
        TRUE if the character is white space, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsAlpha " link "isalpha" 0} @{" IsDigit " link "isdigit" 0}

@endnode

@node "isupper" "Utils/StringLib/IsUpper"

    Utils/StringLib/IsUpper

    NAME
        isupper - check if character is in A..Z

    SYNOPSIS
        FUNCTION IsUpper(c : Char) : Boolean;

    DESCRIPTION
        This routine checks whether the character is an upper
        case letter.

    EXAMPLE

        PROGRAM CheckAll;
        {$I "Include:Utils/StringLib.i"}
        VAR
            c : Char;
        BEGIN
            FOR c := Chr(0) TO Chr(255) DO BEGIN
                Write('Chr(', Ord(c), ') is ');
                IF NOT IsUpper(c) THEN
                    Write('NOT ');
                Writeln('an uppercase letter');
            END;
        END.

    INPUTS

        c     : The character to check

    RESULTS
        TRUE if the character is in the range A .. Z, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" IsLower " link "islower" 0}

@endnode

@node "strcat" "Utils/StringLib/StrCat"

    Utils/StringLib/StrCat

    NAME
        strcat - concatenate two strings

    SYNOPSIS
        PROCEDURE StrCat(Str1, Str2 : String);

    DESCRIPTION
        This routine attaches Str2 on the end of Str1.  Str1 must
        have enough room for the entire resulting string, which
        will be null-terminated.

    EXAMPLE

        PROGRAM Attach;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            StrCat(Str1, Str2);
            Writeln('Str1 is now ', Str1);
            Writeln('Str1 is still ', Str2);
        END.

    INPUTS

        Str1  : The base string.  The second string will be
                attached to the end of this one, so Str1 must
                have enough space allocated for both.
        Str2  : The second string, which will be attached to the
                end of the first.  Str2 itself will not be
                affected.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" StrnCat " link "strncat" 0} @{" StrCpy  " link "strcpy" 0}

@endnode

@node "strcmp" "Utils/StringLib/StrCmp"

    Utils/StringLib/StrCmp

    NAME
        strcmp - compare two strings, returning relationship

    SYNOPSIS
        FUNCTION StrCmp(Str1, Str2 : String) : Integer;

    DESCRIPTION
        This function returns an Integer whose relationship with
        zero is the same as the relationship of Str1 to Str2.  In
        other words, if the return value is less than zero, Str1
        is less than Str2.  If the return value is equal to zero,
        Str1 is equal to Str2.  If the return value is greater
        than zero, Str1 is greater than Str2.

    EXAMPLE

        PROGRAM Comparem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            Writeln('strcmp returns ', StrCmp(Str1,Str2));
        END.

    INPUTS

        Str1,Str2 : The strings to compare

    RESULTS
        -MaxInt to -1 if Str1 < Str2, or
        0 if Str1 = Str2, or
        1 to MaxInt if Str1 > Str2

    BUGS

    SEE ALSO

        @{" StrEq    " link "streq" 0} @{" StrIeq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrnIeq  " link "strnieq" 0}
        @{" StrIcmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrnIcmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}

@endnode

@node "strcpy" "Utils/StringLib/StrCpy"

    Utils/StringLib/StrCpy

    NAME
        strcpy - copy one string into another

    SYNOPSIS
        PROCEDURE StrCpy(Dest, Source : String);

    DESCRIPTION
        This routine copies the string Source into the string
        Dest.  Both strings must already be allocated.  Note
        that this is different from "Dest := Source", which
        just copies a pointer to the same area of memory - this
        procedure actually copies all the characters over to
        a second memory area.

    EXAMPLE

        PROGRAM MakeTwo;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter a String: ');
            Readln(Str1);
            StrCpy(Str2,Str1);
            Writeln('You entered "', Str2, '"');
        END.

    INPUTS

        Dest   : The string buffer that will recieve characters
        Source : The string to be copied

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" StrnCpy " link "strncpy" 0} @{" StrCat  " link "strcat" 0} @{" StrnCat " link "strncat" 0} @{" StrDup  " link "strdup" 0}

@endnode

@node "strdup" "Utils/StringLib/StrDup"

    Utils/StringLib/StrDup

    NAME
        strdup - duplicate a string

    SYNOPSIS
        FUNCTION StrDup(Str : String) : String;

    DESCRIPTION
        This function allocates an area of memory large enough
        to hold Str, copies Str into it, and returns a pointer
        to the new string.

        Understanding this function goes a long way toward
        understanding PCQ strings in general.  Consider the
        three following statements:

                Str1 := Str2;
                StrCpy(Str1,Str2);
                Str1 := StrDup(Str2);

        They each do very different things.  The first one points
        Str1 at the same area of memory as Str2 points to - any
        changes you make to Str1 show up in Str2 as well.  The
        second statement copies the contents of Str2 into Str1 -
        Str1 must already point to an allocated area of memory
        at least as long as Str2.  The third one makes a completely
        new copy of Str2.  It works just like the following
        statements:

                Str1 := AllocString(StrLen(Str2) + 1);
                StrCpy(Str1,Str2);

    EXAMPLE

        PROGRAM CopyTwo;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
            i          : Integer;
        BEGIN
            Str1 := AllocString(256);
            Write('Enter a String: ');
            Readln(Str1);
            Str2 := StrDup(Str1);
            FOR i := 0 TO StrLen(Str1) DO
                Str1[i] := ToUpper(Str1[i]);
            Writeln('Str1 is now ', Str1);
            Writeln('Str2 is now ', Str2);
        END.

    INPUTS

        Str   : The string that will be duplicated.

    RESULTS
        A pointer to a string matching Str, or possibly Nil if
        the program could not allocate the memory and you have
        set up the appropriate HeapError.

    BUGS

    SEE ALSO

        @{" AllocString " link "allocstring" 0} @{" StrCpy      " link "strcpy" 0}

@endnode

@node "streq" "Utils/StringLib/StrEq"

    Utils/StringLib/StrEq

    NAME
        streq - compare two strings for equality

    SYNOPSIS
        FUNCTION StrEq(Str1, Str2 : String) : Boolean;

    DESCRIPTION
        The streq function compares two strings, and returns
        TRUE if they are equal and FALSE otherwise.  Of all the
        string comparison functions, it is the fastest.

    EXAMPLE

        PROGRAM Comparem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            IF StrEq(Str1,Str2) THEN
                Writeln('The strings are equal')
            ELSE
                Writeln('The strings are NOT equal');
        END.

    INPUTS

        Str1 and Str2 : The two strings to compare

    RESULTS
        TRUE if the strings are equal, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" StrIeq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrnIeq  " link "strnieq" 0} @{" StrCmp   " link "strcmp" 0}
        @{" StrIcmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrnIcmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}

@endnode

@node "stricmp" "Utils/StringLib/StriCmp"

    Utils/StringLib/StriCmp

    NAME
        stricmp - return the relationship ignoring case

    SYNOPSIS
        FUNCTION StrIcmp(Str1, Str2 : String) : Integer;

    DESCRIPTION
        This function compares two strings, ignoring any
        differences in case, and returns an Integer whose
        relationship to zero is the same as the relationship
        of Str1 to Str2.

    NOTE
        In PCQ.lib version 1.3 and above this function use
        utility.library. It can handle all characters not
        just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

        PROGRAM Comparem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            Writeln('strieq returns ', StrIeq(Str1,Str2));
        END.

    INPUTS

        Str1,Str2 : The two strings to compare

    RESULTS
        -MaxInt to -1 if Str1 < Str2, or
        0 if Str1 = Str2, or
        1 to MaxInt if Str1 > Str2

    BUGS

    SEE ALSO

        @{" StrEq    " link "streq" 0} @{" StrIeq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrnIeq  " link "strnieq" 0}
        @{" StrCmp   " link "strcmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrnIcmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}

@endnode

@node "strieq" "Utils/StringLib/StrIEq"

    Utils/StringLib/StrIEq

    NAME
        strieq - compare the strings ignoring case

    SYNOPSIS
        FUNCTION StrIeq(Str1, Str2 : String) : Boolean;

    DESCRIPTION
        This function compares the two strings, and returns TRUE
        if they are equal.  It is case insensitive, which means
        that it considers, for example, "String" and "STRING"
        equal.

        This function is much slower than streq, so it should
        only be used where you really need to ignore case.

    NOTE
        In PCQ.lib version 1.3 and above this function use
        utility.library. It can handle all characters not
        just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

        PROGRAM Comparem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            IF StrIeq(Str1,Str2) THEN
                Writeln('The strings are equal')
            ELSE
                Writeln('The strings are NOT equal');
        END.

    INPUTS

        Str1,Str2 : The strings to compare

    RESULTS
        TRUE if the strings are equal, ignoring case, or
        FALSE otherwise

    BUGS

    SEE ALSO

        @{" StrEq    " link "streq" 0} @{" StrnEq   " link "strneq" 0} @{" StrnIeq  " link "strnieq" 0} @{" StrCmp   " link "strcmp" 0}
        @{" StrIcmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrnIcmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}

@endnode

@node "strlen" "Utils/StringLib/StrLen"

    Utils/StringLib/StrLen

    NAME
        strlen - return the length of a string

    SYNOPSIS
        FUNCTION StrLen(Str : String) : Integer;

    DESCRIPTION
        This function returns the number of characters in the
        string.  Note that a string requires strlen(Str) + 1
        bytes of memory for storage, because it also has to
        store the trailing zero byte.

    EXAMPLE

        PROGRAM Countem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str : String;
        BEGIN
            Str := AllocString(256);
            Write('Enter a String: ');
            Readln(Str);
            Writeln('That String is ', StrLen(Str),
                    ' characters long.');
        END.

    INPUTS

        Str   : The string to measure

    RESULTS
        The number of characters in the string

    BUGS

    SEE ALSO

@endnode

@node "strncat" "Utils/StringLib/StrnCat"

    Utils/StringLib/StrnCat

    NAME
        strncat - concatenate at most n characters

    SYNOPSIS
        PROCEDURE StrnCat(Str1, Str2 : String; n : Short);

    DESCRIPTION
        This routine attaches Str2 on the end of Str1, but will
        attach at most n characters.  This helps you ensure that
        the resulting string does not overrun Str1's memory
        area.  The result, whether it is truncated or not, will
        be null-terminated.

    EXAMPLE

        PROGRAM Attach;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
            n          : Short;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter a String: ');
            Readln(Str1);
            Write('Enter a second String: ');
            Readln(Str2);
            Write('Enter a number: ');
            Readln(n);
            StrnCat(Str1, Str2, n);
            Writeln('Str1 is now: "', Str1, '"');
        END.

    INPUTS

        Str1  : The destination string, which will have Str2
                attached to the end of it.  It must have at
                least n characters left in its allocated space.
        Str2  : The string that will be copied on the end of
                Str1.  It is unaffected by the operation.
        n     : The maximum number of characters that can be
                copied.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" StrCat  " link "strcat" 0} @{" StrCpy  " link "strcpy" 0} @{" StrnCpy " link "strncpy" 0}

@endnode

@node "strncmp" "Utils/StringLib/StrnCmp"

    Utils/StringLib/StrnCmp

    NAME
        strncmp - return relationship of first n characters

    SYNOPSIS
        FUNCTION StrnCmp(Str1,Str2 : String; n : Short) : Integer;

    DESCRIPTION
        This function compares the first n characters in Str1 and
        Str2, and returns an Integer that is greater than zero if
        the first n characters of Str1 are greater alphabetically
        than those of Str2, zero if they are equal, or less than
        zero if the first n characters of Str1 are less than those
        of Str2.

    EXAMPLE

        PROGRAM Comparem;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
            n          : Integer;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter the first String: ');
            Readln(Str1);
            Write('Enter the second String: ');
            Readln(Str2);
            Write('Enter a the number TO compare: ');
            Readln(n);
            Writeln('strncmp returns ', StrnCmp(Str1,Str2));
        END.

    INPUTS

        Str1, Str2 : The strings to compare
        n          : The number of characters to compare at most

    RESULTS
        -MaxInt to -1 if the first n characters of Str1 are less
        than those of Str2, or
        0 if they are equal, or
        1 to MaxInt if they are greater.

    BUGS

    SEE ALSO

        @{" StrEq    " link "streq" 0} @{" StrIeq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrnIeq  " link "strnieq" 0}
        @{" StrCmp   " link "strcmp" 0} @{" StrIcmp  " link "stricmp" 0} @{" StrnIcmp " link "strnicmp" 0}@{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}

@endnode

@node "strncpy" "Utils/StringLib/StrnCpy"

    Utils/StringLib/StrnCpy

    NAME
        strncpy - copy at most n characters from Source to Dest

    SYNOPSIS
        PROCEDURE StrnCpy(Dest, Source : String; n : Short);

    DESCRIPTION
        This routine copies Source into Dest, but if there are
        more than n characters in Source, Dest is truncated to
        n characters.  Dest will always be null-terminated.

    EXAMPLE

        PROGRAM CopyIt;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Str1, Str2 : String;
            n          : Integer;
        BEGIN
            Str1 := AllocString(256);
            Str2 := AllocString(256);
            Write('Enter a String: ');
            Readln(Str1);
            Write('Enter the number OF characters TO copy: ');
            Readln(n);
            StrnCpy(Str2,Str1,n);
            Writeln('Result is ', Str2);
        END.

    INPUTS

        Dest   : The string buffer to copy into.  It must already
                 be allocated.
        Source : The string to be copied.
        n      : The maximum number of characters to copy.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" StrCpy  " link "strcpy" 0} @{" StrCat  " link "strcat" 0} @{" StrnCat " link "strncat" 0}

@endnode

@NODE "strneq" "utils/stringlib/strneq"

    Utils/StringLib/StrnEq

    NAME
    strneq - check whether string prefixes are equal

    SYNOPSIS
    Function strneq(Str1, Str2 : String; n : Short) : Boolean;

    DESCRIPTION
    This function determines whether the two strings are
    equal for the first n characters at most.  If either
    string is less than n characters long, the function
    will return TRUE if both strings are equal and the
    same length.

    EXAMPLE

    Program Comparem;
    {$I "Include:Utils/StringLib.i"}
    var
        Str1, Str2 : String;
        n          : Integer;
    begin
        Str1 := AllocString(256);
        Str2 := AllocString(256);
        Write('Enter the first string: ');
        ReadLn(Str1);
        Write('Enter the second string: ');
        ReadLn(Str2);
        Write('Enter a length: ');
        Readln(n);
        if strneq(Str1,Str2,n) then
        Writeln('The strings are equal up to ',n)
        else
        Writeln('The strings are not equal up to ',n);
    end.

    INPUTS

    Str1,Str2 : The strings to compare
    n         : The number of characters to compare at most

    RESULTS
    TRUE if the first n characters of the strings are equal,
         or if the strings are equal and less than n characters
         length, or
    FALSE otherwise

    BUGS

    SEE ALSO

    @{" StrEq    " link "streq" 0} @{" StriEq   " link "strieq" 0} @{" StrniEq  " link "strnieq" 0} @{" StrCmp   " link "strcmp" 0}
    @{" StriCmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrniCmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}


@ENDNODE

@NODE "strnicmp" "Utils/StringLib/StrniCmp"

    Utils/StringLib/StrniCmp

    NAME
    strnicmp - return alphabetical relationship ignoring case

    SYNOPSIS
    Function strnicmp(Str1, Str2 : String; n : Short) : Integer;

    DESCRIPTION
    This function compares the first n characters of two
    strings, ignoring case, and returns an Integer indicating
    their relative alphabetical position.  If the returned
    value is less than zero, then the prefix of Str1 is less
    than that of Str2.  If it is zero, the prefixes are equal.
    If it is greater than zero, the prefix of Str1 is greater
    than that of Str2.

    NOTE
    In PCQ.lib version 1.3 and above this function use
    utility.library. It can handle all characters not
    just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

    Program Comparem;
    {$I "Include:Utils/StringLib.i"}
    var
        Str1, Str2 : String;
        n          : Integer;
    begin
        Str1 := AllocString(256);
        Str2 := AllocString(256);
        Write('Enter the first string: ');
        ReadLn(Str1);
        Write('Enter the second string: ');
        ReadLn(Str2);
        Write('Enter the number of characters to compare: ');
        Readln(n);
        Writeln('strnicmp returns ', strnicmp(Str1,Str2,n));
    end.

    INPUTS

    Str1,Str2 : The string to be compared.
    n         : The maximum number of characters to compare.

    RESULTS
    -MaxInt to -1 if the first n characters of Str1 are less
    than those of Str2, ignoring case, or
    0 if the prefixes are equal, or
    1 to MaxInt if the prefix of Str1 is greater than that
    of Str2.

    BUGS

    SEE ALSO

    @{" StrEq    " link "streq" 0} @{" StriEq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrniEq  " link "strnieq" 0}
    @{" StrCmp   " link "strcmp" 0} @{" StriCmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}


@ENDNODE

@NODE "strnieq" "Utils/StringLib/StrniEq"

    Utils/StringLib/StrniEq

    NAME
    strnieq - Compares up to n characters ignoring case

    SYNOPSIS
    Function strnieq(Str1,Str2 : String; n : Short) : Boolean;

    DESCRIPTION
    This function compares at most n characters of the two
    strings ignoring case.

    NOTE
    In PCQ.lib version 1.3 and above this function use
    utility.library. It can handle all characters not
    just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

    Program Comparem;
    {$I "Include:Utils/StringLib.i"}
    var
        Str1, Str2 : String;
        n          : Integer;
    begin
        Str1 := AllocString(256);
        Str2 := AllocString(256);
        Write('Enter the first string: ');
        ReadLn(Str1);
        Write('Enter the second string: ');
        ReadLn(Str2);
        Write('Enter the number of characters to compare: ');
        ReadLn(n);
        if strnieq(Str1,Str2,n) then
        Writeln('The strings are equal')
        else
        Writeln('The strings are not equal');
    end.

    INPUTS

    Str1,Str2 : The two strings to compare
    n         : The maximum number of characters to compare

    RESULTS
    TRUE if the first n characters are equal, ignoring case,
         or if the strings are equal and both less than n
         characters long, or
    FALSE otherwise

    BUGS

    SEE ALSO

    @{" StrEq    " link "streq" 0} @{" StriEq   " link "strieq" 0} @{" StrnEq   " link "strneq" 0} @{" StrCmp   " link "strcmp" 0}
    @{" StriCmp  " link "stricmp" 0} @{" StrnCmp  " link "strncmp" 0} @{" StrniCmp " link "strnicmp" 0} @{" SameName " link "PCQ:Hyper/utils/samename.guide/main" 0}


@ENDNODE

@NODE Aguide121 "Utils/StringLib/strpos"


    NAME
    strpos - find the first occurence of a character

    SYNOPSIS
    Function strpos(Str : String; Ch : Char) : Integer;

    DESCRIPTION
    This routine search for the first (leftmost) occurence
    of the character Ch in the string Str.  If it finds it,
    it returns the index, from 0 to strlen(Str).  If the
    character does not occur in the string, it returns -1.

    EXAMPLE

    Program FindChar;
    {$I "Include:Utils/StringLib.i"}
    var
        Str : String;
        i   : Integer;
    begin
        Str := AllocString(256);
        Write('Enter a string: ');
        Readln(Str);
        i := strpos(Str, 'e');
        if i = -1 then
        Writeln('The letter "e" does not occur')
        else
        Writeln('The letter "e" occurs in position ', i);
    end.

    INPUTS

    Str   : The string to search through - it will not be
        modified.
    Ch    : The character to search for.

    RESULTS
    -1 if the character could not be found, or
    the index of the leftmost occurence otherwise.

    BUGS

    SEE ALSO
    strrpos

@ENDNODE
@NODE Aguide122 "Utils/StringLib/strrpos"


    NAME
    strrpos - find the rightmost occurence of a character

    SYNOPSIS
    Function strrpos(Str : String; Ch : Char) : Integer;

    DESCRIPTION
    This function returns the index of the rightmost
    occurrence of the character Ch in the string Str.  If
    the character does not occur in the string, the
    function returns -1.

    EXAMPLE

    Program Rightmost;
    {$I "Include:Utils/StringLib.i"}
    var
        Str : String;
        Ch  : Char;
        Pos : Integer;
    begin
        Str := AllocString(256);
        Write('Enter a string: ');
        Readln(Str);
        Write('Enter a character: ');
        Readln(Ch);
        Pos := strrpos(Str,Ch);
        if Pos = -1 then
        Writeln('"', Ch, '" does not occur in "', Str, '"')
        else
        Writeln(Ch, ' last occurs at position ', Pos);
    end.

    INPUTS

    Str   : The string to be examined.  It will not be modified.
    Ch    : The character for which to search.

    RESULTS
    -1 if the character does not occur in the string, or
    the index of the rightmost occurence.

    BUGS

    SEE ALSO
    strpos


@ENDNODE                                                               

@node "tolower" "Utils/StringLib/ToLower"

    Utils/StringLib/ToLower

    NAME
        tolower - convert an upper case character to lower case

    SYNOPSIS
        FUNCTION ToLower(c : Char) : Char;

    DESCRIPTION
        This function converts characters in the range A..Z to
        their corresponding lower case characters in the range
        a..z.  If the character is not an upper case letter,
        no action is taken.

    NOTE
        In PCQ.lib version 1.3 and above this function use
        utility.library. It can handle all characters not
        just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

        PROGRAM LowerLine;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Line : String;
            i    : Integer;
        BEGIN
            Line := AllocString(256);
            Write('Enter a line: ');
            Readln(Line);
            FOR i := 0 TO StrLen(Line) DO
                Line[i] := ToLower(Line[i]);
            Writeln('IN lower CASE, that is: ', Line);
        END.

    INPUTS

        c     : The character to convert

    RESULTS
        If the input character is in the range A..Z, this
        function returns its corresponding lower case character.
        Otherwise, it returns the character unchanged.

    BUGS

    SEE ALSO

        @{" ToUpper " link "toupper" 0} @{" IsLower " link "islower" 0}

@endnode

@node "toupper" "Utils/StringLib/ToUpper"

    Utils/StringLib/ToUpper

    NAME
        toupper - convert a character to uppercase

    SYNOPSIS
        FUNCTION ToUpper(c : Char) : Char;

    DESCRIPTION
        This function converts a character in the range a..z to
        its upper case equivalent.  If the character is outside
        of that range, it returns the character unchanged.

    NOTE
        In PCQ.lib version 1.3 and above this function use
        utility.library. It can handle all characters not
        just a..z. If you are using WB2.1+ it will use locale.

    EXAMPLE

        PROGRAM UpperLine;
        {$I "Include:Utils/StringLib.i"}
        VAR
            Line : String;
            i    : Integer;
        BEGIN
            Line := AllocString(256);
            Write('Enter a line: ');
            Readln(Line);
            FOR i := 0 TO StrLen(Line) DO
                Line[i] := ToUpper(Line[i]);
            Writeln('IN upper CASE, that is: ', Line);
        END.

    INPUTS

        c     : The character to convert

    RESULTS
        If c is in the range a..z, toupper() returns the
        corresponding character in the range A..Z.  Otherwise,
        it returns the character unchanged.

    BUGS

    SEE ALSO

        @{" ToLower " link "tolower" 0} @{" IsUpper " link "isupper" 0}

@endnode



