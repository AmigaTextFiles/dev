@database Contents
@master PCQ:Hyper/utils/doublebuffer.guide
@$VER: 1.0
@author "Nils Sjoholm"
@(c) "@ Nils Sjoholm"

@node "Main" "Utils/DoubleBuffer"




                          Utils/DoubleBuffer

                         @{" CloseDoubleBuffer " link "closedoublebuffer" 0}
                         @{" OpenDoubleBuffer  " link "opendoublebuffer" 0}
                         @{" SwapBuffers       " link "swapbuffers" 0}













@endnode

@node "closedoublebuffer" "Utils/DoubleBuffer/CloseDoubleBuffer"

    Utils/DoubleBuffer/CloseDoubleBuffer

    NAME
        CloseDoubleBuffer - closes a double-buffered window and screen

    SYNOPSIS
        PROCEDURE CloseDoubleBuffer(w : WindowPtr);

    DESCRIPTION
        This routine frees up all the resources allocated by a call
        to OpenDoubleBuffer.  It closes the Screen and the Window,
        and frees the memory used for the extra buffer.

        You should not call this routine on normal windows, and you
        should not use the normal CloseWindow and CloseScreen calls
        on Windows and Screens created with OpenDoubleBuffer.

    EXAMPLE
        See
           @{" Examples/3d.p " alink "PCQ:Examples/3d.p/main" 0}

    INPUTS

        w     : A pointer to a Window opened with a call to
                OpenDoubleBuffer.

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" OpenDoubleBuffer " link "opendoublebuffer" 0} @{" SwapBuffers      " link "swapbuffers" 0}

@endnode

@node "opendoublebuffer" "Utils/DoubleBuffer/OpenDoubleBuffer"

    Utils/DoubleBuffer/OpenDoubleBuffer

    NAME
        OpenDoubleBuffer - create a double buffered screen and window

    SYNOPSIS
        FUNCTION OpenDoubleBuffer(ns : NewScreenPtr) : WindowPtr;

    DESCRIPTION
        OpenDoubleBuffer creates a screen according to the NewScreen
        passed to it, then opens a borderless backdrop window on it.
        It then allocates extra BitMap memory, and sets the Window's
        BitMap to point to this second buffer.  When the function
        returns, you can pull the RastPortPtr from the Window
        structure, and draw into that same RastPort for the entire
        program.  When you want to display the RastPort, just call
        SwapBuffers.

        Since this routine creates Screens and Windows that the
        system doesn't expect, you should try to avoid having the
        system draw into them.  This means that you should not add
        menus or Window imagery - you should only use RastPort-level
        graphics.library calls.

        Windows and Screens opened with OpenDoubleBuffer should
        only be closed with CloseDoubleBuffer.

    EXAMPLE
        See
           @{" Examples/3d.p " alink "PCQ:Examples/3d.p/main" 0}

    INPUTS

        ns    : A pointer to a NewScreen structure.

    RESULTS
        A valid WindowPtr, or Nil if something went wrong.

    BUGS

    SEE ALSO

        @{" CloseDoubleBuffer " link "closedoublebuffer" 0} @{" SwapBuffers       " link "swapbuffers" 0}

@endnode

@node "swapbuffers" "Utils/DoubleBuffer/SwapBuffers"


    Utils/DoubleBuffer/SwapBuffers

    NAME
        SwapBuffers - swap the drawing and displaying BitMaps

    SYNOPSIS
        PROCEDURE SwapBuffers(w : WindowPtr);

    DESCRIPTION
        When you have drawn something into a Window opened using
        OpenDoubleBuffer, you need to call SwapBuffers in order
        to display it.  SwapBuffers points the Screen's BitMap
        at the BitMap into which you have been drawing, and points
        the RastPort's at the BitMap that was being displayed.  It
        then calls ScrollVPort to update the graphics system.

    EXAMPLE
        See
           @{" Examples/3d.p " alink "PCQ:Examples/3d.p/main" 0}

    INPUTS

        w     : A pointer to a Window opened with OpenDoubleBuffer

    RESULTS
        None

    BUGS

    SEE ALSO

        @{" OpenDoubleBuffer  " link "opendoublebuffer" 0} @{" CloseDoubleBuffer " link "closedoublebuffer" 0}

@endnode




