# ###############################################################
#
#  MakeFile for the standard prelude & related .p files. 
# ###############################################################
#
PARSE  = AmigaTalk:c/Parse -hex
#
OUTDIR = AmigaTalk:Prelude/
#
INDIR  = AmigaTalk:General/
#
NPDIR  = AmigaTalk:General/NewParser/
#
JN     = C:Join
#
PFILES = $(OUTDIR)Class.p $(OUTDIR)Object.p $(OUTDIR)String.p\
 $(OUTDIR)LArray.p $(OUTDIR)Nil.p $(OUTDIR)Array.p $(OUTDIR)Boolean.p\
 $(OUTDIR)True.p $(OUTDIR)False.p $(OUTDIR)Block.p $(OUTDIR)Symbol.p\
 $(OUTDIR)Magnitude.p $(OUTDIR)Number.p $(OUTDIR)Integer.p $(OUTDIR)Char.p\
 $(OUTDIR)Float.p $(OUTDIR)Radian.p $(OUTDIR)Point.p $(OUTDIR)Random.p\
 $(OUTDIR)Collection.p $(OUTDIR)Bag.p $(OUTDIR)Set.p $(OUTDIR)KCollection.p\
 $(OUTDIR)Dictionary.p $(OUTDIR)SCollection.p $(OUTDIR)Interval.p\
 $(OUTDIR)Form.p $(OUTDIR)Pen.p $(OUTDIR)List.p $(OUTDIR)ACollection.p\
 $(OUTDIR)File.p $(OUTDIR)ByteArray.p $(OUTDIR)Semaphore.p\
 $(OUTDIR)Process.p $(OUTDIR)AmigaTalk.p $(OUTDIR)Link.p $(OUTDIR)LongInteger.p\
 $(OUTDIR)AspectAdaptor.p $(OUTDIR)BlockValue.p $(OUTDIR)ComputedValue.p\
 $(OUTDIR)DependencyTransformer.p $(OUTDIR)IndexedAdaptor.p $(OUTDIR)Model.p\
 $(OUTDIR)PluggableAdaptor.p $(OUTDIR)ProtocolAdaptor.p $(OUTDIR)SlotAdaptor.p\
 $(OUTDIR)ValueHolder.p $(OUTDIR)ValueModel.p $(OUTDIR)DependentsCollection.p \
 $(OUTDIR)BufferedValueHolder.p
#
PARSEFILES = $(OUTDIR)Parse.p $(OUTDIR)ParseNodes.p $(OUTDIR)List.p\
 $(OUTDIR)Encoder.p $(OUTDIR)Method.p 
#
# ------ Now for the Rules: -------------------------------------
#
#$(OUTDIR)larray.p
#
standard: $(PFILES) 
  $(JN) $(OUTDIR)acollection.p $(OUTDIR)array.p $(OUTDIR)class.p $(OUTDIR)object.p $(OUTDIR)string.p $(OUTDIR)nil.p AS RAM:s1
  $(JN) $(OUTDIR)boolean.p $(OUTDIR)true.p $(OUTDIR)false.p $(OUTDIR)block.p $(OUTDIR)symbol.p $(OUTDIR)magnitude.p AS RAM:s2
  $(JN) RAM:s1 RAM:s2 AS RAM:s7 
  $(JN) RAM:s7 $(OUTDIR)number.p $(OUTDIR)integer.p $(OUTDIR)char.p $(OUTDIR)float.p  AS RAM:s3
  $(JN) RAM:s3 $(OUTDIR)radian.p $(OUTDIR)point.p $(OUTDIR)random.p $(OUTDIR)collection.p $(OUTDIR)bag.p $(OUTDIR)set.p AS RAM:s4
  $(JN) $(OUTDIR)kcollection.p $(OUTDIR)dictionary.p $(OUTDIR)scollection.p AS RAM:s5
  $(JN) RAM:s4 RAM:s5 $(OUTDIR)interval.p $(OUTDIR)form.p $(OUTDIR)pen.p $(OUTDIR)list.p AS RAM:s6
  $(JN) $(OUTDIR)file.p $(OUTDIR)bytearray.p $(OUTDIR)semaphore.p AS RAM:s7
  $(JN) RAM:s6 RAM:s7 $(OUTDIR)process.p $(OUTDIR)AmigaTalk.p $(OUTDIR)Link.p $(OUTDIR)LongInteger.p AS RAM:s8
  $(JN) RAM:s8 $(OUTDIR)AspectAdaptor.p $(OUTDIR)BlockValue.p $(OUTDIR)ComputedValue.p AS RAM:s3
  $(JN) $(OUTDIR)DependencyTransformer.p $(OUTDIR)IndexedAdaptor.p $(OUTDIR)Model.p AS RAM:s4
  $(JN) $(OUTDIR)PluggableAdaptor.p $(OUTDIR)ProtocolAdaptor.p $(OUTDIR)SlotAdaptor.p AS RAM:s5
  $(JN) $(OUTDIR)DependentsCollection.p $(OUTDIR)ValueHolder.p $(OUTDIR)BufferedValueHolder.p $(OUTDIR)ValueModel.p AS RAM:s6
  $(JN) RAM:s3 RAM:s4 RAM:s5 RAM:s6 AS $(OUTDIR)standard
#
#  $(JN) $(OUTDIR)Parse.p $(OUTDIR)ParseNodes.p $(OUTDIR)Encoder.p $(OUTDIR)Method.p AS RAM:s9 
#  $(JN) RAM:s8 RAM:s9 AS RAM:final 
#
#  COPY RAM:s8 TO $(OUTDIR)standard
  DELETE RAM:s1 RAM:s2 RAM:s3 RAM:s4 RAM:s5 RAM:s6 RAM:s7 RAM:s8 RAM:final
#
# DELETE RAM:s9
#
newParser: $(PARSEFILES) 
  $(JN) $(OUTDIR)Parse.p $(OUTDIR)ParseNodes.p $(OUTDIR)List.p $(OUTDIR)Encoder.p $(OUTDIR)Method.p AS RAM:s1
  COPY RAM:s1 TO $(OUTDIR)newParser
  DELETE RAM:s1
#
# ------ Model & Subclasses Rules: ------------------------------
#
$(OUTDIR)AspectAdaptor.p : $(INDIR)AspectAdaptor.st
  $(PARSE)  $(INDIR)AspectAdaptor.st >$(OUTDIR)AspectAdaptor.p
#
$(OUTDIR)BlockValue.p  : $(INDIR)BlockValue.st
  $(PARSE)  $(INDIR)BlockValue.st >$(OUTDIR)BlockValue.p
#
$(OUTDIR)ComputedValue.p : $(INDIR)ComputedValue.st
  $(PARSE)  $(INDIR)ComputedValue.st >$(OUTDIR)ComputedValue.p
#
$(OUTDIR)DependencyTransformer.p  : $(INDIR)DependencyTransformer.st
  $(PARSE)  $(INDIR)DependencyTransformer.st >$(OUTDIR)DependencyTransformer.p
#
$(OUTDIR)DependentsCollection.p  : $(INDIR)DependentsCollection.st
  $(PARSE)  $(INDIR)DependentsCollection.st >$(OUTDIR)DependentsCollection.p
#
$(OUTDIR)IndexedAdaptor.p  : $(INDIR)IndexedAdaptor.st
  $(PARSE)  $(INDIR)IndexedAdaptor.st >$(OUTDIR)IndexedAdaptor.p
#
$(OUTDIR)Model.p  : $(INDIR)Model.st
  $(PARSE)  $(INDIR)Model.st >$(OUTDIR)Model.p
#
$(OUTDIR)PluggableAdaptor.p  : $(INDIR)PluggableAdaptor.st
  $(PARSE)  $(INDIR)PluggableAdaptor.st >$(OUTDIR)PluggableAdaptor.p
#
$(OUTDIR)ProtocolAdaptor.p  : $(INDIR)ProtocolAdaptor.st
  $(PARSE)  $(INDIR)ProtocolAdaptor.st >$(OUTDIR)ProtocolAdaptor.p
#
$(OUTDIR)SlotAdaptor.p : $(INDIR)SlotAdaptor.st
  $(PARSE)  $(INDIR)SlotAdaptor.st >$(OUTDIR)SlotAdaptor.p
#
$(OUTDIR)ValueHolder.p  : $(INDIR)ValueHolder.st
  $(PARSE)  $(INDIR)ValueHolder.st >$(OUTDIR)ValueHolder.p
#
$(OUTDIR)BufferedValueHolder.p  : $(INDIR)BufferedValueHolder.st
  $(PARSE)  $(INDIR)BufferedValueHolder.st >$(OUTDIR)BufferedValueHolder.p
#
$(OUTDIR)ValueModel.p : $(INDIR)ValueModel.st
  $(PARSE)  $(INDIR)ValueModel.st >$(OUTDIR)ValueModel.p
#
$(OUTDIR)Controller.p : $(INDIR)Controller.st
  $(PARSE)  $(INDIR)Controller.st >$(OUTDIR)Controller.p
#
$(OUTDIR)GUIController.p : $(INDIR)GUIController.st
  $(PARSE)  $(INDIR)GUIController.st >$(OUTDIR)GUIController.p
#
#
# ------ Parser Rules: ------------------------------------------
#
$(OUTDIR)Encoder.p: $(NPDIR)Encoder.st
  $(PARSE)  $(NPDIR)Encoder.st    >$(NPDIR)Encoder.p
#
$(OUTDIR)Parse.p: $(NPDIR)Parse.st
  $(PARSE)  $(NPDIR)Parse.st      >$(NPDIR)Parse.p
#
$(OUTDIR)ParseNodes.p: $(NPDIR)ParseNodes.st
  $(PARSE)  $(NPDIR)ParseNodes.st >$(NPDIR)ParseNodes.p
#
$(OUTDIR)Method.p: $(NPDIR)Method.st
  $(PARSE)  $(NPDIR)Method.st     >$(NPDIR)Method.p
#
# ------ Standard class Rules: ----------------------------------------
#
$(OUTDIR)Link.p: $(INDIR)Link.st
  $(PARSE)  $(INDIR)Link.st >$(OUTDIR)Link.p
#
$(OUTDIR)LongInteger.p: $(INDIR)LongInteger.st
  $(PARSE)  $(INDIR)LongInteger.st >$(OUTDIR)LongInteger.p
#
$(OUTDIR)Nil.p: $(INDIR)UndefinedObject.st
  $(PARSE)  $(INDIR)UndefinedObject.st >$(OUTDIR)nil.p
#
$(OUTDIR)KCollection.p: $(INDIR)KeyedCollection.st
  $(PARSE)  $(INDIR)KeyedCollection.st >$(OUTDIR)KCollection.p
#
$(OUTDIR)SCollection.p: $(INDIR)SequenceableCollection.st
  $(PARSE)  $(INDIR)SequenceableCollection.st >$(OUTDIR)SCollection.p
#
$(OUTDIR)ACollection.p: $(INDIR)ArrayedCollection.st
  $(PARSE)  $(INDIR)ArrayedCollection.st >$(OUTDIR)ACollection.p
#
$(OUTDIR)Interval.p: $(INDIR)Interval.st
  $(PARSE)  $(INDIR)Interval.st   >$(OUTDIR)Interval.p
#
$(OUTDIR)Pen.p: $(INDIR)Pen.st
  $(PARSE)  $(INDIR)Pen.st        >$(OUTDIR)Pen.p
#
$(OUTDIR)List.p: $(INDIR)List.st
  $(PARSE)  $(INDIR)List.st       >$(OUTDIR)List.p
#
$(OUTDIR)ByteArray.p: $(INDIR)ByteArray.st
  $(PARSE)  $(INDIR)ByteArray.st  >$(OUTDIR)ByteArray.p
#
$(OUTDIR)Semaphore.p: $(INDIR)Semaphore.st
  $(PARSE)  $(INDIR)Semaphore.st  >$(OUTDIR)Semaphore.p
#
$(OUTDIR)Class.p: $(INDIR)Class.st
  $(PARSE)  $(INDIR)Class.st      >$(OUTDIR)Class.p
#
$(OUTDIR)Object.p: $(INDIR)Object.st
  $(PARSE)  $(INDIR)Object.st     >$(OUTDIR)Object.p
#
$(OUTDIR)String.p: $(INDIR)String.st
  $(PARSE)  $(INDIR)String.st     >$(OUTDIR)String.p
#
$(OUTDIR)LArray.p: $(INDIR)LArray.st
  $(PARSE)  $(INDIR)LArray.st     >$(OUTDIR)LArray.p
#
$(OUTDIR)Array.p: $(INDIR)Array.st
  $(PARSE)  $(INDIR)Array.st      >$(OUTDIR)Array.p
#
$(OUTDIR)Boolean.p: $(INDIR)Boolean.st
  $(PARSE)  $(INDIR)Boolean.st    >$(OUTDIR)Boolean.p
#
$(OUTDIR)True.p: $(INDIR)True.st
  $(PARSE)  $(INDIR)True.st       >$(OUTDIR)True.p
#
$(OUTDIR)False.p: $(INDIR)False.st
  $(PARSE)  $(INDIR)False.st      >$(OUTDIR)False.p
#
$(OUTDIR)Block.p: $(INDIR)Block.st
  $(PARSE)  $(INDIR)Block.st      >$(OUTDIR)Block.p
#
$(OUTDIR)Symbol.p: $(INDIR)Symbol.st
  $(PARSE)  $(INDIR)Symbol.st     >$(OUTDIR)Symbol.p
#
$(OUTDIR)Magnitude.p: $(INDIR)Magnitude.st
  $(PARSE)  $(INDIR)Magnitude.st  >$(OUTDIR)Magnitude.p
#
$(OUTDIR)Number.p: $(INDIR)Number.st
  $(PARSE)  $(INDIR)Number.st     >$(OUTDIR)Number.p
#
$(OUTDIR)Integer.p: $(INDIR)Integer.st
  $(PARSE)  $(INDIR)Integer.st    >$(OUTDIR)Integer.p
#
$(OUTDIR)Char.p: $(INDIR)Char.st
  $(PARSE)  $(INDIR)Char.st       >$(OUTDIR)Char.p
#
$(OUTDIR)Float.p: $(INDIR)Float.st
  $(PARSE)  $(INDIR)Float.st      >$(OUTDIR)Float.p
#
$(OUTDIR)Radian.p: $(INDIR)Radian.st
  $(PARSE)  $(INDIR)Radian.st     >$(OUTDIR)Radian.p
#
$(OUTDIR)Point.p: $(INDIR)Point.st
  $(PARSE)  $(INDIR)Point.st      >$(OUTDIR)Point.p
#
$(OUTDIR)Random.p: $(INDIR)Random.st
  $(PARSE)  $(INDIR)Random.st     >$(OUTDIR)Random.p
#
$(OUTDIR)Collection.p: $(INDIR)Collection.st
  $(PARSE)  $(INDIR)Collection.st >$(OUTDIR)Collection.p
#
$(OUTDIR)Bag.p: $(INDIR)Bag.st
  $(PARSE)  $(INDIR)Bag.st        >$(OUTDIR)Bag.p
#
$(OUTDIR)Set.p: $(INDIR)Set.st
  $(PARSE)  $(INDIR)Set.st        >$(OUTDIR)Set.p
#
$(OUTDIR)Dictionary.p: $(INDIR)Dictionary.st
  $(PARSE)  $(INDIR)Dictionary.st >$(OUTDIR)Dictionary.p
#
$(OUTDIR)Form.p: $(INDIR)Form.st
  $(PARSE)  $(INDIR)Form.st       >$(OUTDIR)Form.p
#
$(OUTDIR)File.p: $(INDIR)File.st
  $(PARSE)  $(INDIR)File.st       >$(OUTDIR)File.p
#
$(OUTDIR)Process.p: $(INDIR)Process.st
  $(PARSE)  $(INDIR)Process.st    >$(OUTDIR)Process.p
#
$(OUTDIR)AmigaTalk.p: $(INDIR)AmigaTalk.st
  $(PARSE)  $(INDIR)AmigaTalk.st  >$(OUTDIR)AmigaTalk.p
#
#
# ------ Default for the rest of the rules: ---------------------
#
#.st.p:
#  $(PARSE) $(INDIR)$>.st >$@  # Why don't this work all the time??
#
