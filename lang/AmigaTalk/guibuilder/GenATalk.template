"****h* $ProjectFileName [$ProjectVersion] ************************ "
"*"
"* NAME"
"*    $ProjectFileName"
"*"
"* DESCRIPTION"
"*    $ProjectNameGUI Class is a GUI for...."
"*"
"* HISTORY"
"*    $DateToday - Created this file."
"*"
"* COPYRIGHT"
"*    $ProjectFileName $DateToday(C) by $ProjectAuthorName"
"*"
"* NOTES"
"*    This Template is NOT complete or Tested!!                                 "
"*    $VER: $ProjectFileName $ProjectVersion ($DateToday) by $ProjectAuthorName "
"************************************************************************"

Class $ProjectNameGUI :Window  " Controller "
!
  intuition  screen    viObj       guiWindow 
  scrFont    fontAttr  wTags       ctrlDictionary
  gadgetList menuStrip firstGadget itexts bboxes 
!
[
   startUp
      self controlInitialize.
      self controlLoop.
      self controlTerminate
|
   terminateAndInitializeAround: aBlock
      self controlTerminate.

      aBlock value.

      self controlInitialize
|
   controlLoop ! notDone userData !

      " Sent by startUp as part of the standard control sequence. 
      * As long as true is returned, the loop continues. 
      * When false is returned, the loop ends:
      "
      notDone <- true.
      
      [notDone = true]
        whileTrue: [ " userData is an Array Object with at least 2 elements: "
                     userData <- self waitForUserData.

                     notDone  <- self decode: userData.
                   ].

      ^ false  " Inform everyone that we are done "
|
   controlTerminate   ! ele controlObj !
      
      " User did something to exit the Controller Loop.
      * Provide a place in the standard control sequence for terminating the 
      * receiver (taking into account the current state of its model and view).
      "
      
      ele <- ctrlDictionary first.
      
      [ele notNil]
         whileTrue: [ controlObj <- ctrlDictionary at: ele.
                      
                      controlObj dispose.
                                             
                      ctrlDictionary removeKey: ele ifAbsent: [].

                      ele <- ctrlDictionary next. 
                    ].
      self close.
      
      ^ nil
|
   tieInto: thisView
      guiWindow <- thisView window
|
   addControl: controlObject named: ctrlID
      ctrlDictionary at: ctrlID put: controlObject.

      controlObject registerTo: guiWindow
|
   addHotKey: keyValue to: controlObject
      " Upper-case & lower-case keys are equivalent here: " 
      <primitive 239 3 12 keyValue controlObject>
|
   addMenuSelection: menuObject named: menuID
      ctrlDictionary at: menuID put: menuObject

      menuObject registerTo: guiWindow
|
   addMenuHotKey: keyValue to: menuObject
      <primitive 239 1 12 keyValue menuObject>
|
   waitForUserData
      " userData is an Array of three elements, first is the 
      * Gadget (controlObject) value, second is the userData 
      * (a #methodSymbol for this Class), third is the hotKey value.
      *
      * If the User selected a menu item, the first element is
      * the menuitem userData, second is the menuitem Label, 
      * third is Command Key equivalent (a through z, 0 through 9, 
      * or A through Z only [for now!]) 
      "
      ^ <primitive 239 3 9 guiWindow>
|
   closeGUIWindow
      self close.
      
      ^ false
|
   rawKey: keyCode
      ^ true
|
   vanillaKey: keyCode
      ^ true
|
   newSizeWindow
      ^ true
|
   changeWindow
      ^ true
|
   decode: controlData ! ctrlValue ctrlID hotKey !
      ctrlValue <- controlData at: 1. " Usuallly a Symbol  "
      ctrlID    <- controlData at: 2. " String or Integer  "
      hotKey    <- controlData at: 3. " raw or vanilla key "
      
      (ctrlValue = #closeWindow)
         ifTrue: [ ^ self closeGUIWindow ].
         
      (ctrlValue = #rawKey)
         ifTrue: [ ^ self rawKey: hotKey ].
                  
      (ctrlValue = #vanillaKey)
         ifTrue: [ ^ self vanillaKey: hotKey ].
                  
      (ctrlValue = #newSizeWindow)
         ifTrue: [ ^ self newSizeWindow ].
                  
      (ctrlValue = #changeWindow)
         ifTrue: [ ^ self changeWindow ].
                  
      ^ (ctrlDictionary at: ctrlID) perform: ctrlValue
|
   controlInitialize
      " super initialize. "

      intuition <- Intuition new.
      
      self setupIntuiTexts.
      self setupBevelBoxes.
             
      $SetupScreenCode

      firstGadget <- self setupGadgets.

      self setupMenuStrip.
       
      $OpenWindowCode
      
      self renderIntuiTexts.
      
      self renderBevelBoxes.
|
   setupIntuiTexts
      $SetupIntuiTexts
|
   setupBevelBoxes
      $SetupBevelBoxes
|
   setupGadgets ! gadget !

      $SetupGadgets
      
      ^ gadgetList
|
   setupMenuStrip
      $SetupMenus ==>>

      menuStrip <- MenuStrip new: $MenuCount.
      
      ^ menuStrip 
|
$RenderIntuiTexts
|
$RenderBevelBoxes
|
   close
      " CloseWindowCode: "

      guiWindow close.

      $DisposeGadgets
      $DisposeMenus
      $DisposeITexts
      $DisposeBBoxes
            
      " CloseScreenCode: "
      
      screen disposeVisualInfo: viObj.
      
      screen  close.
      scrFont close.
]
