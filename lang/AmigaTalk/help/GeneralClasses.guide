@DataBase "GeneralClasses.guide"

@REMARK "$VER: GeneralClasses.guide 2.5 (07-Oct-2003) by James T. Steichen

@REMARK Written by Jim Steichen, Copyright (c) 1998-2004.

@WIDTH 75
@WORDWRAP

@INDEX main
@NODE main "Descriptions of the Methods of the General classes:"
  @{FG SHINE}
  WARNING:@{FG TEXT}  The documentation in this file is from the Original Little
            SmallTalk documentation.  If there is any question of whether
            these documents are correct, you should check the corresponding
            source file in @{B}AmigaTalk:General/@{UB} directory in order
            to determine what is currently implemented.

  Undocumented Classes or methods are probably NOT something that the 
  casual User should be concerned with.  Some methods & Classes are
  purposely NOT documented.
               
  Show below is the hierarchy of the General Classes that are loaded
  into memory before the AmigaTalk system is ready for user input.
  The indentations indicate which classes are sub-classes:
  
  @{"Object"                   LINK "ObjectClass"}
    @{"UndefinedObject"        LINK "UndefinedObjectClass"}
    @{"Symbol"                 LINK "SymbolClass"}

    @{"DependencyTransformer"  LINK "DependencyTransformerClass"} -- Added for V2.5+

    @{"Model"                  LINK "ModelClass"} -- Added for V2.5+    
      @{"ValueModel"           LINK "ValueModelClass"} -- Added for V2.5+
        @{"ComputedValue"      LINK "ComputedValueClass"} -- Added for V2.5+
          @{"BlockValue"       LINK "BlockValueClass"} -- Added for V2.5+ 
        @{"PluggableAdaptor"   LINK "PluggableAdaptorClass"} -- Added for V2.5+
        @{"ProtocolAdaptor"    LINK "ProtocolAdaptorClass"} -- Added for V2.5+
          @{"AspectAdaptor"    LINK "AspectAdaptorClass"} -- Added for V2.5+
          @{"IndexedAdaptor"   LINK "IndexedAdaptorClass"} -- Added for V2.5+
            @{"SlotAdaptor"    LINK "SlotAdaptorClass"} -- Added for V2.5+
        @{"ValueHolder"        LINK "ValueHolderClass"} -- Added for V2.5+
        @{"BufferedValueHolder" LINK "BufferedValueHolderClass"} -- Added for V2.5+
            
    @{"Boolean"                LINK "BooleanClass"}
      @{"True"                 LINK "TrueClass"}
      @{"False"                LINK "FalseClass"}
    
    @{"Magnitude"              LINK "MagnitudeClass"}
      @{"Char"                 LINK "CharClass"}
      @{"Number"               LINK "NumberClass"}
        @{"Integer"            LINK "IntegerClass"}
        @{"Float"              LINK "FloatClass"}
        @{"LongInteger"        LINK "LongIntegerClass"}
    
      @{"Radian"               LINK "RadianClass"}
      @{"Point"                LINK "PointClass"}
      @{"Random"               LINK "RandomClass"}
    
    @{"Collection"             LINK "CollectionClass"}
      @{"Bag"                  LINK "Bag_SetClass"}
      @{"Set"                  LINK "Bag_SetClass"}
    
    @{"KeyedCollection"        LINK "KCollectionClass"}
      @{"Dictionary"           LINK "DictionaryClass"}
        @{"AmigaTalk"          LINK "AmigaTalkClass"}
    
      @{"File"                 LINK "FileClass"}
    
    @{"SequenceableCollection" LINK "SCollectionClass"}
      @{"Interval"             LINK "IntervalClass"}
      @{"LinkedList"           LINK "LinkedListClass"}
        @{"Semaphore"          LINK "SemaphoreClass"}
    
    @{"Form"                   LINK "FormClass"} -- Do NOT use!

    @{"Pen"                    LINK "PenClass"}
    
    @{"ArrayedCollection"      LINK "ACollectionClass"}
      @{"Array"                LINK "ArrayClass"}
        @{"DependentsCollection" LINK "DependentsCollectionClass"} -- Added for V2.5+ 

      @{"ByteArray"            LINK "ByteArrayClass"}
      @{"String"               LINK "StringClass"}
    
    @{"Block"                  LINK "BlockClass"}
    @{"Class"                  LINK "ClassClass"}
    @{"Process"                LINK "ProcessClass"}

@ENDNODE

@NODE "ObjectClass" "Object Class:"

  The class @{B}Object@{UB} is a superclass of all classes in the system, and is 
  used to provide a consistent basic functionality and default behavior.
  Many methods in class Object are overridden in subclasses.
  @{FG SHINE}
  NOTE:  Unlike most other versions of Smalltalk, AmigaTalk does not have
         dependencies for every object, only the Model class & its subclasses
         use them. @{FG TEXT} 

  @{U}Examples:@{UU}                @{U}Printed result:@{UU}
  7 ~~ 7.0                                True
  7 asSymbol                              #7
  7 class                                 Integer
  7 copy                                  7
  7 isKindOf: Number                      True
  7 isMemberOf: Number                    False
  7 isNil                                 False
  7 respondsTo: #+                        True

  The methods for Object Class are:
  @{FG SHINE}
  instVarAt: index @{FG TEXT}

    Answer with a fixed variable in an object.  The numbering 
    of the variables corresponds to the named instance variables.  
    Fail if the index is not an Integer or is not the index 
    of a fixed variable.  The range for index is 1 to Object size.
    This method is currently only used by the @{" SlotAdaptor " LINK "SlotAdaptorClass"} class.
  @{FG SHINE}
  instVarAt: anInteger put: anObject @{FG TEXT}

    Store a value into a fixed variable in the receiver.  
    The numbering of the variables corresponds to the named 
    instance variables.  Fail if the index is not an Integer or 
    is not the index of a fixed variable.
    Answer with the value stored as the result.  The range for 
    index is 1 to Object size.  Using this message violates 
    the principle that each object has sovereign control over 
    the storing of values into its instance variables.  This 
    method is currently only used by the @{" SlotAdaptor " LINK "SlotAdaptorClass"} class.
  @{FG SHINE} 
    identityHash @{FG TEXT}
    
    Return an @{" Integer " LINK "GeneralClasses.guide/IntegerClass"} that identifies (hashes) to the object. 
  @{FG SHINE}
  == @{FG TEXT}or @{FG SHINE}= @{FG TEXT}
    
    Return true if receiver and argument are the same object, false 
    otherwise.
  @{FG SHINE}
  ~~ @{FG TEXT}or@{FG SHINE} ~= @{FG TEXT}
    
    Inverse of @{I}==@{UI}.
  @{FG SHINE}
  asString @{FG TEXT}
    
    Return a string representation of the receiver, by default this is the
    same as @{B}printString@{UB}, although one or the other is redefined 
    in many subclasses.
  @{FG SHINE}
  asSymbol @{FG TEXT}
    
    Return a symbol representing the receiver.
  @{FG SHINE} 
  yourself @{FG TEXT}
    
    This is just a synonym for @{I}@{B}self@{UI}@{UB}.
  @{FG SHINE}
  class @{FG TEXT}
    
    Return object representing the class of the receiver.
  @{FG SHINE}
  copy @{FG TEXT}
    
    Return @{B}shallowCopy@{UB} of receiver.  Many subclasses redefine shallowCopy.
  @{FG SHINE}
  deepCopy @{FG TEXT}
    
    Return the receiver.  This method is redefined in many subclasses.
  @{FG SHINE}
  first @{FG TEXT}
    
    Return first item in sequence, which is by default simply the receiver.
    See @{B}next@{UB}, below.
  @{FG SHINE}
  do: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Execute the block on every
    element of the receiver collection.  Elements in the receiver col-
    lection are listed using @{I}first@{UI} and @{I}next@{UI}, so the default 
    behavior is merely to execute the block using the receiver as argument.
  @{FG SHINE}
  do: aBlock without: anObject@{FG TEXT}
    
    The first argument must be a one argument block.  Execute the block on every
    element of the receiver collection except for @{I}anObject@{UI}.  Elements in the receiver col-
    lection are listed using @{I}first@{UI} and @{I}next@{UI}, so the default 
    behavior is merely to execute the block using the receiver as argument.
  @{FG SHINE}
  error: errMsg @{FG TEXT}
    
    Argument must be a String.  Print argument string as error message.  
    Return @{I}nil@{UI}.
  @{FG SHINE}
  isKindOf: className @{FG TEXT}
    
    Argument must be a Class.  Return true if class of receiver, or any 
    superclass thereof, is the same as argument.
  @{FG SHINE}
  isMemberOf: className @{FG TEXT}
    
    Argument must be a Class.  Return true if receiver is instance of 
    argument class.
  @{FG SHINE} 
  ifKindOf: className thenDo: aBlock @{FG TEXT}
    
    If the class of the receiver, or any superclass thereof, is the same
    as the argument, then execute @{I}aBlock@{UI}.   
  @{FG SHINE}
  isNil @{FG TEXT}
    
    Test whether receiver is object @{B}nil@{UB}.
  @{FG SHINE}
  next @{FG TEXT}
    
    Return next item in sequence, which is by default @{I}nil@{UI}.  This 
    message is redefined in classes which represent sequences, such as
    @{B}Array@{UB} or @{B}Dictionary@{UB}.
  @{FG SHINE}
  notNil @{FG TEXT}
    
    Test if receiver is not object @{I}nil@{UI}.
  @{FG SHINE}
  print @{FG TEXT}
    
    Display print image of receiver on the Status Window.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Return a string representation  of receiver.  Objects which do not re-
    define @{I}printString@{UI}, and which therefore do not have a printable
    representation, return their class name as a string.
  @{FG SHINE}
  respondsTo: msgSymbol @{FG TEXT}
    
    Argument must be a symbol.  Return true if receiver will respond to 
    the indicated message.
  @{FG SHINE}
  shallowCopy @{FG TEXT}
    
    Return the receiver.  This method is redefined in many subclasses.

  @{FG SHINE} asciiToString: aNumber @{FG TEXT}
    Convert @{I}aNumber@{UI} into a single-character @{" String " LINK "GeneralClasses.guide/StringClass"}.
  @{FG SHINE}
  subclassResponsibility: methodString @{FG TEXT}

    Inform the user that a subclass did NOT implement the given method.
  @{FG SHINE}
  notImplemented: methodString @{FG TEXT}

    Inform the user that the given method is NOT implemented.
  @{FG SHINE}
  doesNotUnderstand: methodString @{FG TEXT}

    Inform the user that a subclass does NOT understand the given method.
  @{FG SHINE}
  shouldNotImplement: methodString @{FG TEXT}

    Inform the user that a subclass should NOT implement the given method.
  @{FG SHINE} 
  notYetImplemented @{FG TEXT}

    Inform the user that a method is NOT implemented yet.
  @{FG SHINE}
  breakPoint: msgString @{FG TEXT}
     
     This method will act as a breakpoint for your code, displaying 
     a Requester with @{I}msgString@{UI} in it.  This does not mean that
     your code will stop executing, this method is simply a way of 
     displaying debugging statements.  In the future, perhaps it will do
     more than simply display a message on the GUI.
  @{B}
  The following methods were added to support inter-object communications:@{UB}
  @{FG SHINE} 
  perform: selector @{FG TEXT}
   
    Send the unary @{I}selector@{UI} (@{" Symbol " LINK "SymbolClass"})to the receiver.
  @{FG SHINE} 
  perform: selector orSendTo: otherTarget @{FG TEXT}
   
    If I wish to intercept and handle @{I}selector@{UI} myself, 
    do it; else send it to @{I}otherTarget@{UI}.  Default behavior
    is to execute @{B}^ otherTarget perform: selector@{UB}.
  @{FG SHINE}
  perform: selector with: anObject @{FG TEXT}
      
    Send the @{I}selector@{UI} (@{" Symbol " LINK "SymbolClass"}), to the receiver with 
    @{I}anObject@{UI} as its argument.
  @{FG SHINE}
  perform: selector withArguments: argArray @{FG TEXT}
      
    Send the @{I}selector@{UI}, (Symbol), to the receiver with 
    arguments in @{I}argArray@{UI}.  Fail if the number of 
    arguments expected by the @{I}selector@{UI} does not match 
    the size of @{I}argArray@{UI}.  This method is the general case
    of the @{B}perform:@{UB} methods.  Use @{B}perform:with:@{UB} for a single argument
    method, @{B}perform:with:with:@{UB} for methods that require two arguments,
    and @{B}perfrom:with:with:with:@{UB} for methods that require three arguments.
    @{B}perform:@{UB} is for methods that require no arguments.
  @{FG SHINE}
  perform: selector with: firstObject with: secondObject @{FG TEXT}

    Send the @{I}selector@{UI}, (Symbol), to the receiver with the 
    given arguments.
  @{FG SHINE}
  perform: selector with: firstObject with: secondObject with: thirdObject @{FG TEXT}
   
    Send the @{I}selector@{UI}, (Symbol), to the receiver with the given arguments.
  @{FG SHINE}
  performUpdate: aSymbol with: anObject @{FG TEXT}
    
     This method is a synonym for @{B}perform:with:@{UB}.   
  @{FG SHINE}
  performUpdate: aSymbol @{FG TEXT}
    
     This method is a synonym for @{B}perform:@{UB}.

@ENDNODE

@NODE "ModelClass" "Model Class:"
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Any Model can have dependents that receive notification of 
   any change to the object.  This representation is faster but 
   takes more space.

   Instance Variables:
      myDependents  <nil | Object | DependentsCollection>
      haveAChange   <Integer>
      linkedMethods <KeyedCollection>

   Model is an abstract class whose subclasses represent various 
   kinds of information models.  An information model is an 
   object on which user-interface objects such as input fields 
   depend for their data -- thus, the interface objects are 
   said to be dependents of the model.
  
   Here, dependents are kept in an instance variable. 

   While Model does not provide any new abilities, it has many 
   subclasses that do.  An ApplicationModel mediates between a 
   set of data models and the user interface that is used to 
   manipulate the data.  Various kinds of ValueModel are able to 
   adapt simple data objects so they behave like full-fledged models. 

   Available methods are:
   @{FG SHINE}
   postCopy @{FG TEXT}

      Do not copy the dependents list, just everything else. 
   @{FG SHINE}
   initialize @{FG TEXT}

   @{FG SHINE}
   addDependent: anObject @{FG TEXT}

      Make the given object one of the receiver's dependents.
   @{FG SHINE}
   changeComplete @{FG TEXT}

      If haveAChange count has reached zero, return true, else
      return false.
   @{FG SHINE}
   changeMade @{FG TEXT}

      Increment the haveAChange instance variable.
   @{FG SHINE}
   release @{FG TEXT}

      Remove all of the receiver's dependents.
   @{FG SHINE}
   breakDependents @{FG TEXT}

      Remove all of the receiver's dependents.
   @{FG SHINE}
   canDiscardEdits @{FG TEXT}

      Answer true if none of the controllers on this model has 
      unaccepted edits that matter.
   @{FG SHINE}
   dependents: dependentsOrNil @{FG TEXT}
     
      Set the receivers dependents.
   @{FG SHINE}
   dependents @{FG TEXT}

      Answer a collection of objects that are 'dependent' on the 
      receiver; that is, all objects that should be notified if 
      the receiver changes.
   @{FG SHINE}
   hasUnacceptedEdits @{FG TEXT}

      Answer true if any of the controllers on this model has unaccepted edits.
   @{FG SHINE}
   removeDependent: anObject @{FG TEXT}

      Remove the given object as one of the receiver's dependents.
   @{FG SHINE}
   topController @{FG TEXT}

      Find the first top controller on me.  Is there any danger
      of their being two with the same model?  Any danger 
      from ungarbage collected old controllers?
   @{FG SHINE}
   linkMethod: classAndMethod @{FG TEXT}

      Make a message list and put this method in it.
   @{FG SHINE}
   value    @{FG TEXT}
      
      SubClasses must override this.
   @{FG SHINE}
   perform: selector orSendTo: otherTarget @{FG TEXT}

      Selector was just chosen from a Control by a User.  
      If I can respond, then perform it on myself.  If not, send 
      it to otherTarget.

   See Also, @{" ValueModel " LINK "ValueModelClass"}

@ENDNODE

@NODE "ValueModelClass" "ValueModel Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   ValueModel Class is a simple Model that provides direct access 
   to some kind of value.  It notifies dependents when the value changes.
   The collection accessing protocol is here as a convenience, to 
   avoid some of the need for special collection models.

   Subclasses must implement the following messages:
       value
       setValue:

   ValueModel is an abstract class that provides model-like abilities for 
   an enfolded object -- that is, it notifies dependent objects whenever 
   its held object is changed. 
 
   Value models are most commonly used to hold data models on which gadgets 
   such as input fields depend.  To understand why a value model is needed, 
   take the case of an input field that displays a number.  The input 
   field needs to be notified whenever the application changes the number, 
   so it registers itself as a dependent of the number.  If that dependency 
   were established on the raw number, however, the dependency would be 
   obsolete as soon as the application substituted a different number, 
   defeating its purpose.  Instead, a value model is used to hold the 
   number, and the input field registers itself as a dependent of the 
   value model.  The application can insert a new number and the value 
   model then notifies the input field of the change so the field can 
   get the new number and display it.  Since the value model remains in 
   place while its value is changed, the dependency that was established 
   by the input field remains alive as long as the application is running. 
 
   The most commonly used subclass of ValueModel is @{" ValueHolder " LNIK "ValueHolderClass"}, which 
   would be used in the simple case described above.  Because value 
   holders are widely used, every object inherits from the Object class 
   the ability to enfold itself in a value holder -- sending @{B}#asValue@{UB} to 
   any object returns a ValueHolder on the object.  A consequence of 
   inserting a value holder as an adaptor or mediator between a data object 
   and its dependents is that you must send @{B}#value@{UB} to the value model, 
   thus extracting the enfolded object, before you can send a message 
   to that object.  For example, suppose the numeric input field mentioned 
   above uses an instance variable named salesCommission to hold its 
   ValueHolder.  If the application wanted to retrieve the actual number 
   for use in a computation, it would use the expression 'self 
   salesCommission value' instead of simply 'self salesCommission.'  The 
   fact that a value model always gets its enfolded object in response to 
   @{B}#value@{UB}, and sets that value in response to @{B}#value:@{UB}, simplifies 
   communications for gadgets.  
   
   Another commonly used subclass of ValueModel is @{" AspectAdaptor " LINK "AspectAdaptorClass"}, which 
   is used to enfold an embedded value.  For example, suppose we have an 
   AccountNumber class that has a string part and a number part, for a 
   composite account number such as 'TEL-4792'.  We might want to use a 
   separate input field for each part of this account number.  
   One AspectAdaptor could be used to enfold the string part, and another 
   the numeric part.  The most flexible subclass of ValueModel 
   is @{" PluggableAdaptor " LINK "PluggableAdaptorClass"}, because it can be configured to transform the value 
   on its way to and from the dependent.  
   
   @{" PluggableAdaptor " LINK "PluggableAdaptorClass"} can be configured with blocks to perform highly 
   specialized transformations.  Other subclasses of ValueModel are more 
   specialized.  A @" BlockValue " LINK "BlockValueClass"} enables a computation 
   inside a block to have dependents.  
   
   An @{" IndexedAdaptor " LINK "IndexedAdaptorClass"} enfolds an element in a collection.  
 
   @{" SlotAdaptor " LINK "SlotAdaptorClass"} and @{" DependencyTransformer " LINK "DependencyTransformerClass"} are mainly used by system machinery.  
   
   A ValueModel provides a convenient way for an application to arrange 
   to receive a particular message whenever the value is changed.  Making 
   such an arrangement is known as expressing an interest in the value, and 
   involves sending @{B}#onChangeSend:to:@{UB}.  Retracting an interest is
   achieved via @{B}#retractInterestsFor:@{UB}.  When creating a subclass, equip 
   it with the following methods: 
        
        value 
        setValue: 

   The available methods are:
   @{FG SHINE}
   new @{FG TEXT}

     Create a new instance of ValueModel.
   @{FG SHINE}
   initialize @{FG TEXT}
     
     Initialize the instance.  Subclasses may extend this.
   @{FG SHINE}
   release @{FG TEXT}

     Break the dependency links from any parts of myself to myself.
     Subclasses holding composite values will implement this in 
     a non-trivial way. 
   @{FG SHINE}
   releaseParts @{FG TEXT}
     
     Break the dependency links from any parts of myself to myself.
     Subclasses holding composite values will implement this in 
     a non-trivial way. 
   @{FG SHINE}
   setValue: newValue @{FG TEXT}
     
     Set the currently stored value, without notifying dependents. "
   @{FG SHINE}
   value @{FG TEXT}

     Answer the currently stored value.
   @{FG SHINE}
   value: newValue @{FG TEXT}

     Set the currently stored value, and notify dependents.
   @{FG SHINE}
   valueUsingSubject: aSubject @{FG TEXT}

     Return the value of aSubject.
   @{FG SHINE}
   asValue @{FG TEXT}

     Since the receiver is already a ValueModel, merely return self.
   @{FG SHINE}
   onChangeSend: aSymbol to: anObject  @{FG TEXT}

     Arrange for anObject to receive a message named aSymbol when 
     I signal that my attribute #value has changed.
   @{FG SHINE}
   retractInterestsFor: anObject  @{FG TEXT}

     Undo a send of @{I}onChangeSend:to:@{UI}
   @{FG SHINE}
   compute: aBlock  @{FG TEXT}

     Answer a BlockValue that computes aBlock with the receiver's value 
     as the argument. aBlock will become a dependent of the receiver, 
     and will be sent the message value: when the receiver is sent the 
     message value:.
   @{FG SHINE}
   receive: aSelector  @{FG TEXT}

     Answer a BlockValue that responds to the message value by sending 
     aSelector as a message to the receiver. This BlockValue will become a 
     dependent of the receiver, and will be sent the message value: when 
     the receiver is sent the message value:.
   @{FG SHINE}
   receive: aSelector with: value1  @{FG TEXT}

     Answer a BlockValue that responds to the message value by sending 
     aSelector as a message to the receiver. This BlockValue will become a 
     dependent of the receiver, and will be sent the message value: when 
     the receiver is sent the message value:. The message aSelector has 
     one argument, value1. It is assumed that value1 itself responds to 
     the message value (i.e., may be a kind of ValueModel).
   @{FG SHINE}
   with: value2 compute: aBlock  @{FG TEXT}

     Answer a BlockValue that computes aBlock with the receiver and 
     value2 as the first and second arguments, respectively. This 
     BlockValue will become a dependent of the receiver, and will be sent 
     the message value: when the receiver is sent the message value:. It 
     is assumed that value2 itself responds to the message value (i.e., 
     may be a kind of ValueModel).
   @{FG SHINE}
   with: value2 with: value3 compute: aBlock  @{FG TEXT}

     Answer a BlockValue that computes aBlock with the receiver, value2, 
     and value3 as the first, second and third arguments, respectively. 
     This BlockValue will become a dependent of the receiver, and will be 
     sent the message value: when the receiver is sent the message 
     value:. It is assumed that the objects value2 and value3 respond to 
     the message value (i.e., may be a kind of ValueModel).
   @{FG SHINE}
   isBuffering @{FG TEXT}

     ValueModels by default do not buffer values, only special
     subclasses who should reimplement this message for themselves.

   See Also, @{" BlockValue  " LINK "BlockValueClass"},   
             @{" ValueHolder " LINK "ValueHolderClass"}
 
@ENDNODE

@NODE "DependencyTransformerClass" "DependencyTransformer Class:"
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   DependencyTransformer transforms update messages from an object 
   into concrete messages to a receiver.
  
   Objects understand:   
     expressInterestIn: anAspect for: anObject sendBack: aSelector  

   by creating a DependencyTransformer that looks for upates on anAspect 
   and sending aSelector to anObject 
  
   retractInterestIn: anAspect for: anObject 
     removes the DependencyTransformer created above.

   @{" ValueModels " LINK "ValueModelClass"} understand      
     onChangeSend: aSelector to: anObject retractInterestsFor: anObject   
    
   since ValueModels only do changed: #value 
   the aspect can be dropped.
    
   Instance Variables:   
      receiver     <Object>  the object to receive a message on update   
      selector     <Object>  the message selector to send   
      numArguments <Object>  number of arguments in the message selector
      aspect       <Object>  the change aspect to look for 

   Available methods are:
   @{FG SHINE}   
   setReceiver: aReceiver aspect: anAspect selector: aSymbol @{FG TEXT}

   @{FG SHINE}  
   aspect   @{FG TEXT}

     Return the aspect.
   @{FG SHINE}
   receiver   @{FG TEXT}

     Return the receiver. 
   @{FG SHINE}
   selector   @{FG TEXT}

     Return the selector.
   @{FG SHINE}  
   matches: anObject forAspect: anAspect   @{FG TEXT}

     Return true if anObject matches the receiver and the aspect.
   @{FG SHINE}  
   update: anAspect with: parameters from: anObject@{FG TEXT}

     Update anObject.
   @{FG SHINE}  
   = anObject @{FG TEXT}

     Two DependencyTransformers are equivalent if their receiver
     aspect and selectors are identical.
   @{FG SHINE}
   hash   @{FG TEXT}

     Redefined because @{B}=@{UB} is redefined.   

   See Also, @{" DependentsCollection " LINK "DependentsCollectionClass"}

@ENDNODE

@NODE "DependentsCollectionClass" "DependentsCollection Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   A DependentsCollection is a collection of dependents for some 
   object.  Instances forward update messages to the dependents, 
   which are the elements of the collection.  Note that the same 
   dependent may appear more than once in the collection.  Note 
   also that the size of a DependentsCollection must always be 
   2 or greater.  (If an object has only one dependent, that 
   object by itself serves as the collection of dependents.)

   Available methods are:
   @{FG SHINE}   
   asDependentsAsCollection @{FG TEXT}

     Answer the receiver, considered as a collection of 
     dependents, as a real Collection.  Since the receiver 
     is a Collection already, answer the receiver. 
   @{FG SHINE}
   asDependentsWith: anObject @{FG TEXT}

     Answer the receiver, considered as a collection of 
     dependents, with anObject added. 
   @{FG SHINE}
   asDependentsWithout: anObject @{FG TEXT}

     Answer the receiver, considered as a collection of 
     dependents, with the first occurrence of anObject 
     (if any) removed.  If anObject does not occur in 
     the receiver, answer the receiver. 

     If there is only one dependent left, just answer it, 
     rather than a new Collection. 
   @{FG SHINE}
   performUpdate: aSymbol @{FG TEXT}

     Send aSymbol to each member of the receiver.
   @{FG SHINE}
   performUpdate: aSymbol with: anObject @{FG TEXT}

     Send aSymbol to each member of the receiver with 
     anObject as argument.
   @{FG SHINE}
   update: anAspect with: aParameter from: anObject @{FG TEXT}

     Send the message @{B}update: anAspect with: aParameter
     from: anObject@{UB} to each member of the receiver.
   @{FG SHINE}
   updateRequest @{FG TEXT}

     Send the message @{B}updateRequest@{UB} to each member of the receiver.
     If any member answers false, answer false; otherwise, answer true.
   @{FG SHINE}
   updateRequest: anAspectSymbol @{FG TEXT}

     Send the message @{B}updateRequest:@{UB} to each member of the 
     receiver with anAspectSymbol as argument.  If one 
     answers false, answer false, otherwise answer true.

   See Also, @{" DependencyTransformer " LINK "DependencyTransformerClass"}

@ENDNODE

@NODE "ComputedValueClass" "ComputedValue Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   ComputedValue is an abstract class that represents a computation 
   that propagates changes to dependents.  It caches the result of the 
   computation.  Kinds of ComputedValues can not respond to the message 
   @{B}value:@{UB}.  Subclasses must implement:   
  
      parts computeValue
    
   Instance Variables:   
    
     cachedValue     <Object>   
     eagerEvaluation <Boolean> controls whether to wait until the 
                               receiver is asked to perform the 
                               computation (eager vs. late)

     unassignedValue <Object> a unique object that is guaranteed to 
                              be used by no one else in the system,
     used to denote that the value has not yet been computedObject 

   ComputedValue is an abstract class that provides support 
   for creating a BlockClosure that recomputes a cached value
   whenever one of the block arguments changes its value.  When asked 
   for its #value, a ComputedValue supplies its cached value, 
   recomputing it if necessary.  This is useful when object3 is 
   computed using object1 and object2, which are expected to be 
   value models.  ComputedValue has a single subclass, 
   BlockValue.  For usage instructions, see @{" BlockValue " LINK "BlockValueClass"}.  When creating 
   a subclass, equip it with the following methods:

        parts       computeValue 
   @{FG SHINE}    
   Subclasses should not implement: @{B}value:@{UB} @{FG TEXT}

   Available Class methods are:
   @{FG SHINE}
   initialize @{FG TEXT}

      Setup the instance variables.
   @{FG SHINE}
   unassigned @{FG TEXT}

      Return the contents of @{I}unassignedValue@{UI}  
   @{FG SHINE}
   releaseParts    @{FG TEXT}

      Remove any dependencies involving the receiver.
   @{FG SHINE}
   eagerEvaluation: aBoolean     @{FG TEXT}

      If aBoolean is true the receiver will do late evaluation of its
      computation; otherwise the receiver will do eager computation.
   @{FG SHINE}
   parts   @{FG TEXT}

      Answer a collection of objects that have the receiver as a dependent.
      Defined in @{" BlockValue " LINK "BlockValueClass"} Class (& any other subclasses).
   @{FG SHINE}
   value    @{FG TEXT}

      Answer the cached value for the receiver. If the value is unknown,    
      then compute the value.
   @{FG SHINE}
   value: anObject    @{FG TEXT}

      This method only reports that you should Not Implement it. 
   @{FG SHINE}
   update: aspect with: parameter from: sender     @{FG TEXT}

      If a model is propogating a change, then reset the receiver and
      propogate change to dependents.
   @{FG SHINE}
   printOn: aStream    @{FG TEXT}

      Print the receiver's value on aStream.   
   @{FG SHINE}
   computeValue    @{FG TEXT}

      Compute a value for the receiver.
   @{FG SHINE}
   resetValue    @{FG TEXT}

      Set the receiver's value to unknown.  Propogate change to dependents.

   See Also, @{" BlockValue " LINK "BlockValueClass"}
@ENDNODE

@NODE "BlockValueClass" "BlockValue Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   An instance of BlockValue represents a computation that propagates 
   changes.  The value of an instance is recomputed by evaluating a block 
   when the value of any of the instance's arguments changes.  All 
   dependents are notified when the value has changed.

   Instance Variables:
	block      <BlockClosure>
	arguments  <SequenceableCollection of: ValueModel>
	numArgs    <SmallInteger> The number of arguments block takes

   A BlockValue computes its value using a given BlockClosure and a 
   set of arguments for that block.  It registers itself as a dependent 
   of each argument, so the arguments are typically value models. 
   Whenever any of the argument objects changes its value, the BlockValue 
   is updated.  The result is similar to sending #onChangeSend:to: 
   to each of the argument objects, asking them to trigger a method that 
   updates a particular value.  Using a BlockValue eliminates the need 
   to create the method that is triggered -- instead, the block is 
   evaluated with the changed arguments.  The resulting value is cached 
   so that it need not be recomputed unless one of the block arguments 
   changes again.  Being able to use a block instead of a method is 
   especially helpful in the case of dialog that has been built from 
   scratch, such that a method in the application model would have 
   difficulty accessing some of the data in the dialog for its computation.

   A BlockValue is typically created by sending @{B}#block:arguments:@{UB} to 
   this class.  The @{" ValueModel " LINK "ValueModelClass"} class also provides a set of methods for 
   conveniently spawning a BlockValue from one of the argument objects 
   (see the constructing protocol in @{" ValueModel " LINK "ValueModelClass"}).

   By default, a BlockValue recomputes its cached value whenever it is 
   notified that one of the block arguments has changed.  This is known 
   as eager evaluation.  In some situations, late evaluation may be 
   preferable -- then, the cached value is only recomputed when it is 
   requested via @{B}#value@{UB} (assuming one of the block arguments has changed). 

   Late evaluation can be arranged by sending an @{B}#eagerEvaluation:@{UB} 
   message to the BlockValue with false as the argument.  This is most 
   useful when the cached value is only requested infrequently and the 
   block computation is costly in terms of time or other resources. 

   Available methods are:
   @{FG SHINE}   
   block: aBlock arguments: aCollection @{FG TEXT}

     Answer an instance of the receiver with aCollection as arguments.
   @{FG SHINE}
   with: aBlock @{FG TEXT}

     Answer a new instance of the receiver that computes aBlock.
   @{FG SHINE}
   dependOn: anObject @{FG TEXT}

     Make the receiver depend on anObject.
   @{FG SHINE}
   parts @{FG TEXT}

     Answer a collection of objects that have the receiver as a dependent.
   @{FG SHINE}
   computeValue @{FG TEXT}

     Compute a value for the receiver.
   @{FG SHINE}
   setBlock: aBlock @{FG TEXT}

     Set the block for the receiver to be aBlock.
   @{FG SHINE}
   setBlock: aBlock arguments: aCollection @{FG TEXT}

     Set the receiver's block to be aBlock and the arguments to
     be aCollection.

@ENDNODE

@NODE "PluggableAdaptorClass" "PluggableAdaptor Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   PluggableAdaptors provide a level of indirection between a 
   Controller and an underlying model.  The Controller sends my 
   instances the standard messages @{B}value & value:@{UB}, which I 
   convert into arbitrary actions defined by blocks.

   Instance Variables:
	model	<ValueModel>  the underlying model (only used for 
                              dependency and for isActive testing)

	getBlock	<BlockClosure>  evaluate this block to get the value

	putBlock	<BlockClosure>  evaluate this block to set the value

	updateBlock	<BlockClosure>  evaluate this block to handle 
                                        an update from the model; if it 
                                        returns true, notify our dependents

   The getBlock is evaluated with one argument, the model.  
   The putBlock is evaluated with two arguments, the model and the 
   new value.  The updateBlock is evaluated with three arguments, 
   the model, the update aspect, and the update parameter.

   We use blocks rather than selectors because blocks are much more 
   flexible than selectors for representing encapsulated behavior.  
   They can reference more than one object, and they can include 
   embedded parameters such as a collection index.

   A PluggableAdaptor is the most flexible of the value models, 
   because its activities are highly configurable.  This flexibility 
   comes at the cost of a certain conceptual complexity, however. 

   At one time, PluggableAdaptor was the only value model -- now, 
   more convenient value models exist for the most common situations 
   in which a PluggableAdaptor was formerly applied.
  
   A PluggableAdaptor has a model, which can either be an application 
   model or a domain model, from which it obtains the desired data value. 
 
   The adaptor is configured via three blocks, which enable it to 
   perform customized actions at three junctures in the flow of 
   communications between the dependent (typically a widget) and the 
   model.  The first block, the getBlock, controls what happens when a 
   value is requested (via #value).  The block takes one argument, 
   the model.  The block returns the value, after fetching it from 
   the model and applying any necessary computations or transformations. 
   For example, the following getBlock fetches an accountNumber from 
   the model, converts it to a string and pads it with leading zeroes: 

	[ :model | | paddedString | 
           
           paddedString <- model accountNumber printString. 
           
           (6 - paddedString size)
              timesRepeat: [paddedString := '0', paddedString]. 
           
           paddedString ] 

   The second block, the putBlock, controls what happens when a value 
   is stored (via #value:).  The block takes two arguments, the model 
   and the value to be stored.  The block stores the value in the 
   model after applying any necessary computations or transformations. 
   For example, the following putBlock converts a padded 
   accountNumber string back into a number and stores the number 
   in the model: 
	
        [ :model :val | model accountNumber: val asNumber]. 

   The third block, the updateBlock, controls what happens when the 
   adaptor receives an #update:with:from: message.  It receives that 
   message whenever the model sends a variant of #changed:with: to 
   itself -- in the accountNumber example, the model would send such 
   a message when its accountNumber had been changed.  The block takes 
   three arguments: the model and the first two arguments from the 
   #update:with: message (known as the update aspect and the update 
   parameter).  The block returns true or false, usually after testing 
   the aspect to see whether the adaptor cares about that type of 
   change in the model.  When the updateBlock returns true, the 
   adaptor's getBlock is invoked to update the widget's value.  When 
   the updateBlock returns false, no action is taken.  For example, 
   the following updateBlock causes the widget to refetch the value 
   only when the update aspect is #accountNumber and the parameter 
   (an accountNumber string) is less than 1000: 

	[ :model :aspect :parameter | 
            aspect == #accountNumber and: [parameter asNumber < 1000]]. 

   A PluggableAdaptor is created by sending #on: to this class, 
   with the model as the argument.  The three blocks are then 
   initialized via @{B}#getBlock:putBlock:updateBlock@{UB}.

   Available methods are:
   @{FG SHINE}
   on: aModel @{FG TEXT}

     Create a new PluggableAdaptor with the given aModel @{" Model " LINK "ModelClass"}
   @{FG SHINE}
   getBlock: aBlock1 putBlock: aBlock2 updateBlock: aBlock3 @{FG TEXT}

     Set the blocks used for dealing with the model.
   @{FG SHINE}
   initialize @{FG TEXT}

     Initialize the blocks on the assumption that the 
     underlying model is a @{" ValueModel " LINK "ValueModelClass"}.  This is wrong, 
     of course. 
   @{FG SHINE}
   model: aModel @{FG TEXT}

     Set our model instance variable to aModel.
   @{FG SHINE}     
   subjectChannel: aValueHolder @{FG TEXT}

   @{FG SHINE}
   collectionIndex: index @{FG TEXT}
     Initialize the receiver to access the given element of a collection
     that is the value of the model. 
   @{FG SHINE}
   getSelector: aSymbol0 putSelector: aSymbol1 @{FG TEXT}

     Initialize the receiver to act like the old pluggable classes. 
   @{FG SHINE}
   performAction: aSelector @{FG TEXT}

     Initialize the receiver to perform the action when assigned a value 
   @{FG SHINE}
   selectValue: aValue @{FG TEXT}

     Initialize the receiver to act like a Boolean 
     that is true when the model's value is equal to aValue. 
   @{FG SHINE}
   model @{FG TEXT}

     Return our model.
   @{FG SHINE}
   setValue: newValue @{FG TEXT}

   @{FG SHINE}
   value @{FG TEXT}

     Return our value.
   @{FG SHINE}
   valueUsingSubject: aSubject @{FG TEXT}

   @{FG SHINE}
   update: aspect with: parameter from: sender @{FG TEXT}

   @{FG SHINE}
   addDependent: aDependent  @{FG TEXT}

   @{FG SHINE}
   removeDependent: aDependent  @{FG TEXT}

   @{FG SHINE}
   isProtocolAdaptor @{FG TEXT}

     Answer as to whether the receiver transduces protocol 
     into ValueModel protocol.
   @{FG SHINE}
   makeAdaptorForRenderingStoreLeafInto: pair @{FG TEXT}

   @{FG SHINE}
   renderingValueUsingSubject: aSubject @{FG TEXT}

@ENDNODE

@NODE "ProtocolAdaptorClass" "ProtocolAdaptor Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Class ProtocolAdaptor is an abstract class that introduces the 
   concept of a @{" ValueModel " LINK "ValueModelClass"} which redirects the @{B}value & value:@{UB}
   messages to another object (the subject) and adds lazy dependency.  
   Lazy dependency means that the ProtocolAdaptor will only register 
   itself as a dependent of the subject if it has at least one dependent 
   and the subject will send update messages.  Subclasses which implement 
   value: are responsible for sending update messages if the subject 
   does not send update messages. 

   ProtocolAdaptors can have a collection of object used to transform 
   the subject into the "target" which subclasses then operate on.

   A ProtocolAdaptor has either a constant or variable subject.  The 
   constant subject is initialized with the @{B}subject:@{UB} or 
   @{B}subject:sendsUpdates:@{UB} messages.  A variable subject is commonly used 
   when a set of adaptors all adapt a different part of the same subject 
   or the subject is changed after initialization.  A variable subject 
   requires the use of a @{" ValueModel " LINK "ValueModelClass"} to inform the ProtocolAdaptor of the 
   new subject and is initialized using the @{B}subjectChannel:@{UB} or 
   @{B}subjectChannel:sendsUpdates:@{UB} messages.

   Dependents are notified of the value changing when the subject is changed.

   Instance Variables:
      subject              <Object> The object we're adapting.
 
      subjectSendsUpdates  <Boolean> When this is set to true, it is 
                                     assumed that the subject will 
        send update notices and we'll pass them on to our dependents 
        when received.  When set to false, the adaptor generates the 
        update notice to the dependents of the adaptor.  The lazy dependency
        mechanism avoids double-notificaton of dependents when the subject 
        does send updates.
   
      subjectChannel       <ValueModel> When this sends a change notice, 
                                        update the subject.

      accessPath    <SequencableCollection | nil> holds accessors to turn 
                                             the subject into the target


   ProtocolAdaptor is an abstract class that provides its subclasses with 
   the ability to get and set an embedded value in an object other than 
   the application model, such as an instance variable in a domain model. 
   Each such adaptor has a subject, which is typically a composite domain 
   model, and specialized value-getting and -setting messages for extracting 
   the desired value from the subject. 
  
   For example, suppose you are creating a canvas containing one input 
   field for each part of a Customer object: accountNumber, name, company, 
   address, and so on.  Since the accountNumber is held by a Customer 
   object rather than by the application model, an ordinary ValueHolder 
   offers no help in accessing it.  While you can create a duplicate 
   accountNumber variable in the application model, and charge the 
   application model with the responsibility of updating the Customer 
   object whenever the input field is changed, this is cumbersome, 
   especially for a large number of such fields.  A ProtocolAdaptor (in this 
   case, an @{" AspectAdaptor " LINK "AspectAdaptorClass"}) enables you to cut out the middle man by 
   getting and setting the accountNumber in the Customer object directly. 
   
   In this case, the Customer would be the subject of several 
   AspectAdaptors -- one adaptor translates @{B}#value & #value:@{UB} into 
   @{B}#accountNumber & #accountNumber:@{UB}, another adaptor manages the 
   customer name, and so on. 

   The subject can be changed during the life of an adaptor -- for 
   example, a new instance of Customer can become the focus of the adaptor's 
   inquiries.  When a change of subject is likely, it is most economical 
   to first enfold the subject in a value holder.  This value holder is 
   known as a subject channel, because it provides a channel to the subject. 
   In that case, the adaptor would be created via a @{B}#subjectChannel:@{UB} 
   message rather than a @{B}#subject:@{UB} message.  In the example, instead of 
   storing a Customer object in an instance variable of the application 
   model, we would store a value holder containing the Customer object. 

   Because both the adaptor and its subject are capable of sending 
   @{B}#update:with:from:@{UB} messages to the same dependent, it is sometimes 
   necessary to disable the adaptor's update facility.  This is usually 
   done at instance creation time, via a @{B}#subjectSendsUpdates:@{UB} message. 

   By default, the adaptor assumes that the subject does not send redundant 
   update messages. 

   ProtocolAdaptor is actually capable of extracting a value that is 
   deeply embedded in the subject.  For example, suppose the Customer 
   holds an AccountNumber object, which holds an AccountPrefix object, 
   which holds a prefixCharacter and a prefixNumber.  The AspectAdaptor 
   for the prefixNumber would need to send @{B}#accountNumber@{UB} to the address, 
   then send @{B}#accountPrefix@{UB} to the account number.  This series of messages 
   is called the access path, and is initialized via @{B}#accessPath:@{UB}. 
   @{" AspectAdaptor " LINK "AspectAdaptorClass"} is the most commonly used subclass of ProtocolAdaptor. 
   @{" IndexedAdaptor " LINK "IndexedAdaptorClass"} is used to access an element in a collection. 
   
   When creating a subclass, equip it with the following methods: 

       setValueUsingTarget:to: 
       valueUsingTarget: 

   A subclass that implements @{B}#value:@{UB} is responsible for sending an 
   update message if its subject does not send one. 

   Available methods are:
   @{FG SHINE}   
   accessPath: aSequenceableCollection @{FG TEXT}

     Answer a new instance of the receiver with accessPath
     aSequenceableCollection.
   @{FG SHINE}
   new @{FG TEXT}

     Create a new instance of the class.
   @{FG SHINE}
   subject: aSubject @{FG TEXT}

     Answer a new ProtocolAdaptor with a constant subject 
     (aSubject).  By default, the ProtocolAdaptor's subject 
     does not send update notices to its dependents.
     
     Note:  For a ProtocolAdaptor which will change subjects
     frequently, or a group of ProtocolAdaptors which should 
     all share a subject and change at the same time, 
     @{I}subjectChannel:@{UI} provides a convenient interface.
   @{FG SHINE}
   subject: aSubject accessPath: aSequenceableCollection @{FG TEXT}

     Create and initialize the ProtocolAdaptor.
   @{FG SHINE}
   subject: aSubject sendsUpdates: aBoolean @{FG TEXT}

     Answer a new ProtocolAdaptor with a constant subject 
     (aSubject).  This ProtocolAdaptor will send update 
     messages when the value changes if aBoolean is false.
     
     Note:  For a ProtocolAdaptor which will change subjects
     frequently, or a group of ProtocolAdaptors which should 
     all share a subject and change at the same time, 
     subjectChannel:sendsUpdates: provides a convenient interface.
   @{FG SHINE}
   subject: aSubject sendsUpdates: aBoolean 
                       accessPath: aSequencableCollection @{FG TEXT}

     Create and initialize the ProtocolAdaptor.
   @{FG SHINE}
   subjectChannel: aValueModel @{FG TEXT}

     Answer a new ProtocolAdaptor with a variable subject 
     (aValueModel is the subject channel) to notify it of 
     changes in the subject.  By default, the   ProtocolAdaptor's 
     subject does not send update notices to its dependents.
     
     Note:  A ProtocolAdaptor which will not change subjects
     does not need to use a subject channel.  It is more 
     efficient and convenient to set the subject using subject:
   @{FG SHINE}
   subjectChannel: aValueModel accessPath: aSequenceableCollection @{FG TEXT}

     Set our instance variables.
   @{FG SHINE}
   subjectChannel: aValueModel sendsUpdates: aBoolean @{FG TEXT}

     Answer a new ProtocolAdaptor with a variable subject
     (aValueModel is the subject channel) to notify it of 
     changes in the subject.  The ProtocolAdaptor will send 
     update messages when the value changes if aBoolean is false.
     
     Note:  A ProtocolAdaptor which will not change subjects 
     does not need to use a subject channel.  It is more 
     efficient and convenient to set the subject
     using subject:sendsUpdates:
   @{FG SHINE}
   subjectChannel: aValueModel sendsUpdates: aBoolean 
       accessPath: aSequenceableCollection @{FG TEXT}
   
     Read the class description. 
   @{FG SHINE}
   initialize @{FG TEXT}

   @{FG SHINE}
   releaseParts @{FG TEXT}

     Remove the receiver as a dependent of the receiver's subject.
   @{FG SHINE}
   subject @{FG TEXT}

     Answer the current subject.
   @{FG SHINE}
   subject: anObject @{FG TEXT}

      Set the subject to be anObject.  Send an update since the value has
      probably changed too.  If this ProtocolAdaptor has a subject channel,
      delegate setting the new subject to it so that others depending 
      on the same subject channel value model will be informed automatically.
     
      Note:  For a ProtocolAdaptor which will change subjects frequently,
      or a group of ProtocolAdaptors which should all share a subject and
      change at the same time, subjectChannel: provides a convenient interface.
   @{FG SHINE}
   subjectChannel @{FG TEXT}

     Answer the ValueModel used to provide new subjects.
   @{FG SHINE}
   subjectChannel: aValueModel @{FG TEXT}

     Set or change the ValueModel we depend on to provide the latest subject.
     In the rare cases where the subject channel needs to be reinitialized an
     update message is sent on the assumption that the value has changed.
   @{FG SHINE}
   subjectSendsUpdates @{FG TEXT}

     Does our subject send updates to its dependents?
   @{FG SHINE}
   subjectSendsUpdates: aBoolean @{FG TEXT}

      Set or change the nature of the subject.
      If the subject does not send updates, we 
      won't bother to depend on it.
   @{FG SHINE}
   accessPath @{FG TEXT}

     Answer the receiver's accessPath.  This is a collection
     of accessors used to turn the receiver's subject into 
     the target for messages.
   @{FG SHINE}
   accessPath: aSequenceableCollection @{FG TEXT}

     Set the receiver's accessPath to be aSequenceableCollection.
     This will be used to turn the subject into the target.
   @{FG SHINE}
   setValue: newValue @{FG TEXT}

     Set a new value using the reciever's target.
   @{FG SHINE}
   target @{FG TEXT}

     Answer the receiver's target for operations.
     If there is an accessPath it will hold accessors that 
     will be used to turn the subject into the target.
   @{FG SHINE}
   value @{FG TEXT}

     Answer the value returned by sending the receiver's 
     retrieval (get) selector to the receiver's target.
   @{FG SHINE}
   value: newValue @{FG TEXT}

     Set the currently stored value, and notify dependents.
   @{FG SHINE}
   valueUsingSubject: aSubject @{FG TEXT}

     Answer a value for the subject if aSubject were the 
     receiver's subject.
   @{FG SHINE}
   addDependent: anObject @{FG TEXT}

     Add anObject as one of the receiver's dependents.
   @{FG SHINE}
   removeDependent: anObject @{FG TEXT}

     Remove the argument, anObject, as one of the 
     receiver's dependents.
   @{FG SHINE}
   update: anAspect with: parameters from: anObject @{FG TEXT}

     If the update is from the subjectChannel, it must be because
     there is a new subject.
   @{FG SHINE}
   isProtocolAdaptor @{FG TEXT}

     Answer as to whether the receiver transduces protocol
     into ValueModel protocol.
   @{FG SHINE}
   printOn: aStream @{FG TEXT}

   @{FG SHINE}
   printPathOn: aStream @{FG TEXT}

   @{FG SHINE}
   access: anObject with: anAccessor @{FG TEXT}

   @{FG SHINE}
   changedSubject @{FG TEXT}
     
     The subject has changed.
   @{FG SHINE}
   hookupToSubject @{FG TEXT}

     Add the receiver as a dependent of the receiver's subject.
   @{FG SHINE}
   makeAdaptorForRenderingStoreLeafInto: pair @{FG TEXT}

   @{FG SHINE}
   renderingValueUsingSubject: aSubject @{FG TEXT}

   @{FG SHINE}
   setSubject: anObject @{FG TEXT}

     Set the subject to be anObject.  Send an update since the
     value has probably changed too.
   @{FG SHINE}
   setValueUsingTarget: anObject to: newValue @{FG TEXT}

     Using anObject set a new value.
   @{FG SHINE}  
   targetUsingSubject: aSubject @{FG TEXT}

   @{FG SHINE}
   unhookFromSubject @{FG TEXT}

     Remove the receiver as a dependent of the receiver's subject.
   @{FG SHINE}
   valueUsingTarget: anObject    @{FG TEXT}

     Answer the value returned by using anObject.
     
   See Also, @{" AspectAdaptor  " LINK "AspectAdaptorClass"}
             @{" IndexedAdaptor " LINK "IndexedAdaptorClass"}
@ENDNODE

@NODE "IndexedAdaptorClass" "IndexedAdaptor Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Class IndexedAdaptor provides the appearance of a ValueHolder, but 
   redirects the value and value: methods to the target by sending 
   at: and at:put:, respectively.

   When there is no target, the value is always nil; setValue: is a 
   no-op; and value: only notifies the dependents.

   Instance Variables:
	index <Integer> The index to adapt.

   An IndexedAdaptor is used to get and set an element in a collection. 
   It is typically created by sending a #subject: message to this 
   class, with the collection as the argument.  It is then equipped with 
   the index number or other lookup key of the desired element, via 
   @{B}#forIndex:@{UB}. 

   An IndexedAdaptor can manage a collection element that is embedded 
   multiple levels within the subject, via an access path.  It can also 
   be told to withhold its update messages to avoid duplicating those 
   sent by its subject.  See @{" ProtocolAdaptor " LINK "ProtocolAdaptorClass"} for a fuller discussion of 
   these abilities. 

   Avaialble methods are:
   @{FG SHINE}   
   forIndex: anIndex @{FG TEXT}

     Create a new IndexedAdaptor and initialize the index to adapt. 
     The subject or subjectChannel and whether the subject sends updates 
     must be initialized separately.
   @{FG SHINE}
   forIndex: anIndex accessPath: aSequencableCollection @{FG TEXT}

     Create a new IndexedAdaptor and initialize the index to adapt. 
     The subject or subjectChannel and whether the subject sends updates 
     must be initialized separately.
   @{FG SHINE}
   forIndex @{FG TEXT}

     Answer the index we're adapting.
   @{FG SHINE}
   forIndex: anIndex @{FG TEXT}

     Set out index instance variable to anIndex.
   @{FG SHINE}
   setValueUsingTarget: anObject to: newValue @{FG TEXT}

     Set the value in anObject using @{I}at:put:@{UI}
   @{FG SHINE}
   valueUsingTarget: anObject	 @{FG TEXT}

     Answer the value returned by sending anObject with @{I}at:@{UI}
   @{FG SHINE}
   update: anAspect with: aParameter from: anObject @{FG TEXT}

     Update our dependents or ask our parent to pass on the message.
   @{FG SHINE}
   printOn: aStream @{FG TEXT}

     Print ourself to aStream.

   See Also, @{" SlotAdaptor " LINK "SlotAdaptorClass"}

@ENDNODE

@NODE "SlotAdaptorClass" "SlotAdaptor Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Class SlotAdaptor redirects the value and value: methods to the 
   target by sending instVarAt: and instVarAt:put:, respectively.

   When there is no target, the value is always nil; setValue: is a 
   no-op; and value: only notifies the dependents.

   The subject is assumed to not send updates.  However, if it uses 
   #at as the aspect and provides the index as the parameter, it will 
   be treated as a change notice an propogated to the dependents of 
   the SlotAdaptor.

   Available methods are:
   @{FG SHINE}
   forIndex: instVarIndex @{FG TEXT}

     Set out index to instVarIndex. 
   @{FG SHINE}
   setValueUsingTarget: anObject to: newValue @{FG TEXT}

     Set the value in anObject using @{I}instVarAt:put:@{UI}
   @{FG SHINE}
   valueUsingTarget: anObject	 @{FG TEXT}

     Answer the value returned by sending anObject @{I}instVarAt:@{UI}
   @{FG SHINE}
   printOn: aStream @{FG TEXT}

     Print our index to aStream.
     
   See Also, @{" IndexedAdaptor " LINK "IndexedAdaptorClass"}

@ENDNODE

@NODE "ValueHolderClass" "ValueHolder Class:" 
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   ValueHolder is a very simple @{" Model " LINK "ModelClass"}, no more than a value holder with updates.

   Instance variables:
	value  <Object> the current value


   A ValueHolder is the simplest value model. It merely holds a value, 
   and notifies the dependents of that value whenever it is changed. 
 
   A ValueHolder is widely used to enfold the strings, numbers and 
   other data objects that are displayed in widgets.  For this reason, 
   every object has been made capable of enfolding itself in a ValueHolder 
   when it receives an @{B}#asValue@{UB} message.  ValueHolder also provides both 
   general and specialized creation messages for enfolding a given value.
   
   Available methods are:
   @{FG SHINE}   
   newBoolean @{FG TEXT}

     Answer a new instance, initialized to false.
   @{FG SHINE}
   newFraction @{FG TEXT}

     Answer a new instance, initialized to 0.0.
   @{FG SHINE}
   newString @{FG TEXT}

     Answer a new instance, initialized to an empty string.
   @{FG SHINE}
   with: initialValue @{FG TEXT}

     Answer a new instance, initialized to the given value.
   @{FG SHINE}
   setValue: aValue @{FG TEXT}

     Just initialize the value without notifying dependents of a change. 
   @{FG SHINE}
   value @{FG TEXT}

     Return the current stored value.
   @{FG SHINE}
   printOn: aStream  @{FG TEXT}

     Let what is printed reflect the value of the receiver.

@ENDNODE

@NODE "BufferedValueHolderClass" "BufferedValueHolder Class"

@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Class BufferedValueHolder is a wrapper for a @{" ValueModel " LINK "ValueModelClass"} (the 
   subject).  Clients see the current value of the subject until 
   value: provides a new value.  The new value is not provided to 
   the subject until the application directs it via a setting the 
   triggerChannel value to true.  The buffered value may be discarded 
   by setting the trigger channel value to false.

   Instance Variables:
     subject <ValueModel> The ultimate source/destination of the value.
     
     triggerChannel <ValueModel> When this changes, push the current
                                 value down to the subject.  If the
                    value is equal to notYetAssigned, do nothing.

   Class Variables (see BVHGlobalVar class):
     notYetAssigend <Object> A distinguished value used to 
                             indicate that value has not been set.

   A BufferedValueHolder is used to hold a temporary copy of the 
   value in another valueModel (known as the subject).  The 
   application modifies the temporary copy, but the Buffered-
   ValueHolder only gives this temporary value to its subject when 
   the application confirms the changes.  The application also has 
   the option of canceling the changes, resetting the temporary 
   copy to the subject's value. 

   For example, suppose the application provides a series of input
   fields for entering customer name, address, phone, etc., but we 
   only want the Customer object to be updated after the user has 
   finished entering data and has indicated completion by clicking 
   on an OK button.  This technique is often used in database 
   applications, to postpone updating the customer record in the 
   database until all changes to that record are completed.  In this
   application, the customer's old address would likely be held by 
   an AspectAdaptor on the Customer object.  The aspect adaptor would 
   become the subject of a BufferedValueHolder.  The Buffered-
   ValueHolder would make a temporary copy of the customer's address 
   and make that value available to the input field for editing. 
   The user could change the address, but so far only the temporary 
   copy has been altered.  Only when the users clicks on 'OK' does 
   the application notify each field's BufferedValueHolder to replace 
   the corresponding value in the Customer object. 
   
   A BufferedValueHolder is created by sending a #subject:triggerChannel: 
   message to this class.  The subject is a valueModel containing the 
   data value.  The triggerChannel is a ValueHolder containing the 
   boolean object false.  Later, when the user clicks on 'OK', the 
   application can cause the temporary copy to become the subject's 
   value by setting the triggerChannel's value to true.  The 
   application can also cancel any edits, by setting the trigger-
   Channel's value to false.  Note that the prior value in the 
   triggerChannel is not significant -- setting the value to true 
   when it is already true has the same effect as if it were 
   previously false. 
   
   By using the same triggerChannel for all of the Buffered-
   ValueHolders, the application can cause them all to be updated 
   at the same time.  This is the usual arrangement for a set of 
   related widgets. 

   This class exists because Little Smalltalk does not have Class
   variables available.  The following class is used to store 
   the Class variable notYetAssigned:

   Class BVHGlobalVar methods you need to use are:
   @{FG SHINE}
   notYetAssigned @{FG TEXT}

      Return the stored variable.
   @{FG SHINE}
   notYetAssigned: aBoolean @{FG TEXT}

      Set/Reset the stored variable.

   @{B} 
   The Methods for the BufferedValueHolder Class are: @{UB}
   
   @{FG SHINE}
   subject: aSubject triggerChannel: aTrigger @{FG TEXT}

      Create a new BufferedValueHolder which provides buffering
      for the ValueModel aSubject, and which pushes the buffered
      value into the subject when the ValueModel aTrigger changes.
   @{FG SHINE}
   initialize @{FG TEXT}

      Setup this BufferValueHolder instance.
   @{FG SHINE}
   releaseParts @{FG TEXT}

      Remove the receiver as dependents of the triggerChannel
      and subject.
   @{FG SHINE}
   subject @{FG TEXT}

      The subject of our adapting logic.  The saved value will
      be sent to the subject when the trigger channel indicates
      that it is time to do so.
   @{FG SHINE}
   subject: aValueModel @{FG TEXT}

      The subject is the actual respository for the value
      held in this object.
   @{FG SHINE}
   triggerChannel @{FG TEXT}

      The object we depend on which sends an update message
      when the saved value should be inserted into the subject.
   @{FG SHINE}
   triggerChannel: aValueModel @{FG TEXT}

      An object to depend on which will send an update message
      to trigger the copy of the saved value to the subject.
   @{FG SHINE}
   value @{FG TEXT}

      Answer with the current value.
   @{FG SHINE}
   valueUsingSubject: aSubject @{FG TEXT}

      ^ subject valueUsingSubject: aSubject
   @{FG SHINE}
   addDependent: anObject @{FG TEXT}

      Add anObject as one of the receiver's dependents.
   @{FG SHINE}
   removeDependent: anObject @{FG TEXT}

      Remove the argument, anObject, as one of the receiver's dependents.
   @{FG SHINE}
   changedTrigger @{FG TEXT}

      Process the trigger notification. "
      Unhooking and rehooking the subject prevents 
      dependency notification being propogated thru this object.
      The dependents of this object have already been informed
      of the current value.
      
      There's nothing to do if no new value has been set
      since the last trigger.
   @{FG SHINE}
   hookupToSubject @{FG TEXT}

      Add the receiver as a dependent of the receiver's subject.
   @{FG SHINE}
   renderingValueUsingSubject: aSubject @{FG TEXT}

      Return the value using aSubject.
   @{FG SHINE}
   unhookFromSubject @{FG TEXT}

      Remove the receiver as a dependent of the receiver's subject.
   @{FG SHINE}
   update: anAspect with: parameters from: anObject @{FG TEXT}

   @{FG SHINE}
   isBuffering @{FG TEXT}

      Answer true if a value is being buffered

   See Also, @{" ValueHolder " LINK "ValueHolderClass"}

@ENDNODE

@NODE "AspectAdaptorClass" "AspectAdaptor Class:"
@NEXT "ObjectClass"
@PREV "Main"

   Added for V2.5+    

   Class AspectAdaptor provides the appearance of a ValueHolder, but 
   redirects the value and value: methods to the target by sending 
   getSelector and putSelector, respectively.  The putSelector is assumed 
   to take a single argument which is the argument provided to value:.

   When there is no target, the value is always nil; setValue: is a no-op; 
   and value: only notifies the dependents.

   Instance Variables:
     getSelector   <Symbol>  0-arg message selector
     putSelector   <Symbol>  1-arg message selector
     aspect        <Symbol | nil> aspect for which the adaptor is willing to 
                              field updates.  If nil, use the getSelector instead
 
   An AspectAdaptor is widely used in applications, to get and set an 
   embedded value.  While a ValueHolder typically manages a value held by 
   an application model, an AspectedAdaptor typically manages a value held 
   by a domain model, which itself is held by the application model.  The 
   domain model is the adaptor's subject, and the adaptor must be equipped 
   with messages (getSelector and putSelector) for accessing the desired value 
   in the subject.  See @{" ProtocolAdaptor " LINK "ProtocolAdaptorClass"} for a descriptive 
   example. 
  
   An AspectAdaptor is typically created by sending a @{B}#subject:@{UB} message to 
   this class, with the domain model as the argument.  The getSelector and 
   putSelector are typically the same message (with a colon, in the case of 
   the putSelector) and can be set via @{B}#forAspect:@{UB}.  When the getSelector and 
   putSelector are dissimilar, use @{B}#accessWith:assignWith:@{UB} to set them. 
  
   An AspectAdaptor can manage a value that is embedded multiple levels within 
   the subject, via an access path.  It can also be told to withhold its 
   update messages to avoid duplicating those sent by its subject.  See 
   @{" ProtocolAdaptor " LINK "ProtocolAdaptorClass"} for a fuller discussion of these abilities. 

   Available methods are:
   @{FG SHINE}
   accessWith: getSymbol assignWith: putSymbol @{FG TEXT}

     Create a new AspectAdaptor and initialize the getSelector and putSelector
     with getSymbol and putSymbol, respectively. The subject or subjectChannel
     and whether the subject sends updates must be initialized separately.
   @{FG SHINE}
   accessWith: getSymbol assignWith: putSymbol accessPath: aSequencableCollection @{FG TEXT}

     Create a new AspectAdaptor and initialize the getSelector and putSelector
     with getSymbol and putSymbol, respectively. The subject or subjectChannel
     and whether the subject sends updates must be initialized separately.
   @{FG SHINE}
   forAspect: anAspectSymbol @{FG TEXT}

     Create a new AspectAdaptor and initialize the getSelector and putSelector
     based on anAspectSymbol and the symbol with a colon appended.
     The subject or subjectChannel and whether the subject sends updates must
     be initialized separately.
   @{FG SHINE}
   forAspect: anAspectSymbol accessPath: aSequencableCollection @{FG TEXT}

     Create a new AspectAdaptor and initialize the getSelector and putSelector
     based on anAspectSymbol and the symbol with a colon appended.
     The subject or subjectChannel and whether the subject sends updates must
     be initialized separately.
   @{FG SHINE}
   accessWith: getSymbol assignWith: putSymbol @{FG TEXT}

     Set or change the symbols used to access the subject.
   @{FG SHINE}
   accessWith: getSymbol assignWith: putSymbol aspect: aspectSymbol @{FG TEXT}

     Set or change the symbols used to access the subject.
   @{FG SHINE}
   forAspect @{FG TEXT}

     Answer the aspect we're adapting.
   @{FG SHINE}
   forAspect: anAspectSymbol @{FG TEXT}
    
     Set or change the symbols used to access the subject.
   @{FG SHINE}
   initialize @{FG TEXT}

     Initialize this instance of the class.
   @{FG SHINE}
   setValueUsingTarget: anObject to: newValue @{FG TEXT}

     Set the value of anObject by sending the receiver's 
     store (put) selector to the anObject with argument newValue.
   @{FG SHINE}
   valueUsingTarget: anObject @{FG TEXT}

     Answer the value returned by sending the receiver's 
     retrieval (get)  selector to anObject.
   @{FG SHINE}
   update: anAspect with: parameter from: sender @{FG TEXT}

     Propagate change if the sender is the receiver's subject 
     and anAspect is the receiver's aspect.
   @{FG SHINE}
   printOn: aStream @{FG TEXT}

     Output the object onto aStream.
     
   See Also, @{" ProtocolAdaptor " LINK "ProtocolAdaptorClass"}
 
@ENDNODE
 
@NODE "PenClass" "Pen Class:"
@NEXT "ObjectClass"
@PREV "Main"

  The class @{B}Pen@{UB} is a class that opens a Window for performing simple
  graphics commands in.  This class has been re-written & is completely
  different from the intentions of the Little SmallTalk author, Tim Budd.
  Instead of using a plotting device (How many of those are there for the
  Amiga?), this class simply opens a Window that can be used to see the
  results of the @{B}Pen@{UB} methods.  
  @{FG SHINE}
  NOTE: @{FG TEXT} There's a limit of @{B}20@{UB} for how many Plot Windows can be open
         at the same time.  AmigaTalk will tell you via Requesters when
         this limit is violated.
            
  This class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}

    make a new instance of class @{B}Pen@{UB}, initializing the 
    instance variables (default title: 'Unknown Plot').
  @{FG SHINE}
  new: newPlotTitle @{FG TEXT}

    make a new instance of class @{B}Pen@{UB}, initializing the 
    instance variables & using the supplied @{U}newPlotTitle@{UU} as
    the Plot Window title.
  @{FG SHINE}
  openPlotEnv: sizePoint @{FG TEXT}

    Open the Plot Window with the given size (sizePoint is of class @{" Point " LINK "PointClass"},
    so (sizePoint x) is the width, & (sizePoint y) is the height of the
    Plot Window).
    @{FG SHINE}
    WARNING:  @{FG TEXT}You can only open a Plot Window as big as the AmigaTalk screen
              (default 640 by 480).
  @{FG SHINE}  
  closePlotEnv: whichPlotTitle @{FG TEXT}

    Close the Plot Window with the given title.
  @{FG SHINE}  
  movePlotEnvBy: deltaPoint @{FG TEXT}

    Move the Plot Window by the given deltaPoint amounts (deltaPoint is 
    of class @{" Point " LINK "PointClass"}, so (deltaPoint x) is x movement,
    & (deltaPoint y) is y movement of the Plot Window.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              the Plot Window visible!
  @{FG SHINE}  
  setLineType: bitPattern @{FG TEXT}

    Change the type of the line to plot with to the given bitPattern value.
    (example:  2r11110000111100001111000011110000 = 16rF0F0F0F0 will draw 
     a dashed line).  This is equivalent to SetDrPt() in graphics.library.
  @{FG SHINE}  
  drawText: text at: startPoint @{FG TEXT}

    Place the given text at the given starting point using the current 
    pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              the text inside the Plot Window!
  @{FG SHINE}
  drawBox: fromPoint to: endPoint @{FG TEXT}

    Draw a box (fromPoint x) @ (fromPoint y) 
    to (endPoint x) @ (endPoint y).  This is different from the 
    graphics.library DrawBox() call in that the endPoint is @{B}NOT@{UB} interpreted
    to be the width & height of the box.  If you want to use the second 
    point as width @ height, simply add this:
    
      endPoint x <- fromPoint x + endPoint x.
      endPoint y <- fromPoint y + endPoint y.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawCircleAt: centerPoint radius: r @{FG TEXT}

    Draw a circle at the given centerPoint with the given radius using 
    the current pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}  
  circleRadius: radius @{FG TEXT}

    Draw a circle at the current location, with the given radius using 
    the current pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawArcAround: pivotPoint for: angleSizer @{FG TEXT}

    Draw an arc starting at the current location, around the given pivotPoint for the
    given angleSize (expressed in @{" Radians " LINK "RadianClass"}) using the current pen colors.
    This method is math intensive, so don't expect it to be fast!
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawArcAt: startPoint around: pivotPoint for: angleSize @{FG TEXT}

    Draw an arc starting at startPoint, around the given pivotPoint for the
    given angleSize (expressed in @{" Radians " LINK "RadianClass"}) using the current pen colors.
    This method is math intensive, so don't expect it to be fast!
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawTo: endPoint @{FG TEXT}

    Draw a line from the current location to the given endPoint using the
    current pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  goTo: aPoint @{FG TEXT}

    Move the drawing point to the given aPoint.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawLine: fromPoint to: endPoint @{FG TEXT}

    Draw a line fromPoint to endPoint using the current pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  drawPoint: atPoint @{FG TEXT}

    Draw a pixel atPoint using the current pen colors.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  @{FG SHINE}
  direction @{FG TEXT}

    This method returns a @{" Radian " LINK "RadianClass"} value, indicating the current direction
    that the @{B}Pen@{UB} will go with the @{I}go:@{UI} method.
  @{FG SHINE}
  direction: radianAngle @{FG TEXT}

    Set the direction that the @{B}Pen@{UB} will go with the @{I}go:@{UI} method.
  @{FG SHINE}        
  erase @{FG TEXT}

    Fill the Plot Window with the background color & erase all Plotting.  
  @{FG SHINE}
  extent @{FG TEXT}

    Return a @{" Point " LINK "PointClass"} that indicates the width @ height of the Plot Window.  
  @{FG SHINE}
  location @{FG TEXT}

    Return a @{" Point " LINK "PointClass"} that indicates the x @ y of the 
    plotter's location.
  @{FG SHINE}
  center @{FG TEXT}

    Move the current plotting location to the center of the Plot Window.  
  @{FG SHINE}
  tellPens @{FG TEXT}

    Return a @{" Point " LINK "PointClass"} that indicates the fpen @ bpen
    of the Plot Window.
  @{FG SHINE}
  setPens: penSet @{FG TEXT}

    Change the fpen @ bpen values to (penSet x) @ (penSet y) respectively.
  @{FG SHINE}
  go: anAmount @{FG TEXT}

    Move the plotting location anAmount in the current direction.
    anAmount is a scalar value (@{" Integer " LINK "IntegerClass"} or @{" Float " LINK "FloatClass"}).
  @{FG SHINE}
  turn: addedAngle @{FG TEXT}

    Change the current direction by the given addedAngle (in @{" Radians " LINK "RadianClass"}).
  @{FG SHINE}
  titleIs @{FG TEXT}

    Return a @{" String " LINK "StringClass"} that corresponds to the title of the plot window.
    
  SEE ALSO @{" FormPen " LINK "FormPenClass"}, @{" SavePen " LINK "SavePenClass"}, @{" ShowPen " LINK "ShowPenClass"} 

@ENDNODE

@NODE "FormPenClass" "FormPen Class:"
@PREV "PenClass"
@NEXT "ObjectClass"

  The class @{B}FormPen@{UB} is a sub-class of @{" Pen " LINK "PenClass"} that allows the User
  to put together a collection (actually a @{" Bag " LINK "Bag_SetClass"}) of lines.
  
  This class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}
  
    Initialize the @{B}FormPen@{UB} class instance.
  @{FG SHINE}
  add: startingPoint to: endPoint @{FG TEXT}

    Add a line with the given points to the instance.
  @{FG SHINE}
  with: aPen displayAt: location @{FG TEXT}

    Draw all the lines contained in the @{B}FormPen@{UB} using the given aPen.
    aPen is of class @{" Pen " LINK "PenClass"}.
@ENDNODE

@NODE "SavePenClass" "SavePen Class:"
@PREV "PenClass"
@NEXT "ObjectClass"

  The class @{B}SavePen@{UB} is a sub-class of @{" FormPen " LINK "FormPenClass"} that allows the User
  to save a drawing made by a @{B}Pen@{UB}.  What the original author of
  this class means by @{B}save@{UB} isn't quite clear.
  
  This class responds to the following methods:
  @{FG SHINE}
  setForm: aForm @{FG TEXT}
   
    Initialize the instance variable with aForm of class @{" Form " LINK "FormClass"}.
  @{FG SHINE}
  goTo: aPoint @{FG TEXT}
   
    Add a line from the current location to aPoint of class @{" Point " LINK "PointClass"}
    to @{B}aForm@{UB}.
@ENDNODE

@NODE "ShowPenClass" "ShowPen Class:"
@PREV "PenClass"
@NEXT "ObjectClass"

  The class @{B}ShowPen@{UB} is a sub-class of @{" Pen " LINK "PenClass"} that allows the User
  to see some fancy uses of the @{B}Pen@{UB} class.
  
  This class responds to the following methods:
  @{FG SHINE}  
  withPen: aPen @{FG TEXT}
  
    Initialize the instance variable(s) (aPen is of class @{" Pen " LINK "PenClass"}.
  @{FG SHINE}
  poly: nSides length: length @{FG TEXT}

    Draw a ploygon with the given number of sides each with the given
    length.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!  Also, there is no such thing as a
              ploygon with less than 3 sides, but this method doesn't
              perform any check for this!
  @{FG SHINE}
  spiral: n angle: a @{FG TEXT}  

    Draw a spiral with the given number of segments (which is also the
    length of the segments), changing the direction angle by @{B}a@{UB} @{" Radians " LINK "RadianClass"}.
    @{FG SHINE}
    WARNING:  @{FG TEXT}There is no bounds checking for this, so make sure you keep
              inside the Plot Window!
  
@ENDNODE

@NODE "FormClass" "Form Class:" 
@PREV "Main"
@NEXT "ObjectClass"

  The class @{B}Form@{UB} is a sub-class of @{" Object " LINK "ObjectClass"} that allows the 
  User to draw figures using ASCII text.  This class is @{B}NOT@{UB} ported to 
  the graphic capabilities of the Amiga, so don't expect to get any useful
  pictures with it.  I've just left the Smalltalk code as descriptions
  of what the methods actually do.  Use class @{" Pen " LINK "PenClass"} or the @{" Curses " LINK "Curses.guide/Main"} 
  primitives (in @{B}AmigaTalk:User/Curses.st@{UB}) for drawing simple 
  pictures instead.
  
  This class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}

    Initialize the instance of @{B}Form@{UB}.
  @{FG SHINE}
  clipFrom: upperLeft to: lowerRight @{FG TEXT}

    "You figure it out:"
    ! newForm newRow rsize left top rText !

    left    <- upperLeft  y - 1.  " left hand side"
    top     <- upperLeft  x - 1.
    rsize   <- lowerRight y - left.
    newForm <- Form new.

    (upperLeft x to: lowerRight x) 
       do: [:i |
             newRow <- String new: rsize.
             rText  <- self   row: i.

             (1 to: rsize) 
                do: [:j |
                      newRow at: j
                            put: (rText at: (left + j)
                       ifAbsent: [$ ])
                    ].

             newForm row: (i - top) put: newRow
           ].
    ^ newForm
  @{FG SHINE}
  columns @{FG TEXT}

      ^ text inject: 0 into: [:x :y | x max: y size ]
  @{FG SHINE}
  display @{FG TEXT}

      smalltalk clearScreen. 
      self printAt: 1 @ 1.
      '  ' printAt: 20 @ 0
  @{FG SHINE}
  eraseAt: aPoint @{FG TEXT} ! location !

     location <- aPoint copy.

     text do: [:x | (String new: (x size)) printAt: location.
                     location x: (location x + 1) ]
  @{FG SHINE}
  extent @{FG TEXT}

      ^ self rows @ self columns
  @{FG SHINE}
  first @{FG TEXT}

      ^ text first
  @{FG SHINE}
  next @{FG TEXT}

      ^ text next
  @{FG SHINE}
  overLayForm: sourceForm at: startingPoint @{FG TEXT}
    ! newRowNum rowText left rowSize !

      newRowNum <- startingPoint x.
      left      <- startingPoint y - 1.

      sourceForm do: [:sourceRow |

         rowText <- self row: newRowNum.
         rowSize <- sourceRow size.
         rowText <- rowText padTo: (left + rowSize).

         (1 to: rowSize) do: [:i |
            ((sourceRow at: i) ~= $ )
            ifTrue: [ rowText at: (left + i) 
                  put: (sourceRow at: i)]].

             self row: newRowNum put: rowText.
         newRowNum <- newRowNum + 1]
  @{FG SHINE}
  placeForm: sourceForm at: startingPoint @{FG TEXT} 
    ! newRowNum rowText left rowSize !

      newRowNum <- startingPoint x.
      left      <- startingPoint y - 1.

      sourceForm do: [:sourceRow |
         rowText <- self row: newRowNum.
         rowSize <- sourceRow size.

         rowText <- rowText padTo: (left + rowSize).
         (1 to: rowSize) do: [:i |
            rowText at: (left + i) 
               put: (sourceRow at: i)].

         self row: newRowNum put: rowText.
         newRowNum <- newRowNum + 1]
  @{FG SHINE}
  reversed @{FG TEXT} ! newForm columns newRow !

      columns <- self columns.
      newForm <- Form new.

      (1 to: self rows) do: [:i |
         newRow <- text at: i.
         newRow <- newRow , 
            (String new: (columns - newRow size)).
         newForm row: i put: newRow reversed ].

      ^ newForm
  @{FG SHINE}
  rotated @{FG TEXT} ! newForm rows newRow !

      rows <- self rows.
      newForm <- Form new.

      (1 to: self columns) do: [:i |
         newRow <- String new: rows.

         (1 to: rows) do: [:j |
            newRow at: ((rows - j) + 1)
               put: ((text at: j)
                  at: i ifAbsent: [$ ])].

         newForm row: i put: newRow ].

      ^ newForm
  @{FG SHINE}
  row: index @{FG TEXT}

      ^ text at: index ifAbsent: ['']
  @{FG SHINE}
  row: index put: aString @{FG TEXT}

      (index > text size)
         ifTrue: [ [text size < index] whileTrue:
                                       [text <- text grow: ''] ].

      text at: index put: aString
  @{FG SHINE}
  rows @{FG TEXT}

      ^ text size
  @{FG SHINE}
  printAt: aPoint @{FG TEXT} ! location !

      location <- aPoint copy.

      text do: [:x | x printAt: location.
                    location x: ((location x) + 1) ]

@ENDNODE

@NODE UndefinedObjectClass "UndefinedObject Class:"

  The pseudo variable @{I}nil@{UI} is an instance (usually the only instance)
  of the class @{B}UndefinedObject@{UB}.  @{I}nil@{UI} is used to represent undefined 
  values, and is also typically returned in error situations.  @{I}nil@{UI} is also
  used as a terminator in sequences, as for example in response to the 
  message @{B}next@{UB} when there are no further elements in a sequence.

  @{U}Examples:@{UU}            @{U}Printed result:@{UU}

  nil isNil            True

  This class responds to the following methods:
  @{FG SHINE}
  isNil @{FG TEXT}
    
    Overrides method found in Object.  Return true.
  @{FG SHINE}
  notNil @{FG TEXT}
    
    Overrides method found in Object.  Return false.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Return @{I}'nil'@{UI}.

@ENDNODE

@NODE SymbolClass "Symbol Class:"

  Instances of the class @{B}Symbol@{UB} are created either by their literal 
  representation, which is a pound sign followed by a string of nonspace
  characters (for example @{I}#aSymbol@{UI}), or by the message @{U}asSymbol@{UU} being
  passed to an object.  Symbols cannot be created using @{B}new@{UB}.  Symbols 
  are guaranteed to have unique representations; that is, two symbols 
  representing the same characters will always test equal to each other.
  Inside of literal arrays, the leading pound signs on symbols can be 
  eliminated, for example:  @{I}#( these are symbols )@{UI}.

  @{U}Examples:@{UU}                @{U}Printed result:@{UU}

  #abc == #abc             True
  #abc == #ABC             False
  #abc ~~ #ABC             True
  #abc printString         #abc
  'abc' asSymbol           #abc
  #do:ifAbsent: numArgs    2
  
  This class responds to the following methods:
  @{FG SHINE}
  == @{FG TEXT}
    
    Return true if the two symbols represent the same characters, false 
    otherwise.
  @{FG SHINE}
  asString @{FG TEXT}
    
    Return a @{B}String@{UB} representation of the symbol without the 
    leading pound sign.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Return a @{B}String@{UB} representation of the symbol, including the 
    leading pound sign.
  @{FG SHINE}  
  numArgs @{FG TEXT}
    
    Return the number of arguments that the receiver would require
    if it were to be interpreted as a message.
    
@ENDNODE

@NODE BooleanClass "Boolean Class:"

  The class @{B}Boolean@{UB} provides protocol for manipulating true and false
  values.  The pseudo-variables @{I}true@{UI} and @{I}false@{UI} are instances of the
  subclasses of Boolean; @{B}True@{UB} and @{B}False@{UB}, respectively.  The subclasses
  True and False, in combination with blocks, are used to implement con-
  ditional control structures.  Note, however, that the bytecodes may 
  optimize conditional tests by generating code in-line, rather than using
  message passing.  Note that bit-wise boolean operations are provided by
  class @{B}Integer@{UB}.

  @{U}Examples:@{UU}                  @{U}Printed result:@{UU}
  (1 > 3) & (2 < 4)          False
  (1 > 3) | (2 < 4)          True
  (1 > 3) and: [2 < 4]       False

  This Class responds to the following methods:
  @{FG SHINE}
    & @{FG TEXT}
        
      The argument must be a boolean.  Return the logical conjunction (and)
      of the two values.
  @{FG SHINE}
    | @{FG TEXT}
        
      The argument must be a boolean.  Return the logical disjunction (or)
      of the two values.
  @{FG SHINE}
    and: aBlock @{FG TEXT}
        
      The argument must be a block.  Return the logical conjunction (and) 
      of the two values.  If the receiver is false the second argument
      is not used, otherwise the result is the value yielded in evaluating
      the argument block.
  @{FG SHINE}
    or: aBlock @{FG TEXT}
        
      The argument must be a block.  Return the logical disjunction (or) 
      of the two values.  If the receiver is true the second argument
      is not used, otherwise the result is the value yielded in evaluating
      the argument block.
  @{FG SHINE}
    eqv: aBoolean @{FG TEXT}
        
      The argument must be a boolean.  Return the logical equivalence (eqv)
      of the two values.
  @{FG SHINE}
    xor: aBoolean @{FG TEXT}
        
      The argument must be a boolean.  Return the logical exclusive or 
      (xor) of the two values.

@ENDNODE

@NODE TrueClass "True Class:"

  The pseudo-variable @{I}true@{UI} is an instance (usually the only instance) of
  the class @{B}True@{UB}.

  @{U}Examples:@{UU}               @{U}Printed result:@{UU}
  (3 < 5) not             False
  (3 < 5) ifTrue: [17]    17

  This Class responds to the following methods:
  @{FG SHINE}
  ifTrue: trueAlternativeBlock @{FG TEXT}
    
    Return the result of evaluating the argument block.
  @{FG SHINE}
  ifFalse: falseAlternativeBlock @{FG TEXT}
  
    Return @{I}nil@{UI}.
  @{FG SHINE}
  ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock @{FG TEXT}

    Return the result of evaluating the first argument block.
  @{FG SHINE}
  ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock @{FG TEXT}

    Return the result of evaluating the second argument block.
  @{FG SHINE}
  not @{FG TEXT}
    
    Return @{I}false@{UI}.

@ENDNODE

@NODE FalseClass "False Class:"

  The pseudo-variable @{I}false@{UI} is an instance (usually the only instance) of
  the class @{B}False@{UB}.

  @{U}Examples:@{UU}                  @{U}Printed result:@{UU}
  (1 < 3) ifTrue:  [17]      17
  (1 < 3) ifFalse: [17]      nil

  This Class responds to the following methods:
  @{FG SHINE}
  ifTrue: trueAlternativeBlock @{FG TEXT}
  
    Return @{I}nil@{UI}.
  @{FG SHINE}
  ifFalse: falseAlternativeBlock @{FG TEXT}
    
    Return the result of evaluating the argument block.
  @{FG SHINE}
  ifTrue: trueAlternativeBlock ifFalse: falseAlternativeBlock @{FG TEXT}

    Return the result of evaluating the second argument block.
  @{FG SHINE}
  ifFalse: falseAlternativeBlock ifTrue: trueAlternativeBlock @{FG TEXT}

    Return the result of evaluating the first argument block.
  @{FG SHINE}
  not @{FG TEXT}
    
    Return @{I}true@{UI}.

@ENDNODE

@NODE MagnitudeClass "Magnitude Class:"

  The class @{B}Magnitude@{UB} provides protocol for those subclasses possessing 
  a linear ordering.  For the sake of efficiency, most subclasses redefine
  some or all of the relational messages.  All methods are defined in 
  terms of the basic messages @{I}<@{UI}, @{I}=@{UI} and @{I}>@{UI}, which are in turn defined circu-
  larly in terms of each other.  Thus each subclass of @{B}Magnitude@{UB} must 
  redefine at least one of these messages.

  @{U}Examples:@{UU}                          @{U}Printed result:@{UU}
  $A max: $a                         $a
  4 between: 3.1 and: (17/3)         True

  This Class responds to the following methods:
  @{FG SHINE}
  < @{FG TEXT}
    
    Relational less than test.  Returns a boolean.
  @{FG SHINE}
  <= @{FG TEXT}
    
    Relational less than or equal test.
  @{FG SHINE}
  = @{FG TEXT}
    
    Relational equal test.  @{B}Note that this differs from @{I}==@{UI}, 
    which is an object equality test.@{UB}
  @{FG SHINE}
  ~= @{FG TEXT}
    
    Relational not equal test, opposite of @{I}=@{UI}.
  @{FG SHINE}
  >= @{FG TEXT}
    
    Relational greater than or equal test.
  @{FG SHINE}
  > @{FG TEXT}
    
    Relational greater than test.
  @{FG SHINE}
  between: low and: high @{FG TEXT}
    
    Relational test for inclusion.
  @{FG SHINE}
  max: arg @{FG TEXT}
    
    Return the maximum of the receiver and argument value.
  @{FG SHINE}
  min: arg @{FG TEXT}
    
    Return the minimum of the receiver and argument value.

@ENDNODE

@NODE CharClass "Char Class:"

  This class defines protocol for objects with character values.
  Characters possess an ordering given by the underlying representation,
  however arithmetic is not defined for character values.  Characters are
  written literally by preceding the character desired with a dollar sign,
  for example: @{B}$a   $B   $$@{UB}.

  @{U}Examples:@{UU}             @{U}Printed result:@{UU}
  $A < $0               False
  $A asciiValue         65
  $A asString           A
  $A printString        $A
  $A isVowel            True
  $A digitValue         10

  This Class responds to the following methods:
  @{FG SHINE}
  == @{FG TEXT}
    
    Object equality test.  Two instances of the same character always 
    test equal.
  @{FG SHINE}
  asciiValue @{FG TEXT}
    
    Return an @{B}Integer@{UB} representing the ASCII value of the receiver.
  @{FG SHINE}
  asLowercase @{FG TEXT}
    
    If the receiver is an uppercase letter returns the same letter in 
    lowercase, otherwise returns the receiver.
  @{FG SHINE}
  asUppercase @{FG TEXT}
    
    If the receiver is a lowercase letter returns the same letter in 
    uppercase, otherwise returns the receiver.
  @{FG SHINE}
  asString @{FG TEXT}
    
    Return a length one string containing the receiver.  Does not contain
    leading dollar sign, compare to @{I}printString@{UI}.
  @{FG SHINE}
  digitValue @{FG TEXT}
    
    If the receiver represents a number (for example @{I}$9@{UI}) return 
    the digit value of the number.  If the receiver is an uppercase
    letter (for example @{I}$B@{UI}) return the position of the number in 
    the uppercase letters + 10, (@{I}$B@{UI} returns 11, for example).  If 
    the receiver is neither a digit nor an uppercase letter an error is 
    given and @{I}nil@{UI} returned.
  @{FG SHINE}
  isAlphaNumeric @{FG TEXT}

    Respond true if receiver is either digit or letter, false otherwise.
  @{FG SHINE}
  isDigit @{FG TEXT}
    
    Respond true if receiver is a digit, false otherwise.
  @{FG SHINE}
  isLetter @{FG TEXT}
    
    Respond true if receiver is a letter, false otherwise.
  @{FG SHINE}
  isLowercase @{FG TEXT}
    
    Respond true if receiver is a lowercase letter, false otherwise.
  @{FG SHINE}
  isSeparator @{FG TEXT}
    
    Respond true if receiver is a space, tab or newline, false otherwise.
  @{FG SHINE}
  isUppercase @{FG TEXT}
    
    Respond true if receiver is an uppercase letter, false otherwise.
  @{FG SHINE}
  isVowel @{FG TEXT}
    
    Respond true if receiver is $a, $e, $i, $o or $u, in either upper or 
    lower case.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Respond with a string representation of the character value.  Includes
    leading dollar sign, compare to @{I}asString@{UI}, which does not
    include $.

@ENDNODE

@NODE NumberClass "Number Class:"

  The class @{B}Number@{UB} is an abstract superclass for @{B}Integer@{UB} and @{B}Float@{UB}.
  Instances of @{B}Number@{UB} cannot be created directly.  Relational messages 
  and many arithmetic messages are redefined in each subclass for arguments
  of the appropriate type.  In general, an error message is given and @{I}nil@{UI}
  returned for illegal arguments.

  @{U}Examples:@{UU}              @{U}Printed result:@{UU}
  3 < 4.1                True
  3 + 4.1                7.1
  3.14159 exp            23.1406
  9 gamma                40320
  5 reciprocal           0.2
  0.5 radians            0.5 radians
  13 roundTo: 5          15
  13 truncateTo: 5       10

  This Class responds to the following methods:
  @{FG SHINE}
  maxtype: aNumber @{FG TEXT}

    Return the receiver if the receiver has greater generality than the
    argument, otherwise return the argument coerced into being the same
    type as the receiver.
  @{FG SHINE}
  = aNumber @{FG TEXT}
    
    Compare the Receiver with the argument, return true if they are the
    same type, false otherwise.
  @{FG SHINE}
  < aNumber @{FG TEXT}
    
    Return true if the Receiver has less generality than the argument,
    false otherwise.
  @{FG SHINE}
  > aNumber @{FG TEXT}

    Return true if the Receiver has greater generality than the argument,
    false otherwise.
  @{FG SHINE}
  + aNumber @{FG TEXT}
    
    Mixed type addition.
  @{FG SHINE}
  - aNumber @{FG TEXT}
    
    Mixed type subtraction.
  @{FG SHINE}
  * aNumber @{FG TEXT}
    
    Mixed type multiplication
  @{FG SHINE}
  / aNumber @{FG TEXT}
    
    Mixed type division.
  @{FG SHINE}
  ^ aNumber @{FG TEXT}
    
    Exponentiation, same as @{I}raisedTo:@{UI}.
  @{FG SHINE}
  \@ aNumber @{FG TEXT}
    
    Construct a point with coordinates being the receiver and the argument.
  @{FG SHINE}
  abs @{FG TEXT}
    
    Absolute value of the receiver.
  @{FG SHINE}
  exp @{FG TEXT}
    
    e raised to the power represented by the receiver.
  @{FG SHINE}
  gamma @{FG TEXT}
    
    Return the gamma function (generalized factorial) evaluated at the 
    receiver.
  @{FG SHINE}
  ln @{FG TEXT}
    
    Natural logarithm of the receiver.
  @{FG SHINE}
  log: aNumber @{FG TEXT}
    
    Logarithm in the given base.
  @{FG SHINE}
  negated @{FG TEXT}
    
    The arithmetic inverse of the receiver.
  @{FG SHINE}
  negative @{FG TEXT}
    
    True if the receiver is negative.
  @{FG SHINE}
  pi @{FG TEXT}
    
    Return the approximate value of the receiver multiplied by (3.1415926).
  @{FG SHINE}
  positive @{FG TEXT}
    
    True if the receiver is positive (>= 0).
  @{FG SHINE}
  radians @{FG TEXT}
    
    Argument converted into radians.
  @{FG SHINE}
  raisedTo: aNumber @{FG TEXT}
    
    The receiver raised to the argument value.
  @{FG SHINE}
  reciprocal @{FG TEXT}
    
    The arithmetic reciprocal of the receiver.
  @{FG SHINE}
  roundTo: aNumber @{FG TEXT}
    
    The receiver rounded to units of the argument (see the source in
    AmigaTalk:General/Number.st).
  @{FG SHINE}
  sign @{FG TEXT}
    
    Return -1, 0 or 1 depending upon whether the receiver is negative, 
    zero or positive, respectively.
  @{FG SHINE}
  sqrt @{FG TEXT}
    
    Square root.  @{I}nil@{UI} if receiver is less than zero.
  @{FG SHINE}
  squared @{FG TEXT}
    
    Return the receiver multiplied by itself.
  @{FG SHINE}
  strictlyPositive @{FG TEXT}

    True if the receiver is greater than zero.
  @{FG SHINE}
  to: highValue @{FG TEXT}
    
    Interval from Receiver to argument value (highValue) with step of 1.
  @{FG SHINE}
  to: highValue by: stepSize @{FG TEXT}
    
    Interval from Receiver to argument (highValue) in given steps.
  @{FG SHINE}
  truncatedTo: aNumber @{FG TEXT}
    
    The receiver truncated to units of the argument.  (see the source in
    AmigaTalk:General/Number.st).

@ENDNODE

@NODE IntegerClass "Integer Class:"

  The class @{B}Integer@{UB} provides protocol for objects with integer values.

  @{U}Examples:@{UU}            @{U}Printed result:@{UU}

  5 + 4                7
  5 allMask: 4         True
  4 allMask: 5         False
  5 anyMask: 4         True
  5 bitAnd: 3          1
  5 bitOr: 3           7
  5 bitInvert          -6
  254 radix: 16        16rFE
  -5 // 4              -2
  -5 quo: 4            -1
  -5 intNegRem: 4      1
  -5 rem: 4            -1
  8 factorial          40320

  This Class responds to the following methods:
  @{FG SHINE}
  = aNumber @{FG TEXT}

    Return true if the Receiver & the argument are equal, false otherwise.
  @{FG SHINE}
  > aNumber @{FG TEXT}

    Return true if the Receiver is greater than the argument, false 
    otherwise.
  @{FG SHINE}
  < aNumber @{FG TEXT}
    Return true if the Receiver is less than the argument, false otherwise.
  @{FG SHINE}
  + aNumber @{FG TEXT}

    Return the sum of the Receiver & the argument.
  @{FG SHINE}
  - aNumber @{FG TEXT}
    
    Return the difference between the Receiver & the argument.
  @{FG SHINE}
  * aNumber @{FG TEXT}

    Return the product of the Receiver & the argument.
  @{FG SHINE}
  / aNumber @{FG TEXT}
    
    Return the quotient of the Receiver & the argument.
  @{FG SHINE}
  // aNumber @{FG TEXT}
    
    Integer quotient, truncated towards  negative infinity (compare to 
    @{I}quo:@{UI}).
  @{FG SHINE}
  intNegRem: aNumber @{FG TEXT}
    
    Integer remainder, truncated towards negative infinity (compare to 
    @{I}rem:@{UI}).
  @{FG SHINE}
  allMask: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB}.  Treating receiver and argument as
    bit strings, return @{I}true@{UI} if all bits with 1 value in argument
    correspond to bits with 1 values in the receiver.
  @{FG SHINE}
  anyMask: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB}.  Treating receiver and argument as 
    bit strings, return true if any bit with 1 value in argument corres-
    ponds to a bit with value 1 in the receiver.
  @{FG SHINE}
  asCharacter @{FG TEXT}
    
    Return the @{" Char " LINK "CharClass"} with the same underlying ASCII representation as the 
    low order eight bits of the receiver.
  @{FG SHINE}
  asFloat @{FG TEXT}
    
    Return a floating point value with same magnitude as receiver.
  @{FG SHINE}  
  asHex @{FG TEXT}

    Return the Receiver as a HexaDecimal @{" String " LINK "StringClass"}.
  @{FG SHINE}  
  asBinary @{FG TEXT}

    Return the Receiver as a binary @{" String " LINK "StringClass"}.
  @{FG SHINE}  
  asOctal @{FG TEXT}
  
    Return the Receiver as an octal @{" String " LINK "StringClass"}.
  @{FG SHINE}
  bitAnd: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB}.  Treating the receiver and argument
    as bit strings, return logical @{I}and@{UI} of values.
  @{FG SHINE}
  bitAt: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB} greater than 0 and less than under-
    lying word size.  Treating receiver as a bit string, return the bit 
    value at the given position, numbering from low order (or rightmost)
    position.
  @{FG SHINE}
  bitInvert @{FG TEXT}
    
    Return the receiver with all bit positions logically inverted.
  @{FG SHINE}
  bitOr: anInteger @{FG TEXT}
    
    Return logical @{I}or@{UI} of values.
  @{FG SHINE}
  bitShift: anInteger @{FG TEXT}
    
    Treating the receiver as a bit string, shift bit values by amount 
    indicated by @{I}anInteger@{UI}.  Negative values shift right, positive left.
  @{FG SHINE}
  bitXor: anInteger @{FG TEXT}
    
    Return logical @{I}xor@{UI} of values.
  @{FG SHINE}
  even @{FG TEXT}
    
    Return true if receiver is even, false otherwise.
  @{FG SHINE}
  factorial @{FG TEXT}
    
    Return the factorial of the receiver.  Return is a @{" Float " LINK "FloatClass"} for large 
    numbers.
  @{FG SHINE}
  gcd: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB}.  Return the greatest common divisor
    of the receiver and argument.
  @{FG SHINE}
  highBit @{FG TEXT}
    
    Return the location of the highest 1 bit in the receiver.  Return 
    @{I}nil@{UI} if the Receiver is zero.
  @{FG SHINE}
  lcm: anInteger @{FG TEXT}
    
    Argument must be @{B}Integer@{UB}.  Return least common multiple of 
    receiver and argument.
  @{FG SHINE}
  noMask: anInteger @{FG TEXT}
    
    Argument must be Integer.  Treating receiver and argument as bit 
    strings, return true if no 1 bit in the argument corresponds to a 1
    bit in the receiver.
  @{FG SHINE}
  odd @{FG TEXT}
    
    Return true if receiver is odd, false otherwise.
  @{FG SHINE}
  quo: anInteger @{FG TEXT}
    
    Return quotient of Receiver divided by argument.
  @{FG SHINE}
  radix: aNumber @{FG TEXT}
    
    Return a string representation of the receiver value, printed in the 
    base represented by @{I}aNumber.  aNumber@{UI} value must be <= 36
    and >= to 2.
  @{FG SHINE}
  asSignedHex @{FG TEXT}
    
    Same as @{B}asHex@{UB} only the Integer is treated as a signed quantity.
  @{FG SHINE}
  asSignedBinary @{FG TEXT}

    Same as @{B}asBinary@{UB} only the Integer is treated as a signed quantity.
  @{FG SHINE}
  asSignedOctal @{FG TEXT}

    Same as @{B}asOctal@{UB} only the Integer is treated as a signed quantity.
  @{FG SHINE}
  rem: anInteger @{FG TEXT}
    
    Remainder after receiver is divided by argument value.
  @{FG SHINE}
  timesRepeat: aBlock @{FG TEXT}
    
    Repeat argument block the number of times given by the receiver.


@ENDNODE

@NODE "LongIntegerClass" "LongInteger Class:"

   LongInteger Class is for 64-Bit integer representation.  
   Since there are four functions in utility.library that 
   produce 64-bit quantities, I felt that a separate Class 
   should make use of them.

   @{B}signed32BitDivide@{UB}     is really the SDivMod32() function.
   @{B}unsigned32BitDivide@{UB}   is really the UDivMod32() function.
   @{B}signed64BitMultiply@{UB}   is really the SMult64()   function.
   @{B}unsigned64BitMultiply@{UB} is really the UMult64()   function.

   NOTE:  Primitives for addition & subtraction will be added later.

   Methods are:
   @{FG SHINE}
   = aNumber @{FG TEXT}

      Return @{B}true@{UB} if the receiver is equal to @{I}aNumber@{UI}.
   @{FG SHINE}
   > aNumber @{FG TEXT}

      Return @{B}true@{UB} if the receiver is greater than @{I}aNumber@{UI}.
   @{FG SHINE}
   < aNumber @{FG TEXT}

      Return @{B}true@{UB} if the receiver is less than @{I}aNumber@{UI}.
   @{FG SHINE}
   asString @{FG TEXT}

      Return the receiver as a @{" String " LINK "StringClass"} Object.
   @{FG SHINE}
   asFloat @{FG TEXT}

      Return the receiver as a @{" Float " LINK "FloatClass"} Object.
   @{FG SHINE}
   even @{FG TEXT}

      Return @{B}true@{UB} if the receiver is an even number.
   @{FG SHINE}
   odd @{FG TEXT}

      Return @{B}true@{UB} if the receiver is an odd number.
   @{FG SHINE}
   getLower32Bits @{FG TEXT}

      Return the lower 32 Bits of the receiver.
   @{FG SHINE}
   getUpper32Bits @{FG TEXT}

      Return the upper 32 Bits of the receiver.
   @{FG SHINE}
   signed32BitDivide: dividend by: divisor @{FG TEXT}

      Perform some LongInteger signed division.
      @{I}dividend & divisor@{UI} are 32-Bit Integers, upper32Bits is 
      really the Quotient & lower32Bits is really the Remainder.
   @{FG SHINE}
   unsigned32BitDivide: dividend by: divisor @{FG TEXT}

      Perform some LongInteger unsigned division.
      @{I}dividend & divisor@{UI} are 32-Bit Integers, upper32Bits is 
      really the Quotient & lower32Bits is really the Remainder.
   @{FG SHINE}
   signed64BitMultiply: arg1 times: arg2 @{FG TEXT}

      Evaluate a signed 64-bit product.  @{I}arg1 & arg2@{UI} are 
      NOT necessarily 64-bit Integers.
   @{FG SHINE}
   unsigned64BitMultiply: arg1 times: arg2 @{FG TEXT}

      Evaluate an unsigned 64-bit product.  @{I}arg1 & arg2@{UI} are 
      NOT necessarily 64-bit Integers.
   @{FG SHINE}
   quotientIs @{FG TEXT}

      Return the Quotient of a @{B}signed/unsigned32BitDivide:@{UB} method.
   @{FG SHINE}
   remainderIs @{FG TEXT}

      Return the Remainder of a @{B}signed/unsigned32BitDivide:@{UB} method.

@ENDNODE

@NODE FloatClass "Float Class:"

  The class @{B}Float@{UB} provides protocol for objects with floating point values.

  @{U}Examples:@{UU}              @{U}Printed result:@{UU}
  4.2 * 3                12.6
  2.1 |^ 4               19.4481
  2.1 raisedTo: 4        19.4481
  0.5 arcSin             0.523599 radians
  2.1 reciprocal         0.47619
  4.3 sqrt               2.07364

  This Class responds to the following methods:
  @{FG SHINE}
  = aNumber @{FG TEXT}

    Return true if the Receiver & the argument have the same value, false
    otherwise.
  @{FG SHINE}
  < aNumber @{FG TEXT}
 
    Return true if the receiver is less than the argument.
  @{FG SHINE}
  > aNumber @{FG TEXT}

    Return true if the receiver is greater than the argument.
  @{FG SHINE}
  + aNumber @{FG TEXT}

    Return the sum of the Receiver & the argument.
  @{FG SHINE}
  - aNumber @{FG TEXT}

    Return the difference of the Receiver & the argument.
  @{FG SHINE}
  * aNumber @{FG TEXT}

    Return the product of the Receiver & the argument.
  @{FG SHINE}
  / aNumber @{FG TEXT}

    Return the quotient of the Receiver & the argument.
  @{FG SHINE}
  ^ aNumber @{FG TEXT}
    Floating point exponentiation.
  @{FG SHINE}
  arcCos @{FG TEXT}
    
    Return a @{B}Radian@{UB} representing the arcCos of the receiver.
  @{FG SHINE}
  arcSin @{FG TEXT}
    
    Return a @{B}Radian@{UB} representing the arcSin of the receiver.
  @{FG SHINE}
  arcTan @{FG TEXT}
    
    Return a @{B}Radian@{UB} representing the arcTan of the receiver.
  @{FG SHINE}
  asFloat @{FG TEXT}
    
    Return the receiver.
  @{FG SHINE}
  ceiling @{FG TEXT}

    Return the @{B}Integer@{UB} ceiling of the receiver.
  @{FG SHINE}
  coerce: aNumber @{FG TEXT}
    
    Convert the argument into being type @{B}Float@{UB}.
  @{FG SHINE}
  exp @{FG TEXT}
    
    Return e raised to the receiver value.
  @{FG SHINE}
  floor @{FG TEXT}
    
    Return the @{B}Integer@{UB} floor of the receiver.
  @{FG SHINE}
  fractionPart @{FG TEXT}
    
    Return the fractional part of the receiver.
  @{FG SHINE}
  gamma @{FG TEXT}
    
    Return the value of the gamma function applied to the receiver value.
  @{FG SHINE}
  integerPart @{FG TEXT}
    
    Return the integer part of the receiver.
  @{FG SHINE}
  ln @{FG TEXT}
    
    Return the natural log of the receiver.
  @{FG SHINE}
  radix: aNumber @{FG TEXT}
    
    Return a string containing the printable representation of the receiver
    in the given radix.  Argument must be an @{B}Integer@{UB} <= 36 and
    >= 2.
  @{FG SHINE}
  rounded @{FG TEXT}
    
    Return the receiver rounded to the nearest integer.
  @{FG SHINE}
  sqrt @{FG TEXT}
    
    Return the square root of the receiver.
  @{FG SHINE}
  truncated @{FG TEXT}
    
    Return the receiver truncated to the nearest integer.

@ENDNODE

@NODE RadianClass "Radian Class:"

  The class @{B}Radian@{UB} is used to represent radians.  Radians are a unit of 
  measurement, independent of other numbers.  Only radians will respond 
  to the trigonometric functions such  as @{I}sin & cos@{UI}.  Numbers can be
  converted into radians by passing them the message @{I}radians@{UI}.  Similarly,
  radians can be converted into numbers by sending them the message 
  @{I}asFloat@{UI}.  Notice that only a limited range of arithmetic operations 
  are permitted on Radians.  Radians are normalized to be between 0 and
  2 * @{" pi " LINK "NumberClass"}.

  @{U}Examples:@{UU}              @{U}Printed result:@{UU}
  0.5236 radians sin     0.5
  0.5236 radians cos     0.866025
  0.5236 radians tan     0.577352
  0.5 arcSin asFloat     0.523599

  This Class responds to the following methods:
  @{FG SHINE}
  new: x @{FG TEXT}

    Create a new instance of Class @{B}Radian@{UB} from x normalized to between 
    0 & 2 * pi.
  @{FG SHINE}
  < arg @{FG TEXT}

    Return true if the Receiver is less than the argument.
  @{FG SHINE}
  = arg @{FG TEXT}

    Return true if the argument is equal to the Receiver.
  @{FG SHINE}
  asFloat @{FG TEXT}
    
    Return the receiver as a floating point number.
  @{FG SHINE}
  cos @{FG TEXT}

    Return a floating point number representing the cosine of the receiver.
  @{FG SHINE}
  sin @{FG TEXT}
    
    Return a floating point number representing the sine of the receiver.
  @{FG SHINE}
  tan @{FG TEXT}
    
    Return a floating point number representing the tangent of the re-
    ceiver.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Display the Reciever as a String in the Status Window.
   
@ENDNODE

@NODE PointClass "Point Class:"

  @{B}Point@{UB}s are used to represent pairs of quantities, such
  as coordinate pairs.

  @{U}Examples:@{UU}                  @{U}Printed result:@{UU}
  (10@12) < (11@14)          True
  (10@12) < (11@11)          False
  (10@12) max: (11@11)       11@12
  (10@12) min: (11@11)       10@11
  (10@12) dist: (11@14)      2.23607
  (10@12) transpose          12@10

  This Class responds to the following methods:
  @{FG SHINE}
  < aPoint @{FG TEXT}
    
    True if both values of the receiver are less than the corresponding 
    values in the argument.
  @{FG SHINE}
  <= aPoint @{FG TEXT}
    
    True if the first value is less than or equal to the corresponding 
    value in the argument, and the second value is less than the
    corresponding value in the argument.
  @{FG SHINE}
  >= aPoint @{FG TEXT}
    
    True if both values of the receiver are greater than or equal to the 
    corresponding values in the argument.
  @{FG SHINE}
  * scale @{FG TEXT}
    
    Return a new point with coordinates multiplied by the argument value.
  @{FG SHINE}
  / scale @{FG TEXT}
    
    Return a new point with coordinates divided by the argument value.
  @{FG SHINE}
  // scale @{FG TEXT}
    
    Return a new point with coordinates divided by the argument value.
  @{FG SHINE}
  + delta @{FG TEXT}
    
    Return a new point with coordinates offset by the corresponding 
    values in the argument.
  @{FG SHINE}
  abs @{FG TEXT}
    
    Return a new point with coordinates having the absolute value of the 
    receiver.
  @{FG SHINE}
  dist: aPoint @{FG TEXT}
    
    Return the Euclidean distance between the receiver and the argument 
    point.
  @{FG SHINE}
  max: aPoint @{FG TEXT}
    
    The argument must be a @{B}Point@{UB}.  Return the lower right corner
    of the rectangle defined by the receiver and the argument.
  @{FG SHINE}
  min: aPoint @{FG TEXT}
    
    The argument must be a @{B}Point@{UB}.  Return the upper left corner 
    of the rectangle defined by the receiver and the argument.
  @{FG SHINE}
  transpose @{FG TEXT}
    
    Return a new point with coordinates being the transpose of the re-
    ceiver.
  @{FG SHINE}
  x @{FG TEXT}
    
    Return the first coordinate of the receiver.
  @{FG SHINE}
  x: aValue @{FG TEXT}
    
    Set the first coordinate of the receiver.
  @{FG SHINE}
  x: xValue y: yValue @{FG TEXT}
    
    Sets both coordinates of the receiver.
  @{FG SHINE}
  y @{FG TEXT}
    
    Return the second coordinate of the receiver.
  @{FG SHINE}
  y: aValue @{FG TEXT}
    
    Set the second coordinate of the receiver.

@ENDNODE

@NODE RandomClass "Random Class:"

  The class @{B}Random@{UB} provides protocol for random number generation.  
  Sending the message @{I}next@{UI} to an instance of @{B}Random@{UB} results in a @{B}Float@{UB} 
  between 0.0 and 1.0, randomly distributed.  By default, the pseudo-random
  sequence is the same for each object in class @{B}Random@{UB}.  This can be 
  altered using the message "randomize".

  @{U}Examples:@{UU}                   @{U}Printed result:@{UU}
  i <- Random new
  i next                      0.759
  i next                      0.157
  i next: 3                   #( 0.408 0.278 0.547 )
  i randInteger: 12           5
  i between: 4 and: 17.5      10.0

  This Class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}

    Initialize the seed Object to 1.
  @{FG SHINE}    
  between: low and: high @{FG TEXT}
    
    Return a random number uniformly distributed between the two arguments.
  @{FG SHINE}
  first @{FG TEXT}
    
    Return a random number between 0.0 and 1.0.  This message merely 
    provides consistency with protocol for other sequences, such as 
    @{B}Array@{UB}s or @{B}Interval@{UB}s.
  @{FG SHINE}
  next @{FG TEXT}
    
    Return a random number between 0.0 and 1.0.
  @{FG SHINE}
  next: n @{FG TEXT}
    
    Return an @{B}Array@{UB} containing the next n random numbers, where 
    n is the argument value.
  @{FG SHINE}
  randInteger: limit @{FG TEXT}
    
    The argument must be an @{B}Integer@{UB}.  Return a random integer 
    between 1 and the value given.
  @{FG SHINE}
  randomize @{FG TEXT}
    
    Change the pseudo-random number generator seed by a time dependent 
    value.

@ENDNODE

@NODE CollectionClass "Collection Class:"

  The class @{B}Collection@{UB} provides protocol for groups of objects, such as
  @{B}Array@{UB}s or @{B}Set@{UB}s. The different forms of collections are distinguished
  by several characteristics, among them whether the size of the collection
  is fixed or unbounded, the presence or absence of an ordering, and their
  insertion or access method.  For example, an @{B}Array@{UB} is a collection with 
  a fixed size and ordering, indexed by integer keys.  A @{B}Dictionary@{UB}, on
  the other hand, has no fixed size or ordering, and can be indexed by 
  arbitrary elements.  Nevertheless, @{B}Array@{UB}s and @{B}Dictionary@{UB}s share many 
  features in common, such as their access method (@{I}at:@{UI} and @{I}at:put:@{UI}), and
  the ability to respond to @{I}collect:, select:@{UI}, and many other messages.

  The table below lists some of the characteristics of several forms 
  of collections:
  ___________________________________________________________________
@{FG SHINE}
   Name         Creation    Size    Ordered?   Insertion    Access
                 Method    fixed?               method      method@{FG TEXT}
  ___________________________________________________________________

   Bag/Set        new        no        no        add:      includes:

   Dictionary     new        no        no       at:put:       at:

   Interval     n to: m     yes       yes        none         at:

   List           new        no       yes      addFirst:     first
                                               addLast:      last

   Array          new:      yes       yes       at:put:       at:

   String         new:      yes       yes       at:put:       at:

  ___________________________________________________________________

  @{U}Examples:@{UU}                        @{U}Printed result:@{UU}
  i <- 'abacadabra'
  i size                           10
  i asArray                        #( $a $b $a $c $a $d $a $b $r $a )
  i asBag                          Bag ( $a $a $a $a $a $r $b $b $c $d)
  i asSet                          Set ( $a $r $b $c $d )
  i occurrencesOf: $a              5
  i reject: [:x | x isVowel]       bcdbr

  The Collection class responds to the following methods:
  @{FG SHINE}
  addAll: aCollection @{FG TEXT}
    
    The argument must be a @{B}Collection@{UB}.  Add all the elements of 
    the argument collection to the receiver collection.
  @{FG SHINE}
  asArray @{FG TEXT}
    
    Return a new collection of type @{B}Array@{UB} containing the
    elements from the receiver collection.  If the receiver was ordered, 
    the elements will be in the same order in the new collection, otherwise
    the elements will be in an arbitrary order.
  @{FG SHINE}
  asBag @{FG TEXT}
    
    Return a new collection of type @{B}Bag@{UB} containing the elements 
    from the receiver collection.
  @{FG SHINE}
  asList @{FG TEXT}
    
    Return a new collection of type @{B}List@{UB} containing the
    elements from the receiver collection.  If the receiver was ordered, 
    the elements will be in the same order in the new collection, otherwise
    the elements will be in an arbitrary order.
  @{FG SHINE}
  asSet @{FG TEXT}
    
    Return a new collection of type @{B}Set@{UB} containing the elements 
    from the receiver collection.
  @{FG SHINE}
  asString @{FG TEXT}
    
    Return a new collection of type @{B}String@{UB} containing the
    elements from the receiver collection.  The elements to be included 
    must all be of type @{B}Character@{UB}.  If the receiver was ordered, 
    the elements will be in the same order in the new collection, otherwise
    the elements will be listed in an arbitrary order.
  @{FG SHINE}
  coerce: aCollection @{FG TEXT}
    
    The argument must be a @{B}Collection@{UB}.  Return a collection,
    of the same type as the receiver, containing elements from the argument
    collection.  This message is redefined in most subclasses of 
    @{B}Collection@{UB}.
  @{FG SHINE}
  collect: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Return a new collection, 
    like the receiver, containing the result of evaluating the argument 
    block on each element of the receiver collection.
  @{FG SHINE}
  detect: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Return the first element 
    in the receiver collection for which the argument block evaluates true.
    Report an error and return "nil" if no such element exists.  Note that
    in unordered collections (such as @{B}Bag@{UB}s or @{B}Dictionary@{UB}s)
    the first element to be encountered that will satisfy the condition may
    not be easily predictable.
  @{FG SHINE}
  detect: aBlock ifAbsent: exceptionBlock @{FG TEXT}

    Return the first element in the receiver collection for which the first
    argument block evaluates true.  Return the result of evaluating the 
    second argument if no such element exists.
  @{FG SHINE}
  includes: anObject @{FG TEXT}
    
    Return true if the receiver collection contains the argument.
  @{FG SHINE}
  inject: thisValue into: binaryBlock @{FG TEXT}
    
    The first argument must be a value, the second a two argument block.  
    The second argument is evaluated once for each element in the receiver
    collection, passing as arguments the result of the previous evaluation
    (starting with the first argument) and the element.  The value returned
    is the final value generated.
  @{FG SHINE}
  isEmpty @{FG TEXT}
    
    Return true if the receiver collection contains no elements.
  @{FG SHINE}
  occurrencesOf: anObject @{FG TEXT}

    Return the number of times the argument occurs in the receiver col-
    lection.
  @{FG SHINE}
  remove: oldObject @{FG TEXT}
    
    Remove the argument from the receiver collection.  Report an error if 
    the element is not contained in the receiver collection.
  @{FG SHINE}
  remove: oldObject ifAbsent: exceptionBlock @{FG TEXT}

    Remove the first argument from the receiver collection.  Evaluate the 
    second argument if not present.
  @{FG SHINE}
  reject: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Return a new collection 
    like the receiver containing all elements for which the argument block
    returns false.
  @{FG SHINE}
  select: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Return a new collection 
    like the receiver containing all elements for which the argument block
    returns true.
  @{FG SHINE}
  size @{FG TEXT}
    
    Return the number of elements in the receiver collection.
  @{FG SHINE}
  shallowCopy @{FG TEXT}

    Return a copy of the receiver. 
  @{FG SHINE}
  printString @{FG TEXT}

    print the Collection into the Status Window.
           
@ENDNODE

@NODE Bag_SetClass "Bags & Sets Classes:"

  @{B}Bag@{UB}s and @{B}Set@{UB}s are each unordered collections of elements.  Elements in
  the collections do not have keys, but are added and removed directly.
  The difference between a @{B}Bag@{UB} and a @{B}Set@{UB} is that each element can occur
  any number of times in a @{B}Bag@{UB}, whereas only one copy is inserted into
  a @{B}Set@{UB}.

  @{U}Examples:@{UU}                                     @{U}Printed result:@{UU}

  i <- (1 to: 6) asBag                                Bag ( 1 2 3 4 5 6 )
  i size                                              6
  i select: [:x | (x intNegRem: 2) strictlyPositive]  Bag ( 1 3 5 )
  i collect: [:x | x intNegRem: 3]                    Bag ( 0 0 1 1 2 2 )
  j <- ( i collect: [:x | x intNegRem: 3] ) asSet     Set ( 0 1 2 )
  j size                                              3

  Note:  Since Bags and Sets are unordered, there is no way  to
  establish a mapping between the elements of the @{B}Bag@{UB} i in the
  example above and the corresponding elements in the  collection that
  resulted from the message @{I}collect: [:x | x intNegRem: 3]@{UI}.

  This Class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}
    
    (@{B}Set@{UB} only) Initialize a new instance of @{B}Set@{UB}.
   
  @{FG SHINE}
  add: newElement @{FG TEXT}

    Add the indicated element to the receiver collection.
  @{FG SHINE}
  add: newObj withOccurences: anInteger @{FG TEXT}

    (@{B}Bag@{UB} only) Add the indicated element to the
    receiver @{B}Bag@{UB} the given number of times.
  @{FG SHINE}
  first @{FG TEXT}
    
    Return the first element from the receiver collection.  As the col-
    lection is unordered, the first element depends upon certain values in
    the internal representation, and is not guaranteed to be any specific 
    element in the collection.
  @{FG SHINE}
  next @{FG TEXT}
    
    Return the next element in the collection.  In conjunction with 
    @{I}first@{UI}, this can be used to access each element of the col-
    lection in turn.
  @{FG SHINE}
  remove: oldElement ifAbsent: exceptionBlock @{FG TEXT}

    Remove the element from a Bag or Set or evaluate the exceptionBlock if
    the oldElement is NOT present.
  @{FG SHINE}
  size @{FG TEXT}

    Return the number of Elements in the @{B}Set or Bag@{UB}.
  @{FG SHINE}
  occurrencesOf: anElement @{FG TEXT}

    ^ dict at: anElement ifAbsent: [0] "for a @{B}Bag@{UB}."

    ^ (list includes: anElement) ifTrue: [1] ifFalse: [0] "for a @{B}Set@{UB}."

@ENDNODE

@NODE KCollectionClass "KeyedCollection Class:"

  The class @{B}KeyedCollection@{UB} provides protocol for collections with keys,
  such as @{B}Dictionary@{UB}s and @{B}Array@{UB}s.  Since each entry in the collection has
  both a key and value, the method @{I}add:@{UI} is no longer appropriate.  Instead,
  the method @{I}at:put:@{UI}, which provides both a key and a value, must be used.

  @{U}Examples:@{UU}                           @{U}Printed result:@{UU}
  i <- 'abacadabra'
  i atAll: (1 to: 7 by: 2) put: $e    ebecedebra
  i indexOf: $r                       9
  i atAll: i keys put: $z             zzzzzzzzzz
  i keys                              Set ( 1 2 3 4 5 6 7 8 9 10 )
  i values                            Bag ( $z $z $z $z $z $z $z $z $z $z )
  #(how odd) asDictionary             Dictionary ( 1 @ #how 2 @ odd )

  This class responds to the following methods:
  @{FG SHINE}
  add: anElement @{FG TEXT}

    Returns an error @{B}String@{UB} (no key!).
  @{FG SHINE}
  addAll: aCollection @{FG TEXT}

    Add the elements of the argument to the Receiver.
  @{FG SHINE}
  asDictionary @{FG TEXT} 

    Return a new collection of type @{B}Dictionary@{UB} containing the 
    elements from the receiver collection.
  @{FG SHINE}
  at: key @{FG TEXT}

    Return the item in the receiver collection whose key matches the 
    argument.  Produces and error message, and returns @{I}nil@{UI}, if no
    item is currently in the receiver collection under the given key.
  @{FG SHINE}
  at:ifAbsent: @{FG TEXT}

    Return the element stored in the dictionary under the key given by the 
    first argument.  Return the result of evaluating the second argument if
    no such element exists.
  @{FG SHINE}
  atAll: aCollection put: anObject @{FG TEXT}
    
    The first argument must be a collection containing keys valid for the 
    receiver.  At each location given by a key in the first argument
    place the second argument.
  @{FG SHINE}
  binaryDo: aBlock @{FG TEXT}
    
    The argument must be a two argument block.  This message is similar to
    @{I}do:@{UI}, however both the key and the element value are passed as
    arguments to the block.
  @{FG SHINE}
  includesKey: key @{FG TEXT}
    
    Return true if the indicated key is valid for the receiver collection.
  @{FG SHINE}
  indexOf: anElement @{FG TEXT}
    
    Return the key value of the first element in the receiver collection 
    matching the argument.  Produces an error message if no such element 
    exists.  Note that, as with the message @{I}detect:@{UI}, in unordered
    collections the first element may not be related in any way to the 
    order in which elements were placed into the collection, but is rather
    implementation dependent.
  @{FG SHINE}
  indexOf: anElement ifAbsent: exceptionBlock @{FG TEXT}

    Return the key value of the first element in the receiver collection 
    matching the argument.  Return the result of evaluating the second 
    argument if no such element exists.
  @{FG SHINE}
  select: aBlock @{FG TEXT}
    
    Select elements from the Collection based on their values.
  @{FG SHINE}
  keys @{FG TEXT}
    
    Return a @{" Set " LINK "Bag_SetClass"} containing the keys for the receiver collection.
  @{FG SHINE}
  keysDo: aBlock @{FG TEXT}
    
    The argument must be a one argument block.  Similar to @{B}do:@{UB}, 
    except that the values passed to the block are the keys of the receiver
    collection.
  @{FG SHINE}
  keysSelect: aBlock @{FG TEXT}
    
    Similar to @{B}select@{UB}, except that the selection is made on the 
    basis of keys instead of values.
  @{FG SHINE}
  remove: anElement @{FG TEXT}

    Returns an error @{B}String@{UB} -- (no key!). (Default behavior).
  @{FG SHINE}
  removeKey: key @{FG TEXT}
    
    Remove the object with the given key from the receiver collection.  
    Print an error message, and return @{I}nil@{UI}, if no such object 
    exists.  Return the value of the deleted item.
  @{FG SHINE}
  removeKey: key ifAbsent: exceptionBlock @{FG TEXT}

    Remove the object with the given key from the receiver collection.  
    Return the result of evaluating the second argument if no such
    object exists.
  @{FG SHINE}
  values @{FG TEXT}
    
    Return a @{" Bag " LINK "Bag_SetClass"} containing the values from the receiver 
    collection.

@ENDNODE

@NODE DictionaryClass "Dictionary Class:"

  A @{B}Dictionary@{UB} is an unordered collection of elements, as are @{B}Bag@{UB}s and
  @{B}Set@{UB}s.  However, unlike these collections, elements inserted and removed
  from a @{B}Dictionary@{UB} must reference an explicit key.  Both the key and 
  value portions of an element can be any object, although commonly the 
  keys are instances of @{B}Symbol@{UB} or @{B}Number@{UB}.

  @{U}Examples:@{UU}              @{U}Printed result:@{UU}
  i <- Dictionary new
  i at: #abc put: #def
  i at: #pqr put: #tus
  i at: #xyz put: #wrt
  i print                Dictionary ( #abc @ #def #pqr @ #tus #xyz @ #wrt )
  i size                 3
  i at: #pqr             #tus
  i indexOf: #tus        #pqr
  i keys                 Set ( #abc #pqr #xyz )
  i values               Bag ( #wrt #def # tus )

  This class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}
  
    Initialize a new Dictionary, 17 elements in size.
  @{FG SHINE}
  hashNumber: aKey @{FG TEXT}

    Compute the hash Number for the given Key.  
  @{FG SHINE}
  getList: aKey @{FG TEXT}
  
    Return a @{" List " LINK "LinkedListClass"} starting at @{I}aKey@{UI}.   
  @{FG SHINE}
  at: aKey put: anObject @{FG TEXT}
  
    Place the second argument into the receiver under the key given by 
    the first argument.
  @{FG SHINE}
  removeKey: aKey ifAbsent: exceptionBlock @{FG TEXT}

    Remove an entry from the Dictionary.
  @{FG SHINE}     
  findAssociation: aKey inList: linkedList @{FG TEXT}

    If aKey is in the linkedList, return the item, else return nil.
  @{FG SHINE}
  currentKey @{FG TEXT}
    
    Return the key of the last element yielded in response to a @{I}first@{UI} 
    or @{I}next@{UI} Method.
  @{FG SHINE}
  first @{FG TEXT}
    
    Return the first element of the receiver collection.  Return @{I}nil@{UI} 
    if the receiver collection is empty.
  @{FG SHINE}
  next @{FG TEXT}
    
    Return the next element of the receiver collection, or @{I}nil@{UI} if
    no such element exists.
  @{FG SHINE}
  printString @{FG TEXT}

    Display the currentKey & associated value as a Point.
  @{FG SHINE}    
  checkBucket: bucketNumber @{FG TEXT}
    
    Check to see if the bucketNumber is nil, if it is, return nil,
    otherwise return the first element of the currentList.

@ENDNODE

@NODE AmigaTalkClass "AmigaTalk Class:"

  The class @{B}AmigaTalk@{UB} provides protocol for the pseudo-variable 
  @{I}amigatalk or smalltalk@{UI} (use @{I}amigatalk@{UI} in new code).

  Since it is a subclass of @{B}Dictionary@{UB}, this variable can be used to store
  information, and thus provide a means of communication between objects.
  Other messages modify various parameters used by the AmigaTalk system.

  This class is set up as a Singleton class, so that there is only one copy
  of the global Dictionary. 

  ALL singleton classes contain the following:

    the methods:  isSingleton AND privateSetup AND
                  uniqueInstance Class instance variable.

  @{U}Examples:@{UU}                                   @{U}Printed result:@{UU}
  atalk <- AmigaTalk new
  atalk date                                  Fri Apr 12 16:15:42 1985
  atalk perform: #+ withArguments: #(2 5)     7
  atalk doPrimitive: 10 withArguments: #(2 5) 7

  AmigaTalk responds to the following methods:
  @{FG SHINE}
  isSingleton @{FG TEXT} 
    
    Simply returns @{I}true@{UI}.
  @{FG SHINE}
  getByteCodeArrayFrom: aClass for: aMethodString @{FG TEXT}

    Returns a @{" ByteCodeArray " LINK "ByteArrayClass"} from @{I}aClass@{UI} for @{I}aMethodString@{UI}, if @{I}aClass@{UI}
    responds to @{I}aMethodString@{UI}.  This method is only for examining
    how a method has been translated into byteCodes.
  @{FG SHINE}
  date @{FG TEXT}
    
    Return the current date and time as a string.
  @{FG SHINE}
  printString@{FG TEXT}
  
    Override the parent @{I}printString@{UI} method.  
  @{FG SHINE}
  globalDictionary @{FG TEXT}
    
    Return the global Dictionary object.
  @{FG SHINE}
  addGlobal: newGlobal key: newKey@{FG TEXT}
  
    Add a new entry to the global Dictionary.
  @{FG TEXT}
  @{FG SHINE}
  clearScreen @{FG TEXT}
    
    Erase any Curses or Plot3 windows.
  @{FG SHINE}
  debug: n @{FG TEXT}
    
    Change the AmigaTalk debug flag to n (0 = OFF or 1 = ON).
  @{FG SHINE}
  display @{FG TEXT}
    
    Set execution display (Status Window) to display the result of every 
    expression typed, but not for assignments.  Note that the display 
    behavior can also be modified using the PRINTCMD=1 (formerly -d1) 
    argument on the command line.
    There is also a menu item for this, attached to the Command Window.
  @{FG SHINE}
  displayAssign @{FG TEXT} 

    Set execution display to display the result of every expression typed,
    including assignment statements.  Equivalent to using the PRINTCMD=2
    argument when first starting the @{B}AmigaTalk@{UB} system.
    There is also a menu item for this, attached to the Command Window.
  @{FG SHINE}
  noDisplay @{FG TEXT}
    
    Turn off execution display - no results will be displayed unless 
    explicitly requested by the user.
    There is also a menu item for this, attached to the Command Window.
  @{FG SHINE}
  doPrimitive: primNumber withArguments: argArray @{FG TEXT}

    Execute the indicated primitive with arguments given by the second 
    array.  A few primitives (such as those dealing with process manage-
    ment) cannot be executed in this manner.
  @{FG SHINE}
  sh: sysCommand @{FG TEXT}
    
    The argument, which must be a String, is executed as an AmigaDOS 
    command by the shell.  The value returned is the termination status 
    number of the shell.
    @{FG SHINE}WARNING: @{FG TEXT} Know what you're doing when you use this method!
  @{FG SHINE}
  time: aBlock @{FG TEXT}
    
    The argument must be a block.  The block is executed, and the number 
    of seconds elapsed during execution returned.  Time is only accurate 
    to within about one second.
  @{FG SHINE}
  getProcessAddress: procName @{FG TEXT}
    
    Return an Integer representing the Address of the named Amiga-OS
    Process.
  @{FG SHINE}
  getTaskAddress: taskName @{FG TEXT}

    Return an Integer representing the Address of the named Amiga-OS
    Task.
  @{FG SHINE}
  getScreenAddress: screenName @{FG TEXT}

    Return an Integer representing the Address of the named Amiga-OS
    Screen.  screenName is the displayed title of the @{" Screen " LINK "Intuition.guide/ScreenClass"}.
  @{FG SHINE}
  getWindowAddress: windowName @{FG TEXT}

    Return an Integer representing the Address of the named Amiga-OS
    Window.  windowName is the displayed title of the @{" Window " LINK "Intuition.guide/WindowClass"}.
  @{FG SHINE}
  getStringAddress: aString @{FG TEXT}

    Return an Integer representing the Address of @{I}aString@{UI}.
    NOT Kosher smalltalk, DO NOT USE!
  @{FG SHINE}
   getIntegerAddress: anInteger @{FG TEXT}

    Return an Integer representing the Address of @{I}anInteger@{UI}.
    NOT Kosher smalltalk, DO NOT USE!
  @{FG SHINE}
   getByteArrayAddress: aByteArray @{FG TEXT}

    Return an Integer representing the Address of @{I}aByteArray@{UI}.
    NOT Kosher smalltalk, DO NOT USE!
  @{FG SHINE}
  getTaskAddressList @{FG TEXT}
    
    Return an @{" Array " LINK "ArrayClass"} of Amiga-Task addresses.
  @{FG SHINE}
  getProcessAddressList @{FG TEXT}
    
    Return an Array of Amiga-Process addresses.
  @{FG SHINE}
  getScreenAddressList @{FG TEXT}

    Return an Array of @{" Screen " LINK "Intuition.guide/ScreenClass"} addresses.
  @{FG SHINE}
  getWindowAddressList @{FG TEXT} 

    Return an Array of @{" Window " LINK "Intuition.guide/WindowClass"} addresses.
  @{FG SHINE}
  showTaskProcessList @{FG TEXT}

    Display a Requester that lists all current System Tasks & Processes.
    Returns an Integer representing the address of the last structure
    selected in the ListView.
  @{FG SHINE}
  showScreenWindowList @{FG TEXT}

    Display a Requester that lists all current System Screens & Windows.
    Returns an Integer representing the address of the last structure
    selected in the ListView.
  @{FG SHINE}
  displayProcessInfo: procAddress @{FG TEXT}

    Display a Requester that lists the System Process structure.
  @{FG SHINE}
  displayTaskInfo: taskAddress @{FG TEXT}

    Display a Requester that lists the System Task structure.
  @{FG SHINE}
  displayScreenInfo: screenAddress @{FG TEXT}

    Display a Requester that lists the System @{" Screen " LINK "Intuition.guide/ScreenClass"} structure.
  @{FG SHINE}
  displayWindowInfo: windowAddress @{FG TEXT}

    Display a Requester that lists the System @{" Window " LINK "Intuition.guide/WindowClass"} structure.
  @{FG SHINE}
  newIO: msgString title: title @{FG TEXT}
    
    Initialize the instance variables used for methods that allow the
    User to use Amiga GUIs to get Strings, Integers, ScreenModes, display
    Files, display Strings or to display Integers.  This method is 
    equivalent to calling @{B}setIOMessage:@{UB} followed by @{B}setIOTitle:@{UB}
  @{FG SHINE}
  setIOMessage: newMessage @{FG TEXT}      
    
    Change the display message for getString, getInteger, displayString &
    displayInteger.
  @{FG SHINE}
  setIOTitle: newTitle @{FG TEXT}
    
    Change the display title for getString, getInteger, displayString &
    displayInteger.
  @{FG SHINE}
  setIODirectory: newDirectory @{FG TEXT}
    
    Change the starting directory for @{I}getFileName@{UI}.  This method is
    identical to @{I}setIOMessage@{UI}, but it's easier to see what your program is
    doing if you call @{I}getFileName@{UI} afterwards.
  @{FG SHINE}
  setIOScreenName: newScreenName @{FG TEXT}
    
    Change the Screen Name for @{I}getScreenModeID@{UI}.  This method is
    identical to @{I}setIOMessage@{UI}, but it's easier to see what your program is
    doing if you call @{I}getScreenModeID@{UI} afterwards.
  @{FG SHINE}
  getString @{FG TEXT}

    Show the User a GUI that asks them to enter a @{" String " LINK "StringClass"}.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method, in
          order to have a Requester title & a Request to display!
  @{FG SHINE}
  getInteger @{FG TEXT}

    Show the User a GUI that asks them to enter an @{" Integer " LINK "IntegerClass"}.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!
  @{FG SHINE}
  getFileName @{FG TEXT}

    Show the User the ASL file Requester & ask them to enter a filename.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!
  @{FG SHINE}
  getScreenModeID @{FG TEXT}

    Show the User the ASL ScreenMode Requester & ask them to select a 
    screen mode.  This method @{B}DOES NOT@{UB} change the current Screen Mode
    being used, it simply returns an Integer that corresponds to the 
    ScreenModeID selected.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!
  @{FG SHINE}  
  displayFile: fileName @{FG TEXT}

    Display the contents of a file to the User, using the contents of the
    @{B}FileDisplayer ToolType@{UB} as the file display program.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!
  @{FG SHINE}
  displayString: string @{FG TEXT}

    Display a @{" String " LINK "StringClass"} to the User in a GUI.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!
  @{FG SHINE}
  displayInteger: integer @{FG TEXT}

    Display an @{" Integer " LINK "IntegerClass"} to the User in a GUI.
    @{B}NOTE:@{UB}  @{I}newIO:title:@{UI} has to be called before this method!

  @{FG SHINE}
  listClassDictionaryTo: fileName indent: numSpaces @{FG TEXT}

    Write a list of all Classes currently known to AmigaTalk to the 
    given @{I}fileName@{UI}, indenting subclasses by @{I}numSpaces@{UI}.
  @{FG SHINE}
  listClassesOf: classObj to: fileName indent: numSpaces @{FG TEXT}

    Write a list of all subclasses of @{I}classObj@{UI} currently known to 
    AmigaTalk to the given @{I}fileName@{UI}, indenting subclasses by 
    @{I}numSpaces@{UI}.
  @{FG SHINE}
  fileInPrimitiveFile: fileName @{FG TEXT}
    
    Read in a primitive file & incorporate it into the current AmigaTalk
    environment.  Primitive files end with @{I}.p@{UI} (NOT enforced) 
    & represent parsed Class source code.
    @{FG SHINE}
    WARNING:  Since there is no way of checking, make sure that the file
              is debugged BEFORE you use this! @{FG TEXT}
  @{FG SHINE}
  activeScreen @{FG TEXT}

    Returns a @{" Screen " LINK "Intuition.guide/ScreenClass"} Object that represents the currently active Screen.
  @{FG SHINE}
  activeWindow @{FG TEXT}
 
    Returns a @{" Window " LINK "Intuition.guide/WindowClass"} Object that represents the currently active Window 
    or nil.

  @{FG SHINE}
  addUserScript: scriptMenuName toCall: scriptFileName@{FG TEXT}
    
    Adds the given scriptMenuName to the @{B}USER SCRIPTS@{UB} menu of the main
    AmigaTalk Command Window & allows the User to select & execute the 
    scriptFileName as if it were selected & loaded from @{I}Load Commands File...@{UI}
    Returns true if successful.
    @{FG SHINE}
    NOTE: @{FG TEXT} Added menu items are currently NOT saved when the AmigaTalk program
           exits.  If you want a permanent menu item, add it to the 
           @{B}InitializeCommands@{UB} Script that AmigaTalk executes on startup &
           be sure to remove them using the @{I}removeUserScript:@{UI} method in the
           @{B}UpdateCommands@{UB} Script.  This is necessary to clean up the
           memory allocations used by this method.  These Scripts are both located 
           in the AmigaTalk:C/ directory.
           
  @{FG SHINE} 
  removeUserScript: scriptMenuName @{FG TEXT}

    Removes the given scriptMenuName from the @{B}USER SCRIPTS@{UB} menu of the main
    AmigaTalk Command Window.

  NOTE:  All other methods are purposely NOT documented because the User 
         should not be using them.
   
@ENDNODE

@NODE SCollectionClass "SequenceableCollection Class:"

  The class @{B}SequenceableCollection@{UB} contains protocol for collections 
  that have a definite sequential ordering and are indexed by integer 
  keys.  Since there is a fixed order for elements, it is possible to 
  refer to the last element in a @{B}SequenceableCollection@{UB}.

  @{U}Examples:@{UU}                               @{U}Printed result:@{UU}
  i <- 'abacadabra'
  i copyFrom: 4 to: 8                     cadab
  i copyWith: $z                          abacadabraz
  i copyWithout: $a                       bcdbr
  i findFirst: [:x | x > $m]              9
  
  i indexOfSubCollection: 'dab' startingAt: 16
  
  i reversed                              arbadacaba
  i , i reversed                          abacadabraarbadacaba
  i sort: [:x :y | x >= y]                rdcbbaa

  This class responds to the following methods:
  @{FG SHINE}
  , aCollection @{FG TEXT}
    
    Appends the argument collection to the receiver collection, returning 
    a new collection of the same type as the receiver.
  @{FG SHINE}
  copyFrom: start to: stop @{FG TEXT}
    
    Return a new collection, like the receiver, containing the designated 
    sub-portion of the receiver collection.
  @{FG SHINE}
  copyWith: newElement @{FG TEXT}   
    
    Return a new collection, like the receiver, with the argument added 
    to the end.
  @{FG SHINE}
  copyWithout: oldElement @{FG TEXT}
    
    Return a new collection, like the receiver, with all occurrences of 
    the argument removed.
  @{FG SHINE}
  equals: aSubCollection startingAt: anIndex @{FG TEXT}

    The first argument must be a @{B}SequenceableCollection@{UB}.  Return 
    true if each element of the receiver collection is equal to the cor-
    responding element in the argument offset by the amount given in the 
    second argument.
  @{FG SHINE}
  findFirst: aBlock @{FG TEXT}  
    
    Find the key for the first element whose value satisfies the argument
    block.  Produce an error message if no such element exists.
  @{FG SHINE}
  findFirst: aBlock ifAbsent: exceptionBlock @{FG TEXT}

    Both arguments must be blocks.  Find the key for the first element 
    whose value satisfies the first argument block.  If no such element
    exists return the value of the second argument.
  @{FG SHINE}
  findLast: aBlock @{FG TEXT}
    
    Find the key for the last element whose value satisfies the argument 
    block.  Produce an error message if no such element exists.
  @{FG SHINE}
  findLast: aBlock ifAbsent: exceptionBlock @{FG TEXT}

    Both arguments must be blocks.  Find the key for the last element 
    whose value satisfies the first argument block.  If no such element
    exists return the value of the second argument block.
  @{FG SHINE}
  firstKey @{FG TEXT}
    
    Return the first key valid for the receiver collection.
  @{FG SHINE}
  indexOfSubCollection: aSubColl startingAt: anIndex @{FG TEXT}

    Starting at the position given by the second argument, find the next 
    block of elements in the receiver collection which match the col-
    lection given by the first argument, and return the index for the start
    of that block.  Produce an error message if no such position exists.
  @{FG SHINE}
  indexOfSubCollection: aSubColl startingAt: anIndex ifAbsent: exceptBlk @{FG TEXT}

    Similar to @{I}indexOfSubCollection:startingAt:@{UI}, except that the 
    result of the exception block is produced if no position exists 
    matching the pattern.
  @{FG SHINE}
  last @{FG TEXT}
    
    Return the last element in the receiver collection.
  @{FG SHINE}
  lastKey @{FG TEXT}
    
    Return the last key valid for the receiver collection.
  @{FG SHINE}
  replaceFrom: start to: stop with: replacementCollection @{FG TEXT}

    Replace the elements in the receiver collection in the positions in-
    dicated by the first two arguments with values taken from the col-
    lection given by the third argument.
  @{FG SHINE}
  replaceFrom: first to: stop with: repColl startingAt: repStart @{FG TEXT}

    Replace the elements in the receiver collection in the positions in-
    dicated by the first two arguments with values taken from the col-
    lection given in the third argument, starting at the position given 
    by the fourth argument.
  @{FG SHINE}
  reversed @{FG TEXT}
    
    Return a collection, like the receiver, with elements reversed.
  @{FG SHINE}
  reverseDo: aBlock @{FG TEXT}
    
    Similar to @{I}do:@{UI}, except that the items are presented in 
    reverse order.
  @{FG SHINE}
  select: aBlock @{FG TEXT}
  
    Return a new Collection like the receiver containing all elements for 
    which the argument Block returns true.
  @{FG SHINE}
  sort @{FG TEXT}
    
    Return a collection, like the receiver, with the elements sorted using
    the comparison @{I}<=@{UI}.  Elements must be able to respond to the
    binary message @{I}<=@{UI}.
  @{FG SHINE}
  sort: sortBlock @{FG TEXT}
    
    The argument must be a two argument block which yields a boolean.  
    Return a collection, like the receiver, sorted using the argument to
    compare elements for the purpose of ordering.
  @{FG SHINE}
  with: aSequencableCollection do: aBlock @{FG TEXT}
    
    The second argument must be a two argument block.  Present one element
    from the receiver collection and from the collection given by the first
    argument in turn to the second argument block.  An error message is 
    given if the collections do not have the same number of elements.

@ENDNODE

@NODE IntervalClass "Interval Class:"

  The class @{B}Interval@{UB} represents a sequence of numbers in an arithmetic
  sequence, either ascending or descending.  Instances of Interval are 
  created by Numbers in response to the message @{I}to:@{UI} or @{I}to:by:@{UI}.  In 
  conjunction with the message @{I}do:@{UI}, Intervals create a control structure
  similar to do or for loops in Algol-like languages.  For example:

    @{FG SHINE}(from: 1 to: 10 by: 2) do: [:x | x print]@{FG TEXT}


  will print the even numbers from 2 to 10.  Although they are a col-
  lection, @{B}Intervals@{UB} cannot be added to.  They can, however, be accessed 
  randomly using the message @{I}at:ifAbsent:@{UI}.

  @{U}Examples:@{UU}                                   @{U}Printed result:@{UU}
  (7 to: 13 by: 3) asArray                    #( 7 10 13 )
  (7 to: 13 by: 3) at: 2                      10
  (1 to: 10) inject: 0 into: [:x :y | x + y]  55
  (7 to: 13) copyFrom: 2 to: 5                #( 8 9 10 11 )
  (3 to: 5) copyWith: 13                      #( 3 4 5 13 )
  (3 to: 5) copyWithout: 4                    #( 3 5 )
  (2 to: 4) equals: (1 to: 4) startingAt: 2   True

  This class responds to the following methods:
  @{FG SHINE}
  first @{FG TEXT}
    
    Produce the first element from the  interval.  Note that @{B}Intervals@{UB} 
    also respond to the message @{I}at:ifAbsent:@{UI}, which can be used 
    to produce elements in an arbitrary order.
  @{FG SHINE}
  last @{FG TEXT}

    Produce the last element from the  interval.  Note that @{B}Intervals@{UB} 
    also respond to the message @{I}at:ifAbsent:@{UI}, which can be used 
    to produce elements in an arbitrary order.
  @{FG SHINE}
  from: lowerBound to: upperBound by: stepSize @{FG TEXT}
    
    Initialize the upper and lower bounds and the step size for the 
    receiver.  (This is also used internally by methods in Number to 
    create new @{B}Intervals@{UB}).
  @{FG SHINE}
  next @{FG TEXT}
    
    Produce the next element from the @{B}Interval@{UB}.
  @{FG SHINE}
  size @{FG TEXT}
    
    Return the number of elements that will be generated in producing 
    the interval.
  @{FG SHINE}
  inRange: value @{FG TEXT}

    Return true if value is within the @{B}Interval@{UB} boundaries.
  @{FG SHINE}
  at: index ifAbsent: exceptionBlock @{FG TEXT}

    If the value lies within the @{B}Interval@{UB} boundaries, return the value,
    else evaluate the exceptionBlock.
  @{FG SHINE}
  printString @{FG TEXT}

    Display the @{B}Interval@{UB} in the Status Window.
  @{FG SHINE}
  coerce: newCollection @{FG TEXT}

    Transform the @{B}Interval@{UB} into an Array.
  @{FG SHINE}
  at: index put: value @{FG TEXT}

    This method is NOT valid for @{B}Intervals@{UB} & returns an error String.
  @{FG SHINE}
  add: val @{FG TEXT}

    This method is NOT valid for @{B}Intervals@{UB} & returns an error String.
  @{FG SHINE}
  removeKey: key ifAbsent: exceptionBlock @{FG TEXT}

    This method is NOT valid for @{B}Intervals@{UB} & returns an error String.
  @{FG SHINE}
  deepCopy @{FG TEXT}
    
    Return a copy of the @{B}Interval@{UB}.
  @{FG SHINE}
  shallowCopy @{FG TEXT}

    Same as @{I}deepCopy@{UI} method.

@ENDNODE

@NODE LinkedListClass "LinkedList Class:"

  @{B}List@{UB}s represent collections with a fixed order, but indefinite size.
  No keys are used, and elements are added or removed from one end of 
  the other.  Used in this way, @{B}List@{UB}s can perform as @{I}stacks@{UI} or as 
  @{I}queues@{UI}.  The table below illustrates how stack and queue operations
  can be implemented in terms of messages to instances of List.

  @{U}Examples:@{UU}                          @{U}Printed result:@{UU}
  i <- List new
  i addFirst: 2 / 3                  List ( 0.6666 )
  i add: $A
  i addAllLast: (12 to: 14 by: 2)
  i print                            List ( 0.6666 $A 12 14 )
  i first                            0.6666
  i removeLast                       14
  i print                            List ( 0.6666 $A 12 )

  stack operations          queue operations
  _____________________________________________________________
  @{FG SHINE}
  push         addLast:     add                     addLast:
  pop          removeLast   first in queue          first
  top          last         remove first in queue   removeFirst
  test empty   isEmpty      test empty              isEmpty@{FG TEXT}

  This class responds to the following methods:
  @{FG SHINE}
  add: anItem @{FG TEXT}

    Add the element to the beginning of the receiver collection.  This is 
    the same as @{I}addFirst:@{UI}.
  @{FG SHINE}
  addAllFirst: aCollection @{FG TEXT}
    
    The argument must be a @{B}SequenceableCollection@{UB}.  The
    elements of the argument are added, in order, to the front of the 
    receiver collection.
  @{FG SHINE}
  addAllLast: aCollection @{FG TEXT}
    
    The argument must be a @{B}SequenceableCollection@{UB}.  The
    elements of the argument are added, in order, to the end of the 
    receiver collection.
  @{FG SHINE}
  addFirst: anItem @{FG TEXT}
    
    The argument is added to the front of the receiver collection.
  @{FG SHINE}
  addLast: anItem @{FG TEXT}

    The argument is added to the back of the receiver collection.
  @{FG SHINE}
  remove: anItem @{FG TEXT}
    
    Remove the given element from the List.
  @{FG SHINE}
  remove: anItem ifAbsent: exceptionBlock @{FG TEXT}
    
    Remove an element from the List if it's present.  If it's absent,
    evaluate the @{I}exceptionBlock@{UI}.
  @{FG SHINE}
  removeFirst @{FG TEXT}  
    
    Remove the first element from the receiver collection, returning the 
    removed value.
  @{FG SHINE}
  removeLast @{FG TEXT}
    
    Remove the last element from the receiver collection, returning the 
    removed value.
  @{FG SHINE}
  first @{FG TEXT}
    
    Return the first element in the List.
  @{FG SHINE}
  next @{FG TEXT}
    
    Return the next element in the List.
  @{FG SHINE}
  current @{FG TEXT}
    
    Return the current element in the List.
  @{FG SHINE}
  last @{FG TEXT}
    
    Return the last element in the List.                
  @{FG SHINE}
  isEmpty @{FG TEXT}
    
    Return @{B}true@{UB} if the List is empty, false otherwise.
  @{FG SHINE}
  removeError @{FG TEXT}

    Return a string indicating that the User cannot remove from an empty
    List.
  @{FG SHINE}
  coerce: aCollection @{FG TEXT}
    
    Transform @{I}aCollection@{UI} into a List Object.
            
@ENDNODE

@NODE SemaphoreClass "Semaphore Class:"

  @{B}Semaphore@{UB}s are used to synchronize concurrently running Processes.
  This class is NOT the same as the Semaphores used by the AmigaOS.
  
  This class responds to the following methods:
  @{FG SHINE}
  new @{FG TEXT}
  
  A @{B}Semaphore@{UB} starts out with zero excess signals when created by
  this method.
  @{FG SHINE}
  new: numberOfSignals @{FG TEXT}
    
  A @{B}Semaphore@{UB} can be created with an arbitrary number of excess 
  signals with this method.
  @{FG SHINE}
  signal @{FG TEXT}
        
    If there is a process blocked on the semaphore it is scheduled for 
    execution, otherwise the number of excess signals is incremented by 1.
  @{FG SHINE}
  wait @{FG TEXT}
    
    If there are excess signals associated with the semaphore
    the number of signals is decremented by one, otherwise 
    the current process is placed on the semaphore queue.

@ENDNODE

@NODE FileClass "File Class:"

  A @{B}File@{UB} is a type of collection where the elements of the collection are
  stored on an external medium, typically a disk.  For this reason, 
  although most operations on collections  are defined for files, many can
  be quite slow in execution.  A file can be opened in one of three 
  @{U}modes@{UU}:  In @{I}character@{UI} mode every read returns a single character from
  the file.  In @{I}integer@{UI} mode every read returns a single word, as an
  integer value.  In @{I}string@{UI} mode every read returns a single line, as a
  @{B}String@{UB}.  For writing, character and string modes will write the string
  representation of the argument, while integer mode must write only a 
  single integer.

  @{FG SHINE}Responds To

  at: aPosition @{FG TEXT}
    
    Return the object stored at the indicated position.  Position is given 
    as a character count from the start of the file.
  @{FG SHINE}
  at: aPosition put: anObject @{FG TEXT}
    
    Place the object at the indicated position in the file.  Position is 
    given as a character count from the start of the file.
  @{FG SHINE}
  modeCharacter @{FG TEXT}

    Set the mode of the receiver file to @{I}character@{UI}.
  @{FG SHINE}
  currentKey @{FG TEXT}
  
    Return the current position in the file, as a character count from 
    the start of the file.
  @{FG SHINE}
  modeInteger @{FG TEXT} 
    
    Set the mode of the receiver file to @{I}integer@{UI}.
  @{FG SHINE}
  open: aName @{FG TEXT}
    
    Open the indicated file for reading.  The argument must be a @{B}String@{UB}.
  @{FG SHINE}
  open: aName for: opType @{FG TEXT}    
    
    The @{I}for:@{UI} argument must be one of @{B}r, w@{UB} or @{B}r+@{UB} (see
    fopen(3) in the @{I}Unix programmers manual@{UI}).  Open the file
    in the indicated mode.
  @{FG SHINE}
  close @{FG TEXT}
    
    Close a previously opened file.
  @{FG SHINE}
  read @{FG TEXT}        
    
    Return the next object from the file.
  @{FG SHINE}
  size @{FG TEXT}
    
    Return the size of the file, in character counts.
  @{FG SHINE}
  modeString @{FG TEXT}  
    
    Set the mode of the receiver file to @{I}string@{UI}.
  @{FG SHINE}
  write: anObject @{FG TEXT}      
    
    Write the argument into the file.
@ENDNODE

@NODE ACollectionClass "ArrayedCollection Class:"

  The class @{B}ArrayedCollection@{UB} provides protocol for collections with a 
  fixed size and integer keys.  Unlike other collections, which are 
  created using the message @{I}new@{UI}, instances of @{B}ArrayedCollection@{UB} must be
  created using the one argument message @{I}new:@{UI}.  The argument given with
  this message must be a positive integer, representing the size of the
  collection to be  created.   In addition to the protocol shown, many of
  the methods inherited from superclasses are redefined in this class.

  @{U}Examples:@{UU}                    @{U}Printed result:@{UU}
  'small' = 'small'            True
  'small' = 'SMALL'            False
  'small' asArray              #( $s $m $a $l $l)
  'small' asArray = 'small'    True
  #(1 2 3) padTo: 5            #(1 2 3 nil nil)
  #(1 2 3) padTo: 2            #(1 2 3)

  This class responds to the following methods:
  @{FG SHINE}
  = anArray@{FG TEXT}

    The argument must also be an @{B}Array@{UB}.  Test whether the
    receiver and the argument have equal elements listed in the same order.
  @{FG SHINE}
  at: key ifAbsent: exceptionBlock @{FG TEXT}
    
    Return the element stored with the given key.  Return the result of 
    evaluating the second argument if the key is not valid for the 
    receiver collection.
  @{FG SHINE}
  coerce: aCollection @{FG TEXT}

    Transform aCollection to an ArrayedCollection.
  @{FG SHINE}
  copyFrom: start to: stop @{FG TEXT}
    
    Return a new portion of the ArrayedCollection.
  @{FG SHINE}
  currentKey @{FG TEXT}
    
    Return the current key value.
  @{FG SHINE}  
  deepCopy @{FG TEXT}     

    Return a copy of the ArrayedCollection.  This method differs from
    shallowCopy in that more memory space is allocated from the system.
  @{FG SHINE}
  do: aBlock @{FG TEXT}
    
    Perform aBlock for each element of the ArrayedCollection.
  @{FG SHINE}
  first @{FG TEXT}

    Return the first element of the ArrayedCollection.     
  @{FG SHINE}
  firstKey @{FG TEXT}
    
    Return the index of the first element (which is always one).
  @{FG SHINE}
  lastKey @{FG TEXT}
    
    Return the index of the last element (which is equal to the size).
  @{FG SHINE}
  next @{FG TEXT}
   
    Return the next element of the ArrayedCollection.
  @{FG SHINE}
  padTo: length @{FG TEXT}

    Return an array like the received that is at least as long as the 
    argument value.  Returns the receiver if it is already longer than the 
    argument.
  @{FG SHINE}
  shallowCopy @{FG TEXT}

    Return a copy of the ArrayedCollection.
    
@ENDNODE

@NODE ArrayClass "Array Class:"

  Instances of the class @{B}Array@{UB} are perhaps the most commonly used data 
  structure in Smalltalk programs.  Arrays are represented textually by
  a pound sign preceding the list of array elements.

  @{U}Examples:@{UU}                               @{U}Printed result:@{UU}
  i <- #(110 101 97)
  i size                                  3
  i <- i grow: 116                        #( 110 101 97 116)
  i <- i collect: [:x | x asCharacter]    #( #n #e #a #t )
  i asString                              neat

  This class responds to the following methods:
  @{FG SHINE}
  at: index @{FG TEXT}
  
    Return the item stored in the position given by the argument.  An error
    message is produced, and @{I}nil@{UI} returned, if the argument is not
    a valid key.
  @{FG SHINE}
  at: index put: value @{FG TEXT}
  
    Store the second argument in the position given by the first argument.
    An error message is produced, and @{I}nil@{UI} returned, if the 
    argument is not a valid key.
  @{FG SHINE}
  grow: newElement @{FG TEXT}
  
    Return a new array one element larger than the receiver, with the 
    argument value attached to the end.  This is a slightly more efficient
    command than @{I}copyWith:@{UI}, although the effect is the same.
  @{FG SHINE}
  printString @{FG TEXT}
  
    Display the elements of the Array in the Status Window.
  @{FG SHINE}
  size @{FG TEXT}

    Return the number of elements in the Array.
  @{FG SHINE}
  new: newSize @{FG TEXT}
    
    Return a new instance of Array of the given size.

@ENDNODE

@NODE ByteArrayClass "ByteArray Class:"

  A @{B}ByteArray@{UB} is a special form of array in which the elements must be
  numbers in the range 0-255.  Instances of @{B}ByteArray@{UB} are given a very 
  compact encoding, and are used extensively internally in the AmigaTalk
  system.  A @{B}ByteArray@{UB} can be represented textually by a pound sign
  preceding the list of array elements surrounded by a pair of square 
  braces.

  @{U}Examples:@{UU}                                    @{U}Printed result:@{UU}
  i <- #[110 101 97]
  i size                                       3
  i <- i copyWith: 116                         #[ 110 101 97 116 ]
  i <- i asArray collect: [:x | x asCharacter] #( #n #e #a #t )
  i asString                                   neat

  This class responds to the following methods:
  @{FG SHINE}
  at: index @{FG TEXT}
    
    Return the item stored in the position given by the argument.  An 
    error message is produced, and @{I}nil@{UI} returned, if the argument 
    is not a valid key.
  @{FG SHINE}
  at: index put: value @{FG TEXT}

    Store the second argument in the position given by the first argument.
    An error message is produced, and @{I}nil@{UI} returned, if the 
    argument is not a valid key.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Display a representation of the array in the status window.
  @{FG SHINE}
  displayBytes: title @{FG TEXT}

    Display the array in a Requester with the given title.  This method is
    substantially faster than @{I}printString@{UI} for large @{B}ByteArrays@{UB}.
  @{FG SHINE}   
  size @{FG TEXT}

    Return the number of elements in the array.
  @{FG SHINE}    
  new: numElements @{FG TEXT}

    Make a new instance of the ByteArray Class as large as the given 
    size.  The elements are initialized to zero. 
    
@ENDNODE

@NODE StringClass "String Class:"

  Instances of the class @{B}String@{UB} are similar to @{B}Array@{UB}s, except that the 
  individual elements must be @{B}Character@{UB}.  @{B}String@{UB}s are represented literally
  by placing single quote marks around the characters making up the string.
  @{B}String@{UB}s also differ from @{B}Array@{UB}s in that @{B}String@{UB}s possess an ordering,
  given by the underlying ASCII sequence.

  @{U}Examples:@{UU}                               @{U}Printed result:@{UU}
  'example' at: 2                         $x
  'bead' at: 1 put: $r                    read
  'small' > 'BIG'                         True
  'small' sameAs: 'SMALL'                 True
  'tary' sort                             arty
  'Rats live on no evil Star' reversed    ratS live on no evil staR

  This class responds to the following methods:
  @{FG SHINE}
  , aString @{FG TEXT}
    
    Concatenates the argument to the receiver string, producing a new 
    @{B}String@{UB}.  If the argument is not a @{B}String@{UB} it is first converted
    using @{I}printString@{UI}.
  @{FG SHINE}
  = aString @{FG TEXT}
    
    Return true if the Receiver is the same as the arugment.
  @{FG SHINE}    
  < aString @{FG TEXT}
    
    The argument must be a @{B}String@{UB}.  Test if the receiver is
    lexically less than the argument.  For the purposes of 
    comparison, case differences are ignored.
  @{FG SHINE}
  <= aString @{FG TEXT}
    
    Test if the receiver is lexically less than or equal to the argument.
  @{FG SHINE}
  >= aString @{FG TEXT}
    
    Test if the  receiver is lexically greater than or equal to the argu-
    ment.
  @{FG SHINE}
  > aString @{FG TEXT}
    
    Test if the  receiver is lexically greater than the argument.
  @{FG SHINE}
  cr @{FG TEXT
    
     Return newline (ASCII value 10) as a @{B}String@{UB} object.
  @{FG SHINE}
  asSymbol @{FG TEXT}
    
    Return a @{B}Symbol@{UB} with characters given by the receiver string.
  @{FG SHINE}
  at: aNumber @{FG TEXT}
    
    Return the character stored at the position given by the argument.  
    Produce an error message, and return @{I}nil@{UI}, if the argument 
    does not represent a valid key.
  @{FG SHINE}
  at: aNumber put: aChar @{FG TEXT}

    Store the character given by second argument at the location given by 
    the first argument.  Produce an error message, and return @{I}nil@{UI},
    if either argument is invalid.
  @{FG SHINE}
  compareError @{FG TEXT}
  
    Return an error @{B}String@{UB} about string comparison.
  @{FG SHINE}
  copyFrom: start length: len @{FG TEXT}

    Return a substring of the receiver.  The substring is taken from the 
    indicated starting position in the receiver and extends for the given 
    length.  Produce an error message, and return @{I}nil@{UI}, if the 
    given positions are not legal.

  @{FG SHINE}
  copyFrom: start to: stop @{FG TEXT}
    
    Return a substring of the receiver.  The substring is taken from the 
    indicated positions.  Produce an error message, and return @{I}nil@{UI},
    if the given positions are not legal.
  @{FG SHINE}
  deepCopy @{FG TEXT}
    
    Return a copy of the Receiver.
  @{FG SHINE}
  new: size @{FG TEXT}

    Make a new @{B}String@{UB} filled with blanks of the size given.
    @{B}NOTE:@{UB}  the maximum string length is silently limited to 512 characters.
  @{FG SHINE}
  printAt: aPoint @{FG TEXT}
    
    The argument must be a @{B}Point@{UB} which describes a location on
    the @{" Curses " LINK "Curses.guide"} screen.  The string is printed at the specified
    location.
  @{FG SHINE}
  printString @{FG TEXT}
    
    Print the Receiver (with surrounding quote marks) on the Status Window.
  @{FG SHINE}
  print @{FG TEXT}

    Print the Receiver (with NO surrounding quote marks) on the Status 
    Window.
  @{FG SHINE}
  size @{FG TEXT}
  
    Return the number of characters stored in the string.
  @{FG SHINE}
  sameAs: aString @{FG TEXT}
    
    Return true if the receiver and argument string match with
    the exception of case differences.  Note that the boolean
    message @{I}=@{UI}, inherited from @{B}ArrayedCollection@{UB}, can be 
    used to see if two strings are the same including case differences.

@ENDNODE

@NODE BlockClass "Block Class:"

  Although it is easy for the programmer to think of blocks as a syntactic
  construct, or a control structure, they are actually objects, and share
  attributes of all other objects in the Smalltalk system, such as the 
  ability to respond to messages.

  @{U}Examples:@{UU}                               @{U}Printed result:@{UU}
  ['block indeed'] value                  block indeed
  [:x :y | x + y + 3] value: 5 value: 7   15

  This Class responds to the following methods:
  @{FG SHINE}
  fork @{FG TEXT}
    
    Start the block executing as a @{B}Process@{UB}.  The value @{I}nil@{UI} is
    immediately returned, and the @{B}Process@{UB} created from the 
    block is scheduled to run in parallel with the current process.
  @{FG SHINE}
  forkWith: argumentArray @{FG TEXT}
    
    Similar to @{I}fork@{UI}, except that the array is passed as
    arguments to the receiver block prior to scheduling for execution.
  @{FG SHINE}
  newProcess @{FG TEXT}
    
    A new @{B}Process@{UB} is created for the block, but is not scheduled 
    for execution.
  @{FG SHINE}
  newProcessWith: argumentArray @{FG TEXT}

    Similar to @{I}newProcess@{UI}, except that the array is passed
    as arguments to the receiver block prior to it being made into a 
    process.
  @{FG SHINE}
  value @{FG TEXT}
    
    Evaluates the receiver block.  Produces an error message, and returns 
    @{I}nil@{UI}, if the receiver block required arguments.
    Return the value yielded by the block.
  @{FG SHINE}
  value: a @{FG TEXT}

    Evaluates the receiver block.  Produces an error message, and returns 
    @{I}nil@{UI}, if the receiver block did not require a single argument.
    Return the value yielded by the block.
  @{FG SHINE}
  value: a value: b @{FG TEXT}
    
    Two argument block evaluation.
  @{FG SHINE}
  value:a value: b value: c @{FG TEXT}

    Three argument block evaluation.
  @{FG SHINE}
  value: a value: b value: c value: d @{FG TEXT}

    Four argument block evaluation.
  @{FG SHINE}
  value: a value: b value: c value: d value: e @{FG TEXT}

    Five argument block evaluation.
  @{FG SHINE}
  whileTrue: aBlock @{FG TEXT}
    
    The receiver block is repeatedly evaluated.  While it evaluates to 
    true, the argument block is also evaluated.  Return @{I}nil@{UI} when 
    the receiver block no longer evaluates to true.
  @{FG SHINE}
  whileTrue @{FG TEXT}
    
    The receiver block is repeatedly evaluated until it returns a value 
    that is not true.
  @{FG SHINE}
  whileFalse: aBlock @{FG TEXT}
    The receiver block is repeatedly evaluated.  While it evaluates to 
    false, the argument block is also evaluated.  Return @{I}nil@{UI} when
    the receiver block no longer evaluates to false.
  @{FG SHINE}
  whileFalse @{FG TEXT}
    
    The receiver block is repeatedly evaluated until it returns a value 
    that is not false.

@ENDNODE

@NODE ClassClass "Class Class:"

  The class @{B}Class@{UB} provides protocol for manipulating class instances.  An
  instance of class @{B}Class@{UB} is generated for each class in the AmigaTalk 
  system.  New instances of this class are then formed by sending messages
  to the class instance.

  @{U}Examples:@{UU}                               @{U}Printed result:@{UU}
  Array new: 3                            #( nil nil nil )
  Bag respondsTo: #add:                   True
  SequenceableCollection superClass       KeyedCollection

  The methods that Class responds to are:
  @{FG SHINE}
  edit @{FG TEXT}
    
    The user is placed into a editor editing the file from which the class
    description was originally obtained.  When the editor terminates, the 
    class description will be re-parsed and will override the previous 
    description.  See also @{I}view@{UI}.
  @{FG SHINE}
  list @{FG TEXT}
    
    Lists all subclasses of the given class recursively.  In particular, 
    @{B}Object @{I}list@{UI}@{UB} will list the names of all the
    classes in the system.
  @{FG SHINE}
  new @{FG TEXT}
    
    A new instance of the receiver class is returned.  If the methods for 
    the receiver contain protocol for @{I}new@{UI}, the new instance will 
    first be passed this message before returning.
  @{FG SHINE}
  new: aValue @{FG TEXT}
    
    A new instance of the receiver class is returned.  If the methods for 
    the receiver contain protocol for @{I}new:@{UI}, the new instance will
    first be passed this message before returning.
  @{FG SHINE}
  printClassString @{FG TEXT}
    
    Return a @{" Symbol " LINK "SymbolClass"} representing the argument Class.
  @{FG SHINE}
  respondsTo @{FG TEXT}
    
    List all the messages that the current class will respond to.
  @{FG SHINE}
  respondsTo: aSymbol @{FG TEXT}
    
    The argument must be a @{B}Symbol@{UB}.  Return true if the receiver 
    class, or any of its superclasses, contains a method for the indicated
    message.  Return false otherwise.
  @{FG SHINE}
  superClass @{FG TEXT}
    
    Return the superclass of the receiver class.
  @{FG SHINE}
  variables @{FG TEXT}
    
    Return an array containing the names of the instance variables used 
    in the receiver class.
  @{FG SHINE}
  view @{FG TEXT}
    
    Place the user into an editor viewing the class description from which
    the class was created.  Changes made to the file will not, however, 
    affect the current class representation.
  @{FG SHINE}  
  getByteArray: methodString @{FG TEXT}

    Return a ByteArray that represents the given method in the Receiver.

@ENDNODE

@NODE ProcessClass "Process Class:"

  Processes are created by the system, or by passing the message 
  @{I}newProcess@{UI} or @{I}fork@{UI} to a block; they cannot be created directly 
  by the user.

  This Class responds to the following methods:
  @{FG SHINE}
  block @{FG TEXT}
    
    The receiver process is marked as being @{I}blocked@{UI}.  This is
    usually the result of a @{B}Semaphore@{UB} wait.  Blocked processes
    are not executed.
  @{FG SHINE}
  resume @{FG TEXT}
    
    If the receiver process has been @{I}suspended@{UI}, it is rescheduled
    for execution.
  @{FG SHINE}
  suspend @{FG TEXT}
    
    If the receiver process is scheduled for execution, it is marked as 
    suspended.  Suspended processes are not executed.
  @{FG SHINE}
  state @{FG TEXT}
    
    The current state of the receiver process is returned as a @{B}Symbol@{UB}.
  @{FG SHINE}
  termErr: msgName @{FG TEXT}
    
    Print a @{B}String@{UB} describing action taken on a terminated @{B}Process@{UB}.
  @{FG SHINE}    
  terminate @{FG TEXT}
    
    The receiver process is @{I}terminated@{UI}.  Unlike a @{I}blocked@{UI} or 
    @{I}suspended@{UI} process, a @{I}terminated@{UI} process cannot be 
    restarted.
  @{FG SHINE}
  unblock @{FG TEXT}
    
    If the receiver process is currently blocked, it is scheduled for 
    execution.
  @{FG SHINE}
  yield @{FG TEXT}
    
    Returns @{I}nil@{UI}.  As a side effect, however, if there are 
    pending processes, the current process is placed back on the process 
    queue and another process started.
@ENDNODE
