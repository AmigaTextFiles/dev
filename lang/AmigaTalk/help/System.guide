@DataBase   "System.guide"

@REMARK "$VER: System.guide 2.5 (15-Nov-2003) by James T. Steichen"

@REMARK "Written by Jim Steichen, Copyright (c) 1998-2003."

@WIDTH 75
@WORDWRAP

@NODE main  "System-related Classes for AmigaTalk© 1998-2003:"

   Described herein are the classes & their methods for manipulating 
   Amiga-System objects with @{B}AmigaTalk@{UB}.

   @{" Libraries " LINK "LibraryClass"}

   @{" ARexx      " LINK ARexxClass} -- New for V2.3+

   @{" Devices   " LINK DeviceClass}
     @{" Audio     " LINK AudioClass} - New for V2.1+
     @{" CDROM     " LINK CDClass} - New for V2.1+
     @{" Clipboard " LINK ClipboardClass}
       @{" IFFClipBoard " LINK "IFFClipBoardClass"}        

     @{" Console   " LINK ConsoleClass} - New for V2.1+
     @{" GamePort  " LINK GamePortClass}
       @{" Mouse       " LINK "MouseClass"}
       @{" AbsJoyStick " LINK "AbsJoyStickClass"}
       @{" RelJoyStick " LINK "RelJoyStickClass"}

     @{" Keyboard   " LINK KeyboardClass} - New for V2.1+
     @{" Narrator   " LINK NarratorClass}
     @{" Parallel   " LINK ParallelClass}
     @{" Printer    " LINK PrinterClass}
     @{" PrintFlags " LINK PrinterFlagsClass} -- Singleton Class  

     @{" SCSI      " LINK SCSIClass} -- New for V2.1+
     @{" Serial    " LINK SerialClass}
     @{" Timer     " LINK TimerClass}
     @{" TrackDisk " LINK TrackDiskClass}

   @{" MsgPort " LINK PortClass} -- New for V2.3+
   @{" Tasks   " LINK TaskClass} -- Not Implemented yet!
     @{" Processes " LINK ProcessesClass} -- Not Implemented yet!

   @{" Memory     " LINK MemoryClass} -- Not Implemented yet!
   @{" ELists     " LINK ListsClass} -- Not Implemented yet!
   @{" Interrupt  " LINK InterruptClass} -- Not Implemented yet!
   @{" ESemaphore " LINK SemaphoreClass} -- Not Implemented yet!
   @{" Signal     " LINK SignalClass} -- Not Implemented yet!
   @{" Exception  " LINK ExceptionClass} -- Not Implemented yet!

@ENDNODE

@NODE "CDClass" "CD Device Class (Parent Class = Device):"

   Class @{B}CD@{UB} allows the user of the @{B}AmigaTalk@{UB} system to 
   control any CDROM that is under the control of cd.device only; in my
   system, all of my CDROMs are connected to SCSI bus controllers, so I
   cannot even test this mess (at least I don't know if I can)!
   
   Valid methods are:   
   @{FG SHINE}
   open: cdDeviceName unit: unitNum @{FG TEXT}
   
     open the CDROM numbered unitNum that's connected to the cdDeviceName,
     which is normally @{B}cd.device@{UB}.  Returns @{I}true@{UI} if successful.

   @{I}unitNum@{UI} - Normally zero; however, this is described as:
               Ones digit      = Unit (SCSI unit number)
               Tens digit      = LUN (disk within disk changer)
               Hundreds digit  = Card number (SCSI card)
               Thousands digit = Reserved (must be zero)
   @{FG SHINE}
   close @{FG TEXT}
    
     Terminate access to the CDROM by closing the CDROM inside the receiver 
     & freeing up any resources.
   @{FG SHINE}
   cdInfo @{FG TEXT}

     Read some CDROM configuration information into program memory.
   @{FG SHINE}
   playSpeed @{FG TEXT}

     Return the current play speed of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}     
   readSpeed @{FG TEXT}

     Return the current reading speed of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}
   readXLSpeed @{FG TEXT}

     Return the current readXL speed of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}
   sectorSize @{FG TEXT}

     Return the sector size of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}
   maxSpeed @{FG TEXT}

     Return the maximum speed of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}
   audioPrecision @{FG TEXT}

     Return the audio precision of the CDROM (provided that you
     used the @{B}cdInfo@{UB} method first!).
   @{FG SHINE}
   status @{FG TEXT}

     Return the status flags of the CDROM (provided that you used the 
     @{B}cdInfo@{UB} method first!  See Also:  CDTags Class in CDDevice.st file).
   @{FG SHINE}
   translateCDErrorNumber: errNumber @{FG TEXT}

     Translate any @{I}errNumber@{UI} into a @{" String " LINK "GeneralClasses.guide/StringClass"} that you can read.
   @{FG SHINE}
   readInto: dataByteArray startingAt: location @{FG TEXT}

     The @{I}dataByteArray@{UI} size & @{I}location@{UI} must be divisible by two,
     or this method might fail!

     Reads data from the CD into memory.  Data may be accessed on WORD
     boundaries (you are not restricted to sector boundaries as with
     normal disk devices).  Data lengths can also be described in WORD
     amounts.

     Returns the number of bytes actually transferred.
     @{FG SHINE}
     NOTES @{FG TEXT}
     If an error occurs when attempting a CD_READ, the software will
     retry up to 10 times before giving up on the request.  If the
     drive is in double-speed and an error occurs, the software will
     retry once more in double-speed, and if this fails, will retry
     the next 9 times in single-speed.
   @{FG SHINE}
   motorOn @{FG TEXT}

     Turning the motor on or off manually is not necessary, the device does
     this automatically if it receives a request when the motor is off.
   @{FG SHINE}
   seekTo: location @{FG TEXT}

     This method moves the laser to the approximate position specified.  The
     @{I}location@{UI} should be set to the offset to which the head is
     to be positioned & is @{B}always specified in LSN format@{UB}.
   @{FG SHINE}
   newGeometryObject @{FG TEXT}
    
     You @{B}must@{UB} use this method @{B}before@{UB} you use @{B}getGeometry:@{UB}
   @{FG SHINE}               
   getGeometry: geometryObject @{FG TEXT}

     Fill the @{I}geometryObject@{UI} with the Drive Geometry of the CDROM.
   @{FG SHINE}
   dipose: geometryObject @{FG TEXT}

     You @{B}must@{UB} use this method @{B}after@{UB} you're done
     using a @{I}geometryObject@{UI}.
   @{FG SHINE}
   changeCount @{FG TEXT}

     This method returns the current value of the disk-change counter
     The disk change counter is incremented each time a disk is inserted
     or removed from the cd unit.
   @{FG SHINE}
   validDisk @{FG TEXT}

     This method checks to see if there is a @{B}valid@{UB} disk in a drive.

     0 means there is a disk while anything else indicates there is no disk.

     NOTE:  A @{B}valid@{UB} disk is a disk with a readable table of contents.
   @{FG SHINE}
   writeProtected @{FG TEXT}

     This method is used to determine whether the current disk is
     write-protected.  Currently, this function always returns write-
     protected status.  If write-once CDs are made available at some point,
     this may change.
   @{FG SHINE}
   attenuateBy: factor for: duration @{FG TEXT}

     @{I}duration@{UI} - duration of volume fade in frames
     @{I}factor@{UI}   - target volume level (0 - 16r7FFF) (-1 = status only)

     This method will ramp the CD audio volume up or down from its
     current value to the value contained in @{I}factor@{UI}.  The range is 0
     (silence) to 16r7FFF (full volume).  If -1 is specified as the target,
     the attenuation will not be modified; the current attenuation value
     will be returned.

     @{I}duration@{UI} contains the duration of the fade.  In seconds, this is
     @{I}duration@{UI} divided by the current frame rate (usually 75).

     Note that this method returns before the fade has completed.  Thus,
     once started, a fade cannot be aborted.  You can, however, send a
     new @{B}attenuateBy:for:@{UB} method, which will immediately override any fade
     currently in progress.  A @{I}duration@{UI} of zero means attenuate
     immediately.

     If a gradual attenuation method is sent before the play command, the
     fade will begin as soon as the play command is sent.
     @{FG SHINE}
     NOTES @{FG TEXT}
     This method has no effect on Amiga audio volume, only CD audio.

     If the drive does not support volume attenuation, but does support
     mute, a @{I}factor@{UI} of under 16r800 should be considered mute, and equal
     to or above should be full volume.  If chunky attenuation is
     supported, the drive should do the best it can.  If the drive does
     not support volume attenuation at all, an error should be returned.
     Even if only mute is supported, if gradual attenuation is requested,
     the device should still emulate the fade command and mute based on
     the 16r800 boundary.
   @{FG SHINE}
   motorOff @{FG TEXT}

     Turn the spindle motor of the CDROM off.
   @{FG SHINE}
   eject @{FG TEXT}

     Eject the CD if it's in the drive.
   @{FG SHINE}
   encloseDisk @{FG TEXT}

     Suck in a CD & close the CDROM door (if the CD was out of the drive).
   @{FG SHINE}
   pausePlay @{FG TEXT}

     This method will place the CD in pause mode.  This method only
     effects play commands.  When the audio is playing and the pausemode
     is set, this method will immediately pause the audio output
     suspending the play command until you @{B}resumePlay@{UB}.  When audio
     is not playing and the pausemode is set, this method will set the
     pause mode (having no immediate effect).  When a play method is
     submitted, the laser will seek to the appropriate position and pause
     at that spot.  The play method will be suspended until you @{B}resumePlay@{UB}
     (or the play is aborted).
   @{FG SHINE}
   resumePlay @{FG TEXT}

     This method will take the CD out of pause mode.  This method only
     effects play commands.
   @{FG SHINE}
   playTracks: numTracks startingAt: startTrack @{FG TEXT}

     This method causes the drive to play the specified audio track(s).
     The method will return when the audio has completed.

     @{I}startTrack@{UI} specifies the track number (starting from 1).
     @{I}numTracks@{UI}  specifies the number of tracks to play (0 is invalid).  
     @{FG SHINE}
     NOTES @{FG TEXT}
     play methods are asynchronous with many other CD commands.
   @{FG SHINE}
   playMSF: duration startingAt: startLocation @{FG TEXT}

     This method causes the drive to start playing CD audio from the
     specified position until the specified length has passed.

     @{I}startLocation@{UI} specifies the starting position.  @{I}duration@{UI} 
     contains the amount of time to play.  All data is specified in MSF format.
     @{FG SHINE}
     EXAMPLE @{FG TEXT}
       Play two minutes, ten seconds of audio starting at 20 minutes,
       58 seconds, and 10 frames:

       @{I}startLocation@{UI} <- 16r00143A0A. " 16r14=20, 16r3A=58, 16r0A=10 "
       @{I}duration@{UI}      <- 16r00020A00. " 16r02=02, 16r0A=10, 16r00=00 "
   @{FG SHINE}
   playLSN: duration startingAt: startLocation @{FG TEXT}

     This method causes the drive to start playing CD audio from the
     specified position until the specified length has passed.

     @{I}startLocation@{UI} specifies the starting position.  @{I}duration@{UI} 
     contains the amount of time to play.  All data is specified in LSN format.
     @{FG SHINE}
     EXAMPLE @{FG TEXT}
       Play two minutes, ten seconds of audio starting at 20 minutes,
       58 seconds, and 10 frames:

       @{I}startLocation@{UI} <- 94360. " 20 * (60 * 75) + 58 * 75 + 10 "
       @{I}duration@{UI}      <- 9750.  " 2  * (60 * 75) + 10 * 75 "
   @{FG SHINE}
   configure: tagArray @{FG TEXT}

     This method sets one or more of the configuration items.
     The configuration items are (see CDTags Class in CDDevice.st file):

       TAGCD_PLAYSPEED                 Default: 75
       TAGCD_READSPEED                 Default: 75 (do not count on this)
       TAGCD_READXLSPEED               Default: 75
       TAGCD_SECTORSIZE                Default: 2048
       TAGCD_XLECC                     Default: 1 (on)
       TAGCD_EJECTRESET                Default: can be 0 (off) or 1 (on)

     The speed settings are described in the number of frames (sectors)
     per second.  All CD-ROM drives are capable of the 75 frames/second
     rate.  Some drives are capable of 150 frames/second, and some even
     more.  To determine the maximum frame rate of the drive, use the
     @{B}cdInfo@{UB} method.  Valid values for caddyless Commodore CD-ROM drives
     are 75 and 150 (normal speed and double speed).  All other values are
     invalid.  You should always make sure the drive is capable of the
     configuration you are requesting by either using the @{B}cdInfo@{UB} method,
     and/or by checking for an error condition after submitting your
     request.

     There are three different types of CD-ROM sectors.  Mode 1 sectors
     (2048 bytes), mode 2 form 1 sectors (2048 bytes), and mode 2 form 2
     sectors (2328 bytes).  Normally, disks are encoded in Mode 1 format.
     Mode 2 form 1 is basically the same as mode 1; however, the mode 2
     form 2 sector format contains no CD-ROM error correction information.
     In order to read information encoded in this sector format, the
     drive's sector size must be configured to 2328 byte sectors.

     Error correction (ECC) of the readXL method can be turned off or
     on with this command.  Error correction can be implemented in either
     hardware or software (depending on the CD-ROM drive).  When ECC is
     implemented in software, CPU usage can become bursty.  Errors rarely
     occur on CDs unless they have numerous scratches, but when they do
     occur, they will cause a loss of CPU bandwith.  When ECC is
     implemented in hardware, no CPU bandwidth is lost -- in this case,
     ECC will always be on no matter how you configure the drive because 
     it is free.  The readXL method is used primarily for displaying
     movie-like data.  In this case, speed is essential and data integrety
     is not; however, if the CPU is not being utilized during an XL
     animation there is no need to disable ECC (since the bandwidth is
     there to be used).  The only time ECC should be disabled is when you
     are doing intense calculations in the background of a readXL method,
     AND your program is time-critical.  Do not forget to change this back
     when you are done!
       
     To make the computer reset when a CD is ejected (for an application
     that does not exit), use the TAGCD_EJECTRESET tag.  When possible,
     titles should be able to exit cleanly back to Workbench.  Error
     conditions should be monitored when doing disk I/O.
     @{FG SHINE}
     NOTES @{FG TEXT}
     Setting the configuration will not modify the behavior of a read or
     play command already in progress.

     This can be a very dangerous command.  If for instance you set
     TAGCD_SECTORSIZE to 2328, you will no longer be able to read any
     data encoded at 2048 byte sectors (e.g. the file system will not be
     able to read the disk anymore).  After you read any data stored with
     this sector format, you should immediately configure back to the
     original default value (even if the read failed -- the disk could
     be removed in the middle of your read).  You should NEVER use this
     command if you are not the exclusive owner of your disk.
     @{FG SHINE}
     BUGS @{FG TEXT}
     TAG_IGNORE, TAG_MORE, and TAG_SKIP do not work.  Do not use these.

     When switching speeds from single to double (or double to single),
     If the drive is prefetching in single-speed the data you are going
     to use in double-speed, the drive will not switch to double-speed
     (and visa versa).  To avoid this problem, switch to the desired speed,
     begin reading at least 4k into the data (just read two bytes), then
     begin reading at the beginning.  This will force the prefetch buffer
     to clear and issue a new read command with the desired speed.
     (Fixed in 40.24).
   @{FG SHINE}
   contentsMSF: numEntries startingAt: start @{FG TEXT}

     This method returns a table of contents information from CD (MSF form).

     @{I}numEntries@{UI} number of CDTOC entries to be fetched (100 maximum).
     @{I}start@{UI}      entry to begin at (entry 0 is summary information).

     Returns the actual number of entries copied.

     This method returns the table of contents of the disk currently in
     the drive.  The table of contents consists of up to 100 entries.
     Entry zero is summary information describing the number of tracks
     and the total number of minutes on the disk.  Entries 1 through N
     contain information about each individual track.  All position
     information will be in MSF format.

     Entry zero (the summary entry) contains the following:

     struct TOCSummary {

           UBYTE        FirstTrack;    /* First track on disk (always 1)   */
           UBYTE        LastTrack;     /* Last track on disk               */
           union LSNMSF LeadOut;       /* Beginning of lead-out track      */
           };

     Track entries (entries 1 through number of tracks) contain:

     struct TOCEntry {

           UBYTE        CtlAdr;        /* Q-Code info                  */
           UBYTE        Track;         /* Track number                 */
           union LSNMSF Position;      /* Start position of this track */
           };
   @{FG SHINE}     
   contentsLSN: numEntries startingAt: start @{FG TEXT}

     Return table of contents information from CD (LSN form).

     @{I}numEntries@{UI}  number of CDTOC entries to be fetched (100 maximum).
     @{I}start@{UI}       entry to begin at (entry 0 is summary information).

     Returns actual number of entries copied.

     This method returns the table of contents of the disk currently in
     the drive.  The table of contents consists of up to 100 entries.
     Entry zero is summary information describing the number of tracks
     and the total number of minutes on the disk.  Entries 1 through N
     contain information about each individual track.  All position
     information will be in LSN format.

     Entry zero (the summary entry) contains the following:

     struct TOCSummary {

           UBYTE        FirstTrack;    /* First track on disk (always 1)   */
           UBYTE        LastTrack;     /* Last track on disk               */
           union LSNMSF LeadOut;       /* Beginning of lead-out track      */
           };

     Track entries (entries 1 through number of tracks) contain:

     struct TOCEntry {

           UBYTE        CtlAdr;        /* Q-Code info                  */
           UBYTE        Track;         /* Track number                 */
           union LSNMSF Position;      /* Start position of this track */
           };
     @{FG SHINE}
     NOTES @{FG TEXT}
     The amount of data on the disk is calculated as being equal to the 
     location of the lead-out track minus the start of the first track 
     (which is never zero).
   @{FG SHINE}
   readXL: length startingAt: start @{FG TEXT}

     @{FG SHINE} This is NOT working yet!! @{FG TEXT}

     This command starts reading data off the disk at the @{I}start@{UI}
     location and deposits it into memory according to the nodes in a
     transfer list.
     If you have a non-circular transfer list, simply set
     @{I}length@{UI} to 0 (0 is special and means ignore @{I}length@{UI})
     Your transfer will end when your transfer list has been exhausted.  If you
     have a circular transfer list, the list will never end.  In this case,
     the transfer will terminate when @{I}length@{UI} bytes have been
     transferred.

     The philosophy here is that you set up the buffers you want filled,
     create CDXL nodes describing the locations and sizes of these
     buffers, link all the nodes together in the order that you'd like
     (even make a circular list for animations), and execute the command.
     The data will be streamed into the appropriate buffers until the
     list has been exhausted, an entry with a Length of zero is
     encountered, @{I}length@{UI} bytes have been transferred (if @{I}length@{UI} is
     non-zero), or the method is aborted with AbortIO() [No way to do this!].

     If you fill in the (*IntCode)() field with a pointer to an interrupt
     routine, your routine will be called when the transfer for the node
     is complete.  Your code will be called before the driver proceeds to
     the next node.  The interrupt should follow the same rules as standard
     interrupts (see AddIntServer of Exec autodocs).  Register A2 will
     contain a pointer to the node just completed.  You may manipulate the
     list from within the interrupt. Your code must be brief (this is an
     interrupt).  When returning from this interrupt, D0 should be cleared
     and an RTS instruction should be used to return.

     Servers are called with the following register conventions:

           D0 - scratch
           D1 - scratch

           A0 - scratch
           A1 - server is_Data pointer (scratch)
           A2 - pointer to CDXL node just completed

           A5 - jump vector register (scratch)

           all other registers must be preserved
     @{FG SHINE}
     NOTES @{FG TEXT}
     Try to make sure that small buffers are not overused.  Each time
     a node is completed, an interrupt is generated.  If you find that
     your computer is acting sluggish, or the CD_READXL command is
     aborting, you are probably generating too many interrupts.  It is
     not efficient to have more than a few of these interrupts generated
     within a vertical blank.

     Unlike the @{B}readInto:startingAt:@{UB} method, the @{B}readXL:startingAt:@{UB} method 
     will not retry a sector if there is an error.  Since the 
     @{B}readXL:startingAt:@{UB} method's purpose is primarily for animations, data 
     streaming is considered more important than the data itself.  An error 
     will be returned if a data error did occur.  This method will never 
     drop to a lower speed in the event of an error.
   @{FG SHINE}
   search: searchMode @{FG TEXT}

     This method causes a play command to play in fast-forward,
     fast-reverse, or normal play mode.  These modes are defined as:

       CDMODE_NORMAL   0   Normal play (current speed setting)
       CDMODE_FFWD     1   Play in fast forward mode  
       CDMODE_FREV     2   Play in fast reverse mode

     The search mode can be set before the play method is sent, or during
     a play.  If @{B}search:@{UB} is sent before a play method is sent, the
     mode is set and the command immediately returns.  If the mode is set
     to REV mode, when the play method is sent the play will begin at the
     requested end position and work backwards to the start position.

     If @{B}search:@{UB} is sent during a play, the play will automatically
     switch to the desired mode and continue playing until the original
     play method is completed.  If REV mode is set and the beginning of
     the play is encountered before switching back to forward play, the
     play method will terminate with no error.
   @{FG SHINE}
   qCodeMSF @{FG TEXT}

     This method reports current subcode Q channel time information.  This
     method only returns data when CD Audio is playing (or paused).  At 
     any other time, an error is returned.  The Q-Code packet consists of:

     struct QCode {

           UBYTE        CtlAdr;        /* Data type / QCode type           */
           UBYTE        Track;         /* Track number                     */
           UBYTE        Index;         /* Track subindex number            */
           UBYTE        Zero;          /* The "Zero" byte of Q-Code packet */
           union LSNMSF TrackPosition; /* Position from start of track     */
           union LSNMSF DiskPosition;  /* Position from start of disk      */
           };
     @{FG SHINE}
     NOTES @{FG TEXT}
     This function may not return immediately.  It may take several frames
     to pass by before a valid Q-Code packet can be returned.
   @{FG SHINE}
   qCodeLSN @{FG TEXT}

     This method reports current subcode Q channel time information.  This
     method only returns data when CD Audio is playing (or paused).  At
     any other time, an error is returned.  The Q-Code packet consists of:

     struct QCode {

           UBYTE        CtlAdr;        /* Data type / QCode type           */
           UBYTE        Track;         /* Track number                     */
           UBYTE        Index;         /* Track subindex number            */
           UBYTE        Zero;          /* The "Zero" byte of Q-Code packet */
           union LSNMSF TrackPosition; /* Position from start of track     */
           union LSNMSF DiskPosition;  /* Position from start of disk      */
           };
     @{FG SHINE}
     NOTES @{FG TEXT}
     This function may not return immediately.  It may take several frames
     to pass by before a valid Q-Code packet can be returned.
   @{FG SHINE}     
   addChangeInterrupt: interruptObject @{FG TEXT}
     @{B} @{FG SHINE}
     NOTE:  I have NOT implemented a way to create interruptObjects yet,
            so DO NOT use this method! @{UB} @{FG TEXT}
             
     This command lets you add a software interrupt handler to the
     disk device that gets invoked whenever a disk insertion or removal
     occurs.

     You must pass in a properly initialized Exec Interrupt structure
     and be prepared to deal with disk insertions/removals immediately.
     The interrupt is generated by the exec Cause function, so you must
     preserve A6.

     To set up the handler, an Interrupt structure must be initialized.
     This structure is supplied as the io_Data to the CD_ADDCHANGEINT
     command.  The handler then gets linked into the handler chain and
     gets invoked whenever a disk change happens.  You must eventually
     remove the handler before you exit.

     This command only returns when the handler is removed. That is,
     the device holds onto the IO request until the CD_REMCHANGEINT command
     is executed with that same IO request.  Hence, you must use SendIO()
     with this command (which is how @{" I " LINK "AmigaTalk.guide/Author"} coded it).
   @{FG SHINE}
   removeChangeInterrupt: interruptObject @{FG TEXT}

     @{B} @{FG SHINE}
     NOTE:  I have NOT implemented a way to create interruptObjects yet,
            so DO NOT use this method! @{UB} @{FG TEXT}
             
     This method removes a disk change software interrupt added
     by a previous use of @{B}addChangeInterrupt:@{UB}
   @{FG SHINE}
   addFrameInterrupt: interruptObject @{FG TEXT}

     @{B} @{FG SHINE}
     NOTE:  I have NOT implemented a way to create interruptObjects yet,
            so DO NOT use this method! @{UB} @{FG TEXT}
             
     This method lets you add a software interrupt handler to the
     disk device that gets invoked whenever a new frame is encountered
     while CD audio is being played.

     You must pass in a properly initialized Exec Interrupt structure
     and be prepared to deal with frame interrupts immediately.
     The interrupt is generated by the exec Cause function, so you must
     preserve A6.

     To set up the handler, an Interrupt structure must be initialized.
     This structure is supplied in io_Data of the CD_ADDFRAMEINT
     command.  The handler then gets linked into the handler chain and
     gets invoked whenever a frame event occurs.  You must eventually
     remove the handler before you exit.

     This command only returns when the handler is removed. That is,
     the device holds onto the IO request until the CD_REMFRAMEINT command
     is executed with that same IO request.  Hence, you must use SendIO()
     with this command (which is how @{" I " LINK "AmigaTalk.guide/Author"} coded it).
     @{FG SHINE}
     NOTES @{FG TEXT}
     The interrupt handler can be added before or after a play command is
     sent.  Interrupts will only be generated while CD audio is playing.
     Interrupts will not be generated when audio is paused.
   @{FG SHINE}
   removeFrameInterrupt: interruptObject @{FG TEXT}

     @{B} @{FG SHINE}
     NOTE:  I have NOT implemented a way to create interruptObjects yet,
            so DO NOT use this method! @{UB} @{FG TEXT}
             
     This method removes a CD-frame software interrupt added
     by a previous use of @{B}addFrameInterrupt:@{UB}

@ENDNODE

@NODE LibraryClass "Library Class (Parent Class = Object):"

   Class @{B}Library@{UB} allows the user of the @{B}AmigaTalk@{UB} system to retrieve
   values for any @{B}Library@{UB} known to @{B}AmigaTalk@{UB} & to open or close them.
   Valid methods are:   
   
   @{FG SHINE}
   new: libname @{FG TEXT}
   
     Initialize the @{B}Library@{UB} class instance variable to libname. 
   @{FG SHINE}
   open: libraryName version: ver @{FG TEXT}

     Open the library @{B}libraryName@{UB} at the version supplied.

     Example libraryName:  '@{B}intuition.library@{UB}'

     @{B}NOTE:@{UB}  This method does @{B}NOT@{UB} tie the opened Library into @{B}AmigaTalk@{UB}.
            Its only practical purpose is to allow the User to see if
            a specific version of a Library is present in their system.

   @{FG SHINE}
   close: libraryName @{FG TEXT}

     Close the given library.
   @{FG SHINE}
   getIDString: libraryName @{FG TEXT}

     Return the library's Internal identifier string.
   @{FG SHINE}
   getVersion: libraryName @{FG TEXT}
 
     Return the library's Version number.
   @{FG SHINE}
   getRevision: libraryName @{FG TEXT}

     Return the library's Revision number.
   @{FG SHINE}
   getCheckSum: libraryName @{FG TEXT}

     Return the library's CheckSum.
   @{FG SHINE}
   getOpenCount: libraryName @{FG TEXT}

     Return a count of the number of times the library has been opened
     by the @{B}Amiga OS@{UB}.
   @{FG HIGHTLIGHT} @{I}
   NOTE:  The following methods are only supplied to complete the 
          accessability to the @{B}Library@{UB} class & are probably not of much
          use to the casual user: @{FG TEXT} @{UI}
   @{FG SHINE}
   getNegSize: libraryName @{FG TEXT}

     Return the amount of bytes in front of the library ROMTAG.
   @{FG SHINE}
   getPosSize: libraryName @{FG TEXT}

     Return the amount of bytes after the library @{B}ROMTAG@{UB}.
   @{FG SHINE}
   getFlags: libraryName @{FG TEXT}

     Return the library's @{B}Flags@{UB} value.
@ENDNODE

@NODE PortClass "MsgPort Class:"

   Class @{B}MsgPort@{UB} allows the user of the @{B}AmigaTalk@{UB} system to send
   & retrieve messages via Exec MsgPorts.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!
   @{FG TEXT} @{UB}
   Valid methods are:
   @{FG SHINE}
   new @{FG TEXT}
    
      Use @{I}new:@{UI} instead.    
   @{FG SHINE}
   new: newPortName @{FG TEXT}
      
      Initialize a new instance of @{B}MsgPort@{UB} with the name newPortName.
      This has to be done @{B}before@{UB} any other method.
   @{FG SHINE}
   addPort messageSize: msgSize priority: pri @{FG TEXT}

     Return @{I}true@{UI} if the @{B}MsgPort@{UB} was added & registered, @{I}nil@{UI} otherwise.
     This has to be done @{B}AFTER new: newPortName@{UB}
   @{B}
   NOTE:  Once a port has been made, all messages to & from the port
          are supposed to be the given size (MessageSize) or less.  
          Any code that you write to use MsgPorts should therefore 
          verify the size of the bytearrays passed in & out or clip 
          them to the known size. @{UB}
   @{FG SHINE}
   killPort @{FG TEXT}
     
     Close & delete the @{B}MsgPort@{UB} from the AmigaTalk system.
   @{FG SHINE}   
   getMessage @{FG TEXT}

     Returns a @{B}ByteArray@{UB} that represents the actual 
     message, not including the operating system overhead. 

     If no message ever gets sent, you'll freeze AmigaTalk!!

     This method has waitPort: getMsg: & replyMsg: built-in
   @{FG SHINE}
   sendMessage: atalkMsgPortObj msg: byteArray @{FG TEXT}
    
     Place the given byteArray (Message) on the @{B}MsgPort@{UB}.
     This method has putMsg:, waitPort built-in.  The reply is
     thrown away.
   @{FG SHINE}
   checkForPort @{FG TEXT}

      Return @{I}true@{UI} if the @{B}MsgPort@{UB} is known to the
      Amiga OS, or @{I}false@{UI} if not.
   @{FG SHINE}
   getNamedSystemPort: sysPortName @{FG TEXT}

      Return a @{B}MsgPort@{UB} Object that represents sysPortName. 
   @{FG SHINE}
   sendMessageOutsideTo: systemPortObj msg: bytesArray size: msgSize @{FG TEXT}

      Send a message to a @{B}MsgPort@{UB} outside the AmigaTalk System. @{B}
      WARNING!  WARNING!  Danger, Will Robinson!
      You had better know what size & what Message the port expects! @{UB}

      This method has putMsg:, waitPort: & getMsg: built-in
   @{FG SHINE}
   getMsgPort @{FG TEXT}
      Returns this instance's @{B}MsgPort@{UB} Object.
   
@ENDNODE

@NODE ProcessesClass "Processes Class (Parent Class = Task):"
   Not implemented yet!

   Class @{B}Processes@{UB} allows the user of the @{B}AmigaTalk@{UB} system to create
   & destroy processes that are running in their Amiga.
   
   @{B}NOTE:@{UB}  This is @{B}NOT@{UB} the same as the @{" Process " LINK "GeneralClasses.guide/ProcessClass"} Class, which is from the
          @{B}General/Process.st@{UB} file!
          
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!
   @{B}SubClasses:@{UB}

   Proposed methods are:   
   @{FG SHINE}
   new: newProcessName @{FG TEXT}

   @{FG SHINE}
   addProcess @{FG TEXT}

   @{FG SHINE}
   setProcessInput: inputName @{FG TEXT}

   @{FG SHINE}
   setProcessOutput: outputName @{FG TEXT}

   @{FG SHINE}
   setProcessState: newProcessState @{FG TEXT}

   @{FG SHINE}
   setProcessPriority: newProcessPriority @{FG TEXT}

   @{FG SHINE}
   freezeProcess @{FG TEXT}

   @{FG SHINE}
   removeProcess @{FG TEXT}

   @{FG SHINE}
   displayProcesses @{FG TEXT}

@ENDNODE

@NODE TaskClass "Task Class:"
   Not implemented yet!

   Class @{B}Task@{UB} allows the user of the @{B}AmigaTalk@{UB} system to create
   & delete tasks that are running in their Amiga.
   
     SubClass: @{" Processes " LINK "ProcessClass"}
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   @{FG SHINE}
   findTaskNamed: taskName @{FG TEXT}

      ^ <primitive 209 4 90 taskName>
   @{FG SHINE}
   addTask: taskObj initialPC: inpcObj finalPC: fnpcObj @{FG TEXT}

      ^ <primitive 209 4 8 taskObj inpcObj fnpcObj>
   @{FG SHINE}
   removeTask: taskObj @{FG TEXT}

      <primitive 209 4 9 taskObj>
   @{FG SHINE}
   setTaskPriority: taskObj to: priority @{FG TEXT}

      ^ <primitive 209 4 10 taskObj priority>
   @{FG SHINE}
   new: taskName @{FG TEXT}

      create a new Task Object.

@ENDNODE

@NODE MemoryClass "Memory Class:"
   Not implemented yet!

   Class @{B}Memory@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate memory blocks inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE ListsClass "Lists Class:"
   Not implemented yet!

   Class @{B}Lists@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate Lists inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE InterruptClass "Interrupt Class:"
   Not implemented yet!

   Class @{B}Interrupt@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate software Interrupt handlers inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE SemaphoreClass "Semaphore Class:"
   Not implemented yet!

   Class @{B}Semaphorte@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate Semaphores inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE SignalClass "Signal Class:"
   Not implemented yet!

   Class @{B}Signal@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate signals inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE ExceptionClass "Exception Class:"
   Not implemented yet!

   Class @{B}Exception@{UB} allows the user of the @{B}AmigaTalk@{UB} system to
   manipulate system Exception handlers inside their Amiga.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class!

   Proposed methods are:
   
@ENDNODE

@NODE ARexxClass "ARexx Class:"

   Class @{B}ARexxPort@{UB} allows the User to communicate with ARexx, either
   within AmigaTalk programs, or to any defined arexxPort known to the AmigaOS.
   The intent of this Class is only to allow communication between ARexx
   & AmigaTalk, not full access to all the functions/commands available
   in ARexx.  This would result in a duplication of operations in other
   classes (such as file I/O), so just the methods that are necessary to
   send & receive messages via ARexx ports is contained herein.

   There are also two other helper classes defined in the source
   file (System/ARexx.st).  These are @{B}ARexxTags & ARexxArg@{UB}.
   @{B}ARexxTags@{UB} is a Singleton Class that contains Symbols for the various
   action codes that can be set inside a rexxMsg Object.
   @{B}ARexxArg@{UB} is a Class that is used to create arguments for the @{B}ARexxPort@{UB}
   Class.  The methods in @{B}ARexxArg@{UB} correspond to the functions that
   create & destroy what the author of ARexx calls ArgStrings.
   @{FG SHINE} @{B}
   ArgStrings are not the same as @{" String " LINK "GeneralClasses.guide/StringClass"} Objects, so do not expect them
   to behave as such. @{FG TEXT} @{UB}
   
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{UB} @{FG TEXT}

   The methods for @{B}ARexxTags@{UB} that the User needs are:
   @{FG SHINE}   
   new @{FG TEXT}
     
     Instantiate the ARexxTags instance (there can be only one).
   @{FG SHINE}
   arexxTag: aKeySymbol @{FG TEXT}
     
     Return a value associated with the key @{" Symbol " LINK "GeneralClasses.guide/SymbolClass"} supplied.
   @{B}
   The methods for ARexxArg are: @{UB}
   @{FG SHINE}    
   new @{FG TEXT}
     
     Just prints an error message & returns @{B}nil@{UB}.
   @{FG SHINE}
   new: aString @{FG TEXT}
     
     Creates a new instance of the Class, initialized with aString.
   @{FG SHINE}
   dispose @{FG TEXT}

     Remove the instance from AmigaTalk.  @{B}DO NOT use 
     the instance after this method!@{UB}
   @{FG SHINE}
   length @{FG TEXT}
     
     Return the length of the ARexxArg as an @{" Integer " LINK "GeneralClasses.guide/IntegerClass"}.
   @{FG SHINE}
   value @{FG TEXT}
    
     Return the contents of the ARexxArg as a String.
   @{B}
   The methods for ARexxPort are: @{UB}
   @{FG SHINE}   
   open: arexxPortName  @{FG TEXT}

     Open the ARexx port & assign it the name @{I}arexxPortName@{UI}.
     (You still have to use @{B}myport <- ARexxPort new@{UB} first!)
   @{FG SHINE}
   errorIs: errorNumber @{FG TEXT}
    
     Return a String that corresponds to the given @{I}errorNumber@{UI}.
   @{FG SHINE}
   defaultExtension   @{FG TEXT}

     Returns the default file extension for ARexx scripts (normally '.rexx'). 
   @{FG SHINE}
   fileExtension: newExtString @{FG TEXT}
    
     Change the file extension for ARexx scripts to newExtString
     (a @{FG SHINE}.@{FG TEXT} should not be included).
   @{FG SHINE}
   fileExtension @{FG TEXT}
    
     Return the current file extension as a @{" String " LINK "GeneralClasses.guide/StringClass"}.
   @{FG SHINE}
   findARexxPort: portName @{FG TEXT}
     See if the @{I}portName@{UI} port is known to the AmigaOS.
     This method returns a msgPortObj or @{B}nil@{UB} on failure.
     The msgPortObj is required by the 
     @{B}createRexxMsg:extension:port:@{UB} method only.
   @{FG SHINE}
   selectARexxPort @{FG TEXT}
    
     Display a ListView of all known message Ports so that
     the User can select a msgPortObj to send messages to.
     This method returns a msgPortObj or @{B}nil@{UB} on failure.
     The msgPortObj is required by the 
     @{B}createRexxMsg:extension:port:@{UB} method only.
   @{FG SHINE}
   createRexxMsg: msgPortObj extension: extString port: newPortName @{FG TEXT}

     This method returns a rexxMsgObj or nil if there is a problem.
     Use this method to create a message for a foreign ARexx port.
   @{FG SHINE}
   sendRexxCmd: aString @{FG TEXT}

     Send a message @{I}aString@{UI} to ARexx. 
     Be sure to use @{FG SHINE}port setRMAction: myActionCode@{FG TEXT} first!
   @{FG SHINE}     
   sendOutMessage: aString to: rexxMsgObj @{FG TEXT}

     Send a message @{I}aString@{UI} to the port given in @{I}rexxMsgObj@{UI}. 
     Be sure to use @{FG SHINE}port setRMAction: myActionCode@{FG TEXT} first!
     Try @{B}sendRexxCmd: aString@{UB} before using this method to see if
     it does what you need before using this method.      
     Returns true if successful, false on failure.
   @{FG SHINE}
   disposeRexxMsg: rexxMsgObj @{FG TEXT}
     
     Remove @{I}rexxMsgObj@{UI} from AmigaTalk. @{B}
     Do NOT use the rexxMsgObj after this method!@{UB}
   @{FG SHINE}
   clearRexxMsg: rexxMsgObj count: c @{FG TEXT}

     Release one or more arguments from the @{I}rexxMsgObj@{UI}.
     @{B}This method is not normally needed.@{UB}
   @{FG SHINE}
   fillRexxMsg: rexxMsgObj count: c mask: m @{FG TEXT}

     Convert & install arguments into the @{I}rexxMsgObj@{UI}.
     The argument array must already be set to either Strings
     or Integers.  The count argument @{I}c@{UI} specifies the number
     of fields to convert, beginning with the first one.
     Bits 0 - 15 of the mask argument @{I}m@{UI} specify whether the
     corresponding argument is a String (bit clear) or an
     Integer (bit set).
     @{B}This method is not normally needed.@{UB}
   @{FG SHINE}      
   isRexxMsg: chkThisObject @{FG TEXT}
    
     See if @{I}chkThisObject@{UI} is a rexxMsg Object.
     Returns true or false.
   @{FG SHINE}
   arrayToArgs: inputArray @{FG TEXT}

     Each element of the inputArray should be a @{" String " LINK "GeneralClasses.guide/StringClass"}.
     This method will store the arguments away.
     @{B}The ARexx system only has space for 16 arguments maximum.@{UB}
   @{FG SHINE}     
   getRexxMsg @{FG TEXT}
    
     Wait for a message from the ARexx system.
   @{FG SHINE}
   setRMAction: actionCode @{FG TEXT}

     Normally, the actionCode should be:
     #RXCOMM + #RXFF_STRING (See ARexxTags Class notes in System/ARexx.st
     on how to do this)
   @{FG SHINE}
   getPrimaryResult @{FG TEXT}
    
     Retrieve the primary result returned from ARexx (normally,
     zero indicates success, 5 is for WARNING, 10 for ERROR,
     & 20 for FAIL (check the number with @{B}errorIs: errNumber@{UB} method)
   @{FG SHINE}
   getSecondaryResult @{FG TEXT}

     Retrieve the secondary result returned from ARexx.
   @{FG SHINE}
   setArgument: argNumber for: rexxMsgObj to: argument @{FG TEXT}

     This method is for setting the arguments for external
     rexxMsg Objects only.  Valid range for @{I}argNumber@{UI} is 
     1 to 16.  an @{I}argNumber@{UI} of 1's value will be overwritten by 
     @{B}sendOutMessage:to:@{UB} or by @{B}sendRexxCmd:@{UB}, so just 
     use this method for setting arguments 2 through 16 only.
   @{FG SHINE}
   setArgument: argNumber to: argument @{FG TEXT}

     For setting this instance's arguments only.
     This is the only method that uses @{I}myRexxMsg@{UI} instance variable.
   @{FG SHINE}
   getArgument: argNumber @{FG TEXT}
    
     Retrieve the argument specified by the index value 
     in @{I}argNumber@{UI} (1 to 16).  Normally the first 
     argument (@{I}argNumber@{UI} = 1) is the one you wish to
     examine.
   @{FG SHINE}
   portNameIs @{FG TEXT}
    
     Retrieve the name of the ARexx port.
   @{FG SHINE}
   close @{FG TEXT}
    
     Close the ARexx port & remove it from the AmigaOS & AmigaTalk.

@ENDNODE

@REM --------------------------------------------------------------------

@NODE DeviceClass "Device Class:"

   Class @{B}Device@{UB} is an abstract class.
   Methods defined by the Class are:  

   @{FG SHINE}
   getDeviceAddressList @{FG TEXT}

     Return an @{" Array " LINK "GeneralClasses.guide/ArrayClass"} of Device Addresses.
   @{B}
   All of the following methods only return an error message, they 
   should be re-defined by sub-classes: @{UB}
   @{FG SHINE}
   clear @{FG TEXT}
   @{FG SHINE}
   flush: devName @{FG TEXT}
   @{FG SHINE}
   invalid @{FG TEXT}
   @{FG SHINE}
   read: devName @{FG TEXT}
   @{FG SHINE}
   reset: devName @{FG TEXT}
   @{FG SHINE}
   stop @{FG TEXT}
   @{FG SHINE}
   start @{FG TEXT}
   @{FG SHINE}
   update @{FG TEXT}
   @{FG SHINE}
   write: devName this: string @{FG TEXT}

   @{B}SubClasses:@{UB}
   
     @{" Serial    " LINK SerialClass}
     @{" Audio     " LINK AudioClass}
     @{" CDROM     " LINK CDClass}
     @{" Narrator  " LINK NarratorClass}
     @{" Clipboard " LINK ClipboardClass}
       @{" IFFClipBoard " LINK "IFFClipBoardClass"}        
     @{" Console   " LINK ConsoleClass}
     @{" Keyboard  " LINK KeyboardClass}
     @{" GamePort  " LINK GamePortClass}
       @{" Mouse       " LINK "MouseClass"}
       @{" AbsJoyStick " LINK "AbsJoyStickClass"}
       @{" RelJoyStick " LINK "RelJoyStickClass"}

     @{" Parallel  " LINK ParallelClass}
     @{" Printer   " LINK PrinterClass}
     @{" SCSI      " LINK SCSIClass}
     @{" Timer     " LINK TimerClass}
     @{" TrackDisk " LINK TrackDiskClass}

@ENDNODE

@NODE SerialClass "SerialDevice Class (Parent Class = Device):"

   Class @{B}SerialDevice@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   Serial Device that the Amiga PC uses to communicate to the outside 
   world.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT}
             
   NOTE:  All commands (except Read & Write) use BeginIO with IOF_QUICK 
          set, regardless of the state of the SyncType. @{UB}

   @{FG SHINE}
   new: newSerialName @{FG TEXT}
    
     Initialize an Instance of SerialDevice & name it newSerialName.
   @{FG SHINE}
   open @{FG TEXT}

     Open the serial device & assign it the given name with the 
     buffer size given (one for reads & one for writes).
   @{FG SHINE}
   setBufferSize: newSize @{FG TEXT}

     Set the size of the (initial or opening) buffers.
   @{FG SHINE}
   close @{FG TEXT}

     Close the serial device & deallocate the buffers.
   @{FG SHINE}
   initializeWithTerm: charVals @{FG TEXT}

     Initialize the serial device & utilize the @{B}charVals@{UB} as EOF indicators.
   @{FG SHINE}
   readSync: syncValue @{FG TEXT}
    
     Read the serial device.  If syncValue == 0, then perform:
        BeginIO();
        WaitIO();
     else perform:
        DoIO();
   @{FG SHINE}
   writeThis: writeString @{FG TEXT}
    
     Write the given string to the serial device.
   @{FG SHINE}
   reset @{FG TEXT}

     Issue a CMD_RESET to the serial device.
   @{FG SHINE}
   pause @{FG TEXT}

     Issue a CMD_STOP to the serial device.
   @{FG SHINE}
   restart @{FG TEXT}

     Issue a CMD_START to the serial device.
   @{FG SHINE}
   sendBreakOfDuration: usecs @{FG TEXT}

     Issue a CMD_BREAK to the serial device.
   @{FG SHINE}
   getStatus @{FG TEXT}

     Return the status bits (SDCMD_QUERY) of the serial device.
   @{FG SHINE}
   flush @{FG TEXT}

     Issue a CMD_FLUSH to the serial device.
   @{FG SHINE}
   clearReadBuffer @{FG TEXT}

     Place nils ('\0') in all of the read buffer locations.
   @{FG SHINE}
   setSyncType: newSync @{FG TEXT}

     Set the type of synching to use, synchronous > 0 or asynchronous = 0.
   @{FG SHINE}
   setBaud: newBaud @{FG TEXT}

     Set the BAUD rate for the serial device.
   @{FG SHINE}
   setParity: newParity status: onOrOff  @{FG TEXT}

     Enable or disable Parity, where newParity has the following values:

       0 = Space      onOrOff:  0 = disable, 1 = enable.
       1 = Mark
       2 = Even
       3 = Odd
   @{FG SHINE}
   setDataSize: newSize @{FG TEXT}

     Set the read buffer length to @{B}newSize@{UB}.
   @{FG SHINE}
     NOTE:  This method does @{B}NOT@{UB} reallocate the buffer. @{FG TEXT}
   @{FG SHINE}
   setStops: newStops @{FG TEXT}

     Set the number (0, 1, or 2) of Stop bits to use for communication.
   @{FG SHINE}
   setBreakLen: duration @{FG TEXT}

     Set the duration of break signals to @{B}duration@{UB}.
   @{FG SHINE}
   setRBufSize: size @{FG TEXT}
    
     Reset the size of the read buffer to @{B}size@{UB}.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Set the serial device @{B}Flags@{UB}.
   @{FG SHINE}
   setTerminators: termChars @{FG TEXT}

     Set the termination characters array that will signal the serial
     device to break.
     
     termchars = 8 bytes in descending order representing the
                 characters that the serial channel should 
                 recognize as EOF characters.
@ENDNODE

@NODE AudioClass "Audio Class (Parent Class = Device):"

   Class @{B}Audio@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the Audio
   Device that the Amiga PC uses to generate sounds & speech (NOT any custom
   hardware you might have).
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}
             
   The methods are:
   @{FG SHINE}
   initialize: portName channels: chBytes flags: flags priority: newPriority @{FG TEXT}
      
      Does everything to get the Audio Class ready for playing sound data.

       @{I}newPriority@{UI} is in the range: -128 to 127.
      
       @{I}chBytes@{UI} is a ByteArray that is only 4 bytes long.  #[ 3 5 10 12 ] 
       It is encoded as follows for each byte:
      
          Channel 3 Channel 2 Channel 1 Channel 0 Allocation 
            RIGHT     LEFT      LEFT      RIGHT      MASK
      
              0         0         1         1        0x03    Stereo
              0         1         0         1        0x05    Stereo
              1         0         1         0        0x0A    Stereo
              1         1         0         0        0x0C    Stereo
      
              0         0         0         1        0x01    MonAural
              0         0         1         0        0x02    MonAural
              0         1         0         0        0x04    MonAural
              1         0         0         0        0x08    MonAural
        
       UNCOMMON USAGE:
      
              0         0         0         0        0x00    NO CHANNELS
              0         1         1         0        0x06    Both Left Ch.
              0         1         1         1        0x07    Three Channels
              1         0         0         1        0x09    Both Right Ch.
              1         0         1         1        0x0B    Three Channels
              1         1         0         1        0x0D    Three Channels
              1         1         1         0        0x0E    Three Channels
              1         1         1         1        0x0F    ALL Channels
   @{FG SHINE}
   openChannel: chByteArray priority: pri @{FG TEXT}
    
      Just use the @{B}@{I}initialize@{UI}@{UB} method instead.
   @{FG SHINE}
   myChannel @{FG TEXT}

      Not normally needed by the User, but if you're curious, it returns
      the actual Audio channel number(s) being used.
   @{FG SHINE}
   volume: volumeLevel @{FG TEXT}
    
      Set the Audio volume level (range 0 to 64).
   @{FG SHINE}
   period: newPeriod @{FG TEXT}
      
      Set the Audio waveform period.
   @{FG SHINE}
   waitCycle @{FG TEXT}

      Wait until the current cycle is completed.
   @{FG SHINE}
   read @{FG TEXT}
      
      Return an Object that represents the current @{I}playAt:for:@{UI} Object.
   @{FG SHINE}
   setData: aByteArray @{FG TEXT}

      Set the data to be played (contained in @{I}aByteArray@{UI}).
   @{FG SHINE}
   playAt: volume for: duration @{FG TEXT}

      Play the sound data that's in the channel.  If the duration is zero, 
      the channel will play continuously, until you abort it (stop method).
   @{FG SHINE}
   start @{FG TEXT}

      Undo a @{I}stop@{UI} command.
   @{FG SHINE}
   stop @{FG TEXT}

      Stops the current @{I}playAt:for:@{UI} method immediately.  If there are
      no @{I}playAt:for:@{UI} methods in progress, it sets a flag so any future 
      @{I}playAt:for:@{UI} is queued up and does not begin (until you issue a @{I}start@{UI}).
   @{FG SHINE}
   reset @{FG TEXT}

   @{FG SHINE}
   changePriority: newPriority @{FG TEXT}

      
   @{FG SHINE}
   flush @{FG TEXT}

      
   @{FG SHINE}
   clear @{FG TEXT}

      
   @{FG SHINE}
   update @{FG TEXT}

      
   @{FG SHINE}
   finish @{FG TEXT}

      
   @{FG SHINE}
   lock @{FG TEXT}

      Inform the Amiga OS that the Audio channel is in use.      
   @{FG SHINE}
   read: audioFileName size: size @{FG TEXT}

      
   @{FG SHINE}
   write: audioFileName size: size @{FG TEXT}

      
   @{FG SHINE}
   freeChannel @{FG TEXT}

      Tell the system you are done with an Audio Channel.
   @{FG SHINE}
   dispose @{FG TEXT}

      Remove the instance from the AmigaTalk system.
   @{FG SHINE}
   audioKey @{FG TEXT}
      
      NOT really needed at this time (returns the allocation key).
   
@ENDNODE

@NODE NarratorClass "Narrator Class (Parent Class = Device):"

   Class @{B}Narrator@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   Narrator Device that the Amiga PC uses to talk with.  This Class requires
   that you have narrator.device (located in DEVS:) & translator.library
   (located in LIBS:) in order to work correctly.  AmigaTalk will NOT even
   execute without them (unless you modify the @{B}AmigaTalk:C/InitializeCommands@{UB}
   script file & edit out all lines referencing @{B}nar@{UB}).
   
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT}
   @{UB}
   Class Methods are:
   @{FG SHINE}
   new @{FG TEXT}

     Initialize the instance of Class Narrator.  NOTE:  Class Narrator
     is a Singleton class, which means there can be only one narrator
     while Amigatalk is running.
   @{FG SHINE}   
   close @{FG TEXT}

     De-allocate the resources for the narrator.
   @{FG SHINE}         
   setVolume: newSpeakingVolume @{FG TEXT}
   
      Change the volume of the narrator.  Range: 0 to 64 (max volume).
   @{FG SHINE}
   setSex: newSpeakerSex @{FG TEXT}

      Only Male = 1 or Female = 0 (at this time) are available.
   @{FG SHINE}
   setPitch: newSpeakingPitch @{FG TEXT}

      Set the basic frequency of the narrator's voice.
      RANGE 65 to 320 Hz (max).
   @{FG SHINE}
   setMode: newModeString @{FG TEXT}

      Robotic, Natural or Manual are the only recognized values for
      newModeString.
   @{FG SHINE}
   setRate: newSpeakingRate @{FG TEXT}

      Set the speaking rate in words-per-minute (40 to 400 max).  
   @{FG SHINE}
   setFormant1: percentDeviation @{FG TEXT}

      Change the tuning of the lowest formant frequency.  Positive values
      raise the formant frequency (Default = 0).
      RANGE: -100 to 100 by 5% steps.
   @{FG SHINE}
   setFormant2: percentDeviation @{FG TEXT}

      Change the tuning of the middle formant frequency.  Positive values
      raise the formant frequency (Default = 0).
      RANGE: -100 to 100 by 5% steps.
   @{FG SHINE}
   setFormant3: percentDeviation @{FG TEXT}

      Change the tuning of the highest formant frequency.  Positive values
      raise the formant frequency (Default = 0).
      RANGE: -100 to 100 by 5% steps.
   @{FG SHINE}
   setFormant1Amplitude: newAmplitude @{FG TEXT}

      Change the amplitude of the lowest formant frequency.  
      Positive values raise the formant Amplitude.
      RANGE: 31 to -32 dB (= OFF)
   @{FG SHINE}
   setFormant2Amplitude: newAmplitude       @{FG TEXT}

      Change the amplitude of the middle formant frequency.  
      Positive values raise the formant Amplitude.
      RANGE: 31 to -32 dB (= OFF)
   @{FG SHINE}
   setFormant3Amplitude: newAmplitude @{FG TEXT}

      Change the amplitude of the highest formant frequency.  
      Positive values raise the formant Amplitude.
      RANGE: 31 to -32 dB (= OFF)
   @{FG SHINE}
   setFlags: @{FG TEXT}
   
     NDB_NEWIORB = 1, NDB_WORDSYNC = 2, NDB_SYLSYNC = 4.
     Default:  NDB_NEWIORB only.
   @{FG SHINE}
   setVoicingAmplitude: newAVBias @{FG TEXT}

     Play with it & see what it does.  RANGE: 31 to -32 dB.
   @{FG SHINE}
   setFricationAmplitude: newAFBias @{FG TEXT}
   
     Play with it & see what it does.  RANGE: 31 to -32 dB.
   @{FG SHINE}
   speak: normalString @{FG TEXT}

     Translate the normalString into a phonetic string & have the
     Narrator speak it.
   @{FG SHINE}
   speakPhonetics: phoneticString @{FG TEXT}

     Have the Narrator speak the phoneticString.
   @{FG SHINE}
   setPriority: newSpeakingPriority @{FG TEXT}

     Default:  100.  Range: -128 to 127 (max).
   @{FG SHINE}
   setEnthusiasm: aFloat @{FG TEXT}

     set Enthusiasm of the narrator from 1/32 to 32/32.
     (32/32 is the default).
   @{FG SHINE}
   setPitchModulation: voiceQuiver @{FG TEXT}

     Add pitch modulation to the narrator.  RANGE: 0 to 255. (0 = default).
     Non-zero values make the narrator sound older.
   @{FG SHINE}
   setArticulation: newPercentArticulation @{FG TEXT}

     Set amount of slurring of words.
     RANGE: 0 to 255% (max).  (Default = 100 = 100%)   
   @{FG SHINE}
   setPhonemes: phonemeString @{FG TEXT}

     NOTE:  Used in conjunction with setCentralizeValue: method to alter
            the Narrator's acccent.

     Valid strings are:
      
     IY  long  e as in beet,   eat.
     IH  short i as in bit,    in.
     EH  short e as in bet,    end.
     AE  short a as in bat,    ad.
     AA  short o as in bottle, on.
     AH  short u as in but,    up.
     AO  short a as in ball,   awl.
     OW  long  o as in boat,   own.     (diphthong)
     UH  short u as in book,   soot.
     ER  short i as in bird,   early.
     UW  long  u as in brew,   boolean. (diphthong)

     No checking is performed on your string, so get it right!
   @{FG SHINE}
   setCentralizeValue: newCentralizePercent @{FG TEXT}

     RANGE:  0 to 100% (0 = default).
     
     NOTE:  Used in conjunction with setPhonemes: method to alter the
            Narrator's acccent.

@ENDNODE

@NODE ClipboardClass "Clipboard Class (Parent Class = Device):"

   Class @{B}Clipboard@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   Clipboard Device that the Amiga PC uses to temporarily store text & 
   images.  You may open up to 256 different clipboards, but there
   is a unique instance of this Class for each Clipboard you use.
   Valid unit Numbers are from 0 to 255.
   
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The methods are:
   @{FG SHINE}
   new @{FG TEXT}
    
     Return Clipboard unit 0.   
   @{FG SHINE}
   new: unitNum @{FG TEXT}

     Return Clipboard unitNum.
   @{FG SHINE}
   setClipUnit: unitNum @{FG TEXT}
    
     Set the unit number of the clipboard to use with other methods.
     As a user, you should never have to use this method.
   @{FG SHINE}
   writeFTXTClipToFTXTFile: fileName @{FG TEXT}

     Write the Clipboard to the fileName in FTXT format.
   @{FG SHINE}   
   writeFTXTClipToASCIIFile: fileName @{FG TEXT}

     Write the Clipboard to the fileName in plain ASCII format.
   @{FG SHINE}   
   postFTXTToClip: ftxtString @{FG TEXT}

     Place the FTXT string contents into the Clipboard.
     @{B}Experimental, do NOT use.@{UB}
   @{FG SHINE}
   sendAsciiFileToClip: fileName @{FG TEXT}
    
     Place the contents of an ASCII file to the Clipboard.
   @{FG SHINE}
   update @{FG TEXT}

     Send CMD_UPDATE to the Clipboard device.
   @{FG SHINE}
   sendFTXTFileToClip: fileName @{FG TEXT}

     Place the contents of an FTXT file to the Clipboard.
   @{FG SHINE}
   sendILBMFileToClip: fileName @{FG TEXT}

     Place the contents of an ILBM file to the Clipboard.
     (Once I figure out a clean way to do it, I'll write the code 
      to retrieve an ILBM clip).
   @{FG SHINE}
   sendAsciiStringToClip: clipString @{FG TEXT}

     Place the plain ASCII string contents into the Clipboard.
   @{FG SHINE}
   clipTypeIs @{FG TEXT}

     Return 0 if the Clipboard data is FTXT or 1 if the data is ILBM.
        
   Once the Hook class is working the following methods will be
   made available:
   @{FG SHINE}  
   WARNING!!!! @{FG TEXT} There is only space for @{B}ONE@{UB} change hook for the
                Clipboard, so be extremely careful how you use it!
   @{FG SHINE}                 
   openHookedClipboard: clipNumber withHook: aHook @{FG TEXT}
    
     Open a Clipboard with a changeHook function.

   @{FG SHINE}   
   closeHookedClipboard @{FG TEXT}

     Close a Clipboard that has a changeHook function.
     
   SEE ALSO, @{" IFFClipBoard Class " LINK "IFFClipBoardClass"}
@ENDNODE

@NODE "IFFClipBoardClass" "IFFClipBoard Class (Parent Class = Device):"

   Class @{B}IFFClipboard@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the
   Clipboard Device that the Amiga PC uses to temporarily store text only.
   You may open up to 256 different clipboards, but there
   is a unique instance of this Class for each Clipboard you use.
   Valid unit Numbers are from 0 to 255.
   
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The methods are:
   @{FG SHINE}
   writeToClipUnit: unit fromFTXTString: ftxtString @{FG TEXT}

     Place the contents of the FTXT-format string into the Clipboard.
   @{FG SHINE}     
   sendFTXTClip: unit toFTXTString: ftxtString size: numBytes @{FG TEXT}

     Place the contents of the Clipboard into a string as FTXT.

   SEE ALSO, @{" ClipBoard Class " LINK "ClipBoardClass"}        

@ENDNODE

@NODE ConsoleClass "ConsoleClass (Parent Class = Device):"

   Class @{B}Console@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   Console Device that the Amiga PC uses to send & receive keyboard input
   from the User.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   methods are:
   @{FG SHINE}
   dispose @{FG TEXT}
     
     Detach the console.device from @{" aWindow " LINK "Intuition.guide/WindowClass"} & get rid of it.
   @{FG SHINE}
   initialize: consoleName for: aWindow @{FG TEXT}

     Open a console.device & Attach it to @{" aWindow " LINK "Intuition.guide/WindowClass"}.
   @{FG SHINE}
   backSpace  @{FG TEXT}

     Write a BackSpace character to the console.
   @{FG SHINE}
   formFeed @{FG TEXT}

     Write a FormFeed character to the console.
   @{FG SHINE}
   lineFeed @{FG TEXT}

     Write a LineFeed character to the console.
   @{FG SHINE}
   carriageReturn @{FG TEXT}

     Write a Carriage Return character to the console.
   @{FG SHINE}
   bell @{FG TEXT}

     Write a Bell character (^G) to the console, which will flash the screen
     (& play a sound, if you have it set up via Workbench preferences).
   @{FG SHINE}
   crlf @{FG TEXT}

     Write a Carriage Return & LineFeed character to the console.
   @{FG SHINE}
   cursorToHome @{FG TEXT}

     Return the Console cursor to the first line & first column.
   @{FG SHINE}
   moveCursorTo: aPoint @{FG TEXT}

     Move the Console cursor to the coordinates (in characters) 
     given in @{" aPoint " LINK "GeneralClasses.guide/PointClass"} (Home position is 1@1).
   @{FG SHINE}
   nextLineStart  @{FG TEXT}

     Go to beginning of next line.
   @{FG SHINE}
   prevLineStart @{FG TEXT}

     Go to beginning of previous line.
   @{FG SHINE}
   moveCursorUp: numlines @{FG TEXT}

     Move the Console cursor up the given number of lines.
   @{FG SHINE}
   moveCursorDown: numlines @{FG TEXT}

     Move the Console cursor down the given number of lines.
   @{FG SHINE}
   moveCursorRight: numChars @{FG TEXT}

     Move the Console cursor to the right the given number of character positions.
   @{FG SHINE}
   moveCursorLeft: numChars @{FG TEXT}

     Move the Console cursor to the left the given number of character positions.
   @{FG SHINE}
   insertLineBelowCurrent @{FG TEXT}

     Insert a Blank line below the current line (where the cursor is located).
   @{FG SHINE}
   insertSpaces: numSpaces @{FG TEXT}

     Insert the given number of spaces starting at the current cursor location.  
   @{FG SHINE}
   deleteCurrentLine @{FG TEXT}

     Delete the line the cursor is currently located on.
   @{FG SHINE}
   deleteCurrentChar @{FG TEXT}

     Delete the character the cursor is currently located on.
   @{FG SHINE}
   deleteCharacters: howMany @{FG TEXT}

     Delete the character the cursor is currently located on & delete
     the characters to the right of the cursor by @{I}howMany@{UI}.
   @{FG SHINE}
   normalChars @{FG TEXT}

     Set the font display type to normal.
   @{FG SHINE}
   boldChars @{FG TEXT}

     Set the font display type to @{B}bold@{UB}.
   @{FG SHINE}
   boldCharsOff @{FG TEXT}

     Turn off the @{B}bold@{UB} font display type.
   @{FG SHINE}
   italicChars @{FG TEXT}

     Set the font display type to @{I}italic@{UI}.
   @{FG SHINE}
   italicCharsOff @{FG TEXT}

     Turn off the @{I}italic@{UI} font display type.
   @{FG SHINE}
   underlineChars @{FG TEXT}

     Set the font display type to @{U}underline@{UU}.
   @{FG SHINE}
   underlineCharsOff @{FG TEXT}

     Turn off the @{U}underline@{UU} font display type.
   @{FG SHINE}
   invertedChars @{FG TEXT}

     Set the font display type to inverted colors (i.e., foreground (text)
     color is set to background and background color is set to foreground).
   @{FG SHINE}
   invertedCharsOff @{FG TEXT}

     Turn off the inverted colors font display type.
   @{FG SHINE}
   invisibleText @{FG TEXT}

     Render text with invisible ink.
   @{FG SHINE}     
   visibleText @{FG TEXT}

     Re-enable the display of text.
   @{FG SHINE}     
   cursorInvisible @{FG TEXT}

     Turn off the cursor.
   @{FG SHINE}
   cursorVisible @{FG TEXT}

     Tutn on the display of the cursor.
   @{FG SHINE}
   textColor: colorNumber @{FG TEXT}

     Set the text color to the color register number given.
     Valid values for colorNumber are: 0 to 7 and 9, which is the default color
     (usually the same as 1).
   @{FG SHINE}
   backgroundColor: colorNumber @{FG TEXT}

     Set the background color to the color register number given.
     Valid values for colorNumber are: 0 to 7 and 9, which is the default color
     (usually the same as 0).
   @{FG SHINE}
   enableScroll @{FG TEXT}

     Enable the scrolling of the Console.
   @{FG SHINE}
   disableScroll @{FG TEXT}

     Disable the scrolling of the Console.
   @{FG SHINE}
   autoWrapOff @{FG TEXT}

     Disable the automatic wrapping of text to the next line (default is ON).
   @{FG SHINE}
   autoWrapOn @{FG TEXT}

     Enable the automatic wrapping of text to the next line (default is ON).
   @{FG SHINE}
   setPageLength: rasterLines @{FG TEXT}

     Set the length of the console page in terms of raster lines. 
     Don't use this unless you know the height of the font you're using. 
   @{FG SHINE}
   setLineLength: charPositions @{FG TEXT}

     Set the length of the line in number of characters.
   @{FG SHINE}
   setLeftOffset: rasterColumns @{FG TEXT}

     Set the left margin that text will start at.
   @{FG SHINE}
   setTopOffset: rasterLines  @{FG TEXT}

     Set the top of the display area for the text.
     Take care, you could end up in the window Title Bar!
   @{FG SHINE}
   clearTabs @{FG TEXT}

     Clear all Console tab settings.
   @{FG SHINE}
   clearTab @{FG TEXT}

     Clear the Console tab that the cursor is located at.
   @{FG SHINE}
   setTab @{FG TEXT}

     Set a Console tab to the location the cursor is at.
   @{FG SHINE}
   backTab @{FG TEXT}

     Go backwards one tab setting.
   @{FG SHINE}
   tab @{FG TEXT}

     Go forward one tab setting.
   @{FG SHINE}
   forwardTabs: numTabs @{FG TEXT}

     Go forward the given number of tab settings.
   @{FG SHINE}
   reset @{FG TEXT}

     Send a reset Code to the Console.
   @{FG SHINE}
   clear @{FG TEXT}

     Clear the entire Console display & place the cursor at the bottom
     of the Console.
   @{FG SHINE}
   clearToBottom @{FG TEXT}

     Clear the Console display from the current cursor location to the
     bottom of the Console display.
   @{FG SHINE}
   getChar @{FG TEXT}

     Get a @{" Character " LINK "GeneralClasses.guide/CharClass"} from the Console.
   @{FG SHINE}
   getString @{FG TEXT}

     Get a @{" String " LINK "GeneralClasses.guide/StringClass"} from the Console.
   @{FG SHINE}
   putChar: aCharacter @{FG TEXT}

     Write a @{" Character " LINK "GeneralClasses.guide/CharClass"} to the Console display.
   @{FG SHINE}
   putString: aString @{FG TEXT}

     Write a @{" String " LINK "GeneralClasses.guide/StringClass"} to the Console display,
     followed by a Carriage Return-LineFeed.
   @{FG SHINE}
   putStringNoReturn: aString @{FG TEXT}

     Write a @{" String " LINK "GeneralClasses.guide/StringClass"} to the Console display.
   @{FG SHINE}
   csi @{FG TEXT}
   
     Return CSI (Command Sequence Introducer, which is 16r9B) as a String.
   @{FG SHINE}
   esc @{FG TEXT}
   
     Return ESCAPE (which is 16r1B) as a @{" String " LINK "GeneralClasses.guide/StringClass"}.
   @{B}
   SEE ALSO, @{UB}@{" Key Class " LINK "KeyboardClass"}

@ENDNODE

@NODE KeyboardClass "Keyboard Class (Parent Class = Device):"

   This class is NOT a full implementation of the keyboard.device, just
   a way to get keystrokes from a Window.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   Bear in mind that the keyCodes returned by the @{B}getRawKey@{UB} method are
   RawKey codes, NOT ASCII!

   Use this Class if you need function keys, ESC, Help, Mouse buttons
   or the Arrow keys for some purpose, otherwise use @{B}getVanillaKey@{UB}, the 
   Console Class, the NewGadgets or NewMenus class for getting vanilla keys.

   Use the translateKey: method to get an ASCII value for the
   RawKey (if there is one; '?' will be returned for non-ASCII keys)

   methods are:
   @{FG SHINE}
   initialize @{FG TEXT}

     Initialize the instance variables.
   @{FG SHINE}
   registerTo: thisWindow @{FG TEXT}

     Which Window will be the focus of your keyboard activity?  @{I}thisWindow@{UI}
     of course.
   @{FG SHINE}
   getRawKey @{FG TEXT}
     
     Wait for a key press from the User & return the Raw KeyCode.
   @{FG SHINE}
   translateKey: rawKeyCode @{FG TEXT}

     Return the ASCII-equivalent of the given rawKeyCode (if there is one).
   @{FG SHINE}
   getVanillaKey @{FG TEXT}
     
     Wait for a key press from the User & return the Vanilla (ASCII) KeyCode.
   @{FG SHINE}
   keyCode @{FG TEXT}
     
     Return the last keyCode.
   @{FG SHINE}
   keyQualifiers @{FG TEXT}

     Return the last key Qualifier(s).
   @{FG SHINE}
   keyShifted @{FG TEXT}

     Return true if the last key Qualifier indicates a @{B}SHIFT@{UB} key was pressed.
   @{FG SHINE}
   keyControlled @{FG TEXT}

     Return true if the last key Qualifier indicates @{B}CTRL@{UB} was pressed.
   @{FG SHINE}
   keyAlternated @{FG TEXT}

     Return true if the last key Qualifier indicates @{B}ALT@{UB} was pressed.
   @{FG SHINE}
   leftShift @{FG TEXT}
     
     Return the BitMask for the Left Shift key Qualifier.
   @{FG SHINE}
   rightShift @{FG TEXT}

     Return the BitMask for the Right Shift key Qualifier.
   @{FG SHINE}
   capsLock @{FG TEXT}
     
     Return the BitMask for the CapsLock key Qualifier.
   @{FG SHINE}
   control @{FG TEXT}

     Return the BitMask for the @{B}CTRL@{UB} key Qualifier.
   @{FG SHINE}
   leftAlt @{FG TEXT}
    
     Return the BitMask for the Left @{B}ALT@{UB} key Qualifier.
   @{FG SHINE}
   rightAlt @{FG TEXT}

     Return the BitMask for the Right @{B}ALT@{UB} key Qualifier.
   @{FG SHINE}
   leftAmiga @{FG TEXT}

     Return the BitMask for the Left @{B}AMIGA@{UB} key Qualifier.
   @{FG SHINE}
   rightAmiga @{FG TEXT}

     Return the BitMask for the Right @{B}AMIGA@{UB} key Qualifier.
   @{FG SHINE}
   leftMouseButton @{FG TEXT}

     Return the BitMask for the Left Mouse Button Qualifier.
   @{FG SHINE}
   rightMouseButton @{FG TEXT}

     Return the BitMask for the Right Mouse Button Qualifier.
   @{FG SHINE}
   middleMouseButton @{FG TEXT}

     Return the BitMask for the Middle Mouse Button Qualifier.
   @{FG SHINE}
   numericPad @{FG TEXT}

     Return the BitMask for the Numeric Pad Qualifier.
   @{FG SHINE}
   repeatKey @{FG TEXT}

     Return the BitMask for the Repeat key Qualifier.
   @{B}
   SEE ALSO, @{UB}@{" Console Class " LINK "ConsoleClass"}
@ENDNODE

@NODE "MouseClass" "Mouse Class (Parent Class = GamePort):"

   Class @{B}Mouse@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the
   GamePort Device that the Amiga PC uses to detect input events from a
   mouse, such as movement or button clicks.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The Class implements the following methods:
   
   @{FG SHINE}
   openMousePort: unit named: portname @{FG TEXT}

     Open the given GamePort unit & assign it the given portname.  If a
     unit is already in use, AmigaTalk will @{B}NOT@{UB} open the given unit.
   @{FG SHINE}   
   closeMousePort @{FG TEXT}

     Close the GamePort & remove it from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   clearMousePortBuffer @{FG TEXT}

     Flush the gameport events out of the device.
   @{FG SHINE}
   getButtonCode @{FG TEXT}

     Return the button Code that the gameport received.
   @{FG SHINE}
   getQualifiers @{FG TEXT}

     Return the input event Qualifiers that the gameport received.
   @{FG SHINE}
   getXPos @{FG TEXT}

     Return the x-position that the gameport received. 
   @{FG SHINE}
   getYPos @{FG TEXT}

     Return the y-position that the gameport received. 
   @{FG SHINE}
   getIEAddress @{FG TEXT}

     Return the Event Address that the gameport received.
     @{B}WARNING:  If you don't know what this is, don't use this method!@{UB}
   @{FG SHINE}
   getTimeStamp   @{FG TEXT}  

     Return the Event seconds value that the gameport received.
   @{FG SHINE}
   getTriggerKeys @{FG TEXT}

     Return which type of key/button presses the gameport is looking for.
     Either GPTF_UPKEYS = 2, GPTF_DOWNKEYS = 1 or both = 3 will be
     valid values.
   @{FG SHINE}
   getTriggerTime   @{FG TEXT}       

     Return the timeout value that the gameport is currently set to.
   @{FG SHINE}
   getTriggerXDelta @{FG TEXT}

     Return the horizontal direction trigger value that the gameport
     device is currently set to.
   @{FG SHINE}
   getTriggerYDelta @{FG TEXT}

     Return the vertical direction trigger value that the gameport
     device is currently set to.
   @{FG SHINE}
   setKeyTransition: transType @{FG TEXT}

     Tell AmigaTalk which type of key/button press to react to.  
     @{I}transType@{UI} is either GPTF_UPKEYS = 2 or GPTF_DOWNKEYS = 1 or 
     both in value.
   @{FG SHINE}
   setTimeTransition: timeOutValue @{FG TEXT}

     Tell Amigatalk when to let time expire on GamePort events.
   @{FG SHINE}
   setXDeltaTransition: xvalue @{FG TEXT}

     Tell AmigaTalk how far in the horizontal direction the gameport
     device has to move to generate an event.
   @{FG SHINE}
   setYDeltaTransition: yvalue @{FG TEXT}

     Tell AmigaTalk how far in the vertical direction the gameport
     device has to move to generate an event.
   @{FG SHINE}
   waitForButton: kvalue @{FG TEXT}

     Tell AmigaTalk to wait for a mouse button being pressed.  See the 
     @{I}TestFiles/TestMousePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForQualifier: qvalue @{FG TEXT}

     Tell AmigaTalk to wait for a mouse button being pressed.  See the 
     @{I}TestFiles/TestMousePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForXPos:      xvalue @{FG TEXT}
     
     Tell AmigaTalk to wait for the given x-position value to occur.
     If xvalue is less than zero, the User has to move the mouse left. 
   @{FG SHINE}
   waitForYPos:      yvalue @{FG TEXT}

     Tell AmigaTalk to wait for the given y-position value to occur.
     If yvalue is less than zero, the User has to move the mouse ??.
@ENDNODE

@NODE "AbsJoyStickClass" "AbsJoyStick Class (Parent Class = GamePort):"

   Class @{B}AbsJoyStick@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the
   GamePort Device that the Amiga PC uses to detect input events from an
   Absolute-type joystick (normally, a User should be using the 
   @{" RelJoyStick " LINK "RelJoyStick"} Class).
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The Class implements the following methods:
   
   @{FG SHINE}
   openGamePort: unit named: portname @{FG TEXT}

     Open the given GamePort unit & assign it the given portname.  If a
     unit is already in use, AmigaTalk will @{B}NOT@{UB} open the given unit.
   @{FG SHINE}   
   closeGamePort @{FG TEXT}

     Close the GamePort & remove it from the Amigatalk system.
   @{FG SHINE}
   clearGamePortBuffer @{FG TEXT}

     Flush the gameport events out of the device.
   @{FG SHINE}
   setKeyTransition: transType @{FG TEXT}

     Tell AmigaTalk which type of key press to react to.  
     @{I}transType@{UI} is either GPTF_UPKEYS = 2 or GPTF_DOWNKEYS = 1 or 
     both in value.
   @{FG SHINE}
   setTimeTransition: timeOutValue @{FG TEXT}

     Tell Amigatalk when to let time expire on GamePort events.
   @{FG SHINE}
   setXDeltaTransition: xvalue @{FG TEXT}

     Tell AmigaTalk how far in the horizontal direction the gameport
     device has to move to generate an event (normally, xvalue = 1).
   @{FG SHINE}
   setYDeltaTransition: yvalue @{FG TEXT}

     Tell AmigaTalk how far in the vertical direction the gameport
     device has to move to generate an event (normally yvalue = 1).
   @{FG SHINE}
   waitForButton:    kvalue @{FG TEXT}

     Tell AmigaTalk to wait for the Fire button being pressed.  See the 
     @{I}TestFiles/TestGamePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForQualifier: qvalue @{FG TEXT}
     
     Tell AmigaTalk to wait for the Fire button being pressed.  See the 
     @{I}TestFiles/TestGamePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForXPos:      xvalue @{FG TEXT}
     
     Tell AmigaTalk to wait for the given x-position value to occur.
     For Absolute-type joysticks (GPCT_ABSJOYSTICK), the valid values are:
        @{B}-1 = left, 0 = no movement, +1 = right.@{UB}
   @{FG SHINE}
   waitForYPos:      yvalue @{FG TEXT}

     Tell AmigaTalk to wait for the given y-position value to occur.
     For Absolute-type joysticks (GPCT_ABSJOYSTICK), the valid values are:
        @{B}-1 = up, 0 = no movement, +1 = down.@{UB}
   @{FG SHINE}
   getButtonCode @{FG TEXT}

     Return the button Code that the gameport received.
   @{FG SHINE}
   getQualifiers @{FG TEXT}

     Return the input event Qualifiers that the gameport received.
   @{FG SHINE}
   getXPos @{FG TEXT}

     Return the x-position that the gameport received. 
   @{FG SHINE}
   getYPos @{FG TEXT}

     Return the y-position that the gameport received. 
   @{FG SHINE}
   getIEAddress @{FG TEXT}

     Return the Event Address that the gameport received.
     @{B}WARNING:  If you don't know what this is, don't use this method!@{UB}
   @{FG SHINE}
   getTimeStamp   @{FG TEXT}  

     Return the Event seconds value that the gameport received.
   @{FG SHINE}
   getTriggerKeys @{FG TEXT}

     Return which type of key presses the gameport is looking for.
     Either GPTF_UPKEYS = 2, GPTF_DOWNKEYS = 1 or both = 3 will be
     valid values.
   @{FG SHINE}
   getTriggerTime   @{FG TEXT}       

     Return the timeout value that the gameport is currently set to.
   @{FG SHINE}
   getTriggerXDelta @{FG TEXT}

     Return the horizontal direction trigger value that the gameport
     device is currently set to.
   @{FG SHINE}
   getTriggerYDelta @{FG TEXT}

     Return the vertical direction trigger value that the gameport
     device is currently set to.
@ENDNODE

@NODE "RelJoyStickClass" "RelJoyStick Class (Parent Class = GamePort):"

   Class @{B}RelJoyStick@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the
   GamePort Device that the Amiga PC uses to detect input events from a
   Relative-type joystick.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The Class implements the following methods:
   
   @{FG SHINE}
   openGamePort: unit named: portname @{FG TEXT}

     Open the given GamePort unit & assign it the given portname.  If a
     unit is already in use, AmigaTalk will @{B}NOT@{UB} open the given unit.
   @{FG SHINE}   
   closeGamePort @{FG TEXT}

     Close the GamePort & remove it from the Amigatalk system.
   @{FG SHINE}
   clearGamePortBuffer @{FG TEXT}

     Flush the gameport events out of the device.
   @{FG SHINE}
   setKeyTransition: transType @{FG TEXT}

     Tell AmigaTalk which type of key press to react to.  
     @{I}transType@{UI} is either GPTF_UPKEYS = 2 or GPTF_DOWNKEYS = 1 or 
     both in value.
   @{FG SHINE}
   setTimeTransition: timeOutValue @{FG TEXT}

     Tell Amigatalk when to let time expire on GamePort events.
   @{FG SHINE}
   setXDeltaTransition: xvalue @{FG TEXT}

     Tell AmigaTalk how far in the horizontal direction the gameport
     device has to move to generate an event.
   @{FG SHINE}
   setYDeltaTransition: yvalue @{FG TEXT}

     Tell AmigaTalk how far in the vertical direction the gameport
     device has to move to generate an event.
   @{FG SHINE}
   waitForButton:    kvalue @{FG TEXT}

     Tell AmigaTalk to wait for the Fire button being pressed.  See the 
     @{I}TestFiles/TestGamePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForQualifier: qvalue @{FG TEXT}
     
     Tell AmigaTalk to wait for the Fire button being pressed.  See the 
     @{I}TestFiles/TestGamePort@{UI} file or Amiga OS 3.0+ include file 
     @{I}Devices/InputEvent.h@{UI} for additional information.
   @{FG SHINE}
   waitForXPos:      xvalue @{FG TEXT}
     
     Tell AmigaTalk to wait for the given x-position value to occur.
   @{FG SHINE}
   waitForYPos:      yvalue @{FG TEXT}

     Tell AmigaTalk to wait for the given y-position value to occur.
   @{FG SHINE}
   getButtonCode @{FG TEXT}

     Return the button Code that the gameport received.
   @{FG SHINE}
   getQualifiers @{FG TEXT}

     Return the input event Qualifiers that the gameport received.
   @{FG SHINE}
   getXPos @{FG TEXT}

     Return the x-position that the gameport received. 
   @{FG SHINE}
   getYPos @{FG TEXT}

     Return the y-position that the gameport received. 
   @{FG SHINE}
   getIEAddress @{FG TEXT}

     Return the Event Address that the gameport received.
     @{B}WARNING:  If you don't know what this is, don't use this method!@{UB}
   @{FG SHINE}
   getTimeStamp   @{FG TEXT}  

     Return the Event seconds value that the gameport received.
   @{FG SHINE}
   getTriggerKeys @{FG TEXT}

     Return which type of key presses the gameport is looking for.
     Either GPTF_UPKEYS = 2, GPTF_DOWNKEYS = 1 or both = 3 will be
     valid values.
   @{FG SHINE}
   getTriggerTime   @{FG TEXT}       

     Return the timeout value that the gameport is currently set to.
   @{FG SHINE}
   getTriggerXDelta @{FG TEXT}

     Return the horizontal direction trigger value that the gameport
     device is currently set to.
   @{FG SHINE}
   getTriggerYDelta @{FG TEXT}

     Return the vertical direction trigger value that the gameport
     device is currently set to.
@ENDNODE

@NODE GamePortClass "GamePort Class (Parent Class = Device):"

   Class @{B}GamePort@{UB} is an abstract Parent Class for the following
   classes: 
   
      @{" Mouse       " LINK "MouseClass"} 
      @{" AbjJoyStick " LINK "AbsJoyStickClass"} 
      @{" RelJoyStick " LINK "RelJoyStickClass"} 

   The subClasses implement more functionality for the @{B}GamePort@{UB} Device.

   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   The Class implements the following methods:
   
   @{FG SHINE}
   openGamePort: whichUnit named: portname @{FG TEXT}

     For this Class, this method returns an error @{" String " LINK "GeneralClasses.guide/StringClass"} that tells the
     User that a subClass has to implement this method.
   @{FG SHINE}
   getControllerType: portname @{FG TEXT}

     This method returns an @{" Integer " LINK "GeneralClasses.guide/IntegerClass"} that corresponds to:

       -1 = GPCT_ALLOCATED    -- indicating port is already being used. 
        0 = GPCT_NOCONTROLLER -- indicating port is NOT being used.
        1 = GPCT_MOUSE        -- indicating port is a mouse. 
        2 = GPCT_RELJOYSTICK  -- indicating port is a  Relative JoyStick.
        3 = GPCT_ABSJOYSTICK  -- indicating port is an Absolute JoyStick.
 
   @{FG SHINE}
   new: dummy @{FG TEXT}
   
     For this Class, this method returns an error String that tells the
     User that @{I}new:@{UI} is @{B}NOT@{UB} understood by this Class.
@ENDNODE

@NODE ParallelClass "ParallelClass (Parent Class = Device):"

   Class @{B}ParallelDevice@{UB} allows the user of @{B}AmigaTalk@{UB} to 
   utilize the Parallel Device that the Amiga PC uses to control the 
   parallel port.  @{FG SHINE}NOTE: @{FG TEXT} The parallel.device has to be opened with the 
   PARF_SHARED flag set, so @{B}AmigaTalk@{UB} makes sure to provide it before
   opening the device is attempted.

   This class is a Singleton Class.  In the future, this class will be
   modified to allow more than one Parallel port to be open at a time
   (for those of us fortunate enough to have more than one Parallel Port.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}
   @{FG SHINE}
   status @{FG TEXT}

     Return the status (PDCMD_QUERY) of the Parallel Port.
     The returned status has the following meaning:

     BIT:  ACTIVE:  FUNCTION:

     0      HIGH   Printer Busy toggle (offline).
     1      HIGH   Paper out.
     2      HIGH   Printer Select.
     3      ----   Read = 0, Write = 1
     4-7    ----   Reserved.
   @{FG SHINE}
   resetPort @{FG TEXT}
    
     send a CMD_RESET to the ParallelPort.
   @{FG SHINE}
   flushPort @{FG TEXT}

     send a CMD_FLUSH to the ParallelPort.
   @{FG SHINE}
   stopPort @{FG TEXT}

     send a CMD_STOP to the ParallelPort.
   @{FG SHINE}                  
   startPort @{FG TEXT}

     send a CMD_START to the ParallelPort.
   @{FG SHINE}
   readThisMany: numChars @{FG TEXT}
      
     Read the desired amount of characters (bytes) from the Parallel Port.
     The return value should equal the amount of characters requested.
   @{FG SHINE}
   writeToPort: aString thisLong: numChars @{FG TEXT}

     Write the given string to the Parallel Port.  numChars should be less
     than or equal to the length of aString.
     Your device must handshake with the Amiga.  Most printers do, other-
     wise, the method will hang up at a WaitIO() forever!
   @{FG SHINE}
   setTerminatorsTo: aString @{FG TEXT}

     Set the termination array of characters to the given string of 4
     characters.  These characters have to be in descending ASCII order.
     AmigaTalk does NOT currently check that this is true.
   @{FG SHINE}
   setPortDirectionAtomic: rwFlag @{FG TEXT}

      This method actually writes to a hardware register (0xBFD200) that 
      controls the direction of the Parallel Port Data bits.  It's NOT
      needed for reading & writing to the Parallel Port.
   @{FG SHINE}
   sendPortControlBits: newBits @{FG TEXT}
 
      This method actually writes to a hardware register (0xBFD101) that
      holds the Parallel Port control bits. 

      @{B}NOTE: @{UB} Only the 3 least-significant bits will be written to the 
             hardware.  This is to prevent your code from interfering 
             with the Serial device.
   @{FG SHINE}
   readControlBitsMaskedBy: ctrlMask @{FG TEXT}

      This method actually reads a hardware register (0xBFD101) that
      holds the Parallel Port control bits. 

      NOTE:  Only the 3 least-significant bits have any meaning for the 
             Parallel Port.  Use ctrlMask of seven (7).
   @{FG SHINE}
   privateOpen: parallelFlags @{FG TEXT}

      This is the method that actually opens the Parallel Port.  Use
      @{B}new:@{UB} instead.   
   @{FG SHINE}
   close @{FG TEXT}

      This is the method that closes the Parallel Port.
   @{FG SHINE}
   new @{FG TEXT}

      This method overrides the @{B}new@{UB} method in Class & simply
      prints an error string.
   @{FG SHINE}
   privateSetup: parallelFlags @{FG TEXT}

      This is a private method, use @{B}new@{UB} instead. 
   @{FG SHINE}
   new: parallelFlags @{FG TEXT}

      This method overrides the @{B}new:@{UB} method in Class & makes this class
      a Singleton Class.  Use this method instead of @{B}open:@{UB}
   @{FG SHINE}
   testToggleCtrlBits: loopCount @{FG TEXT}

     Use this method only for verifying operation of control bits
     using test equipment of some kind on your hardware!
     loopCount of 1 is around 60 milli-Seconds so do NOT use values
     greater than 60,000 (over 1 hour).
   @{FG SHINE}
   testToggleDataBits: loopCount @{FG TEXT}

     Use this method only for verifying operation of data bits
     using test equipment of some kind on your hardware!
     loopCount of 1 is around 60 milli-Seconds so do NOT use values
     greater than 60,000 (over 1 hour).

@ENDNODE

@NODE PrinterClass "Printer Class (Parent Class = Device):"

   Class @{B}Printer@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   Printer Device that the Amiga PC uses to control printers.

   If any @{B}Send@{UB} method seems to hang the System, either Ctrl-C or
   Ctrl-D should break the I/O hangup.

   If your printer does not support a method, AmigaTalk might display
   a Requester stating that the printer.device failed to open, because
   the Error code returned by the printer.device is brain-damaged.

   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   Methods are:
   @{FG SHINE}
   initialize: initString @{FG TEXT}

     Send an initialization string to the printer.device.
   @{FG SHINE}
   getPrinterClassString @{FG TEXT}

     Return a String that describes the printer set by @{" Sys:Prefs/Printer " SYSTEM "Sys:Prefs/Printer"}
   @{FG SHINE}
   getPrinterColorClassString  @{FG TEXT}

     Return a String that describes the printer's color class set by @{" Sys:Prefs/Printer " SYSTEM "Sys:Prefs/Printer"}
   @{FG SHINE}
   getPrinterName  @{FG TEXT}

     Return a String that describes the name of the printer set by @{" Sys:Prefs/Printer " SYSTEM "Sys:Prefs/Printer"}
   @{FG SHINE}
   getNumberOfCharSets @{FG TEXT}

     Return an Integer that describes the number of character sets
     the printer can deliver.
   @{FG SHINE}
   getHorizontalDPI  @{FG TEXT}

     Return an Integer that describes the number of horizontal dots-
     per-inch that the printer is capable of printing.
   @{FG SHINE}
   getVerticalDPI  @{FG TEXT}

     Return an Integer that describes the number of vertical dots-
     per-inch that the printer is capable of printing.
   @{FG SHINE}
   getNumberOfPrintColumns  @{FG TEXT}

     Return an Integer that describes the number of character columns
     that the printer is capable of printing.
   @{FG SHINE}
   getNumberOfHeadPins  @{FG TEXT}

     Return an Integer that describes the number of pins in the
     printer printHead (if it's a dot-matrix printer).
   @{FG SHINE}
   getMaxXRasterDump  @{FG TEXT}

     Return an Integer that describes the number of dots in the 
     horizontal direction that the printer is capable of printing.
   @{FG SHINE}
   getMaxYRasterDump  @{FG TEXT}

     Return an Integer that describes the number of dots in the 
     vertical direction that the printer is capable of printing.
   @{FG SHINE}
   reset @{FG TEXT}

     Send CMD_RESET to the printer.device.
   @{FG SHINE}
   sendExtendedCmd: command parm1: p1 parm2: p2 parm3: p3 parm4: p4 @{FG TEXT}

     Send an extended command to the printer.device. 
     (See @{" PrtCommands " LINK "PrinterFlagsClass"} class.
   @{FG SHINE}
   restart @{FG TEXT}

     Send CMD_START to the printer.device.
   @{FG SHINE}
   stop @{FG TEXT}

     Send CMD_STOP to the printer.device.
   @{FG SHINE}
   flush @{FG TEXT}

     Send CMD_FLUSH to the printer.device.
   @{FG SHINE}
   query @{FG TEXT}

     Ask the printer.device to return two bytes of status (PRD_QUERY)
     as a two-byte @{" String " LINK "GeneralClasses.guide/StringClass"}.  The String might have non-displayable values!
   @{FG SHINE}
   dumpGraphics: specialArray @{FG TEXT}

     Send PRD_DUMPRPORT to the printer.device in order to print a screen
     dump.
     
      The parameters needed in specialArray are as follows:
     
        rpObj   = raster port,        RastPort Object
        cm      = color map,          ColorMap Object
        modeID  = screenModeID,       ULONG
        xOffset = source x origin,    UWORD
        yOffset = source y origin,    UWORD
        w       = source width,       UWORD
        h       = source height,      UWORD
        dc      = destination width,  LONG
        dr      = destination height, LONG
        flags   = option flags,       UWORD (See @{" PrtRPFlags " LINK "PrtRPFlagsClass"} class).
   @{FG SHINE}
   readPrinterPrefsInto: aBuffer ofSize: length @{FG TEXT}

     If the read fails because the buffer is too small you should double
     the size of the buffer and try it again.
     
     Never interpret the contents of the buffer.  You are allowed to save
     it to file (as one block of data) and of course to write it back to
     the driver (writePrinterPrefs).
     
     If you close the printer device between @{B}editPrinterPrefs:@{UB} and the
     actual printing (CMD_WRITE or @{B}dumpTaggedGraphics:@{UB}) you must read
     the prefs after @{B}editPrinterPrefs:@{UB} and write it back before printing
     or the driver may forget the user changes.
   @{FG SHINE}
   writePrinterPrefsFrom: aBuffer ofSize: length @{FG TEXT}

     This is a non standard write command that writes the driver 
     preferences.  The printer driver checks the buffer before 
     copying it to its preferences.  So you do not have to worry 
     about changing the printer driver between @{B}readPrinterPrefsInto:ofSize:@{UB}
     and this method.
   @{FG SHINE}
   editPrinterPrefs: tagArray @{FG TEXT}

     New drivers can have their own preferences.  This method asks the driver
     to open a window to allow the user to change the prefs.
     
     Every application should have a button @{B}Driver Options...@{UB} 
     (that calls this method in its printer dialog.
   @{FG SHINE}
   setPrinterErrorHook: hookObject @{FG TEXT}

     This command sets a hook that will be called if the printer.device
     returns with an error from any other I/O command.  This allows
     printer drivers to use private error messages.  @{B}DO NOT USE THIS!@{UB}

     In general, Hooks will probably NOT be added to the AmigaTalk system,
     since they are NOT Object-Oriented (as implemented by the Amiga OS).
   @{FG SHINE}
   dumpTaggedGraphics: specialArray @{FG TEXT}

      Send PRD_DUMPRPORTTAGS to the printer.device in order to print a screen
      dump.
     
      The parameters needed in specialArray are as follows:
     
        rpObj   = raster port,        RastPort Object
        cm      = color map,          ColorMap Object
        modeID  = screenModeID,       ULONG
        xOffset = source x origin,    UWORD
        yOffset = source y origin,    UWORD
        w       = source width,       UWORD
        h       = source height,      UWORD
        dc      = destination width,  LONG
        dr      = destination height, LONG
        flags   = option flags,       UWORD (See @{" PrtRPFlags " LINK "PrtRPFlagsClass"} class.)
        tags    = tagList             TagItem Object
   @{FG SHINE}
   getPrinterErrorString @{FG TEXT}

     Return a String that describes the last Printer Error Number found.
   @{FG SHINE}
   close @{FG TEXT}

     Close the printer.device & remove it from AmigaTalk program space.
   @{FG SHINE}
   open: printerName @{FG TEXT}

     Allocate the internal memory & structures needed for opening
     the printer.device.
   @{FG SHINE}
   sendRawWrite: buffer ofLength: length @{FG TEXT}

     Send a Raw buffer of data to the printer.device.
   @{FG SHINE}
   write: thisString ofLength: length @{FG TEXT}

     Write a string @{I}length@{UI} bytes long to the printer.device.
   @{FG SHINE}
   asyncWrite: thisString ofLength: length @{FG TEXT}

     Write a string @{I}length@{UI} bytes long to the printer.device 
     with asynchronous I/O.
   
   @{B}SHORTCUTS FOR COMMON PRINTER COMMANDS: @{UB}
   @{FG SHINE}
   crlf @{FG TEXT}

     Send a Carriage Return-LineFeed command code to the Printer.
   @{FG SHINE}
   nlqOn @{FG TEXT}

     Send a Near-Letter-Quality ON command code to the Printer.
   @{FG SHINE}
   nlqOff @{FG TEXT}

     Send a Near-Letter-Quality OFF command code to the Printer.
   @{FG SHINE}
   normalCharSet @{FG TEXT}

     Send a Normal Character Set command code to the Printer.
   @{FG SHINE}
   italicsOn @{FG TEXT}

     Send an Italics ON command code to the Printer.
   @{FG SHINE}
   italicsOff @{FG TEXT}

     Send an Italics OFF command code to the Printer.
   @{FG SHINE}
   underlineOn @{FG TEXT}

     Send an Underline ON command code to the Printer.
   @{FG SHINE}
   underlineOff @{FG TEXT}

     Send an Underline OFF command code to the Printer.
   @{FG SHINE}
   boldOn @{FG TEXT}

     Send an BoldFace ON command code to the Printer.
   @{FG SHINE}
   boldOff @{FG TEXT}

     Send an BoldFace OFF command code to the Printer.
   @{FG SHINE}
   normalPitch @{FG TEXT}

     Send an Normal Pitch command code to the Printer.
   @{FG SHINE}
   elitePitchOn @{FG TEXT}

     Send an Elite Pitch ON command code to the Printer.
   @{FG SHINE}
   elitePitchOff @{FG TEXT}

     Send an Elite Pitch OFF command code to the Printer.
   @{FG SHINE}
   condensedPitchOn @{FG TEXT}

     Send a Condensed Fine Pitch ON command code to the Printer.
   @{FG SHINE}
   condensedPitchOff @{FG TEXT}

     Send a Condensed Fine Pitch OFF command code to the Printer.
   @{FG SHINE}
   enlargedPitchOn @{FG TEXT}

     Send a Enlarged Pitch ON command code to the Printer.
   @{FG SHINE}
   enlargedPitchOff @{FG TEXT}

     Send a Enlarged Pitch OFF command code to the Printer.
   @{FG SHINE}
   superScriptOn @{FG TEXT}

     Send a SuperScript ON command code to the Printer.
   @{FG SHINE}
   superScriptOff @{FG TEXT}

     Send a SuperScript OFF command code to the Printer.
   @{FG SHINE}
   subScriptOn @{FG TEXT}

     Send a SubScript ON command code to the Printer.
   @{FG SHINE}
   subScriptOff @{FG TEXT}

     Send a SubScript OFF command code to the Printer.
   @{FG SHINE}
   normalizeLine @{FG TEXT}

     Send a Normalize the line (after super or sub-scripting)
     command code to the Printer.
   @{FG SHINE}
   partialLineUp @{FG TEXT}

     Send a Partial line UP command code to the Printer.
   @{FG SHINE}
   partialLineDown @{FG TEXT}

     Send a Partial line DOWN command code to the Printer.
   @{FG SHINE}
   setFormLength: numLines @{FG TEXT}

     Send a Set Form Length nn command code to the Printer.
   @{FG SHINE}
   setPerfSkip: numLines @{FG TEXT}

     Send a Set Perforation Skip nn command code to the Printer.
   @{FG SHINE}
   perfSkipOff @{FG TEXT}

     Send a Perforation Skip OFF command code to the Printer.
   @{FG SHINE}
   setLeftMargin: numSpaces @{FG TEXT}

     Send a Left Margin Set nn command code to the Printer.
   @{FG SHINE}
   setRightMargin: numSpaces @{FG TEXT}

     Send a Right Margin Set nn command code to the Printer.
   @{FG SHINE}
   setTopMargin: numLines @{FG TEXT}

     Send a Top Margin Set nn command code to the Printer.
   @{FG SHINE}
   setBottomMargin: numLines @{FG TEXT}

     Send a Bottom Margin Set nn command code to the Printer.
   @{FG SHINE}
   setTopAndBottomMargins: topLines bottom: bottomLines @{FG TEXT}

     Send a Top & Bottom Margin Set nn command code to the Printer.
   @{FG SHINE}
   setLeftAndRightMargins: leftSpcs right: rightSpcs @{FG TEXT}

     Send a Left & Right Margin Set nn command code to the Printer.
   @{FG SHINE}
   clearMargins @{FG TEXT}

     Send a Clear Margins command code to the Printer.
   @{FG SHINE}
   setTabs: tab1 t2: tab2 t3: tab3 t4: tab4 @{FG TEXT}

     Send a Set Horizontal Tabs command code to the Printer.
   @{FG SHINE}
   setTab: tab @{FG TEXT}

     Send a Set Horizontal Tab nn command code to the Printer.
   @{FG SHINE}
   clearTabs @{FG TEXT}

     Send a Clear ALL Horizontal Tabs command code to the Printer.
   @{FG SHINE}
   sendFormFeed @{FG TEXT}

     Send an ASCII FormFeed character (value = 12) to the Printer.

   @{B}SEE ALSO,@{UB} @{" PrintFlags Class " LINK "PrinterFlagsClass"}, 

@ENDNODE

@NODE "PrinterFlagsClass" "Printer Flags/Commands (Singleton) Class:"

   PrinterFlags Class is a Singleton class that allows the user to
   reference special printer flags/commands' hexadecimal values symbolically.

   EXAMPLE:  @{B}myPrtCmd <- prtFlags systemTag: #aRIS@{UB}

   This class is subclassed from @{" UndefinedObject " LINK "GeneralClasses.guide/UndefinedObjectClass"} and
   MUST contain the following:

   the methods:  isSingleton AND privateSetup AND
                 uniqueInstance Class instance variable.

      Methods the Class recognizes are:

   @{FG SHINE}   
   isSingleton @{FG TEXT}

     Since this Class is a Singleton, return true.  
   @{FG SHINE}  
   new @{FG TEXT}

     Create (if necessary) & initialize a new instance of the Class.
   @{FG SHINE}
   close @{FG TEXT}    " Remove, Kill, Destroy, Burn the Bridge, etc! " 

     Before exiting AmigaTalk be sure to send this message to printFlags.
     (Better still, place @{B}printFlags close@{UB} in the UpdateCommands script file).
   @{FG SHINE}
   systemTag: aSymbol @{FG TEXT}

     Search for aSymbol in the dictionary & return it's associated value:
   @{FG SHINE} 
   isNil @{FG TEXT}      
    
     We have to override our parent Class methods, because we are not nil.
   @{FG SHINE}
   notNil @{FG TEXT}

     We have to override our parent Class methods, because we are not nil.
   @{FG SHINE}
   ifNil: aBlock @{FG TEXT}

     We have to override our parent Class methods, because we are not nil.
   @{FG SHINE}
   printString @{FG TEXT}

     Simply return our dictionary fileName.

   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      Printer command definitions:
     @{FG SHINE}
     Cmd:      Meaning:                         Defined by: @{FG TEXT}
     --------- -------------------------------- -----------
     #aRIS     ESCc      reset                  ISO
     #aRIN     ESC#1     initialize             AMI
     #aIND     ESCD      lf                     ISO
     #aNEL     ESCE      return,lf              ISO
     #aRI      ESCM      reverse lf             ISO

     #aSGR0    ESC[0m    normal character set   ISO
     #aSGR3    ESC[3m    italics on             ISO
     #aSGR23   ESC[23m   italics off            ISO
     #aSGR4    ESC[4m    underline on           ISO
     #aSGR24   ESC[24m   underline off          ISO
     #aSGR1    ESC[1m    boldface on            ISO
     #aSGR22   ESC[22m   boldface off           ISO
     #aSFC     SGR30-39  set foreground color   ISO
     #aSBC     SGR40-49  set background color   ISO

     #aSHORP0  ESC[0w    normal pitch           DEC
     #aSHORP2  ESC[2w    elite on               DEC
     #aSHORP1  ESC[1w    elite off              DEC
     #aSHORP4  ESC[4w    condensed fine on      DEC
     #aSHORP3  ESC[3w    condensed off          DEC
     #aSHORP6  ESC[6w    enlarged on            DEC
     #aSHORP5  ESC[5w    enlarged off           DEC

     #aDEN6    ESC[6''z  shadow print on        DEC
     #aDEN5    ESC[5''z  shadow print off       DEC
     #aDEN4    ESC[4''z  doublestrike on        DEC
     #aDEN3    ESC[3''z  doublestrike off       DEC
     #aDEN2    ESC[2''z  NLQ on                 DEC
     #aDEN1    ESC[1''z  NLQ off                DEC

     #aSUS2    ESC[2v    superscript on         AMI
     #aSUS1    ESC[1v    superscript off        AMI
     #aSUS4    ESC[4v    subscript on           AMI
     #aSUS3    ESC[3v    subscript off          AMI
     #aSUS0    ESC[0v    normalize the line     AMI
     #aPLU     ESCL      partial line up        ISO
     #aPLD     ESCK      partial line down      ISO

     #aFNT0    ESC(B     US char set        or Typeface  0 (default)
     #aFNT1    ESC(R     French char set    or Typeface  1
     #aFNT2    ESC(K     German char set    or Typeface  2
     #aFNT3    ESC(A     UK char set        or Typeface  3
     #aFNT4    ESC(E     Danish I char set  or Typeface  4
     #aFNT5    ESC(H     Sweden char set    or Typeface  5
     #aFNT6    ESC(Y     Italian char set   or Typeface  6
     #aFNT7    ESC(Z     Spanish char set   or Typeface  7
     #aFNT8    ESC(J     Japanese char set  or Typeface  8
     #aFNT9    ESC(6     Norweign char set  or Typeface  9
     #aFNT10   ESC(C     Danish II char set or Typeface 10

       Suggested (#aFNTxx) typefaces are:
  
       *  0 - default typeface.
       *  1 - Line Printer or equivalent.
       *  2 - Pica         or equivalent.
       *  3 - Elite        or equivalent.
       *  4 - Helvetica    or equivalent.
       *  5 - Times Roman  or equivalent.
       *  6 - Gothic       or equivalent.
       *  7 - Script       or equivalent.
       *  8 - Prestige     or equivalent.
       *  9 - Caslon       or equivalent.
       * 10 - Orator       or equivalent.

     #aPROP2   ESC[2p    proportional on        AMI
     #aPROP1   ESC[1p    proportional off       AMI
     #aPROP0   ESC[0p    proportional clear     AMI
     #aTSS     ESC[n E  set proportional offset ISO
     #aJFY5    ESC[5 F   auto left justify      ISO
     #aJFY7    ESC[7 F   auto right justify     ISO
     #aJFY6    ESC[6 F   auto full justify      ISO
     #aJFY0    ESC[0 F   auto justify off       ISO
     #aJFY3    ESC[3 F   letter space (justify) ISO (special)
     #aJFY1    ESC[1 F   word fill(auto center) ISO (special)

     #aVERP0   ESC[0z    1/8'' line spacing     AMI
     #aVERP1   ESC[1z    1/6'' line spacing     AMI
     #aSLPP    ESC[nt    set form length n      DEC
     #aPERF    ESC[nq    perf skip n (n>0)      AMI
     #aPERF0   ESC[0q    perf skip off          AMI

     #aLMS     ESC#9     Left margin set        AMI
     #aRMS     ESC#0     Right margin set       AMI
     #aTMS     ESC#8     Top margin set         AMI
     #aBMS     ESC#2     Bottom marg set        AMI

     #aSTBM    ESC[Pn1;Pn2r  T&B margins        DEC
     #aSLRM    ESC[Pn1;Pn2s  L&R margin         DEC

     #aCAM     ESC#3     Clear margins          AMI

     #aHTS     ESCH      Set horiz tab          ISO
     #aVTS     ESCJ      Set vertical tabs      ISO
     #aTBC0    ESC[0g    Clr horiz tab          ISO
     #aTBC3    ESC[3g    Clear all h tab        ISO
     #aTBC1    ESC[1g    Clr vertical tabs      ISO
     #aTBC4    ESC[4g    Clr all v tabs         ISO
     #aTBCALL  ESC#4     Clr all h & v tabs     AMI
     #aTBSALL  ESC#5     Set default tabs       AMI
     #aEXTEND  ESC[Pn''x extended commands      AMI

     #aRAW     ESC[Pn''r Next @{B}Pn@{UB} chars are raw  AMI

     Dump RastPort to Printer flags that can be used by the Printer Class
     (& any subclasses):

     #SPECIAL_ASPECT
     #SPECIAL_CENTER
     #SPECIAL_NOFORMFEED
     #SPECIAL_NOPRINT
     #SPECIAL_TRUSTME
     #SPECIAL_DENSITY1
     #SPECIAL_DENSITY2
     #SPECIAL_DENSITY3
     #SPECIAL_DENSITY4
     #SPECIAL_DENSITY5
     #SPECIAL_DENSITY6
     #SPECIAL_DENSITY7
     #SPECIAL_FULLCOLS
     #SPECIAL_FULLROWS
     #SPECIAL_FRACCOLS
     #SPECIAL_FRACROWS
     #SPECIAL_MILCOLS
     #SPECIAL_MILROWS

     @{B}setPrinterErrorHook:@{UB} Symbols:
     
     #PDHOOK_NONE
     #PDHOOK_STD
     
     @{B}dumpTaggedGraphics:@{UB} tag Symbols:

      a pointer to a Hook Object which is called to read
      the source data.  io_RastPort and io_ColorMap are
      ignored and should be nil. 
     
      The hook is called with object == nil and message
      is a pointer to a DRPSourceMsg Object.  It must read
      an array of source data. 
     
      Each pixel of the array is an ULONG of form 16r00RRGGBB.
     
      Some printer drivers have set PPCB_NOSTRIPE which
      means they cannot print in stripes.  Using
      DRPA_SourceHook is the best way for printing for such
      printers because you can still prepare the printer
      source data in stripes then.
     
      The Source Hook is always called in the context of
      the printer driver DOS process.     
     
     #DRPA_SourceHook -- Ignores RastPort & ColorMap

     #DRPA_AspectX    -- the X aspect ratio.
     
     the Y aspect ratio. This values overwrites the aspect
     ratio from GfxBase or io_Modes and is used for scaling.
     
     #DRPA_AspectY
     
     #DRPA_ICCProfile   -- Reserved
     #DRPA_ICCName      -- Reserved
     #DRPA_NoColCorrect -- Reserved

     @{B}editPrinterPrefs:@{UB} tag Symbols:

      A pointer to a window.  This prefs window will open on the 
      same screen and lock the window from user input.

     #PPRA_Window
     
     A pointer to a screen that can be used if no window is open:
     #PPRA_Screen
     
     A name of a public screen that will be used to open the window.
     This can be NULL to use the default public screen.     

     #PPRA_PubScreen

     @{B}SEE ALSO,@{UB} @{" Printer Class " LINK "PrinterClass"},
@ENDNODE

@NODE SCSIClass "SCSI Class (Parent Class = Device):"
   Not implemented yet!

   <primitive 226   cmd# SCSIname>

   Class @{B}SCSI@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the SCSI
   Device that the Amiga PC uses to control SCSI peripherals.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT}

   Proposed methods are:
   
@ENDNODE

@NODE TimerClass "Timer Class (Parent Class = Device:)"

   Class @{B}Timer@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the Timer
   Device that the Amiga PC uses to control timers.  @{FG SHINE}NOTE:@{FG TEXT}  System Date &
   Time functions are implemented in class @{" AmigaTalk " LINK GeneralClasses.guide/AmigaTalkClass}
   & are totally different from the methods in this class.
   
   Timer requests fall into two categories:
   
   1. Time delay   - wait a specified amount of time.

   2. Time measure - Record the time, do other tasks, Record the time again
                     & take the difference between the two times.

   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   @{FG SHINE}
   openTimerType: type name: timerName seconds: s micros: m @{FG TEXT}
     Open the given Timer unit & assign it the given timerName.  If a
     unit is already in use, AmigaTalk will NOT open the given unit.

     Currently known Timer types recognized by the Amiga are:  

     1. UNIT_MICROHZ    (0)
     
     2. UNIT_VBLANK     (1) 
     
     3. UNIT_ECLOCK     (2) 
     
     4. UNIT_WAITUNTIL  (3) 
     
     5. UNIT_WAITECLOCK (4)

     Please read the RKM Devices manual (pg. 288 of 3rd Edition) for a
     detailed explanation of their differences.
   @{FG SHINE}
   close @{FG TEXT}
     Abort the Timer's operation.
   @{FG SHINE}
   stop @{FG TEXT}
     Stop the Timer's action.
   @{FG SHINE}
   startWithSecs: s micros: m @{FG TEXT}
     Start the Timer with the given parameters.
   @{FG SHINE} 
   delaySeconds: s micros: m @{FG TEXT}
     Start the Timer & wait for completion of the timing event.
   @{FG SHINE}
   test @{FG TEXT}
     Check that the Timer for error conditions.
   @{FG SHINE}
   getSeconds @{FG TEXT}
     Return the number of seconds that the Timer is using.
   @{FG SHINE}
   getMicros @{FG TEXT}
     Return the number of microseconds that the Timer is using.
   @{FG SHINE} 
   setSeconds: s micros: m @{FG TEXT}
     Change the timing parameters of the Timer.
   @{FG SHINE} 
   compare: s micros: m toSeconds: s2 micros: m @{FG TEXT}
     Compare the two given sets of parameters.

     if      t1 >  t2, return -1
     else if t1 <  t2, return +1
     else if t1 == t2, return 0  
   @{FG SHINE}
   getEClockHigh @{FG TEXT}
     Return the upper long word of the E-Clock time.
   @{FG SHINE}
   getEClockLow @{FG TEXT}
     Return the lower long word of the E-Clock time.

@ENDNODE

@NODE TrackDiskClass "TrackDisk Class (Parent Class = Device):"

   Class @{B}TrackDisk@{UB} allows the user of @{B}AmigaTalk@{UB} to utilize the 
   TrackDisk Device that the Amiga PC uses to control floppy disks.
   @{FG SHINE} @{B}
   WARNING:  You should know what you're doing to the Amiga OS before
             messing with this Class, or any other System Class! @{FG TEXT} @{UB}

   (See the contents of AmigaTalk:TestFiles/TestTrackDisk or type:
   @{B})r AmigaTalk:TestFiles/TestTrackDisk@{UB} into the Command Line string Gadget
   when AmigaTalk is running to see how this Class is used).
   
   Valid methods are:
   @{FG SHINE}
   new: newDiskName @{FG TEXT}

     Initialize a new instance of TrackDisk Class & call it newDiskName.
     
     @{B}NOTE:@{UB}  Diskname is in the form:  @{B}DFx:@{UB}, where x is the drive 
            number (0 to 3).
   @{FG SHINE}
   openDisk: unitNumber @{FG TEXT}
     
     Open a TrackDisk Device & add it to the AmigaTalk system. 

     @{B}NOTE:@{UB}  unitNumber should be a number from 0 to 3 & has to match the 
            drive number in newDiskName (see @{I}new: newDiskName@{UI}).
   @{FG SHINE}   
   closeDisk @{FG TEXT}

     Close the TrackDisk device & remove it from the AmigaTalk system.
   @{FG SHINE}
   readTrack: trackNumber @{FG TEXT}

     Read the given trackNumber from a TrackDisk & return it as a 
     ByteArray.
   @{FG SHINE}
   writeTrack: outputBytes track: trackNumber @{FG TEXT}

     Write a ByteArray to the given trackNumber for a TrackDisk.  Returns
     an Integer, with zero meaning success.
   @{FG SHINE}     
   getErrorString @{FG TEXT}

     Translate the current TrackDisk error number to an informative string.
   @{FG SHINE}
   getSectorSize @{FG TEXT}

     Return the TrackDisk SectorSize (normally 512 bytes).
   @{FG SHINE}
   getTrackSize @{FG TEXT}

     Return the TrackDisk (SectorSize * number of TrackSectors).
     Normally 11 TrackSectors * 512 bytes.
   @{FG SHINE}
   getDeviceType @{FG TEXT}
     Return a string indicating the TrackDisk type.  Known values are:

        "Type = Direct Access, Removable | Non-removable media."
        "Type = Sequential Access, Removable | Non-removable media."
        "Type = Printer, Removable | Non-removable media."
        "Type = Processor, Removable | Non-removable media."
        "Type = W.O.R.M., Removable | Non-removable media."
        "Type = CD-ROM, Removable | Non-removable media."
        "Type = Scanner, Removable | Non-removable media."
        "Type = Optical Disk, Removable | Non-removable media."
        "Type = Medium Changer, Removable | Non-removable media."
        "Type = Communication, Removable | Non-removable media."
        "Type = Unknown, Removable | Non-removable media."
   @{FG SHINE}
   getDriveType @{FG TEXT}
     Return an Integer Object indicating the type of TrackDisk device.

        1 = 3-1/2" Drive.
        2 = 5-1/4" Drive.
        3 = 3-1/2" Drive spinning at 150 RPM.
   @{FG SHINE}
   displayDriveType @{FG TEXT}
     Display in the status window a String Object indicating the type 
     of TrackDisk device.  The Strings will be:

        "3-1/2" Floppy Disk."
        "5-1/4" Floppy Disk."
        "3-1/2" Floppy spinning at 150 RPM."
   @{FG SHINE}
   getNumberOfTracks @{FG TEXT}

     Return the number of tracks that the TrackDisk recognizes. 
     Normally 160, or 80 Cylinders.
   @{FG SHINE}
   getTotalSectors @{FG TEXT}
    
     Return the total number of sectors present in the TrackDisk. 
     Normally 1760 for a 3-1/2" Amiga disk.
   @{FG SHINE}
   getTotalSize @{FG TEXT}
    
     Return the total number of bytes present in the TrackDisk. 
     Normally 1760 * 512 for a 3-1/2" Amiga disk.
   @{FG SHINE}
   seekTrack: trackNumber @{FG TEXT}

     Move the head of the drive to a specific track.

     NOTE:  Seeking is NOT reading!  The heads only move, nothing else.
   @{FG SHINE}
   clearReadBuffer @{FG TEXT}
     
     Tell the TrackDisk Device to mark the track buffer as invalid, forcing
     a re-read of the disk on the next operation.  
   @{FG SHINE}
   isDiskPresent @{FG TEXT}

     Return @{B}true@{UB} if a disk is in the TrackDisk, @{B}false@{UB} otherwise.   
   @{FG SHINE}
   isWriteProtected @{FG TEXT}

     Return @{B}true@{UB} if a disk is write-protected, @{B}false@{UB} otherwise.   
   @{FG SHINE}
   displayBytes: byteArray title: reqTitle @{FG TEXT}
    
     Display an array of bytecodes (such as those returned from readTrack:
     for instance) in a Requester.  This Method is also used in @{" ByteArray " LINK "GeneralClasses.guide/ByteArrayClass"}.
   @{FG SHINE} @{B}   
   WARNING:  The following methods are considered dangerous (to the health
             of your floppy disks), and should NOT be used by amateurs. @{UB}

   turnMotorOn @{FG TEXT}
     
     Start the TrackDisk motor.  This method is used by all the other
     methods as required, so it doesn't really have to be called by the
     User.
   @{FG SHINE}        
   turnMotorOff @{FG TEXT}
   
     Turn off the TrackDisk motor.  This method is used by all the other
     methods as required, so it doesn't really have to be called by the
     User.
   @{FG SHINE}
   ejectDisk @{FG TEXT}

     Tell the TrackDisk to send an eject disk command to the disk drive.
     Return an Integer.

     WARNING:  Most Amiga disk drives won't know what to do with this
               method, except return an error.  Read your disk drive
               instruction manuals to determine whether ejection is
               supported.
   @{FG SHINE}     
   formatTrack: trackNumber data: theDataBytes @{FG TEXT}

     Format the given trackNumber.
     @{B}
     WARNING:  This is a sure, quick way of trashing a disk.  Make sure
               you really know what you're doing! @{UB}
   @{FG SHINE}
   readRawData: trackNumber @{FG TEXT}

     Read the given trackNumber from a TrackDisk & return it as a 
     ByteArray of MFM data.  
     
     NOTE:  This method is only really useful for reading & decoding other
            disk formats, such as MS-DOS (yuck!).
   @{FG SHINE}     
   writeRawData: rawDataBytes track: trackNumber @{FG TEXT}
   
     Write a ByteArray of (MFM) data to the given trackNumber for a 
     TrackDisk.

     NOTE:  This method is only really useful for encoding & writing other
            disk formats, such as MS-DOS (yuck!).
   @{FG SHINE}     
   setSyncType: newSyncType @{FG TEXT}

     Change the sync-word that TrackDisk will use during reads & writes.
     If newSyncType is zero, the drive will synchronize to the Index
     hole in the floppy.  All other values will tell the drive to
     synchronize to the Sync Pattern (16r4489) in Track Gaps. 

@ENDNODE
