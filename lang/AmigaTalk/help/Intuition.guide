@DATABASE "Intuition.guide"

@REMARK "$VER: Intuition.guide 2.5 (15-Oct-2003) by James T. Steichen

@REMARK Written by Jim Steichen, Copyright (c) 1998-2003.

@WIDTH 75
@WORDWRAP

@NODE main  "Intuition-related Classes for AmigaTalk© 1998-2003:"

   Described herein are the classes & their methods for manipulating 
   Amiga-Intuition objects with AmigaTalk.  Please be aware that each
   Class that I've added to AmigaTalk is generic & all-purpose.  So
   there is a lot of methods that you won't have to use all of the time.
   I would encourage you to write your own subClasses, & just use
   your own standard Window sizes, Images, BitMaps, etc.

   The class hierarchy is:

     @{" Workbench " LINK "WorkbenchClass"} (parent class is Object) - New for V2.0+
        
     @{" BasicIFF " LINK "BasicIFFClass"} (parent class is Object) - New for V1.9+
       @{" ExamineIFF " LINK "ExamineIFFClass"} - New for V1.9+

     @{" Glyph "       LINK "GlyphClass"} (parent class is Object)   

       @{" Screen      " LINK "ScreenClass"}
       @{" Window      " LINK "WindowClass"}
       @{" Menu        " LINK "MenuClass"}
       @{" Gadget      " LINK "GadgetClass"}
       @{" Color       " LINK "ColorMapClass"}
       @{" LargeColors " LINK "LargeColorClass"} - New for V2.5+
       @{" Requester   " LINK "RequesterClass"}
       @{" Border      " LINK "BorderClass"}
       @{" BitMap      " LINK "BitMapClass"}
       @{" Painter     " LINK "PainterClass"}
       @{" Image       " LINK "ImageClass"}
       @{" IStruct     " LINK "IStructClass"} -- NOT implemented yet!
       @{" Animation   " LINK "AnimClass"} -- NOT implemented yet!

       @{" Font        " LINK "FontClass"}
       @{" IText       " LINK "ITextClass"}
       @{" Icon        " LINK "IconClass"} - New for V1.8+

     @{" GadgetSystem " LINK "GadgetSystemClass"} (parent class is Array) - New for V2.5+
     @{" CommonGadget " LINK "CommonGadgetClass"} (parent class is Glyph) - New for V2.5+
       @{" GetFileGadget  " LINK "GetFileGadgetClass"} - New for V2.5+
       @{" ButtonGadget   " LINK "ButtonGadgetClass"} - New for V2.5+
       @{" CheckBoxGadget " LINK "CheckBoxGadgetClass"} - New for V2.5+
       @{" IntegerGadget  " LINK "IntegerGadgetClass"} - New for V2.5+
       @{" ListViewGadget " LINK "ListViewGadgetClass"} - New for V2.5+
       @{" MXGadget       " LINK "MXGadgetClass"} - New for V2.5+
       @{" NumberGadget   " LINK "NumberGadgetClass"} - New for V2.5+
       @{" CycleGadget    " LINK "CycleGadgetClass"} - New for V2.5+
       @{" PaletteGadget  " LINK "PaletteGadgetClass"} - New for V2.5+
       @{" ScrollerGadget " LINK "ScrollerGadgetClass"} - New for V2.5+
       @{" SliderGadget   " LINK "SliderGadgetClass"} - New for V2.5+
       @{" StringGadget   " LINK "StringGadgetClass"} - New for V2.5+
       @{" TextGadget     " LINK "TextGadgetClass"} - New for V2.5+

     @{" MenuStrip    " LINK "MenuStripClass"} (parent class is Object) - New for V2.5+
     @{" NewMenu      " LINK "NewMenuClass"} (parent class is Object) - New for V2.5+
     
     @{"  Layers   " LINK "LayersClass"} (parent class is Object) - New for V2.3+

@ENDNODE   

@NODE "LayersClass" "Layers Class:" 

   The Class @{B}Layers@{UB} implements the functions in layers.library (you must
   really be a glutton for punishment!).  Be warned that this Class can
   do really @{B}DANGEROUS@{UB} things to your AmigaOS environment, including
   locking up your system (just reset it).  Be sure to read the AutoDocs
   about all layers.library functions @{B}BEFORE@{UB} you use this Class if you've
   never programmed Amiga graphic manipulation using layers.library. 
   I highly recommend leaving this Class for the experts to use.

   Only applications that create and manage their own View will be able
   to use the following methods:
 
   newLayerInfo
   disposeLayerInfo
   createUpFrontLayer: thisBitMap start: SPoint end: ePoint flags: flags second: bitMap2
   createBehindLayer:  thisBitMap start: SPoint end: ePoint flags: flags second: bitMap2
   deleteLayer: layerObject
   moveLayer: layerObject to: newPoint
   sizeLayer: layerObject by: lowRightCornerPoint
   moveAndSizeLayer: layerObject to: newPoint sizeChange: dPoint
   scrollLayer: layerObject by: deltaPoint
   makeLayerLast: layerObject
   makeLayerFirst: layerObject
   placeLayer: layerObject inFrontOf: thisLayer
   VOID SwapBitsRastPortClipRect( struct RastPort *rp, struct ClipRect *cr );
   beginLayerUpdate: layerObject
   endLayerUpdate: layerObject flag: flag

   The methods that this class recognizes are:
   @{FG SHINE}
   newLayerInfo @{FG TEXT}

     Returns a layerInfo Object or nil.
   @{FG SHINE}
   disposeLayerInfo@{FG TEXT}

     Get rid of the Class instance variable (after you're done with it,
     of course!).
   @{FG SHINE}
   createUpFrontLayer: thisBitMap start: SPoint end: ePoint 
                flags: flags     second: bitMap2@{FG TEXT}

     Create a new top Layer for your graphics. 
     Returns a layer Object or nil.
   @{FG SHINE}    
   createBehindLayer: thisBitMap start: SPoint end: ePoint flags: flags second: bitMap2@{FG TEXT}

     Create a new bottom Layer for your graphics.
     Returns a layer Object or nil.
   @{FG SHINE}
   deleteLayer: layerObject @{FG TEXT}

     Returns @{B}true@{UB} if successful.
   @{FG SHINE}
   moveLayer: layerObject to: newPoint @{FG TEXT}

     Move a Layer to a new starting point.  Returns @{B}true@{UB} if successful.
   @{FG SHINE}
   sizeLayer: layerObject by: lowRightCornerPoint @{FG TEXT}

     Resize a Layer to a new size point.  Returns @{B}true@{UB} if successful.
   @{FG SHINE}
   moveAndSizeLayer: layerObject to: newPoint sizeChange: dPoint @{FG TEXT}

     Move & resize a Layer to the given coordinates.
     Returns @{B}true@{UB} if successful.
   @{FG SHINE}
   scrollLayer: layerObject by: deltaPoint @{FG TEXT}

     Scroll a Layer by the given amount.
   @{FG SHINE}
   makeLayerLast: layerObject@{FG TEXT}

     (Same as LONG BehindLayer( LONG dummy, struct Layer *layer );)
     Move a Layer to the bottom of the Layer stack.
   @{FG SHINE}
   makeLayerFirst: layerObject @{FG TEXT}

     (Same as LONG UpfrontLayer( LONG dummy, struct Layer *layer );)
     Move a Layer to the top of the Layer stack.
   @{FG SHINE}
   placeLayer: layerObject inFrontOf: thisLayer@{FG TEXT}

     (Same as LONG MoveLayerInFrontOf( struct Layer *layer_to_move, 
                                       struct Layer *other_layer );)
     Shuffle the arrangement of Layers.
   @{FG SHINE}
   whichLayerContains: thisPoint @{FG TEXT}

     (Same as struct Layer *WhichLayer( struct Layer_Info *li, LONG x, LONG y );)
     Test whether the Layer contains the given point. 
     Returns the Layer Object that contains the point.
   @{FG SHINE}
   swapBitsFrom: rastPort with: clipRectangleObj@{FG TEXT}

     (Same as VOID SwapBitsRastPortClipRect( struct RastPort *rp,
                                             struct ClipRect *cr );)
   @{FG SHINE}
   beginLayerUpdate: layerObject@{FG TEXT}

     (Same as LONG BeginUpdate( struct Layer *layer );)
   @{FG SHINE}
   endLayerUpdate: layerObject flag: flag@{FG TEXT}

     (Same as VOID EndUpdate( struct Layer *layer, ULONG flag );)
   @{FG SHINE}
   lockLayer: layerObject @{FG TEXT}

     Lock the given Layer Object.
   @{FG SHINE}
   unlockLayer: layerObject@{FG TEXT}

     Unlock the given Layer Object.
   @{FG SHINE}
   lockAllLayers@{FG TEXT}

     (Same as VOID LockLayers( struct Layer_Info *li );)
   @{FG SHINE}
   unlockAllLayers@{FG TEXT}

     (Same as VOID UnlockLayers( struct Layer_Info *li );)
   @{FG SHINE}
   lockLayerInfo@{FG TEXT}

     Lock the LayerInfo.
   @{FG SHINE}
   unlockLayerInfo@{FG TEXT}

     Unlock the LayerInfo.
   @{FG SHINE}
   installClipRegion: aRegion to: layerObject@{FG TEXT}

     Returns a region Object or nil (which is sometimes a valid return).
   @{FG SHINE}
   fattenLayerInfo@{FG TEXT}

     Pad the LayerInfo (with more calories??)
   @{FG SHINE}
   thinLayerInfo@{FG TEXT}

     Remove excess LayerInfo padding (??)
   @{FG SHINE}
   createTopLayerHook: hook with: thisBitMap from: sPoint to: ePoint 
                flags: f  second: bitMap2@{FG TEXT}

     (Same as struct Layer *CreateUpfrontHookLayer( struct Layer_Info *li, 
                                                    struct BitMap *bm, 
                                                    LONG x0, LONG y0, 
                                                    LONG x1, LONG y1, 
                                                    LONG flags, 
                                                    struct Hook   *hook,
                                                    struct BitMap *bm2   );) 
     
     Returns a layer Object or nil.
   @{FG SHINE} @{B}
     NOTE:  Hook Objects are NOT currently implemented!!@{FG TEXT}@{UB}
   @{FG SHINE}
   createLastLayerHook: hook with: thisBitMap from: sPoint to: ePoint 
                 flags: f  second: bitMap2@{FG TEXT}

     (Same as struct Layer *CreateBehindHookLayer( struct Layer_Info *li, 
                                                   struct BitMap *bm, 
                                                   LONG x0, LONG y0, 
                                                   LONG x1, LONG y1, 
                                                   LONG flags, 
                                                   struct Hook   *hook, 
                                                   struct BitMap *bm2  );
      
     Returns a layer Object or nil.
   @{FG SHINE} @{B}
     NOTE:  Hook Objects are NOT currently implemented!!@{FG TEXT}@{UB}
   @{FG SHINE}
   installLayerHook: hook to: layerObject@{FG TEXT}

     Returns a hook Object or nil.
   @{FG SHINE}@{B}
     NOTE:  Hook Objects are NOT currently implemented!!@{FG TEXT}@{UB}
   @{FG SHINE}
   installLayerInfoHook: hook@{FG TEXT}

     Returns a hook Object or nil.
   @{FG SHINE}@{B}
     NOTE:  Hook Objects are NOT currently implemented!!@{FG TEXT}@{UB}
   @{FG SHINE}
   sortLayerCR: layerObject at: aPoint @{FG TEXT}
    
     Sort Layers by ClipRegion??
   @{FG SHINE}
   doClipRectHook: hook on: rastPortObj with: rectangleObj @{FG TEXT}

     Perform a Hook function on a RastPort??
   @{FG SHINE}@{B}
     NOTE:  Hook Objects are NOT currently implemented!!@{FG TEXT}@{UB}
   @{FG SHINE}
   initLayers: layerInfoObject@{FG TEXT}

     Get the Layers in LayerInfo ready.
   @{FG SHINE}
   lockLayerROM: layerObject@{FG TEXT}

   @{FG SHINE}
   unlockLayerROM: layerObject@{FG TEXT}

   @{FG SHINE}
   attemptToLockLayerROM: layerObject@{FG TEXT}

   @{FG SHINE}
   newRegion@{FG TEXT}

     Returns a region Object or nil.
   @{FG SHINE}
   disposeRegion: regionObject@{FG TEXT}

     Get rid of the given regionObject.
   @{FG SHINE}
   andRegion: aRegion with: aRectangle @{FG TEXT}

     Perform a Logical AND on a Region. 
     (Same as VOID AndRectRegion( struct Region *region,
                                  CONST struct Rectangle *rectangle );)
   @{FG SHINE}
   orRegion: aRegion with: aRectangle @{FG TEXT}
     
     Perform a Logical OR on a Region. 
     (Same as BOOL OrRectRegion( struct Region *region, 
                                 CONST struct Rectangle *rectangle );)
   @{FG SHINE}
   xorRegion: aRegion with: aRectangle @{FG TEXT}

     Perform a Logical XOR on a Region.
     (Same as BOOL XorRectRegion( struct Region *region,
                                  CONST struct Rectangle *rectangle );)
   @{FG SHINE}
   clearRegion: aRegion in: aRectangle @{FG TEXT}

     Clear a Region with the given coordinates.
     (Same as BOOL ClearRectRegion( struct Region *region,
                                    CONST struct Rectangle *rectangle );)
   @{FG SHINE}
   orRegionRegion: destRegion to: srcRegion@{FG TEXT}

     Perform a Logical OR operation on two Regions.
   @{FG SHINE}
   xorRegionRegion: srcRegion and: destRegion@{FG TEXT}

     Perform a Logical XOR operation on two Regions.
   @{FG SHINE}
   andRegionRegion: srcRegion and: destRegion @{FG TEXT}

     Perform a Logical AND operation on two Regions.
   @{FG SHINE}
   clearRegion: aRegion@{FG TEXT}

     Clear a complete Region.
   @{FG SHINE}
   synchronizeSuperBitMap: layerObject@{FG TEXT}

     (Same as VOID SyncSBitMap( struct Layer *layer );)
   @{FG SHINE}
   copySuperBitMap: layerObject@{FG TEXT}

     (Same as VOID CopySBitMap( struct Layer *layer );)
   
@ENDNODE

@NODE "WorkbenchClass" "Workbench Class:"

   Workbench Class implements the functions that the AmigaOS uses to
   interface to workbench.  Dealings with Icons are performed in
   @{" Icon Class " LINK "IconClass"}.  Some methods in this Class
   use @{" Tags " LINK "IntTags.guide/WorkbenchTagsClass"} that are located in WorkbenchTags.st

   The Methods are:
   @{FG SHINE}
   closeWorkbench @{FG TEXT}

      Returns true if the Workbench was closed, false if not.
   @{FG SHINE}
   openWorkbench    @{FG TEXT}

      Returns true if the Workbench was opened, false if not.
   @{FG SHINE}
   workbenchToBack@{FG TEXT}

      Returns true if Workbench was moved, false if not.   
   @{FG SHINE}
   workbenchToFront@{FG TEXT}

      Returns true if Workbench was moved, false if not.
   @{FG SHINE}
   addAppWindow: windowObj port: msgPort id: id data: userData tags: tagArray @{FG TEXT}

     Returns an appWindow Object or nil.
   @{FG SHINE}
   removeAppWindow: appWindowObject@{FG TEXT}

     Returns true if the AppWindow was removed or false, if not.
   @{FG SHINE}
   addAppIcon: text port: msgPort   id: id data: userData lock: fileLock
                    icon: diskObj tags: tagArray @{FG TEXT}

     Returns an appIcon Object or nil.
   @{FG SHINE}
   removeAppIcon: appIconObject@{FG TEXT}

     Returns true if the AppIcon was removed, false if not.
   @{FG SHINE}
   addAppMenuItem: text port: msgPort id: id data: userData tags: tagArray @{FG TEXT}
     
     Returns an appMenuItem Object or nil.
   @{FG SHINE}
   removeAppMenuItem: appMenuItemObject@{FG TEXT}

     Returns true if the AppMenuItem was removed, false if not.
   @{FG SHINE}
   workbenchInfo: objName lock: fileLock screen: screenObject@{FG TEXT}

     <primitive 209 1 8 private fileLock objName screenObject>
   @{FG SHINE}
   openWorkbenchObject: objName tags: tagArray@{FG TEXT}

     Returns true or false.
   @{FG SHINE}
   closeWorkbenchObject: objName tags: tagArray@{FG TEXT}

     Returns true or false.
   @{FG SHINE}
   workbenchControl: objName tags: tagArray@{FG TEXT}
     
     Returns true or false.
   @{FG SHINE}
   addAppWindowDropZone: appWindow id: id data: userData tags: tagArray@{FG TEXT}

     Returns an appWindowDropZone Object or nil.
   @{FG SHINE}
   removeAppWindowDropZone: appWindow dropZone: appWindowDropZoneObject@{FG TEXT}
     
     Returns true or false.
   @{FG SHINE}
   changeWorkbenchSelection: objName hook: hookObject tags: tagArray@{FG TEXT}

     Returns true or false.
   @{FG SHINE}
   makeWorkbenchObjectVisible: objName tags: tagArray@{FG TEXT}

     Returns true or false.

@ENDNODE

@NODE "BasicIFFClass" "BasicIFF Class:"
   The BasicIFF Class interfaces AmigaTalk to the iffparse.library.  See
   class IDNumbers in IFFConstants.st file for valid ID numbers that
   identify valid IFF chunks that IFF files & Objects contain.

      EXAMPLE:  16r424F4459 is 'BODY'

   You should have access to the documentation for iffparse.library (or
   wait for me to write some examples of how to use this Class ;).  I'm
   NOT going to re-hash the IFF documentation for iffparse.library.  The
   Help directory is getting complicated as it is.
   
   The Methods are:
   @{FG SHINE}
   closeIFF @{FG TEXT}
      
      Dispose of the IFF Object that was in the System.
   @{FG SHINE}
   openIFF: iffFileName type: fileType mode: mode @{FG TEXT}

      Open a file that contain IFF object(s).  @{I}fileType@{UI} here means:
        
         0 for a file, & 1 for a clipboard.  @{I}mode@{UI} is either 
        
         #IFFF_READ, #IFFF_WRITE or #IFFF_RWBITS.
   @{FG SHINE}
   initIFFHook: hookObj flags: flags @{FG TEXT}
    
      Add a hook to the IFF object.
   @{FG SHINE}
   initIFFAsDOS @{FG TEXT}
    
      Initialize an IFF object as an AmigaDOS file.
   @{FG SHINE}
   initIFFAsClip @{FG TEXT}

      Initialize an IFF object as an AmigaDOS Clipboard.
   @{FG SHINE}
   closeClipboard @{FG TEXT}
      
      Close the previously opened Clipboard.
   @{FG SHINE}
   openClipboard: clipUnitNumber @{FG TEXT}
    
      Open a Clipboard with the given clipUnitNumber.  Range for 
      @{I}clipUnitNumber@{UI} is 0 to 255.  If you supply an out-of-range
      @{I}clipUnitNumber@{UI}, this method will open clip number 0.
   @{FG SHINE}
   parseIFF: mode @{FG TEXT}

      Parse the IFF object using the supplied mode.  Valid values for
      @{I}mode@{UI} are:

        #IFFPARSE_SCAN
        #IFFPARSE_STEP
        #IFFPARSE_RAWSTEP
   @{FG SHINE}
   readChunkBytes: byteArray size: numBytes @{FG TEXT}
    
      Read a chunk of bytes from the IFF object into the @{I}byteArray@{UI} that's
      @{I}numBytes@{UI} in size.
   @{FG SHINE}
   readChunkRecords: byteArray size: numBytes number: numRecords @{FG TEXT}

      Read the given number of records (@{I}numRecords@{UI}) into a chunk of bytes 
      from the IFF object into the @{I}byteArray@{UI} that's @{I}numBytes@{UI} in size.
   @{FG SHINE}
   writeChunkBytes: byteArray size: numBytes @{FG TEXT}

      Write a chunk of bytes from the @{I}byteArray@{UI} that's
      @{I}numBytes@{UI} in size to the IFF object.
   @{FG SHINE}
   writeChunkRecords: byteArray size: numBytes number: numRecords @{FG TEXT}

      Write the given number of records (@{I}numRecords@{UI}) from a chunk of bytes 
      to the IFF object.  The @{I}byteArray@{UI} is @{I}numBytes@{UI} in size.
   @{FG SHINE}
   stopChunk: type id: id @{FG TEXT}
      
      Tell parseIFF: which chunks to stop upon entry into the given chunk.  
      The most common types are: 

         #ID_ILBM, #ID_FTXT, #ID_SMUS, #ID_8SVX, #ID_ANIM

      See IDNumbers Class in IFFConstants.st for @{I}id@{UI} values.
   @{FG SHINE}
   stopChunks: iffObj with: propertyArray size: numPairs @{FG TEXT}

      Do a bunch of stopChunk settings at once.  The propertyArray 
      is constructed as follows:
      
        ele[1] <- type,     ele[2] <- id,
        ele[3] <- nextType, ele[4] <- nextid,
        ...
   @{FG SHINE}
   currentChunk @{FG TEXT}
    
      Return the current chunk as an Object.
   @{FG SHINE}
   propertyChunk: type id: id @{FG TEXT}
    
      Tell parseIFF: what chunks this IFF object is supposed to have.
   @{FG SHINE}
   propertyChunks: iffObj with: propertyArray size: numPairs @{FG TEXT}

      Do a bunch of propertyChunk settings at once.  The propertyArray 
      is constructed as follows:
        
         ele[1] <- type,     ele[2] <- id,
         ele[3] <- nextType, ele[4] <- nextid,
         ...
   @{FG SHINE}
   findProperty: type id: id @{FG TEXT}
    
      Tell iffparse.library which chunk to find.
   @{FG SHINE}
   collectionChunk: type id: id @{FG TEXT}

      Collect ALL instances of a specified chunk.
   @{FG SHINE}
   collectionChunks: iffObj with: propertyArray size: numPairs @{FG TEXT}
      
      Do a bunch of collectionChunk settings at once.  The propertyArray 
      is constructed as follows:
      
        ele[1] <- type,     ele[2] <- id,
        ele[3] <- nextType, ele[4] <- nextid,
        ...
   @{FG SHINE}
   findCollection: type id: id @{FG TEXT}
    
      Find the collected chunks currently in scope.
   @{FG SHINE}
   stopOnExit: type id: id @{FG TEXT}
      
      Tell iffParse: to stop just before leaving the given chunk.
   @{FG SHINE}
   addEntryHandlerHook: hookObj for: anObject type: type id: id position: pos @{FG TEXT}

      Install a custom chunk entry handler that will be invoked after the parser
      enters the given chunk. @{FG SHINE}
      WARNING:  If you don't know what this does (I certainly don't!), 
                then DO NOT use it! @{FG TEXT}
   @{FG SHINE}
   addExitHandlerHook: hookObj for: anObject type: type id: id position: pos @{FG TEXT}

      Install a custom chunk exit handler that will be invoked before the parser
      leaves the given chunk. @{FG SHINE}
      WARNING:  If you don't know what this does (I certainly don't!), 
                then DO NOT use it! @{FG TEXT}
   @{FG SHINE}
   pushChunk: type id: id size: size @{FG TEXT}

      Tell iffParse: you are about to begin writing a new chunk.
      @{I}size@{UI} can also be #IFFSIZE_UNKNOWN if you dont know the size, but this
      is slower than supplying the correct size.
   @{FG SHINE}
   popChunk @{FG TEXT}
      
      When you are through writing data to a chunk, complete the write 
      by using this method.  Every call to pushChunk MUST have a 
      corresponding call to this method! 
   @{FG SHINE}
   parentChunk @{FG TEXT}
    
      Find the parent of a relevant context node object.
   @{FG SHINE}
   allocateLocalItem: ident type: type id: id size: dataSize @{FG TEXT}

      Create a local item having the specified @{I}type, id, & ident@{UI} values; and
      with @{I}dataSize@{UI} bytes of buffer space for your application to use.
   @{FG SHINE}
   getLocalItemData @{FG TEXT}
      
      Obtain a local item buffer Object.  Remember that the size of this
      buffer is what you asked for with @{B}allocateLocalItem:type:id:size:@{UB}
   @{FG SHINE}
   storeLocalItem: position @{FG TEXT}

      Store a local item Object in a context node.  The position argument
      determines where the local item is stored.  The possible values are:
      
         #IFFSLI_ROOT, #IFFSLI_TOP & #IFFSLI_PROP.
   @{FG SHINE}
   storeItemInContext @{FG TEXT}
    
      Use this when you already have a context node Object to which you
      want to attach a local item Object.
   @{FG SHINE}
   findPropertyContext @{FG TEXT}
    
      Find the topmost context Object for @{B}storeLocalItem:@{UB}
   @{FG SHINE}
   findLocalItem: ident type: type id: id @{FG TEXT}
   
      After you've stored your local item Object in a context node Object,
      you can retrieve it later with this method.
   @{FG SHINE}
   freeLocalItem @{FG TEXT}
    
      Dispose of the local item Object obtained via @{B}allocateLocalItem:type:id:size:@{UB} 
   @{FG SHINE}
   setLocalItemPurge: hookObj @{FG TEXT}

      Add a hook that the parser will call before deleting local item(s).
   @{FG SHINE}
   getErrorString: errorNumber @{FG TEXT}

      Return a String Object that describes the given @{I}errorNumber@{UI}.
   @{FG SHINE}
   idToString: identifier @{FG TEXT}

      Convert the given 32-bit identifier into a String object.  Probably
      useful someday.
   @{FG SHINE}
   getPropertySize: propertyObject @{FG TEXT}

      Return an Integer describing the size of the propertyObject.
   @{FG SHINE}
   getPropertyData: propertyObject @{FG TEXT}

      Return an Integer describing the data location of the propertyObject.
   @{FG SHINE}
   getCollectionSize: collectionObject @{FG TEXT}

      Return an Integer describing the size of the collectionObject.
   @{FG SHINE}
   getCollectionData: collectionObject @{FG TEXT}

      Return an Integer describing the data location of the collectionObject.
@ENDNODE

@NODE "ExamineIFFClass" "ExamineIFF Class:"

   The ExamineIFF Class allows the User to obtain various chunks from an
   IFF file (NOT clipboards).
   Available methods for this class are:
   @{FG SHINE}
   initialize @{FG TEXT}
   
      Use this method after: @{B}myIFFExaminer <- ExamineIFF new@{UB}
   @{FG SHINE}
   privateObtainChunk: chunkType from: fileName id: chunkID parent: pID @{FG TEXT}

      @{B}You DO NOT need to use this method!@{UB}      
   @{FG SHINE}
   obtainBMHD: fileName @{FG TEXT}

      Return an Integer Object that describes the BitMap Header chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainCMAP: fileName @{FG TEXT}

      Return an Integer Object that describes the ColorMap chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainCAMG: fileName @{FG TEXT}

      Return an Integer Object that describes the ViewModes chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainPixelData: fileName @{FG TEXT}

      Return an Integer Object that describes the Pixel data chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainCHRS: fileName @{FG TEXT}

      Return an Integer Object that describes the Text data chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainVHDR: fileName @{FG TEXT}

      Return an Integer Object that describes the Voice Header chunk found
      in the given @{I}fileName@{UI}.
   @{FG SHINE}
   obtainVoiceData: fileName @{FG TEXT}

      Return an Integer Object that describes the Voice data chunk found
      in the given @{I}fileName@{UI}.
@ENDNODE

@NODE GlyphClass "Glyph Class:"
@PREV "Main"

   Class @{B}Glyph@{UB} is an abstract class that serves as a parent class for
   most Intuition-related classes.

   @{FG SHINE}
   glyphType   @{FG TEXT}
     Return the receiver class @{I}asString@{UI}.  In class @{B}Glyph@{UB}, this
     method simply returns an error message.

   @{FG SHINE}
   isDisplayed   @{FG TEXT}
     Return true if the object is being displayed, else return false.
     For class @{B}Glyph@{UB}, this method simply returns as error message.
   
@ENDNODE

@NODE "GadgetSystemClass" "GadgetSystem Class:"
@PREV "Main"
@NEXT "CommonGadgetClass"

   The class named GadgetSystem is necessary for setting up the 
   environment for a bunch of NewGadgets, since a @{" GUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} usually has 
   more than one Gadget in it.  See @{B}TestFiles/TestGadTool@{UB} for an 
   example of how to use this Class.

   The methods for GadgetSystem class are:
   @{FG SHINE}
   new: @{" forUserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} @{FG TEXT}
      
      Setup internal instance variables of the Class.
   @{FG SHINE}
   gadgetList @{FG TEXT}
      
      Return the instance that matches the internal gadget List.
   @{FG SHINE}
   dispose    @{FG TEXT}

      Free allocated resources (if any).
   @{FG SHINE}
   firstGadget @{FG TEXT}

      Return the instance that matches the first Gadget in the
      gadget List.
   @{FG SHINE}
   visualInfo @{FG TEXT}
      
      Used by subclasses to retrieve the visualInfo Object.
   @{FG SHINE}
   textAttributes @{FG TEXT}
      
      Used by subclasses to retrieve the Screen text Attributes.
   @{FG SHINE}
   addGadgetToList: newGadgetObj at: gadgetObj type: gType tags: tagArray @{FG TEXT}

      Equivalent to CreateGadgetA() from gadtools.library.

   SEE ALSO, @{" NewMenu " LINK "NewMenuClass"}, @{" CommonGadget " LINK "CommonGadgetClass"},
             @{" ButtonGadget " LINK "ButtonGadgetClass"}, @{" CheckBoxGadget " LINK "CheckBoxGadgetClass"},
             @{" IntegerGadget " LINK "IntegerGadgetClass"}, @{" ListViewGadget " LINK "ListViewGadgetClass"},
             @{" MXGadget " LINK "MXGadgetClass"}, @{" NumberGadget " LINK "NumberGadgetClass"},
             @{" CycleGadget " LINK "CycleGadgetClass"}, @{" PaletteGadget " LINK "PaletteGadgetClass"},
             @{" ScrollerGadget " LINK "ScrollerGadgetClass"}, @{" SliderGadget " LINK "SliderGadgetClass"},
             @{" StringGadget " LINK "StringGadgetClass"}, @{" TextGadget " LINK "TextGadgetClass"}

@ENDNODE

@NODE "CommonGadgetClass" "CommonGadget Class (Parent Class is Glyph):"

   This class contains common methods for all the different types of
   NewGadgets in NewGadget.st.

   These classes are meant for use with UserGUI & its subclasses.
   They do NOT allow for remote updating via the underlying model.  
   The corresponding Auto??Gadget classes do.

   Be sure to look at @{B}AmigaTalk:TestFiles/TestNewGadTool@{UB} for better examples
   of how to use NewGadget(s).
   @{FG SHINE}
   NOTE:  Hotkeys assigned to subclass NewGadgets do NOT behave as you might
          expect them to.  A Hotkey press will simply return the last valid
          value for the given NewGadget (A hotkey for a NewGadget is 
          ambiguous; for example, which value should you return for a MX
          Gadget the next MX string or the previous?). @{FG TEXT}
             
   In general, all NewGadget classes should have the following notes
   adhered to:

   structArray is an Array Object with the following elements in the     
   given order:
     ele[1]  <- ng_LeftEdge,   ele[2]  <- ng_TopEdge,
     ele[3]  <- ng_Width,      ele[4]  <- ng_Height,
     ele[5]  <- ng_GadgetText, ele[6]  <- ng_TextAttr,
     ele[7]  <- ng_GadgetID,   ele[8]  <- ng_Flags,
     ele[9]  <- ng_VisualInfo, ele[10] <- ng_UserData

     ele[11] <- NewGadget Type Tag
     ele[12] <- HotKey or nil.

     ele[10] (UserData) can be any AmigaTalk object 
     but I recommend that you use a #methodSymbol.

     ele[7] (GadgetID) should be a 16-Bit Integer value.

   Some the ele[]'s are not used in certain subclassed NewGadgets; for example,
   MXGadget's do not use the ele[3], ele[4] & ele[12] elements.
   
   Class Methods are as follows:
   @{FG SHINE}
   glyphType @{FG TEXT}
   
      Answer with the type of NewGadget associated with this instance.
   @{FG SHINE}
   isDisplayed @{FG TEXT}

      If the window is not nil, then answer true.
   @{FG SHINE}
   window @{FG TEXT}
   
      Answer with the window Object we've been registered to.
   @{FG SHINE}
   registerTo: aWindowObject @{FG TEXT}

      Set our window instance variable to @{I}aWindowObject.@{UI}
   @{FG SHINE}
   dispose @{FG TEXT}

      Release resources associated with this instance.
   @{FG SHINE}
   gadgetTypeFor: typeSymbol @{FG TEXT}
   
      Set our NewGadget type according to the @{I}typeSymbol.@{UI}
   @{FG SHINE}
   defaultOrientationFor: typeSymbol @{FG TEXT}
   
      This method only pertains to Scrollers & Sliders, & sets the
      orientation of either the SliderGadget or ScrollerGadget that
      we're responding to.
   @{FG SHINE}
   test: gadgetName @{FG TEXT}

      Respond with a default test method for the NewGadget that decoded
      from the UserGUI controller loop.
   @{FG SHINE}
   gadgetType @{FG TEXT}
   
      Answer with the NewGadget type associated with this instance.
   @{FG SHINE}
   gadget  @{FG TEXT}
   
      Answer with the NewGadget associated with this instance.
   @{FG SHINE}
   gadgetName @{FG TEXT}

      Answer with the gadget Label (ng_GadgetText), or in the case of
      GENERIC_KIND gadgets, answer with the gadget ID (ng_GadgetID).
   @{FG SHINE}
   value: newAspect @{FG TEXT}

      Set the state/contents of the Gadget to @{I}newAspect.@{UI}
   @{FG SHINE}
   value @{FG TEXT}

      Answer with the current state/contents of the NewGadget.
   @{FG SHINE}
   setup: srcArray @{FG TEXT}
   
      Initialize the NewGadget structure to @{I}srcArray.@{UI}
   @{FG SHINE}
   addToGList: gadgetList at: gadgetObject with: tagArray @{FG TEXT}
   
      Add our instance to the gadgetList.  
   @{FG SHINE}
   setValue   @{FG TEXT}
   
      Make instance variable reflect the Gadget contents.
   @{FG SHINE}
   newGadget: gadgetType @{FG TEXT}

      Create a NewGadget of @{I}gadgetType.@{UI}
   @{FG SHINE}
   initializeValue: newAspect @{FG TEXT}
   
      Set our aspect instance variable @{B}myAspect@{UB} to @{I}newAspect.@{UI}

   All other methods are private & support the documented methods.
   
   SEE ALSO, @{" GadgetSystem " LINK "GadgetSystemClass"}, @{" GetFileGadget " LINK "GetFileGadgetClass"},
             @{" ButtonGadget " LINK "ButtonGadgetClass"}, @{" CheckBoxGadget " LINK "CheckBoxGadgetClass"},
             @{" IntegerGadget " LINK "IntegerGadgetClass"}, @{" ListViewGadget " LINK "ListViewGadgetClass"},
             @{" MXGadget " LINK "MXGadgetClass"}, @{" NumberGadget " LINK "NumberGadgetClass"},
             @{" CycleGadget " LINK "CycleGadgetClass"}, @{" PaletteGadget " LINK "PaletteGadgetClass"},
             @{" ScrollerGadget " LINK "ScrollerGadgetClass"}, @{" SliderGadget " LINK "SliderGadgetClass"},
             @{" StringGadget " LINK "StringGadgetClass"}, @{" TextGadget " LINK "TextGadgetClass"}

@ENDNODE

@NODE "GetFileGadgetClass" "GetFileGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "ButtonGadgetClass"

   This Class is a simple Image Button that displays a getFile glyph.
   Use it to indicate to the User that a fileName string Gadget can be
   filled from an ASL File Requester called by this GetFileGadget.

   GetFileGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoGetFileGadget class does.

   structArray is an Array Object with the following elements blanked
   out:
     ele[5]  <- nil,           
     ele[6]  <- nil,
     ele[12] <- nil.

   Class Methods are as follows:
   @{FG SHINE}
   dispose @{FG TEXT}
      
     Release resource(s) associated with this NewGadget.
   @{FG SHINE}
   setup: thisArray @{FG TEXT}

      
     Create all needed parts for a getFile NewGadget (GENERIC_KIND).
   @{FG SHINE}
   addToGList: gadgetList at: gadgetObject with: tagArray @{FG TEXT}
   
     Add this instance to the @{I}gadgetList.@{UI}
   @{FG SHINE}
   new: newAction @{FG TEXT}

     Create a new GetFileGadget instance.
   @{FG SHINE}
   buttonPressed @{FG TEXT}

     Subclasses should override this & use it to process User interaction
     with ASL File Requesters. 
   @{FG SHINE}
   testGetFileGadget @{FG TEXT}

     Use this method as an example of what @{B}buttonPressed@{UB} should
     do.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "ButtonGadgetClass" "ButtonGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "CheckBoxGadgetClass"

   ButtonGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoButtonGadget class does.

   This Class is meant for giving User control over actions that can be
   taken from the UserGUI, such as '_OKAY', or '_CANCEL' operations.

   Example usage:
   newGadget    <- ButtonGadget new: newAction
   newStruct    <- #( 10 40 100 20 'My _Gadget'
                      textAttrObj gadgetID 
                      myFlags vi userData 
                      nil $G )
 
   newGadgetObj <- newGadget setup: newStruct

   The Class methods available are:
   @{FG SHINE}
   new: newAction @{FG TEXT}

     Make a new instance of the Class.
   @{FG SHINE}
   buttonPressed @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the button gets pressed by the user.
   @{FG SHINE}
   testButtonGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     
   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "CheckBoxGadgetClass" "CheckBoxGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "IntegerGadgetClass"

   CheckBoxGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoCheckBoxGadget class does.

   This Class is meant for giving User a way to choose to set/clear an
   option.

   The Class methods available are:
   @{FG SHINE}
   new: newAction @{FG TEXT}

     Make a new instance of the Class.
   @{FG SHINE}
   buttonPressed @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the checkBox gets pressed by the user.
   @{FG SHINE}
   testCheckBoxGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     
   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "IntegerGadgetClass" "IntegerGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "ListViewGadgetClass"

   IntegerGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoIntegerGadget class does.

   IntegerGadget class allows the User to enter an Integer value into
   a UserGUI & its subclasses.

   The Class methods available are:
   @{FG SHINE}
   new: newInteger @{FG TEXT}

     Make a new instance of the Class.
   @{FG SHINE}
   value: newInteger @{FG TEXT}

     Set our instance variable @{I}myInteger.@{UI}
   @{FG SHINE}
   value @{FG TEXT}

     Retrieve the current contents of the IntegerGadget.
   @{FG SHINE}
   testIntegerGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.

   SEE ALSO, @{" CommonGaget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "ListViewGadgetClass" "ListViewGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "MXGadgetClass"

   ListViewGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoListViewGadget class does.

   This Class is meant for giving the User a way to choose from a List
   of indeterminate length any String/Item displayed.

   The Class methods available are:
   @{FG SHINE}
   dispose @{FG TEXT}
      
     Release resource(s) associated with this instance.
   @{FG SHINE}
   new: theseStrings @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   value @{FG TEXT}
   
     Retrieve the currently selected item (String).
   @{FG SHINE}
   choicesTag @{FG TEXT}
        
     This method is used to initialize the tagArray for the @{B}addToGList:at:with:@{UB}
     method, so that the ListView actually has some content.  Read the 
     TestFiles/TestNewGadTool file for where it's used.
   @{FG SHINE}
   listContents @{FG TEXT}
   
     Answer with the Array of items displayed in the Gadget.
   @{FG SHINE}
   selectionMade @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the ListView gets an item selected by the user.
   @{FG SHINE}
   setValue @{FG TEXT}

     Set the instance variable to reflect the current item selection index.
   @{FG SHINE}
   testListViewGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     This serves as a good example of what to do in the @{B}selectionMade@{UB} method.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "MXGadgetClass" "MXGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "NumberGadgetClass"

   MXGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoMXGadget class does.

   This Class is meant for giving the User a way to choose from a List
   of Mutually exclusive choices.

   The Class methods available are:
   @{FG SHINE}
   dispose @{FG TEXT}
      
     Release resource(s) associated with this instance.
   @{FG SHINE}
   new: theseStrings @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   choicesTag @{FG TEXT}
        
     This method is used to initialize the tagArray for the @{B}addToGList:at:with:@{UB}
     method, so that the MXGadgets are labeled.  Read the 
     TestFiles/TestNewGadTool file for where it's used.
   @{FG SHINE}
   value @{FG TEXT}
   
     Retrieve the currently selected item (String).
   @{FG SHINE}
   choices @{FG TEXT}
   
     Answer with the Array of choices for the Gadget(s).
   @{FG SHINE}
   selectionMade @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the MXGadget gets selected by the user.
   @{FG SHINE}
   setValue @{FG TEXT}

     Set the instance variable to reflect the current item selection index number.
   @{FG SHINE}
   testMXGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     This serves as a good example of what to do in the @{B}selectionMade@{UB} method.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "NumberGadgetClass" "NumberGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "CycleGadgetClass"

   NumberGadget class allows the User to view an Integer value in
   a UserGUI & its subclasses.  A NumberGadget is a read-only gadget,
   so the @{I}testNumberGadget@{UI} method will never get sent.

   The Class methods available are:
   @{FG SHINE}
   new: newNumber @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   value: newNumber @{FG TEXT}

     Set our instance variable & Gadget contents to @{I}newNumber.@{UI}
   @{FG SHINE}
   value @{FG TEXT}

     Retrieve the current Gadget contents.
   @{FG SHINE}
   testNumberGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "CycleGadgetClass" "CycleGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "PaletteGadgetClass"

   CycleGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoCycleGadget class does.

   This Class is meant for giving the User a way to choose from a (small) List
   of choices.

   The Class methods available are:
   @{FG SHINE}
   dispose @{FG TEXT}
      
     Release resource(s) associated with this instance.
   @{FG SHINE}
   new: theseStrings @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   choicesTag @{FG TEXT}
        
     This method is used to initialize the tagArray for the @{B}addToGList:at:with:@{UB}
     method, so that the CycleGadget has some labels.  Read the 
     TestFiles/TestNewGadTool file for where it's used.
   @{FG SHINE}
   value @{FG TEXT}
   
     Retrieve the currently displayed choice String.
   @{FG SHINE}
   choices @{FG TEXT}
   
     Answer with the Array of choices for the Gadget.
   @{FG SHINE}
   selectionMade @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the CycleGadget gets pressed by the user.
   @{FG SHINE}
   setValue @{FG TEXT}

     Set the instance variable to reflect the current choice selection index.
   @{FG SHINE}
   testCycleGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     This serves as a good example of what to do in the @{B}selectionMade@{UB} method.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "PaletteGadgetClass" "PaletteGadget Class:"
@PREV "GadgetSystemClass"
@NEXT "ScrollerGadgetClass"

   PaletteGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoPaletteGadget class does.
   
   This Class is meant for giving the User a way to choose from an
   array of colored boxes.  The colors cannot be changed by this
   class.  (See @{" Colors Class " LINK "ColorMapClass"} for more Color information.)

   The Class methods available are:
   @{FG SHINE}
   new: theseStrings @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   selectionMade @{FG TEXT}

     Subclasses should override this with the desired action to take
     when the PaletteGadget gets pressed by the user.
   @{FG SHINE}
   testPaletteGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     This serves as a good example of what to do in the @{B}selectionMade@{UB} method.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "ScrollerGadgetClass" "ScrollerGadget Class:"
@PREV "GadgetSystemClass"
@NEXT "SliderGadgetClass"

   ScrollerGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoScrollerGadget class does.

   ScrollerGadget class allows the User to move either horizontally or
   vertically with a control.

   The Class methods available are:
   @{FG SHINE}
   new: newInterval @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   orientation: newOrientation  @{FG TEXT}
   
     Set the orientation of the Gadget.  The @{" Parent Class " LINK "CommonGadgetClass"}
     defaults to Horizontal, so use this method to reset orientation
     to Vertical (but do NOT change the orientation once the window
     is opened!).
     
     0 = None, 1 = Horizontal, 2 = Vertical
   @{FG SHINE}
   orientation @{FG TEXT}
   
     Answer with the orientation of the instance.
   @{FG SHINE}
   value: newPosition @{FG TEXT}

     Update the Gadget contents to @{I}newPosition@{UI}.
   @{FG SHINE}
   value @{FG TEXT}

     Retrieve the currently displayed Scroller setting.
   @{FG SHINE}
   testScrollerGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "SliderGadgetClass" "SliderGadget Class:"
@PREV "GadgetSystemClass"
@NEXT "StringGadgetClass"

   SliderGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:help/GeneralClasses.guide/ModelClass"}.  The
   AutoSliderGadget class does.

   SliderGadget class allows the User to move either horizontally or
   vertically with a control & set a level.

   The Class methods available are:
   @{FG SHINE}
   new: newOrientation @{FG TEXT}

     Create a new instance of the Class.
   @{FG SHINE}
   setMin: newMin max: newMax @{FG TEXT}
   
     Set the minimum & maximum values that the Slider will report to
     your code.
   @{FG SHINE}
   value: newPosition @{FG TEXT}

     Update the Gadget contents to @{I}newPosition@{UI}.
   @{FG SHINE}
   value @{FG TEXT}

     Retrieve the currently displayed Slider setting.
   @{FG SHINE}
   testSliderGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.

   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "StringGadgetClass" "StringGadget Class: "   
@PREV "CommonGadgetClass"
@NEXT "TextGadgetClass"

   StringGadget class is meant for use with @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} & its subclasses.  
   It does NOT allow for remote updating via the underlying @{" Model " LINK "Amigatalk:Help/GeneralClasses.guide/ModelClass"}.  
   The AutoStringGadget class does.

   StringGadget class allows the User to enter a String value into
   a UserGUI & its subclasses.

   The Class methods available are:
   @{FG SHINE}
   new: newAction @{FG TEXT}

     Make a new instance of the Class.
   @{FG SHINE}
   value: newAction @{FG TEXT}
      
     Change the desired String to display in the Gadget.
   @{FG SHINE}
   value @{FG TEXT}

     Return the current String in the Gadget.
   @{FG SHINE}
   testStringGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     
   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "TextGadgetClass" "TextGadget Class:"
@PREV "CommonGadgetClass"
@NEXT "NewMenuClass"

   TextGadget class allows the User to view a String in
   a UserGUI & its subclasses.  A TextGadget is a read-only gadget,
   so the @{I}testTextGadget@{UI} method will never get sent.

   The Class methods available are:
   @{FG SHINE}
   new: newText @{FG TEXT}

     Make a new instance of the Class.
   @{FG SHINE}
   value: newText @{FG TEXT}
      
     Change the desired String to display in the Gadget.
   @{FG SHINE}
   value @{FG TEXT}

     Return the current String in the Gadget.
   @{FG SHINE}
   testTextGadget @{FG TEXT}

     Use this to test your code with respect to the @{" UserGUI " LINK "Amigatalk:help/UserGUI.guide/Main"}.
     
   SEE ALSO, @{" CommonGadget " LINK "CommonGadgetClass"}, @{" GadgetSystem " LINK "GadgetSystemClass"}

@ENDNODE

@NODE "MenuStripClass" "MenuStrip Class:" 
@PREV "Main"
@NEXT "NewMenuClass"

   MenuStrip class is an @{" Array " LINK "Amigatalk:help/GeneralClasses.guide/ArrayClass"} of @{" NewMenu " LINK "NewMenuClass"} Objects.  
   It also contains the methods to set & clear itself from a 
   parent Window.
   @{FG SHINE}
   attachedTo @{FG TEXT}

     Return the @{" window " LINK "WindowClass"} that the receiver is attached to.
   @{FG SHINE}
   attachTo: aWindow @{FG TEXT}

     This all-in-one method does CreateMenus(), LayoutMenus() &
     SetMenuStrip() calls to the gadtools.library
   @{FG SHINE}
   hide @{FG TEXT}

     Equivalent to ClearMenuStrip() in C.
   @{FG SHINE}
   append: newMenuObject @{FG TEXT}

     Add a newMenuObject to the Array of NewMenu Objects.
   @{FG SHINE}
   new: numberOfElements @{FG TEXT}  
    
     Create the underlying Array of NewMenu objects.  
     This @{B}MUST@{UB} include space for #NM_END as well!

   SEE ALSO, @{" NewMenu Class " LINK "NewMenuClass"}

@ENDNODE

@NODE "NewMenuClass" "NewMenu Class:"
@PREV "MenuStripClass"
@NEXT "Main"

   NewMenu Class is the class that interfaces AmigaTalk to the
   new Menus portion of gadtools.library.  This class is designed
   to work with @{" UserGUI " LINK "AMigatalk:Help/UserGUI.guide/Main"}.  Read the Test file in 
   @{B}AmigaTalk:TestFiles/TestNewMenu@{UB} for an example on how to use this
   Class.

   The methods for this Class are:
   @{FG SHINE}
   dispose@{FG TEXT}

     Free resources used (if any).
   @{FG SHINE}
   new: newAction @{FG TEXT}

     Create a new instance of NewMenu.
   @{FG SHINE}
   addedTo: menuStrip @{FG TEXT}

     Add the receiver to the given @{" menuStrip " LINK "MenuStripClass"}
   @{FG SHINE}
   registerTo: myWindowObject @{FG TEXT}
   
     Tie the receiver to the given @{" window " LINK "WindowClass"}
   @{FG SHINE}
   value: newAction @{FG TEXT}
   
     Set the action @{" Symbol " LINK "AMigaTalk:Help/GeneralClasses.guide/SymbolClass"} that @{" UserGUI " LINK "AmigaTalk:Help/UserGUI.guide/Main"} will send us when this 
     menu item is selected by the User.
     @{I}testMenu@{UI} is an example Action.
   @{FG SHINE}
   value @{FG TEXT}
      
     Answer with the action Symbol that's defined for the receiver.
   @{FG SHINE}
   testMenu @{FG TEXT}
   
     This is a test method for @{" UserGUI " LINK "Amigatalk:Help/UserGUI.guide/Main"} to use & is setup
     by setting @{B}userDataArray at: 3 put: #testMenu@{UB}
   @{FG SHINE}
   menuUserData: userDataArray @{FG TEXT}
   
     Set the userData field in structArray.
   @{FG SHINE}
   fillNewMenuItemWith: structureArray @{FG TEXT}

     Setup the NewMenu array with structureArray.   
     @{B}structureArray@{UB} is an Array Object with the following
     elements in the given order:

       ele[1] <- nm_Type,          ele[2] <- nm_Label,
       ele[3] <- nm_CommKey,       ele[4] <- nm_Flags,
       ele[5] <- nm_MutualExclude, ele[6] <- nm_UserData 

       ele[6] is an Array as follows:

       udele[1] <- Menu Type (#NM_TITLE, #NM_ITEM, #NM_SUB, #IM_ITEM,
                              or #IM_SUB)
       udele[2] <- menu ID_String,
       udele[3] <- userData (Usually a #methodSymbol, such as #value or
                             #testMenu.
       udele[4] <- equivalent to ele[3] (nm_CommKey)
   @{FG SHINE}
   endOfMenuArray @{FG TEXT}

     Fill this instance with the fields that indicate the end of
     the NewMenu array.  This is required by ALL @{" menuStrips " LINK "MenuStripClass"}.
   @{FG SHINE}
   titleMenuArray: title @{FG TEXT}
   
     Make a new Menu #NM_TITLE.
   @{FG SHINE}
   barLabel  @{FG TEXT}
     
     Make a new Menu item NM_BARLABEL.
   @{FG SHINE}
   menuItemArray: title key: commKey flags: flags data: userData @{FG TEXT}
   
     Make a new Menu #NM_ITEM.
   @{FG SHINE}
   subItemArray: title key: commKey flags: flags data: userData @{FG TEXT}

     Make a new menu #NM_SUB.
   @{FG SHINE}
   menuItemSpace @{FG TEXT}
   
     Make a new Menu Item/SubItem that is blank (#NM_IGNORE).
   @{FG SHINE}
   menuImageArray: image key: commKey flags: flags data: userData @{FG TEXT}

     Make a new Menu @{" Image " LINK "ImageClass"} #IM_ITEM.
   @{FG SHINE}
   subImageArray: image key: commKey flags: flags data: userData @{FG TEXT}

     Make a new Menu @{" Image " LINK "ImageClass"} #IM_SUB.

   SEE ALSO, @{" NewGadgets " LINK "NewGadgetsClass"}, @{" GadTools " LINK "GadToolsClass"}

@ENDNODE

@NODE ScreenClass "Screen Class:"

   Class @{B}Screen@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga screens.
   The Methods are:

   @{FG SHINE}
   new: newScreenModeID @{FG TEXT}
    
     Create a new Screen Object with the mode of @{B}newScreenModeID@{UB}.
     @{FG SHINE}NOTE:@{FG TEXT}  The order of methods for making a Screen is as follows:

            scr <- Screen new
            scr setTitle: 'My Screen Title'
            scr new: screenMode
            
            or:
            
            scr <- Screen new
            "Set any Screen parameters in here."
            scr openScreen: screenMode title: 'My Screen Title'
   @{FG SHINE}
   openScreen: screenMode title: screenTitle @{FG TEXT}
   
     Create a new Screen Object with the given screenMode & screenTitle &
     open it.
   @{FG SHINE}   
   thisScreen @{FG TEXT}

      Necessary for passing a screen to a tag list (tag <- scr thisScreen).
   @{FG SHINE}
   setScreenModeID: newScreenModeID @{FG TEXT}
             
     Set the Screen Object's ModeID to @{B}newScreenModeID@{UB}.
   @{FG SHINE}
   getScreenModeID @{FG TEXT}
   
     Return the current screenModeID.
   @{FG SHINE}
   close @{FG TEXT}

     Close the Screen Object.
   @{FG SHINE}
   pullScreenUp: numLines @{FG TEXT}

     Move a screen up by numLines (see intuition.library 
     function MoveScreen()).  numLines has to be <= 0.
   @{FG SHINE}
   pushScreenDown: numLines   @{FG TEXT}  

     Move a screen down by numLines (see intuition.library 
     function MoveScreen()).  numLines has to be >= 0.
   @{FG SHINE}
   redrawScreen @{FG TEXT}

     Re-draw the Screen Object (see intuition.library functions 
     MakeScreen() & RethinkDisplay()).
   @{FG SHINE}   
   reOpenScreen @{FG TEXT}
   
     Re-open the screen with any new parameters that were changed by the
     user, such as a new screenModeID, Depth, etc.
   @{FG SHINE}
   displayBeep @{FG TEXT}
     
     Call the intuition function @{B}DisplayBeep()@{UB} for the given screen.
   @{FG SHINE}
   screenToBack @{FG TEXT}

     Place the given screen behind all other open screens (see 
     intuition.library function @{B}ScreenToBack()@{UB}).
   @{FG SHINE}
   screenToFront @{FG TEXT}

     Place the given screen in front of all other open screens (see 
     intuition.library function @{B}ScreenToFront()@{UB}).
   @{FG SHINE}
   turnOffTitle @{FG TEXT}
      
     Blank out the screenTitle (see intuition.library function
     @{B}ShowTitle()@{UB}).
   @{FG SHINE}
   showTitle @{FG TEXT}

     Enable the screenTitle display (see intuition.library function
     @{B}ShowTitle()@{UB}).
   @{FG SHINE}
   NOTE:  All of the set Parameter methods won't take effect until a 
          call to @{B}openScreen: or reOpenScreen@{UB} is given.

          In general, it's best to perform all of the set parameter 
          methods @{B}before@{UB} you open the screen, then a call to @{B}reOpenScreen@{UB}
          isn't necessary.
          
   setOrigin: aPoint @{FG TEXT}

     Set the starting point of the screen to the given point @{B}aPoint@{UB}.
   @{FG SHINE}
   setScreenSize: sizePoint @{FG TEXT}

     Set the width & height of the Screen to (sizePoint x) &
     (sizePoint y) respectively.
   @{FG SHINE}
   setScreenPens: pensPoint @{FG TEXT}

     Set the Foreground & Background pens to (pensPoint x) &
     (pensPoint y) respectively.
   @{FG SHINE}
   setTitle: newTitle @{FG TEXT}

     Change the title of the Screen to @{B}newTitle@{UB}.
   @{FG SHINE}
   setDepth: newDepth   @{FG TEXT}

     Change the number of bit-planes that the screen will use.  The 
     depth of a screen determines how many colors it has.
   @{FG SHINE}
   setFont: newFontName   @{FG TEXT}

     Change the @{" Font " LINK "FontClass"} used to render text in the screen.
   @{FG SHINE}
   setBitMap: newBitMap @{FG TEXT}

     Change the bitmap of the given screen.
   @{FG SHINE}
   getOrigin  @{FG TEXT}

     Return the current value of the @{B}LeftEdge \@ TopEdge@{UB} of the screen
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getScreenSize @{FG TEXT}

     Return the current value of the @{B}Width \@ Height@{UB} of the screen
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getScreenPens @{FG TEXT}

     Return the current value of the foreground \@ background pens for the 
     screen as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getFlags  @{FG TEXT}

     Return the current value of the @{B}Flags@{UB} for the screen.
   @{FG SHINE}
   getType @{FG TEXT}

     Return the current value of the @{B}Type@{UB} of the screen.
   @{FG SHINE}
   getViewMode @{FG TEXT}

     Return the current value of the @{B}ViewMode@{UB} of the screen.
   @{FG SHINE}
   getTitle @{FG TEXT}

     Return the current value of the @{B}Title@{UB} of the screen.
   @{FG SHINE}
   getDepth @{FG TEXT}

     Return the current value of the @{B}Depth@{UB} of the screen.
   @{FG SHINE}
   getFontName @{FG TEXT}

     Return the name of the current @{" Font " LINK "FontClass"} for the screen.
   @{FG SHINE}
   getBitMap @{FG TEXT}

     Return the current @{" BitMap " LINK "BitMapClass"} for the screen.
   @{FG SHINE}
   getFontObject @{FG TEXT}

     Return the current @{" Font " LINK "FontClass"} for the screen.
   @{FG SHINE}
   getBarHeightSize @{FG TEXT}

      Return the height of the Screen title bar (in pixels).
   @{FG SHINE}         
   getBarVBorderSize @{FG TEXT}

      Return the vertical Border size of the Screen (in lines/pixels).
   @{FG SHINE}         
   getBarHBorderSize @{FG TEXT}

      Return the horizontal Border size of the Screen (in pixels).
   @{FG SHINE}         
   getMenuVBorderSize @{FG TEXT}

      Return the vertical Border size of menus (in lines/pixels).
   @{FG SHINE}         
   getMenuHBorderSize @{FG TEXT}

      Return the horizontal Border size of menus (in pixels).
   @{FG SHINE}         
   getWBorTopSize @{FG TEXT}

      Return the default top Border size of windows.
   @{FG SHINE}         
   getWBorLeftSize @{FG TEXT}

      Return the default left Border size of windows.
   @{FG SHINE}         
   getWBorRightSize @{FG TEXT}

      Return the default right Border size of windows.
   @{FG SHINE}         
   getWBorBottomSize @{FG TEXT}

      Return the default bottom Border size of windows.
   @{FG SHINE}
   getUserData @{FG TEXT}

      Return any user data associated with the Screen.
   @{FG SHINE}
   getVisualInfo: tagArray @{FG TEXT}
   
      Return an Object that represents the VisualInfo
      associated with the Screen.  @{I}tagArray@{UI} can be nil.
      Make sure that each use of @{B}getVisualInfo:@{UB} is balanced
      by @{B}disposeVisualInfo:@{UB}
   @{FG SHINE}
   disposeVisualInfo: viObj @{FG TEXT}

      Free the @{I}viObj@{UI}.
   @{FG SHINE}
   openScreenWithTags: tagArray @{FG TEXT}

      Open a screen with the given tagArray Object.  Valid tag
      values for Screens are documented in ScreenTags.st &
      the ScreenTags class is instantiated by the Intuition Class,
      located in SetupIntuition.st.  You use the @{I}getScreenTag:@{UI}
      method in Intuition to obtain the correct tag value for a given
      ScreenTag Symbol from ScreenTags as follows:
         @{FG SHINE}
         intuition <- Intuition new
                
         tag1  <- intuition getScreenTag: #SA_Top
         data1 <- myScreenTopInteger             "Usually 0"
         ...
         
         tagArray <- Array new: (howManyTagPairs * 2)
         
         tagArray at: 1 put: tag1
         tagArray at: 2 put: data1
         ...
         
         myScreen <- openScreenWithTags: tagArray @{FG TEXT}
@{B}
      NOTE:
      This method assumes you included an SA_Title tag!
@{UB}
      This might seem to be a complicated way to open a screen,
      but if you make your own subClass of Screen & bury all of
      this in a method, you only have to write the method once
      & you can use it over & over (the Data is encapsulated,
      do I have to teach you Object-Oriented programming too?) 
   @{FG SHINE}   
   lockPublicScreen: screenName @{FG TEXT}
  
      Lock the given public @{B}Screen@{UB} named @{I}screenName@{UI} (which can
      be nil).       
   @{FG SHINE}   
   unlockPublicScreen: screenObject named: screenName  @{FG TEXT}

      Unlock the given public @{B}Screen@{UB} named @{I}screenName@{UI} (which can
      be nil).       
   @{FG SHINE}
   getScreenErrorString: errorNumber @{FG TEXT}

      Translate an @{I}errorNumber@{UI} into a String Object
   @{FG SHINE}
   selectAndOpenScreen @{FG TEXT}

      Query the User for a Screen title & a ScreenModeID
      from the ScreenMode ASL requester & open a new Screen.
@ENDNODE

@NODE WindowClass "Window Class:"

   Class @{B}Window@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga windows.
   The Methods are:
   @{FG SHINE}
   refreshYourself @{FG TEXT}

     Refresh (redraw) any Gadget imagery & the window frame graphics.
   @{FG SHINE}
   new: newWindowTitle @{FG TEXT}

     Create a new Window Object & set the title to @{B}newWindowTitle@{UB}.
   @{FG SHINE}
   openOnScreen: screenObject @{FG TEXT}

     Open a new window on the given screen (screenObject is what you get
     from @{B}screenObject <- Screen new: 16r40D20001@{UB} for example).
   @{FG SHINE}
   close  @{FG TEXT}

     Close the given window.
   @{FG SHINE}
   setPointer: spriteObject size: sizePt offset: offPt @{FG TEXT}

     This method is obsolete, use setWindowPointer: instead.
   @{FG SHINE}
   setWindowPointer: tagArray @{FG TEXT}

     Change the mouse pointer to the given sprite @{B}spriteObject@{UB}.
   @{FG SHINE}
   addGadget: gadgetObject @{FG TEXT}

     Add a gadgetObject to the given window.
   @{FG SHINE}
   setFirstGadget: newGadget @{FG TEXT}

     Change the @{B}FirstGadget@{UB} to @{B}newGadget@{UB}.
@{B}
     NOTE:  Make sure that the newGadget is chained to all the other
            gadgets you want for the window (See @{B}setNextGadget method
            for @{" Gadget " LINK GadgetClass}).
@{UB}
   @{FG SHINE}
   refreshWindowFrame @{FG TEXT}

     Execute a call to @{B}RefreshWindowFrame()@{UB} (see intuition.library).
   @{FG SHINE}
   refreshGadgets @{FG TEXT}

     Execute a call to @{B}RefreshGadgets()@{UB} (see intuition.library).
   @{FG SHINE}
   removeGadget: gadgetObject @{FG TEXT}

     Delete a @{" Gadget " LINK "GadgetClass"} from the @{B}Window@{UB} Object.
   @{FG SHINE}
   reportMouse: boolvalue @{FG TEXT}

     Turn @{B}reportMouse@{UB} events on or off.

   @{FG SHINE}
   getMouseCoords @{FG TEXT}

     Return the current x & y-coordinates of the mouse position as a
     @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   printIText: iTextObject at: aPoint @{FG TEXT}

     Display the given @{" IText " LINK "ITextClass"} structure in the Window at the
     given @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   reOpen @{FG TEXT}

     Re-open a window so that any changed parameters will take effect.
   @{FG SHINE}
   handleIntuition @{FG TEXT}

     Wait for the user to select a Gadget or MenuItem from the window.
   @{FG SHINE}
     NOTE:  Only @{B}IDCMP_CLOSEWINDOW, IDCMP_GADGETUP & IDCMP_MENUPICK@{UB} events 
            are currently recognized.  This method will return the name of
            the first Gadget or MenuItem selected by the user.
   @{FG SHINE}
   windowToBack @{FG TEXT}

     Place the @{B}Window@{UB} behind all other windows.
   @{FG SHINE}
   windowToFront @{FG TEXT}

     Place the @{B}Window@{UB} in front of all other windows.
   @{FG SHINE}
   showRequester: requesterObject @{FG TEXT}

     Display the given Requester to the user.
   @{FG SHINE}
   addMenuStrip: menuObject @{FG TEXT}

     Display the given menu(s) in the @{B}Window@{UB}.
   @{FG SHINE}
   removeMenuStrip @{FG TEXT}

     Remove the current menu strip from the @{B}Window@{UB}.
   @{FG SHINE}
   moveWindow: deltaPoint   @{FG TEXT}

     Move the @{B}Window@{UB} to the new @{" Point " LINK "GeneralClasses.guide/PointClass"} of origin.
   @{FG SHINE}
   infoReq: msg title: t   @{FG TEXT}

     Display an information Requester to the user.
   @{FG SHINE}
   yesNoReq: msg title: t   @{FG TEXT}

     Obtain a @{B}yes@{UB} or @{B}no@{UB} response from the user.
   @{FG SHINE}
   getUserChoice: msg title: t choices: bstr   @{FG TEXT}

     Obtain a choice from the user from the given bstr (Button strings).
     Example:  'YES@{B}|@{UB}NO@{B}|@{UB}MAYBE'
   @{FG SHINE}
   getOrigin @{FG TEXT}

     Return the current @{B}LeftEdge \@ TopEdge@{UB} values for the @{B}Window@{UB}
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getWindowSize @{FG TEXT}

     Return the current @{B}Width \@ Height@{UB} values for the @{B}Window@{UB}
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getWindowPens @{FG TEXT}

     Return the current foreground \@ background pen values for the @{B}Window@{UB}
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getFlags: windowTitle   @{FG TEXT}

     Return the current @{B}Flags@{UB} value for the given @{B}Window@{UB}.
   @{FG SHINE}
   getIDCMPFlags: windowTitle   @{FG TEXT}

     Return the current @{B}IDCMPFlags@{UB} value for the given @{B}Window@{UB}.
   @{FG SHINE}
   beginRefresh @{FG TEXT}

     Execute a call to @{B}BeginRefresh()@{UB} for the @{B}Window@{UB}.
     (see intuition.library)
   @{FG SHINE}
   endRefresh @{FG TEXT}

     Execute a call to @{B}EndRefresh()@{UB} for the @{B}Window@{UB}.
     (see intuition.library)
   @{FG SHINE}
   remakeDisplay @{FG TEXT}

     Execute a call to @{B}RemakeDisplay()@{UB} for the @{B}Window@{UB}.
     (see intuition.library)
   @{FG SHINE}
   rethinkDisplay @{FG TEXT}

     Execute a call to @{B}RethinkDisplay()@{UB} for the @{B}Window@{UB}.
     (see intuition.library)

   @{FG SHINE}
   NOTE:  All of the set Parameter methods won't take effect until a 
          call to @{B}openOnScreen:{UB} is given.

   setWindowOrigin: aPoint   @{FG TEXT}

     Change the @{B}LeftEdge & TopEdge@{UB} of the receiver to the new 
     values.
   @{FG SHINE}
   setWindowSize: sizePoint @{FG TEXT}

     Change the size of the Window to the given values (sizePoint x) & 
     (sizePoint y).
   @{FG SHINE}
   setWindowPens: pensPoint @{FG TEXT}

     Change the foreground & background pens of the receiver to the new 
     values (foreground <- pensPoint x) & (background <- pensPoint y).  
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Change the @{B}Flags@{UB} of the @{B}Window@{UB} to the new value.  
   @{FG SHINE}
   setIDCMPFlags: windowTitle to: newIDCMP   @{FG TEXT}

     Change the @{B}IDCMPFlags@{UB} of the @{B}Window@{UB} to the new value.  
   @{FG SHINE}
   setMinSize: newMinPoint @{FG TEXT}

     Change the @{B}MinWidth \@ MinHeight@{UB} of the @{B}Window@{UB} to the new 
     values.  
   @{FG SHINE}
   setMaxSize: newMaxPoint @{FG TEXT}

     Change the @{B}MaxWidth \@ MaxHeight@{UB} of the @{B}Window@{UB} to the new 
     values.  
   @{FG SHINE}
   getReqCount @{FG TEXT}

     Return a count of the @{" Requesters " LINK "RequesterClass"} (@{B}reqcount@{UB})for the @{B}Window@{UB}.
   @{FG SHINE}
   getPointerSize @{FG TEXT}

     Return the width & height of the mouse pointer for the @{B}Window@{UB} as a
     @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   setCheckMark: newCheckMark   @{FG TEXT}

     Change the @{B}CheckMark Image@{UB} of the Window to the 
     new value specified by '@{B}newCheckMark@{UB}', which is an @{" Image " LINK "ImageClass"}.
   @{FG SHINE}
   getWindowOffset @{FG TEXT}

     Return the current x & y-offset coordinates for the @{B}Window@{UB} as a
     @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   setBitMap: newBitMap   @{FG TEXT}

     Change the @{" BitMap " LINK "BitMapClass"} of the @{B}Window@{UB} to the new value specified 
     by '@{I}newBitMap@{UI}'.
   @{FG SHINE}
   getBorderLeft @{FG TEXT}

     Return the size of the left @{" Border " LINK "BorderClass"} of the window.
   @{FG SHINE}
   getBorderTop @{FG TEXT}

     Return the size of the top @{" Border " LINK "BorderClass"} of the window.
   @{FG SHINE}
   getBorderRight @{FG TEXT}

     Return the size of the right @{" Border " LINK "BorderClass"} of the window.
   @{FG SHINE}
   getBorderBottom @{FG TEXT}

     Return the size of the bottom @{" Border " LINK "BorderClass"} of the window.
   @{FG SHINE}
   getCheckMarkImage @{FG TEXT}

      Returns the check mark Image Object.
   @{FG SHINE}
   getUserData @{FG TEXT}

      Return any User Data associated with the window.
   @{FG SHINE}
   getWindowObject @{FG TEXT}

      Necessary for creating tags.
   @{FG SHINE}
   getTitle: windowTitle    @{FG TEXT}

     Return the current @{B}Title@{UB} value for the given @{B}Window@{UB}.
   @{FG SHINE}
   changeTitle: newTitle   @{FG TEXT}

     Change the title of the @{B}Window@{UB} to @{B}newTitle@{UB}.
   @{FG SHINE}
   getScreenTitle @{FG TEXT}

     Get the title of the @{" Screen " LINK "ScreenClass"} that the given @{B}Window@{UB} is attached to.
   @{FG SHINE}
   changeWindowSize: deltaPoint @{FG TEXT}
     Ask Intuition to size the @{B}Window@{UB} the specified amounts.
     @{FG SHINE}NOTE:@{FG TEXT}  This method is different from @{I}setWindowSize:@{UI}
            @{I}changeWindowSize:@{UI} operates on a @{B}Window@{UB} that's open.
   @{FG SHINE}
   openWindowWithTags: tagArray @{FG TEXT}

      Open a @{B}Window@{UB} using a @{I}tagArray@{UI}.
   @{FG SHINE}
   getWindowSignal @{FG TEXT}

      Return an Integer representing the Signal associated with
      the Window.
      @{B}
      WARNING:  The window HAS TO BE OPEN BEFORE you use this!@{UB}

@ENDNODE

@NODE MenuClass "Menu Class:" 

   Class @{B}Menu@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga menus.
   Actual display of any Menus are taken care of in the @{" Window Class " LINK "WindowClass"} by
   @{B}setMenuStrip & removeMenuStrip@{UB}.

   The Methods for the Menu Class are:

   @{FG SHINE}
   new: newMenuName @{FG TEXT}

     Add a menu to the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a Menu from the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   registerTo: windowTitle @{FG TEXT}

     Inform the @{B}AmigaTalk@{UB} internal system which window is the parent of
     the Menu.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge & TopEdge@{UB} of the Menu.
   @{FG SHINE}
   getMenuSize @{FG TEXT}

     Return the @{B}Width & Height@{UB} of the Menu.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} of the Menu.
   @{FG SHINE}
   getNextMenu @{FG TEXT}

     Return the name of the @{B}NextMenu@{UB} for the Menu.
   @{FG SHINE}
   getFirstItem @{FG TEXT}

     Return the name of the @{B}FirstItem@{UB} for the Menu.
   @{FG SHINE}
   getMenuName @{FG TEXT}

     Return the name of the Menu.  This is a silly function, since
     you have to know the name of the menu to use it!
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}
    
     Set the @{B}LeftEdge & TopEdge@{UB} of the Menu to the given values.
   @{FG SHINE}
   setMenuSize: sizePoint @{FG TEXT}
    
     Set the @{B}Width & Height@{UB} of the Menu to the given values.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}
    
     Set the @{B}Flags@{UB} of the Menu to the given value.
   @{FG SHINE}
   setNextMenu: newNextMenu @{FG TEXT}
    
     Set the @{B}NextMenu@{UB} of the Menu to the given value.
   @{FG SHINE}
   setFirstItem: newFirstItem @{FG TEXT}
    
     Set the @{B}FirstItem@{UB} of the Menu to the given value.
   @{FG SHINE}
   setMenuName: newMenuName @{FG TEXT}

     Set the name of the Menu to the new name given.

   See Also @{" MenuItems " LINK "MenuItemClass"}, @{" SubItems " LINK "SubItemClass"}

@ENDNODE

@NODE MenuItemClass "MenuItem Class:" 

   Class @{B}MenuItem@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga 
   MenuItems.  Actual display of any Menus are taken care of in the 
   @{" Window Class " LINK "WindowClass"} by @{B}setMenuStrip & removeMenuStrip@{UB}.

   The Methods for the MenuItem Class are:

   @{FG SHINE}
   new: newMenuItemName @{FG TEXT}

     Add a MenuItem to the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a MenuItem from the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge & TopEdge@{UB} of the MenuItem.
   @{FG SHINE}
   getItemSize @{FG TEXT}

     Return the @{B}Width & Height@{UB} of the MenuItem.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}
    
     Set the @{B}LeftEdge & TopEdge@{UB} of the MenuItem to the given values.
   @{FG SHINE}
   setItemSize: sizePoint @{FG TEXT}
    
     Set the @{B}Width & Height@{UB} of the MenuItem to the given values.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} of the MenuItem.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}
    
     Set the @{B}Flags@{UB} of the MenuItem to the given value.
   @{FG SHINE}
   getMutualExclude @{FG TEXT}

     Return the @{B}MutualExclude@{UB} value of the MenuItem.
   @{FG SHINE}
   setMutualExclude: newMutualExclude @{FG TEXT}
    
     Set the @{B}MutualExclude@{UB} of the MenuItem to the given value.
   @{FG SHINE}
   getCommand @{FG TEXT}

     Return the @{B}Command@{UB} (menu key-equivalent) value of the 
     MenuItem.
   @{FG SHINE}
   setCommand: newCommand @{FG TEXT}
    
     Set the @{B}Command@{UB} (menu key-equivalent) of the MenuItem
     to the given value.
   @{FG SHINE}
   getNextItem @{FG TEXT}

     Return the name of the @{B}NextItem@{UB} from the MenuItem.
   @{FG SHINE}
   setNextItem: newNextItem @{FG TEXT}
    
     Set the @{B}NextItem@{UB} of the MenuItem to the given value.
   @{FG SHINE}
   setItemFill: newItemFill @{FG TEXT}
    
     Set the @{B}ItemFill@{UB} (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"} name) of the MenuItem.
   @{FG SHINE}
   setSelectFill: newSelectFill @{FG TEXT}

     Set the @{B}SelectFill@{UB} (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"} name) of the MenuItem.
   @{FG SHINE}
   setSubItem: newSubItem @{FG TEXT}

     Set the @{B}SubItem@{UB} of the MenuItem to the given value.
   @{FG SHINE}
   getSubItem @{FG TEXT}
    
     Return the name of the first @{B}SubItem@{UB} attached to the
     MenuItem.
   @{FG SHINE}
   getItemFill @{FG TEXT}

     Return the name of the @{B}ItemFill@{UB} (either @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) from 
     the MenuItem.
   @{FG SHINE}
   getSelectFill @{FG TEXT}

     Return the name of the @{B}SelectFill@{UB} (either @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) 
     from the MenuItem.

   See Also @{" Menus " LINK "MenuClass"}, @{" SubItems " LINK "SubItemClass"}
@ENDNODE

@NODE SubItemClass "SubItem Class:" 

   Class @{B}SubItem@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga 
   Menu SubItems.  Actual display of any Menus are taken care of in the 
   @{" Window Class " LINK "WindowClass"} by @{B}setMenuStrip & removeMenuStrip@{UB}.

   The Methods for the SubItem Class are:

   @{FG SHINE}
   new: newSubItemName @{FG TEXT}

     Add a SubItem to the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a SubItem from the @{B}AmigaTalk@{UB} internal system list.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge & TopEdge@{UB} of the SubItem.
   @{FG SHINE}
   getSubSize @{FG TEXT}

     Return the @{B}Width & Height@{UB} of the SubItem.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}
    
     Set the @{B}LeftEdge & TopEdge@{UB} of the SubItem to the given values.
   @{FG SHINE}
   setSubSize: sizePoint @{FG TEXT}
    
     Set the @{B}Width & Height@{UB} of the SubItem to the given values.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} of the SubItem.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}
    
     Set the @{B}Flags@{UB} of the SubItem to the given value.
   @{FG SHINE}
   getMutualExclude @{FG TEXT}

     Return the @{B}MutualExclude@{UB} value of the SubItem.
   @{FG SHINE}
   setMutualExclude: newMutualExclude @{FG TEXT}
    
     Set the @{B}MutualExclude@{UB} of the SubItem to the given value.
   @{FG SHINE}
   getCommand @{FG TEXT}

     Return the @{B}Command@{UB} (menu key-equivalent) value of the 
     SubItem.
   @{FG SHINE}
   setCommand: newCommand @{FG TEXT}
    
     Set the @{B}Command@{UB} (menu key-equivalent) of the SubItem
     to the given value.
   @{FG SHINE}
   getNextItem @{FG TEXT}

     Return the name of the @{B}NextItem@{UB} from the SubItem.
   @{FG SHINE}
   setNextItem: newNextItem @{FG TEXT}
    
     Set the @{B}NextItem@{UB} of the SubItem to the given value.
   @{FG SHINE}
   setItemFill: newItemFill @{FG TEXT}
    
     Set the @{B}ItemFill@{UB} (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"} name) of the SubItem.
   @{FG SHINE}
   setSelectFill: newSelectFill @{FG TEXT}

     Set the @{B}SelectFill@{UB} (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"} name) of the SubItem.
   @{FG SHINE}
   getItemFill @{FG TEXT}

     Return the name of the @{B}ItemFill@{UB} (either @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) from 
     the SubItem.
   @{FG SHINE}
   getSelectFill @{FG TEXT}

     Return the name of the @{B}SelectFill@{UB} (either @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) 
     from the SubItem.

   See Also @{" Menus " LINK "MenuClass"}, @{" MenuItems " LINK "MenuItemClass"}
@ENDNODE

@NODE GadgetClass "Gadget Class:"

   Class @{B}Gadget@{UB} is an abstract class that serves as a parent class for
   all Gadget-related classes.  The methods it defines are only useful
   for system-wide purposes:
   
   @{FG SHINE}
   gadgetTypeIs: gadgetName @{FG TEXT}

     Return the type of the gadget given by gadgetName.  The return
     values are:
     
     BOOLEAN      = 1
     PORPORTIONAL = 3
     STRING       = 4

   @{FG SHINE}
   new: newGadgetName @{FG TEXT}

     Create a new Gadget to the @{B}newGadgetName@{UB} & the default
     type of BoolGadget.

   @{B}SubClasses:@{UB}  @{" BoolGadget " LINK BoolGadgetClass}
                @{" StrGadget  " LINK StrGadgetClass}  
                @{" PropGadget " LINK PropGadgetClass}
@ENDNODE

@NODE BoolGadgetClass "Boolean Gadget Class:"

   Class @{B}BoolGadget@{UB} allows the @{B}AmigaTalk@{UB} system to man-
   ipulate Amiga Boolean Gadgets.  The Methods are:
     
   @{FG SHINE}
   new: newGadgetName @{FG TEXT}

     Add a BoolGadget to the @{B}AmigaTalk@{UB} system.  This method allocates
     an internal memory structure to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a BoolGadget from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   registerTo: windowTitle @{FG TEXT}

     Set the name of the gadget's parent to the @{B}windowTitle@{UB}.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}

     Set the origin of the gadget to the given point value.
   @{FG SHINE}
   setGadgetSizeTo: sizePoint @{FG TEXT}

     Set the size of the gadget to the given width & height.
   @{FG SHINE}
   getLeftEdge @{FG TEXT}

     Return the @{B}LeftEdge@{UB} value of the BoolGadget. 
   @{FG SHINE}
   getTopEdge @{FG TEXT}

     Return the @{B}TopEdge@{UB} value of the BoolGadget.
   @{FG SHINE}
   getWidth @{FG TEXT}
 
     Return the @{B}Width@{UB} value of the BoolGadget.
   @{FG SHINE}
   getHeight @{FG TEXT}

     Return the @{B}Height@{UB} value of the BoolGadget.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} value of the BoolGadget.
   @{FG SHINE}
   getActivation @{FG TEXT}

     Return the @{B}Activation@{UB} value of the BoolGadget.
   @{FG SHINE}
   getGadgetType @{FG TEXT}

     Return the @{B}Type@{UB} of the BoolGadget.
     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   getGadgetID @{FG TEXT}

     Return the @{B}GadgetID@{UB} number for the BoolGadget.
   @{FG SHINE}
   getNextGadgetName @{FG TEXT}

     Return the name of the @{B}NextGadget@{UB} for the BoolGadget.
   @{FG SHINE}
   getITextName @{FG TEXT}

     Return the name of the @{" IText " LINK "ITextClass"} attached to the BoolGadget.
   @{FG SHINE}
   getRenderName @{FG TEXT}

     Return the name of the gadget rendering (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) for the
     BoolGadget.
   @{FG SHINE}
   getSelectName @{FG TEXT}

     Return the name of the gadget selection rendering (@{" IText " LINK "ITextClass"} or
     @{" Image " LINK "ImageClass"}) for the BoolGadget.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Set the gadget @{B}Flags@{UB} to the new value(s).
   @{FG SHINE}
   setActivation: newActivation @{FG TEXT}

     Set the gadget @{B}Activation@{UB} to the new value.
   @{FG SHINE}
   setGadgetType: newGadgetType @{FG TEXT}

     Set the gadget @{B}Type@{UB} to the new value.
     
     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   setGadgetID: newGadgetID @{FG TEXT}

     Set the @{B}GadgetID@{UB} to the new value.
   @{FG SHINE}
   setNextGadgetName: newNextGadgetName @{FG TEXT}

     Set the @{B}NextGadget@{UB} to the @{B}Gadget@{UB} attached to @{B}newNextGadgetName@{UB}.

   @{FG SHINE}
   setITextName: newITextName @{FG TEXT}

     Set the @{" IText " LINK "ItextClass"} to the new value.

   @{FG SHINE}
   setRenderName: newRenderName @{FG TEXT}

     Set the BoolGadget rendering to the name of the @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}
     supplied. 

   @{FG SHINE}
   setSelectName: newSelectName @{FG TEXT}

     Set the gadget selection rendering to the name of the @{" IText " LINK "ITextClass"} 
     or @{" Image " LINK "ImageClass"} supplied. 

@ENDNODE

@NODE StrGadgetClass "String Gadget Class:"

   Class @{B}StrGadget@{UB} allows the @{B}AmigaTalk@{UB} system to man-
   ipulate Amiga String Gadgets.  The Methods are:
     
   @{FG SHINE}
   new: newGadgetName @{FG TEXT}

     Add a StrGadget to the @{B}AmigaTalk@{UB} system.  This method allocates
     an internal memory structure to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a StrGadget from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   registerTo: windowTitle @{FG TEXT}

     Set the name of the StrGadget's parent to the @{B}windowTitle@{UB}.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}

     Set the origin of the StrGadget to the given point value.
   @{FG SHINE}
   setGadgetSize: sizePoint @{FG TEXT}

     Set the size of the StrGadget to the given point value.
   @{FG SHINE}
   changeBufferSize: newSize @{FG TEXT}

     Change the internal buffer size for the StrGadget.
   @{FG SHINE}
   getBufferSize @{FG TEXT}

     Return the size of the StrGadget buffer (in bytes).
   @{FG SHINE}
   getLeftEdge @{FG TEXT}

     Return the @{B}LeftEdge@{UB} value of the StrGadget.
   @{FG SHINE}
   getTopEdge @{FG TEXT}

     Return the @{B}TopEdge@{UB} value of the StrGadget.
   @{FG SHINE}
   getWidth @{FG TEXT}
 
     Return the @{B}Width@{UB} value of the StrGadget.
   @{FG SHINE}
   getHeight @{FG TEXT}

     Return the @{B}Height@{UB} value of the StrGadget.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} value of the StrGadget.
   @{FG SHINE}
   getActivation @{FG TEXT}

     Return the @{B}Activation@{UB} value of the StrGadget.
   @{FG SHINE}
   getGadgetType @{FG TEXT}

     Return the @{B}Type@{UB} of the StrGadget.

     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   getGadgetID @{FG TEXT}

     Return the @{B}GadgetID@{UB} number for the StrGadget.
   @{FG SHINE}
   getNextGadgetName @{FG TEXT}

     Return the name of the @{B}NextGadget@{UB} for the StrGadget.
   @{FG SHINE}
   getITextName @{FG TEXT}

     Return the name of the @{" IText " LINK "ITextClass"} attached to the StrGadget.
   @{FG SHINE}
   getRenderName @{FG TEXT}

     Return the name of the gadget rendering (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) for the
     StrGadget.
   @{FG SHINE}
   getSelectName @{FG TEXT}

     Return the name of the gadget selection rendering (@{" IText " LINK "ITextClass"} 
     or @{" Image " LINK "ImageClass"}) for the StrGadget.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Set the StrGadget @{B}Flags@{UB} to the new value(s).
   @{FG SHINE}
   setActivation: newActivation @{FG TEXT}

     Set the StrGadget @{B}Activation@{UB} to the new value.
   @{FG SHINE}
   setGadgetType: newGadgetType @{FG TEXT}

     Set the StrGadget @{B}Type@{UB} to the new value.
     
     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   setGadgetID: newGadgetID @{FG TEXT}

     Set the @{B}GadgetID@{UB} to the new value.
   @{FG SHINE}
   setNextGadgetName: newNextGadgetName @{FG TEXT}

     Set the @{B}NextGadget@{UB} to the @{B}Gadget@{UB} attached to @{B}newNextGadgetName@{UB}.
   @{FG SHINE}
   setITextName: newITextName @{FG TEXT}

     Set the @{ "IText " LINK "ITextClass"} to the new value.
   @{FG SHINE}
   setRenderName: newRenderName @{FG TEXT}

     Set the StrGadget rendering to the name of the @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}
     supplied. 
   @{FG SHINE}
   setSelectName: newSelectName @{FG TEXT}

     Set the StrGadget selection rendering to the name of the @{" IText " LINK "ITextClass"} 
     or @{" Image " LINK "ImageClass"} supplied. 
@ENDNODE

@NODE PropGadgetClass "Proportional Gadget Class:"

   Class @{B}PropGadget@{UB} allows the @{B}AmigaTalk@{UB} system to man-
   ipulate Amiga Proportional Gadgets.  The Methods are:
     
   @{FG SHINE}
   new: gadgetName @{FG TEXT}

     Add a PropGadget to the @{B}AmigaTalk@{UB} system.  This method allocates
     an internal memory structure to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a PropGadget from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   registerTo: windowTitle @{FG TEXT}

     Set the name of the PropGadget's parent to the @{B}windowTitle@{UB}.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}

     Set the origin of the PropGadget to the given point value.
   @{FG SHINE}
   setGadgetSize: sizePoint @{FG TEXT}

     Set the size of the PropGadget to the given width & height.
   @{FG SHINE}
   modifyProps: newFlags hPot: hp vPot: vp hBody: hb vBody: vb 
                windowName: windowTitle @{FG TEXT}

     Change the given porportional values for the PropGadget.
   @{FG SHINE}
   setProps: gadgetName flags: newFlags hPot: hp vPot: vp 
                        hBody: hb vBody: vb @{FG TEXT}

     Initialize the porportional gadget values.
   @{FG SHINE}
   getPropFlags @{FG TEXT}

     Return the @{B}PropFlags@{UB} value for the PropGadget.  
   @{FG SHINE}
   getHPot @{FG TEXT}

     Return the HPot value of the PropGadget.
   @{FG SHINE}
   getVPot @{FG TEXT}

     Return the VPot value of the PropGadget.
   @{FG SHINE}
   getHBody @{FG TEXT}

     Return the HBody value of the PropGadget.
   @{FG SHINE}
   getVBody @{FG TEXT}
 
     Return the VBody value of the PropGadget.
   @{FG SHINE}
   getLeftEdge @{FG TEXT}

     Return the @{B}LeftEdge@{UB} value of the PropGadget.
   @{FG SHINE}
   getTopEdge @{FG TEXT}

     Return the @{B}TopEdge@{UB} value of the PropGadget.
   @{FG SHINE}
   getWidth @{FG TEXT}
 
     Return the @{B}Width@{UB} value of the PropGadget.
   @{FG SHINE}
   getHeight @{FG TEXT}

     Return the @{B}Height@{UB} value of the PropGadget.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} value of the PropGadget.
   @{FG SHINE}
   getActivation @{FG TEXT}

     Return the @{B}Activation@{UB} value of the PropGadget.
   @{FG SHINE}
   getGadgetType @{FG TEXT}

     Return the @{B}Type@{UB} of the PropGadget.

     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   getGadgetID @{FG TEXT}

     Return the @{B}GadgetID@{UB} number for the PropGadget.
   @{FG SHINE}
   getNextGadgetName @{FG TEXT}

     Return the name of the @{B}NextGadget@{UB} for the PropGadget.
   @{FG SHINE}
   getITextName @{FG TEXT}

     Return the name of the @{ " IText " LINK "ITextClass"} attached to the PropGadget.
   @{FG SHINE}
   getRenderName @{FG TEXT}

     Return the name of the gadget rendering (@{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}) for the
     PropGadget.
   @{FG SHINE}
   getSelectName @{FG TEXT}

     Return the name of the gadget selection rendering (@{" IText " LINK "ITextClass"} 
     or @{" Image " LINK "ImageClass"}) for the PropGadget.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Set the gadget @{B}Flags@{UB} to the new value(s).
   @{FG SHINE}
   setActivation: newActivation @{FG TEXT}

     Set the PropGadget @{B}Activation@{UB} to the new value.
   @{FG SHINE}
   setGadgetType: newGadgetType @{FG TEXT}

     Set the PropGadget @{B}Type@{UB} to the new value.
     
     NOTE:  only needed because of GZZGADGET & REQGADGET type flags.
   @{FG SHINE}
   setGadgetID: newGadgetID @{FG TEXT}

     Set the @{B}GadgetID@{UB} to the new value.
   @{FG SHINE}
   setNextGadgetName: newNextGadgetName @{FG TEXT}

     Set the @{B}NextGadget@{UB} to the @{B}Gadget@{UB} attached to @{B}newNextGadgetName@{UB}.
   @{FG SHINE}
   setITextName: newITextName @{FG TEXT}

     Set the @{" IText " LINK "ITextClass"} to the new value.
   @{FG SHINE}
   setRenderName: newRenderName @{FG TEXT}

     Set the PropGadget rendering to the name of the @{" IText " LINK "ITextClass"} or @{" Image " LINK "ImageClass"}
     supplied. 
   @{FG SHINE}
   setSelectName: newSelectName @{FG TEXT}

     Set the PropGadget selection rendering to the name of the @{" IText " LINK "ITextClass"} 
     or @{" Image " LINK "ImageClass"} supplied. 
@ENDNODE

@NODE ColorMapClass "Colors Class:"

   Class @{B}Colors@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga Colors.
   The Methods are:
   @{FG SHINE}
   new: windowObject @{FG TEXT}

     Initialize the instance of the @{B}ColorMap@{UB}. 
   @{FG SHINE}
   makeColorMap: numColors @{FG TEXT}

     Allocate a new @{B}ColorMap@{UB}.  Use this method after @{B}new:@{UB}
   @{FG SHINE}
   dispose @{FG TEXT}

     Free the given @{B}ColorMap@{UB} from the system. 
   @{FG SHINE}
   loadColors: howMany from: colorMapFileName @{FG TEXT}

     Load the amount of color registers @{B}howMany@{UB} with the values given in the 
     @{B}colorMapFileName@{UB} file.
   @{FG SHINE}
   getColor: sourceType from: sourceName which: n @{FG TEXT}

     Return an RGB representation from the given source (window = 1,
     all else is a colormapObject) for the @{B}n@{UB}th register.
     The format is whatever GetRGB4() returns for a windowObject &
     the format in ColorMap->ColorTable for a colorMapObject.
   @{FG SHINE}
   setColorReg: n red: r green: g blue: b @{FG TEXT}

     Set the color register @{B}n@{UB} to the RGB values supplied.
     (Equivalent to a call to SetRGB4( vport, n, red, green, blue )).
   @{FG SHINE}
   setMapValue: sourceType from: source num: n red: r green: g blue: b @{FG TEXT}

     Set the color register @{B}n@{UB} for the given source (window = 1 or
     colormap) to the RGB values supplied.
   @{FG SHINE}
   copyMap: source to: dest sourceType: type @{FG TEXT}

     Copy a @{B}ColorMap@{UB} from the source of @{I}type@{UI} 
     (window = 1 -> destination is @{B}ColorMap@{UB}, any other value implies
     @{B}ColorMap@{UB} Object -> destination is @" Window " LINK "WindowClass"} Object).
   @{FG SHINE}
   saveColorsTo: colorMapFileName @{FG TEXT}

     Save the color register values to the given filename. 

   See Also @{" LargeColors " LINK "LargeColorClass"}

@ENDNODE

@NODE "LargeColorClass" "LargeColors Class:"

   Class @{B}LargeColors@{UB} allows the @{B}AmigaTalk@{UB} system to manipulate Amiga Colors
   using full 32-bit values for red, green & blue color information.

   The Methods are:
   @{FG SHINE}
   new: windowObject @{FG TEXT}

     Initialize the instance of the @{B}ColorMap@{UB}. 
   @{FG SHINE}
   makeColorMap: numColors @{FG TEXT}

     Allocate a new @{B}ColorMap@{UB}.  Use this method after @{B}new:@{UB}
   @{FG SHINE}
   dispose @{FG TEXT}

     Free the given @{B}ColorMap@{UB} from the system. 
   @{FG SHINE}
   copyMap: source to: dest sourceType: type @{FG TEXT}

     Copy a @{B}ColorMap@{UB} from the source of @{I}type@{UI} 
     (window = 1 -> destination is @{B}ColorMap@{UB}, any other value implies
     @{B}ColorMap@{UB} Object -> destination is @" Window " LINK "WindowClass"} Object).
   @{FG SHINE}
   saveColorsTo: colorMapFileName @{FG TEXT}

     Save the color register values to the given filename. 
   @{FG SHINE}
   findColorMatch: red green: green blue: blue @{FG TEXT}
    
     Find the closest matching color to the RGB values given.
   @{FG SHINE}
   obtainBestPenMatch: red green: green blue: blue tags: tagArray @{FG TEXT}
   
     Find the closest matching color or allocate one.

     NOTE: be sure to use the @{B}releasePen:@{UB} method on the
     returned value from this method when you are done with it! 
   @{FG SHINE}
   obtainPen: red green: green blue: blue flags: flags @{FG TEXT}
   
     Obtain a free palette entry (if any are left).
     
     NOTE: be sure to use the @{B}releasePen:@{UB} method on the
     returned value from this method when you are done with it! 
   @{FG SHINE}
   releasePen: whichPen @{FG TEXT}
   
     You MUST use this method for each pen Number returned from
     @{B}obtainBestPenMatch:green:blue:tags:@{UB} & 
     @{B}obtainPen:green:blue:flags:@{UB} methods when you are done with
     them.
   @{FG SHINE}
   getRGB32: firstPen howMany: numColors into: colorArray @{FG TEXT}
   
     Get a series of color register values & palce them in 
     colorArray.
     @{FG SHINE}
     WARNING:  The size of colorArray MUST be at least 
               3 * numColors in length or this method will
               fail with error messages. @{FG TEXT}
   @{FG SHINE}
   makeColorTable: firstPen howMany: numColors with: colorArray @{FG TEXT}
   
     Create & format an Array that can be used by the 
     loadRGB32 method (This is NOT the same as the colorArray 
     found in the @{B}getRGB32:howMany:into:@{UB} method!): 
   @{FG SHINE}
   loadRGB32 @{FG TEXT}
   
     Set a series of color registers for this instance using the
     colorTable obtained from @{B}makeColorTable:howMany:with:@{UB}
     method.
   @{FG SHINE}
   attachExtraPaletteInfo @{FG TEXT}
   
     Allocate & attach extra palette info to the ColorMap
     (The @{B}dispose@{UB} method will take care of this). 

   See Also @{" Colors " LINK "ColorMapClass"}

@ENDNODE

@NODE RequesterClass "Requester Class:"

   Class @{B}Requester@{UB} implements control of Amiga Requesters for @{B}AmigaTalk@{UB},
   except for displaying them, which is done inside the @{" Window " LINK WindowClass} class.
   The methods are:
   @{FG SHINE}
   initialize: reqValuesArray @{FG TEXT}

     Initialize a @{B}Requester@{UB} for the @{B}AmigaTalk@{UB} system.
     reqValuesArray is an @{B}Array@{UB} with the following fields:

       LeftEdge,  TopEdge, 
       Width,     Height, 
       RelLeft,   RelTop,
       ReqGadget, ReqBorder, ReqText, 
       Flags      BackFill,  ImageBMap,
       ReqImage,  ReqLayer
   @{FG SHINE}
   new @{FG TEXT}

     Create a new @{B}Requester@{UB} instance.
   @{FG SHINE}
   dispose @{FG TEXT}

     Remove a @{B}Requester@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge \@ TopEdge@{UB} of the receiver.
   @{FG SHINE}
   getReqSize @{FG TEXT}

     Return the @{B}Width \@ Height@{UB} of the receiver.
   @{FG SHINE}
   getRelativePoint @{FG TEXT}

     Return the @{B}RelLeft \@ RelTop@{UB} variable of the receiver.
   @{FG SHINE}
   getFlags @{FG TEXT}

     Return the @{B}Flags@{UB} variable of the receiver.
   @{FG SHINE}
   getBackFill @{FG TEXT}

     Return the background pen number of the receiver.
   @{FG SHINE}
   getReqText @{FG TEXT}
     
     Return the @{" IText " LINK "ITextClass"} attached to the receiver.
   @{FG SHINE}
   getReqGadget @{FG TEXT}

     Return the first @{" Gadget " LINK "GadgetClass"} attached to the receiver.
   @{FG SHINE}
   getReqBorder @{FG TEXT}

     Return the @{" Border " LINK "BorderClass"} attached to the receiver. 
   @{FG SHINE}
   getReqBitMap @{FG TEXT}

     Return the @{" BitMap " LINK "BitMapClass"} attached to the receiver.
   @{FG SHINE}
   setStartPoint: newPoint @{FG TEXT}

     Change the @{B}LeftEdge \@ TopEdge@{UB} of the receiver to 
     the supplied values.
   @{FG SHINE}
   setReqSize: sizePoint @{FG TEXT}

     Change the @{B}Width \@ Height@{UB} of the receiver to the
     values supplied.
   @{FG SHINE}
   setRelativePoint: newRelPoint @{FG TEXT}

     Change the @{B}RelLeft \@ RelTop@{UB} of the receiver to the values
     given.
     NOTE:  You should also add the @{B}POINTREL@{UB} value to the @{B}Flags@{UB} of the
            receiver in order to use this feature.
   @{FG SHINE}
   setFlags: newFlags @{FG TEXT}

     Change the @{B}Flags@{UB} of the receiver to @{B}newFlags@{UB}.
   @{FG SHINE}
   setBackFill: newBackFill @{FG TEXT}

     Change the background pen number to @{B}newBackFill@{UB} for the 
     receiver.
   @{FG SHINE}
   setReqText: newReqText @{FG TEXT}

     Change the @{" IText " LINK "ITextClass"} attached to the reciever to @{B}newReqText@{UB}.
   @{FG SHINE}
   setReqBorder: newReqBorder @{FG TEXT}

     Change the @{" Border " LINK "BorderClass"} attached to the receiver to @{B}newReqBorder@{UB}. 
   @{FG SHINE}
   setReqGadget: newReqGadget @{FG TEXT}

     Change the @{" Gadget " LINK "GadgetClass"} attached to the receiver to @{B}newReqGadget@{UB}. 
   @{FG SHINE}
   setReqBitMap: newReqBMap @{FG TEXT}

     Change the @{" BitMap " LINK "BitMapClass"} attached to the receiver to @{B}newReqBMap@{UB}. 
   @{FG SHINE}   
   setReqLayer: newLayerObject @{FG TEXT}

     Change the @{" Layer " LINK "LayersClass"} attached to the receiver to
     @{I}newLayerObject@{UI}.

   @{FG SHINE}   
   setReqImage: newImageObject @{FG TEXT}

     Change the @{" Image " LINK "ImageClass"} attached to the receiver to
     @{I}newImageObject@{UI}.

@ENDNODE

@NODE AlertClass "Alert Class:"

   Class @{B}Alert@{UB} implements control of Amiga Alerts for the @{B}AmigaTalk@{UB} system.
@{FG SHINE}   The message string that the user supplies will be truncated at 128 
   characters & the alert number will be prepended to it. @{FG TEXT}
   @{FG SHINE}
   new: newAlertName @{FG TEXT}

     Add an @{B}Alert@{UB} to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   remove @{FG TEXT}

     Remove an @{B}Alert@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   getAlertNumber @{FG TEXT}

     Return the alert number attached to the receiver.
   @{FG SHINE}
   getAlertHeight @{FG TEXT}

     Return the height of the receiver.
   @{FG SHINE}
   getAlertMessage @{FG TEXT}

     Return the alert @{" String " LINK "GeneralClasses.guide/StringClass"} attached to the receiver.
   @{FG SHINE}
   setAlertNumber: num @{FG TEXT}

     Change the alert number of the receiver to @{B}num@{UB}.
   @{FG SHINE}
   setAlertHeight: height @{FG TEXT}

     Change the alert height of the receiver to @{B}height@{UB}.
   @{FG SHINE}
   setAlertMessage: newMsg @{FG TEXT}

     Change the alert @{B}String@{UB} of the receiver to @{B}newMsg@{UB}.
   @{FG SHINE}
   displayAlert @{FG TEXT}

     Display the receiver to the user.
@ENDNODE

@NODE BorderClass "Border Class:"

   The Class @{B}Border@{UB} (in this implementation) is an abstract class that
   normally is attached to other objects, such as @{B}Gadgets or Requesters@{UB}.
   This is why there is no method for actually drawing borders into 
   @{B}Window@{UB}s in this Class.  See @{I}drawPolygon@{UI} in the Class @{"Painter" LINK "PainterClass"}
   if you need to draw a @{B}Border@{UB} in a @{"Window" LINK "WindowClass"}.
   
   SubClasses:  @{" Line      " LINK LineClass}
                @{" Triangle  " LINK TriangleClass}
                @{" Rectangle " LINK RectangleClass}
   
   @{FG SHINE}
   new: numPoints @{FG TEXT}

     Add the receiver to the @{B}AmigaTalk@{UB} system.  Initialize the new
     Border Object as follows:
        nextBorder     <- nil.
        leftEdge       <- 0
        topEdge        <- 0
        frontPen       <- 1
        backPen        <- 0
        drawMode       <- 1
        count          <- numPoints * 2
   @{FG SHINE}
   dispose @{FG TEXT}

     Remove the receiver from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   registerTo: parentObject @{FG TEXT}

     Set the parent of the receiver to @{B}parentObject@{UB}.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge \@ TopEdge@{UB} of the receiver as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getBorderPens @{FG TEXT}

     Return the foreground \@ background pen numbers of the receiver
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   setBorderPens: newPensPoint @{FG TEXT}

     Change the foreground \@ background pen numbers of the receiver.
   @{FG SHINE}
   getDrawMode @{FG TEXT}

     Return the drawing mode of the receiver.  Currently known values
     are:
     
        JAM1       = 0
        JAM2       = 1
        COMPLEMENT = 2
        INVERSEVID = 4
   @{FG SHINE}
   getCount @{FG TEXT}

     Return the number of points in the receiver.
   @{FG SHINE}
   getNextBorder @{FG TEXT}

     Return the next @{B}Border@{UB} Object attached to the receiver.
   @{FG SHINE}
   setStartPoint: sPoint @{FG TEXT}

     Change the starting point of the receiver to @{B}sPoint@{UB}.
     This method sets @{B}LeftEdge & TopEdge@{UB}.
   @{FG SHINE}
   setDrawMode: newDrawMode @{FG TEXT}

     Change the drawing mode of the receiver.  Currently known values
     are:
     
        JAM1       = 0
        JAM2       = 1
        COMPLEMENT = 2
        INVERSEVID = 4
   @{FG SHINE}
   setCount: newCount @{FG TEXT}

     Change the number of points in the receiver.
   @{FG SHINE}
   setNextBorder: newBorderObject @{FG TEXT}

     Change the next @{B}Border@{UB} attached to the receiver.
   @{FG SHINE}
   setBorderPoint: thePt to: newPoint @{FG TEXT}

     Change the value of a point in the receiver.
   @{FG SHINE}
   draw @{FG TEXT}
     
     If the parent of the receiver is a Screen, Window or Requester this
     method will display it in it's parent Object.
@ENDNODE

@NODE LineClass "Line Class (Border sub-class):"

   @{FG SHINE}
   makeLineFrom: fPoint to: tPoint @{FG TEXT}

     Create a @{" Border " LINK "BorderClass"} with two @{" Points " LINK "GeneralClasses.guide/PointClass"}.
@ENDNODE

@NODE TriangleClass "Triangle Class (Border sub-class):"

   @{FG SHINE}
   makeTriangle: v1Point vert2: v2Point vert3: v3Point @{FG TEXT}

     Create a @{" Border " LINK "BorderClass"} with 4 @{" Points " LINK "GeneralClasses.guide/PointClass"}.
@ENDNODE

@NODE RectangleClass "Rectangle Class (Border sub-class):"

   @{FG SHINE}
   makeRectangleFrom: fPoint to: tPoint @{FG TEXT}

     Create a @{" Border " LINK "BorderClass"} with 5 @{" Points " LINK "GeneralClasses.guide/PointClass"}.
@ENDNODE

@NODE FontClass "Font Class:"

   Class @{B}Font@{UB} implements control of Amiga Fonts.
   The methods for @{B}Font@{UB} are:
   @{FG SHINE}
   openFont: newFontName size: fontSize style: newFontStyle  @{FG TEXT}

     Open the given font in the AmigaOS & setup the font
     instance variables.  Valid values for newFontStyle:
        NORMAL     = 0,
        @{U}UNDERLINED@{UU} = 1,
     @{B}   BOLD  @{UB}     = 2,
     @{I}   ITALIC @{UI}    = 4
        
     newFontStyle can also be set to more than one style by adding
     these numbers together.
   @{FG SHINE}
   closeFont @{FG TEXT}
   
     Close the given font to the AmigaOS.
   @{FG SHINE}
   fontName @{FG TEXT}

     Return the name of the Font.
   @{FG SHINE}
   fontYSize @{FG TEXT}
     
     Return the Height of the Font (in pixels - ta_YSize).
   @{FG SHINE}
   fontStyle @{FG TEXT}

     Return the style (ta_Style) of the Font such as PLAIN (NORMAL), 
     BOLD, UNDERLINED or ITALIC, etc.
   @{FG SHINE}
   fontFlags @{FG TEXT}

     Return the @{B}Flags@{UB} of the receiver (ta_Flags).
   @{FG SHINE}
   fontName: newName @{FG TEXT}

     Change the name of the Font to newName (ta_Name <- newName).
     This method is probably not really needed.
   @{FG SHINE}
   fontYSize: newYSize @{FG TEXT}

     Set the Height of the Font   (ta_YSize <- newYSize).
   @{FG SHINE}
   fontStyle: newStyle @{FG TEXT}

     Change the style of the Font (ta_Style <- newStyle).
   @{FG SHINE}
   fontFlags: newFlags @{FG TEXT}

     Change the Flags of the Font (ta_Flags <- newFlags).
   @{FG SHINE}
   xxxNew: newFontName @{FG TEXT}

     Add a @{B}Font@{UB} named @{I}newFontName@{UI} (example:
     'topaz.font') to the @{B}AmigaTalk@{UB} system.  Use the
     @{I}openFont:size:style:@{UI} method instead!
   @{FG SHINE}
   xxxDispose @{FG TEXT}

     Remove a @{B}Font@{UB} from the @{B}AmigaTalk@{UB} system.
     Use the @{I}closeFont@{UI} method instead.
     
   See Also @{" IText Class " LINK "ITextClass"}
@ENDNODE

@NODE ITextClass "IText Class:"

   Class @{B}IText@{UB} implements control of Amiga @{B}IntuiText@{UB} except for actually
   displaying it, which is in the @{"Window" LINK "WindowClass"} class.
   The methods for @{B}IText@{UB} are:
   @{FG SHINE}
   new: newITextString @{FG TEXT}

     Add an @{B}IText@{UB} (@{I}IntuiText@{UI}) to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   dispose @{FG TEXT}

     Remove an @{B}IText@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   getPens @{FG TEXT}

     Return the foreground \@ background pen numbers of the receiver
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getDrawMode @{FG TEXT}

     Return the drawing mode of the receiver.  Currently known values are:

        JAM1       = 0
        JAM2       = 1
        COMPLEMENT = 2
        INVERSEVID = 4
   @{FG SHINE}
   getITextOrigin @{FG TEXT}

     Return the @{B}LeftEdge \@ TopEdge @{UB} of the receiver
     as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getFontName @{FG TEXT}

     Return the name of the rendering font of the receiver.
   @{FG SHINE}
   getIText @{FG TEXT}

     Return the @{" String " LINK "GeneralClasses.guide/StringClass"} that the the receiver will display.
   @{FG SHINE}
   getNextText @{FG TEXT}

     Return the next @{B}IText@{UB} Object (@{B}IntuiText@{UB}) of the receiver.
   @{FG SHINE}
   getTextLength @{FG TEXT}

     Return the length (in pixels) of the text of the receiver.
   @{FG SHINE}
   setPens: newPens @{FG TEXT}

     Change the foreground \@ background pens of the receiver
     to newPens (which is a @{" Point " LINK "GeneralClasses.guide/PointClass"}).
   @{FG SHINE}
   setDrawMode: newDrawMode @{FG TEXT}

     Change the drawing mode of the receiver.  Currently known values are:

        JAM1       = 0
        JAM2       = 1
        COMPLEMENT = 2
        INVERSEVID = 4
   @{FG SHINE}
   setITextOrigin: newPoint @{FG TEXT}

     Change the @{B}LeftEdge \@ TopEdge@{UB} of the receiver
     (newPoint is a @{" Point " LINK "GeneralClasses.guide/PointClass"}).
   @{FG SHINE}
   setFont: newFontObject @{FG TEXT}

     Change the rendering font of the receiver.
   @{FG SHINE}
   setIText: iTextName to: newIText @{FG TEXT}

     Change the text @{B}String@{UB} of the receiver.
   @{FG SHINE}
   setNextText: newNextTextObj @{FG TEXT}

     Change the next @{B}IText@{UB} of the receiver.

   See Also @{" Font Class " LINK "FontClass"}
@ENDNODE

@NODE IconClass "Icon Class:"

   Class @{B}Icon@{UB} implements control of Amiga @{B}Icons@{UB}.
   The methods for @{B}Icon@{UB} are:
   @{FG SHINE}
   openIcon: iconFileName @{FG TEXT}

     Add an @{B}Icon@{UB} to the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   new: iconFileName @{FG TEXT}

     Same as openIcon: method.
   @{FG SHINE}
   closeIcon @{FG TEXT}

     Remove an @{B}Icon@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   editToolTypes @{FG TEXT}

     Display the ToolTypes in a GUI for editing purposes.  Not all
     Icon types have ToolTypes (just Tool & Project icon types).
   @{FG SHINE}
   displayIconInfo @{FG TEXT}
    
     Display a GUI containing information about the Icon. 
     NOTE:  The Icon colors displayed might not be correct 
            (working on it!).
   @{FG SHINE}
   displayIconImages @{FG TEXT}
    
     Display only the Icon images.  NOTE:  The Icon colors displayed
     might not be correct (working on it!).
   @{FG SHINE}
   setIconPosition: newPoint @{FG TEXT}
    
     Set the physical screen location of an Icon to @{" newPoint " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   moveIcon: deltaPoint @{FG TEXT}
    
     Move the physical screen location of an Icon by @{" deltaPoint " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   editIcon: externalEditorName @{FG TEXT}
    
     Invoke the named external Icon editor (such as Sys:Tools/IconEdit),
     so that you can edit the Icon with the editor of your choosing.
   @{FG SHINE}
   addToolType: toolString @{FG TEXT}
    
     Add a ToolType to the Icon (only Tool & Project Icon types have
     ToolTypes).
   @{FG SHINE}
   deleteToolType: toolString @{FG TEXT}

     Delete a ToolType from the Icon (only Tool & Project Icon types have
     ToolTypes).
   @{FG SHINE}
   getIconWidth @{FG TEXT}

      Return the Width (in pixels) of the Icon.
   @{FG SHINE}
   getIconHeight @{FG TEXT}

      Return the Height (in pixels) of the Icon.
   @{FG SHINE}
   getIconFlags @{FG TEXT}

      Return the Flags (usually related to Display mode) of the Icon.
      ^ <primitive 219 12 private>
   @{FG SHINE}
   getIconImageObject @{FG TEXT}

      Return the Icon Image.
   @{FG SHINE}
   getIconAlternateImageObj @{FG TEXT}

      Return the Icon alternate Image.
   @{FG SHINE}
   getIconType @{FG TEXT}

      Return an Integer representing the type of the Icon.  The returned
      value is decoded as follows:

         WBDISK     = 1, WBDRAWER   = 2
         WBTOOL     = 3, WBPROJECT  = 4
         WBGARBAGE  = 5, WBDEVICE   = 6
         WBKICK     = 7, WBAPPICON  = 8
   @{FG SHINE}
   getDefaultIcon: iconType @{FG TEXT}
   
      (See getIconType comments for iconType).
   @{FG SHINE}
   newDiskObject: iconType @{FG TEXT}

      Create an @{B}empty@{UB} Icon.    
      The DiskObject returned by this method will have a zero
      width and height Image in the do_Gadget.GadgetRender member
      and the do_Gadget.Width/do_Gadget.Height members will both
      be 0, too.
      (See getIconType comments for iconType).
   @{FG SHINE}
   getNewDiskObject: iconName @{FG TEXT}

      This method reads in a Workbench disk object in from disk.  The
      iconName parameter will have ".info" postpended to it, and the
      icon file of that name will be read.
   @{FG SHINE}
   getDefaultTool @{FG TEXT}

      Return a String representing the Default Tool of the Icon (only
      Project & Disk Icon types have Default Tools).
   @{FG SHINE}
   getStackSize @{FG TEXT}

      Return an Integer representing the Stack Size of the Icon.
   @{FG SHINE}
   getWindowWidth @{FG TEXT}

      Return an Integer representing the Window Width of the Icon.  Only
      Disk, Drawer & Garbage icon types have a valid value for this.
   @{FG SHINE}
   getWindowHeight @{FG TEXT}

      Return an Integer representing the Window Height of the Icon.  Only
      Disk, Drawer & Garbage icon types have a valid value for this.
   @{FG SHINE}
   getWindowTopEdge @{FG TEXT}

      Return an Integer representing the Window TopEdge of the Icon.  Only
      Disk, Drawer & Garbage icon types have a valid value for this.
   @{FG SHINE}
   getWindowLeftEdge @{FG TEXT}

      Return an Integer representing the Window LeftEdge of the Icon.  Only
      Disk, Drawer & Garbage icon types have a valid value for this.
   @{FG SHINE}
   getIconBounds: diskObj for: rectObj from: windowObj label: labelStr tags: tagArray @{FG TEXT}

      @{I}labelStr@{UI} can be nil for this method.      
   @{FG SHINE}
   setIconWidth: newWidth @{FG TEXT}

      Change the Width of the Icon to newWidth.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setIconHeight: newHeight @{FG TEXT}

      Change the Height of the Icon to newHeight.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setIconFlags: newFlags @{FG TEXT}

      Change the Flags of the Icon to newFlags.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setIconImage: imageObject @{FG TEXT}

      Change the Image of the Icon to @{" imageObject " LINK "ImageClass"}.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setIconAlternateImage: imageObject @{FG TEXT}

      Change the alternate Image of the Icon to @{" imageObject " LINK "ImageClass"}.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setIconType: newType @{FG TEXT}

      Change the type of the Icon to newType.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.

      Valid types are:

         WBDISK     = 1, WBDRAWER   = 2
         WBTOOL     = 3, WBPROJECT  = 4
         WBGARBAGE  = 5, WBDEVICE   = 6
         WBKICK     = 7, WBAPPICON  = 8
   @{FG SHINE}
   setDefaultTool: newDefaultTool @{FG TEXT}

      Change the Default Tool of the Icon to newDefaultTool.  Only 
      Disk & Project Icon types have a Default Tool.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setStackSize: newStackSize @{FG TEXT}

      Change the Stack Size of the Icon to newStackSize.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setWindowWidth: newWidth @{FG TEXT}

      Change the Width of the Icon Window to newWidth. Only Disk, Drawer
      & Garbage Icon types have Windows.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setWindowHeight: newHeight @{FG TEXT}

      Change the Height of the Icon Window to newHeight. Only Disk, Drawer
      & Garbage Icon types have Windows.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setWindowTopEdge: newTopEdge @{FG TEXT}

      Change the TopEdge of the Icon Window to newTopEdge. Only Disk, 
      Drawer & Garbage Icon types have Windows.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   setWindowLeftEdge: newLeftEdge @{FG TEXT}

      Change the LeftEdge of the Icon Window to newLeftEdge. Only Disk, 
      Drawer & Garbage Icon types have Windows.
      WARNING:  This method updates the Icon to disk, so do NOT change
                it unless you're willing (or you have a backup) to live
      with the consequences.
   @{FG SHINE}
   readInAsciiImage: fileName @{FG TEXT}

      The image read in will be placed in the Icon normal Image
      (icon->do_Gadget.GadgetRender for you programmers), then the Icon 
      will be written to the file system.

      The ASCII image file has the following format:

         width, height, depth \n
         datum \n datum \n datum \n ... \n<EOF>

      Only @{B}writeAsciiImage:@{UB} can create these types of files. @{B}
      NOTE:  This is NOT the same as an @{" Image " LINK "ImageClass"} object (or an Intuition 
             Image)!@{UB}
   @{FG SHINE}
   writeAsciiImage: fileName @{FG TEXT}

      Write the normal Icon Image (icon->do_Gadget.GadgetRender for you
      programmers) to the fileName in the following format:

         width, height, depth\n
         datum \n datum \n datum \n ... <EOF>

      Only @{B}readInAsciiImage:@{UB} can make use of these types of files.@{B}
      NOTE:  This is NOT the same as an @{" Image " LINK "ImageClass"} object (or an Intuition 
             Image)!@{UB}
   @{FG SHINE}
   iconControl: diskObject tags: tagArray @{FG TEXT}

      This method is used to modify and query icon and icon.library
      options via the tags supplied in tagArray.
      (diskObject can be nil).
   @{FG SHINE}
   findToolType: toolName in: diskObj @{FG TEXT}

      This method searches a tool type array for a given entry,
      and returns a String for that entry.  This is useful for
      finding standard tool type variables.
   @{FG SHINE}
   matchTool: toolTypeString to: toolValueStr @{FG TEXT}

      Check a tool type variable for a particular String.
   @{FG SHINE}    
   storeDefaultIcon: diskObject @{FG TEXT}

      Write @{I}diskObject@{UI} as the default Icon for its icon Type.
   @{FG SHINE}
   duplicateDiskObject: diskObject tags: tagArray @{FG TEXT}

      This method is used to create a duplicate of a DiskObject
      in memory. It can also be used to create an extended
      ("native") DiskObject data structure from an existing,
      traditional format DiskObject data structure.
   @{FG SHINE}
   drawIcon: diskObj on: windowObj label: labelStr at: sPoint inState: whichState
                   tags: tagArray @{FG TEXT} 

      This method will draw an icon as if it were an image; if
      a @{I}labelStr@{UI} is provided, it will be printed below it.
      (@{I}labelStr@{UI} can be nil for this method).
   @{FG SHINE}
   layoutIcon: diskObj on: screenObj tags: tagArray @{FG TEXT}

      This method will prepare an icon for display, either on a
      specific @{I}screenObj@{UI} or using a default color palette. It is
      useful only for palette mapped icons.
      (@{I}screenObj@{UI} can be nil).
   @{FG SHINE}
   bumpRevision: oldName to: newName @{FG TEXT}

      Reformat an Icon name for a second copy.
      @{B}bumpRevision:to:@{UB} takes a name and turns it into a 'copy_of_name'.
      It knows how to deal with copies of copies.  The method
      will truncate the new name to the maximum dos name size
      (currently 30 characters).      
      @{I}newName@{UI} @{B}HAS@{UB} to be a @{" String " LINK "GeneralCalsses.guide/StringClass"} object of at 
      least 31 characters in length.  Just create it 
      with:  @{B}newName <- String new: 32@{UB}
   @{FG SHINE}
   changeColorToSelectedIconColor: colorRegisterObj @{FG TEXT}

      See icon.library docs for ChangeToSelectedIconColor() function.
   @{FG SHINE}
   disposeFreeList: freeListObj @{FG TEXT}

      This method frees all memory in a free list, and the
      free list itself.  It is useful for easily getting
      rid of all memory in a series of structures.  There is
      a free list in a Workbench object (i.e., Icon), and this contains
      all the memory associated with that object.
   @{FG SHINE}
   add: memoryObj toFreeList: freeListObj size: size @{FG TEXT}

      This method adds the specified memory to the free list.
      The free list will be extended (if required).  If there
      is not enough memory to complete the call, nil is returned.

      Note that AddFreeList() does NOT allocate the requested memory.
      It only records the memory in the free list.
   @{FG SHINE}
   deleteDiskObject: iconName @{FG TEXT}

      Delete a diskObject from disk, associated with the Icon named
      @{I}iconName@{UI}.  Returns true if successful.
   @{FG SHINE}
   storeIcon: diskObj named: iconName tags: tagArray @{FG TEXT}

      Store an @{I}iconName@{UI} specified in @{I}diskObj@{UI} according 
      to the @{I}tagArray@{UI} options.

   See Also @{" Image Class " LINK "ImageClass"}
@ENDNODE

@NODE BitMapClass "BitMap Class:"                   

   Class @{B}BitMap@{UB} implements control of Amiga BitMaps for the @{B}Amigatalk@{UB} 
   system.  Valid values for Flags are:
   
     BMB_CLEAR       = 0
     BMB_DISPLAYABLE = 1
     BMB_INTERLEAVED = 2
     BMB_STANDARD    = 3
     BMB_MINPLANES   = 4
   @{FG SHINE}
   new: newBitMapName @{FG TEXT}

     Add an instance of a @{B}BitMap@{UB} to the @{B}AmigaTalk@{UB} system.
     Default values are as follows:
        
        name   <- newBitMapName
        width  <- 1
        height <- 1
        depth  <- 1
   @{FG SHINE}
   remove @{FG TEXT}

     Remove a @{B}BitMap@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   getBitMapWidth @{FG TEXT}
    
     Return the width (in pixels) of the receiver.
   @{FG SHINE}
   getBitMapHeight @{FG TEXT}

     Return the height (in pixels) of the receiver.
   @{FG SHINE}
   getBitMapFlags @{FG TEXT}

     Return the @{B}Flags@{UB} of the receiver.
   @{FG SHINE}
   getBitMapDepth @{FG TEXT}

     Return the depth (number of bitplanes) of the receiver.
   @{FG SHINE}
   setBitMapWidth: newWidth @{FG TEXT}

     Change the width (in pixels) of the receiver.
   @{FG SHINE}
   setBitMapHeight: newHeight @{FG TEXT}

     Change the height (in pixels) of the receiver.
   @{FG SHINE}
   setBitMapFlags: newFlags @{FG TEXT}

     Change the @{B}Flags@{UB} of the receiver.
   @{FG SHINE}
   setBitMapDepth: newDepth @{FG TEXT}

     Change the depth (number of bitplanes) of the receiver.
   @{FG SHINE}
   readBitMapFile: bitMapFile @{FG TEXT}

     Load a @{B}BitMap@{UB} from the given file.  The file format is unique to
     @{B}AmigaTalk@{UB}.
   @{FG SHINE}
   writeBitMapFile: bitMapFile @{FG TEXT}

     Save a @{B}BitMap@{UB} to the given file.  The file format is unique to
     @{B}AmigaTalk@{UB}.
@ENDNODE

@NODE PainterClass "Painter Class:"

   Class @{B}Painter@{UB} allows the user to draw simple graphics onto
   @{" Windows " LINK "WindowClass"}.  The methods are:

   @{FG SHINE}
   new: newOwnerWindow @{FG TEXT}
     
     Initialize a new instance of Painter by setting the Window that will
     be used by the @{B}Painter@{UB}.
   @{FG SHINE}
   setLinePattern: newPatternMask @{FG TEXT}
     
     Set a pattern to use for drawing lines.  For example, if 
     newPatternMask is 2r11001100110011001100110011001100, a dashed
     line will be drawn.   
   @{FG SHINE}
   setAPen: pen @{FG TEXT}

     Change the foreground pen number of the given @{B}Window@{UB}.
   @{FG SHINE}
   setBPen: pen @{FG TEXT}

     Change the background pen number of the given @{B}Window@{UB}.
   @{FG SHINE}
   setOPen: pen @{FG TEXT}

     Change the outline pen number of the given @{B}Window@{UB}.
   @{FG SHINE}
   setDrawMode: mode @{FG TEXT}

     Change the drawing mode of the given @{B}Window@{UB}.  Currently known
     values are:

        JAM1       = 0
        JAM2       = 1
        COMPLEMENT = 2
        INVERSEVID = 4
   @{FG SHINE}
   getPens @{FG TEXT}

      Return the foreground pen & the background pen as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getOPen @{FG TEXT}
    
      Return an Integer representing the outline pen color Register number.
   @{FG SHINE}
   getDrawMode @{FG TEXT}

      Return an Integer representing the drawing mode (See @{I}setDrawMode:@{UI})
   @{FG SHINE}
   location @{FG TEXT}

      Return the coordinates, where the pen is located, as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   ownerIs @{FG TEXT}

      Return an Object representing the Window that the Painter is attached to.

   @{FG SHINE}
   movePenTo: newPoint @{FG TEXT}

     Change the drawing @{" Point " LINK "GeneralClasses.guide/PointClass"} (without drawing anything!) on the given
     @{B}Window@{UB}.

   @{FG SHINE}
   drawTo: aPoint @{FG TEXT}

     Draw a line from the current @{B}Window@{UB} location to the given point.
   @{FG SHINE}
   drawLineFrom: fPoint to: tPoint @{FG TEXT}

     Draw a line from @{B}fPoint@{UB} to @{B}tPoint@{UB}.
   @{FG SHINE}
   drawBoxFrom: fPoint to: tPoint @{FG TEXT}

     Draw a box from @{B}fPoint@{UB} to @{B}tPoint@{UB}.
   @{FG SHINE}
   drawCircle: cPoint radius: r @{FG TEXT}

     Draw a circle of radius @{B}r@{UB} with center point @{B}cPoint@{UB}.
   @{FG SHINE}
   drawEllipse: cPoint minaxis: a maxaxis: b @{FG TEXT}

     Draw an ellipse at center point @{B}cPoint@{UB}.
   @{FG SHINE}
   drawPolygon: borderObject @{FG TEXT}

     Draw a @{" Border " LINK "BorderClass"} Object.
   @{FG SHINE}
   drawPixelAt: aPoint @{FG TEXT}

     Draw a single pixel at the point given.
   @{FG SHINE}
   drawText: iTextObject at: aPoint @{FG TEXT}

     Draw an @{" IText " LINK "ITextClass"} at the point given.
     @{B}
     NOTE:  You should set the foreground pen, background pen & the
            drawing mode before using this method! @{UB}
   @{FG SHINE}
   initializeArea: numPoints tmpXSize: x tmpYSize: y @{FG TEXT}

      You MUST use this method BEFORE using any of the Area/Filled methods
      down to @{I}disposeArea:y:@{UI} (which MUST be used after you're done
      with the Area/Filled method(s).  x & y should specify the dimensions
      of the largest rectangular area that will be drawn.
   @{FG SHINE}
   drawFilledEllipse: cPoint minaxis: a maxaxis: b @{FG TEXT}

      Same as @{I}drawEllipse:minaxis:maxaxis:@{UI}, only the ellipse is a solid color.
   @{FG SHINE}
   drawFilledCircle: cPoint radius: r @{FG TEXT}

      Same as @{I}drawCircle:radius:@{UI}, only the circle is a solid color.
   @{FG SHINE}
   areaMoveTo: newPoint @{FG TEXT}

      Same as @{I}movePenTo:@{UI} method, only for Area/Filled methods.
   @{FG SHINE}
   areaDrawTo: aPoint @{FG TEXT}

      Same as @{I}drawTo:@{UI} method, only for Area/Filled methods.
   @{FG SHINE}
   drawFilledBoxFrom: fPoint to: tPoint @{FG TEXT}

      This uses the RectFill() function.
   @{FG SHINE}
   floodFill: mode at: aPoint @{FG TEXT}

      If mode is 0 (outline mode), every pixel surrounding aPoint that is
      NOT the outline Pen color will be changed to the flood Pen color (or
      flood pattern).  If the mode is 1 (color mode), whatever the color is
      at aPoint and all surrounding pixels of the same color will be flood-
      filled (or patterned).
   @{FG SHINE}   
   areaEnd @{FG TEXT}

      Complete the Area/Filled polygons.  Use this after
      @{I}areaDrawTo:, drawFilledEllipse:minaxis:maxaxis:, 
      & drawFilledCircle:radius:@{UI} only.
   @{FG SHINE}
   setAreaPattern: patternWords size: size @{FG TEXT}

      Similar to @{I}setLinePattern:@{UI}
      
      @{I}patternWords@{UI} is a ByteArray that is divisible by two.  Each pair of
      bytes in @{I}patternWords@{UI} is interpreted as a UWORD value.
      @{I}size@{UI} is a power of two, indicating how tall the pattern is, 
      which means that the number of elements in @{I}patternWords@{UI} must 
      be 2 * 2 ^ @{I}size@{UI}.
      (example: 0 = two ByteArray elements (1 line), 
      1 = four elements (2 lines), 
      2 = 4 lines, 3 = 8 lines, 4 = 16, etc).  No checking is done, 
      so get it right (or write your own method!).
   @{FG SHINE}
   outlineOff @{FG TEXT}

      Turn off usage of the outline Pen.  Part of the Area/Filled methods.
   @{FG SHINE}
   outlineOn @{FG TEXT}

      Turn on usage of the outline Pen.  Part of the Area/Filled methods.
   @{FG SHINE}
   disposeArea: xSize y: ySize @{FG TEXT}

      xSize & ySize MUST be the same dimensions that were used in the
      @{I}initializeArea:tmpXSize:tmpYSize:@{UI} method.

@ENDNODE

@NODE "ImageClass" "Image Class:"

   Class @{B}Image@{UB} allows the user to draw Amiga Images
   onto @{" Windows " LINK "WindowClass"}.  This Class is
   Located in Painter.st  The methods are:
   @{FG SHINE}
   ownerIs @{FG TEXT}

     Return the @{" Window " LINK "WindowClass"} object that contains the Image.
   @{FG SHINE}
   registerTo: windowObject @{FG TEXT}

     Set the parent Object of the receiver @{B}Image@{UB} to @{B}windowObject@{UB}.
   @{FG SHINE}
   disposeImage @{FG TEXT}

     Remove an @{B}Image@{UB} from the @{B}AmigaTalk@{UB} system.
   @{FG SHINE}
   drawImageAt: aPoint @{FG TEXT}

     Display an @{B}Image@{UB} at the given @{" aPoint " LINK "GeneralClasses.guide/PointClass"} coordinates.
   @{FG SHINE}
   drawImageAt: aPoint inState: state @{FG TEXT}

      Same as @{I}drawImageAt:@{UI} except that the state of the @{B}Image@{UB} can be
      specified.  Valid values for @{B}state@{UB} are:

        0 = IDS_NORMAL:           // same as @{I}drawImageAt:@{UI}
        1 = IDS_SELECTED:         // represents the 'selected state' of a Gadget
        2 = IDS_DISABLED:         // the 'ghosted state' of a gadget
        3 = IDS_BUSY:             // for future functionality
        4 = IDS_INDETERMINATE:    // for future functionality
        5 = IDS_INACTIVENORMAL:   // for gadgets in window border
        6 = IDS_INACTIVESELECTED: // for gadgets in window border
        7 = IDS_INACTIVEDISABLED: // for gadgets in window border
        8 = IDS_SELECTEDDISABLED: // disabled and selected
   @{FG SHINE}
   pointInImage: testPoint @{FG TEXT}

      If the @{I}testPoint@{UI} is inside the @{B}Image@{UB} boundaries, return true.
   @{FG SHINE}
   eraseImageStartingAt: aPoint @{FG TEXT}

      Erase part or ALL of an @{B}Image@{UB}.
   @{FG SHINE}
   setImageDataFrom: imageFile @{FG TEXT}

     Load @{B}Image@{UB} data from the given file.
   @{FG SHINE}
   getStartPoint @{FG TEXT}

     Return the @{B}LeftEdge & TopEdge@{UB} of the receiver as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getImageSize @{FG TEXT}

     Return the @{B}Width & Height@{UB} of the receiver as a @{" Point " LINK "GeneralClasses.guide/PointClass"}.
   @{FG SHINE}
   getImageDepth @{FG TEXT}

     Return the @{B}Depth@{UB} of the receiver.
   @{FG SHINE}
   getImagePlanePick @{FG TEXT}

     Return the @{B}PlanePick@{UB} variable of the receiver.
   @{FG SHINE}
   getImagePlaneOnOff @{FG TEXT}

     Return the @{B}PlaneOnOff@{UB} variable of the receiver.
   @{FG SHINE}
   getNextImage @{FG TEXT}

     Return the next @{B}Image@{UB} Object in the receiver.
   @{FG SHINE}
   setOrigin: aPoint @{FG TEXT}

     Set the @{B}LeftEdge & TopEdge@{UB} of the receiver to the @{" Point " LINK "GeneralClasses.guide/PointClass"} given.
   @{FG SHINE}
   setExtent: sizePoint @{FG TEXT}

     Set the @{B}Width & Height@{UB} of the receiver to the @{" Point " LINK "GeneralClasses.guide/PointClass"} given.
   @{FG SHINE}
   setImageDepth: newDepth @{FG TEXT}

     Set the @{B}Depth@{UB} (range: 1 to 8) of the receiver.
   @{FG SHINE}
   setImagePlanePick: pp @{FG TEXT}

     Set the @{B}PlanePick@{UB} variable of the receiver.
   @{FG SHINE}
   setImagePlaneOnOff: po @{FG TEXT}

     Set the @{B}PlaneOnOff@{UB} variable of the receiver.
   @{FG SHINE}
   setNextImage: nextImage @{FG TEXT}

     Set the next @{B}Image@{UB} Object in the receiver.
   @{FG SHINE}
   grabImageFrom: windowObj startPoint: s endPoint: e @{FG TEXT}
    
     Initialize the receiver data from the Window Object's display from
     the given coordinates. @{FG SHINE} WARNING:  Make sure that the receiver
     has enough room before you use this method.  No checks for 
     overflowing the internal memory area can be performed! @{FG TEXT} 

     I cannot test this method since my system has a CyberVision 64D
     graphics card (which uses a non-standard method for reading/
     writing BitMaps, so please let @{" me " LINK "GeneralClasses.guide/Author"} know if it works for you!)
   @{FG SHINE}
   addImage: width height: h depth: d @{FG TEXT}

     Initialize the receiver Object.  Use this method after:
     @{B}myIMage <- Image new@{UB}
@ENDNODE

@NODE IStructClass "IStruct Class:"

     Not Implemented yet!
     
     Class @{B}IStruct@{UB} allows access to various Amiga OS structures
     used by Intuition.  These are:

     ViewPorts
     Views
     PlayFields
     RastPorts
     RasInfo
     Blitter
     Copper

@ENDNODE

@NODE AnimClass "Animation Class:"

     Not Implemented yet!
     
     Class @{B}Anim@{UB}
@ENDNODE
