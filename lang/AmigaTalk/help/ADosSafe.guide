@DATABASE ADosSafe.guide

@COPYRIGHT (C) 2002 by J.T. Steichen

@REM $VER: AmigaTalk:Help/ADosSafe.guide 2.1 (22-Mar-2002) by J.T. Steichen

@REM Generated with RoboDoc v3.0j (May 24 1999)
@REM RoboDoc is copyright 1994-1997 by Maverick Software Development

@INDEX "Main"
@TOC   "Main"

@NODE "Main" "AmigaTalk to AmigaDOS Help:"

   The functions listed here & used by @{B}AmigaTalk@{UB} have been deemed
   the least harmful of the AmigaDOS functions.  This is based
   on my judgement only, but here is how I arrived at this:
   The functions determined to be safe are mainly for gathering
   information from AmigaDOS.  Those that actually change things
   are easily corrected by the User (for example:  If you use
   @{I}setComment: commentString onFile: fileName@{UI} & you used the
   wrong commentString, you can always re-do the Method with the
   correct comment, or correct it using a file utility, such as
   DirOpus or DiskMaster II).  Where it made sense to do so,
   the arguments the User supplies these functions/Methods are
   also checked for valid ranges or values, so even if you pass
   in a NULL pointer, @{B}AmigaTalk@{UB} should short-circuit your 
   attempt to kill your system (I hope!).
   
   @{FG SHINE}  
   SAFE AmigaDOS Functions/AmigaTalk Methods: @{FG TEXT}

   @{"waitForChar       " Link "waitForChar"}
   @{"vPrintf           " Link "vPrintf"}
   @{"vFPrintf          " Link "vFPrintf"}
   @{"unGetC            " Link "unGetC"}
   @{"strToLong         " Link "strToLong"}
   @{"strToDate         " Link "strToDate"}
   @{"splitName         " Link "splitName"}
   @{"setProtection     " Link "setProtection"}
   @{"setPrompt         " Link "setPrompt"}
   @{"setIoErr          " Link "setIoErr"}
   @{"setFileDate       " Link "setFileDate"}
   @{"setComment        " Link "setComment"}
   @{"sameLock          " Link "sameLock"}
   @{"sameDevice        " Link "sameDevice"}
   @{"readLink          " Link "readLink"}
   @{"readItem          " Link "readItem"}
   @{"readArgs          " Link "readArgs"}
   @{"readFile          " Link "readFile"}
   @{"putStr            " Link "putStr"}
   @{"printFault        " Link "printFault"}
   @{"pathPart          " Link "pathPart"}
   @{"parentOfFH        " Link "parentOfFH"}
   @{"parentDir         " Link "parentDir"}
   @{"maxCli            " Link "maxCli"}
   @{"matchNext         " Link "matchNext"}
   @{"matchFirst        " Link "matchFirst"}
   @{"matchEnd          " Link "matchEnd"}
   @{"isInteractive     " Link "isInteractive"}
   @{"isFileSystem      " Link "isFileSystem"}
   @{"ioErr             " Link "ioErr"}
   @{"getVar            " Link "getVar"}
   @{"getPrompt         " Link "getPrompt"}
   @{"getProgramName    " Link "getProgramName"}
   @{"getProgramDir     " Link "getProgramDir"}
   @{"getFileSysTask    " Link "getFileSysTask"}
   @{"getDeviceProc     " Link "getDeviceProc"}
   @{"getCurrentDirName " Link "getCurrentDirName"}
   @{"getConsoleTask    " Link "getConsoleTask"}
   @{"getArgStr         " Link "getArgStr"}
   @{"fPutS             " Link "fPutS"}
   @{"fPutC             " Link "fPutC"}
   @{"findVar           " Link "findVar"}
   @{"findCliProc       " Link "findCliProc"}
   @{"filePart          " Link "filePart"}
   @{"fGetS             " Link "fGetS"}
   @{"fGetC             " Link "fGetC"}
   @{"fault             " Link "fault"}
   @{"endNotify         " Link "endNotify"}
   @{"errReport         " Link "errReport"}
   @{"delay             " Link "delay"}
   @{"dateToStr         " Link "dateToStr"}
   @{"currentDir        " Link "currentDir"}
   @{"compareDates      " Link "compareDates"}
   @{"cliPointer        " Link "cliPointer"}
   @{"addBuffers        " Link "addBuffers"}
   @{"abortPacket       " Link "AbortPacket"}

@ENDNODE

@NODE "waitForChar" "waitForChar (SAFE):"

   @{B}NAME@{UB}
       WaitForChar -- Determine if chars arrive within a time limit

   @{B}SYNOPSIS@{UB}
       BOOL status = WaitForChar( BPTR file, LONG timeout );


   @{B}FUNCTION@{UB}
       If a character is available to be read from 'file' within the
       time (in microseconds) indicated by 'timeout', WaitForChar()
   returns -1 (TRUE). If a character is available, you can use Read()
   to read it.  Note that WaitForChar() is only valid when the I/O
   stream is connected to a virtual terminal device.  If a character is
   not available within 'timeout', a 0 (FALSE) is returned.

   @{B}BUGS@{UB}
   @{FG SHINE}    Due to a bug in the timer.device in V1.2/V1.3, specifying a timeout
       of zero for WaitForChar() can cause the unreliable timer & floppy
       disk operation.
   @{FG TEXT}
   @{B}INPUTS@{UB}
       file    - BCPL pointer to a file handle
       timeout - integer

   @{B}SEE ALSO@{UB}
       @{" Read " LINK "readFile"}, @{" FGetC " LINK "fGetC"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   waitForCharAt: bptrFileHandle for: timeout @{FG TEXT}

@ENDNODE

@NODE "vPrintf" "vPrintf (SAFE):"

   @{B}NAME@{UB}
       VPrintf -- format and print string (buffered)

   @{B}SYNOPSIS@{UB}
       LONG count = VPrintf( char *fmt, LONG *argv );

   @{B}FUNCTION@{UB}
       Writes the formatted string and values to Output().  This routine is 
       assumed to handle all internal buffering so that the formatting string
   and resultant formatted values can be arbitrarily long.  Any secondary
   error code is returned in IoErr().  This routine is buffered.

   Note:  RawDoFmt assumes 16 bit ints, so you will usually need 'l's in
   your formats (example:  %ld versus %d).

   @{B}INPUTS@{UB}
       fmt   - exec.library RawDoFmt() style formatting string
       argv  - Pointer to array of formatting values
   
   @{B}RESULT@{UB}
       count - Number of bytes written or -1 (EOF) for an error

   @{B}BUGS@{UB}
   @{FG SHINE}    The prototype for Printf() currently forces you to cast the first
       varargs parameter to LONG due to a deficiency in the program
       that generates fds, prototypes, and amiga.lib stubs.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" VFPrintf " LINK "vFPrintf"}, @{" VFWritef " LINK "ADosUnsafe.guide/vFWritef"}, 
       @{" FPutC    " LINK "fPutC"}, RawDoFmt()
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   vPrintf: formatString withArgs: argv @{FG TEXT}

@ENDNODE

@NODE "vFPrintf" "vFPrintf (SAFE): "

   @{B}NAME@{UB}
       VFPrintf -- format and print a string to a file (buffered)

   @{B}SYNOPSIS@{UB}
       LONG count = VFPrintf( BPTR fh, char *fmt, LONG *argv )

   @{B}FUNCTION@{UB}
       Writes the formatted string and values to the given file.  This
       routine is assumed to handle all internal buffering so that the
   formatting string and resultant formatted values can be arbitrarily
   long.  Any secondary error code is returned in @{" IoErr() " LINK "ioErr"}.  This routine
   is buffered.

   @{B}INPUTS@{UB}
       fh    - Filehandle to write to
       fmt   - RawDoFmt() style formatting string
       argv  - Pointer to array of formatting values

   @{B}RESULT@{UB}
       count - Number of bytes written or -1 (EOF) for an error

   @{B}BUGS@{UB}
   @{FG SHINE}    The prototype for FPrintf() currently forces you to cast the first
       varargs parameter to LONG due to a deficiency in the program
       that generates fds, prototypes, and amiga.lib stubs.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" VPrintf " LINK "vFPrintf"}, @{" VFWritef " LINK "ADosUnsafe.guide/vFWritef"}, 
       @{" FPutC " LINK "fPutC"}, RawDoFmt()
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   vFPrintfTo: bptrFileHandle format: fmtString withArgs: argv @{FG TEXT}

@ENDNODE

@NODE "unGetC" "unGetC (SAFE):"

   @{B}NAME@{UB}
       UnGetC -- Makes a char available for reading again. (buffered) 

   @{B}SYNOPSIS@{UB}
       LONG value = UnGetC( BPTR fh, LONG character )

   @{B}FUNCTION@{UB}
       Pushes the character specified back into the input buffer.  Every
       time you use a buffered read routine, you can always push back 1
   character.  You may be able to push back more, though it is not
   recommended, since there is no guarantee on how many can be
   pushed back at a given moment.

   Passing -1 for the character will cause the last character read to
   be pushed back.  If the last character read was an EOF, the next
   character read will be an EOF.
 
   Note:  UnGetC can be used to make sure that a filehandle is set up
   as a read filehandle.  This is only of importance if you are writing
   a shell, and must manipulate the filehandle's buffer.

   @{B}INPUTS@{UB}
       fh     - filehandle to use for buffered I/O
       character - character to push back or -1

   @{B}RESULT@{UB}
       value - character pushed back, or FALSE if the character cannot
               be pushed back.

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, UnGetC(fh,-1) after an EOF would not cause the next character
       read to be an EOF.  This was fixed for V37.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FGetC " LINK "fGetC"}, @{" FPutC " LINK "fPutC"}, 
       @{" Flush " LINK "ADosUnsafe.guide/flushFH"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   unGetC: chr to: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "strToLong" "strToLong (SAFE):"

   @{B}NAME@{UB}
       strToLong -- string to long value (decimal)

   @{B}SYNOPSIS@{UB}
       LONG value = strToLong: aString


   @{B}FUNCTION@{UB}
       Converts decimal string into LONG value.
       Skips over leading spaces & tabs.  If no decimal digits are found 
    (after skipping leading spaces & tabs), StrToLong returns -1 for 
    characters converted, and puts 0 into value.

   @{B}INPUTS@{UB}
       string - Input string.

   @{B}RESULT@{UB}
       result - the value the string was converted to.
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   strToLong: aString @{FG TEXT}

@ENDNODE

@NODE "strToDate" "strToDate (SAFE):"

   @{B}NAME@{UB}
       StrToDate -- Converts a string to a DateStamp 

   @{B}SYNOPSIS@{UB}
       BOOL success = StrToDate( struct DateTime *datetime );

   @{B}FUNCTION@{UB}
       Converts a human readable ASCII string into an AmigaDOS
       DateStamp.

   @{B}INPUTS@{UB}
       DateTime - a pointer to an initialized DateTime structure.

       The DateTime structure should   be initialized as follows:
 
       dat_Stamp  - ignored on input.
 
       dat_Format - a format byte which specifies the format of the
                    dat_StrDat.  This can be any of the following   
                    (note:  If value used is something other than   
                    those below, the default of FORMAT_DOS is used):
 
          FORMAT_DOS:     AmigaDOS format (dd-mmm-yy).
 
          FORMAT_INT:     International   format (yy-mmm-dd).
 
          FORMAT_USA:     American format (mm-dd-yy).
 
          FORMAT_CDN:     Canadian format (dd-mm-yy).
 
          FORMAT_DEF:     default format for locale.
 
       dat_Flags - a flags byte.  The only flag which affects this
                   function is:
 
          DTF_SUBST:   ignored by this function
          DTF_FUTURE:  If set, indicates that strings such
                       as (stored in   dat_StrDate) "Monday"
                       refer to "next" monday.  Otherwise,
                       if clear, strings like "Monday"
                       refer to "last" monday.
 
       dat_StrDay - ignored bythis function.
 
       dat_StrDate - pointer to valid string representing the date.
                     This can be a "DTF_SUBST" style string such as
                     "Today" "Tomorrow" "Monday", or it may be a string
       
         as specified by the dat_Format byte.   This will be
         converted to the ds_Days portion of the DateStamp.
         If this pointer is NULL, DateStamp->ds_Days will not
         be affected.
 
       dat_StrTime - Pointer to a buffer which contains the time in
                     the ASCII format hh:mm:ss.  This will be converted
         to the ds_Minutes and ds_Ticks portions of the
         DateStamp.  If this pointer is NULL, ds_Minutes and
         ds_Ticks will be unchanged.
 

   @{B}RESULT@{UB}
       success - a zero return indicates that a conversion could
                 not be performed. A non-zero return indicates that the
                 DateTime.dat_Stamp variable contains the converted
                 values.

   @{B}SEE ALSO@{UB}
       @{" DateStamp " LINK "ADosUnsafe.guide/dateStamp"}, @{" DateToStr " LINK "dateToStr"}, 
       <dos/datetime.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   strToDate: dateTimeObject @{FG TEXT}

@ENDNODE

@NODE "splitName" "splitName (SAFE):"

   @{B}NAME@{UB}
       SplitName -- splits out a component of a pathname into a buffer 

   @{B}SYNOPSIS@{UB}
       WORD newpos = SplitName( char *name, UBYTE separator,
                                char *buf, WORD oldpos, LONG size );

   @{B}FUNCTION@{UB}
       This routine splits out the next piece of a name from a given file
       name.  Each piece is copied into the buffer, truncating at size-1
   characters.  The new position is then returned so that it may be
   passed in to the next call to splitname.  If the separator is not
   found within 'size' characters, then size-1 characters plus a null will
   be put into the buffer, and the position of the next separator will
   be returned.
 
   If a a separator cannot be found, -1 is returned (but the characters
   from the old position to the end of the string are copied into the
   buffer, up to a maximum of size-1 characters).  Both strings are
   null-terminated.
 
   This function is mainly intended to support handlers.
 
   @{B}INPUTS@{UB}
       name      - Filename being parsed.
       separator - Separator charactor to split by.
       buf       - Buffer to hold separated name.
       oldpos    - Current position in the file.
       size      - Size of buf in bytes (including null termination).


   @{B}RESULT@{UB}
       newpos    - New position for next call to splitname.  -1 for last one.

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36 and V37, path portions greater than or equal to 'size' caused
       the last character of the portion to be lost when followed by a
   separator.  Fixed for V39 dos.  For V36 and V37, the suggested work-
   around is to call SplitName() with a buffer one larger than normal
   (for example, 32 bytes), and then set buf[size - 2] to '0' (for example,
   buf[30] = @{B}'0'@{UB};).
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FilePart " LINK "filePart"}, @{" PathPart " LINK "pathPart"}, 
       @{" AddPart  " LINK "ADosUnsafe.guide/addPart"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   splitName: name by: sep into: aBuffer ofSize: size at: oldpos @{FG TEXT}     

@ENDNODE
      
@NODE "setProtection" "setProtection (SAFE):"

   @{B}NAME@{UB}
       SetProtection -- Set protection for a file or directory

   @{B}SYNOPSIS@{UB}
       BOOL success = SetProtection( char *name, LONG mask );

   @{B}FUNCTION@{UB}
       SetProtection() sets the protection attributes on a file or
       directory.  See <dos/dos.h> for a listing of protection bits.

   Before V36, the ROM filesystem didn't respect the Read and Write
   bits.  In V36 or later and in the FFS, the Read and Write
   bits are respected.
 
   The archive bit should be cleared by the filesystem whenever the file
   is changed.  Backup utilities will generally set the bit after
   backing up each file.
 
   The V36 Shell looks at the execute bit, and will refuse to execute
   a file if it is set.
 
   Other bits will be defined in the <dos/dos.h> include files.  Rather
   than referring to bits by number you should use the definitions in
   <dos/dos.h>.

   @{B}INPUTS@{UB}
       name - pointer to a null-terminated string
       mask - the protection mask required

   @{B}SEE ALSO@{UB}
       @{" SetComment " LINK "setComment"}, @{" Examine " LINK "ADosUnsafe.guide/examine"},
       @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, 
       <dos/dos.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   setProtectionOf: filename to: protectionMask @{FG TEXT}  " Tested. "

@ENDNODE

@NODE "setPrompt" "setPrompt (SAFE):"

   @{B}NAME@{UB}
       SetPrompt -- Sets the CLI/shell prompt for the current process 

   @{B}SYNOPSIS@{UB}
       BOOL success = SetPrompt( char *name );

   @{B}FUNCTION@{UB}
       Sets the text for the prompt in the cli structure.  If the prompt is 
       too long to fit, a failure is returned, and the old value is left
   intact.  It is advised that you inform the user of this condition.
   This routine is safe to call even if there is no CLI structure.

   @{B}INPUTS@{UB}
       name - Name of prompt to be set.

   @{B}BUGS@{UB}
   @{FG SHINE}    This clips to a fixed (1.3 compatible) size.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" GetPrompt " LINK "getPrompt"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   setPromptTo: newPromptString @{FG TEXT}

@ENDNODE

@NODE "setIoErr" "setIoErr (SAFE):"

   @{B}NAME@{UB}
       SetIoErr -- Sets the value returned by @{" IoErr " LINK "ioErr"} 

   @{B}SYNOPSIS@{UB}
       LONG oldcode = SetIoErr( LONG code );

   @{B}FUNCTION@{UB}
       This routine sets up the secondary result (pr_Result2) return code 
       (returned by the IoErr function).

   @{B}INPUTS@{UB}
       code - Code to be returned by a call to IoErr.
  
   @{B}RESULT@{UB}
       oldcode - The previous error code.

   @{B}SEE ALSO@{UB}
       @{" IoErr " LINK "ioErr"}, @{" Fault " LINK "fault"}, 
       @{" PrintFault " LINK "printFault"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   setIoErrTo: errorCode @{FG TEXT}

@ENDNODE

@NODE "setFileDate" "setFileDate (SAFE):"

   @{B}NAME@{UB}
       SetFileDate -- Sets the modification date for a file or dir 

   @{B}SYNOPSIS@{UB}
       BOOL success = SetFileDate( char *name, struct DateStamp *date );


   @{B}FUNCTION@{UB}
       Sets the file date for a file or directory.  Note that for the Old
       File System and the Fast File System, the date of the root directory
   cannot be set.  Other filesystems may not support setting the date
   for all files/directories.

   @{B}INPUTS@{UB}
       name - Name of object
       date - New modification date


   @{B}SEE ALSO@{UB}
       @{" DateStamp " LINK "ADosUnsafe.guide/dateStamp"}, @{" Examine " LINK "ADosUnsafe.guide/examine"}, 
       @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, @{" ExAll " LINK "ADosUnsafe.guide/exAll"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   setFileDateOf: fileOrDirName to: dateStampObject @{FG TEXT}

@ENDNODE

@NODE "setComment" "setComment (SAFE):"

   @{B}NAME@{UB}
       SetComment -- Change a files' comment string

   @{B}SYNOPSIS@{UB}
       BOOL success = SetComment( char *name, char *comment );


   @{B}FUNCTION@{UB}
       SetComment() sets a comment on a file or directory. The comment is
       a pointer to a null-terminated string of up to 80 characters in the
   current ROM filesystem (and RAM:).  Note that not all filesystems
   will support comments (for example, NFS usually will not), or the
   size of comment supported may vary.

   @{B}INPUTS@{UB}
       name    - pointer to a null-terminated string
       comment - pointer to a null-terminated string


   @{B}SEE ALSO@{UB}
       @{" Examine " LINK "ADosUnsafe.guide/examine"}, @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, 
       @{" SetProtection " LINK "setProtection"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   setCommentFieldOf: fileOrDirName to: comment @{FG TEXT}  " Tested "

@ENDNODE

@NODE "sameLock" "sameLock (SAFE):"

   @{B}NAME@{UB}
       SameLock -- returns whether two locks are on the same object 

   @{B}SYNOPSIS@{UB}
       LONG value = SameLock( BPTR lock1, BPTR lock2 );

   @{B}FUNCTION@{UB}
       Compares two locks.  Returns LOCK_SAME if they are on the same object,
       LOCK_SAME_VOLUME if on different objects on the same volume, and
   LOCK_DIFFERENT if they are on different volumes.  Always compare
   for equality or non-equality with the results, in case new return
   values are added.

   @{B}INPUTS@{UB}
       lock1 - 1st lock for comparison
       lock2 - 2nd lock for comparison

   @{B}RESULT@{UB}
       value - LOCK_SAME, LOCK_SAME_VOLUME, or LOCK_DIFFERENT

   @{B}BUGS@{UB}
   @{FG SHINE}    Should do more extensive checks for NULL against a real lock, checking
    to see if the real lock is a lock on the root of the boot volume.

    In V36, it would return LOCK_SAME_VOLUME for different volumes on the
    same handler.  Also, LOCK_SAME_VOLUME was LOCK_SAME_HANDLER (now
    an obsolete define, see <dos/dos.h>).
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       <dos/dos.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   areSameLock: bptrLock1 and: bptrLock2 @{FG TEXT}

@ENDNODE

@NODE "sameDevice" "sameDevice (SAFE):"

   @{B}NAME@{UB}
       SameDevice -- Are two locks on the same partition of 
                     the device? (V37)

   @{B}SYNOPSIS@{UB}
       BOOL same = SameDevice( BPTR lock1, BPTR lock2 );

   @{B}FUNCTION@{UB}
       SameDevice returns whether two locks refer to partitions that
       are on the same physical device (if it can figure it out).  This
   may be useful in writing copy routines to take advantage of
   asynchronous multi-device copies.

   Entry existed in V36 and always returned 0.

   @{B}INPUTS@{UB}
       lock1, lock2 - locks

   @{B}RESULT@{UB}
       whether they're on the same device as far as Dos can determine.
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   areSameDevice: bptrLock1 and: bptrLock2 @{FG TEXT}

@ENDNODE

@NODE "readLink" "readLink (SAFE):"

   @{B}NAME@{UB}
       ReadLink -- Reads the path for a soft filesystem link 

   @{B}SYNOPSIS@{UB}
       BOOL success = ReadLink( struct MsgPort *port, BPTR lock,
                                char *path, char *buffer, 
                                ULONG size );

   @{B}FUNCTION@{UB}
       ReadLink() takes a lock/name pair (usually from a failed attempt
       to use them to access an object with packets), and asks the
   filesystem to find the softlink and fill buffer with the modified
   path string.  You then start the resolution process again by
   calling GetDeviceProc() with the new string from ReadLink().
 
   Soft-links are resolved at access time by a combination of the
   filesystem (by returning ERROR_IS_SOFT_LINK to dos), and by
   Dos (using ReadLink() to resolve any links that are hit).

   @{B}INPUTS@{UB}
       port   - msgport of the filesystem
       lock   - lock this path is relative to on the filesystem
       path   - path that caused the ERROR_IS_SOFT_LINK
       buffer - pointer to buffer for new path from handler.
       size   - size of buffer.


   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, soft-links didn't work in the ROM filesystem.  This was
       fixed for V37.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" MakeLink " LINK "ADosUnsafe.guide/makeLink"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}, 
       @{" Lock " LINK "ADosUnsafe.guide/lock"}, @{" GetDeviceProc " LINK "getDeviceProc"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   readLinkInto: aBuffer ofSize: length onPort: msgPort 
          using: bptrLock   and: pathName @{FG TEXT}

@ENDNODE

@NODE "readItem" "readItem (SAFE):"

   @{B}NAME@{UB}
       ReadItem - reads a single argument/name from command line 

   @{B}SYNOPSIS@{UB}
       LONG value = ReadItem( char *buffer, LONG maxchars, 
                              struct CSource *input );

   @{B}FUNCTION@{UB}
       Reads a "word" from either Input() (buffered), or via CSource, if it
       is non-NULL (see <dos/rdargs.h> for more information).  Handles
   quoting and some '*' substitutions (*e and *n) inside quotes (only).
   See dos/dos.h for a listing of values returned by ReadItem()
   (ITEM_XXXX).  A "word" is delimited by whitespace, quotes, '=', or
   an EOF.

   ReadItem always unreads the last thing read (UnGetC( fh, -1 )) so the
   caller can find out what the terminator was.

   @{B}INPUTS@{UB}
       buffer   - buffer to store word in.
       maxchars - size of the buffer
       input    - CSource input or NULL (uses FGetC(Input()))

   @{B}RESULT@{UB}
       value - See <dos/dos.h> for return values.

   @{B}BUGS@{UB}
   @{FG SHINE}    Doesn't actually unread the terminator.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" ReadArgs " LINK "readArgs"}, @{" FindArg " LINK "ADosUnsafe.guide/findArg"}, 
       @{" UnGetC   " LINK "unGetC"}, @{" FGetC " LINK "fGetC"}, 
       @{" Input " LINK "ADosUnsafe.guide/input"}, @{" FreeArgs " LINK "ADosDanger.guide/freeArgs"},
       <dos/dos.h>, <dos/rdargs.h> 
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   readItemInto: aBuffer ofSize: maxChars with: csourceInput @{FG TEXT}

@ENDNODE

@NODE "readArgs" "readArgs (SAFE):"

   @{B}NAME@{UB}
       ReadArgs - Parse the command line input 

   @{B}SYNOPSIS@{UB}
       struct RDArgs *result = ReadArgs( char          *template, 
                                         LONG          *array,
                                         struct RDArgs *rdargs
                                       );

   @{B}FUNCTION@{UB}
       Parses and argument string according to a template.  Normally gets
       the arguments by reading buffered IO from @{" Input() " LINK "ADosUnsafe.guide/input"}, but also can be
       made to parse a string.  MUST be matched by a call to @{" FreeArgs() " LINK "ADosDanger.guide/freeArgs"}.
 
   ReadArgs() parses the commandline according to a template that is
   passed to it.  This specifies the different command-line options and
   their types.  A template consists of a list of options.  Options are
   named in "full" names where possible (for example, "Quick" instead of
   "Q").  Abbreviations can also be specified by using "abbrev=option"
   (for example, "Q=Quick").
 
   Options in the template are separated by commas.  To get the results
   of ReadArgs(), you examine the array of longwords you passed to it
   (one entry per option in the template).  This array should be cleared
   (or initialized to your default values) before passing to ReadArgs().
   Exactly what is put in a given entry by ReadArgs() depends on the type
   of option.  The default is a string (a sequence of non-whitespace
   characters, or delimited by quotes, which will be stripped by
   ReadArgs()), in which case the entry will be a pointer.
 
   Options can be followed by modifiers, which specify things such as
   the type of the option.  Modifiers are specified by following the
   option with a '/' and a single character modifier.  Multiple modifiers
   can be specified by using multiple '/'s.  Valid modifiers are:
 
    /S - Switch.  This is considered a boolean variable, and will be
         set if the option name appears in the command-line.  The entry
         is the boolean (0 for not set, non-zero for set).
 
    /K - Keyword.  This means that the option will not be filled unless
         the keyword appears.  For example if the template is "Name/K",
         then unless "Name=<string>" or "Name <string>" appears in the
         command line, Name will not be filled.
 
    /N - Number.  This parameter is considered a decimal number, and will
         be converted by ReadArgs.  If an invalid number is specified,
         an error will be returned.  The entry will be a pointer to the
         longword number (this is how you know if a number was specified).
 
    /T - Toggle.  This is similar to a switch, but when specified causes
         the boolean value to "toggle".  Similar to /S.
 
    /A - Required.  This keyword must be given a value during command-line
         processing, or an error is returned.
 
    /F - Rest of line.  If this is specified, the entire rest of the line
         is taken as the parameter for the option, even if other option
         keywords appear in it.
 
    /M - Multiple strings.  This means the argument will take any number
         of strings, returning them as an array of strings.  Any arguments
         not considered to be part of another option will be added to this
         option.  Only one /M should be specified in a template.  Example:
         for a template "Dir/M,All/S" the command-line "foo bar all qwe"
         will set the boolean "all", and return an array consisting of
         "foo", "bar", and "qwe".  The entry in the array will be a pointer
         to an array of string pointers, the last of which will be NULL.
 
         There is an interaction between /M parameters and /A parameters.
         If there are unfilled /A parameters after parsing, it will grab
         strings from the end of a previous /M parameter list to fill the
         /A's.  This is used for things like Copy ("From/A/M,To/A").
 
   ReadArgs() returns a struct RDArgs if it succeeds.  This serves as an
   "anchor" to allow @{" FreeArgs() " LINK "ADosDanger.guide/freeArgs"} to free the associated memory.  You can
   also pass in a struct RDArgs to control the operation of ReadArgs()
   (normally you pass NULL for the parameter, and ReadArgs() allocates
   one for you).  This allows providing different sources for the
   arguments, providing your own string buffer space for temporary
   storage, and extended help text.  See <dos/rdargs.h> for more
   information on this.  Note: if you pass in a struct RDArgs, you must
   still call FreeArgs() to release storage that gets attached to it,
   but you are responsible for freeing the RDArgs yourself.
 
   If you pass in a RDArgs structure, you MUST reset (clear or set)
   RDA_Buffer for each new call to RDArgs.  The exact behavior if you
   don't do this varies from release to release and case to case; don't
   count on the behavior!
 
   See BUGS regarding passing in strings.
    
   @{B}INPUTS@{UB}
       template - formatting string
       array    - array of longwords for results, 1 per template entry
       rdargs   - optional rdargs structure for options.  AllocDosObject
                  should be used for allocating them if you pass one in.

   @{B}RESULT@{UB}
       result   - a struct RDArgs or NULL for failure.

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, there were a couple of minor bugs with certain argument
       combinations (/M/N returned strings, /T didn't work, and /K and
    /F interacted).  Also, a template with a /K before any non-switch
    parameter will require the argument name to be given in order for
    line to be accepted (i.e. "parm/K,xyzzy/A" would require
    "xyzzy=xxxxx" in order to work - "xxxxx" would not work).  If you
    need to avoid this for V36, put /K parameters after all non-switch
    parameters.  These problems should be fixed for V37.
 
    Currently (V37 and before) it requires any strings passed in to have
    newlines at the end of the string.  This may or may not be fixed in
    the future.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FindArg " LINK "ADosUnsafe.guide/findArg"}, @{" ReadItem " LINK "readItem"}, 
       @{" FreeArgs " LINK "ADosDanger.guide/freeArgs"}, @{" AllocDosObject " LINK "ADosDanger.guide/allocDosObject"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   readArgs: template into: stringPointerArray auxRDArgs: rdArgs @{FG TEXT}

@ENDNODE

@NODE "readFile" "readFile (SAFE):"

   @{B}NAME@{UB}
       Read -- Read bytes of data from a file

   @{B}SYNOPSIS@{UB}
       LONG actualLength = Read( BPTR file, char *buffer, LONG length );


   @{B}FUNCTION@{UB}
       Data can be copied using a combination of Read() and @{" Write() " LINK "ADosDanger.guide/writeFile"}.
       Read() reads bytes of information from an opened file (represented
       here by the argument 'file') into the buffer given. The argument
       'length' is the length of the buffer given.
 
   The value returned is the length of the information actually read.
   So, when 'actualLength' is greater than zero, the value of
   'actualLength' is the the number of characters read. Usually Read
   will try to fill up your buffer before returning. A value of zero
   means that end-of-file has been reached. Errors are indicated by a
   value of -1.
 
   Note:  This is an unbuffered routine (the request is passed directly
   to the filesystem.)  Buffered I/O is more efficient for small
   reads and writes; see FGetC().

   @{B}INPUTS@{UB}
       file   - BCPL pointer to a file handle
       buffer - pointer to buffer
       length - integer

   @{B}RESULT@{UB}
       actualLength - integer

   @{B}SEE ALSO@{UB}
       @{" Open " LINK "ADosUnsafe.guide/openFile"}, @{" Close " LINK "ADosUnsafe.guide/closeFIle"}, 
       @{" Write " LINK "ADosDanger.guide/writeFile"}, @{" Seek " LINK "ADosDanger.guide/seekFile"}, 
       @{" FGetC " LINK "fGetC"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   read: bptrFileHandle into: aBuffer ofSize: length @{FG TEXT}

@ENDNODE

@NODE "putStr" "putStr (SAFE):"

   @{B}NAME@{UB}
       PutStr -- Writes a string the the default output (buffered) 

   @{B}SYNOPSIS@{UB}
       LONG error = PutStr( char *str );

   @{B}FUNCTION@{UB}
       This routine writes an unformatted string to the default output.  No 
       newline is appended to the string and any error is returned.  This
       routine is buffered.

   @{B}INPUTS@{UB}
       str   - Null-terminated string to be written to default output

   @{B}RESULT@{UB}
       error - 0 for success, -1 for any error. 
       
       NOTE:  This is opposite most Dos function returns!

   @{B}SEE ALSO@{UB}
       @{" FPuts " LINK "fPuts"}, @{" FPutC " LINK "fPutC"}, 
       @{" FWrite " LINK "ADosDanger.guide/fWrite"}, @{" WriteChars " LINK "ADosUnsafe.guide/writeChars"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   putStr: aString @{FG TEXT}

@ENDNODE

@NODE "printFault" "printFault (SAFE):"

   @{B}NAME@{UB}
       PrintFault -- Returns the text associated with a DOS error code 

   @{B}SYNOPSIS@{UB}
       BOOL success = PrintFault( LONG code, char *header );

   @{B}FUNCTION@{UB}
       This routine obtains the error message text for the given error code.
       This is similar to the @{" Fault() " LINK "fault"} function, except that the output is
   written to the default output channel with buffered output.
   The value returned by @{" IoErr() " LINK "ioErr"} is set to the code passed in.

   @{B}INPUTS@{UB}
       code   - Error code
       header - header to output before error text

   @{B}SEE ALSO@{UB}
       @{" IoErr " LINK "ioErr"}, @{" Fault " LINK "fault"}, 
       @{" SetIoErr " LINK "setIoErr"}, @{" Output " LINK "ADosUnsafe.guide/output"}, 
       @{" FPuts " LINK "fPuts"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   printFault: header code: c @{FG TEXT}

@ENDNODE

@NODE "pathPart" "pathPart (SAFE):"

   @{B}NAME@{UB}
       PathPart -- Returns a pointer to the end of the next-to-last 
                   component of a path.
   @{B}SYNOPSIS@{UB}
       char *fileptr = PathPart( char *path );

   @{B}FUNCTION@{UB}
       This function returns a pointer to the character after the next-to-last
       component of a path specification, which will normally be the directory
   name.  If there is only one component, it returns a pointer to the
   beginning of the string.  The only real difference between this and
   FilePart() is the handling of @{B}/@{UB}.

   @{B}INPUTS@{UB}
       path - pointer to an path string.  May be relative to the current
              directory or the current disk.

   @{B}RESULT@{UB}
       fileptr - pointer to the end of the next-to-last component of the path.

   @{B}EXAMPLE@{UB}
       PathPart( "xxx:yyy/zzz/qqq" ) would return a pointer to the last @{B}/@{UB}.
       PathPart( "xxx:yyy" )         would return a pointer to the first @{B}y@{UB}).

   @{B}SEE ALSO@{UB}
       @{" FilePart " LINK "filePart"}, @{" AddPart " LINK "ADosUnsafe.guide/addPart"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getPathPart: pathAndFile @{FG TEXT}  " Tested "

@ENDNODE

@NODE "parentOfFH" "parentOfFH (SAFE):"

   @{B}NAME@{UB}
       ParentOfFH -- returns a lock on the parent directory of a file 

   @{B}SYNOPSIS@{UB}
       BPTR lock = ParentOfFH( BPTR fh );

   @{B}FUNCTION@{UB}
       Returns a shared lock on the parent directory of the filehandle.

   @{B}INPUTS@{UB}
       fh   - Filehandle you want the parent of.

   @{B}RESULT@{UB}
       lock - Lock on parent directory of the filehandle or NULL for failure.

   @{B}SEE ALSO@{UB}
       @{" Parent " LINK "parentDir"}, @{" Lock " LINK "ADosUnsafe.guide/lock"}, 
       @{" UnLock " LINK "ADosUnsafe.guide/unLock"}, @{" DupLockFromFH " LINK "ADosUnsafe.guide/dupLockFromFH"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getParentLockFromFH: fromBPTRFileHandle @{FG TEXT}

@ENDNODE

@NODE "parentDir" "parentDir (SAFE):"

   @{B}NAME@{UB}
       ParentDir -- Obtain the parent of a directory or file

   @{B}SYNOPSIS@{UB}
       BPTR newlock = ParentDir( BPTR lock )


   @{B}FUNCTION@{UB}
       The argument 'lock' is associated with a given file or directory.
       ParentDir() returns 'newlock' which is associated the parent
       directory of 'lock'.

   Taking the ParentDir() of the root of the current filing system
   returns a NULL (0) lock.  Note this 0 lock represents the root of
   file system that you booted from (which is, in effect, the parent
   of all other file system roots.)

   @{B}INPUTS@{UB}
       lock - BCPL pointer to a lock

   @{B}RESULT@{UB}
       newlock - BCPL pointer to a lock

   @{B}SEE ALSO@{UB}
       @{" Lock " LINK "ADosUnsafe.guide/lock"}, @{" DupLock " LINK "ADosUnsafe.guide/dupLock"}, 
       @{" UnLock " LINK "ADosUnsafe.guide/unLock"}, @{" ParentOfFH " LINK "parentOfFH"}, 
       @{" DupLockFromFH " LINK "ADosUnsafe.guide/dupLockFromFH"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getParentDirLock: fromBPTRLock @{FG TEXT}

@ENDNODE

@NODE "maxCli" "maxCli (SAFE):"

   @{B}NAME@{UB}
       MaxCli -- returns the highest CLI process number possibly in use 

   @{B}SYNOPSIS@{UB}
       LONG number = MaxCli( void );

   @{B}FUNCTION@{UB}
       Returns the highest CLI number that may be in use.  CLI numbers are
       reused, and are usually as small as possible.  To find all CLIs, scan
       using FindCliProc() from 1 to MaxCLI().  The number returned by
       MaxCli() may change as processes are created and destroyed.

   @{B}RESULT@{UB}
       number - The highest CLI number that _may_ be in use.

   @{B}SEE ALSO@{UB}
       @{" FindCliProc " LINK "findCliProc"}, @{" Cli " LINK "cliPointer"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getMaxCli @{FG TEXT}

@ENDNODE

@NODE "matchNext" "matchNext (SAFE):"

   @{B}NAME@{UB}
       MatchNext - Finds the next file or directory that matches pattern 

   @{B}SYNOPSIS@{UB}
       LONG error = MatchNext( struct AnchorPath *ap );

   @{B}FUNCTION@{UB}
       Locates the next file or directory that matches a given pattern.
       See <dos/dosasl.h> for more information.  Various bits in the flags
       allow the application to control the operation of MatchNext().

       See @{" MatchFirst() " LINK "matchFirst"} for other notes.

   @{B}INPUTS@{UB}
       AnchorPath - Place holder for search.  MUST be longword aligned!

   @{B}RESULT@{UB}
       error - 0 for success or error code.  (Opposite of most Dos calls)

   @{B}BUGS@{UB}
   @{FG SHINE}    See @{" MatchFirst " LINK "matchFirst"}.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" MatchFirst " LINK "matchFirst"}, @{" ParsePattern " LINK "ADosUnsafe.guide/parsePattern"}, 
       @{" Examine " LINK "ADosUnsafe.guide/examine"}, @{" CurrentDir " LINK "currentDir"}, 
       @{" MatchEnd " LINK "matchEnd"}, @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, 
       <dos/dosasl.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   matchNext: anchorPath @{FG TEXT}

@ENDNODE

@NODE "matchFirst" "matchFirst (SAFE):"

   @{B}NAME@{UB}
       MatchFirst -- Finds file that matches pattern 

   @{B}SYNOPSIS@{UB}
       LONG error = MatchFirst( char *pat, struct AnchorPath *ap );

   @{B}FUNCTION@{UB}
       Locates the first file or directory that matches a given pattern.
       MatchFirst() is passed your pattern (you do not pass it through
   @{" ParsePattern() " LINK "ADosUnsafe.guide/parsePattern"} - MatchFirst() does that for you), and the control
   structure.  MatchFirst() normally initializes your AnchorPath
   structure for you, and returns the first file that matched your
   pattern, or an error.  Note that MatchFirst()/MatchNext() are unusual
   for Dos in that they return 0 for success, or the error code (see
   <dos/dos.h>), instead of the application getting the error code
   from @{" IoErr() " LINK "ioErr"}.
 
   When looking at the result of MatchFirst()/@{" MatchNext() " LINK "matchNext"}, the ap_Info
   field of your AnchorPath has the results of an @{" Examine() " LINK "ADosUnsafe.guide/examine"} of the object.
   You normally get the name of the object from fib_FileName, and the
   directory it's in from ap_Current->an_Lock.  To access this object,
   normally you would temporarily @{" CurrentDir() " LINK "currentDir"} to the lock, do an action
   to the file/dir, and then CurrentDir() back to your original directory.
   This makes certain you affect the right object even when two volumes
   of the same name are in the system.  You can use ap_Buf (with
   ap_Strlen) to get a name to report to the user.
 
   To initialize the AnchorPath structure (particularily when reusing
   it), set ap_BreakBits to the signal bits (CDEF) that you want to take
   a break on, or NULL, if you don't want to convenience the user.
   ap_Flags should be set to any flags you need or all 0's otherwise.
   ap_FoundBreak should be cleared if you'll be using breaks.
 
   If you want to have the FULL PATH NAME of the files you found,
   allocate a buffer at the END of this structure, and put the size of
   it into ap_Strlen.  If you don't want the full path name, make sure
   you set ap_Strlen to zero.  In this case, the name of the file, and
   stats are available in the ap_Info, as per usual.
 
   Then call MatchFirst() and then afterwards, MatchNext() with this
   structure.  You should check the return value each time (see below)
   and take the appropriate action, ultimately calling MatchEnd() when
   there are no more files or you are done.  You can tell when you are
   done by checking for the normal AmigaDOS return code
   ERROR_NO_MORE_ENTRIES.
 
   Note:  Patterns with trailing slashes may cause MatchFirst()/MatchNext()
   to return with an ap_Current->an_Lock on the object, and a filename
   of the empty string ("").

   See @{" ParsePattern() " LINK "ADosUnsafe.guide/parsePattern"} for more information on the patterns.

   @{B}INPUTS@{UB}
       pat        - Pattern to search for
       AnchorPath - Place holder for search.  MUST be longword aligned!

   @{B}RESULT@{UB}
       error - 0 for success or error code.  (Opposite of most Dos calls!)

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, there were a number of bugs with MatchFirst()/MatchNext().
       One was that if you entered a directory with a name like "df0:L"
    using DODIR, it would re-lock the full string "df0:L", which can
    cause problems if the disk has changed.  It also had problems
    with patterns such as #?/abc/def - the ap_Current->an_Lock would
    not be on the directory def is found in.  ap_Buf would be correct,
    however.  It had similar problems with patterns with trailing
    slashes.  These have been fixed for V37 and later.
 
    A bug that has not been fixed for V37 concerns a pattern of a
    single directory name (such as @{B}L@{UB}).  If you enter such a directory
    via DODIR, it re-locks @{B}L@{UB} relative to the current directory.  Thus
    you must not change the current directory before calling MatchNext()
    with DODIR in that situation.  If you aren't using DODIR to enter
    directories you can ignore this.  This may be fixed in some upcoming
    release.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" MatchNext " LINK "matchNext"}, @{" ParsePattern " LINK "ADosUnsafe.guide/parsePattern"}, 
       @{" Examine " LINK "ADosUnsafe.guide/examine"}, @{" CurrentDir " LINK "currentDir"},
       @{" MatchEnd " LINK "matchEnd"}, @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, 
       <dos/dosasl.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   matchFirst: pattern fromAnchor: anchorPath @{FG TEXT}

@ENDNODE

@NODE "matchEnd" "matchEnd (SAFE):"

   @{B}NAME@{UB}
       MatchEnd -- Free storage allocated for MatchFirst()/MatchNext() 

   @{B}SYNOPSIS@{UB}
       void MatchEnd( struct AnchorPath *ap );

   @{B}FUNCTION@{UB}
       Return all storage associated with a given search.

   @{B}INPUTS@{UB}
       AnchorPath - Anchor used for @{" MatchFirst() " LINK "matchFirst"}/@{" MatchNext() " LINK "matchNext"}
                    MUST be longword aligned!


   @{B}SEE ALSO@{UB}
       @{" MatchFirst " LINK "matchFirst"}, @{" ParsePattern " LINK "ADosUnsafe.guide/parsePattern"}, 
       @{" Examine " LINK "ADosUnsafe.guide/examine"}, @{" CurrentDir " LINK "currentDir"},
       @{" MatchNext " LINK "matchNext"}, @{" ExNext " LINK "ADosUnsafe.guide/exNext"}, 
       <dos/dosasl.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   matchEnd: anchorPath @{FG TEXT}

@ENDNODE

@NODE "isInteractive" "isInteractive (SAFE):"

   @{B}NAME@{UB}
       IsInteractive -- Discover whether a file is "interactive"

   @{B}SYNOPSIS@{UB}
       BOOL status = IsInteractive( BPTR file )

   @{B}FUNCTION@{UB}
       The return value 'status' indicates whether the file associated
       with the file handle 'file' is connected to a virtual terminal.

   @{B}INPUTS@{UB}
       file - BCPL pointer to a file handle
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   isInteractive: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "isFileSystem" "isFileSystem (SAFE):"

   @{B}NAME@{UB}
       IsFileSystem -- returns whether a Dos handler is a filesystem 

   @{B}SYNOPSIS@{UB}
       BOOL result = IsFileSystem( char *name )

   @{B}FUNCTION@{UB}
       Returns whether the device is a filesystem or not.  A filesystem
       supports seperate files storing information.  It may also support
   sub-directories, but is not required to.  If the filesystem doesn't
   support this new packet, IsFileSystem() will use Lock( ":", ... ) as
   an indicator.

   @{B}INPUTS@{UB}
       name   - Name of device in question, with trailing ':'.

   @{B}RESULT@{UB}
       result - Flag to indicate if device is a file system

   @{B}SEE ALSO@{UB}
       @{" Lock " LINK "ADosUnsafe.guide/lock"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   ifFileSystem: name @{FG TEXT}

@ENDNODE

@NODE "ioErr" "ioErr (SAFE):"

   @{B}NAME@{UB}
       IoErr -- Return extra information from the system

   @{B}SYNOPSIS@{UB}
       LONG error = IoErr( void );

   @{B}FUNCTION@{UB}
       Most I/O routines return zero to indicate an error. When this 
       happens (or whatever the defined error return for the routine)
   this routine may be called to determine more information. It is
   also used in some routines to pass back a secondary result.

   Note:  There is no guarantee as to the value returned from IoErr()
   after a successful operation, unless specified by the routine.

   @{B}RESULT@{UB}
       error - integer

   @{B}SEE ALSO@{UB}
       @{" Fault " LINK "fault"}, @{" PrintFault " LINK "printFault"}, 
       @{" SetIoErr " LINK "setIoErr"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getIoErr @{FG TEXT}

@ENDNODE

@NODE "getVar" "getVar (SAFE):"

   @{B}NAME@{UB}
       GetVar -- Returns the value of a local or global variable

   @{B}SYNOPSIS@{UB}
       LONG len = GetVar( char *name, char *buffer, LONG size, LONG flags ); 

   @{B}FUNCTION@{UB}
       Gets the value of a local or environment variable.  It is advised to
       only use ASCII strings inside variables, but not required.  This stops
   putting characters into the destination when a @{B}newline@{UB} is hit, unless
   GVF_BINARY_VAR is specified.  (The @{B}newline@{UB} is not stored in the buffer.)

   @{B}INPUTS@{UB}
       name   - pointer to a variable name.
       buffer - a user allocated area which will be used to store
                the value associated with the variable.
       size   - length of the buffer region in bytes.
      
       flags  - combination of type of var to get value of (low 8 bits),
                & flags to control the behavior of this routine.  Currently
                defined flags include:

            GVF_GLOBAL_ONLY - tries to get a global env variable.
            GVF_LOCAL_ONLY  - tries to get a local variable.
            GVF_BINARY_VAR  - don't stop at @{B}newline@{UB}
            
            GVF_DONT_NULL_TERM - no null termination (only valid
                                 for binary variables). (V37)

       The default is to try to get a local variable first, then
       to try to get a global environment variable.

   @{B}RESULT@{UB}
       len -   Size of environment variable.  -1 indicates that the
               variable was not defined (if @{" IoErr() " LINK "ioErr"} returns
   
       ERROR_OBJECT_NOT_FOUND - it returns ERROR_BAD_NUMBER if
       you specify a size of 0).  If the value would overflow
       the user buffer, the buffer is truncated.  The buffer
       returned is null-terminated (even if GVF_BINARY_VAR is
       used, unless GVF_DONT_NULL_TERM is in effect).  If it
       succeeds, len is the number of characters put in the buffer
       (not including null termination), and IoErr() will return the
       the size of the variable (regardless of buffer size).

   @{B}BUGS@{UB}
   @{FG SHINE}    LV_VAR is the only type that can be global.
       Under V36, we documented (and it returned) the size of the variable,
   not the number of characters transferred.  For V37 this was changed
   to the number of characters put in the buffer, and the total size
   of the variable is put in IoErr().
   GVF_DONT_NULL_TERM only works for local variables under V37.  For
   V39, it also works for globals.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" SetVar " LINK "ADosUnsafe.guide/setVar"}, @{" DeleteVar " LINK "ADosDanger.guide/deleteVar"}, 
       @{" FindVar " LINK "findVar"}, <dos/var.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getVarNamed: name into: aBuffer ofSize: size flags: flags @{FG TEXT}

@ENDNODE

@NODE "getPrompt" "getPrompt (SAFE):"

   @{B}NAME@{UB}
       GetPrompt -- Returns the prompt for the current process 

   @{B}SYNOPSIS@{UB}
       BOOL success = GetPrompt( char *buf, LONG len );

   @{B}FUNCTION@{UB}
       Extracts the prompt string from the CLI structure and puts it 
       into the buffer.  If the buffer is too small, the string is truncated 
   appropriately and a failure code returned.  If no CLI structure is 
   present, a null string is returned in the buffer, and failure from
   the call (with @{" IoErr() " LINK "ioErr"} == ERROR_OBJECT_WRONG_TYPE);

   @{B}INPUTS@{UB}
       buf     - Buffer to hold extracted prompt
       len     - Number of bytes of space in buffer

   @{B}SEE ALSO@{UB}
       @{" SetPrompt " LINK "setPrompt"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getPromptInto: aBuffer ofSize: length @{FG TEXT}

@ENDNODE

@NODE "getProgramName" "getProgramName (SAFE):"

   @{B}NAME@{UB}
       GetProgramName -- Returns the current program name 

   @{B}SYNOPSIS@{UB}
       BOOL success = GetProgramName( char *buf, LONG len )

   @{B}FUNCTION@{UB}
       Extracts the program name from the CLI structure and puts it 
       into the buffer.  If the buffer is too small, the name is truncated.
   If no CLI structure is present, a null string is returned in the
   buffer, and failure from the call (with @{" IoErr() " LINK "ioErr"} ==
   ERROR_OBJECT_WRONG_TYPE);

   @{B}INPUTS@{UB}
       buf     - Buffer to hold extracted name
       len     - Number of bytes of space in buffer

   @{B}SEE ALSO@{UB}
       @{" SetProgramName " LINK "ADosUnsafe.guide/setProgramName"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getProgramNameInto: aBuffer ofSize: length @{FG TEXT}

@ENDNODE

@NODE "getProgramDir" "getProgramDir (SAFE):"

   @{B}NAME@{UB}
       GetProgramDir -- Returns a lock on the directory the program was loaded
                        from 
   @{B}SYNOPSIS@{UB}
       BPTR lock = GetProgramDir( void )

   @{B}FUNCTION@{UB}
       Returns a shared lock on the directory the program was loaded from.
       This can be used for a program to find data files, etc, that are stored
   with the program, or to find the program file itself.  NULL returns are
   valid, and may occur, for example, when running a program from the
   resident list.  You should NOT unlock the lock.

   @{B}RESULT@{UB}
       lock - A lock on the directory the current program was loaded from,
              or NULL if loaded from resident list, etc.

   @{B}BUGS@{UB}
   @{FG SHINE}    Should return a lock for things loaded via resident.  
       Perhaps should return currentdir if NULL.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" SetProgramDir " LINK "ADosUnsafe.guide/setProgramDir"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getProgramDir @{FG TEXT}

@ENDNODE

@NODE "getFileSysTask" "getFileSysTask (SAFE):"

   @{B}NAME@{UB}
       GetFileSysTask -- Returns the default filesystem for the process 

   @{B}SYNOPSIS@{UB}
       struct MsgPort *port = GetFileSysTask( void )

   @{B}FUNCTION@{UB}
       Returns the default filesystem task's port (pr_FileSystemTask) for the
       current process.

   @{B}RESULT@{UB}
       port - The pr_MsgPort of the filesystem, or NULL.

   @{B}SEE ALSO@{UB}
       @{" SetFileSysTask " LINK "ADosDanger.guide/setFileSysTask"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getFileSysTask @{FG TEXT}

@ENDNODE

@NODE "getDeviceProc" "getDeviceProc (SAFE):"

   @{B}NAME@{UB}
       GetDeviceProc -- Finds a handler to send a message to 

   @{B}SYNOPSIS@{UB}
       struct DevProc *devproc = GetDeviceProc( char *name, struct DevProc *devproc );


   @{B}FUNCTION@{UB}
       Finds the handler/filesystem to send packets regarding 'name' to.
       This may involve getting temporary locks.  It returns a structure
   that includes a lock and msgport to send to to attempt your operation.
   It also includes information on how to handle multiple-directory
   assigns (by passing the DevProc back to GetDeviceProc() until it
   returns NULL).

   The initial call to GetDeviceProc() should pass NULL for devproc.  If
   after using the returned DevProc, you get an ERROR_OBJECT_NOT_FOUND,
   and (devproc->dvp_Flags & DVPF_ASSIGN) is true, you should call
   GetDeviceProc() again, passing it the devproc structure.  It will
   either return a modified devproc structure, or NULL (with
   ERROR_NO_MORE_ENTRIES in IoErr()).  Continue until it returns NULL.

   This call also increments the counter that locks a handler/fs into
   memory.  After calling FreeDeviceProc(), do not use the port or lock
   again!

   @{B}INPUTS@{UB}
       name    - name of the object you wish to access.  This can be a
                 relative path ("foo/bar"), relative to the current volume
                 (":foo/bar"), or relative to a device/volume/assign
                 ("foo:bar").
       devproc - A value returned by GetDeviceProc() before, or NULL

   @{B}RESULT@{UB}
       devproc - a pointer to a DevProc structure or NULL

   @{B}BUGS@{UB}
   @{FG SHINE}    Counter not currently active in 2.0.
    In 2.0 and 2.01, you HAD to check DVPF_ASSIGN before calling it again.
    This was fixed for the 2.02 release of V36.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FreeDeviceProc " LINK "ADosDanger.guide/freeDeviceProc"}, @{" DeviceProc " LINK "ADosDanger.guide/deviceProc"}, 
       @{" AssignLock " LINK "ADosUnsafe.guide/assignLock"}, @{" AssignLate " LINK "ADosUnsafe.guide/assignLate"},
       @{" AssignPath " LINK "ADosUnsafe.guide/assignPath"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getDeviceProc: name auxDevProc: devProc @{FG TEXT}

@ENDNODE

@NODE "getCurrentDirName" "getCurrentDirName (SAFE):"

   @{B}NAME@{UB}
       GetCurrentDirName -- returns the current directory name 

   @{B}SYNOPSIS@{UB}
       BOOL success = GetCurrentDirName( char *buf, LONG len );

   @{B}FUNCTION@{UB}
       Extracts the current directory name from the CLI structure and puts it 
       into the buffer.  If the buffer is too small, the name is truncated 
   appropriately and a failure code returned.  If no CLI structure is 
   present, a null string is returned in the buffer, and failure from
   the call (with @{" IoErr() " LINK "ioErr"} == ERROR_OBJECT_WRONG_TYPE);

   @{B}INPUTS@{UB}
       buf     - Buffer to hold extracted name
       len     - Number of bytes of space in buffer

   @{B}RESULT@{UB}
       success - Success/failure indicator

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, this routine didn't handle 0-length buffers correctly.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" SetCurrentDirName " LINK "ADosUnsafe.guide/setCurrentDirName"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getCurrentDirNameInto: aBuffer ofSize: length @{FG TEXT}

@ENDNODE

@NODE "getConsoleTask" "getConsoleTask (SAFE):"

   @{B}NAME@{UB}
       GetConsoleTask -- Returns the default console for the process 

   @{B}SYNOPSIS@{UB}
       struct MsgPort *port = GetConsoleTask( void );

   @{B}FUNCTION@{UB}
       Returns the default console task's port (pr_ConsoleTask) for the
       current process.

   @{B}RESULT@{UB}
       port - The pr_MsgPort of the console handler, or NULL.

   @{B}SEE ALSO@{UB}
       @{" SetConsoleTask " LINK "ADosDanger.guide/setConsoleTask"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getConsoleTask @{FG TEXT}

@ENDNODE

@NODE "getArgStr" "getArgStr (SAFE):"

   @{B}NAME@{UB}
       GetArgStr -- Returns the arguments for the process 

   @{B}SYNOPSIS@{UB}
       char *ptr = GetArgStr( void );

   @{B}FUNCTION@{UB}
       Returns a pointer to the (null-terminated) arguments for the program
       (process).  This is the same string passed in a0 on startup from CLI.

   @{B}RESULT@{UB}
       ptr - pointer to arguments

   @{B}SEE ALSO@{UB}
       @{" SetArgStr " LINK "ADosDanger.guide/setArgStr"}, @{" RunCommand " LINK "ADosDanger.guide/runCommand"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getArgStr @{FG TEXT}

@ENDNODE

@NODE "fPutS" "fPutS (SAFE):"

   @{B}NAME@{UB}
       FPuts -- Writes a string the the specified output (buffered) 

   @{B}SYNOPSIS@{UB}
       LONG error = FPuts( BPTR fh, char *str );

   @{B}FUNCTION@{UB}
       This routine writes an unformatted string to the filehandle.  No 
       newline is appended to the string.  This routine is buffered.

   @{B}INPUTS@{UB}
       fh    - filehandle to use for buffered I/O
       str   - Null-terminated string to be written to default output

   @{B}RESULT@{UB}
       error - 0 normally, otherwise -1.  Note that this is opposite of
               most other Dos functions, which return success.

   @{B}SEE ALSO@{UB}
       @{" FGets " LINK "fGets"}, @{" FPutC " LINK "fPutC"}, 
       @{" FWrite " LINK "ADosDanger.guide/fWrite"}, @{" PutStr " LINK "putStr"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   fPutS: aString to: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "fPutC" "fPutC (SAFE):"

   @{B}NAME@{UB}
       FPutC -- Write a character to the specified output (buffered)

   @{B}SYNOPSIS@{UB}
       LONG char = FPutC( BPTR fh, LONG chr );


   @{B}FUNCTION@{UB}
       Writes a single character to the output stream.  This call is
       buffered.  Use Flush() between buffered and unbuffered I/O on a
       filehandle.  Interactive filehandles are flushed automatically
       on a newline, return, @{B}0@{UB}, or line feed.

   @{B}INPUTS@{UB}
       fh   - filehandle to use for buffered I/O
       char - character to write

   @{B}RESULT@{UB}
       char - either the character written, or EOF for an error.

   @{B}BUGS@{UB}
   @{FG SHINE}    Older autodocs indicated that you should pass a UBYTE.  The
       correct usage is to pass a LONG in the range 0-255.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FGetC " LINK "fGetC"}, @{" UnGetC " LINK "unGetC"}, 
       @{" Flush " LINK "ADosUnsafe.guide/flushFH"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   fPutC: theChar to: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "findVar" "findVar (SAFE):"

   @{B}NAME@{UB}
       FindVar -- Finds a local variable 

   @{B}SYNOPSIS@{UB}
       struct LocalVar *var = FindVar( char *name, ULONG type ); 

   @{B}FUNCTION@{UB}
       Finds a local variable structure.

   @{B}INPUTS@{UB}
       name - pointer to an variable name.  Note variable names follow
              filesystem syntax and semantics.
   
       type - type of variable to be found (see <dos/var.h>)
 
   @{B}RESULT@{UB}
       var  - pointer to a LocalVar structure or NULL

   @{B}SEE ALSO@{UB}
       @{" GetVar " LINK "getVar"}, @{" SetVar " LINK "ADosUnsafe.guide/setVar"}, 
       @{" DeleteVar " LINK "ADosDanger.guide/deleteVar"}, <dos/var.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   findVar: varName ofType: type @{FG TEXT}

@ENDNODE

@NODE "findCliProc" "findCliProc (SAFE):"

   @{B}NAME@{UB}
       FindCliProc -- returns a pointer to the requested CLI process 

   @{B}SYNOPSIS@{UB}
       struct Process *proc = FindCliProc( ULONG num );

   @{B}FUNCTION@{UB}
       This routine returns a pointer to the CLI process associated with the 
       given CLI number.  If the process isn't an active CLI process, NULL is
       returned.  NOTE:  Should normally be called inside a Forbid(), if you
       must use this function at all.

   @{B}INPUTS@{UB}
       num  - Task number of CLI process (range 1-N)

   @{B}RESULT@{UB}
       proc - Pointer to given CLI process

   @{B}SEE ALSO@{UB}
       @{" Cli " LINK "cliPointer"}, Forbid, @{" MaxCli " LINK "maxCli"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   findCliProc: numbered @{FG TEXT}

@ENDNODE

@NODE "filePart" "filePart (SAFE):"

   @{B}NAME@{UB}
       FilePart -- Returns the last component of a path 

   @{B}SYNOPSIS@{UB}
       char *fileptr = FilePart( char *path );

   @{B}FUNCTION@{UB}
       This function returns a pointer to the last component of a string path
       specification, which will normally be the file name.  If there is only
       one component, it returns a pointer to the beginning of the string.

   @{B}INPUTS@{UB}
       path - pointer to an path string.  May be relative to the current
              directory or the current disk.

   @{B}RESULT@{UB}
       fileptr - pointer to the last component of the path.

   @{B}EXAMPLE@{UB}
       FilePart( "xxx:yyy/qqq" ) would return a pointer to the first @{B}q@{UB}.
       FilePart( "xxx:yyy"     ) would return a pointer to the first @{B}y@{UB}).

   @{B}SEE ALSO@{UB}
       @{" PathPart " LINK "pathPart"}, @{" AddPart " LINK "ADosUnsafe.guide/addPart"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getFilePart: pathAndFile  @{FG TEXT} " Tested "

@ENDNODE

@NODE "fGetS" "fGetS (SAFE):"

   @{B}NAME@{UB}
       FGets -- Reads a line from the specified input (buffered) 

   @{B}SYNOPSIS@{UB}
       char *buffer = FGets( BPTR fh, char *buf, ULONG len );

   @{B}FUNCTION@{UB}
       This routine reads in a single line from the specified input stopping
       at a NEWLINE character or EOF.  In either event, UP TO the number of
   len specified bytes minus 1 will be copied into the buffer.  Hence if
   a length of 50 is passed and the input line is longer than 49 bytes,
   it will return 49 characters.  It returns the buffer pointer normally,
   or NULL if EOF is the first thing read.

   If terminated by a newline, the newline WILL be the last character in
   the buffer.  This is a buffered read routine.  The string read in IS
   null-terminated.

   @{B}INPUTS@{UB}
       fh  - filehandle to use for buffered I/O
       buf - Area to read bytes into.
       len - Number of bytes to read, must be > 0.

   @{B}RESULT@{UB}
       buffer - Pointer to buffer passed in, or NULL for immediate EOF 
                or for an error.  If NULL is returnd for an EOF, 
                @{" IoErr() " LINK "ioErr"} will return 0.

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36 and V37, it copies one more byte than it should if it doesn't
    hit an EOF or newline.  In the example above, it would copy 50 bytes
    and put a null in the 51st.  This is fixed in dos V39.  Workaround
    for V36/V37: pass in buffersize-1.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FRead " LINK "ADosUnsafe.guide/fRead"}, @{" FPuts " LINK "fPuts"}, @{" FGetC " LINK "fGetC"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   fGets: fromBPTRFileHandle into: aBuffer ofSize: length using: flag @{FG TEXT}

      If flag is 0, then a newline will be left on the end of the
      returned String, a value of 1 will replace the last newline
      with a value of 0.

@ENDNODE

@NODE "fGetC" "fGetC (SAFE):"

   @{B}NAME@{UB}
       FGetC -- Read a character from the specified input (buffered) 

   @{B}SYNOPSIS@{UB}
       LONG char = FGetC( BPTR fh );

   @{B}FUNCTION@{UB}
       Reads the next character from the input stream.  A -1 is
       returned when EOF or an error is encountered.  This call is buffered.
       Use @{" Flush() " LINK "ADosUnsafe.guide/flushFH"} between buffered and unbuffered I/O on a filehandle.

   @{B}INPUTS@{UB}
       fh - filehandle to use for buffered I/O

   @{B}RESULT@{UB}
       char - character read (0-255) or -1

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, after an EOF was read, EOF would always be returned from
    FGetC() from then on.  Starting in V37, it tries to read from the
    handler again each time (unless UnGetC(fh,-1) was called).
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FPutC " LINK "fPutC"}, @{" UnGetC " LINK "unGetC"}, @{" Flush " LINK "ADosUnsafe.guide/flushFH"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   fGetC: fromBPTRFileHandle @{FG TEXT}

@ENDNODE

@NODE "fault" "fault (SAFE):"

   @{B}NAME@{UB}
       Fault -- Returns the text associated with a DOS error code 

   @{B}SYNOPSIS@{UB}
       LONG len = Fault( LONG code, char *header, char *buffer, LONG len );


   @{B}FUNCTION@{UB}
       This routine obtains the error message text for the given error code.
       The header is prepended to the text of the error message, followed
   by a colon.  Puts a null-terminated string for the error message into
   the buffer.  By convention, error messages should be no longer than 80
   characters (+1 for termination), and preferably no more than 60.
   The value returned by @{" IoErr() " LINK "ioErr"} is set to the code passed in.  If there
   is no message for the error code, the message will be "Error code
   <number>".

   The number of characters put into the buffer is returned, which will
   be 0 if the code passed in was 0.

   @{B}INPUTS@{UB}
       code   - Error code
       header - header to output before error text
       buffer - Buffer to receive error message.
       len    - Length of the buffer.

   @{B}RESULT@{UB}
       len    - number of characters put into buffer (may be 0)

   @{B}SEE ALSO@{UB}
       @{" IoErr " LINK "ioErr"}, @{" SetIoErr " LINK "setIoErr"}, 
       @{" PrintFault " LINK "printFault"}

   @{B}BUGS@{UB}
   @{FG SHINE}    In older documentation, the return was shown as BOOL success.
       This was incorrect, it has always returned the length.
   @{FG TEXT}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   fault: header code: c into: aBuffer ofSize: length @{FG TEXT}
@ENDNODE

@NODE "errReport" "ErrorReport (SAFE):"

   @{B}NAME@{UB}
       ErrorReport -- Displays a Retry/Cancel requester for an error 

   @{B}SYNOPSIS@{UB}
       BOOL status = ErrorReport( LONG code, LONG type, 
                                  ULONG arg1, struct MsgPort *device );

   @{B}FUNCTION@{UB}
       Based on the request type, this routine formats the appropriate
       requester to be displayed.  If the code is not understood, it returns
   DOS_TRUE immediately.  Returns DOS_TRUE if the user selects CANCEL or
   if the attempt to put up the requester fails, or if the process
   pr_WindowPtr is -1.  Returns FALSE if the user selects Retry.  The
   routine will retry on DISKINSERTED for appropriate error codes.
   These return values are the opposite of what AutoRequest returns.

   Note:  This routine sets @{" IoErr() " LINK "ioErr"} to code before returning.

   @{B}INPUTS@{UB}
       code   - Error code to put a requester up for.

          Current valid error codes are:

          ERROR_DISK_NOT_VALIDATED
          ERROR_DISK_WRITE_PROTECTED
          ERROR_DISK_FULL
          ERROR_DEVICE_NOT_MOUNTED
          ERROR_NOT_A_DOS_DISK
          ERROR_NO_DISK
          ABORT_DISK_ERROR   // read/write error
          ABORT_BUSY         // you MUST replace...

       type   - Request type:
             REPORT_LOCK   - arg1 is a lock (BPTR).
             REPORT_FH     - arg1 is a filehandle (BPTR).
             REPORT_VOLUME - arg1 is a volumenode (C pointer).
             REPORT_INSERT - arg1 is the string for the volumename

                (will be split on a ':').
                With ERROR_DEVICE_NOT_MOUNTED puts
                up the "Please insert..." requester.

       arg1   - variable parameter (see type)
       device - (Optional) Address of handler task for which report is to be 
                 made.  Only required for REPORT_LOCK, and only if arg1==NULL.

   @{B}RESULT@{UB}
       status - Cancel/Retry indicator (0 means Retry)

   @{B}SEE ALSO@{UB}
       @{" Fault " LINK "fault"}, @{" IoErr " LINK "ioErr"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   errorReport: code type: t arg1: a1 fromDevicePort: msgPort @{FG TEXT}

@ENDNODE

@NODE "endNotify" "endNotify (SAFE):"

   @{B}NAME@{UB}
       EndNotify -- Ends a notification request 

   @{B}SYNOPSIS@{UB}
       void EndNotify( struct NotifyRequest *notifystructure );

   @{B}FUNCTION@{UB}
       Removes a notification request.  Safe to call even if @{" StartNotify() " LINK "ADosUnsafe.guide/startNotify"}
       failed.  For NRF_SEND_MESSAGE, it searches your port for any messages
       about the object in question and removes and replies them before
       returning.

   @{B}INPUTS@{UB}
       notifystructure - a structure passed to StartNotify()

   @{B}SEE ALSO@{UB}
       @{" StartNotify " LINK "ADosUnsafe.guide/startNotify"}, <dos/notify.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   endNotify: notifyRequest @{FG TEXT}

@ENDNODE

@NODE "delay" "delay (SAFE):"

   @{B}NAME@{UB}
       Delay -- Delay a process for a specified time

   @{B}SYNOPSIS@{UB}
       void Delay( ULONG ticks );

   @{B}FUNCTION@{UB}
       The argument 'ticks' specifies how many ticks (50 per second) to
       wait before returning control.

   @{B}INPUTS@{UB}
       ticks - integer

   @{B}BUGS@{UB}
   @{FG SHINE}    Due to a bug in the timer.device in V1.2/V1.3, specifying a 
       timeout of zero for Delay() can cause the unreliable timer & floppy 
       disk operation.  This is fixed in V36 and later.
   @{FG TEXT}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   delay: ticks @{FG TEXT}

@ENDNODE

@NODE "dateToStr" "dateToStr (SAFE):"

   @{B}NAME@{UB}
       DateToStr -- Converts a DateStamp to a string 

   @{B}SYNOPSIS@{UB}
       BOOL success = DateToStr( struct DateTime *datetime );

   @{B}FUNCTION@{UB}
       DateToStr converts an AmigaDOS DateStamp to a human
       readable ASCII string as requested by your settings in the
       DateTime structure.

   @{B}INPUTS@{UB}
       DateTime - a pointer to an initialized DateTime structure.

       The DateTime structure should be initialized as follows:

       dat_Stamp - a copy of the datestamp you wish to convert to
                   ascii.

       dat_Format - a format byte which specifies the format of the
            dat_StrDate.  This can be any of the following
            (note: If value used is something other than those
            below, the default of   FORMAT_DOS is used):
   
            FORMAT_DOS:     AmigaDOS format (dd-mmm-yy).
   
            FORMAT_INT:     International   format (yy-mmm-dd).
   
            FORMAT_USA:     American format (mm-dd-yy).
   
            FORMAT_CDN:     Canadian format (dd-mm-yy).
   
            FORMAT_DEF:     default format for locale.

       dat_Flags - a flags byte.  The only flag which affects this
                   function is:

         DTF_SUBST:  If set, a string such as Today,
                     Monday, etc., will be used instead
                     of the dat_Format specification if
                     possible.
         DTF_FUTURE: Ignored by this function.

       dat_StrDay - pointer to a buffer to receive the day of the
                    week string.  (Monday, Tuesday, etc.). If 
                    null, this string will not be generated.

       dat_StrDate - pointer to a buffer to receive the date
                     string, in the format requested by dat_Format,
                     subject to possible modifications by DTF_SUBST.  
                     If null, this string will not be generated.

       dat_StrTime - pointer to a buffer to receive the time of day
                     string. If NULL, this will not be generated.

   @{B}RESULT@{UB}
       success - a zero return indicates that the DateStamp was
                 invalid, and could not be converted.  Non-zero
                 indicates that the call succeeded.
      
   @{B}SEE ALSO@{UB}
       @{" DateStamp " LINK "ADosUnsafe.guide/dateStamp"}, @{" StrtoDate " LINK "strToDate"}, 
       <dos/datetime.h>
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   dateToStr: dateTime @{FG TEXT}

@ENDNODE

@NODE "currentDir" "currentDir (SAFE):"

   @{B}NAME@{UB}
       CurrentDir -- Make a directory lock the current directory

   @{B}SYNOPSIS@{UB}
       BPTR oldLock = CurrentDir( BPTR lock );

   @{B}FUNCTION@{UB}
       CurrentDir() causes a directory associated with a lock to be made
       the current directory.   The old current directory lock is returned.

   A value of zero is a valid result here, this 0 lock represents the
   root of file system that you booted from.

   Any call that has to Open() or Lock() files (etc) requires that
   the current directory be a valid lock or 0.

   @{B}INPUTS@{UB}
       lock - BCPL pointer to a lock

   @{B}RESULT@{UB}
       oldLock - BCPL pointer to a lock

   @{B}SEE ALSO@{UB}
       @{" Lock " LINK "ADosUnsafe.guide/lock"}, @{" UnLock " LINK "ADosUnsafe.guide/unLock"}, 
       @{" Open " LINK "ADosUnsafe.guide/openFile"}, @{" DupLock " LINK "ADosUnsafe.guide/dupLock"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   currentDir: fromBPTRLock @{FG TEXT}

@ENDNODE

@NODE "compareDates" "compareDates (SAFE):"

   @{B}NAME@{UB}
       CompareDates -- Compares two datestamps 

   @{B}SYNOPSIS@{UB}
       LONG result = CompareDates( struct DateStamp *date1,
                                   struct DateStamp *date2 );

   @{B}FUNCTION@{UB}
       Compares two times for relative magnitide.  < 0 is returned if date1 is
       later than date2, 0 if they are equal, or > 0 if date2 is later than
       date1.  NOTE:  This is NOT the same ordering as strcmp!

   @{B}INPUTS@{UB}
       date1, date2 - DateStamps to compare

   @{B}RESULT@{UB}
       result -  <0, 0, or >0 based on comparison of two date stamps

   @{B}SEE ALSO@{UB}
       @{" DateStamp " LINK "ADosUnsafe.guide/dateStamp"}, @{" DateToStr " LINK "dateToStr"}, 
       @{" StrToDate " LINK "strToDate"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   compareDates: dateStamp1 and: dateStamp2 @{FG TEXT}

@ENDNODE

@NODE "cliPointer" "cliPointer (SAFE):"

   @{B}NAME@{UB}
       Cli -- Returns a pointer to the CLI structure of the process 

   @{B}SYNOPSIS@{UB}
       struct CommandLineInterface *cli_ptr = Cli( void );

   @{B}FUNCTION@{UB}
       Returns a pointer to the CLI structure of the current process, or NULL
       if the process has no CLI structure.

   @{B}RESULT@{UB}
       cli_ptr - pointer to the CLI structure, or NULL.
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   getCLIObject @{FG TEXT}
@ENDNODE

@NODE "addBuffers" "addBuffers (SAFE):"

   @{B}NAME@{UB}
       AddBuffers -- Changes the number of buffers for a filesystem 

   @{B}SYNOPSIS@{UB}
       BOOL success = AddBuffers( char *filesystem, LONG number );

   @{B}FUNCTION@{UB}
       Adds buffers to a filesystem.  If it succeeds, the number of current
       buffers is returned in @{" IoErr() " LINK "ioErr"}.  Note that "number" may be negative.
   The amount of memory used per buffer, and any limits on the number of
   buffers, are dependant on the filesystem in question.
   If the call succeeds, the number of buffers in use on the filesystem
   will be returned by IoErr().

   @{B}INPUTS@{UB}
       filesystem - Name of device to add buffers to (with ':').
       number     - Number of buffers to add.  May be negative.

   @{B}RESULT@{UB}
       success    - Success or failure of command.

   @{B}BUGS@{UB}
   @{FG SHINE}    The V36 ROM filesystem (FFS/OFS) doesn't return the right number of
    buffers unless preceded by an AddBuffers(fs,-1) (in-use buffers aren't
    counted).  This is fixed in V37.

    The V37 and before ROM filesystem doesn't return success, it returns
    the number of buffers.  The best way to test for this is to consider
    0 (FALSE) failure, -1 (DOSTRUE) to mean that IoErr() will have the
    number of buffers, and any other positive value to be the number of
    buffers.  It may be fixed in some future ROM revision.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" IoErr " LINK "ioErr"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   addBuffers: howMany toFileDevice: diskDrive @{FG TEXT}

@ENDNODE

@NODE "AbortPacket" "AbortPacket (SAFE):"

   @{B}NAME@{UB}
       AbortPkt -- Aborts an asynchronous packet, if possible. 

   @{B}FUNCTION@{UB}
       This attempts to abort a packet sent earlier with @{" SendPkt " LINK "ADosDanger.guide/sendPkt"} to a
       handler.  There is no guarantee that any given handler will allow
   a packet to be aborted, or if it is aborted whether function
   requested completed first or completely.  After calling AbortPkt(),
   you must wait for the packet to return before reusing it or
   deallocating it.

   @{B}INPUTS@{UB}
       port - port the packet was sent to
       pkt  - the packet you wish aborted

   @{B}BUGS@{UB}
   @{FG SHINE}    As of V37, this function does nothing.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" SendPkt " LINK "ADosDanger.guide/sendPkt"}, @{" DoPkt " LINK "ADosDanger.guide/doPacket"}, 
       @{" WaitPkt " LINK "ADosDanger.guide/waitPkt"}
   @{B}
   AMIGATALK INTERFACE (SafeDOS Class): @{UB}
   @{FG SHINE}
   abortPacket: dosPacket onMsgPort: msgPort @{FG TEXT}
@ENDNODE
