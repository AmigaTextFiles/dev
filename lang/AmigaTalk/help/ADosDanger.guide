@DATABASE ADosDanger.guide

@COPYRIGHT (C) 2002 by J.T. Steichen

@REM $VER: AmigaTalk:Help/ADosDanger.guide 2.1 (22-Mar-2002) by J.T. Steichen

@REM Generated with RoboDoc v3.0j (May 24 1999)
@REM RoboDoc is copyright 1994-1997 by Maverick Software Development

@INDEX "Main"
@TOC   "Main"

@NODE "Main" "AmigaTalk to AmigaDOS Help:"
@{FG SHINE}
   WARNING:  Improper usage of these Methods will (at the bare
             minimum), result in the Operating System hanging
             up, which could result in loss of data.  This is
             the least of what could happen!  Turn back now! @{FG TEXT}
   @{FG SHINE}  
   DANGEROUS AmigaDOS Functions/AmigaTalk Methods: @{FG TEXT}

   @{"writeFile         " Link "writeFile"}
   @{"setVBuf           " Link "setVBuf"}
   @{"setFileSize       " Link "setFileSize"}
   @{"setArgStr         " Link "setArgStr"}
   @{"selectOutput      " Link "selectOutput"}
   @{"selectInput       " Link "selectInput"}
   @{"seekFile          " Link "seekFile"}
   @{"runCommand        " Link "runCommand"}
   @{"replyPkt          " Link "replyPkt"}
   @{"inhibit           " Link "inhibit"}
   @{"fWrite            " Link "fWrite"}
   @{"freeDosObject     " Link "freeDosObject"}
   @{"freeDosEntry      " Link "freeDosEntry"}
   @{"freeDeviceProc    " Link "freeDeviceProc"}
   @{"freeArgs          " Link "freeArgs"}
   @{"exitProgram       " Link "exitProgram"} -- Avoid like the plague!
   @{"deviceProc        " Link "deviceProc"}
   @{"deleteVar         " Link "deleteVar"}
   @{"createNewProc     " Link "createNewProc"}
   @{"cliInitRun        " Link "cliInitRun"}
   @{"cliInitNewcli     " Link "cliInitNewcli"}
   @{"attemptLockDosList" Link "attemptLockDosList"}
   @{"allocDosObject    " Link "allocDosObject"}
   @{"addDosEntry       " Link "addDosEntry"}

   See Also, @{" VERY DANGEROUS METHODS " LINK "VeryDangerousFunctions"}
@ENDNODE

@NODE "VeryDangerousFunctions" "VERY DANGEROUS AmigaDOS Methods:"
@{FG SHINE}
   WARNING:  Improper usage of these Methods will (at the bare
             minimum), result in the Operating System hanging
             up, which could result in loss of data.  This is
             the least of what could happen!  Turn back now! @{FG TEXT}
   @{FG SHINE}
   VERY DANGEROUS AmigaDOS Functions/AmigaTalk Methods: @{FG TEXT}

   @{"waitPkt           " Link "waitPkt"}
   @{"unLoadSeg         " Link "unLoadSeg"}
   @{"systemTagList     " Link "systemTagList"}
   @{"setFileSysTask    " Link "setFileSysTask"}
   @{"setConsoleTask    " Link "setConsoleTask"}
   @{"sendPkt           " Link "sendPkt"}
   @{"remSegment        " Link "remSegment"}
   @{"remDosEntry       " Link "remDosEntry"}
   @{"remAssignList     " Link "remAssignList"}
   @{"newLoadSeg        " Link "newLoadSeg"}
   @{"loadSeg           " Link "loadSeg"}
   @{"internalUnLoadSeg " Link "internalUnLoadSeg"}
   @{"internalLoadSeg   " Link "internalLoadSeg"}
   @{"format            " Link "format"} -- Are you out of your tree??
   @{"doPacket          " Link "doPacket"}
   @{"deleteFile        " Link "deleteFile"}
   @{"addSegment        " Link "addSegment"}

@ENDNODE

@NODE "writeFile" "writeFile (DANGEROUS):"
   @{B}NAME@{UB}
      Write -- Write bytes of data to a file

   @{B}SYNOPSIS@{UB}
      LONG returnedLength =  Write( BPTR file, void *buffer, LONG length );
   @{B}
   FUNCTION@{UB}
      Write writes bytes of data to the opened file 'file'. 'length'
      indicates the length of data to be transferred; 'buffer' is a
      pointer to the buffer. The value returned is the length of
      information actually written. So, when 'length' is greater than
      zero, the value of 'length' is the number of characters written.
      Errors are indicated by a value of -1.

      Note:  This is an unbuffered routine (the request is passed directly
      to the filesystem.)  Buffered I/O is more efficient for small
      reads and writes; see FPutC.

   @{B}INPUTS@{UB}
      file   - BCPL pointer to a file handle
      buffer - pointer to the buffer
      length - integer

   @{B}RESULT@{UB}
      returnedLength - integer

   @{B}SEE ALSO@{UB}
      @{" Read  " LINK "ADosSafe.guide/readFile"}, @{" Seek  " LINK "seekFile"},
      @{" Open  " LINK "ADosUnsafe.guide/openFile"}, @{" Close " LINK "ADosUnsafe.guide/closeFile"}, 
      @{" FPutC " LINK "ADosSafe.guide/fPutC"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
     @{FG SHINE}
   writeFile: bptrFileHandle with: aBuffer ofSize: length @{FG TEXT}

   @{B}WARNING:  Make sure that @{I}aBuffer@{UI} is a String of @{I}length@{UI} bytes!@{UB} 
@ENDNODE

@NODE "waitPkt" "waitPkt (VERY DANGEROUS):"

   @{B}NAME@{UB}
       WaitPkt -- Waits for a packet to arrive at your pr_MsgPort

   @{B}SYNOPSIS@{UB}
       struct DosPacket *packet = WaitPkt( void );


   @{B}FUNCTION@{UB}
       Waits for a packet to arrive at your pr_MsgPort.  If anyone has
       installed a packet wait function in pr_PktWait, it will be called.
       The message will be automatically GetMsg()ed so that it is no longer
       on the port.  It assumes the message is a dos packet.  It is NOT
       guaranteed to clear the signal for the port.

   @{B}RESULT@{UB}
       packet - the packet that arrived at the port (from ln_Name of message).

   @{B}SEE ALSO@{UB}
       @{" SendPkt " LINK "sendPkt"}, @{" DoPkt " LINK "doPacket"}, @{" AbortPkt " LINK "ADosSafe.guide/abortPacket"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   waitForPacket @{FG TEXT}
    
@ENDNODE

@NODE "unLoadSeg" "unLoadSeg (VERY DANGEROUS):"

   @{B}NAME@{UB}
       UnLoadSeg -- Unload a seglist previously loaded by LoadSeg

   @{B}SYNOPSIS@{UB}
       void UnLoadSeg( BPTR seglist );

   @{B}FUNCTION@{UB}
       Unload a seglist loaded by LoadSeg.  'seglist' may be zero.
       Overlaid segments will have all needed cleanup done, including
       closing files.

   @{B}INPUTS@{UB}
       seglist - BCPL pointer to a segment identifier

   @{B}SEE ALSO@{UB}
       @{" LoadSeg " LINK "loadSeg"}, @{" InternalLoadSeg " LINK "internalLoadSeg"}, 
       @{" InternalUnLoadSeg " LINK "internalUnloadSeg"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   unLoadSegment: bptrSegList @{FG TEXT}

@ENDNODE

@NODE "systemTagList" "systemTagList (VERY DANGEROUS):"

   @{B}NAME@{UB}
       SystemTagList -- Have a shell execute a command line

   @{B}SYNOPSIS@{UB}
       LONG error = SystemTagList( char *command, struct TagItem *tags );


   @{B}FUNCTION@{UB}
       Similar to Execute(), but does not read commands from the input
       filehandle.  Spawns a Shell process to execute the command, and
       returns the returncode the command produced, or -1 if the command
       could not be run for any reason.  The input and output filehandles
       will not be closed by System, you must close them (if needed) after
       System returns, if you specified them via SYS_Input or SYS_Output.
 
    By default the new process will use your current Input() and Output()
    filehandles.  Normal Shell command-line parsing will be done
    including redirection on 'command'.  The current directory and path
    will be inherited from your process.  Your path will be used to find
    the command (if no path is specified).
 
    Note that you may NOT pass the same filehandle for both SYS_Input
    and SYS_Output.  If you want input and output to both be to the same
    CON: window, pass a SYS_Input of a filehandle on the CON: window,
    and pass a SYS_Output of NULL.  The shell will automatically set
    the default Output() stream to the window you passed via SYS_Input,
    by opening "*" on that handler.
 
    If used with the SYS_Asynch flag, it WILL close both it's input and
    output filehandles after running the command (even if these were
    your Input() and Output()!)
 
    Normally uses the boot (ROM) shell, but other shells can be specified
    via SYS_UserShell and SYS_CustomShell.  Normally, you should send
    things written by the user to the UserShell.  The UserShell defaults
    to the same shell as the boot shell.
 
    The tags are passed through to CreateNewProc() (tags that conflict
    with SystemTagList() will be filtered out).  This allows setting
    things like priority, etc for the new process.  The tags that are
    currently filtered out are:
 
       NP_Seglist,     NP_FreeSeglist, NP_Entry
       NP_Input,       NP_Output,      NP_CloseInput
       NP_CloseOutput, NP_HomeDir,     NP_Cli

    @{B}INPUTS@{UB}
       command - Program and arguments
       tags    - see <dos/dostags.h>.  Note that both SystemTagList()-
                 specific tags and tags from CreateNewProc() may be passed.

    @{B}RESULT@{UB}
    error - 0 for success, result from command, or -1.  Note that on
            error, the caller is responsible for any filehandles or other
    things passed in via tags.  -1 will only be returned if
    dos could not create the new shell.  If the command is not
    found the shell will return an error value, normally RETURN_ERROR.


   @{B}SEE ALSO@{UB}
      @{" Execute " LINK "ADosUnsafe.guide/execute"}, @{" CreateNewProc " LINK "createNewProc"},
      @{" Input   " LINK "ADosUnsafe.guide/input"}, @{" Output " LINK "ADosUnsafe.guide/output"},
      <dos/dostags.h>
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   systemCommandTagList: commandString: tags: tagArray @{FG TEXT}

@ENDNODE

@NODE "setVBuf" "setVBuf (DANGEROUS):"

   @{B}NAME@{UB}
       SetVBuf -- set buffering modes and size

   @{B}SYNOPSIS@{UB}
       LONG error = SetVBuf( BPTR fh, char *buff, LONG type, LONG size );

   @{B}FUNCTION@{UB}
       Changes the buffering modes and buffer size for a filehandle.
       With buff == NULL, the current buffer will be deallocated and a
       new one of (approximately) size will be allocated.  If buffer is
       non-NULL, it will be used for buffering and must be at least
       max( size, 208 ) bytes long, and MUST be longword aligned.  If size
       is -1, then only the buffering mode will be changed.
 
   Note that a user-supplied buffer will not be freed if it is later
   replaced by another SetVBuf() call, nor will it be freed if the
   filehandle is closed.
 
   Has no effect on the buffersize of filehandles that were not created
   by @{" AllocDosObject() " LINK "allocDosObject"}.

   @{B}INPUTS@{UB}
       fh   - Filehandle
       buff - buffer pointer for buffered I/O or NULL.  MUST be LONG-aligned!
       type - buffering mode (see <dos/stdio.h>)
       size - size of buffer for buffered I/O (sizes less than 208 bytes
              will be rounded up to 208), or -1.

   @{B}RESULT@{UB}
       error - 0 if successful.  NOTE: opposite of most dos functions!
   
       NOTE:  fails if someone has replaced the buffer without using SetVBuf() 
              - RunCommand() does this.  Remember to check error before 
              freeing user-supplied buffers!
 
   @{B}BUGS@{UB} 
   @{FG SHINE}    Not implemented until after V39.  From V36 up to V39, always
       returned 0.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FputC  " LINK "ADosSafe.guide/fPutC"}, @{" FGetC " LINK "ADosSafe.guide/fGetC"}, 
       @{" UnGetC " LINK "ADosSafe.guide/unGetC"}, @{" Flush " LINK "ADosUnsafe.guide/flushFH"}, 
       @{" FRead  " LINK "ADosUnsafe.guide/fRead"}, @{" FWrite " LINK "fWrite"}, 
       @{" FGets  " LINK "ADosSafe.guide/fGetS"}, @{" FPuts " LINK "ADosSafe.guide/fPutS"}, 
       @{" AllocDosObject " LINK "allocDosObject"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
     @{FG SHINE}
   setVBuf: bptrFileHandle to: aBuffer type: t bufferSize: size @{FG TEXT}

@ENDNODE

@NODE "setFileSysTask" "setFileSysTask (VERY DANGEROUS):"

   @{B}NAME@{UB}
       SetFileSysTask -- Sets the default filesystem for the process

   @{B}SYNOPSIS@{UB}
       struct MsgPort *oldport = SetFileSysTask( struct MsgPort *port );

   @{B}FUNCTION@{UB}
       Sets the default filesystem task's port (pr_FileSystemTask) for the
       current process.

   @{B}INPUTS@{UB}
       port - The pr_MsgPort of the default filesystem for the process

   @{B}RESULT@{UB}
       oldport - The previous FileSysTask value

   @{B}SEE ALSO@{UB}
       @{" GetFileSysTask " LINK "ADosSafe.guide/getFileSysTask"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   setFileSystemTask: msgPort @{FG TEXT}

@ENDNODE

@NODE "setFileSize" "setFileSize (DANGEROUS):"

   @{B}NAME@{UB}
       SetFileSize -- Sets the size of a file

   @{B}SYNOPSIS@{UB}
       LONG newsize = SetFileSize( BPTR fh, LONG offset, LONG mode );

   @{B}FUNCTION@{UB}
       Changes the file size, truncating or extending as needed.  Not all
       handlers may support this; be careful and check the return code.  If
    the file is extended, no values should be assumed for the new bytes.
    If the new position would be before the filehandle's current position
    in the file, the filehandle will end with a position at the
    end-of-file.  If there are other filehandles open onto the file, the
    new size will not leave any filehandle pointing past the end-of-file.
    You can check for this by looking at the new size (which would be
    different than what you requested).
 
    The seek position should not be changed unless the file is made
    smaller than the current seek position.  However, see BUGS.
 
    Do NOT count on any specific values to be in any extended area.

    @{B}INPUTS@{UB}
       fh     - File to be truncated/extended.
       offset - Offset from position determined by mode.
       mode   - One of OFFSET_BEGINNING, OFFSET_CURRENT, or OFFSET_END.

    @{B}RESULT@{UB}
       newsize - position of new end-of-file or -1 for error.

    @{B}BUGS@{UB}
    @{FG SHINE}   The RAM: filesystem and the normal Amiga filesystem act differently
       in where the file position is left after SetFileSize().  RAM: leaves
    you at the new end of the file (incorrectly), while the Amiga ROM
    filesystem leaves the seek position alone, unless the new position
    is less than the current position, in which case you're left at the
    new EOF.
 
    The best workaround is to not make any assumptions about the seek
    position after SetFileSize().   
    @{FG TEXT}
    @{B}SEE ALSO@{UB}
       @{" Seek " LINK "seekFile"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   setFileSize: bptrFileHandle at: offset mode: mode @{FG TEXT}

@ENDNODE

@NODE "setConsoleTask" "setConsoleTask (VERY DANGEROUS):"

   @{B}NAME@{UB}
       SetConsoleTask -- Sets the default console for the process

   @{B}SYNOPSIS@{UB}
       struct MsgPort *oldport = SetConsoleTask( struct MsgPort *port );

   @{B}FUNCTION@{UB}
       Sets the default console task's port (pr_ConsoleTask) for the
       current process.

   @{B}INPUTS@{UB}
       port - The pr_MsgPort of the default console handler for the process

   @{B}RESULT@{UB}
       oldport - The previous ConsoleTask value.

   @{B}SEE ALSO@{UB}
       @{" GetConsoleTask " LINK "ADosSafe.guide/getConsoleTask"}, @{" Open " LINK "ADosUnsafe.guide/openFile"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   setConsoleTask: msgPort @{FG TEXT}

@ENDNODE

@NODE "setArgStr" "setArgStr (DANGEROUS):"

   @{B}NAME@{UB}
       SetArgStr -- Sets the arguments for the current process

   @{B}SYNOPSIS@{UB}
       BOOL success = SetArgStr( char *ptr );

   @{B}FUNCTION@{UB}
       Sets the arguments for the current program.  The ptr MUST be reset
       to it's original value before process exit.  So save the original 
       ptr BEFORE calling this funcion!

   @{B}INPUTS@{UB}
       ptr - pointer to new argument string.

   @{B}RESULT@{UB}
       success (DOSTRUE) or failure (FALSE).

   @{B}SEE ALSO@{UB}
       @{" GetArgStr " LINK "ADosSafe.guide/getArgStr"}, @{" RunCommand " LINK "runCommand"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   setArgumentString: argString @{FG TEXT}

@ENDNODE

@NODE "sendPkt" "sendPkt (VERY DANGEROUS):"

   @{B}NAME@{UB}
       SendPkt -- Sends a packet to a handler

   @{B}SYNOPSIS@{UB}
       void SendPkt( struct DosPacket *packet, 
                     struct MsgPort   *port,
                     struct MsgPort   *replyport );

   @{B}FUNCTION@{UB}
       Sends a packet to a handler and does not wait.  All fields in the
       packet must be initialized before calling this routine.  The packet
       will be returned to replyport.  If you wish to use this with
       @{" WaitPkt() " LINK "waitPkt"}, use the address of your pr_MsgPort for replyport.

   @{B}INPUTS@{UB}
       packet    - packet to send, must be initialized and have a message.
       port      - pr_MsgPort of handler process to send to.
       replyport - MsgPort for the packet to come back to.

   @{B}NOTES@{UB}
   @{B}@{FG SHINE}    Callable from a task.
   @{FG TEXT}@{UB}
   @{B}SEE ALSO@{UB}
       @{" DoPkt " LINK "doPacket"}, @{" WaitPkt " LINK "waitPkt"}, 
       @{" AllocDosObject " LINK "allocDosObject"}, @{" FreeDosObject " LINK "freeDosObject"}, 
       @{" AbortPkt " LINK "ADosSafe.guide/abortPacket"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   sendPacket: dosPacket to: msgPort replyTo: replyPort @{FG TEXT}

@ENDNODE

@NODE "selectOutput" "selectOutput (DANGEROUS):"

   @{B}NAME@{UB}
       SelectOutput -- Select a filehandle as the default output channel

   @{B}SYNOPSIS@{UB}
       BPTR old_fh = SelectOutput( BPTR fh );

   @{B}FUNCTION@{UB}
       Set the current output as the default output for the process.
       This changes the value returned by Output().  old_fh should
       be closed or saved as needed.

   @{B}INPUTS@{UB}
       fh - Newly desired output handle

   @{B}RESULT@{UB}
       old_fh - Previous current output

   @{B}SEE ALSO@{UB}
       @{" Output " LINK "ADosUnsafe.guide/output"}, @{" SelectInput " LINK "selectInput"}, 
       @{" Input  " LINK "ADosUnsafe.guide/input"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   selectOutput: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "selectInput" "selectInput (DANGEROUS):"

   @{B}NAME@{UB}
       SelectInput -- Select a filehandle as the default input channel

   @{B}SYNOPSIS@{UB}
       BPTR old_fh = SelectInput( BPTR fh );

   @{B}FUNCTION@{UB}
       Set the current input as the default input for the process.
       This changes the value returned by Input().  old_fh should
       be closed or saved as needed.

   @{B}INPUTS@{UB}
       fh     - Newly default input handle

   @{B}RESULT@{UB}
       old_fh - Previous default input filehandle

   @{B}SEE ALSO@{UB}
       @{" Input  " LINK "ADosUnsafe.guide/input"}, @{" SelectOutput " LINK "selectOutput"}, 
       @{" Output " LINK "ADosUnsafe.guide/output"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   selectInput: bptrFileHandle @{FG TEXT}

@ENDNODE

@NODE "seekFile" "seekFile (DANGEROUS):"

   @{B}NAME@{UB}
       Seek -- Set the current position for reading and writing

   @{B}SYNOPSIS@{UB}
       LONG oldPosition = Seek( BPTR file, LONG position, LONG mode );

   @{B}FUNCTION@{UB}
       Seek sets the read/write cursor for the file 'file' to the
       position 'position'. This position is used by both Read() and
    Write() as a place to start reading or writing. The result is the
    current absolute position in the file, or -1 if an error occurs, in
    which case IoErr() can be used to find more information. 'mode' can
    be OFFSET_BEGINNING, OFFSET_CURRENT or OFFSET_END. It is used to
    specify the relative start position. For example, 20 from current
    is a position 20 bytes forward from current, -20 is 20 bytes back
    from current.
 
    So that to find out where you are, seek zero from current. The end
    of the file is a Seek() positioned by zero from end. You cannot
    Seek() beyond the end of a file.

   @{B}INPUTS@{UB}
       file     - BCPL pointer to a file handle
       position - integer
       mode     - integer

   @{B}RESULT@{UB}
       oldPosition - integer

   @{B}BUGS@{UB}
   @{FG SHINE}    The V36 and V37 ROM filesystem (and V36/V37 l:fastfilesystem)
       returns the current position instead of -1 on an error.  It sets
   IoErr() to 0 on success, and an error code on an error.  This bug
   was fixed in the V39 filesystem.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" Read " LINK "ADosSafe.guide/readFile"}, @{" Write " LINK "writeFile"}, 
       @{" SetFileSize " LINK "setFileSize"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   seek: bptrFileHandle to: position mode: mode @{FG TEXT}

@ENDNODE

@NODE "runCommand" "runCommand (DANGEROUS):"

   @{B}NAME@{UB}
       RunCommand -- Runs a program using the current process

   @{B}SYNOPSIS@{UB}
       LONG rc = RunCommand( BPTR seglist, ULONG stacksize,
                             char *argptr, ULONG argsize );

   @{B}FUNCTION@{UB}
       Runs a command on your process/cli.  Seglist may be any language,
       including BCPL programs.  Stacksize is in bytes.  argptr is a null-
   terminated string, argsize is its length.  Returns the returncode the
   program exited with in d0. Returns -1 if the stack couldn't be
   allocated.
 
   NOTE:  The argument string MUST be terminated with a newline to work
   properly with ReadArgs() and other argument parsers.
 
   RunCommand also takes care of setting up the current input filehandle
   in such a way that ReadArgs() can be used in the program, and restores
   the state of the buffering before returning.  It also sets the value
   returned by GetArgStr(), and restores it before returning.  NOTE:
   the setting of the argument string in the filehandle was added in V37.
 
   It's usually appropriate to set the command name (via
   @{" SetProgramName() " LINK "ADosUnsafe.guide/setProgramName"}) before calling RunCommand().  RunCommand() sets
   the value returned by @{" GetArgStr() " LINK "ADosSafe.guide/getArgStr"} while the command is running.
 
   @{B}INPUTS@{UB}
       seglist   - Seglist of command to run.
       stacksize - Number of bytes to allocate for stack space
       argptr    - Pointer to argument command string.
       argsize   - Number of bytes in argument command.

   @{B}RESULT@{UB}
       rc        - Return code from executed command. -1 indicates failure 

   @{B}SEE ALSO@{UB}
       @{" CreateNewProc " LINK "createNewProc"}, @{" SystemTagList " LINK "systemTagList"}, 
       @{" Execute " LINK "ADosUnsafe.guide/execute"}, @{" GetArgStr " LINK "ADosSafe.guide/getArgStr"},
       @{" SetProgramName " LINK "ADosUnsafe.guide/setProgramName"}, @{" ReadArgs " LINK "ADosSafe.guide/readArgs"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   runCommand: bptrSegmentList args: argString count: argSize stack: stackSize @{FG TEXT}

@ENDNODE

@NODE "replyPkt" "replyPkt (DANGEROUS):"

   @{B}NAME@{UB}
       ReplyPkt -- replies a packet to the person who sent it to you

   @{B}SYNOPSIS@{UB}
       void ReplyPkt( struct DosPacket *packet, LONG result1, LONG result2 );

   @{B}FUNCTION@{UB}
       This returns a packet to the process which sent it to you.  In
       addition, puts your pr_MsgPort address in dp_Port, so using ReplyPkt()
   again will send the message to you.  (This is used in "ping-ponging"
   packets between two processes).  It uses result 1 & 2 to set the
   dp_Res1 and dp_Res2 fields of the packet.

   @{B}INPUTS@{UB}
       packet  - packet to reply, assumed to set up correctly.
       result1 - first result
       result2 - secondary result

   @{B}SEE ALSO@{UB}
       @{" DoPkt " LINK "doPacket"}, @{" SendPkt " LINK "sendPkt"}, 
       @{" WaitPkt " LINK "waitPkt"}, @{" IoErr " LINK "ADosSafe.guide/setIoErr"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   replyPacket: dosPacketObject primaryResult: result1 secondaryResult: result2 @{FG TEXT}

@ENDNODE

@NODE "remSegment" "remSegment (VERY DANGEROUS):"

   @{B}NAME@{UB}
       RemSegment - Removes a resident segment from the resident list

   @{B}SYNOPSIS@{UB}
       BOOL success = RemSegment( struct Segment *segment );

   @{B}FUNCTION@{UB}
       Removes a resident segment from the Dos resident segment list,
       unloads it, and does any other cleanup required.  Will only succeed
       if the seg_UC (usecount) is 0.

   @{B}INPUTS@{UB}
       segment - the segment to be removed

   @{B}SEE ALSO@{UB}
       @{" FindSegment " LINK "ADosUnsafe.guide/findSegment"}, @{" AddSegment " LINK "addSegment"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   removeSegment: segmentObject @{FG TEXT}

@ENDNODE

@NODE "remDosEntry" "remDosEntry (VERY DANGEROUS):"

   @{B}NAME@{UB}
       RemDosEntry -- Removes a Dos List entry from it's list

   @{B}SYNOPSIS@{UB}
       BOOL success = RemDosEntry( struct DosList *dlist );

   @{B}FUNCTION@{UB}
       This removes an entry from the Dos Device list.  The memory associated
       with the entry is NOT freed.  NOTE: you must have locked the Dos List
   with the appropriate flags before calling this routine.  Handler
   writers should see the AddDosEntry() caveats about locking and use
   a similar workaround to avoid deadlocks.

   @{B}INPUTS@{UB}
       dlist   - Device list entry to be removed.

   @{B}SEE ALSO@{UB}
       @{" AddDosEntry  " LINK "addDosEntry"}, @{" FindDosEntry " LINK "ADosUnsafe.guide/findDosEntry"}, 
       @{" NextDosEntry " LINK "ADosUnsafe.guide/nextDosEntry"}, @{" LockDosList " LINK "ADosUnsafe.guide/lockDosList"},
       @{" MakeDosEntry " LINK "ADosUnsafe.guide/makeDosEntry"}, @{" FreeDosEntry " LINK "freeDosEntry"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   removeDosEntry: dosList @{FG TEXT}

@ENDNODE

@NODE "remAssignList" "remAssignList (VERY DANGEROUS):"

   @{B}NAME@{UB}
       RemAssignList -- Remove an entry from a multi-dir assign

   @{B}SYNOPSIS@{UB}
       BOOL success = RemAssignList( char *name, BPTR lock );

   @{B}FUNCTION@{UB}
       Removes an entry from a multi-directory assign.  The entry removed is
       the first one for which SameLock with 'lock' returns that they are on
       the same object.  The lock for the entry in the list is unlocked (not
       the entry passed in).

   @{B}INPUTS@{UB}
       name - Name of device to remove lock from (without trailing ':')
       lock - Lock associated with the object to remove from the list

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36 through V39.23 dos, it would fail to remove the first lock
       in the assign.  Fixed in V39.24 dos (after the V39.106 kickstart).
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" Lock " LINK "ADosUnsafe.guide/lock"}, @{" AssignLock " LINK "ADosUnsafe.guide/assignLock"}, 
       @{" AssignPath " LINK "ADosUnsafe.guide/assignPath"}, @{" AssignLate " LINK "ADosUnsafe.guide/assignLate"}, 
       @{" DupLock " LINK "ADosUnsafe.guide/dupLock"}, @{" AssignAdd " LINK "ADosUnsafe.guide/assignAdd"}, 
       @{" UnLock  " LINK "ADosUnsafe.guide/unLock"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   removeAssignList: assignmentName from: bptrLock @{FG TEXT}

@ENDNODE

@NODE "newLoadSeg" "newLoadSeg (VERY DANGEROUS):"

   @{B}NAME@{UB}
       NewLoadSeg -- Improved version of LoadSeg for stacksizes

   @{B}SYNOPSIS@{UB}
       BPTR seglist = NewLoadSeg( char *file, struct TagItem *tags );

   @{B}FUNCTION@{UB}
       Does a LoadSeg on a file, and takes additional actions based on the
       tags supplied.

   Clears unused portions of Code and Data hunks (as well as BSS hunks).
   (This also applies to InternalLoadSeg() and LoadSeg()).

   NOTE to overlay users:  NewLoadSeg() does NOT return seglist in
   both D0 and D1, as @{" LoadSeg " LINK "loadSeg"} does.  The current ovs.asm uses LoadSeg(),
   and assumes returns are in D1.  We will support this for LoadSeg() ONLY.

   @{B}INPUTS@{UB}
       file - Filename of file to load
       tags - pointer to tagitem array

   @{B}RESULT@{UB}
       seglist - Seglist loaded, or NULL

   @{B}BUGS@{UB}
   @{FG SHINE}    No tags are currently defined.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" LoadSeg " LINK "loadSeg"}, @{" UnLoadSeg " LINK "unLoadSeg"}, 
       @{" InternalLoadSeg " LINK "internalLoadSeg"}, @{" InternalUnLoadSeg " LINK "internalUnloadSeg"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   newLoadSegment: fileName tags: tagArray @{FG TEXT}

@ENDNODE

@NODE "loadSeg" "loadSeg (VERY DANGEROUS):"

   @{B}NAME@{UB}
       LoadSeg -- Scatterload a loadable file into memory

   @{B}SYNOPSIS@{UB}
       BPTR seglist = LoadSeg( char *name )

   @{B}FUNCTION@{UB}
       The file 'name' should be a load module produced by the linker.
       LoadSeg() scatterloads the CODE, DATA and BSS segments into memory,
   chaining together the segments with BPTR's on their first words.
   The end of the chain is indicated by a zero.  There can be any number
   of segments in a file.  All necessary re-location is handled by
   LoadSeg().
 
   In the event of an error any blocks loaded will be unloaded and a
   NULL result returned.
 
   If the module is correctly loaded then the output will be a pointer
   at the beginning of the list of blocks. Loaded code is unloaded via
   a call to UnLoadSeg().
 
   @{B}INPUTS@{UB}
       name - pointer to a null-terminated string

   @{B}RESULT@{UB}
       seglist - BCPL pointer to a seglist

   @{B}SEE ALSO@{UB}
       @{" UnLoadSeg " LINK "unloadSeg"}, @{" InternalLoadSeg " LINK "internalLoadSeg"}, 
       @{" InternalUnLoadSeg " LINK "internalUnloadSeg"}, @{" CreateProc " LINK "createProc"},
       @{" CreateNewProc " LINK "createNewProc"}, @{" NewLoadSeg " LINK "newLoadSeg"}.
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   loadSegment: segmentName @{FG TEXT}

@ENDNODE

@NODE "internalUnLoadSeg" "internalUnLoadSeg (VERY DANGEROUS):"

   @{B}NAME@{UB}
       InternalUnLoadSeg -- Unloads a seglist loaded with InternalLoadSeg()

   @{B}SYNOPSIS@{UB}
       BOOL success = InternalUnLoadSeg( BPTR seglist,
                                         void (*FreeFunc)( char *, ULONG )
                                       );

   @{B}FUNCTION@{UB}
       Unloads a seglist using freefunc to free segments.  Freefunc is called
       as for InternalLoadSeg.  NOTE:  Will call Close() for overlaid
       seglists.

   @{B}INPUTS@{UB}
       seglist  - Seglist to be unloaded
       FreeFunc - Function called to free memory
 
   @{B}RESULT@{UB}
       success - returns whether everything went OK (since this may close
                 files).  Also returns FALSE if seglist was NULL.

   @{B}BUGS@{UB}
   @{FG SHINE}    Really should use tags
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" LoadSeg " LINK "loadSeg"}, @{" UnLoadSeg " LINK "unLoadSeg"}, 
       @{" InternalLoadSeg " LINK "internalLoadSeg"}, @{" NewLoadSeg " LINK "newloadSeg"}, 
       @{" Close " LINK "ADosUnsafe.guide/closeFile"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   internalUnLoadSegment: bptrSegList freeFuncPtr: freeFunc @{FG TEXT}

@ENDNODE

@NODE "internalLoadSeg" "internalLoadSeg (VERY DANGEROUS):"

   @{B}NAME@{UB}
       InternalLoadSeg -- Low-level load routine

   @{B}SYNOPSIS@{UB}
       BPTR seglist = InternalLoadSeg( BPTR  fh,
                                       BPTR  table,
                                       LONG *functionarray,
                                       LONG *stack
                                     );
 
   @{B}FUNCTION@{UB}
       Loads from fh.  Table is used when loading an overlay, otherwise
       should be NULL.  Functionarray is a pointer to an array of functions.
   Note that the current Seek position after loading may be at any point
   after the last hunk loaded.  The filehandle will not be closed.  If a
   stacksize is encoded in the file, the size will be stuffed in the
   LONG pointed to by stack.  This LONG should be initialized to your
   default value: InternalLoadSeg() will not change it if no stacksize
   is found. Clears unused portions of Code and Data hunks (as well as
   BSS hunks).  (This also applies to LoadSeg() and NewLoadSeg()).
 
   If the file being loaded is an overlaid file, this will return
   -(seglist).  All other results will be positive.
 
   NOTE to overlay users:  InternalLoadSeg() does NOT return seglist in
   both D0 and D1, as LoadSeg does.  The current ovs.asm uses LoadSeg(),
   and assumes returns are in D1.  We will support this for LoadSeg()
   ONLY.

   @{B}INPUTS@{UB}
       fh         - Filehandle to load from.
       table         - When loading an overlay, otherwise ignored.
       functionarray - Array of function to be used for read, alloc, and free.
       
         FuncTable[0]->Actual = ReadFunc( readhandle, buffer, length ), DOSBase
                       D0                 D1          D2      D3        A6

         FuncTable[1]->Memory = AllocFunc( size, flags ), Execbase
                       D0                  D0    D1       A6

         FuncTable[2]->FreeFunc( memory, size ), Execbase
                                 A1      D0      A6
 
       stack - Pointer to storage (ULONG) for stacksize.

   @{B}RESULT@{UB}
       seglist - Seglist loaded or NULL.  NOT returned in D1!

   @{B}BUGS@{UB}
   @{FG SHINE}    Really should use tags.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" LoadSeg " LINK "loadSeg"}, @{" UnLoadSeg " LINK "unLoadSeg"}, 
       @{" NewLoadSeg " LINK "newLoadSeg"}, @{" InternalUnLoadSeg " LINK "internalUnloadSeg"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   internalLoadSegment: bptrFileHandle ovlyTable: bptrTable 
             funcArray: fArray          stackPtr: stack @{FG TEXT}

@ENDNODE

@NODE "inhibit" "inhibit (DANGEROUS):"

   @{B}NAME@{UB}
       Inhibit -- Inhibits access to a filesystem

   @{B}SYNOPSIS@{UB}
       BOOL success = Inhibit( char *filesystem, LONG flag );

   @{B}FUNCTION@{UB}
       Sends an ACTION_INHIBIT packet to the indicated handler.  This stops
       all activity by the handler until uninhibited.  When uninhibited,
       anything may have happened to the disk in the drive, or there may no
       longer be one.

   @{B}INPUTS@{UB}
       filesystem - Name of device to inhibit (with ':')
       flag       - New status.  DOSTRUE = inhibited,
                                   FALSE = uninhibited
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   inhibit: fileSystem flags: flag @{FG TEXT}

@ENDNODE

@NODE "fWrite" "fWrite (DANGEROUS):"

   @{B}NAME@{UB}
       FWrite -- Writes a number of blocks to an output (buffered)

   @{B}SYNOPSIS@{UB}
       LONG count = FWrite( BPTR fh, char *buf, ULONG blocklen, ULONG blocks )

   @{B}FUNCTION@{UB}
       Attempts to write a number of blocks, each blocklen long, from the
       specified buffer to the output stream.  May return less than the
       number of blocks requested, if there is some error such as a full
       disk or r/w error.  This call is buffered.

   @{B}INPUTS@{UB}
       fh       - filehandle to use for buffered I/O
       buf      - Area to write bytes from.
       blocklen - number of bytes per block.  Must be > 0.
       blocks   - number of blocks to write.  Must be > 0.

   @{B}RESULT@{UB}
       count - Number of _blocks_ written.  On an error, the number of
               blocks actually written is returned.

   @{B}BUGS@{UB}
   @{FG SHINE}    Doesn't clear IoErr() before starting.  If you want to find out
       about errors, use SetIoErr( 0 ) before calling.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FPutC " LINK "ADosSafe.guide/fPutC"}, @{" FRead " LINK "ADosUnsafe.guide/fRead"}, 
       @{" FPuts " LINK "ADosSafe.guide/fPutS"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   fileWrite: bptrFileHandle to: aBuffer blkSize: blockLength 
       count: blockCount @{FG TEXT}

@ENDNODE

@NODE "freeDosObject" "freeDosObject (DANGEROUS):"

   @{B}NAME@{UB}
       FreeDosObject -- Frees an object allocated by @{" AllocDosObject() " LINK "allocDosObject"}

   @{B}SYNOPSIS@{UB}
       void FreeDosObject( ULONG type, void *ptr );

   @{B}FUNCTION@{UB}
       Frees an object allocated by AllocDosObject().  Do NOT call for
       objects allocated in any other way.

   @{B}INPUTS@{UB}
       type - type passed to AllocDosObject()
       ptr  - ptr returned by AllocDosObject()

   @{B}BUGS@{UB}
   @{FG SHINE}    Before V39, DOS_CLI objects will only have the struct
       CommandLineInterface freed, not the strings it points to.  This
       is fixed in V39 dos.  Before V39, you can workaround this bug by
       using FreeVec() on cli_SetName, cli_CommandFile, cli_CommandName,
       and cli_Prompt, and then setting them all to NULL.  In V39 or
       above, do NOT use the workaround.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" AllocDosObject " LINK "allocDosObject"}, FreeVec, <dos/dos.h>
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   freeDosObject: dosObject type: t @{FG TEXT} " Tested "

@ENDNODE

@NODE "freeDosEntry" "freeDosEntry (DANGEROUS):"

   @{B}NAME@{UB}
       FreeDosEntry -- Frees an entry created by @{" MakeDosEntry " LINK "ADosUnsafe.guide/makeDosEntry"}

   @{B}SYNOPSIS@{UB}
       void FreeDosEntry( struct DosList *dlist );

   @{B}FUNCTION@{UB}
       Frees an entry created by MakeDosEntry().  This routine should be
       eliminated and replaced by a value passed to FreeDosObject()!

   @{B}INPUTS@{UB}
       dlist - DosList to free.

   @{B}SEE ALSO@{UB}
       @{" AddDosEntry  " LINK "addDosEntry"}, @{" RemDosEntry " LINK "remDosEntry"}, 
       @{" FindDosEntry " LINK "ADosUnsafe.guide/findDosEntry"}, @{" LockDosList " LINK "ADosUnsafe.guide/lockDosList"},
       @{" NextDosEntry " LINK "ADosUnsafe.guide/nextDosEntry"}, @{" MakeDosEntry " LINK "ADosUnsafe.guide/MakeDosEntry"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   freeDosEntry: dosListObject @{FG TEXT}

@ENDNODE

@NODE "freeDeviceProc" "freeDeviceProc (DANGEROUS):"

   @{B}NAME@{UB}
       FreeDeviceProc -- Releases port returned by @{" GetDeviceProc() " LINK "ADosSafe.guide/getDeviceProc"}

   @{B}SYNOPSIS@{UB}
       void FreeDeviceProc( struct DevProc *devproc );

   @{B}FUNCTION@{UB}
       Frees up the structure created by GetDeviceProc(), and any associated
       temporary locks.

   Decrements the counter incremented by GetDeviceProc().  The counter
   is in an extension to the 1.3 process structure.  After calling
   FreeDeviceProc(), do not use the port or lock again!  It is safe to
   call FreeDeviceProc(NULL).

   @{B}INPUTS@{UB}
       devproc - A value returned by GetDeviceProc()

   @{B}BUGS@{UB}
   @{FG SHINE}    Counter not currently active in 2.0.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" GetDeviceProc " LINK "ADosSafe.guide/getDeviceProc"}, @{" DeviceProc " LINK "deviceProc"}, 
       @{" AssignLock    " LINK "ADosUnsafe.guide/assignLock"}, @{" AssignLate " LINK "ADosUnsafe.guide/assignLate"},
       @{" AssignPath    " LINK "ADosUnsafe.guide/assignPath"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   freeDeviceProcess: devProcessObject @{FG TEXT}

@ENDNODE

@NODE "freeArgs" "freeArgs (DANGEROUS):"

   @{B}NAME@{UB}
       FreeArgs - Free allocated memory after @{" ReadArgs() " LINK "ADosSafe.guide/readArgs"}

   @{B}SYNOPSIS@{UB}
       void FreeArgs( struct RDArgs *rdargs );

   @{B}FUNCTION@{UB}
       Frees memory allocated to return arguments in from ReadArgs().  If
       ReadArgs allocated the RDArgs structure it will be freed.  If NULL
       is passed in this function does nothing.

   @{B}INPUTS@{UB}
       rdargs - structure returned from ReadArgs() or NULL.

   @{B}SEE ALSO@{UB}
       @{" ReadArgs " LINK "ADosSafe.guide/readArgs"}, @{" ReadItem " LINK "ADosSafe.guide/readItem"}, 
       @{" FindArg  " LINK "ADosUnsafe.guide/findArg"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   freeArgs: rdArgsObject @{FG TEXT}

@ENDNODE

@NODE "format" "format (VERY DANGEROUS):"

   @{B}NAME@{UB}
       Format -- Causes a filesystem to initialize itself

   @{B}SYNOPSIS@{UB}
       BOOL success = Format( char *filesystem, char *volumename,
                              ULONG dostype );

   @{B}FUNCTION@{UB}
       Interface for initializing new media on a device.  This causes the
       filesystem @{B}to write out an empty disk structure to the media@{UB}, which
       should then be ready for use.  This assumes the media has been low-
       level formatted and verified already.

   The filesystem should be inhibited before calling Format() to make
   sure you don't get an ERROR_OBJECT_IN_USE.

   @{B}INPUTS@{UB}
       filesystem - Name of device to be formatted.  ':' must be supplied.
       volumename - Name for volume (if supported).  No ':'.
       dostype    - Type of format, if filesystem supports multiple types.

   @{B}BUGS@{UB}
   @{FG SHINE}    Existed, but was non-functional in V36 dos.  (The volumename wasn't
   converted to a BSTR.)  Workaround:  Require V37, or under V36
   convert volumename to a BPTR to a BSTR before calling Format().
   Note:  A number of printed packet docs for ACTION_FORMAT are wrong
   as to the arguments.
   @{FG TEXT}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   formatDisk: diskName on: volumeName type: dosType @{FG TEXT}

@ENDNODE

@NODE "exitProgram" "exitProgram (DANGEROUS):"

   @{B}NAME@{UB}
       Exit -- Exit from a program

   @{B}SYNOPSIS@{UB}
       void Exit( LONG returnCode );

   @{B}FUNCTION@{UB}
       Exit() is currently for use with programs written as if they
       were BCPL programs.  This function is not normally useful for
       other purposes.

   In general, therefore, please @{B}DO NOT CALL THIS FUNCTION!@{UB}

   In order to exit, C programs should use the C language exit()
   function (note the lower case letter "e").  Assembly programs should
   place a return code in D0, and execute an RTS instruction with
   their original stack ptr.
   @{B}
   IMPLEMENTATION @{UB}

       The action of Exit() depends on whether the program which called it
       is running as a command under a CLI or not. If the program is
   running under the CLI the command finishes and control reverts to
   the CLI. In this case, returnCode is interpreted as the return code
   from the program.

   If the program is running as a distinct process, Exit() deletes the
   process and release the space associated with the stack, segment
   list and process structure.

   @{B}INPUTS@{UB}
       returnCode - integer

   @{B}SEE ALSO@{UB}
       @{" CreateProc " LINK "createProc"}, @{" CreateNewProc " LINK "createNewProc"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   exitProgram: returnCode @{FG TEXT}

@ENDNODE

@NODE "doPacket" "doPacket (VERY DANGEROUS):"

   @{B}NAME@{UB}
       DoPkt -- Send a dos packet and wait for reply

   @{B}SYNOPSIS@{UB}
       LONG result1 = DoPkt( struct MsgPort *port, LONG action,
                             LONG arg1, LONG arg2, LONG arg3,
                             LONG arg4, LONG arg5 );

   @{B}FUNCTION@{UB}
       Sends a packet to a handler and waits for it to return.  Any secondary
       return will be available in D1 AND from @{" IoErr() " LINK "ADosSafe.guide/ioErr"}.  DoPkt() will work
   even if the caller is an exec task and not a process; however it will
   be slower, and may fail for some additional reasons, such as being
   unable to allocate a signal.  DoPkt() uses your pr_MsgPort for the
   reply, and will call pr_PktWait.  (See BUGS regarding tasks, though).

   Only allows 5 arguments to be specified.  For more arguments (packets
   support a maximum of 7) create a packet and use @{" SendPkt() " LINK "sendPkt"}/@{" WaitPkt() " LINK "waitPkt"}.

   @{B}INPUTS@{UB}
       port    - pr_MsgPort of the handler process to send to.
       action  - the action requested of the filesystem/handler
       arg1, arg2, arg3, arg4,arg5 - arguments, depend on the action & may not
                                     all be required.

   @{B}RESULT@{UB}
       result1 - the value returned in dp_Res1, or FALSE if there was some
                 problem in sending the packet or recieving it.
       result2 - Available from IoErr() AND in register D1.

   @{B}BUGS@{UB}
   @{FG SHINE}    Using DoPkt() from tasks doesn't work in V36. 
   Use @{" AllocDosObject() " LINK "allocDosObject"}, PutMsg(), and WaitPort()/GetMsg() 
   for a workaround, or you can call @{" CreateNewProc() " LINK "createNewProc"} to start a process to 
   do Dos I/O for you.  In V37, DoPkt() will allocate, use, and free the 
   MsgPort required.

   @{B}NOTES@{UB}
   @{B}@{FG SHINE}    Callable from a task (under V37 and above).
   @{FG TEXT}@{UB}
   @{B}SEE ALSO@{UB}
       @{" AllocDosObject " LINK "allocDosObject"}, @{" FreeDosObject " LINK "freeDosObject"}, 
       @{" SendPkt " LINK "sendPkt"}, @{" WaitPkt " LINK "waitPkt"},
       @{" CreateNewProc " LINK "createNewProc"}, @{" AbortPkt " LINK "ADosSafe.guide/abortPacket"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   doPacket: action onPort: msgPort arguments: argArray @{FG TEXT}

@ENDNODE

@NODE "deviceProc" "deviceProc (DANGEROUS):"

   @{B}NAME@{UB}
       DeviceProc -- Return the process MsgPort of specific I/O handler

   @{B}SYNOPSIS@{UB}
       struct MsgPort *process = DeviceProc( char *name );

   @{B}FUNCTION@{UB}
       DeviceProc() returns the process identifier of the process which
       handles the device associated with the specified name. If no
   process handler can be found then the result is zero. If the name
   refers to an assign then a directory lock is returned in @{" IoErr() " LINK "ADosSafe.guide/ioErr"}.
   This lock should not be @{" UnLock() " LINK "ADosUnsafe.guide/unLock"}ed or @{" Examine() " LINK "ADosUnsafe.guide/examine"}ed (if you wish to do
   so, @{" DupLock() " LINK "ADosUnsafe.guide/dupLock"} it first).

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, if you try to DeviceProc() something relative to an assign
   made with @{" AssignPath() " LINK "ADosUnsafe.guide/assignPath"}, it will fail.  This is because there's no
   way to know when to unlock the lock.  If you're writing code for
   V36 or later, it is highly advised you use @{" GetDeviceProc() " LINK "ADosSafe.guide/getDeviceProc"} instead,
   or make your code conditional on V36 to use GetDeviceProc()/
   @{" FreeDeviceProc() " LINK "freeDeviceProc"}.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" GetDeviceProc " LINK "ADosSafe.guide/getDeviceProc"}, @{" FreeDeviceProc " LINK "freeDeviceProc"}, 
       @{" DupLock " LINK "ADosUnsafe.guide/dupLock"}, @{" UnLock " LINK "ADosUnsafe.guide/unLock"}, 
       @{" Examine " LINK "ADosUnsafe.guide/examine"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   makeDeviceProcess: deviceName @{FG TEXT}

@ENDNODE

@NODE "deleteVar" "deleteVar (DANGEROUS):"

   @{B}NAME@{UB}
       DeleteVar -- Deletes a local or environment variable

   @{B}SYNOPSIS@{UB}
       BOOL success = DeleteVar( char *name, ULONG flags ); 

   @{B}FUNCTION@{UB}
       Deletes a local or environment variable.

   @{B}INPUTS@{UB}
       name   - pointer to an variable name.  Note variable names follow
                filesystem syntax and semantics.
       flags  - combination of type of var to delete (low 8 bits), and
                flags to control the behavior of this routine.  Currently
                defined flags include:

        GVF_LOCAL_ONLY  - delete a local (to your process) variable.
        GVF_GLOBAL_ONLY - delete a global environment variable.

        The default is to delete a local variable if found, otherwise
        a global environment variable if found (only for LV_VAR).

   @{B}RESULT@{UB}
       success - If non-zero, the variable was sucessfully deleted, FALSE
                 indicates failure.
 
   @{B}BUGS@{UB}
   @{FG SHINE}    LV_VAR is the only type that can be global
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" GetVar " LINK "ADosSafe.guide/getVar"}, @{" SetVar " LINK "ADosUnsafe.guide/setVar"}, 
       @{" FindVar " LINK "ADosSafe.guide/findVar"}, @{" DeleteFile " LINK "deleteFile"}, 
       <dos/var.h>
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   deleteVar: varName flags: f @{FG TEXT}

@ENDNODE

@NODE "deleteFile" "deleteFile (VERY DANGEROUS):"

   @{B}NAME@{UB}
       DeleteFile -- Delete a file or directory

   @{B}SYNOPSIS@{UB}
       BOOL success = DeleteFile( char *name );

   @{B}FUNCTION@{UB}
       This attempts to delete the file or directory specified by 'name'.
       An error is returned if the deletion fails.  Note that all the files
       within a directory must be deleted before the directory itself can
       be deleted.

   @{B}INPUTS@{UB}
       name - pointer to a null-terminated string
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   deleteFile: fileOrDirName @{FG TEXT}

@ENDNODE

@NODE "createProc" "CreateProc (DANGEROUS):"

   @{B}NAME@{UB}
       CreateProc -- Create a new process

   @{B}SYNOPSIS@{UB}
       struct MsgPort *process = CreateProc( char *name,
                                             LONG  pri,
                                             BPTR  seglist,
                                             LONG  stackSize )

   @{B}FUNCTION@{UB}
       CreateProc() creates a new AmigaDOS process of name 'name'.  AmigaDOS
       processes are a superset of exec tasks.

   A seglist, as returned by @{" LoadSeg() " LINK "loadSeg"}, is passed as 'seglist'.
   This represents a section of code which is to be run as a new
   process. The code is entered at the first hunk in the segment list,
   which should contain suitable initialization code or a jump to
   such.  A process control structure is allocated from memory and
   initialized.  If you wish to fake a seglist (that will never
   have DOS UnLoadSeg() called on it), use this code:

           DS.L    0   ;Align to longword
           DC.L    16   ;Segment "length" (faked)
           DC.L    0   ;Pointer to next segment
           ...start of code...

   The size of the root stack upon activation is passed as
   'stackSize'.  'pri' specifies the required priority of the new
   process.  The result will be the process msgport address of the new
   process, or zero if the routine failed.  The argument 'name'
   specifies the new process name.  A zero return code indicates error.

   The seglist passed to CreateProc() is not freed when it exits; it
   is up to the parent process to free it, or for the code to unload
   itself.

   Under V36 and later, you probably should use @{" CreateNewProc() " LINK "createNewProc"} instead.

   @{B}INPUTS@{UB}
       name      - pointer to a null-terminated string
       pri       - signed long (range -128 to +127)
       seglist   - BCPL pointer to a seglist
       stackSize - integer (must be a multiple of 4 bytes)

   @{B}RESULT@{UB}
       process   - pointer to new process msgport

   @{B}SEE ALSO@{UB}
       @{" CreateNewProc " LINK "createNewProc"}, @{" LoadSeg " LINK "loadSeg"}, 
       @{" UnLoadSeg " LINK "unLoadSeg"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   createProcess: processName  priority: pri 
        segments: bptrSegmentList stack: stackSize @{FG TEXT}

@ENDNODE

@NODE "createNewProc" "createNewProc (DANGEROUS):"

   @{B}NAME@{UB}
       CreateNewProc -- Create a new process

   @{B}SYNOPSIS@{UB}
       struct Process *process = CreateNewProc( struct TagItem *tags );

   @{B}FUNCTION@{UB}
       This creates a new process according to the tags passed in.  See
       dos/dostags.h for the tags.

   You must specify one of NP_Seglist or NP_Entry.  NP_Seglist takes a
   seglist (as returned by LoadSeg()).  NP_Entry takes a function
   pointer for the routine to call.

   There are many options, as you can see by examining dos/dostags.h.
   The defaults are for a non-CLI process, with copies of your
   CurrentDir, HomeDir (used for PROGDIR:), priority, consoletask,
   windowptr, and variables.  The input and output filehandles default
   to opens of NIL:, stack to 4000, and others as shown in dostags.h.
   This is a fairly reasonable default setting for creating threads,
   though you may wish to modify it (for example, to give a descriptive
   name to the process.)

   CreateNewProc() is callable from a task, though any actions that
   require doing Dos I/O (DupLock() of currentdir, for example) will not
   occur.

   NOTE:  If you call CreateNewProc() with both NP_Arguments, you must
   not specify an NP_Input of NULL.  When NP_Arguments is specified, it
   needs to modify the input filehandle to make ReadArgs() work properly.
   
   @{B}INPUTS@{UB}
       tags - a pointer to a TagItem array.


   @{B}RESULT@{UB}
       process - The created process, or NULL.  Note that if it returns
                 NULL, you must free any items that were passed in via
                 tags, such as if you passed in a new current directory
                 with NP_CurrentDir.

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36, NP_Arguments was broken in a number of ways, and probably
       should be avoided (instead you should start a small piece of your
       own code, which calls @{" RunCommand() " LINK "runCommand"} to run the actual code you wish
       to run).  In V37, NP_Arguments works, though see the note above.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" LoadSeg " LINK "loadSeg"}, @{" CreateProc " LINK "createProc"}, 
       @{" ReadArgs " LINK "ADosSafe.guide/readArgs"}, @{" RunCommand " LINK "runCommand"}, 
       <dos/dostags.h>
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   createNewProcess: tagArray @{FG TEXT}

@ENDNODE

@NODE "cliInitRun" "cliInitRun (DANGEROUS):"

   @{B}NAME@{UB}
       CliInitRun -- Set up a process to be a shell from initial packet

   @{B}SYNOPSIS@{UB}
       LONG flags = CliInitRun( struct DosPacket *packet );

   @{B}FUNCTION@{UB}
       This function initializes a process and CLI structure for a new
       shell, from parameters in an initial packet passed by the system
   (Run, System(), Execute()).  The format of the data in the packet
   is purposely not defined.  The setup includes all the normal fields
   in the structures that are required for proper operation (current
   directory, paths, input streams, etc).

   It returns a set of flags containing information about what type
   of shell invocation this is.

   Definitions for the values of fn:
       Bit 31     Set to indicate flags are valid
       Bit  3     Set to indicate asynch system call
       Bit  2     Set if this is a System() call
       Bit  1     Set if user provided input stream
       Bit  0     Set if RUN provided output stream

   If Bit 31 is 0, then you must check @{" IoErr() " LINK "ADosSafe.guide/ioErr"} to determine if an error
   occurred.  If IoErr() returns a pointer to your process, there has
   been an error, and you should clean up and exit.  The packet will
   have already been returned by @{" CliInitNewcli() " LINK "cliInitNewCli"}.  If it isn't a pointer
   to your process and Bit 31 is 0, you should wait before replying
   the packet until after you've loaded the first command (or when you
   exit).  This helps avoid disk "gronking" with the Run command.
   (Note:  This is different from what you do for CliInitNewcli().)

   If Bit 31 is 1, then if Bit 3 is one, ReplyPkt() the packet
   immediately (Asynch System()), otherwise wait until your shell exits
   (Sync System(), Execute()).
   (Note:  This is different from what you do for CliInitNewcli().)
   
   This function is very similar to CliInitNewcli().

   @{B}INPUTS@{UB}
       packet - the initial packet sent to your process MsgPort

   @{B}RESULT@{UB}
       fn - flags or a pointer

   @{B}SEE ALSO@{UB}
       @{" CliInitNewcli() " LINK "cliInitNewCli"}, @{" ReplyPkt " LINK "replyPkt"}, 
       @{" WaitPkt " LINK "waitPkt"}, @{" Execute " LINK "ADosUnsafe.guide/execute"}, 
       @{" IoErr " LINK "ADosSafe.guide/ioErr"}, System()
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   cliInitRun: dosPacketObject @{FG TEXT}

@ENDNODE

@NODE "cliInitNewcli" "cliInitNewcli (DANGEROUS):"

   @{B}NAME@{UB}
       CliInitNewcli -- Set up a process to be a shell from initial packet

   @{B}SYNOPSIS@{UB}
       LONG flags = CliInitNewcli( struct DosPacket *packet );

   @{B}FUNCTION@{UB}
       This function initializes a process and CLI structure for a new
       shell, from parameters in an initial packet passed by the system
   (NewShell or NewCLI, etc).  The format of the data in the packet
   is purposely not defined.  The setup includes all the normal fields
   in the structures that are required for proper operation (current
   directory, paths, input streams, etc).

   It returns a set of flags containing information about what type
   of shell invocation this is.

   Definitions for the values of fn:
       Bit 31     Set to indicate flags are valid
       Bit  3     Set to indicate asynch system call
       Bit  2     Set if this is a System() call
       Bit  1     Set if user provided input stream
       Bit  0     Set if RUN provided output stream

   If Bit 31 is 0, then you must check @{" IoErr() " LINK "ADosSafe.guide/ioErr"} to determine if an error
   occurred.  If IoErr() returns a pointer to your process, there has
   been an error, and you should clean up and exit.  The packet will
   have already been returned by CliInitNewcli().  If it isn't a pointer
   to your process and Bit 31 is 0, reply the packet immediately.
   (Note:  This is different from what you do for @{" CliInitRun() " LINK "cliInitRun"}.)

   This function is very similar to CliInitRun().

   @{B}INPUTS@{UB}
       packet - the initial packet sent to your process MsgPort

   @{B}RESULT@{UB}
       fn - flags or a pointer

   @{B}SEE ALSO@{UB}
       @{" CliInitRun() " LINK "cliInitRun"}, @{" ReplyPkt " LINK "replyPkt"}, 
       @{" WaitPkt " LINK "waitPkt"}, @{" IoErr " LINK "ADosSafe.guide/ioErr"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   cliInitNewCLI: dosPacketObject @{FG TEXT}

@ENDNODE

@NODE "attemptLockDosList" "attemptLockDosList (DANGEROUS):"

   @{B}NAME@{UB}
       AttemptLockDosList -- Attempt to lock the Dos Lists for use

   @{B}SYNOPSIS@{UB}
       struct DosList *dlist = AttemptLockDosList( ULONG flags );

   @{B}FUNCTION@{UB}
       Locks the dos device list in preparation to walk the list.  If the
       list is 'busy' then this routine will return NULL.  See @{" LockDosList() " LINK "ADosUnsafe.guide/lockDosList"}
       for more information.

   @{B}INPUTS@{UB}
       flags - Flags stating which types of nodes you want to lock.

   @{B}RESULT@{UB}
       dlist - Pointer to the beginning of the list or NULL.  Not a valid
               node!

   @{B}BUGS@{UB}
   @{FG SHINE}    In V36 through V39.23 dos, this would return NULL or 0x00000001 for
       failure.  Fixed in V39.24 dos (after kickstart 39.106).
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" LockDosList " LINK "ADosUnsafe.guide/lockDosList"}, @{" UnLockDosList " LINK "ADosUnsafe.guide/unLockDosList"}, 
       @{" NextDosEntry " LINK "ADosUnsafe.guide/nextDosEntry"}, Forbid() 
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   attemptLockDosList: flags @{FG TEXT}

@ENDNODE

@NODE "allocDosObject" "allocDosObject (DANGEROUS):"

   @{B}NAME@{UB}
       AllocDosObject -- Creates a dos object

   @{B}SYNOPSIS@{UB}
       void *ptr = AllocDosObject( ULONG type, struct TagItem *tags );

   @{B}FUNCTION@{UB}
       Create one of several dos objects, initializes it, and returns it
       to you.  Note the DOS_STDPKT returns a pointer to the sp_Pkt of the
       structure.

   This function may be called by a task for all types and tags defined
   in the V37 includes (DOS_FILEHANDLE through DOS_RDARGS and ADO_FH_Mode
   through ADO_PromptLen, respectively).  Any future types or tags
   will be documented as to whether a task may use them.

   @{B}INPUTS@{UB}
       type - type of object requested
       tags - pointer to taglist with additional information

   @{B}RESULT@{UB}
       packet - pointer to the object or NULL

   @{B}BUGS@{UB}
   @{FG SHINE}    Before V39, DOS_CLI should be used with care since @{" FreeDosObject() " LINK "freeDosObject"}
       can't free it.
   @{FG TEXT}
   @{B}SEE ALSO@{UB}
       @{" FreeDosObject " LINK "freeDosObject"}, 
       <dos/dostags.h>, <dos/dos.h>
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   allocDosObject: type tags: tagArray @{FG TEXT}  " Tested "

@ENDNODE

@NODE "addSegment" "addSegment (VERY DANGEROUS):"

   @{B}NAME@{UB}
       AddSegment - Adds a resident segment to the resident list

   @{B}SYNOPSIS@{UB}
       BOOL success = AddSegment( char *name, BPTR seglist, LONG type )

   @{B}FUNCTION@{UB}
       Adds a segment to the Dos resident list, with the specified Seglist
       and type (stored in seg_UC - normally 0).  NOTE:  Currently unused
       types may cause it to interpret other registers (D4-?) as additional
       parameters in the future.

   Do NOT build Segment structures yourself!

   @{B}INPUTS@{UB}
       name    - name for the segment
       seglist - Dos seglist of code for segment
       type    - initial usecount, normally 0

   @{B}RESULT@{UB}
       success - success or failure

   @{B}SEE ALSO@{UB}
       @{" FindSegment " LINK "ADosUnsafe.guide/findSegment"}, @{" RemSegment " LINK "remSegment"}, 
       @{" LoadSeg " LINK "loadSeg"}
   @{B}
   AMIGATALK INTERFACE (VeryDangerousDOS Class): @{UB}
   @{FG SHINE}
   addSegment: bptrSegList named: segmentName useCount: count @{FG TEXT}

@ENDNODE

@NODE "addDosEntry" "addDosEntry (DANGEROUS):"

   @{B}NAME@{UB}
       AddDosEntry -- Add a Dos List entry to the lists

   @{B}SYNOPSIS@{UB}
       LONG success = AddDosEntry( struct DosList *dlist );

   @{B}FUNCTION@{UB}
       Adds a device, volume or assign to the dos devicelist.  Can fail if it 
       conflicts with an existing entry (such as another assign to the same
   name or another device of the same name).  Volume nodes with different
   dates and the same name CAN be added, or with names that conflict with
   devices or assigns.  Note:  The dos list does NOT have to be locked to
   call this.  Do not access dlist after adding unless you have locked the
   Dos Device list.

   An additional note concerning calling this from within a handler:
   in order to avoid deadlocks, your handler must either be multi-
   threaded, or it must attempt to lock the list before calling this
   function.  The code would look something like this:

   if (AttemptLockDosList( LDF_xxx | LDF_WRITE ))
      {
      rc = AddDosEntry( ... );
      UnLockDosList( LDF_xxx | LDF_WRITE );
      }

   If @{" AttemptLockDosList() " LINK "attemptLockDosList"} fails (i.e. it's locked already), check for
   messages at your filesystem port (don't wait!) and try the
   AttemptLockDosList() again.

   @{B}INPUTS@{UB}
       dlist   - Device list entry to be added.

   @{B}RESULT@{UB}
       success - Success/Failure indicator

   @{B}SEE ALSO@{UB}
       @{" RemDosEntry  " LINK "remDosEntry"}, @{" FindDosEntry " LINK "ADosUnsafe.guide/findDosEntry"}, 
       @{" NextDosEntry " LINK "ADosUnsafe.guide/NextDosEntry"}, @{" LockDosList " LINK "ADosUnsafe.guide/lockDosList"},
       @{" MakeDosEntry " LINK "ADosUnsafe.guide/makeDosEntry"}, @{" FreeDosEntry " LINK "freeDosEntry"}, 
       @{" AttemptLockDosList " LINK "attemptLockDosList"}
   @{B}
   AMIGATALK INTERFACE (DangerousDOS Class): @{UB}
   @{FG SHINE}
   addDosEntry: dosListObject @{FG TEXT}

@ENDNODE
