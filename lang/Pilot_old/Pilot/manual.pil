r:This is the Manual for PILOT for the Amiga
d:a$(2)
c:a$=chr(12)
t:        Introduction to PILOT for the Amiga
:
:     PILOT is a language or authoring system used to 
:Develop Computer-Assisted Instruction (CAI).  The name
:PILOT is derived from the words
:   #3P#1rogrammed #3I#1nquiry #3L#1earning #3O#1r #3T#1eaching.  
:
:     PILOT was developed in the early 1970's by researchers
:at San Francisco Medical University and developed into
:a somewhat standardized version at Western Washington 
:University.  The Apple II and the IBM PC computers both
:have implementations of PILOT that start on the base of
:common PILOT.
:     The PILOT language uses a small number of commands
:along with modifiers and conditioners to operate a lesson.
:A basic set of nine commands provides most of the work
:required to conduct a lesson.  Depending on the implemen-
:tation, added commands are added to give more capacity to
:the language.
th:               Press return for next page
a:
t:$a$
:
:
:
:     Pilot has been used in the field of Interactive Video.
:In an interactive video application, input from a touch
:panel and integrated control of a laser disk video player
:is frequently used. 
:     The commerical version includes limited support for
:these devices using RS-232 serial port-controlled units.
:Version 1.0 supports the Sony PVM-1911 touchscreen monitor
:and the Pioneer LD-V4200 laser disk player.  Customized
:support of other units may be obtained by contacting
:Flight Training Devices-Alaska.
:
:
t:Press return for next page
a:
*menu
t:$a$           Chapter Index
:
:		1.  How PILOT Operates
:		2.  Labels 
:		3.  Type Instruction
:		4.  Dimension
:		5.  Compute
:		6.  Accept
:		7.  Match
:		8.  Problem
:		9.  Jump
:	       10.  Use
:	       11.  End
:	       12.  eXecute Indirect
:	       13.  Remark
:	       14.  Execution Time Commands
:              15.  Pilot Details (Functions, etc,.)
:              16.  Quit this manual
:
th:   Enter number of your choice: 
a:#choice
u(choice = 1):operate
u(choice = 2):labels
u(choice = 3):type
u(choice = 4):dim
u(choice = 5):compute
u(choice = 6):acpt
u(choice = 7):match
u(choice = 8):pr
u(choice = 9):jump
u(choice = 10):use
u(choice = 11):end
u(choice = 12):xi
u(choice = 13):rem
u(choice = 14):etc
u(choice = 15):details
r: insert here
e(choice = 16):
j:menu
*operate
t:$a$
:                        How PILOT Operates
:
:     To use a PILOT program, a text-file is created using a
:text editor with each line containing a valid pilot statement.
:The file must end in ".pil".  The following sample shows a
:valid PILOT program:
:                                                     
:               Name of file     Sample1.pil
:
:                    r: Sample1
:                    t: Hello World.
:                    e:
:
t:Press return for next page
a:
t:$a$
:This program will open the pilot screen, print "Hello World"
:and then shut down.
:
:    To test various Pilot commands, the program named  
:CON: 20/20/300/120/test can be used.  A console device window
:is opened on the Workbench screen and may be used by sliding
:the PILOT Screen down.
:
:     From the CLI, PILOT is run by the command:  PILOT [-d] 
:name where the PILOT file is name.pil and the -d option outputs
:debugging information such as symbol tables, label lists and
:error messages.
:
:     From the Workbench, double clicking on a PILOT file icon
:will operate the program.
:
t:Press return for next page
a:
t:$a$
:PILOT Statements:
:
:A PILOT statement consists of a label, a space and an
:instruction on one line.  Not all three are required so the
:following are valid PILOT statements:
:                   
:      
:                 label space instruction
:                 label
:                 instruction
:
t:Press return for next page
a:
t:$a$
*submenu
t:$a$
:
:
:       Submenu: Pilot Operation
:
:     1.   Op-codes
:     2.   Modifiers
:     3.   Conditioners
:            (Y, N, C, relational, E, answer-counter)
:     4.   Colon
:     5.   Object
:     6.   PILOT Window
:     7.   Main Menu
:
th: Press Number for choice!
a:#subchoice
u(subchoice = 1):opcode
u(subchoice = 2):modifier
u(subchoice = 3):conditional
u(subchoice = 4):colon
u(subchoice = 5):object
u(subchoice = 6):window
u(subchoice = 7):menu
e:
*labels
t:$a$
:PILOT label:
:     A PILOT label must have an asterisk in the first
:column followed by a letter and, optimally, followed by
:up to 29 alphanumeric characters or underscores.  For
:compatability, PILOT labels should be limited to 6 alpha
:characters following the asterisk. (Version 1.0).
:	Labels may not be duplicated within a lesson unless
:the Wipe-Labels option is used (see Problem instructions).
:(Version 1.0) No specific limit on the number of labels
:has been established - each label uses memory.
:
:                 example:  *num_1  
:
:           A PILOT Instruction is in this format:      
:          
:           op-code [modifier][conditioner]: object
:
t:Press return for next page
a:
e:
*opcode
t:$a$
:Op-Code
:     The op-code is one of the basic pilot instructions.
:Each of these instructions are covered in a separate
:section of the manual.  Grouping the op-codes by their
:functions, they are:
:
:     Op-codes that place something on the screen:
:
:            t:     type--including th:, tx: and ts:	
:            g:     graphic--including gx:  (not included
:                   in Common Pilot)
:     		       		
t:Press return for next page
a:
t:$a$
:     Op-codes that compute, accept, or compare values:
:
:	    d:     dimension
:	    c:     compute
:	    a:     accept--including ah:, as:, ap:, apx:
:                  and ax:.
:	    m:     match--including mj:, ms: and ms:
:
:     Op-codes that control flow or effect input:
:
:	    e:	   end
:	    j:     jump
:	    p:     problem--including pr:
:	    u:     use
:	    x:     eXecute Indirect--including xi:
:	    w:     wait
:
t:Press return for menu!
a:
e:submenu
*modifier
t:$a$
:                   The Modifier
:
:     The Modifier is one or two characters that appear
: immediately after the op-code.  The modifier may be one
: of the letters  H,J,P,S or X  if the particular op-code
: does not use the modifier, it will be ignored.  Otherwise
: the instruction will be modified.  See the section on
: each instruction for particular modifications.  Modified
: instructions are:
:    th:  type-hang     ts:  type-special  (not included)
:    tx:  type-erase    ah:  accept-hang
:    ap:  accept-point  as:  accept-single
:    mj:  match-jump    ms:  match-spell
:    mx:  match-expression
:
:     See each instruction for specific details
t:               Press return for menu!
a:
e:submenu
*conditional
t:$a$
:Conditionals
:
:     The conditional is a 'yes' or 'no' operator.  More
: than one conditional operator can be a part of a PILOT
: instruction.  If any conditional operator is evaluated
: FALSE, the PILOT instruction is not executed and the
: next line is then read in.  The conditions are:
:    
:	   Yes	    Y       last match result
:	   No	    N       last match result
:      	   Error    E	    error flag raised by a match
:                           error or timeout
:Previous condition  C	    last use of conditional
:   Answer count     n	    where 'n' is a single digit
:                           number or a variable containing
:                           a integer from '0' to 'n'.
t:Press return for next page
a:
t:$a$
:    
:    (Expression)	    A relational or mathematical
:                           expression.  '0' is FALSE and
:                           anything else is TRUE for
:                           mathematical expressions.
:
:          For a detailed summary of use of conditionals,
:          see the section on Conditionals.
:
t:Press return for menu!
a:
e:submenu
*colon
t:$a$
:Colon
:
:     In each valid PILOT instruciton, there is a colon
: following the op code and any modifiers or conditioners.
:
:Continuation Colon:
:      
:    The use of a colon as the first character in a PILOT
: instruction is treated as the last type instruction.  The
: instruction is executed if the last conditional evaluated
: was TRUE.
:
t:Press return for menu!
a:
e:submenu
*object
t:$a$
:Object:
:
:    The object of a PILOT instruction is the material that
: follows the colon.  The format of the object varies with
: the type of op-code and ,modifier.  See each instruction
: for details.
:
:Commands that put something on the screen
:
:	  T	  Type commands
:	  G	  Graphic commands
:
:
t:Press return for menu!
a:
e:submenu
*type
t:$a$
:Type commands:
:
:     The Type command is divided into two major catagories.
: The basic type command including modifiers of  'TH' for
: Type-hang and 'TX' for Type- erase is the primary Type
: command. When modified with an 'S', the TS: command is
: referred to as 'Type-special'.  The format of the object
: is different as is described separately below.
:
:	  Type (format)  T: TH: TX:  THX: :      
:             	          
:	  T [modifier][conditioner]
:
:
t:Press return for next page
a:
t:$a$
:     The general use of the Type command is to take the
: object and print it to the screen.  The cursor starts
: where it was left last and returns to the first position
: of the next line.  Thus, the statement:
:
:	  T:Hello World
:
: is displayed on screen as 'Hello World' and returns the
: cursor to the first position of the next line.  If a
: variable is placed in a line of PILOT instructions, it
: will be expanded into the variable full value.  Variables
: in a line of text must be introduced with the character
: ## (for numerical variable) or $$ (for a string variable)
: followed by the variable name and then followed by a
: space or end of line.  For example, name$$ is the string
: variable equal to "Amiga".
t:Press return for next page
a:
t:$a$
:
:	  T:Hello $name$, How are you!
:
:The screen prints:
:	                
:	    Hello Amiga, How are you!
:
:Also, number is the numeric variable equal to 10.
:
: 	  T:Hello Number ## number, how are you!
:
t:Press return for next page
a:
t:$a$
:The screen prints:
:
:	   Hello Number 10, How are you!
:
:In order to print the character ## or $$ on the screen,
:two of these characters must be in a row.  For example:
:
:	  T:$$$$10.00    (or)   ####125
:
:The screen prints:
:
:	  $$10.00               ##125
:
:
t:Press return for next page
a:
t:$a$
:     To properly use a variable, it must be assigned a 
: value using the 'compute' or 'accept' instructions.  A
: string variable must be dimensioned prior to assigning it
: a value using the dimension instruction.
:
:
:
t:Press return for menu!
a:
e:
*window
t:$a$
:The PILOT window.  
:    On opening, PILOT opens a fullscreen window with a
: title bar.  Normal window functions can be performed and
: the output text will be aligned inside the window.  In
: this Version, there is no option to remove the title bar
: or deactivate window gadgets.  That capability will be in
: the commerical version.  An abort capability has been
: placed at several levels in PILOT. To interrupt a program
: you may:
:
:    	  -click to activate the Workbench window and press
:          Control-C on the keyboard.  Then reactivate the
:          PILOT window. 
:	  -at any 'accept' statement, enter a Control-C as
:          the first character in the response.		
:
t:Press return for menu!
a:
e:submenu
*match
t:$a$
t:                           MATCH      
:
:
:
:      Match is used to test a users input in responce 
:  to questions, menu options or any other data needed
:  by a program. It can be used to compare a specific
:  string of characters, either in a specific order or
:  a string of characters contained anywhere in the line.
:     It can match numerical data also. Match sets the
:  condition flag to Y (true) if the match is successful
:  or to N (false) if not successful. You can use special
:  characters to match different types of patterns. These
:  are listed below.
:
:
:              Please press return for next page!
as:
t:$a$
:
:*  Use this to match any single character.
:     
:%  Use this to match a space or a start or end of an
:   answer.
:
:&  (AND) Use this to match one word and another.
:
:@  Use this to match specific words in a string of
:   characters. These can be in any order.
:
:!  (OR) Use this to match specific alternative patterns.
:
:
:
:
:
:               Press return for next page!
as:
t:$a$
:    The flow of the program can be changed if there is no
:match by using MJ:(Jump). If negative then the program
:will jump to the next Match statement.
:
:MS:(Spell) This will ignore minor spelling errors.
:
:MX:(Exp) Numeric match. True if the expression is true.
:
:Some examples:
:
:T: What color are most fire engines?
:A:
:M:red R:( If the responce is red then the match is true)
:
:T: What colors are zebras?
:A:
:MJ:black&white R: (Black and White) must be in this order.
:
:               Press Return for next page!
as:            
t:$a$
:
:
:  You can use the ! moderator if you wanted just one color.
:
:
:T: Name one color of a zebra?
:A:
:M:black!white R:(Black OR White) either answer will be true.
:
:
: There are many ways to use Match. You can make it relaxed
:where it will accept spelling mistakes and any order of words
:or make it stringent, where only the correct answer at the
:right place will test true.
:
:
:               Press Return for Menu!
a:
e:
*jump
t:$a$
t:                     JUMP
:
:   Jump allows you to change the flow of the program.
:You can jump to a different part of your program based
:on inputed data or just jump to a specific part of your
:program that you define.
:
:
:J:label  This would jump to the label specified.
:
:J:@A     Jump to the last Accept instruction.
:
:J:@P     Jump to the next Problem instruction.
:
:J:@M     Jump to the next Match instruction.
:
:         Press Return for next page!
AS:
t:$a$
:
:
:    You can make a jump conditional by using modifiers,
:relational expressions or conditioners.
:
:Example:
:
:JN:@M  If match is false (N) then Jump to next Match.
:
:JY:@P  If match is true (Y) then Jump to next Problem.
:
:JY(B>3):GREATER  If match is True and B is greater than 3
:                 then Jump to label called GREATER.
:
:              
:                Press Return to for Menu!
:
:
as:
e:
*rem
t:$a$
t:                   REMARK
:
:
:
:
:     The R instruction is used to make comments within
:a program. Anything after the R: is ignored. This is
:useful for putting remarks in a program for others
:to know what certain parts of the program do or to
:remind the programmer about certain things a section
:of the program does. A commented listing of a program
:is much easier to understand for those that havn't
:written the program, but may be studying it. It's
:also useful for marking the different sections of a
:program for easy location during debugging!
:
:
:         Press Return for Menu!
as:
e:
*dim
t:$a$
t:                      Dimension
:
:       D: variable (length)
:
:     Dimension is used to reserve space for numeric
: arrays or string variables. String variable lengths
: must be between 1 and 255 and numeric arrays are
: limited to 1 to 255 per dimension.
:     Numeric arrays are one  dimensional.
: You can only dimension one variable by a D: instruc-
: tion. Any variables that require dimensions must be
: dimensioned before there use.
:
:  i.e.
t:           D: A$$(14)
:           D: M(20)
:           D: M2(20,10)
:
:          Press Return for next Page!
AS:
t:$a$
:
:
:
:
:     It's good practice to place all your di-
: mensions at the beginning of the program and
: not in a section that will be executed more
: than once, so no space is wasted by reserving
: space more than once for the same variable.
:     The first subscript of a numeric array
: is 0. And the first substring position of a
: string is always 1.
:
:
:       Press Return for Menu!
:
:
:
AS:
e:
*compute
t:$a$
:
:                   COMPUTE
:
:      C: variable = expression
:
:     Compute is used for numeric and alphanumeric character
: manipulations. Compute may contain any of the following
: types of data and variables:
:
:
: Numeric Constants: Either decimal numbers from a list of
:                    0 to 9, signed and unsigned, which can
:                    contain an embedded decimal point or
:                    floating point numbers written in E
:                    format, consisting of a mantissa
:                    (written as a decimal ##), followed by
:                    the letter E, a sign +(optional) or -,
:                    and a 1to 3 digit exponent.
:
:      Press Return for next page!
as:
t:$a$
: Numeric Variables: This is used to store a numeric value
:		     that can be changed by the program.
:		     This can be written as a single letter
:                    or a letter followed by a single number.
:        i.e.
:		          A  A2  C  C3
:
:		     Assign the value of a numeric variable
:		     by setting the variable equal to an
:		     expression.
:
:	 i.e.
:		          C: A = 1234
:			  C: A2 = 12*34
:
:		Press Return for next page!
:
as:
t:$a$
: Numeric Arrays: This is used to store a one-dimensional
:		  array. An array is a series of elements,
:		  each denoted as a subscript. Each element
:		  of an array can store a number which can
:		  be set or changed by the program. All sub-
:		  scripts must be enclosed in parentheses
:		  and can be numeric constants or numeric
:		  variables, but cannot be a expression. The
:		  name of an array can be a single letter or
:                 a letter followed by a digit or underscore.
:      i.e.
:		     C: A(3) = 5
:		     C: C(1) = 45
:
:		  No element of an array can be used until
:		  space for it has been reserved by the use
:		  of the Dim instruction.
:        		Press return for next page!
as:
t:$a$
: Alphanumeric constants, Character string constants, or
: Literals:
:
:                 All three of the above are synonymous.
:                 Literals must be enclosed in quotation
:                 marks.
:    i.e.
:                 "Example"
:
:                 Literals can be used to assign values to
:                 an alphanumeric variable or as an argu-
:                 ment in an alphanumeric expression.
:
:
:          Press Return to next page!
as:
t:$a$
: Alphanumeric Variable or Character String Variables:
:
:                 This is normally known as a string and is
:                 used to store a string of characters that
:                 can be used or changed by the program.
:                 String variables are recognized by a
:                 single letter followed by a $$ sign, or
:                 a letter followed by a digit and a $$ sign.
:     i.e.
:                 A$$   B2$$
:
:                 A string variable cannot be used in a C:
:                 instruction until space for the string
:                 has been reserved by using the D: instruc-
:                 tion. Maximum length for the string is
:                 established by the D: instruction and can
:                 be from 1 to 255.
:                          Press Return for next page!
as:
t:$a$
:                 A particular part of the string can be
:                 accessed by using subscripts. A string
:                 variable can appear in an expression with
:                 one or two subscripts. The 1st subscript
:                 is the start of the portion of the string
:                 you want and the 2nd subscript is the
:                 length of that portion.
:      i.e
:                 C: A$$ = "A slice of life"
:                 C: B$$ = A$$(3,5)
:
:                 This sets B$$ = to "slice"
:
:                 C: B$$ = A$$(1)
:
:                 This would set B$$ = to "A"
:
:       Press Return for next page!
as:
t:$a$
:                 Subscripts can be from 1 to 255.
:                 Numeric variables or contants can be
:                 used as subscripts, but not expressions.
:                 Values are stored in a string from left
:                 to right and truncated on the right if
:                 the maximum string length is not large
:                 enough to hold the string. If the string
:                 is shorter than the maximum length than
:                 the length is the value of the string it
:                 holds.
:
:      Press Return for next page!
as:
t:$a$
: Pseudo Variables:
:
:                 This term is used only when a part of a
:                 string variable is used on the left of an
:                 assignment. Only the specified part of the
:                 string is altered. The rest of the string
:                 and the length stay the same.
:      i.e.
:                 C: A$$ = "My name is Joe Shmoe"
:                 C: A$$(13,3) = "Sam"
:
:                 A$$(13,3) is a Pseudo Variable of length
:                 3. This assigns A$$ the string "My name is
:                 Sam Shmoe".
:
:
:          Press Return for next page!
as:
t:$a$
: System Variables:
:
:                 Two system variables can be used in a Com-
:                 ute instruction.
:
:                 %A  Current value of the A counter.
:
:                 %B  Current string value in the answer
:                     buffer.
:
:
:     Press Return for Menu!
:
as:
e:
*use
t:$a$
t:                      USE
:
:
:
:    The USE instruction transfers control to a
:subroutine in the same program. This is like a
:GoSub in Basic. When the program exits the sub-
:routine it continues with the command after the
:USE. The destination of the USE command can be
:any of the four destinations that Jump can use.
:
:1.  A Label.
:2.  The previous Accept instruction.
:3.  The next Match instruction.
:4.  A Problem instruction.
:
:
:        Press Return for next page!
as:
t:$a$
:
:    USE eliminates having to constantly recode an
:often used sequence of instructions. It's not a
:recommended programming practice to use any other
:destination than a Label.
:
:Example:
:
:U:ADDRESS
:T: This will be printed after the USE instruction is
:done.
:
:*ADDRESS  (here we would have a routine to print an
:           address)
:
:
:             Press Return for Menu!
:
as:
e:
*acpt
t:$a$
t:                       Accept
:
:       A: string or number
:
:
:     Accept is used to accept one line of input
:  from a user. The line is saved in an internal
:  buffer for use in subsequent match instructions.
:  The line is automatically edited as follows.
:
:     All leading spaces are removed.
:
:     If the S option was set on the last PR: then
:  all spaces are removed, if not all multiple spaces
:  are compressed to one single space.
:
:                Press Return for next Page!
:
:
AS:
t:$a$
:
:     If the U option is set all letters are converted
:  to upper case and to lower case if the L option is
:  in effect. Neither will effect non-alphanumeric
:  characters.
:
:     If you want the line exactly as typed you can over-
:  ride the editing functions by using the X (exact) mo-
:  difier.
:
:   i.e., AX:
:
:     Variable names can be placed in the text field of
:  the Accept instruction. A variable preceeded by a dol-
:  lar sign ($$) is treated as a string variable and one
:  preceeded by a number sign (##) are treated as a numeric
:  variable. You can use both within one Accept if needed.
:
:       Press Return for Next Page!
AS:
t:$a$
:     Example:
:
:          T: What's your name?
:          A: $$N$$
:          T: How old are you?
:          A: ##O
:          T: Enter your name and age.
:          A: $$N$$ ##O
:
:     The S modifier can be used to Accept a single
:  keypress.
:
:    i.e.
:
:           T: Press a key to continue.
:          AS:
:
:          Press Return for next page!
AS:
t:$a$
:
:
:
:
:
:
:
:
:     There is a counter in the system that keeps
:  track of how many times in a row the same Accept
:  is executed. This can be accessed as the system
:  variable %A. 
:
:
:
:
:
:             Press Return for Menu!
:
as:
e:
*end
t:$a$
T:                    END
:
:      End has two functions.
:
:1. To end a program.
:
:2. To end a subroutine.
:
:   END knows whether it's ending a subroutine
:or the program itself by the status of the
:subroutine stack. A USE instruction places the
:address of the following instruction on the
:subroutine stack prior to jumping to the sub-
:routine. If a USE is in force the END will find
:the address on the stack and jump to that address.
:If there is no address, the END will terminate
:the program. It's good practice to only use a 
:label as a destination.
:
:         Press Return for next page!
as:
t:$a$
:
:
:
:
:
:
:
:    The destination of the jump can be controlled
:by using the destination-field of the End instruction.
:The destination-field can be any of the four choices
:that the Jump instruction can use. A instruction
:label, an Accept instruction, a Match or Problem
:instruction. Using any of these will automatically
:remove the USE return address from the stack.
:
:
:
:
:        Press Return for Menu!
as:
E:
*pr
t:$a$
T:                    PROBLEM
:
:    PR or P is used to begin a new frame, problem or
:section of dialogue. It can be used as a destination
:for a Jump or to specify execution of options. The
:following options can be used:
:
:U  Convert all input to upper case.
:
:L  Convert all input to lower case.
:
:S  Remove all spaces from input.
:
:G  Allow the use of GOTO command within program.
:
:W  Discard current label table.
:
:E  Allow the use of escape command within program.
:          Press Return for next page!
as:
t:$a$
:
:
:
:
:
:
:      When PR is used with no options all current
:options remain in force, but if any option is de-
:clared, then all options must be reset to remain
:in effect. You can change options at any time by
:executing another PR instruction. No modifiers,
:conditioners, or relational conditioners can be
:used with PR.
:
:
:
:             Press Return for Menu!
:
as:
E:
*xi
t:$a$
t:             
:
:                    Execute Indirect
:
:     
:    XI is used to execute an instruction created in a
:string variable. The string must contain a valid Pilot
:Opcode and text field. It cannot be preceeded by a label.
:
:    i.e.
:
T:          C: B$$="T: We are using Execute Indirect here!"
:         XI: B$$
:
:
:              Press Return for Next Page!
:
AS:
t:$a$
:
:
:
:     You can also use XI to execute functions you make or
:  those users can make.
:
:     Here is a function to multiply a number by two.
:
:     C: add$$= "C:B*2"
:     T: Enter a number.
:     A: ##B
:    XI: add$$
:
:     Most any function or operation can be contained in 
:  string and executed by XI.
:
:
:              Press Return for Menu!
:
AS:
e:
*etc
t:$a$
:
:
:
:                  Execution Time Commands
:
:
:
:
:     There are two commands that can be given by a user
: during a Pilot program. These can be used anytime a user
: is asked for input and can be disabled or enabled by the
: PR: instruction. If they are enabled the action will take
: place, otherwise they are treated just as any other input.
:
:
:
:             Press Return for next page!
:
as:
t:$a$
:
:                          GOTO
:
:      GOTO destination.
:
:     The Goto command allows a user to perform a jump to
: another part of a program, with valid destinations usually
: described to the user in the program. Destinations can be
: any that are available to the Jump instruction, but are
: usually labels.
:
:              i.e.   GOTO mathroutine
:
:    Goto is usefull to the programmer for testing sections
: of a program by jumping to the areas he wants to test.
: Note that the first four letters of a label should be
: upper case for a goto to recognize it. If you use PR:L
: to set input to lower case a goto will never work.
:
:              Press Return for next page!
as:
t:$a$
:
:                     ESCAPE COMMAND
:
:         @ any text
:
:     If the PR: instruction has enabled it, every line
: of input is searched for a @ character in column one.
: If one is found a "U:SYSX" is executed. If the escape
: function is enabled a labeled routine called SYSX that
: scans the inputed text and performs the desired function
: must be included in the program.
:     This permits the building of custom execution time
: commands. You must use an E: instruction to return from
: SYSX. The return point will be the next instruction after
: the A: unless a label is specified after the E:.
:
:           Press Return for Main Menu!
as:
e:
*details
t:$a$                       Menu
:          
:          1. Operators
:
:          2. Functions
:
:          3. Expressions
:
:          4. Conditioners
:
:          5. Relational Expressions
:
:          6. Precedence Table
:
:          7. Main Menu
:
th:   Enter number of your choice!
:
a:#dtchoice 
u(dtchoice = 1):dtoperator
u(dtchoice = 2):dtfun
u(dtchoice = 3):dtexpres
u(dtchoice = 4):dtcond
u(dtchoice = 5):dtrelat
u(dtchoice = 6):dtprec
e(dtchoice = 7):menu
j:details
*dtoperator
t:$a$
:                        OPERATORS
:
:     An expression can contain any of four types of
: operators.
:                 1. Arithmetic Operators.
:
:     An operator that combines two elements into a single
: result is a dyadic operator. These are all legal dyadic
: operators:
:
:   Symbol     Meaning          Example
:
:     +        Addition          1+2
:     -        Subtraction       3-1
:     *        Multiplication    5*5
:     /        Division          25/5
:   
:
:                 Press Return for next page!
as:
t:$a$
:
:                      Monadic Operators
:
:  Symbol     Meaning     Example
:
:    +        Positive     +5
:    -        Negative     -5
:
:
:    This is used to express positive and nagative numbers. 
: Monadic + is assumed and ignored. Monadic - denotes the
: negative of a number.
:
:              Press Return for next page!
:
as:
t:$a$
:
:                  Relational Operators
:
:     An expression can contain relational operators that
: compare numbers or strings. They are dyadic and both
: quantities must be of the same type. The result of a
: relational operation is True (1) or False (0). These are
: legal Relational Operators.
:
:  Symbol   Meaning             Example
:
:    =      Equal               Y=Z: Y equal to Z?
:    <      Less Than           Y<Z: Y less than Z?
:    >      Greater Than        Y>Z: Y greater than Z?
:   <>      Not = to            Y<>Z: Y not equal to Z?
:   <=      Less than or equal  Y<=Z: Y less or = to Z?
:   >=      Greater than or =   Y>=Z: Y greater or = to Z?
:
:                Press Return for next page!
:
as:
t:$a$
:                   Logical Operators
:
:     An expression can contain a logical operator with a
: numeric value. They are usually used in relational expres-
: sions with relational operators. The result of a logical
: operation is True (1) or False (0). Any non-zero value is
: considered to be True. These are the Logical Operators.
:
:  Symbol     Meaning   Example
:
:  ~ or ^     NOT       ~Y: NOT Y. If Y is 0 then ~Y is 1.
:                           If Y is <> 0 then ~Y is 0.
:
:    &        AND       Y&Z: Y AND Z. Y&Z is True(1) if Y is
:                            <> 0 and Z is <> 0.
:
:             Press Return for next page!
as:
t:$a$
:
:
:    !        OR        Y!Z: Y OR Z. Y!Z is True(1) if Y is
:                            <> 0 or Z is <> 0 or both are
:                            <> 0.
:
:   Due to some character sets some implementation use "^"
: as the logical negation operator (NOT).
:
:
:              Press Return for next page!    
as:
t:$a$
:
:                    String Operators
:
:     Concatenation is merging one string onto the right of
: another string. The Concatenation operator is a double
: exclamation point (!!).
:
:      i.e.
:
:      C: NAME$$ = "John Doe"
:      C: G$$ = "Hello "
:      C: A$$ = G$$!!NAME$$
:
:     Now A$$ will contain the string "Hello John Doe".
: Remember all strings must be dimensioned prior to use.
:
:               Press Return for Menu! 
:
as:
e:details
*dtfun
t:$a$
:
:                        FUNCTIONS
:
:
:     An expression can contain any of the built-in
: functions to carry out a numerical calculation or a
: string manipulation. Function arguments are enclosed
: in parentheses and immediately follow the function
: name. Multiple arguments are separated by a comma.
: These functions always return a number or a string
: value.
:
:
:
:            Press Return for next page!  
:
as:
t:$a$
:
:                      Arithmetic Functions
:
:
:  Example          Meaning                Illustration
:
:  C: Y=ABS(Z)      Absolute value of Z    ABS(5)=5
:
:  C: Y=ATN(Z)      Arctangent of Z in     ATN(1)=PI/4
:                   radians.
:
:  C: Y=COS(Z)      Cosine of Z in radians COS(PI)=-1
:
:  C: Y=EXP(Z)      E to the Z power       EXP(2.4)=11.02
:
:  C: Y=FIX(Z)      Truncate Z             FIX(7.5)=7
:
:  C: Y=INT(Z)      Integer _.<=Z          INT(3.2)=3
:
:              Press Return for next page!
as:
t:$a$
:
:  Example          Meaning                Illustration
:
:  C: Y=LOG(Z)      Base 10 logrithm of Z  LOG(10)=1
:
:  C: Y=LNE(Z)      Base E logrithm of Z   LN(10)=2.3026
:
:  C: Y=RND(Z)      Random number          If Z < 1 RND(Z)=
:                                          0 to -1. If Z =>
:                                          1 then RND(Z) =
:                                          an integer from
:                                          0 to Z -1.
:
:  C: Y=SGN(Z)      Sign of Z              -1 for Neg. Z
:                                           0 for Z=0
:                                           1 for Pos. Z
:
:  C: Y=SQR(Z)      Square root of Z        SQR(4)=2
:                                           SQR(25)=5
:              Press Return for next page!
as:
t:$a$
:
:                   STRING FUNCTIONS
:
: Example                Meaning
:
: C: Y=ASC(Z$$)          The result is a number from 0 to
:                        255. The value is the ASCII value
:                        of the first character in the $$.
:
: C: Y$$="THE"
: C: Z=ASC(Y$$)   Z=84
:
: C: Y$$=CHR(Z)          The result is the ASCII character
:                        of the number Z.
: C: Y$$=CHR(13)         Y$$ = a carriage return. ASCII 13.
:
:                Press Return for next page!
as:
t:$a$
:
:     The CHR function can be used to put screen and cursor
: control characters in a string, but definitions of these
: control characters vary with each terminal. The programmer
: should consult the ROM Kernal manual of Amiga or the Amiga
: 2000 and 500 manuals for control sequences for screen out-
: put.
:
: Example                Meaning
:
: C: Y=FLO(Z$$)          The result is the numeric value of
:                        the first number in Z$$.
:
: C: Z$$="I am 16 years and 2 months old"
: C: Y=FLO(Z$$)    Y=16
:
:
:                Press Return for next page!
as:
t:$a$
:
: Example                Meaning
:
:
: C: Y=LEN(Z$$)          The result is a number, the length of
:                        Z$$.
:
: C: Z$$="How long is this"
: C: Y=LEN(Z$$)    Y=16
:
: C: Y$$=STR(Z)          The result is the conversion of the
:                        floating-point or decimal number
:                        into a string. The format will be
:                        decimal if the number is within the
:                        limits for decimal numbers.
:                        Otherwise it will be in E notation.
:                        Only one STR function is allowed
:                        per expression.
:
:                     Press Return for Menu!
as:
e:details
*dtexpres
t:$a$
:
:                       EXPRESSIONS
:
:     Expressions are combinations of variables, operators,
: constants, and functions. These indicate the calculations
: or string manipulations that are to be performed. An ex-
: pression can be evaluated to yield a single value, either
: a number or a string. Remember that the operators must be
: the same type as the variable or constant.
:     For complex expressions a set of rules determine how
: the expression is evaluated. The rules are:
:
:     1. Sub-expressions in the inner most sets of paren-
: theses are evaluated first; these values then become oper-
: ands for the expression which contained those sets of
: parentheses.
: 
:               Press Return for next page!
as:
t:$a$
:
:     2. When the order of calculation is not set by paren-
: theses the operations are computed according to precedence
: as shown in the precedence table.
:
:     3. Operators of equal precedence are computed from
: left to right.
:
:
:               Press Return for Menu!
as:
e:details
*dtcond
t:$a$
:
:                    CONDITIONERS
:
:     A Conditioner is a single letter appended to an Op
: Code. Conditioners are valid on all op codes. The purpose
: of a Conditioner is to execute an instruction only if a
: certain condition is met. Any number or combination of
: Conditioners can be used with a single instruction, order
: is not important, but if more than one Conditioner is used
: all conditions must be met for the instruction to execute.
:     The four types of Conditioners are:
:
:      Yes and No Conditioners
:      Digit Conditioner
:      Error Conditioner
:      Last Relational Conditioner
:
:             Press Return for next page!
as:
t:$a$
:
:                 YES AND NO CONDITIONERS
:
:     These test the success of the last Match instruction
: executed. If the Match was successful (YES) then the Y
: Conditioner cause an instruction to execute. If the Match
: failed (NO) then the N Conditioner causes a instruction
: to execute.
:                              i.e.
:  T: How was the movie?
:  A:
:  M: Good
: TY: Well, then I'll go see it. (If the answer was good)
: JY:@P
:  M: Bad
: TY: Glad you told me. (Print this if the answer was bad)
: TN: Say what? (If answer doesn't match good or bad.)
:
:                 Press Return for next page!
as:
t:$a$
:
:                    DIGIT CONDITIONER
:
:     The Digit Conditioner executes an instruction based on
: the value of the answer count. Whenever an Accept in-
: struction is encountered its line number is compared to
: the last Accept. If it is the same the asnwer count is in-
: cremented. If not the answer count is reset to 1. Instuc-
: tions with a Digit Conditioner will execute only when the
: answer count equals the Digit Conditioner. The Digit Con-
: ditioner must be a number from 1 to 9.
:
:
:
:              Press Return for next page!
as:
t:$a$
:
:      i.e.
:            T: What's the best computer made?
:            A:
:            M: Amiga
:          TY1: Right! You're smart!
:          TY2: Well, you got it on your second try.
:           JY:out
:           J2:whoops
:            T: Not quite. Try again.
:            J:@A
:            *whoops
:            T: You blew it twice!
:            T: Go buy and Amiga and you'll find out!
:            J: wheretobuy
:
:            Press Return for next page!
as:
t:$a$
:
:
:     The Digit Conditioner is useful for scoring a user
: on the basis of how many times it takes to answer a
: question correctly. The answer counter can be accessed
: as system variable %A.
:
:
:
:
:             Press Return for next page!
as:
t:$a$
:
:                     ERROR CONDITIONER
:
:     The Error Conditioner causes an instruction to be
: executed only if the Error Condition was raised by the
: last instruction capable of raising it. It's raised by
: the following cases:
:
:     1. The last Accept contained a numeric variable, but
: no number was found in the users input.
:
:     2. A C: instruction contained an erroneous statement.
:
:     3. A Relational Expression contained an error.
:
:     4. When any error message is displayed.
:
:     Any successful C: instruction or any True relational
: expression will lower the error flag.
:
:              Press Return for next page!
as:
t:$a$
:
:             LAST RELATIONAL CONDITIONAL (C)
:
:     The C Conditional simplifies the use of Relational
: Expressions. Relational expressions cause a statement
: to be skipped based on the truth of the expression. When
: the same relational expression applies to several instruc-
: tions in a series, a C Conditioner can be used for the
: expression on all instructions but the first. The C Con-
: ditioner allows an instruction to be skipped if the last
: instruction for which a relational expression was
: evaluated was skipped.
:                              i.e.
:              T(A<18): Sorry, your too young.
:                   JC: Juveniles
:
:     The Type and Jump are both executed if, and only if,
: A is less than 18.
:
:               Press Return for Menu!
as:
e:details
*dtrelat
t:$a$
:               RELATIONAL EXPRESSIONS
:
:     Execution of any instruction can be made conditional
: based upon the truth of an expression coded in parentheses
: after the op code and before the colon. The expression can
: be arithmetic or relational. If the value of the expres-
: sion is True (1) the instruction is executed. If False (0)
: it is skipped. If Conditioners are tested first and the
: Conditioner causes the instruction to be skipped the
: relational expression is not evaluated. This is only
: crucial when using the C Conditioner on subsequent in-
: structions because a C Conditioner refers to the last
: relation tested. Relational expressions are subject to the
: same rules as expressions in the Compute instruction.
:
:         i.e.
:                T(A=17): So, you are 17. (Print this only
:                         if A=17.
:                  Press Return for Menu!
as:
e:details

*dtprec
t:$a$
:
:                     PRECEDENCE TABLE
:
:
:    OPERATOR                   ORDER
:
:    ~ or ^                  First Evaluated
:       :       * /
:       + - !!
:       = <> < > <= >=
:       ! &                  Last Evaluated
:
:
:                Press Return for Menu!
:
:
as:
e:details

  
