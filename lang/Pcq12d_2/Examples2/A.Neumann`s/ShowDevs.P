PROGRAM ShowDevices (input , output);

{
 [3;33m
  Programm       : Devices  - listet angemeldet Devices auf
  Sprache        : PCQ-Pascal 1.2b nach einem kleinen Hack von
                   mir in MCC-Pascal V2.04
  Autor          : Andreas Neumann für Purity
  Datum          : 01.03.1992
  [0;31m
}


{$I "Include:Exec/Exec.i"};
{$I "Include:Libraries/Dosextens.i"};
{$I "Include:Libraries/Filehandler.i"};
{$I "Include:Utils/DosUtils.I"}
{$I "Include:Utils/StringLib.i"}


CONST   Device_Types : Array [0..2] OF String = (("DEVICE     "),
                                                 ("DIRECTORY  "),
                                                 ("VOLUME     "));

VAR
    mydosbase    : DosLibraryPtr;
    myrootptr    : RootNodePtr;
    myinfoptr    : DosInfoPtr;
    mydeviceptr  : DeviceNodePtr;
    mystr        : String;
    eingabe      : CHAR;
    mystartup    : FileSysStartupMsgPtr;
    myenvec      : DOSEnvecPtr;
    i            : INTEGER;

BEGIN
 WRITELN;
 WRITELN ('Device-Lister PD © 1992 by Andreas Neumann (NEUDELSoft) für Purity');

 mydosbase:=Address(OpenLibrary (DOSNAME,0));

 { Man braucht ja die Adresse der DOSLibrary                      }

 myrootptr:=mydosbase^.dl_Root;
 myinfoptr:=BPTRtoAPTR (myrootptr^.rn_Info);
 mydeviceptr:=BPTRtoAPTR (myinfoptr^.di_DevInfo);

 { Man hangelt sich von Struktur zu Struktur                      }

 WHILE mydeviceptr<>NIL DO
 BEGIN
  WITH mydeviceptr^ DO
  BEGIN
   WRITELN;

   mystr:=Address(Integer(BPTRtoAPTR(dn_Name))+1);

   { Trick : dn_Name ist ein BSTR. Dies ist ein BPTR auf ein Feld, das }
   {         mit der Anzahl der Stringzeichen beginnt (daher +1) und   }
   {         dann die Zeichen enthält.                                 }

   WRITELN ('Name        : ',mystr,':');
   WRITELN ('Type        : ',Device_Types[dn_Type]);
   IF NOT (dn_Lock=Nil) THEN
    WRITELN ('auf diesem Device ist ein Lock')
   ELSE
    WRITELN;
   WRITELN;

   mystartup:=BPTRtoAPTR(dn_Startup);
   myenvec:=BPTRtoAPTR(mystartup^.fssm_Environ);

   IF (NOT(dn_Startup=Nil)) AND (dn_Type=DLT_DEVICE) AND (myenvec^.de_SizeBlock>0) THEN
   BEGIN

    {          es ist ein dateiorientiertes Device !!!             }
    {  im Gegensatz hierzu : ein logisches Device wie L: oder S:   }

    WRITELN ('Weiter Informationen zur Organisation des Devices : ');
    WITH myenvec^ DO
    BEGIN
     WRITELN;
     WRITELN ('Größe eines Sektors: ',de_SizeBlock*4,' Bytes');
     WRITELN ('Sektoren pro Block : ',de_SectorPerBlock);
     WRITELN ('Blocks pro Spur    : ',de_BlocksPerTrack);
     WRITELN ('Startzylinder      : ',de_LowCyl);
     WRITELN ('Endzylinder        : ',de_HighCyl);
     WRITELN ('Oberflächen        : ',de_Surfaces);

     i:=(de_HighCyl+1-de_LowCyl)*(de_Surfaces)*
         (de_BlocksPerTrack)*(de_SectorPerBlock)*(de_SizeBlock*4);

     { Anzahl der Zylinder * Anzahl der Oberflächen * Anzahl der Blöcke
        pro Spur * Anzahl der Sektoren pro Block * Größe eines
        Blockes * 4                                                     }

     WRITELN ('Speicherkapazität  : ',i,' Bytes    = ',i DIV 1024,' KBytes');
    END;
    WRITELN;
   END;
  END;

  WRITELN ('(W)eiter oder (S)top ?');
  READLN (eingabe);

  mydeviceptr:=BPTRtoAPTR(mydeviceptr^.dn_Next);
  IF (toupper(eingabe)='S') THEN mydeviceptr:=NIL;
 END;

 WRITELN ('Good Bye. NEUDELSoft wünscht noch viel Spaß mit Amiga und Pascal.');
 Delay (200);

END.


