

     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
     *                                                                 *
     *                      HeliOS Dictionary                          *
     *                                                                 *
     *                Copyright (c) 1995 A.R.Wharmby                   *
     *                                                                 *
     *                      26th October 1995                          *
     *                                                                 *
     *       The vocabulary included presents the core of HeliOS       *
     *       Forth-like functions and a few general HeliOS Amiga       *
     *       interface commands.  This set of functions allows         *
     *       the creation of programs running under AmigaDOS.          *
     *                                                                 *
     *       This document does not contain information on the         *
     *       HeliOS internal libraries or special game creation        *
     *       command set (See separate documentation).                 *
     *                                                                 *
     * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *


     -------------------------------------------------------------------
     ********************* DICTIONARY INTRODUCTION *********************
     -------------------------------------------------------------------

     HeliOS is a Forth-like threaded interpretive programming language.

     The central "core" command set of HeliOS is quite close, generally,
     to the widely used fig-Forth standard, so any instructional books
     which relate to Forth should be in many respects applicable to HeliOS.

     Most HeliOS Forth-like words conform to the Fig-Forth, but in a few
     cases the Forth-79 Standard is applicable.

     Although based on a Forth-type model, HeliOS has been so greatly
     expanded with Amiga-specific functions that the vast majority of
     HeliOS commands are, in fact, unique to HeliOS.

     HeliOS is also radically different to Forth in its internal workings,
     so in general you should not assume that what you have here is simply
     an expanded Forth system.

     HeliOS is perhaps best regarded as a unique threaded interpreter which
     runs a full sophisticated Forth emulation, but it is NOT a pure Forth
     system.

     Experienced Forth programmers will quickly be able to make full use of
     the excellent extended functionality of the HeliOS/Forth command set,
     but take care to study carefully HeliOS words which relate to the inner
     organisation of the language: it is here that you will find differences
     from standard Forth.

     Since the fundamental program structure and core functions of HeliOS
     are based on Forth, it is recommended that beginners make use of a
     good Forth introductory textbook such as STARTING FORTH by Leo Brodie,
     which is available in a paperback edition published by Prentice Hall.

     This Dictionary is designed for quick reference and is not intended
     as a full tutorial text in HeliOS Programming.  Nevertheless most of
     the Dictionary sections have, where appropriate, useful descriptive
     introductions.  It is a good idea to read this information at least
     once when you are first starting to learn HeliOS.

     Even experienced Forth programers will find that there are many new
     words in HeliOS which are additional to standard Forth systems, and a
     good way to learn these may be to read through the sections of the
     dictionary which relate to particular programming tasks which you are
     working on.  By doing this you will find enhanced HeliOS functions
     which may be used to supplement or in some cases replace conventional
     Forth words.

     The dictionary is ordered into groups of related words.

     Within each category words are ordered by ASCII value, or, where it is
     more appropriate, in terms of functional relationship.

----------------------------
ORDER OF DICTIONARY CONTENTS
----------------------------

         DICTIONARY INTRODUCTION

         ORDER OF DICTIONARY CONTENTS

         GENERAL NOTATION

         SYSTEM CONSTANTS

         SYSTEM VARIABLES

         LIBRARY BASE STORAGE VARIABLES

         LIBRARY NAMES

         LIBRARY CALLS

         MEMORY MANAGEMENT

         DATA STRUCTURES

         MESSAGES AND PORTS

         LINKED LISTS

         HELIOS STACK OPERATORS

         RETURN STACK OPERATORS

         BIT OPERATORS

         LOGICAL OPERATORS

         ARITHMETIC

         COMPARISONS AND TESTS

         MEMORY OPERATIONS

         COMPILATION AND DICTIONARY

         HELIOS INTERNALS

         DEFINING WORDS

         NUMERIC INPUT AND OUTPUT

         STRING OPERATORS

         TERMINAL I/O

         TOOLS

         SCREENS AND WINDOWS

         STRUCTURE CONTROL

         AMIGADOS AND FILING

         MOUSE, MENU, GADGET, and TICKER REPORTS

         GRAPHICS

         HELIOS MONOCHROME AND MULTICOLOURED BITMAPPED FONTS

         COPPER

         DEBUGGER

         NOTES

----------------
GENERAL NOTATION
----------------

    Here are some of the "shorthand" expressions used in the Dictionary:

    n1, n2 etc    = single length, 16-bit signed numbers.
    d1, d2 etc    = double length, 32-bit signed numbers.
    u1, u2 etc    = single length unsigned numbers.
    ud1, ud2 etc  = double length unsigned numbers.
    b1, b2 etc    = 8 bit (byte) data.
    c1, c2 etc    = ASCII characters.
    a1, a2 etc    = 16 bit memory addresses.
    l1, l2 etc    = 32-bit memory addresses.
    flag          = true or false flag, 1 or 0.
    pad           = 16 bit address of PAD.
    padl          = 32-bit address of PAD.
    <------>      = brackets enclose keyboard entry.
    "------"      = quotes enclose pronunciation convention.
    {------}      = {} enclose references to dictionary end notes.
    (      )      = () enclose stack effect comments.
    _ _ _         = execution point of word.
    cfa           = code field address of a HeliOS word.
    nfa           = name field address of a HeliOS word.
    pfa           = parameter field address of a HeliOS word.


    ---------------------------
    16-bit and 32-bit addresses
    ---------------------------

    Many words have been provided in 16-bit and 32-bit operational forms,
    usually because the 16-bit variant is a common standard Forth word.

    All 16-bit addresses must by default lie within the main dictionary
    memory space, but 32-bit addresses may lie anywhere in the Amiga's
    memory.

    It is easy to convert between 32-bit and 16-bit addressing using the
    simple commands "W>L" and "L>W", but do remember that any "external"
    32-bit addresses which do not lie within the dictionary memory space
    cannot be converted to 16-bit addresses.

    32-bit Addressing    Memory Space      16-bit Addressing
                             ->|
                             ->|
                             ->|
       All memory can be     ->|
       32-bit addressed,     ->|
       including HeliOS   ->|--|--|<- Start of HeliOS dictionary space
       dictionary space   ->|  |  |<-
                          ->|  |  |<- Only these HeliOS dictionary memory
                          ->|  |  |<- locations may be 16-bit addressed
                          ->|  |  |<-
                          ->|--|--|<- End of HeliOS dictionary space
                             ->|
                             ->|
                             ->|

    ----------------------
    16-bit and 32-bit data
    ----------------------

    A single stack cell is 16-bits wide, and all data stored in the HeliOS
    dictionary is word-aligned, so the natural default number size for most
    HeliOS operations is 16-bit.

    In general HeliOS works where possible with 16-bit integers for speed
    and compactness, but there is also complete support for using 8-bit
    and 32-bit numbers.

    In HeliOS, 32-bit numbers are often referred to as "double-numbers".

    A simple way of doing a conversion from signed 16-bit data on the
    stack to 32-bit data is to use the function "S->D" (single-to-double).

    A simple way of doing a conversion from unsigned 16-bit data on the
    stack to 32-bit data is simply to place an additional "0" on the stack.

    This works because the high word of any 32-bit value on the stack is
    always in the upper stack word position.

    e.g.
           Stack diagram for 16-bit value "3"  is        - - - 3
           Stack diagram for 32-bit value "3." is        - - - 3 0

    Make sure you understand this point clearly, because it is vital to
    be very fluent in handling and converting numbers on the stack.

    Note that in circumstances where 32-bit data actually has a value lower
    than its 16-bit counterpart, it is possible to convert from 32-bit to
    16-bit by merely using "DROP" to get rid of the high word of the 32-bit
    number on the stack.

    For example:

    -300.      Stack -> -300 -1
    DROP       Stack -> -300

    or

    300.       Stack -> 300 0
    DROP       Stack -> 300

    Obviously,however, you have to take care when converting from 32-bit to
    16-bit values in case truncation and data loss occur.

    -------------------------
    Specifying 32-bit numbers
    -------------------------

    When you enter a number (and HeliOS interprets the entered number) it
    is necessary to make a distinction between 32-bit and 16-bit numbers.

    A 32-bit number will need to be stored in two stack cells, but a 16-bit
    number will take only one cell.

    There is a convention in the way numbers are entered which specifies
    whether a number is 32-bit or 16-bit:

    *  In HeliOS, 32-bit numbers are specified by an included point (.),
       comma (,), or hyphen (-), character, which may be placed anywhere
       within the number string.

       Note that there may be any number of the above specifier characters
       included in the 32-bit numeric expression, and there may also be any
       combination of the different characters.

    For example:

    200   = 16-bit value 200
    200.  = 32-bit value 200
    2.00  = 32-bit value 200
    20-0  = 32-bit value 200
    .200  = 32-bit value 200
    2,0-0 = 32-bit value 200
    2-0,0 = 32-bit value 200
    2,0.0 = 32-bit value 200

    Obviously you would not normally use bizarre and confusing combinations
    of the specifier characters, but it may often be useful to use number
    strings in certain formats for special applications.  For example, to
    express a date you might use an expression like:

    20-04-95

    It is a convention that in normal circumstances the "." character is
    used when you merely wish to specify a 32-bit numeric entry.  In these
    circumstances, although the specifier character may be placed anywhere
    within the number string, it is usual to place it after the last digit.

    For example:

    200. = 32-bit value 200

    However, you may wish to express a 32-bit number in a form which also
    signifies a decimal value to a certain number of decimal places.

    In the next section we will briefly discuss decimal number entry.

    ---------------
    Decimal numbers
    ---------------

    HeliOS has a mechanism for interpreting 32-bit numbers entered with a
    "." as "decimal numbers", and this is managed by the simple expedient
    of remembering the position of the "decimal point".

    In order to facilitate the entry of decimals, HeliOS stores the number
    of characters AFTER the "." in a system variable called DPL.

    Thus, once a decimal number has been entered, it is possible to read
    DPL (using the expression "DPL @L") to discover how many decimal places
    were entered to the right of the decimal point.

    More than one "." may be included in a number, and if this is the case
    DPL will contain the number of characters after the last "." in the
    number string.

    (See DPL, NUMBER, #IN etc.)

    In addition to the "." character, the "-" and "," characters may also
    be used to specify decimal 32-bit numbers in exactly the same way.

    The ".",  "," and "-" characters may be used in any combination and
    are totally equivalent as far as HeliOS is concerned when interpreting
    decimal number strings.

    Thus, these could all be read as 32-bit decimal numbers:

    12-12-94       (DPL would contain 2)
    2,000,000      (DPL would contain 3)
    123.4567       (DPL would contain 4)
    12,234-12.6    (DPL would contain 1)

    ------------------
    Naming Conventions
    ------------------

    A convention has been adopted of using a "D" prefix for 32-bit data
    operators and a suffix of "L" for 32-bit addressed functions.

    Thus:   !       = Store  16-bit number in 16-bit address
           D!       = Store  32-bit number in 16-bit address
            !L      = Store  16-bit number in 32-bit address
           D!L      = Store  32-bit number in 32-bit address

----------------
SYSTEM CONSTANTS
----------------

    These are commonly used values which are coded as constants for speed.

    Some of these are strictly speaking no longer required if you use the
    new precompiled HeliOS include system, but have been retained for the
    sake of backward compatibility with old HeliOS programs.

     0                 ( _ _ _ n1 )   0 (16-bit value)

     0.                ( _ _ _ d1 )   0 (32-bit value)

     1                 ( _ _ _ n1 )   1

     2                 ( _ _ _ n1 )   2

     3                 ( _ _ _ n1 )   3

     4                 ( _ _ _ n1 )   4

     -1                ( _ _ _ n1 )   -1

     BL                ( _ _ _ n1 )   ASCII Blank

     COMPLEMENT        ( _ _ _ d1 )   RP_COMPLEMENT Drawmode.

     INVERSVID         ( _ _ _ d1 )   RP_INVERSVID Drawmode.

     JAM1              ( _ _ _ d1 )   RP_JAM1 Drawmode.

     JAM2              ( _ _ _ d1 )   RP_JAM2 Drawmode.

     MEMCHIP           ( _ _ _ d1 )   CHIP Memory Allocation.

     MEMCLEAR          ( _ _ _ d1 )   CLEAR Memory Allocation.

     MEMFAST           ( _ _ _ d1 )   FAST Memory Allocation.

     MEMLARGEST        ( _ _ _ d1 )   LARGEST Memory Allocation.

     MEMPUBLIC         ( _ _ _ d1 )   PUBLIC Memory Allocation.

     NEW               ( _ _ _ d1 )   MODE_NEWFILE

     OLD               ( _ _ _ d1 )   MODE_OLDFILE

     OFFSET_BEGINNING  ( _ _ _ d1 )   OFFSET_BEGINNING

     OFFSET_CURRENT    ( _ _ _ d1 )   OFFSET_CURRENT

     OFFSET_END        ( _ _ _ d1 )   OFFSET_END

     READWRITE         ( _ _ _ d1 )   MODE_READWRITE

----------------
SYSTEM VARIABLES
----------------

   Note that many variables are catalogued in the part of the dictionary to
   which they are most intimately related by context.

   ----------------
   16-Bit Addressed
   ----------------

   These variables are all accessed from a 16-bit address, but the actual
   variable values stored at the 16-bit address can be either 16-bit or
   32-bit in length, so take care.

    Name of     Size of     Returns 16-bit
    Variable    Variable    Variable Address

     ALTOUT      32-bit      ( _ _ _ a1 )   Contains ALT File Handle.

                                            If a file is opened and its
                                            handle placed in ALTOUT, HeliOS
                                            automatically sends all TYPED or
                                            EMITted output to this file, as
                                            well as the screen etc, when
                                            FILEON is used.

                                            See FILEON, FILEOFF, OPENALT,
                                                CLOSEALT, ALTERNATE.

     ARGLENGTH   16-bit      ( _ _ _ a1 )   Contains startup CLI arguments
                                            length.

     ARGS        32-bit      ( _ _ _ a1 )   Contains startup CLI arguments
                                            pointer.

     CAPS        16-bit      ( _ _ _ a1 )   Upper Case switch. (Default=1)

                                            If = 1, this causes automatic
                                            translation of HeliOS input to
                                            upper case.

                                            If = 0, disables translation to
                                            upper case.

     DOSERROR    32-bit      ( _ _ _ a1 )   Contains last DOS Error Return.

                                            After any DOS error HeliOS calls
                                            IOErr and updates DOSERROR.

     THISOUT     32-bit      ( _ _ _ a1 )   HeliOS task CLI output handle.


     THISTASK    32-bit      ( _ _ _ a1 )   HeliOS task control block.

------------------------------------------------------------------------

   ----------------
   32-Bit Addressed
   ----------------

   These variables are all accessed from a 32-bit address, but the actual
   variable values stored at the 32-bit address can be either 16-bit or
   32-bit in length, so take care.

     Name        Size of    Returns Longword
                 Variable   Variable Address

     >IN         32-bit      ( _ _ _ l1 )   Pointer to place in input stream.

     BASE        16-bit      ( _ _ _ l1 )   Current number base.

     BUF         16-bit      ( _ _ _ l1 )   Input Stream Specifier:

                                            0  = TIB = Command line
                                            1  = ED1 = Editor 1
                                            2  = ED2 = Editor 2
                                            -1 = ED3 = Editor 3
                                            -2 = OUT = OUT Editor
                                            3  = UserBuffer = SOURCESTART

     CURCOL      16-bit      ( _ _ _ l1 )   Cursor column.

     CURROW      16-bit      ( _ _ _ l1 )   Cursor row.

     DP          16-bit      ( _ _ _ l1 )   Dictionary pointer.

     DPL         16-bit      ( _ _ _ l1 )   Decimal point/place store.

     HLD         16-bit      ( _ _ _ l1 )   Pointer to last char converted
                                            in number formatting.

     OUT         32-bit      ( _ _ _ l1 )   Counter for output stream.

     SPAN        16-bit      ( _ _ _ l1 )   Number of chars input by EXPECTL.

     SP0         32-bit      ( _ _ _ l1 )   Start (NOT TOP!) of HeliOS Stack.

     STATE       16-bit      ( _ _ _ l1 )   System state flag.

     TIB         32-bit      ( _ _ _ l1 )   Terminal Input Buffer Address.

------------------------------
LIBRARY BASE STORAGE VARIABLES
------------------------------

     DOSBASE           ( _ _ _ a1 )   DOS Library.

     EXECBASE          ( _ _ _ a1 )   Exec Library.

     GFXBASE           ( _ _ _ a1 )   Graphics Library.

     INTUBASE          ( _ _ _ a1 )   Intuition Library.

     LAYERSBASE        ( _ _ _ a1 )   Layers Library.

     REQBASE           ( _ _ _ a1 )   Internal HeliOS "req.library"

                                      Contains the base address pointer
                                      for the internal HeliOS version of
                                      the Dawson-Fox "req.library".

                                      A special version of this library is
                                      contained within HeliOS and with care
                                      most of its routines can be used in
                                      your programs as specified in the
                                      documentation for the library.

     N.B.

     These are variables - they return the 16-bit address of the variable
     where the Library Base longword address is stored, NOT the library
     base addresses themselves.

     e.g. To get EXECBASE you would say "EXECBASE D@".

     These addresses are preloaded by HeliOS on startup.

-------------------------
HELIOS INTERNAL LIBRARIES
-------------------------

     DOSLIB              ( FunctionNumber - - - )

              Executes one of the auxiliary commands contained in the HeliOS
              DOS library, which contains functions for quickly loading and
              decrunching files, unpacking and parsing IFF files, displaying
              IFF files on screen etc..

              See "DOSLib.Doc" for details of specific commands.

     GADGETLIB           ( FunctionNumber - - - )

              Executes one of the auxiliary commands contained in the HeliOS
              Gadget library, which contains functions for manipulating
              Intuition gadgets and rendering gadget imagery etc..

              See "GadgetLib.Doc" for details of specific commands.

     GRAPHICSLIB         ( FunctionNumber - - - )

              Executes one of the auxiliary commands contained in the HeliOS
              Graphics library, which contains functions for handling Amiga
              GELS and general purpose blitter and display rendering etc..

              See "GraphicsLib.Doc" for details of specific commands.

     AUDIOLIB            ( FunctionNumber - - - )

              Executes one of the auxiliary commands contained in the HeliOS
              Audio library, which contains functions for handling Amiga
              sound samples and music.

              See "AudioLib.Doc" for details of specific commands.

-------------------
AMIGA LIBRARY CALLS
-------------------

     HeliOS has a simple and efficient method of calling Amiga libraries.

     This works very much like the method used in assembly language, and
     uses dummy "MC680xx register" variables for passing parameters.

     By referring to Amiga documentation for performing library calls in
     assembly language you will easily be able to perform the same process
     in HeliOS using virtually identical methods.

     The HeliOS words AREG and DREG return the 16-bit addresses of 32-bit
     "dummy MC680xx register" storage variables, each of which may then be
     preloaded with whatever values you wish to load into the corresponding
     MC680xx registers when the library call is made.

     For example, to load the value "150" into dummy register D2, use:

     150.  2  DREG  D!

     and to load the value "0" into dummy register A1, use:

     0.  1  AREG  D!

     After the library call is made HeliOS unloads all the real MC680xx
     registers back into the dummy variables so that a similar procedure
     can be used to read the returned values.

     For example, to get a value from dummy register D2, use:

     2  DREG  D@

     The storage area for the dummy register variables is organised as 16
     consecutive 32-bit cells, progressing from low memory to high memory
     in the order D0-D7 then A0-A7.

     The word REGS returns the 16-bit address of the base of this storage
     area for fast preloading if you require maximum speed and efficiency.

     The HeliOS word LIBRARY takes as its parameters a Library Base storage
     variable (16-bit address) and a 16-bit number representing the library
     offset on the HeliOS stack.

     These parameters are transferred into registers D7 and A6 and then the
     library call is made, after which the registers of the MC680xx are
     transferred back into the dummy register storage area.

     Note that because of this special internal use of registers D7 and A6,
     and also the internal use by HeliOS of register A7, the HeliOS library
     routines cannot be used to access library functions which require any
     parameters to be passed using these registers.  In this case (which is
     very unusual!) you would need to use the HeliOS in-line assembler to
     call the required library routine using pure assembler code.

     The word D0RESULT, returning the 32-bit contents of register D0 after
     the last library call, can be used to speed up the commonly required
     operation of getting the value in the dummy D0 register.

     For example:

     INTUBASE            \ Put on the stack the 16-bit address
                         \ where the 32-bit pointer to Intuition
                         \ library base is stored

     -294                \ Put on the stack the offset of the library
                         \ call "ViewAddress"

     LIBRARY             \ Call Intuition Library function to get
                         \ VIEW pointer

     D0RESULT            \ Get dummy register D0 value which is the
                         \ View address returned from the library call

     The above example used a directly coded value of "-294" for the
     Intuition "ViewAddress" function.

     This is fine if you happen to know the right offset, but this method
     is open to typing errors (and other mistakes) which are easy to make
     and hard to trace later.

     You would only use this method if you were wanting to write a program
     which did not make use of the HeliOS include system.

     If you are using the HeliOS include system to allow full symbolic name
     references within your program, it is much better to use a symbolic
     name for the function offset.

     For example:

     INTUBASE            \ Put on the stack the 16-bit address
                         \ where the 32-bit pointer to Intuition
                         \ library base is stored

     WORDINCLUDE         \ Set include system to return 16-bit values

     _LVOViewAddress     \ Put on the stack the offset of the library
                         \ call "ViewAddress" as a 16-bit value

     LONGINCLUDE         \ Reset include system to default 32-bit setting

     LIBRARY             \ Call Intuition Library function to get
                         \ VIEW pointer

     D0RESULT            \ Get dummy register D0 value which is the
                         \ View address returned from the library call

     See the documentation on the HeliOS include system for more information
     on using symbolic include values.

     *********
     IMPORTANT
     *********

     HeliOS also has a word called "LIBRARYL" which is used in a similar
     way to "LIBRARY" but note that it takes a 32-bit library function
     offset value and ITS PARAMETERS ARE IN REVERSE ORDER!

     Each of these two words is suitable for different circumstances, and
     you should be familiar with both of them.


     Using LIBRARYL our above example could be made even simpler:

     _LVOViewAddress     \ Put on the stack the offset of the library
                         \ call "ViewAddress" as a 16-bit value

     INTUBASE            \ Put on the stack the 16-bit address
                         \ where the 32-bit pointer to Intuition
                         \ library base is stored

     LIBRARYL            \ Call Intuition Library function to get
                         \ VIEW pointer

     D0RESULT            \ Get dummy register D0 value which is the
                         \ View address returned from the library call


     OPENLIB and CLOSELIB may be used to open and close libraries, as may
     be obvious, but it should be noted that they also make use of the
     HeliOS resource management system, which ensures that library closure
     is automatically carried out for you upon exit from HeliOS.



     AREG     ( n1 _ _ _ a1 )    n1 = 680xx A-Register Number
                                 a1 = 16-bit address where A-reg n1 is stored.

     CLOSELIB ( l1 _ _ _ )       l1 = Library Handle

                                 This will safely accept a null parameter.


     D0RESULT ( _ _ _ d1 )       d1 = Contents of reg D0 after LIBRARY call.


     DREG     ( n1 _ _ _ a1 )    n1 = 680xx D-Register Number
                                 a1 = 16-bit address where D-reg n1 is stored.


     LIBRARY  ( a1 n1 _ _ _ )    a1 = Library Base storage variable address.
                                 n1 = Library Offset (16-bit).

     LIBRARYL ( d1 a1_ _ _ )     d1 = Library Offset (32-bit).
                                 a1 = Library Base storage variable address.


     OPENLIB  ( a1 n1 _ _ _ l1 ) a1 = Library Name COUNTED string address.
                                 n1 = Revision Number.
                                 l1 = Library Handle. ( or 0 if failure )


     REGS     ( _ _ _ a1 )       a1 = Register storage area base address.


-----------------
MEMORY MANAGEMENT
-----------------

     HeliOS supports a comprehensive resource management system with its own
     resource lists, and operation of the system is transparent to the user.

     The HeliOS memory allocation routines are overseen by the resource
     management system, and any de-allocations which you fail to make will
     be remembered and de-allocated for you automatically when the HeliOS
     system closes down.

     The resource tracking lists are not generally accessible to the user,
     but the exception to this rule is the memory allocation list.

     The word LISTMEM is provided as a very simple method for the user to
     access the HeliOS memory allocation list without undue complication.

     LISTMEM displays a complete list of all addresses and sizes of each
     memory allocation, in order of allocation, since the HeliOS system was
     started up.  This can be very useful for general debugging purposes.

     Try typing "LISTMEM" at the command line to see all current memory
     allocations!

     The words ALLOCMEMORY and FREEMEMORY are self explanatory........

     Remember that all memory is automatically deallocated on exit from
     HeliOS, so if you have had problems with a program which result in
     allocated memory being left not de-allocated you can always tidy up
     by simply closing down HeliOS and restarting.


     ALLOCMEMORY   ( d1 d2 _ _ _ l1 )       d1 = Memory Amount Required.
                                            d2 = Mode. eg. PUBLIC, CLEAR etc
                                            l1 = Address of allocated memory.
                                                 or 0 for failure or error.


     FREEMEMORY    ( l1 _ _ _ )             l1 = Address of Memory Area.

                                            This routine will safely accept
                                            a null parameter.


     LISTMEM       ( _ _ _ )                Displays Memory Usage List.

                                            This is a very useful debugging
                                            aid, especially when used in
                                            conjunction with "OUT" editor.

                                            It allows you to inspect and
                                            compare all memory allocations
                                            before and after a program is
                                            executed.


---------------
DATA STRUCTURES
---------------

     HeliOS contains many general purpose functions which can be used to
     access and manipulate data structures.

     Most of these words are dealt with in their own sub-sections of the
     dictionary, and in particular it is important to read the section on
     general "MEMORY OPERATIONS".

     In the present section you can find a word to allocate data structures
     and a useful set of internal HeliOS pre-definable structure pointers.


     MAKESTRUCTURE ( d1 _ _ _ l1 or null )

       Allocates and clears a section of memory d1 bytes long and returns
       pointer to this memory as l1.

       Allocates fast memory, if available, before chip memory.


     SETSTRUCTURE1   ( StructurePointer(l) - - - )

       Sets up the first of the 16 internal HeliOS pointer-memory stores,
       after which "STRUCTURE1" etc. can be used to generate offsets into
       the given structure.

       See below for an explanation of how this works.

       See also:

       SETSTRUCTURE2
       SETSTRUCTURE3
       etc.
       etc.
       SETSTRUCTURE16

       All these are identical in form.


     STRUCTURE1      ( Offset(l) - - - StructureFieldPointer(l) )

       Adds the pointer stored in the first of the 16 internal HeliOS
       pointer-memory stores, STRUCTURE1, previously set up by using
       SETSTRUCTURE1, to the top 32-bit value on the HeliOS stack.

       This function effectively adds a pre-stored structure pointer to
       the top 32-bit number on the stack: this mechanism is designed for
       speed and does no checking whatever.

       For these functions to work you MUST already have a 32-bit value
       on the stack: if you do not, whatever 32-bit value IS on the top
       of the stack will be incremented.

       Here is an example:

       CREATEL MyStructure 100 ALLOT

       MyStructure SETSTRUCTURE1

       25. STRUCTURE1 \ <-- This will leave on top of the stack your initial
                            "25." added to the address of MyStructure.

                            i.e. The 32-bit address "MyStructure+25"

       See also:

       STRUCTURE2
       STRUCTURE3
       etc.
       etc.
       STRUCTURE16

       All these are identical in form.


------------------
MESSAGES AND PORTS
------------------

     These are convenient predefined HeliOS words to handle EXEC ports
     and messages etc..

     See the Amiga ROM Kernel manuals for details.

     ADDPORT       ( l1 - - - )             EXEC ADDPORT Function

                                            Port Address = l1


     CREATEEXTIO   ( d1 - - - l1 l2 )       Creates IO Ext. Req Block

                                            Block size  = d1 bytes
                                            Port Addr   = l1
                                            IOReq Block = l2

     N.B.

     IO Request total size = Block size = Allocated memory block.

     A message port is automatically created and initialised.

     To free these structures the port should be freed first with
     FREEMEMORY, followed by the IORequest structure.


     CREATEMSG     ( d1 - - - l1 )          Creates Message

                                            Message User Size = d1
                                            Message Pointer   = l1

     CREATEPORT    ( - - - l1 )             Creates Port

                                            Port = l1

     CREATESTDIO   (  - - - l1 l2 )         Creates IO Std. Req Block

                                            Port Addr   = l1
                                            IOReq Block = l2

     N.B.

     IO Request allocated memory = block size = 48 bytes.

     A message port is automatically created and initialised.

     To free these structures the port should be freed first with
     FREEMEMORY, followed by the IORequest structure.


     FINDPORT      ( l1 - - - l2 )          EXEC FINDPORT Function

                                            Port Name = l1 (uncounted string)
                                            Port Addr = l2
                                            (Returns 0. if port not found)


     GETMSG        ( l1 - - - l2 )          EXEC GETMSG Function

                                            Port     = l1
                                            Message  = l2
                                            (Returns 0. if no message present)


     PUTMSG        ( l1 l2 - - - )          EXEC PUTMSG Function

                                            Message Pointer  = l1
                                            Destination Port = l2


     REMPORT       ( l1 - - - )             EXEC REMPORT Function

                                            Port Address = l1


     REPLYMSG      ( l1 - - - )             EXEC REPLYMSG Function

                                            Message = l1


     WAITPORT      ( l1 - - - l2 )          EXEC WAITPORT Function

                                            Port Addr = l1
                                            Message   = l2

------------
LINKED LISTS
------------

     HeliOS uses an internal linked list "resource tracking" system, and
     makes available a small set of linked list operators for general use.

     These HeliOS linked lists can be used for any purpose you wish, but
     they have a special set of features which make them particularly useful
     for controlled multiple memory allocation and deallocation.

     When HeliOS closes down, all linked lists created using this system
     are automatically deallocated, although we recommend that you carry
     out your own deallocation as part of your general closedown routines.

     See the AMIGA operating system documentation for a complete discussion
     of linked lists, and note that HeliOS linked lists are constructed in
     an identical fashion to standard Amiga linked lists in terms of their
     linkage mechanism.

     See the Amiga ROM Kernel manuals for details about this.

     HeliOS linked lists have several extra features and associated HeliOS
     functions to allow then to be used in a generally more sophisticated
     manner than the simple Amiga OS lists, as explained below.

     ----------------------
     HELIOS LIST STRUCTURES
     ----------------------

     All fields in HeliOS linked lists are LONGWORDS

     Each list has a header structure just like an Amiga linked list:

     HEADER: LH_HEAD       --> Pointer to top node
             LH_TAIL       --> Always zero
             LH_TAILPRED   --> Pointer to last node

     Each list has a body consisting of a series of "nodes".

     Each list node has the following structure:

     NODE:   LN_SUCC       --> Next Node
             LN_PRED       --> Previous Node
             FIELD1        --> Actual data, or data pointer (See below)
             FIELD2        --> 0.,-1.,or SUBLIST HEADER (See below)

     All HeliOS linked list nodes have a simple linkage structure consisting
     of two pointers, exactly like Amiga operating system linked lists.

     All HeliOS list nodes have two 32-bit data fields, which we will call
     "FIELD1" and "FIELD2", which have various special functions.

     In general FIELD1 is the main data field and FIELD2 is concerned with
     deallocation sublists etc. (See below for more details).

     The important extra functionality of HeliOS linked list nodes is
     mainly concerned with how they are deallocated, but there are also
     useful words for accessing data structures associated with HeliOS
     linked lists.

     First let us look at the special deallocation mechanism.

     HeliOS linked list nodes are removed by a special function "REMNODE",
     which can intelligently carry out quite sophisticated deallocation
     functions based on the status of FIELD1 and FIELD2.

     The idea is that each node in a HeliOS linked list can be used to hold
     detailed information keeping track of complex memory allocations.  For
     example, when you open a certain element in one of your programs, you
     might need to allocate several data structures and buffers.  You can
     use a single HeliOS linked list node to keep track of every memory
     allocation associated with your new program element, then later simply
     deallocate everything with one call to REMNODE.

     This mechanism allows you to use each list node as a complex resource
     tracking control system, and can greatly simplify memory allocation
     and deallocation strategies.

     FIELD2 specifies the type of data node and determines the manner in
     which the node will be processed by the HeliOS REMNODE function, as
     follows:

     FIELD2 = 0.   Indicates that this is a memory allocation list, with
                   FIELD1 pointing to an allocated memory block.

                   REMNODE will deallocate the memory area pointed to by the
                   FIELD1 entry, before finally deallocating the node itself.

     FIELD2 = -1.  Indicates a simple list with FIELD1 containing a single
                   data item.

                   REMNODE will simply deallocate the node memory.

     FIELD2 = A pointer to a "sublist-header".

                   Any value in FIELD2 other than "-1.", or "0." will be
                   interpreted by HeliOS as a SUBLIST header.

                   The sublist contains housekeeping information about the
                   node, such as memory allocations etc.

                   The FIELD2 sublist contains a full ist of all memory
                   allocations associated with that data node.

                   In this case the use of FIELD1 is "free", and FIELD1
                   might point perhaps to a data area, or it may be a
                   simple data item.

                   Often FIELD1 will point to a data structure, and there
                   are special HeliOS functions which can access this data
                   structure given a pointer to the list node.

                   See below for more details.


     Creating a memory allocation tracking "sublist" is very easy, since
     this list is just a simple first order HeliOS linked list which has
     all the allocated memory blocks pointed to by FIELD1 of its nodes.

     It is easy to set up this kind of list using the HeliOS linked list
     commands described below.

     The header of this "sublist" must then be entered as FIELD2 of the main
     "primary" list node.  If this sublist pointer is found in the primary
     node FIELD2 by "REMNODE", the sublist will be deallocated automatically
     along with all the memory allocation references contained within it,
     before the main node is deallocated.

     This system can be very useful when creating routines which require
     multiple allocations. Each new memory allocation is added to your
     tracking sublist as it is successfully completed.  If it should occur
     that some allocation later in your routine fails, all you have to do
     to exit gracefully is issue one "REMNODE" command to deallocate
     everything. This can greatly simplify your error return routines.

     Here is an example of how the main list and sublist are set up:

     ---------
     MAIN LIST
     ---------

     LIST HEADER
     +
     NODE:   LN_SUCC   --> Next node in main list
             LN_PRED   --> Previous node in main list
             FIELD1    --> Pointer to a data structure
             FIELD2    --> Pointer to memory allocation sublist "SUBLIST1"

     etc. etc.

     --------
     SUBLIST1
     --------

     LIST HEADER
     +
     NODE:   LN_SUCC   --> Next node in sublist
             LN_PRED   --> Previous node in sublist
             FIELD1    --> Pointer to memory allocation
             FIELD2    --> NULL

     etc. etc.


     See below within the word definitions for more details of the use of
     FIELD1 and FIELD2.

     -----------------------------------------------------------------------

     $GETNODE      ( d1 n1 d2 - - - d3 )

                   Tries to find a node in list d2, whose FIELD1 value
                   matches data defined by d1 and n1 as explained below.

                   The value n1 will be used as an offset into a data
                   structure pointed to by FIELD1, and a match will be
                   sought between a string pointed to by d1 and a string
                   stored at the address pointed to by FIELD1 + n1.

                   The two strings may be counted or uncounted, since they
                   are compared on a simple byte by byte basis up to a null
                   terminator.

                   Note that both strings must be the same type (counted or
                   uncounted) and both nust be null terminated.

                   Null strings will return FAILURE.

                   Returns node pointer d3, or null for failure.

     ADDNODE       ( d1 d2 d3 - - - d4 )

                   Adds a new list node to list d3, with Field1 and Field2
                   values of d1 and d2.  Returns node pointer d4, or null.

     DATA!         ( d1 d2 n1 - - - )

                   d1 = Data to be stored
                   d2 = List Node Pointer
                   n1 = Offset into data structure pointed to by FIELD1

                   Stores longword data d1 at an address derived by taking
                   the FIELD1 pointer of node d2, and adding offset n1.

                   Used for quickly accessing offsets into data structures.

                   Don't try using it on simple lists when FIELD1 contains
                   data rather than a pointer!

     DATA@         ( d1 n1 - - - d2 )

                   d1 = List Node Pointer
                   n1 = Offset into data structure pointed to by FIELD1
                   d2 = Longword Data

                   Returns longword data d2 stored at an address derived by
                   taking the FIELD1 pointer of node d1 and adding offset n1.

                   Used for quickly accessing offsets into data structures.

                   Don't try using it on simple lists when FIELD1 contains
                   data rather than a pointer!

     DATAFIELD     ( d1 n1 - - - l1 )

                   d1 = List Node Pointer
                   n1 = Offset into data structure pointed to by FIELD1
                   l1 = Data Pointer

                   Returns pointer l1 to the address derived by taking the
                   FIELD1 pointer of node d1, and adding offset n1.

                   Used for accessing offsets into data structures.

                   Don't try using it on simple lists when FIELD1 contains
                   data rather than a pointer!

     GETNODE       ( d1 n1 d2 n2 - - - d3 )

                   Tries to find a node in list d2, whose FIELD1 value
                   matches data defined by d1, n1 and n2 as explained below.

                   If n1 is -1, a search will be made for a node whose
                   FIELD1 value is equal to d1, and n2 will be ignored.

                   If n1 > 0, n1 will be used as an offset into a data
                   structure pointed to by FIELD1, and a match will be
                   sought between d1 and the data stored at the address
                   pointed to by FIELD1 + n1.

                   In this case:

                   If n2 > 0  A match is sought between data pointed to by
                              the address in d1 and data pointed to by
                              FIELD1 + n1.

                              n2 defines the length of the data over which
                              a match is sought i.e. how many bytes to match.

                   If n2 < 0  The longword at the data address pointed to by
                              FIELD1 + n1 will be matched against the actual
                              value d1 rather than data pointed to by d1.

                   If n2 = 0  a FAILURE will be returned.

                   Returns node pointer d3, or null for failure.

     MAKENODE      ( d1 n1 - - - d2 )

                   Used for creating ready initialised complex nodes.

                   Takes list header in d1 and creates a new node, linking
                   it into the list.

                   The value n1 determines the size of the data area pointed
                   to by FIELD1 of the node.  This data area is allocated
                   and cleared ready for use, and a pointer to it is placed
                   in FIELD1.

                   A sublist is set up with its header pointer in FIELD2
                   ready to add further node-related memory allocations.

                   Returns d2 as new node pointer or 0 for FAILURE.

     NEWLIST       ( - - - d1 )

                   Creates a new list header and returns pointer as d1.
                   Returns 0 for FAILURE.

     NEXTNODE      ( d1 - - - d2 )

                   Takes a node pointer d1 and returns pointer to next node
                   in list as d2.

                   Returns null if d1 is the last node in the list.

     PREVNODE      ( d1 - - - d2 )

                   Takes a node pointer d1 and returns pointer to prior node
                   in list as d2.

                   Returns null if d1 is the first node in the list.

     REMNODE       ( d1 - - - )

                   Removes list node d1.

                   Intelligently deallocates all memory associated with the
                   node and any sublist present.

                   This routine will safely accept a null parameter.

     SUBLIST       ( d1 - - - d2 )

                   Takes node pointer d1, and returns sublist pointer d2.

----------------------
HELIOS STACK OPERATORS
----------------------

    These functions are really vital components of the "engine room" at
    the heart of all HeliOS programs.

    It cannot be stressed too much that you should become familiar with as
    many of the words in this section as possible.

    There may seem to be an awful lot of stack operators, but they are very
    easy to use and learn, and are very, very important in the production
    of efficient and readable code.

    Use these words to MINIMISE THE NUMBER OF STACK MANIPULATIONS which
    you employ.

    DO NOT write long strings of DUPs and SWAPs and ROTs, as this produces
    grotesquely unreadable code and is very inefficient.

    Stack control words are necessary, but they contribute exactly nothing
    to the real work of getting the logical task done: they are actually an
    undesirable OVERHEAD of any Forth based system.

    Use ONE stack control word, if possible, instead of several.

    N.B.

    ALL these HeliOS stack management words are machine coded for speed, as
    distinct from most Forth systems, where words like ROLL, for example, if
    they are present at all, are often inefficiently coded in Forth.

    On old Forth systems most specialised stack control words were coded
    in Forth and were relatively slow, and this rightly led to their use
    being generally condemned as somewhat inefficient.

    However, in HeliOS ALL THE STACK MANAGEMENT WORDS ARE MACHINE CODED AND
    ULTRA EFFICIENT, so use the words which give you SIMPLEST operation.

    Good HeliOS programming starts (and often stops!) here, so really get
    to know these words so that their use becomes second nature.

    It is a good idea to set yourself up a dummy stack in "Interactive" mode
    and play with any words you are not sure of until you see clearly how
    they work.


     -ROLL ( nx..n1..b _ _ nx..n1..n2 ) Rotate TOS to bth place on stack.

     -ROT  ( n1 n2 n3 _ _ n3 n1 n2)  Rotate TOS to third on stack.

     .S    ( _ _ )                   Print current stack contents.

     ?DUP  ( n1 _ _ n1 n1 or 0 )     Duplicates n1 only if non zero.

     3DROP ( n1 n2 n3 _ _ )          Remove 3 numbers from top of stack.

     3DUP  ( n1 n2 n3 _ _ n1 n2 n3 n1 n2 n3 )  Duplicate top 3 numbers.

     3NIP  ( n1 n2 n3 _ _ n2 n3 )    Remove third number on stack.

     3PICK ( n3 n2 n1 _ _ n3 n2 n1 n3 ) Duplicate third number on stack.

     3TUCK ( n1 n2 n3 _ n3 n1 n2 n3) Tuck top number under third number.

     D-ROT ( d1 d2 d3 _ _ d3 d1 d2)  Rotate TOS d-number to third on stack.

     D3NIP ( d1 d2 d3 _ _ d2 d3 )    Remove third double number on stack.

     D3PICK ( d3 d2 d1 _ _ d3 d2 d1 d3 ) Duplicate third double number on stack.

     D3TUCK ( d1 d2 d3 _ d3 d1 d2 d3) Tuck top d-number under third d-number.

     DDDROP( d1 d2 _ _ )             Remove two d-numbers from top of stack.

     DDDUP ( d1 d2 _ _ d1 d2 d1 d2 ) Duplicate two double numbers.

     DDROP ( d1 _ _ )                Remove double number on top of stack.

     DDROPS ( db....d1 b _ _ )       Remove b double numbers from stack.

     DDSWAP( d1 d2 d3 d4 _ _ d3 d4 d1 d2 ) Swap two pairs of double numbers.

     DDUP  ( d1 _ _ d1 d1 )          Duplicate double number.

     DDUPS ( d1 n1 _ _ d1...d1 )     Duplicate double number n1 times.

     DEPTH ( nx..n1 _ _ nx..n1 x )   Return 16-bit number of items on stack.

     DFLAG ( d1 _ _ d1 flag )        If d1<>0, flag=1. If d1=0, flag=0.

     DFLAG0= ( d1 _ _ d1 flag )      If d1<>0, flag=0. If d1=0, flag=1.

     DNIP  ( d1 d2 _ _ d2 )          Remove second double number on stack.

     DOVER ( d1 d2 _ _ d1 d2 d1 )    Duplicate second on stack double number.

     DPACK ( dn..d1 dx b _ _ dn..db..d1 ) Store dx at bth place on stack (=db)
                                  ^              |
                                  |              |
                                  ----------------

     DPICK ( dx..d1 b _ _ dx..d1 db) Duplicate bth d-number on stack.

     DROP  ( n1 _ _ )                Remove number on top of stack.

     DROPS ( nb....n1 b _ _ )        Remove b numbers from stack.

     DROT  ( d1 d2 d3 _ _ d2 d3 d1 ) Rotate third stack double number to TOS.

     DSWAP ( d1 d2 _ _ d2 d1 )       Swap two double numbers.

     DTRIP ( d1 _ _ _ d1 d1 d1 )     Triple top stack double number.

     DTUCK ( d1 d2 _ _ d2 d1 d2 )    Tuck top double number under 2nd d-number.

     DUNDER+( d1 d2 dx _ _ d1+dx d2 ) Add top of stack to third on stack.

     DUNDER-( d1 d2 dx _ _ d1-dx d2 ) Subtract top of stack from third.

     DUP   ( n1 _ _ _ n1 n1 )        Duplicate number on top of stack.

     DUPS  ( n1 n2 _ _ _ n1...n1 )   Duplicate number n2 times

     FLAG0= ( n1 _ _ n1 flag )       If n1<>0, flag=0. If n1=0, flag=1.

     L>W   ( l1 _ _ a2 )             Change Longword address to Word address.

     NIP   ( n1 n2 _ _ n2 )          Remove second number on stack.

     OVER  ( n1 n2 _ _ n1 n2 n1 )    Duplicate second number on stack.

     OVER= ( n1 n2 _ _ n1 flag )     Compares n1 to n2, leaving n1 and flag.

     PACK  ( ny..n1 nx b _ _ ny..nb..n1 ) Store nx at bth place on stack (=nb)
                                  ^              |
                                  |              |
                                  ----------------

     PICK  ( nx..n1 b _ _ nx..n1 nb) Duplicate bth number on stack.

     ROLL  ( nx..n1 b _ _ nx-1..n1 nb ) Rotate bth number on stack to TOS.

     ROT   ( n1 n2 n3 _ _ n2 n3 n1 ) Rotate third on stack to TOS.

     S!    ( l1 _ _ )                Sets HeliOS stack pointer to l1.

     S->D  ( n1 _ _ d1 )             Convert TOS number to double number.

     S0    ( _ _ d1 )                Return 32-bit address of start of stack.

     SP!   ( nx..n1 _ _ )            Clear stack of all items.

     SP@   ( _ _ l1 )                Return l1 = current stack position.

     SWAP  ( n1 n2 _ _ n2 n1 )       Swap top two stack numbers.

     TRIP  ( n1 _ _ _ n1 n1 n1 )     Triple top stack number.

     TUCK  ( n1 n2 _ _ n2 n1 n2 )    Tuck top number under second number.

     UNDER+( n1 n2 x _ _ n1+x n2 )   Add top of stack to third on stack.

     UNDER-( n1 n2 x _ _ n1-x n2 )   Subtract top of stack from third on stack.

     W>L   ( a1 _ _ l2 )             Change Word address to Longword address.


----------------------
RETURN STACK OPERATORS
----------------------

     Like traditional Forth, HeliOS has a secondary stack called the RETURN
     stack, and this is basically used for internal purposes and should be
     treated with caution.

     The RETURN stack can be used as a fast auxiliary data storage space
     for "local" data during the execution of a colon definition.  However,
     you MUST ensure that the state of the RETURN stack is left unchanged
     overall, and that it is restored to exactly the same status at the end
     of any colon definition function as it had when the function started.

     There are easy to use and very fast words for moving data between
     the HeliOS stack and the RETURN stack, in both directions.

     The RETURN stack has the useful property that within loop constructs
     it stores the loop index and loop limit: this means that you can use
     the RETURN stack to get loop indices and generally manipulate loops
     in special ways.

     The use of the RETURN stack in HeliOS is very similar to Forth from
     the programmers point of view, and in many ways HeliOS seems to be
     using the RETURN stack exactly like Forth.  However, HeliOS does in
     fact use the RETURN stack internally in special ways, so do not assume
     that standard Forth usage is applicable unless specifically stated.


     >R    ( n1 _ _ )         Move top of stack onto return stack.

     D>R   ( d1 _ _ )         Move top of stack d-number onto return stack.

     DDUP>R ( d1 _ _ d1 )     DDUP and move tos d-number onto return stack.

     DI    ( _ _ d1 )         Get copy of top d-number from return stack.

     DI'   ( _ _ d1 )         Get copy ofsecond d-number on return stack.

     DJ    ( _ _ d1 )         Get copy of third d-number on return stack.

     DJ'   ( _ _ d1 )         Get copy of fourth d-number on return stack.

     DR>   ( _ _ d1 )         Remove top r-stack d-number onto HeliOS stack.

     DUP>R ( n1 _ _ n1 )      DUP and move top of stack onto return stack.

     I     ( _ _ n1 )         Get copy of top number on return stack.
                                       ( = 1st loop index. )
     I'    ( _ _ n1 )         Get copy of second number on return stack.
                                       ( = 1st loop limit. )
     J     ( _ _ n1 )         Get copy of third number on return stack.
                                       ( = 2nd loop index. )
     J'    ( _ _ n1 )         Get copy of fourth number on return stack.
                                       ( = 2nd loop limit. )
     K     ( _ _ n1 )         Get copy of fifth number on return stack.
                                       ( = 3rd loop index. )
     K'    ( _ _ n1 )         Get copy of sixth number on return stack.
                                       ( = 3rd loop limit. )
     R>    ( _ _ n1 )         Remove top of return stack onto HeliOS stack.

     R!    ( l1 _ _ )         Sets Return stack pointer to l1.

     RP!   ( _ _ )            Initialise return stack.

     RP@   ( _ _ l1 )         Return address of current return stack top.

-------------
BIT OPERATORS
-------------

     These operators are self-explanatory, but note that they preserve
     a copy of the source data in all cases.

     BCLR  ( n1 b _ _ n2 )         Clear bit b of n1, and return result n2.
     BSET  ( n1 b _ _ n2 )         Set bit b of n1, and return result n2.
     BTST  ( n1 b _ _ n1 flag )    Test bit b of n1, and return flag.
     DBCLR ( d1 b _ _ d2 )         Clear bit b of d1, and return result d2.
     DBSET ( d1 b _ _ d2 )         Set bit b of d1, and return result d2.
     DBTST ( d1 b _ _ d1 flag )    Test bit b of d1, and return flag.

-----------------
LOGICAL OPERATORS
-----------------

     AND   ( n1 n2 _ _ n3 )          Return n3 = n1 AND n2. ( 16-bit AND )

     ASL   ( n1 n2 _ _ n3 f)         Arithmetic Shift Left n1, n2 times, to
                                     leave n3 and sign change flag f.

                                     f=1 for changed sign bit
                                     f=0 for unchanged sign bit

     ASR   ( n1 n2 _ _ n3 )          Arithmetic Shift Right n1, n2 times, to
                                     leave n3.

     DAND  ( d1 d2 _ _ d3 )          Return d3 = d1 AND d2. ( 32-bit AND )

     DASL  ( d1 n1 _ _ d2 f)         Arithmetic Shift Left d1, n1 times, to
                                     leave d2 and sign change flag f.

                                     f=1 for changed sign bit
                                     f=0 for unchanged sign bit

     DASR  ( d1 n1 _ _ d2 )          Arithmetic Shift Right d1, n1 times, to
                                     leave d2.

     DLSL  ( d1 n1 _ _ d2 )          Logical Shift Left d1, n1 times, to
                                     leave d2.

     DLSR  ( d1 n1 _ _ d2 )          Logical Shift Right d1, n1 times, to
                                     leave d2.

     DOR   ( d1 d2 _ _ d3 )          Return d3 = d1 OR d2. ( 32-bit OR )

     DXOR  ( d1 d2 _ _ d3 )          Return d3 = d1 XOR d2. ( 32-bit XOR )

     LSL   ( n1 n2 _ _ n3 )          Logical Shift Left n1, n2 times, to
                                     leave n3.

     LSR   ( n1 n2 _ _ n3 )          Logical Shift Right n1, n2 times, to
                                     leave n3.

     OR    ( n1 n2 _ _ n3 )          Return n3 = n1 OR n2. ( 16-bit OR )

     XOR   ( n1 n2 _ _ n3 )          Return n3 = n1 XOR n2. ( 16-bit XOR )


----------
ARITHMETIC
----------

 SINGLE LENGTH OPERATORS


     *             ( n1 n2 _ _ _ n3 )

                   Multiplies n1 by n2 and returns product n3.

                   If overflow occurs, n3 contains least significant
                   16-bits of product.

     +             ( n1 n2 _ _ _ n3 )

                   Returns the sum of n1 + n2 = n3.

     +-            ( n1 n2 _ _ _ n3 )

                   Apply the sign of n2 to n1 returning the result as n3.

     -             ( n1 n2 _ _ _ n3 )

                   Returns the difference of n1 - n2 = n3.

     /             ( n1 n2 _ _ _ n3 )

                   Returns the signed quotient of n1/n2 = n3.

     /MOD          ( n1 n2 _ _ _ n3 n4 )

                   Returns remainder n3 and signed quotient n4 of n1/n2,
                   the remainder having the sign of the dividend.

     1+            ( n1 _ _ _ n2 )

                   Returns n1 incremented by 1 as n2.

     1-            ( n1 _ _ _ n2 )

                   Returns n1 decremented by 1 as n2.

     2*            ( n1 _ _ _ n2 )

                   Returns n1 * 2 as n2.

     4*            ( n1 _ _ _ n2 )

                   Returns n1 * 4 as n2.

     2+            ( n1 _ _ _ n2 )

                   Returns n1 incremented by 2 as n2.

     2-            ( n1 _ _ _ n2 )

                   Returns n1 decremented by 2 as n2.

     2/            ( n1 _ _ _ n2 )

                   Returns n1/2 as n2.

     4/            ( n1 _ _ _ n2 )

                   Returns n1/4 as n2.

     ABS           ( n1 _ _ _ n2 )

                   Returns the absolute value of n1 as n2.

     MOD           ( n1 n2 _ _ _ n3 )

                   Returns the remainder of n1/n2 as n3, with same sign
                   as n1.

     NEGATE        ( n1 _ _ _ n2 )

                   Returns the twos complement of n1 as n2.

-------------------------------------------------------------------------------

 DOUBLE LENGTH OPERATORS


     D+            ( d1 d2 _ _ _ d3 )

                   Returns the double number sum d3 = d1 + d2.

     D+-           ( d1 d2 _ _ _ d3 )

                   Apply the sign of d2 to d1, returning result as d3.

     D-            ( d1 d2 _ _ _ d3 )

                   Returns the double number difference d3 = d1 - d2.

     D2*           ( d1 _ _ _ d2 )

                   Returns d1 * 2 as d2.

     D4*           ( d1 _ _ _ d2 )

                   Returns d1 * 4 as d2.

     D1+           ( d1 _ _ _ d2 )

                   Returns d1 incremented by 1 as d2.

     D1-           ( d1 _ _ _ d2 )

                   Returns d1 decremented by 1 as d2.

     D2+           ( d1 _ _ _ d2 )

                   Returns d1 incremented by 2 as d2.

     D2-           ( d1 _ _ _ d2 )

                   Returns d1 decremented by 2 as d2.

     D2/           ( d1 _ _ _ d2 )

                   Returns d1/2 as d2.

     D4/           ( d1 _ _ _ d2 )

                   Returns d1/4 as d2.

     DABS          ( d1 _ _ _ d2 )

                   Returns the absolute value of double number d1 as d2.

     DNEGATE       ( d1 _ _ _ d2 )

                   Returns the double number twos complement of d1 as d2.

-------------------------------------------------------------------------------

 MIXED LENGTH OPERATORS


     */            ( n1 n2 n3 _ _ _ n4 )

                   Multiplies n1 by n2 and divides by n3 returning quotient
                   n4.

                   The product of n1 and n2 is maintained as a 31-bit number
                   when processing for greater accuracy.

     */MOD         ( n1 n2 n3 _ _ _ n4 n5 )

                   Carries out n1*n2/n3 maintaining the interim result in
                   32-bit signed format.

                   The quotient n5 and remainder n4 are returned.

     *ASR          ( n1 n2 n3 _ _ _ n4 )

                   Multiplies n1 by n2, then does n3 ASR operations on the
                   intermediate double number product before reconverting
                   to a single number n4.

     M*            ( n1 n2 _ _ _ d1 )

                   Returns the double number signed product of n1 * n2 = d1.

     M*/           ( d1 n1 n2 _ _ _ d2 )

                   Multiplies d1 by n1 and divides by n2 returning quotient
                   d2.

     M+            ( d1 n1 _ _ _ d2 )

                   Returns the double number sum of a single and a double
                   number.

     M-            ( d1 n1 _ _ _ d2 )

                   Returns the double number difference between a single and
                   a double number.

     M/            ( d1 n1 _ _ _ n2 )

                   Returns the signed single number quotient of the mixed
                   magnitude division of d1 by n1.

     M/MOD         ( d1 n1 _ _ _ n2 n3 )

                   Returns the signed remainder and quotient, n2 and n3, of
                   the division d1/n1.

                   The remainder n2 takes its sign from d1.

     U*            ( u1 u2 _ _ _ ud1 )

                   Returns the unsigned double number product of two
                   unsigned single numbers.

     U*/           ( u1 u2 u3 _ _ _ u4 )

                   Multiplies u1 by u2 and divides by u3 returning quotient
                   u4.

                   The product of u1 and u2 is maintained as a 32-bit
                   number when processing for greater accuracy.

     U*LSR         ( u1 u2 u3 _ _ _ u4 )

                   Returns the unsigned single number result of multiplying
                   two unsigned single numbers into a double number, then
                   carrying out u3 LSR operations on the double number,
                   then converting it to a single number and returning it
                   on the stack as u4.

     U/            ( ud1 u1 _ _ _ u2 )

                   Returns the unsigned quotient u2 of the division ud1/u1.

     U/MOD         ( ud1 u1 _ _ _ u2 u3 )

                   Returns the unsigned remainder and quotient, u2 and u3,
                   of the division ud1/u1.

     UM/DMOD       ( ud1 u1 _ _ _ u2 ud2 )

                   Returns the unsigned remainder and quotient, u2 and ud2,
                   of the division ud1/u1.

---------------------
COMPARISONS AND TESTS
---------------------

     Signed comparisons:

     <             ( n1 n2 _ _ _ flag )
     <=            ( n1 n2 _ _ _ flag )
     <>            ( n1 n2 _ _ _ flag )
     =             ( n1 n2 _ _ _ flag )
     >             ( n1 n2 _ _ _ flag )
     >=            ( n1 n2 _ _ _ flag )
     D<            ( d1 d2 _ _ _ flag )
     D<=           ( d1 d2 _ _ _ flag )
     D<>           ( d1 d2 _ _ _ flag )
     D=            ( d1 d2 _ _ _ flag )
     D>            ( d1 d2 _ _ _ flag )
     D>=           ( d1 d2 _ _ _ flag )

     Unsigned comparisons:

     DU<           ( ud1 ud2 _ _ _ flag )
     DU<=          ( ud1 ud2 _ _ _ flag )
     DU>           ( ud1 ud2 _ _ _ flag )
     DU>=          ( ud1 ud2 _ _ _ flag )
     U<            ( u1 u2 _ _ _ flag )
     U<=           ( u1 u2 _ _ _ flag )
     U>            ( u1 u2 _ _ _ flag )
     U>=           ( u1 u2 _ _ _ flag )

     Top of stack represents second quantity in comparison.

     Example:

     <   Executed with stack ( n1 n2 _ _ _ ) returns flag signalling truth
         of statement " n1 < n2 ".



     Zero comparisons:

     0<            ( n1 _ _ _ flag )

     0<>           ( n1 _ _ _ flag )

     0=            ( n1 _ _ _ flag )

     0>            ( n1 _ _ _ flag )

     D0<           ( d1 _ _ _ flag )

     D0<>          ( d1 _ _ _ flag )

     D0=           ( d1 _ _ _ flag )

     D0>           ( d1 _ _ _ flag )

     Compare number against zero.



     Signed maximum and minimum number value selection:

     MAX           ( n1 n2 _ _ _ n1 or n2 )

     MIN           ( n1 n2 _ _ _ n1 or n2 )

     DMAX          ( d1 d2 _ _ _ d1 or d2 )

     DMIN          ( d1 d2 _ _ _ d1 or d2 )

     Return the minimum or maximum of two signed values on stack.



     Unsigned maximum and minimum number value selection:

     UMAX          ( u1 u2 _ _ _ u1 or u2 )

     UMIN          ( u1 u2 _ _ _ u1 or u2 )

     DUMAX         ( ud1 ud2 _ _ _ ud1 or ud2 )

     DUMIN         ( ud1 ud2 _ _ _ ud1 or ud2 )

     Return the minimum or maximum of two unsigned values on stack.



     Signed number range tests:

     WITHIN        ( n1 n2 n3 _ _ _ flag )

     Test to see if n1 lies in the range n2 to n3 inclusive.

     DWITHIN       ( d1 d2 d3 _ _ _ flag )

     Test to see if d1 lies in the range d2 to d3 inclusive.



     Unsigned number range tests:

     UWITHIN       ( u1 u2 u3 _ _ _ flag )

     Test to see if u1 lies in the range u2 to u3 inclusive.

     DUWITHIN      ( ud1 ud2 ud3 _ _ _ flag )

     Test to see if ud1 lies in the range ud2 to ud3 inclusive.


-----------------
MEMORY OPERATIONS
-----------------

     This section deals with the many HeliOS words used to access data
     in memory and manipulate data structures.

     These, along with the stack manipulation operators, are the most
     important words in HeliOS, and you should try to become familiar
     with as many of them as possible.

     Although there are a lot of these words, many of them are related in
     groups of similar functionality, so the task of learning them is not
     so great as may appear at first sight.

     You will find it particularly important to learn these words if you
     intend to use the HeliOS game system, because this system is almost
     entirely driven by the manipulation of numbers in data structures.


     !             ( n1 a1 _ _ _ )

                   Store n1 at address a1 - a1+1.

     !L            ( n1 l1 _ _ _ )

                   Store n1 at address l1 - l1+1.

     +!            ( n1 a1 _ _ _ )

                   Add n1 to the number stored at memory a1 and a1+1.

     +!L           ( n1 l1 _ _ _ )

                   Add n1 to the number stored at memory l1 and l1+1.

     -!            ( n1 a1 _ _ _ )

                   Subtract n1 from the number stored at memory a1 and a1+1.

     -!L           ( n1 l1 _ _ _ )

                   Subtract n1 from the number stored at memory l1 and l1+1.

     -1!           ( a1 _ _ _ )

                   Store -1 at memory a1 and a1+1.

     -1!L          ( l1 _ _ _ )

                   Store -1 at memory l1 and l1+1.

     0!            ( a1 _ _ _ )

                   Store zero at memory a1 and a1+1.

     0!L           ( l1 _ _ _ )

                   Store zero at memory l1 and l1+1.

     1!            ( a1 _ _ _ )

                   Store one at memory a1 and a1+1.

     1!L           ( l1 _ _ _ )

                   Store one at memory l1 and l1+1.

     2!            ( a1 _ _ _ )

                   Store two at memory a1 to a1+1.

     2!L           ( l1 _ _ _ )

                   Store two at memory l1 to l1+1.

     ?             ( a1 _ _ _ )

                   Print out the value stored at memory a1 and a1+1.

     <CMOVE        ( a1 a2 n1 _ _ _ )

                   Copies n1 memory bytes starting at address a1 to memory
                   area starting at a2.

                   The move proceeds from high toward low memory.

                   See also CMOVE, TRANSFER, EXCHANGE.

     <CMOVEL       ( l1 l2 d1 _ _ _ )

                   Copies d1 memory bytes starting at address l1 to memory
                   area starting at l2.

                   The move proceeds from high toward low memory.

                   See also CMOVEL, TRANSFERL, EXCHANGEL.

     @             ( a1 _ _ _ n1 )

                   Fetch the number n1 from memory at a1 and a1+1 onto stack.

     @L            ( l1 _ _ _ n1 )

                   Fetch the number n1 from memory at l1 and l1+1 onto stack.

     BLANKS        ( a1 n1 _ _ _ )

                   Fills n1 memory locations starting at a1 with ASCII blanks.

     BLANKSL       ( l1 d1 _ _ _ )

                   Fills d1 memory locations starting at l1 with ASCII blanks.

     C!            ( b1 a1 _ _ _ )

                   Store the single byte b1 at memory address a1.

     C!L           ( b1 l1 _ _ _ )

                   Store the single byte b1 at memory address l1.

     C+!           ( b1 a1 _ _ _ )

                   Add b1 to the number stored at memory a1.

     C+!L          ( b1 l1 _ _ _ )

                   Add b1 to the number stored at memory l1.

     C-!           ( b1 a1 _ _ _ )

                   Subtract b1 from the number stored at memory a1.

     C-!L          ( b1 l1 _ _ _ )

                   Subtract b1 from the number stored at memory l1.

     C@            ( a1 _ _ _ b1 )

                   Returns the single byte value b1 of address a1.

     C@L           ( l1 _ _ _ b1 )

                   Returns the single byte value b1 of address l1.

     CDEC          ( a1 _ _ _ )

                   Decrement a single byte number at memory address a1.

     CDECL         ( l1 _ _ _ )

                   Decrement a single byte number at memory address l1.

     CINC          ( a1 _ _ _ )

                   Increment a single byte number at memory address a1.

     CINCL         ( l1 _ _ _ )

                   Increment a single byte number at memory address l1.

     CMOVE         ( a1 a2 n1 _ _ _ )

                   Copies n1 memory bytes starting at address a1 to memory
                   area starting at a2.

                   The move proceeds from low toward high memory.

                   See also <CMOVE, TRANSFER, EXCHANGE.

     CMOVEL        ( l1 l2 d1 _ _ _ )

                   Copies d1 memory bytes starting at address l1 to memory
                   area starting at l2.

                   The move proceeds from low toward high memory.

                   See also <CMOVEL, TRANSFERL, EXCHANGEL.


     COPYBYTETABLE (ByteTable(l), TargetList(l), Number(n) - - - )

                   Where:

                   ByteTable   -> 32-bit pointer to a linear list of bytes
                   TargetList  -> 32-bit pointer to a linear list of 32-bit
                                  target pointers
                   Number      -> Number of bytes to copy

                   Copies a sequence of byte values, one at a time, from
                   ByteTable, into a series of specified 32-bit addresses
                   stored sequentially in TargetList.

                   Note that POINTERS to the target addresses are stored
                   in TargetList, and the actual target addresses are thus
                   at a further level of indirection.

     COPYLONGTABLE (LongTable(l), TargetList(l), Number(n) - - - )

                   Where:

                   LongTable   -> 32-bit pointer to a linear list of 32-bit
                                  "longwords"
                   TargetList  -> 32-bit pointer to a linear list of 32-bit
                                  target pointers
                   Number      -> Number of longwords to copy

                   Copies a sequence of 32-bit values, one at a time, from
                   LongTable, into a series of specified 32-bit addresses
                   stored sequentially in TargetList.

                   Note that POINTERS to the target addresses are stored
                   in TargetList, and the actual target addresses are thus
                   at a further level of indirection.

     COPYWORDTABLE (WordTable(l), TargetList(l), Number(n) - - - )

                   Where:

                   WordTable   -> 32-bit pointer to a linear list of 16-bit
                                  "words"
                   TargetList  -> 32-bit pointer to a linear list of 32-bit
                                  target pointers
                   Number      -> Number of words to copy

                   Copies a sequence of 16-bit values, one at a time, from
                   WordTable, into a series of specified 32-bit addresses
                   stored sequentially in TargetList.

                   Note that POINTERS to the target addresses are stored
                   in TargetList, and the actual target addresses are thus
                   at a further level of indirection.

     CYCLE         ( a1 n1 - - - )

                   Increments variable a1 until it reaches a limiting value
                   of n1-1, then resets to zero: this is a cyclic operation
                   having n1 states.

                   eg. If n1 = 4, a1 takes values 0 1 2 3 0 1 2 3 .....etc

     CYCLE+!       ( a1 n1 n2 - - - )

                   Increments variable a1 by adding value n1 until it
                   reaches a limiting value of n2-1, then resets to zero:
                   this is a cyclic operation.

                   eg. If n1 = 4 and n2 = 13, a1 takes values 0 4 8 12 0...

     CYCLEL        ( l1 n1 - - - )

                   Increments variable l1 until it reaches a limiting value
                   of n1-1, then resets to zero: this is a cyclic operation
                   having n1 states.

                   eg. If n1 = 4, l1 takes values 0 1 2 3 0 1 2 3 .....etc


     CYCLE+!L      ( l1 n1 n2 - - - )

                   Increments variable l1 by adding value n1 until it
                   reaches a limiting value of n2-1, then resets to zero:
                   this is a cyclic operation.

                   eg. If n1 = 4 and n2 = 13, l1 takes values 0 4 8 12 0...

     D!            ( d1 a1 _ _ _ )

                   Store double number d1 at memory a1 to a1+3.

     D!L           ( d1 l1 _ _ _ )

                   Store double number d1 at memory l1 to l1+3.

     D+!           ( d1 a1 _ _ _ )

                   Add d1 to the number stored at memory a1 to a1+3.

     D+!L          ( d1 l1 _ _ _ )

                   Add d1 to the number stored at memory l1 to l1+3.

     D-!           ( d1 a1 _ _ _ )

                   Subtract d1 from the number stored at memory a1 to a1+3.

     D-!L          ( d1 l1 _ _ _ )

                   Subtract d1 from the number stored at memory l1 to l1+3.

     D0!           ( a1 _ _ _ )

                   Store zero at memory a1 to a1+3.

     D0!L          ( l1 _ _ _ )

                   Store zero at memory l1 to l1+3.

     DCLEAR@       ( a1 _ _ _ d1 )

                   Fetch double number d1 from memory at a1 to a1+3, at
                   the same time setting that location to 0.

     DCYCLE        ( a1 d1 - - - )

                   Increments 32-bit variable a1 until it reaches a limiting
                   value of d1-1, then resets to zero: this is a cyclic
                   operation having d1 states.

                   eg. If d1 = 4, a1 takes values 0. 1. 2. 3. 0. 1.....etc

     DCYCLE+!      ( a1 d1 d2 - - - )

                   Increments 32-bit variable l1 by adding value d1 until it
                   reaches a limiting value of d2-1, then resets to zero:
                   this is a cyclic operation.

                   eg. If d1 = 4. and d2 = 13.

                       a1 takes values 0. 4. 8. 12. 0. 1....etc

     DCYCLEL       ( l1 d1 - - - )

                   Increments 32-bit variable l1 until it reaches a limiting
                   value of d1-1, then resets to zero: this is a cyclic
                   operation having d1 states.

                   eg. If d1 = 4, a1 takes values 0. 1. 2. 3. 0. 1.....etc

     DCYCLE+!L     ( l1 d1 d2 - - - )

                   Increments 32-bit variable l1 by adding value d1 until it
                   reaches a limiting value of d2-1, then resets to zero:
                   this is a cyclic operation.

                   eg. If d1 = 4. and d2 = 13.

                       l1 takes values 0. 4. 8. 12. 0. 1....etc

     DDEC          ( a1 _ _ _ )

                   Decrement 32-bit number at memory address a1 to a1+3.

     DDECL         ( l1 _ _ _ )

                   Decrement 32-bit number at memory address l1 to l1+3.

     DEC           ( a1 _ _ _ )

                   Decrement 16-bit number at memory address a1 to a1+1.

     DECL          ( l1 _ _ _ )

                   Decrement 16-bit number at memory address l1 to l1+1.

     DINC          ( a1 _ _ _ )

                   Increment 32-bit number at memory address a1 to a1+3.

     DINCL         ( l1 _ _ _ )

                   Increment 32-bit number at memory address l1 to l1+3.

     DLIMIT        ( d1 d2 a1 - - - )

                   Limits variable a1 between minimum and maximum values
                   defined by d1 (=lower limit) and d2 (=upper limit).

                   This is a signed operation.

     DLIMIT+!      ( d1 d2 d3 a1 - - - )

                   Increments 32-bit variable a1 by adding value d1, and
                   limits result between minimum and maximum values defined
                   by d2 (=lower limit) and d3 (=upper limit).

                   This is a signed operation.

     DLIMIT+!L     ( d1 d2 d3 l1 - - - )

                   Increments 32-bit variable l1 by adding value d1, and
                   limits result between minimum and maximum values defined
                   by d2 (=lower limit) and d3 (=upper limit).

                   This is a signed operation.

     DLIMITL       ( d1 d2 l1 - - - )

                   Limits variable l1 between minimum and maximum values
                   defined by d1 (=lower limit) and d2 (=upper limit).

                   This is a signed operation.

     DMOVE         ( a1 a2 - - - )

                   Move a 32-bit number from address a1 to a2

     DMOVEL        ( l1 l2 - - - )

                   Move a 32-bit number from address l1 to l2

     D@            ( a1 _ _ _ d1 )

                   Fetch double number d1 from memory at a1 to a1+3.

     D@L           ( l1 _ _ _ d1 )

                   Fetch double number d1 from memory at l1 to l1+3.

     ERASE         ( a1 n1 _ _ _ )

                   Fills n1 memory locations starting at a1 with zeros.

     ERASEL        ( l1 d1 _ _ _ )

                   Fills d1 memory locations starting at l1 with zeros.

     EXCHANGE      ( a1 a2 n1 _ _ _ )

                   Exchanges n1 memory bytes between areas starting at a1
                   and a2. Pad is used as a temporary storage buffer.

                   Overlap of areas is automatically provided for using an
                   interim copy buffer.

                   The down side to this is that EXCHANGE is slightly slower
                   in operation than using CMOVE and <CMOVE directly, so you
                   may wish to use these functions instead for speed.

                   See also TRANSFER, CMOVE, <CMOVE.

     EXCHANGEL     ( l1 l2 d1 _ _ _ )

                   Exchanges d1 memory bytes between areas starting at l1
                   and l2. Pad is used as a temporary storage buffer.

                   Overlap of areas is automatically provided for using an
                   interim copy buffer.

                   The down side to this is that EXCHANGE is slightly slower
                   in operation than using CMOVE and <CMOVE directly, so you
                   may wish to use these functions instead for speed.

                   See also TRANSFERL, CMOVEL, <CMOVEL.

     FILL          ( a1 n1 b1 _ _ _ )

                   Fills n1 memory locations starting at a1 with byte value b1.

     FILLL         ( l1 d1 b1 _ _ _ )

                   Fills d1 memory locations starting at l1 with byte value b1.

     INC           ( a1 _ _ _ )

                   Increment 16-bit number at memory address a1.

     INCL          ( l1 _ _ _ )

                   Increment 16-bit number at memory address l1.

     INDEX!L       ( n1 l1 d1 _ _ _ ) or ( n1 d1 l1 _ _ _ )

                   Store 16-bit number n1 in memory at l1+d1 to l1+d1+1.

     INDEX+!L      ( n1 l1 d1 _ _ _ ) or ( n1 d1 l1 _ _ _ )

                   Add 16-bit number n1 to number in memory at l1+d1 to
                   l1+d1+1.

     INDEX-!L      ( n1 l1 d1 _ _ _ ) or ( n1 d1 l1 _ _ _ )

                   Subtract 16-bit number n1 from number in memory at l1+d1
                   to l1+d1+1.

     INDEX@L       ( l1 d1 _ _ _ n1 ) or ( d1 l1 _ _ _ n1 )

                   Fetch 16-bit number n1 from memory at l1+d1 to l1+d1+1.

     INDEXC!L      ( b1 l1 d1 _ _ _ ) or ( b1 d1 l1 _ _ _ )

                   Store byte b1 in memory at l1+d1.

     INDEXC+!L     ( b1 l1 d1 _ _ _ ) or ( b1 d1 l1 _ _ _ )

                   Add byte b1 to number in memory at l1+d1.

     INDEXC-!L     ( b1 l1 d1 _ _ _ ) or ( b1 d1 l1 _ _ _ )

                   Subtract byte b1 from number in memory at l1+d1.

     INDEXC@L      ( l1 d1 _ _ _ b1 ) or ( d1 l1 _ _ _ b1 )

                   Fetch byte b1 from memory at l1+d1.

     INDEXD!L      ( d2 l1 d1 _ _ _ ) or ( d2 d1 l1 _ _ _ )

                   Store double number d2 in memory at l1+d1 to l1+d1+3.

     INDEXD+!L     ( d2 l1 d1 _ _ _ ) or ( d2 d1 l1 _ _ _ )

                   Add double number d2 to number in memory at l1+d1 to
                   l1+d1+3.

     INDEXD-!L     ( d2 l1 d1 _ _ _ ) or ( d2 d1 l1 _ _ _ )

                   Subtract double number d2 from number in memory at l1+d1
                   to l1+d1+3.

     INDEXD@L      ( l1 d1 _ _ _ d2 ) or ( d1 l1 _ _ _ d2 )

                   Fetch double number d2 from memory at l1+d1 to l1+d1+3.

     LIMIT         ( n1, n2, a1 - - - )

                   Limits variable a1 between minimum and maximum values
                   defined by n1 (=lower limit) and n2 (=upper limit).

                   This is a signed operation.

     LIMIT+!       ( n1 n2 n3 a1 - - - )

                   Increments variable a1 by adding value n1, and limits
                   result between minimum and maximum values defined by
                   n2 (=lower limit) and n3 (=upper limit).

                   This is a signed operation.

     LIMIT+!L      ( n1 n2 n3 l1 - - - )

                   Increments variable l1 by adding value n1, and limits
                   result between minimum and maximum values defined by
                   n2 (=lower limit) and n3 (=upper limit).

                   This is a signed operation.

     LIMITL        ( n1, n2, l1 - - - )

                   Limits variable l1 between minimum and maximum values
                   defined by n1 (=lower limit) and n2 (=upper limit).

                   This is a signed operation.

     LONGOFFSET    ( l1 n1 - - - l2 )

                   Adds 4xn1 to l1, effectively returning an address l2
                   which is n1 longwords after l1.

                   Used to index into longword tables.

     MOVE          ( a1 a2 - - - )

                   Move a 16-bit number from address a1 to a2

     MOVEL         ( l1 l2 - - - )

                   Move a 16-bit number from address l1 to l2

     SWITCH        ( a1 - - - )

                   Switches the value of a variable a1 between 0 and 1.

                   If the value of the variable was non zero before using
                   SWITCH, it will be made equal to zero.

                   If the value of the variable was zero before using
                   SWITCH, it will be made equal to one.

     TOGGLE        ( a1 b1 _ _ _ )

                   Performs 8-bit XOR operation on byte value b1 and 8 bits
                   of data stored at address a1.

                   This is used to toggle the 8 most significant bits of
                   a variable.

     TOGGLEL       ( l1 b1 _ _ _ )

                   Performs 8-bit XOR operation on byte value b1 and 8 bits
                   of data stored at address l1.

                   This is used to toggle the 8 most significant bits of
                   a variable.

     TRANSFER      ( a1 a2 n1 _ _ _ )

                   Transfers n1 memory bytes from an area starting at a1 to
                   a2.

                   Overlap of areas is automatically provided for, so you
                   do not need to worry about whether the bytes are copied
                   from "high towards low" or "low towards high" memory.

                   This means that, unlike CMOVE and <CMOVE, ALL overlapped
                   area copies will be carried out automatically correctly.

                   The down side to this is that TRANSFER is marginally
                   slower in operation than CMOVE and <CMOVE, so you may
                   wish to use these functions instead where speed and
                   maximum efficiency are important.

                   See also EXCHANGE, CMOVE, <CMOVE.


     TRANSFERL     ( l1 l2 d1 _ _ _ )

                   Transfers d1 memory bytes from an area starting at l1 to
                   l2.

                   Overlap of areas is automatically provided for, so you
                   do not need to worry about whether the bytes are copied
                   from "high towards low" or "low towards high" memory.

                   This means that, unlike CMOVEL and <CMOVEL, ALL copies
                   involving overlapped areas will be carried out correctly
                   fully automatically.

                   The down side to this is that TRANSFERL is marginally
                   slower in operation than CMOVEL and <CMOVEL, so you may
                   wish to use these functions instead where speed and
                   maximum efficiency are important.

                   See also EXCHANGEL, CMOVEL, <CMOVEL.

     WORDOFFSET    ( l1 n1 - - - l2 )

                   Adds 2xn1 to l1, effectively returning an address l2
                   which is n1 words after l1.

                   Used to index into word tables.


--------------------------
COMPILATION AND DICTIONARY
--------------------------

     Here we have a section dealing with words which in many cases require
     a fairly subtle understanding of HeliOS code: it is here that you can
     find methods of doing "extra-ordinary" things which require extension
     of the standard HeliOS functions.

     On the other hand, many of these words are very easy and commonplace,
     so learn what you need for the time being and do not worry about the
     more esoteric functions until you are sure that you require them.


     ASCII "null"  ( _ _ _ )                        "null"
     or 0-byte
                   Terminate interpretation.

     "$            ( _ _ _ )                        "quote-string"

                   Compiles following string literal into dictionary as a
                   counted string and advances dictionary pointer to the
                   first location after string.

                   Uses " as delimiter.

     $             ( _ _ _ )                        "string"

                   Compiles following string literal into dictionary as a
                   counted string and advances dictionary pointer to the
                   first location after string.

                   Uses system string delimiter as delimiter.

                   See { DELIMITER }.

     (             ( _ _ _ )                        "paren"

                   Used to enclose a comment in HeliOS source code and requires
                   a terminating delimiter of ")". Comment is skipped by
                   compiler.

                   Example: SOURCEWORD SOURCEWORD ( COMMENT ) SOURCEWORD
                                                 ^ ^       ^ ^
                                              Note spaces required.

                   Expressions enclosed within the comment markers may
                   themselves include the "(" and ")" characters provided
                   that the ")" character has no surrounding spaces.

                   Thus, this is a legal comment:

                    ( This comment includes () and still (We hope!) works )


     (PRELOAD)     ( l1 - - - )

                   Used to load and run a PRESAVED, precompiled, HeliOS
                   program.

                   l1 is a 32-bit pointer to a counted string which is the
                   name of the file to be preloaded.

                   This function totally clears the system before loading
                   the new compiled code, then executes the top word in the
                   new dictionary.

                   See the HeliOS documentation relating to the COMPILING
                   menu for further details.

                   See also PRELOAD.

     (RUN)         ( l1 - - - )

                   Used to load and compile a source file whose (counted)
                   name string is pointed to by l1.

                   The file is first loaded into a memory buffer and then
                   compiled.

                   The memory buffer is opened automatically and closed when
                   the compilation is completed.

                   RUN should be used if you wish to use this function from
                   the command line.

                   See RUN.

     )             ( _ _ _ )                        "close-paren"

                   Used to enclose a comment in HeliOS source code after
                   the use of "(", and acts as a terminating delimiter.

                   Comment is skipped by compiler.

                   Example: SOURCEWORD SOURCEWORD ( COMMENT ) SOURCEWORD
                                                 ^ ^       ^ ^
                                              Note spaces required.

                   Expressions enclosed within the comment markers may
                   themselves include the "(" and ")" characters provided
                   that the ")" character has no surrounding spaces.

                   Thus, this is a legal comment:

                    ( This comment includes () and still (We hope!) works )

     **CORE**      ( _ _ _ )

                   Dummy word marking the top of the HeliOS core dictionary.

     ,             ( n1 _ _ _ )

                   Compile n1 into next dictionary cell and update dictionary
                   pointer.


     .(            ( _ _ _ )                        "print-paren"

                   Used to output a comment in HeliOS source code and requires
                   a terminating delimiter of ")". Acts at compile time.

                   Example:   SOURCEWORD SOURCEWORD .( COMMENT ) SOURCEWORD
                                                   ^  ^       ^ ^
                                                 Note spaces required.

                   As distinct from "(" which merely ignores the comment text
                   ".(" outputs the commment at once as the source is loading.

     :             ( _ _ _ )

                   Used in the form

                   : XXX - - - - - ;

                   to create a new word XXX where - - - - - is a sequence of
                   previously defined words.

                   Note the use of ; as a terminator.

     ;             ( _ _ _ )

                   Terminates colon definition.

     ;CODE         ( _ _ _ )

                   Used in the form :

                   XXX - - - - ;CODE MACHINE-CODE EXITCODE

                   in the creation of new defining word XXX with machine
                   code as its execution procedure.

                   Initial code - - - - must contain an existing defining
                   word to set up the dictionary header.

                   New words created by XXX used in the form XXX NEWWORD
                   will have as their execution procedure the machine
                   code after ;CODE.

                   See EXITCODE.

     ;S            ( _ _ _ )

                   Terminate compilation of source code.

     <$            ( _ _ _ )                        "short-string"

                   Compiles a string literal into the dictionary as an
                   UNcounted string and advances dictionary pointer to the
                   first location after string.

                   Uses the system string delimiter, like this:

                   <$ $My embedded uncounted string$

                   See { DELIMITER }.

     ABORT"        ( _ _ _ )    run-time-> ( flag _ _ _ )

                   Compile " delimited string into dictionary, and at
                   run-time print string and ABORT if flag = 1.

     ALIGNED       (  _ _ _ )

                   Force longword alignment of DP.

     ALLOT        ( n1 _ _ _ )

                   Reserve n1 bytes in dictionary, incrementing DP by n1.

     ALLOT$       ( _ _ _ )                        "allot-string"

                   Compiles a string literal into the dictionary as a
                   simple sequence of ASCII characters with no count
                   or null termination, and advances dictionary pointer
                   to the first location after the ASCII sequence.

                   Uses the system string delimiter, like this:

                   ALLOT$ $My embedded ASCII string$

                   See { DELIMITER }.

     ALLOTFILL    ( n1 c1 _ _ _ )

                   Reserve n1 bytes in dictionary, incrementing DP by n1,
                   and fill with character c1.

     AMIGAINCLUDE ( _ _ _ )

                   Used in the form:

                   AMIGAINCLUDE HeliOS:MyAmigaInclude

                   Loads following filename delimited by spaces as current
                   AMIGA include.

     C,            ( c1 _ _ _ )

                   Compile c1 into next dictionary byte and update dictionary
                   pointer.

     CODE          ( - - - )

                   Used in the form CODE XXX MACHINE-CODE EXITCODE ENDCODE
                   to create a new HeliOS word XXX whose function is defined
                   by the machine code sequence MACHINE-CODE.

                   Note the use of EXITCODE to compile the code for the return
                   to the HeliOS Interpreter.

                   The new word will be included in the current vocabulary.

                   The ASSEMBLER vocabulary will automatically be invoked
                   during the compilation of the new word and then switched
                   out, without your having to worry.

                   See ;CODE, ENDCODE, EXITCODE, SUBROUT

     COMPILE       ( _ _ _ )

                   Used in the form:

                   COMPILE XXX

                   in the definition of a compiling word, to compile the
                   CFA of "XXX" into the dictionary.

     D,            ( d1 _ _ _ )

                   Compile d1 into next four dictionary bytes and update
                   dictionary pointer.

     DLITERAL      ( d1 _ _ _ )

                   Used within colon definitions to compile 32-bit literals
                   into dictionary.

                   At run time d1 will be pushed onto stack.

                   This is a state-sensitive word which does nothing if not
                   used within a colon definition.

                   See also LITERAL

     DOES>         ( _ _ _ )

                   Applications of this word should be implemented using the
                   Forth-79 rather than fig-Forth convention: after use of
                   CREATE rather than <BUILDS.

                   Used in creating a defining word to mark the end of its
                   compile-time section and start of its run-time section.

                   At run time the pfa of the defined word will be put on
                   the stack ready for use by the code after DOES>.

                   For Example, a definition of CONSTANT might be :

                   : CONSTANT CREATE , DOES> @ ;

     ENDCODE       ( _ _ _ )

                   Terminates an assembler-coded HeliOS function definition
                   following CODE by completing the definition of the new
                   word and returning from the ASSEMBLER vocabulary.

                   Note that EXITCODE must be used first, if required, to
                   compile the code to return to the HeliOS Interpreter.

                   See ;CODE, CODE, EXITCODE, SUBROUT

     EXITCODE      ( _ _ _ )

                   Terminates a machine code sequence by compiling address of
                   code to return to HeliOS inner interpreter.
                   See ;CODE, CODE, ENDCODE, SUBROUT

     FORGET        ( _ _ _ )

                   Used in the form FORGET XXX to remove from dictionary all
                   words subsequent to and including XXX.

     FORTH         ( _ _ _ )

                   The primary vocabulary.

     HERE          ( _ _ _ a1 )

                   Returns address of first free byte in dictionary.

     IMMEDIATE     ( _ _ _ )

                   Mark the most recently defined word as immediate.

     JSR           ( l1 _ _ _ )

                   Used within high level HeliOS code to perform a JSR
                   function to a machine code routine starting at the
                   32-bit address defined by l1.

                   The JSR function uses the internal HeliOS dummy MC680xx
                   register set, exactly like the HeliOS LIBRARY functions,
                   to pass parameters from HeliOS high level code to the
                   external machine code.

                   See the notes on the HeliOS Dictionary section called
                   "AMIGA LIBRARY CALLS" for details of how the internal
                   HeliOS dummy MC680xx registers are used.

                   An example of when you might need this function is if
                   you were to use the DOS LoadSeg/UnLoadSeg routines to
                   load an external program into memory.  You could then
                   use the JSR command to run the loaded external code.

                   Here is an example implementation of this use of JSR:

                   0. DVARIABLE Load_SegList      \ Loaded SegList BPTR
                   0. DPOINTER  Load_CodePtr      \ Pointer to loaded code

                   : Code_LoadSeg

                   LIT$ $Code.exe$ W>L D1+        \ Uncounted filename

                   1 DREG D!                      \  -> Reg D1

                   _LVOLoadSeg DOSBASE LIBRARYL   \ Call DOS "LoadSeg"

                   D0RESULT D0= ERROR" Error!"    \ Error check

                   D0RESULT
                   DDUP Load_SegList D!           \ Store SegList
                   2 DLSL                         \ Convert BPTR to APTR
                   4. D+                          \ Get code start offset
                   Load_CodePtr MAKEPOINTER       \ Set up pointer
                   ;

                   : Code_UnLoadSeg

                   Load_SegList D@ 1 DREG D!      \ SegList -> Reg D1                                               ; SegList -> Reg D1
                   _LVOUnLoadSeg DOSBASE LIBRARYL \ Call DOS "UnLoadSeg"
                   ;

                   : Code_RunExt

                   Load_CodePtr JSR               \ JSR to loaded code
                   ;

     JSRFORTH      ( _ _ _ l1 )

                   This command is used to obtain the 32-bit pointer
                   to a special machine code routine within HeliOS
                   which allows the use of a HeliOS high level function
                   within the body of a section of assembly language code.

                   If you intend to use the HeliOS assembler to produce
                   in-line assembly language sections within your HeliOS
                   code you can call any high level HeliOS word within an
                   assembler code section.

                   You can do this by simply calling the special function
                   pointer returned by JSRFORTH with the CFA of the HeliOS
                   word in MC680xx register D6.

                   Notes on the use of JSRFORTH:

                   1. You should use this word, JSRFORTH, to obtain the
                      special function pointer at the start of any of
                      your programs where you might want to incorporate
                      HeliOS high level functions within assembly language
                      code sections.  You should store the returned pointer
                      in a variable for use later.

                   2. To call a HeliOS word inside an assembler code section
                      proceed as follows:

                      * Place the CFA of the HeliOS word in MC680xx
                        register D6.

                      * Perform a "JSR" to the stored address returned
                        earlier by using the JSRFORTH function.

     LATESTCFA     ( _ _ _ cfa )

                   Returns cfa of last word in current vocabulary.

     LIT           ( _ _ _ n1 )

                   Run time code compiled by LITERAL. Causes contents of next
                   two dictionary bytes to be pushed onto stack.

     LIT$          ( _ _ _ )

                   Used only within word definitions to compile string
                   literals.

                   Compiles a string literal delimited by system delimiter
                   and at run time returns the 16-bit address of the counted
                   string.

                   See { DELIMITER }.

                   Example:  : NAME LIT$ $TESTSTRING$ ;
                                         ^          ^  ( Default value.)

                   In this example TESTSTRING would be compiled as a counted
                   string and the run-time code compiled by LIT$ returns the
                   16-bit address of the string when NAME is executed.

     LIT$L         ( _ _ _ )

                   Used only within word definitions to compile string
                   literals.

                   Compiles a string literal delimited by system delimiter
                   and at run time returns the 32-bit address of the counted
                   string.

                   See { DELIMITER }.

                   Example:  : NAME LIT$L $TESTSTRING$ ;
                                          ^          ^  ( Default value.)

                   In this example TESTSTRING would be compiled as a counted
                   string and the run-time code compiled by LIT$ returns the
                   32-bit address of the string when NAME is executed.

     LITERAL       ( n1 _ _ _ )

                   Used within colon definitions to compile the CFA of the
                   word "LIT", and then compile n1 as a 16-bit literal into
                   the dictionary.

                   At run time n1 will be pushed onto stack.

                   This is a state-sensitive word which does nothing if not
                   used within a colon definition.

                   See also DLITERAL

     LOAD          ( n1 _ _ _ )

                   If n1 = 1           Load source code from Editor 1
                   If n1 = 2           Load source code from Editor 2
                   If n1 = -1          Load source code from Editor 3
                   If n1 = -2          Load source code from OUT Editor

                   If n1 = 3           Load source code from a memory buffer
                                       whose 32-bit start address is stored
                                       in the double length variable
                                       SOURCESTART.

                   See also INTERPRET, BUF, SOURCESTART.

     LONGINCLUDE   ( - - - )

                   Causes the HeliOS include system to return 32-bit include
                   values.

                   This is the system default setting, and it is best to 
                   always switch back to 32-bit includes upon return from
                   any routine where you have changed the default setting.

     MYSELF        ( _ _ _ cfa )

                   Used within colon definitions to compile the cfa of the
                   word being defined for recursive functions.

                   Other types of recursive structure can be implemented by
                   using an expression such as FUTUREWORD @EXECUTE, where
                   FUTUREWORD is a variable, to set up the possibility of
                   executing a word not yet defined within a word currently
                   being defined.

                   In this way you can have a word which uses another word
                   which itself uses the first word!

                   Recursion and vectored execution is simply a matter of
                   getting around the relatively trivial difficulty of the
                   sequential definition of HeliOS words and the natural
                   "structure" which this imposes.

                   Have fun!

     PRELOAD       ( - - - )

                   Used to load and run a PRESAVED, precompiled, HeliOS
                   program.

                   Uses $NEXTL internally, so the usage format is simply:

                   PRELOAD FILENAME

                   Note that no spaces may be included in the filename.

                   This word is designed for simple use from the command
                   line as opposed to (PRELOAD) which can be used more
                   generally.

                   This function totally clears the system before loading
                   the new compiled code, then executes the top word in the
                   new dictionary.

                   See the HeliOS documentation relating to the
                   COMPILING menu for further details.

                   See also (PRELOAD).

     RUN           ( - - - )

                   Used in the form:

                   RUN SOURCEFILE

                   to cause a source code file to be loaded into a memory
                   buffer and compiled.

                   The memory buffer is opened automatically and closed when
                   the compilation is completed.

                   RUN uses "$NEXTL" to get the address of the following
                   string onto the stack, and is intended for easy use in
                   Interpretive mode.

                   Note that no spaces may be included in the string.

                   For more general use, and use within colon definitions
                   etc. you must use the more flexible (RUN) command.

                   See (RUN).

     SMUDGE        ( _ _ _ )

                   Used to toggle the "smudge" bit in a word header to allow
                   or prevent a dictionary search finding the word.

     SOURCESTART   ( - - - a1 )

                   Returns variable a1 which contains the 32-bit address of
                   the start of a source code buffer.

                   See LOAD, INTERPRET, BUF

     SUBROUT       ( - - - a1 )

                   Used in the form:

                   SUBROUT XXX MACHINE-CODE ENDCODE

                   to create a new HeliOS word XXX whose function is defined
                   by the machine code sequence MACHINE-CODE.

                   Usually you will place an RTS instruction before ENDCODE,
                   but if you wish to jump back into the HeliOS Interpreter
                   at the end of the code segment you should use EXITCODE
                   before ENDCODE to compile the HeliOS return code.

                   At run time the new word will return the 16-bit address
                   a1 of the start of the machine code segment.

                   The new word will be included in the current vocabulary.

                   The ASSEMBLER vocabulary will automatically be invoked
                   during the compilation of the new word and then switched
                   out, without your having to worry.

                   See also ;CODE, CODE, ENDCODE, EXITCODE

     USERINCLUDE   ( _ _ _ )

                   Used in the form:

                   USERINCLUDE HeliOS:MyUserInclude

                   Loads following filename delimited by spaces as current
                   USER include.

     WORDINCLUDE   ( - - - )

                   Causes the HeliOS include system to return 16-bit include 
                   values.

                   The system default setting is for 32-bit include returns, 
                   and it is best to always switch back to 32-bit includes 
                   upon return from any routine where you have changed the 
                   default setting.


     [             ( _ _ _ )

                   Leave compile mode.

     [COMPILE]     ( _ _ _ )

                   Used in colon definitions in the form [COMPILE] XXX, where
                   XXX  is an immediate word, to force XXX to be compiled.

     \             ( _ _ _ )

                   Stop compilation and continue at next line.

     ]             ( _ _ _ )

                   Enter compile mode.


----------------
HELIOS INTERNALS
----------------

     Like the previous section these words relate to the inner working of
     HeliOS, and some of them should be used with caution until you are
     quite experienced with how the language works.


     '             ( _ _ _ pfa )                    "tick"

                   Used in the form:

                   ' XXX

                   where XXX is any word in dictionary.

                   Searches dictionary for XXX and if found returns pfa.

                   This is a state sensitive word and performs its function
                   within a colon definition by compiling the found pfa as
                   a literal.

     @EXECUTE      ( a1 _ _ _ )

                   Executes word whose CFA is stored at a1.

     ABORT         ( _ _ _ )

                   Clears both stacks and returns to HeliOS QUIT loop.

     BIN           ( _ _ _ )

                   Sets number base to binary.

                   N.B.

                   The number base is reset to decimal at the end of
                   each interpret session.

     CFA           ( pfa _ _ _ cfa )

                   Converts HeliOS word pfa on stack to cfa.

     DECIMAL       ( _ _ _ )

                   Sets number base to decimal.

                   N.B.

                   The number base is reset to decimal at the end of
                   each interpret session.

     ENCLOSE       ( l1 c1 _ _ _ l1 n1 n2 n3 )

                   Scans text from address l1 with respect to delimiter c1.

                   Returns:

                   l1 = unchanged 32-bit address of text.
                   n1 = byte offset to first non-delimiter character.
                   n2 = byte offset to first delimiter after text.
                   n3 = byte offset to next character to be scanned.

     ERRHANDLER    ( _ _ _ a1 )

                   Returns address of the main HeliOS error handler so that
                   by substituting the CFA of your own custom error routine
                   here you can redirect error handling to your own code.

                   After executing your code the main HeliOS internal error
                   handler will continue unless you use SYS@/SYS! to reset
                   the whole system execution path.

                   For example, your program code might include a SYS@ and
                   you error code might use SYS!.  This would allow your
                   error code to force the HeliOS system to return to the
                   SYS@ point of execution without completing the normal
                   HeliOS error return functions.

                   The main use of this function is to prevent the usual
                   error return via QUIT and allow the continuation of an
                   ongoing program by redirecting the program execution.

                   Standard error routine is restored by use of FORTHERROR.

                   An example:

                   ' MYERRORWORD CFA ERRHANDLER !  -> Redirects error handler

                   ( ..... Your Program ...... )

                   All error returns will now be routed to MYERRORWORD and
                   it is up to you to decide what you want this function to
                   do.  You might just want to carry out some extra error
                   code, or you might want to use SYS@/SYS! to pull back
                   code execution to a chosen point in your code.

                   In any case you must be careful to handle variables and
                   the stack so that everything is restored correctly.

                   Standard error routine is restored by use of FORTHERROR.

                   e.g.

                   FORTHERROR                      -> Restores original

                   BE VERY CAREFUL WHEN DEVISING YOUR OWN ERROR RETURNS

     ERROR         (  - - - a1 )

                   A 16-bit variable which will store an error flag after
                   use of certain HeliOS words which require "quiet" error
                   return behaviour.

                   Flag = 0 -> No error
                   Flag = 1 -> Error

                   This variable is updated whwnever the following words
                   are used:

                   NUMBER
                   NUMBERL

     ERROR"        ( flag - - - )

                   Performs a standard error return function which, by
                   default, if the flag on the stack is "true" (or non-zero)
                   prints the following string (delimited by "), resets the
                   stack and returns to the HeliOS interpreter loop.

                   ERROR" is used in the form:

                   DFLAG0= ( or any other expression which returns a flag
                             for success )
                   ERROR" Put your error message here!"

                   The error function can be changed using SETERROR" and
                   RESETERROR".

                   If you supply your own error function, this function
                   will be called with 3 items on the stack, as follows:

                   Error_String(w), Error_String_Count(w), Flag(w) - - -

                   This enables your code to check the error flag and
                   optionally display the error string and do anything
                   else you wish.

                   Your error code might be something like this:

                   : MYOWNERROR

                   IF
                     CR
                     CR
                     TYPE
                     CR
                     CR
                     ." Press <Space> to quit!"
                     CR
                     CR
                     WAITSPACE
                     (MYCLOSEDOWN) @EXECUTE
                     QUIT
                   ELSE
                     DDROP
                   THEN
                   ;

                   Where (MYCLOSEDOWN) contains the CFA of your program's
                   exit routine.

                   See also ERROR"FUNCTION, RESETERROR", SETERROR"

     ERROR"FUNCTION ( - - - a1 )

                   A variable which contains the CFA of the current ERROR"
                   function.

                   See also ERROR", RESETERROR", SETERROR"

     EXECUTE       ( cfa _ _ _ )

                   Executes word whose cfa is on stack.

                   See also the very useful @EXECUTE.

     FIND          ( _ _ _ cfa or 0 )

                   Used in the form FIND XXX to search dictionary for XXX.

                   If not found flag 0 is returned, otherwise the cfa of XXX
                   is returned.

                   This is a state sensitive word and performs its function
                   within a colon definition by compiling the found cfa as
                   a literal.

     FORTHERROR    ( _ _ _ )

                   Restores standard HeliOS error function.

     HEX           ( _ _ _ )

                   Sets number base to hexadecimal.

                   N.B.

                   The number base is reset to decimal at the end of
                   each interpret session.

     INTERPRET     ( _ _ _ )

                   The outer interpreter which either executes or compiles
                   text from current input stream.

                   The start of the text to be read is determined by the
                   value stored in the variable BUF, and the input stream
                   pointer >IN, which is initially set to zero.

                   BUF = 0  Input stream is taken from TIB (Command line)
                   BUF = 1  Input stream is taken from Editor 1
                   BUF = 2  Input stream is taken from Editor 2
                   BUF = -1 Input stream is taken from Editor 3
                   BUF = -2 Input stream is taken from OUT Editor
                   BUF = 3  Input stream is taken from a memory buffer
                            whose 32-bit start address is in the double
                            length variable SOURCESTART.

                   See also LOAD, SOURCESTART, BUF

     NFA           ( pfa(w) _ _ _ nfa(l) )

                   Where:

                   pfa = 16-bit address

                   nfa = 32-bit address


                   Converts HeliOS word pfa on stack to its nfa.

                   The nfa is a 32-bit pointer to the start of the name
                   field of the HeliOS word.

                   Note that the standard fig-Forth name field format is
                   used, with the usual Forth status and smudge bits etc.

     OCTAL         ( _ _ _ )

                   Sets number base to octal.

                   N.B.

                   The number base is reset to decimal at the end of
                   each interpret session.

     PAD           ( _ _ _ pad )

                   Returns the address of "pad" which is a memory work area
                   used by the system and always "floating" a fixed offset
                   above dictionary top.

                   Sometimes also referred to as the text output buffer.

     PADL          ( _ _ _ padl )

                   Returns the address of "pad" which is a memory work area
                   used by the system and always "floating" a fixed offset
                   above dictionary top.

                   Sometimes also referred to as the text output buffer.

     PFA           ( cfa _ _ _ pfa )

                   Converts HeliOS word cfa on stack to pfa.

     QUIT          ( _ _ _ )

                   Clears return stack and returns control to terminal.

     RESETERROR"   ( - - - )

                   Restore the HeliOS system ERROR" function, which prints
                   the following string (delimited by"), resets the stack
                   and returns to the HeliOS interpreter loop.

                   See also ERROR", ERROR"FUNCTION, SETERROR"

     SETDCLICK     (- - -)

                   Used to copy the Amiga prefs double click setting into
                   the HeliOS internal double click setting.

                   This routine is always called automatically at HeliOS
                   startup, but you may wish to use it to change the double
                   click interactively while running HeliOS.

     SETERROR"     ( a1 - - - )

                   Takes as its single parameter a variable containing the
                   cfa of your new error function.

                   Makes this cfa into the current ERROR" function.

                   See also ERROR", ERROR"FUNCTION, RESETERROR"

     SYS!          ( _ _ _ )

                   Restores the state of the HeliOS inner interpreter to
                   what it was when SYS@ was last called.

                   Use with GREAT care!

                   DO NOT USE THIS UNLESS YOU HAVE PREVIOUSLY USED SYS@ !!!

                   See also SYS@ below.

     SYS@          ( _ _ _ )

                   Records the current state of the HeliOS inner interpreter
                   in a set of private variables.

                   Stores the values of the HeliOS stack, Return stack, and
                   Interpreter Pointer.

                   See also SYS! above.

     SYSHFLAG      (a1 - - -)

                   A 16-bit variable which stores the current HeliOS
                   system status.

                   DO NOT WRITE TO THIS VARIABLE!

                   This flag will always return 1 when the Amiga OS is
                   running and 0 when the HeliOS OS is running.

                   SYSHFLAG can be used in your code to run different
                   routines depending on which OS is currently in use.

     VHELP         ( various _ _ _ various )

                   This is a flexible function for manipulating the HeliOS
                   VHelp system, and can have several stack effects.

                   VHELP has three separate functions:

                   1. Removing the current active HeliOS VHelp file and
                      deallocating all associated resources.

                      In this case you should call VHELP with a 32-bit
                      "0." value on the stack:

                      0. VHELP

                      This use of VHELP returns no stack parameters.

                   2. Getting the current active HeliOS VHelp file buffer
                      and its size.

                      In this case you should call VHELP with a 32-bit
                      "-1." value on the stack:

                      -1. VHELP

                      This use of VHELP returns two stack parameters,
                      as follows:

                      - - - VHelpBuffer(l), VHelpBufferSize(l)

                   3. Setting a new current active HeliOS VHelp file buffer.

                      In this case you should call VHELP with two 32-bit
                      values on the stack, these being your new VHelp buffer
                      and its size:

                      MyVHelpBuffer(l), MyVHelpBufferSize(l) - - -

                      This use of VHELP returns no stack parameters.

                      This operation will set up the HeliOS VHelp system
                      with your new VHelp buffer, and will automatically
                      de-allocate the old buffer.

                      If you wish to do so, you can, of course, deallocate
                      the old VHelp buffer before allocating your new one.

--------------
DEFINING WORDS
--------------

     This section deals with functions used to define new HeliOS words.

     Mostly these functions are very easy to use, and some of them can be
     used in subtle ways as you gain in experience:  CREATE, for example,
     can be used as the basis for setting up special data structures.

     CLEARPOINTER  ( "POINTERNAME" _ _ _ )

                   Used in the form:

                   POINTERNAME CLEARPOINTER

                   Clears the 32-bit value stored in the DPOINTER called
                   POINTERNAME.

     CONSTANT      ( n1 _ _ _ )

                   Creates a new word which when executed returns the
                   constant n1.

                   Used in the form:

                   n1 CONSTANT XXX

                   where XXX is the new word which will return n1.

     CREATE        ( _ _ _ )

                   This is the Forth-79 version of CREATE, used in a similar
                   way to Fig-Forth CREATE except that the code field of the
                   new word points to code which returns the pfa of the new
                   word when the new word is executed. The other difference
                   is that the new word does not require the use of SMUDGE.

                   Note that the "pfa" returned actually the first free
                   cell in the "compilation memory area" AFTER the new word
                   has been compiled.

                   Look at the following code which shows the equivalence
                   between using CREATE and the word VARIABLE:

                   CREATE MYVARIABLE

                   1 ,

                   is equivalent to

                   1 VARIABLE MYVARIABLE


     CREATEL       ( _ _ _ )

                   As CREATE above except that a 32-bit address is returned
                   for the pfa.

     CVARIABLE     ( c1 _ _ _ )

                   Creates a new word which when executed returns the
                   address of a byte length variable which is initialised
                   to value c1.

                   Used in the form:

                   c1 CVARIABLE XXX

                   where XXX returns the 16-bit address of its own parameter
                   field where c1 is stored.

     CVARIABLEL    ( c1 _ _ _ )

                   Creates a new word which when executed returns the
                   address of a byte length variable which is initialised
                   to value c1.

                   Used in the form:

                   c1 CVARIABLEL XXX

                   where XXX returns the 32-bit address of its own parameter
                   field where c1 is stored.

     DCONSTANT     ( d1 _ _ _ )

                   Creates a new word which when executed returns double
                   length constant d1.

                   Used in the form:

                   d1 DCONSTANT XXX

                   where XXX is the word which will return d1.

     DPOINTER      ( d1 _ _ _ )

                   Used in the form:

                   d1 DPOINTER XXX

                   where XXX returns a stored 32-bit value d1.

                   Creates a new word which when executed returns a 32-bit
                   value which is initialised to value d1.

                   This 32-bit value can be changed at any time by using
                   MAKEPOINTER and CLEARPOINTER.

                   This word behaves rather like a "variable" DCONSTANT.

                   See MAKEPOINTER and CLEARPOINTER

     DVARIABLE     ( d1 _ _ _ )

                   Creates a new word which when executed returns the
                   address of a double length variable which is initialised
                   to value d1.

                   Used in the form:

                   d1 DVARIABLE XXX

                   where XXX returns the 16-bit address of its own parameter
                   field where d1 is stored.

     DVARIABLEL    ( d1 _ _ _ )

                   Creates a new word which when executed returns the
                   address of a double length variable which is initialised
                   to value d1.

                   Used in the form:

                   d1 DVARIABLEL XXX

                   where XXX returns the 32-bit address of its own parameter
                   field where d1 is stored.

     MAKEPOINTER   ( d1 "POINTERNAME" _ _ _ )

                   Used in the form:

                   d1 POINTERNAME MAKEPOINTER

                   Stores the number d1 in the DPOINTER called POINTERNAME.

     VARIABLE      ( n1 _ _ _ )

                   Creates a new word which when executed returns the address
                   of a single length variable which is initialised to value
                   n1.

                   Used in the form:

                   n1 VARIABLE XXX

                   where XXX returns the address of its own parameter field
                   where n1 is stored.

     VARIABLEL     ( n1 _ _ _ )

                   As VARIABLE above but returns 32-bit address for pfa.

                   Used in the form:

                   n1 VARIABLEL XXX

                   where XXX returns the address of its own parameter field
                   where n1 is stored.

------------------------
NUMERIC INPUT AND OUTPUT
------------------------

     Some of these words require more explanation than is given here, and
     the use of the words is such that they can be most suitably presented
     in the form of a discourse with examples.

     For this reason we have included a discussion on pictured number output
     in the HeliOS tutorials, and you are recommended to refer to the text
     of the tutorials for an in depth discussion.

     Any text book on standard Forth will also prove useful as background
     reading on the interesting and powerful number handling functions in
     HeliOS and Forth.


     #             ( d1 _ _ _ d2 )                  "sharp"

                   Operate on d1 to generate next ASCII character in output
                   string leaving d2 as quotient after division by base.

                   Used between <# and #> in formatting numeric output
                   strings.

     #>            ( d1 _ _ _ a1 n1 )               "sharp-greater"

                   Ends numeric pictured output conversion and returns on
                   stack address a1 and count n1 of completed string.


     #B            ( - - - n1 or d1 )               "hash-b"

                   Converts the next word in the input text stream to a
                   single or double number using binary numeric base.

                   This is a state sensitive word and performs its function
                   within a colon definition by compiling the number as a
                   literal, so that at run time n1 or d1 will be pushed
                   onto the stack.

                   The size of the value left on the stack at run time or
                   compile time depends on the size of the number read
                   from the input stream.

     #D            ( - - - n1 or d1 )               "hash-d"

                   Converts the next word in the input text stream to a
                   single or double number using decimal numeric base.

                   This is a state sensitive word and performs its function
                   within a colon definition by compiling the number as a
                   literal, so that at run time n1 or d1 will be pushed
                   onto the stack.

                   The size of the value left on the stack at run time or
                   compile time depends on the size of the number read
                   from the input stream.


     #H            ( - - - n1 or d1 )               "hash-h"

                   Converts the next word in the input text stream to a
                   single or double number using hexadecimal numeric base.

                   This is a state sensitive word and performs its function
                   within a colon definition by compiling the number as a
                   literal, so that at run time n1 or d1 will be pushed
                   onto the stack.

                   The size of the value left on the stack at run time or
                   compile time depends on the size of the number read
                   from the input stream.

     #S            ( d1 _ _ _ 0 0 )                 "sharp-s"

                   Converts double number d1 to a formatted output string
                   with respect to current value in BASE leaving zero double
                   number remaining on stack.

                   Used between <# and #>.

     .             ( n1 _ _ _ )                     "dot"

                   Output n1 as a signed 16-bit number, converted according
                   to current base.

                   A single space follows number.

     .L            ( n1 n2 _ _ _ )

                   Output n1 as a signed 16-bit number, converted according
                   to current base, left aligned in a field n2 characters
                   wide.

     .R            ( n1 n2 _ _ _ )                  "dot-R"

                   Output n1 as a signed 16-bit number, converted according
                   to current base, right aligned in a field n2 characters
                   wide.

     .R0           ( n1 n2 _ _ _ )                  "dot-R-zero"

                   Output n1 as a signed 16-bit number, converted according
                   to current base, right aligned in a field n2 characters
                   wide.

                   Leading zeros are printed from start of field.

     <#            ( _ _ _ )                        "less-sharp"

                   Prepare for numeric output formatting using #, #S, #> etc.

     CONVERT       ( d1 a1 _ _ _ d2 a2 )

                   Converts a counted string at a1 to a signed double number
                   d2 using current base and accumulating the number into
                   the double number d1 on the stack.

                   Also returns the address of the first non-convertible
                   digit encountered as a2.

                   See also CONVERTL

     CONVERTL      ( d1 l1 _ _ _ d2 l2 )

                   Converts a counted string at l1 to a signed double number
                   d2 using current base and accumulating the number into
                   the double number d1 on the stack.

                   Also returns the address of the first non-covertible
                   digit encountered as l2.

                   See also CONVERT

     D.            ( d1 _ _ _ )

                   Output d1 as a signed 32-bit number, converted according
                   to current base.

                   A single space follows number.

     D.L           ( d1 n1 _ _ _ )

                   Output d1 as a signed 32-bit number, converted according
                   to current base, left aligned in a field n1 characters
                   wide.

     D.R           ( d1 n1 _ _ _ )

                   Output d1 as a signed 32-bit number, converted according
                   to current base, right aligned in a field n1 characters
                   wide.

     D.R0          ( d1 n1 _ _ _ )

                   Output d1 as a signed 32-bit number, converted according
                   to current base, right aligned in a field n1 characters
                   wide.

                   Leading zeros are printed from start of field.

     DIGIT         ( c1 n1 _ _ _ n2 1 or 0 )

                   Converts the ASCII character c1 using base n1 to its
                   binary equivalent n2 and leaves a true flag.

                   If conversion fails only a false flag is returned.

     HOLD          ( c1 _ _ _ )

                   Used between <# and #> to insert ASCII character c1 into
                   a pictured output string.

     NUMBER        ( a1 _ _ _ d1 )

                   Converts a counted string at a1 to a signed double number
                   d1 using current base.

                   If a decimal point, a hyphen, or a comma is encountered
                   in the text string its position will be stored in DPL.

                   If several of the above characters are encountered in
                   the numeric expression only the position of the last,
                   or "rightmost", one will be stored in DPL.

                   Errors will be flagged in the variable ERROR.

                   See also ERROR, NUMBERL

     NUMBERL       ( l1 _ _ _ d1 )

                   Converts a counted string at l1 to a signed double number
                   d1 using current base.

                   If a decimal point, a hyphen, or a comma is encountered
                   in the text string its position will be stored in DPL.

                   If several of the above characters are encountered in
                   the numeric expression only the position of the last,
                   or "rightmost", one will be stored in DPL.

                   Errors will be flagged in the variable ERROR.

                   See also ERROR, NUMBER

     SIGN          ( n1 d1 _ _ _ d1 )

                   Stores minus sign before numeric output string in text
                   buffer if number n1 is negative, dropping n1 and not
                   altering d1.

                   Must be used between <# and #>.

     U.            ( u1 _ _ _ )

                   Output u1 as an unsigned 16-bit number converted
                   according to current base.

                   A single trailing blank follows number.

     U.R           ( u1 n1 _ _ _ )

                   Output u1 as an unsigned 16-bit number, converted
                   according to current base, right aligned in a field
                   n1 characters wide.

     U.R0          ( u1 n1 _ _ _ )

                   Output u1 as an unsigned 16-bit number, converted
                   according to current base, right aligned in a field
                   n1 characters wide.

                   Leading zeros are printed from start of field.

     UD.           ( ud1 _ _ _ )

                   Output ud1 as an unsigned 32-bit number,converted
                   according to current base.

                   A single space follows number.

     UD.R          ( ud1 n1 _ _ _ )

                   Output ud1 as an unsigned 32-bit number,converted
                   according to current base, right aligned in a field
                   n1 characters wide.

     UD.R0         ( ud1 n1 _ _ _ )

                   Output ud1 as an unsigned 32-bit number,converted
                   according to current base, right aligned in a field
                   n1 characters wide.

                   Leading zeros are printed from start of field.

     UHEX.R        ( u1 _ _ _ )

                   Output u1 as an unsigned 16-bit hexadecimal number right
                   aligned in a four character wide field and with a leading $
                   sign and leading zeros printed.

     UHEXD.R       ( ud1 _ _ _ )

                   Output ud1 as an unsigned 32-bit hexadecimal number right
                   aligned in a eight character wide field and with a leading
                   $ sign and leading zeros printed.

----------------
STRING OPERATORS
----------------

     HeliOS has the most extensive and powerful set of string handling
     functions of any Amiga language.

     There are so many string handling functions in HeliOS that you will
     probably only need a small proportion of them in most of your code.
     However, when you come to write a really text-intensive application
     you will find it very worthwhile to come back to this section and read
     more about all the powerful tools at your disposal.

     !TEXTL        ( l1 _ _ _ )

                   Scans ahead in the input stream and gets a string which
                   is delimited by the system string delimiter, which is
                   then stored as a counted string at l1.

                   See { DELIMITER }.

     "             ( _ _ _ a1 n1 )

                   This word has different actions in interpretive and
                   compiling modes:

                   Interpret Mode - Get following string to PAD and return
                                    start and count on stack ready for TYPE.

                   Compile Mode   - Compile following string into dictionary
                                    as counted string, after first compiling
                                    a word which will return the start and
                                    count of the string onto the stack at run
                                    time.

                   The delimiter used in this word is ".


     $!>L          ( a1 l1 _  _  _   )

                   Moves counted string from a1 to l1.

                   (Including count byte & null)

     $!>W          ( l1 a1 _  _  _   )

                   Moves counted string from l1 to a1.

                   (Including count byte & null)

     $!L           ( l1 l2 _  _  _   )

                   Moves counted string from l1 to l2.

                   (Including count byte & null)

     $!W           ( a1 a2 _  _  _   )

                   Moves counted string from a1 to a2.

                   (Including count byte & null)

     $+0L          ( l1 _ _ _ l1 )

                   Add trailing null(s) to counted string l1 at end position
                   calculated by using string count.

                   Extra null is added as required for alignment.

                   The string address is returned unchanged.

     $+0W          ( a1 _ _ _ a1 )

                   Add trailing null(s) to counted string a1 at end position
                   calculated by using string count.

                   Extra null is added as required for alignment.

                   The string address is returned unchanged.

     $+L           ( l1 l2 l3 n1 _  _  _  l3 or 0 )

                   Adds counted string at l1 to counted string at l2 and
                   stores the result as a counted string at l3 only if the
                   count of the total new string is not greater than n1.

                   If so l3 is returned, but otherwise concatenation is not
                   carried out and flag 0. is returned.

     $-TL          ( l1 _ _ _ l1 )

                   Converts the count byte of the string at l1 such that all
                   trailing blanks are omitted, then adds trailing null.
                   Leaves l1 on stack.

     $<=L          ( l1 l2 _ _ _ flag )

                   Checks length of counted strings l1 and l2 to see if l1
                   <= l2 and returns flag on stack.

     $<0>L         ( l1 _ _ _ l2 )

                   Takes the counted or uncounted null terminated string l1
                   and finds the address of the first trailing null, which
                   is returned as l2.

     $<<SPACEL     ( l1 _ _ _ l2 )

                   Returns l2 = address of first space character scanning
                   backwards from l1, like $<SPACEL, but also skips all the
                   spaces which it encounters before finding the first
                   non-space character as it searches backwards.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $<FINDL       ( l1 c1 - - - l2 )

                   Searches backwards through memory, starting from l1, for
                   the first occurrence of character c1, whose address is
                   returned as l2.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $<SPACEL      ( l1 _ _ _ l2 )

                   Returns l2 = address of first space character scanning
                   backwards through memory from l1.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $>>SPACEL     ( l1 _ _ _ l2 )

                   Returns l2 = address of first space character scanning
                   forwards through memory from l1, like $>SPACEL, but this
                   time skips over any leading spaces which it encounters.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $>FINDL       ( l1 c1 - - - l2 )

                   Searches forwards through memory, starting from l1, for
                   the first occurrence of character c1, whose address is
                   returned as l2.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $>SPACEL      ( l1 _ _ _ l2 )

                   Returns l2 = address of first space character scanning
                   forwards through memory from l1.

                   This routine has no inbuilt "safety", and will literally
                   search through the whole of memory if necessary: it is up
                   to you to ensure that this word is only used in controlled
                   circumstances.

     $ADDL         ( l1 l2 n1 _ _ _ l2 or 0 )

                   Accepts a string from the keyboard and adds it to the
                   counted string stored at l1 provided that the total new
                   count does not exceed n1.

                   If so, counted string is stored at l2, and address l2 is
                   returned, otherwise flag 0 is returned.

     $ASCL         ( l1 n1 _ _ _ c1 )

                   Selects the character which is n1 places along the counted
                   string at address l1 and returns its ASCII value on the
                   stack.

     $BL+L         ( l1 _ _ _ l1 )

                   Adds a single space to counted string at l1, increments
                   the string count accordingly and returns the string
                   address unchanged.

                   Note that you must be quite sure that there is room to
                   accomodate extra characters at the end of the string
                   storage location.

                   It your responsibility to ensure that this operation is
                   only carried out on strings with sufficient storage space.

     $C>UL         ( l1 - - - padl )

                   Converts counted to uncounted string.

     $CHRL         ( c1 _ _ _ padl )

                   Creates a one character counted string from the character
                   on the stack and stores it at PAD. Returns PAD address on
                   stack.

     $CLEARL       ( l1 _ _ _ )

                   Clears a counted string stored at a 32-bit address on
                   top of stack, making its count null and replacing its
                   characters with the same number of spaces.

     $COMPL        ( l1 l2 _ _ _ flag )

                   Compares two counted strings at addresses l1 and l2,
                   returning flag 1 on stack if identical, otherwise returns
                   flag 0.

                   The variable "CASE" determines whether the comparison is
                   case sensitive or insensitive.

                   If CASE = 0, string search and compare functions are case
                   insensitive.

                   If CASE = 1, string search and compare functions are case
                   sensitive.

     $CONCL        ( l1 l2 _ _ _  )

                   Concatenates two counted strings at addresses l1 and l2,
                   storing result at l2.

                   Note that you must be sure that there is room to
                   accomodate the new string at l2.

                   It your responsibility to ensure that this operation is
                   only carried out on strings with sufficient storage space.

     $CONSTANT     ( _ _ _ )

                   Used in the following way to define a string constant:

                   $CONSTANT NAME $TESTSTRING$
                                  ^          ^  Delimiter $ (Default value)

                   Creates a new HeliOS word NAME and stores TESTSTRING in
                   the body of this word.

                   When NAME is executed later the address of TESTSTRING is
                   returned on the stack.

                   TESTSTRING is stored as a counted null terminated string
                   and DP is longword aligned.

                   See { DELIMITER }.

     $CONSTANTL    ( _ _ _ )

                   As $CONSTANT above except that 32-bit address is returned.

     $CONTL        ( l1 l2 _ _ _ l3 or 0 )

                   Checks to see if string at l2 is part of string at l1,
                   and if it is found returns address l3 of the first
                   character of the matching section on the stack.

                   Otherwise flag 0 is returned.

                   The variable "CASE" determines whether the match is case
                   sensitive or insensitive.

                   If CASE = 0, string search and compare functions are case
                   insensitive.

                   If CASE = 1, string search and compare functions are case
                   sensitive.

     $COPYL        ( l1 l2 _ _ _  )

                   Copies null-terminated ( uncounted ) string at l1 to l2,
                   including final null.

     $DELNEXTL     ( _ _ _ padl )

                   Takes the next string in the input stream delimited by
                   the system string delimiter and forms a counted string
                   at PADL.

                   The address of PADL is returned.

                   This is useful in defining words where a natural and
                   uncomplicated entry of a filename in interpret mode is
                   desirable.

                   This word is more flexible than $NEXTL because it allows
                   spaces within strings.

                   Example:

                   $DELNEXTL $TESTNAME$ <RETURN>
                             ^        ^ System string delimiter.

                   Leaves 32-bit address of string input on HeliOS stack.

                   See also $NEXTL

     $ENDL         ( l1 _ _ _ l2 )

                   Returns l2 = address of last character of counted string
                   at l1.

     $FIRSTL       ( l1 _ _ _ l2 )

                   Returns l2 = address of first non space character scanning
                   forwards through memory from address l1.

     $FORCECL      ( l1 _ _ _ )

                   Makes an uncounted string l1 into a counted one.

     $FORCEUL      ( l1 _ _ _ )

                   Makes a counted string l1 into an uncounted one.

     $LASTL        ( l1 _ _ _ l2 )

                   Returns l2 = address of last non space character scanning
                   backwards from l1.

     $LL           ( l1 n1 _ _ _ padl )

                   Copies a number of characters, n1, from the left end of
                   the counted string stored at a1 and forms from them a
                   counted string at PAD. The address of PAD is returned.

                   If n1 > count of l1, l1 is accepted in full as the new
                   string.

     $ML           ( l1 n1 n2 _ _ _ padl )

                   Copies a number of characters, n2, from the middle of the
                   counted string stored at l1 starting at the character n1 
                   places from the start of string l1. 

                   If there are fewer than n2 characters after n1 those
                   remaining from n1 to the end are accepted.

                   The new counted string is stored at PAD and PAD is 
                   returned.

     $MAKEL        ( l1 n1 _ _ _ padl )

                   Takes a string of length n1 whose first character is at
                   the address l1 and makes it into a counted string at PAD.

                   The address of PAD is returned.

     $NEXTL        ( _ _ _ padl )

                   Takes the next string in the input stream delimited by
                   spaces - not the system string delimiter - and forms a
                   counted string at PADL.

                   The address of PADL is returned.

                   This is useful in defining words where a natural and
                   uncomplicated entry of a filename in interpret mode is
                   desirable.

                   This word is quicker to use but less flexible than
                   $DELNEXTL because it does not allow spaces within
                   strings.

                   Example:

                   $NEXTL TESTNAME <RETURN>
                         ^        ^ Space delimiter.

                   Leaves 32-bit address of string input on HeliOS stack.

                   See also $DELNEXTL

     $PUTL         ( l1 l2 _ _ _ )

                   Make string l1 into uncounted null terminated string at
                   l2.

     $PUTW         ( a1 a2 _ _ _ )

                   Make string a1 into uncounted null terminated string at
                   a2.

     $RL           ( l1 n1 _ _ _ padl )              "string-right"

                   Copies a number of characters, n1, from the right end of
                   the counted string stored at l1 and forms from them a
                   counted string at PAD. The address of PAD is returned.

                   If n1 > count of l1, the string l1 in full is accepted.

     $SEARCHL      ( l1 d1 l2 _ _ _ l3 or 0 )

                   An area of memory starting at address l1 is searched for
                   any occurrence of string l2.

                   The length in bytes of the area of memory to be searched
                   is specified by d1.

                   If a match is found the search is terminated and the
                   address l3 of the first byte of match is returned on
                   the stack.

                   If not flag 0. is returned.

                   N.B.

                   The variable "CASE" determines whether the search is
                   case sensitive or insensitive.

                   If CASE = 0, string search and compare functions are case
                   insensitive.

                   If CASE = 1, string search and compare functions are case
                   sensitive.

                   The variable "DIRECTION" determines whether the search
                   is forwards or backwards.

                   The default value stored in DIRECTION is 1, and this
                   causes searches to be in a forwards direction, towards
                   higher memory addresses.

                   A value of 0 stored in DIRECTION causes searches to be
                   made backward towards lower memory addresses.

     $SEGSIZEL     ( l1 - - - d1 )

                   Looks forward along a string of ASCII characters in memory
                   from address l1 and returns the length of the next word
                   encountered, delimited by spaces.

                   Leading and trailing spaces are ignored.

     $SEGTYPEL     ( l1 - - - l1 )

                   A handy string parsing word which types a single word
                   from within a string of ASCII characters in memory.

                   Types the succeeding word after l1, delimited by spaces,
                   leaving the original address l1 on the stack unchanged.

                   Also trims leading and trailing spaces from the word and
                   transmits just one space to enable tidy single-spaced
                   output of parsed string.

     $SIZEL        ( l1 - - - d1 )

                   Returns the size of an uncounted null-terminated string.

                   Effectively gives the character count to the next null
                   character, with only the ASCII characters of the string
                   counted (NOT the terminating null).

     $SORTL        ( l1 l2 d1 - - - n1 n2 )

                   Compares two uncounted strings at a1 and a2 only up to
                   the length of the shorter string as indicated by the
                   first null character.

                   The flag d1 determines case sensitivity:

                   d1 = 0    ->  Case Insensitive
                   d1 = 1    ->  Case Sensitive

                   The returned values n1 and n2 set up the stack for a
                   simple ">", "<", or "=" test as follows:

                   n1 = 0, n2 = 0  ( - - - 0 0 )    -> Strings Equal
                   n1 = 1, n2 = 0  ( - - - 1 0 )    -> String l1 > String l2
                   n1 = 0, n2 = 1  ( - - - 0 1 )    -> String l1 < String l2

     $SPACE        ( a1 _ _ _ n1 )

                   Returns total length of counted string at a1, including
                   trailing null(s) and count byte, as n1.

                   N.B.

                   n1 is always even.

     $SPACEL       ( l1 _ _ _ d1 )

                   Returns total length of counted string at l1, including
                   trailing null(s) and count byte, as d1.

                   N.B.

                   d1 is always even.

     $STRIPL       ( l1 _ _ _ l1 )

                   The counted string at l1 has all leading and trailing
                   spaces removed and is terminated with the usual null.

                   Returns l1.

     $TRANSL       ( l1 l2 _ _ _ )

                   Make uncounted null terminated string l1 into counted
                   null terminated string at l2.

     $TRIML        ( l1 _ _ _ l1 )

                   The counted string at l1 has all leading and trailing
                   spaces removed and a single space is placed after the last
                   character along with the usual trailing null.

                   Returns l1.

     $TRUNCCL      ( l1 n1 _ _ _ )

                   Truncates a counted string l1 down to n1 characters.

     $TRUNCUL      ( l1 n1 _ _ _ )

                   Truncates an uncounted string l1 down to n1 characters.

     $TYPE         ( a1 _ _ _ )

                   Types a null terminated string a1.

     $TYPEL        ( l1 _ _ _ )

                   Types a null terminated string l1.

     $U>CL         ( l1 - - - padl )

                   Converts uncounted to counted string.

     $VARIABLE     ( n1 _ _ _ )

                   Used in the form:

                   n1 $VARIABLE NAME

                   Creates a new HeliOS word NAME and allocates a space
                   n1+1+1 bytes long in the body of the new word to hold
                   a string with length n1 characters, its count byte, and
                   terminating null.

                   DP is then longword aligned.

                   When NAME is subsequently executed the address of the
                   first byte of the allocated space is returned (16-bit).

     $VARIABLEL    ( n1 _ _ _ )

                   As $VARIABLE above except that 32-bit address is returned.

     $X            ( a1 a2 _ _ _ )

                   Exchanges counted strings at a1 and a2.

                   Takes no account of length, so make sure there is free
                   space for the swap.

     $XL           ( l1 l2 _ _ _ )

                   Exchanges counted strings at l1 and l2.

                   Takes no account of length, so make sure there is free
                   space for the swap.

     (MATCH)       ( a1 a2 n1 _ _ _ flag )

                   Compare n1 characters starting at a1 and a2, and return
                   flag according to match.

     -TEXT         ( a1 n1 a2 _ _ _ flag )

                   Compare n1 characters starting at a1 and a2, and return
                   flag indicating whether they match and if not which binary
                   string has higher value.

                                 flag = 0 -> Match
                                      = positive  a1 > a2
                                      = negative  a2 > a1

                   This operation is case sensitive.

     -TRAILING     ( a1 n1 _ _ _ a1 n2 )

                   Changes count n1 of string starting at a1 to suppress
                   trailing blanks, leaving new count n2 ready for TYPE.

     -TRAILINGL    ( l1 d1 _ _ _ l1 d2 )

                   Changes count d1 of string starting at l1 to suppress
                   trailing blanks, leaving new count d2 ready for TYPEL.

     >LOWERCASEL   ( l1 d1 _ _ _ )

                   Converts string of d1 ASCII characters in memory starting
                   at l1 to lowercase.

     >UPPERCASEL   ( l1 d1 _ _ _ )

                   Converts string of d1 ASCII characters in memory starting
                   at l1 to uppercase.

     ASCII         ( _ _ _ c1 )

                   Returns the ASCII value c1 of the next character in the
                   input stream delimited by spaces.

                   For example:

                   ASCII X  -> Returns "88"

                   This word is state sensitive and works equally in compile
                   or direct mode.

     CASE          ( _ _ _ a1 )   Case sensitivity. ( Default 0 )

                   A variable which controls whether HeliOS string search
                   and comparison functions are case sensitive or
                   insensitive.

                   If = 0, string search and compare functions are case
                   insensitive.

                   If = 1, string search and compare functions are case
                   sensitive.

                   See also $SEARCHL, $CONTL, $COMPL

     COUNT         ( a1 _ _ _ a2 n1 )

                   Converts address a1 of counted string to address a2 of
                   start of string and the character count n1 of string,
                   ready for TYPE, >UPPERCASE etc.

     COUNTL        ( l1 _ _ _ l2 d1 )

                   Converts address l1 of counted string to address l2 of
                   start of string and the character count d1 of string,
                   ready for TYPEL.

     DEL!          ( c1 _ _ _ )

                   Stores character value c1 as current system string
                   delimiter.

     DEL@          ( _ _ _ c1 )

                   Returns value of current system string delimiter as c1.

     DELWORD       ( _ _ _ a1 )

                   Similar to WORD but uses system string delimiter and
                   returns address of HERE on stack as a1.

                   Reads next text in input stream using HeliOS system
                   string delimiter, and stores counted string at HERE
                   with trailing blank.

                   The start of the text to be read is determined by the
                   value stored in the variable BUF, and the input stream
                   pointer >IN, which is initially set to zero.

                   BUF = 0  Input stream is taken from TIB (Command line)
                   BUF = 1  Input stream is taken from Editor 1
                   BUF = 2  Input stream is taken from Editor 2
                   BUF = -1 Input stream is taken from Editor 3
                   BUF = -2 Input stream is taken from OUT Editor
                   BUF = 3  Input stream is taken from a memory buffer
                            whose 32-bit start address is in the double
                            length variable SOURCESTART.


                   See { DELIMITER }.

                   N.B. Take care when using DELWORD in interactive mode
                        rather than within a COLON definition: you may
                        upset the internal pointers used by the system as
                        it uses WORD/DELWORD to interpret the input stream.

                        In these cases use GETWORDL instead.

                   See also BUF, GETWORDL, SOURCESTART, WORD

     DELWORDL      ( _ _ _ l1 )

                   Similar to WORDL but uses system string delimiter and
                   returns address of HERE on stack as l1.

                   Reads next text in input stream using HeliOS system
                   string delimiter, and stores counted string at HERE
                   with trailing blank.

                   The start of the text to be read is determined by the
                   value stored in the variable BUF, and the input stream
                   pointer >IN, which is initially set to zero.

                   BUF = 0  Input stream is taken from TIB (Command line)
                   BUF = 1  Input stream is taken from Editor 1
                   BUF = 2  Input stream is taken from Editor 2
                   BUF = -1 Input stream is taken from Editor 3
                   BUF = -2 Input stream is taken from OUT Editor
                   BUF = 3  Input stream is taken from a memory buffer
                            whose 32-bit start address is in the double
                            length variable SOURCESTART.

                   See { DELIMITER }.

                   N.B. Take care when using DELWORDL in interactive mode
                        rather than within a COLON definition: you may
                        upset the internal pointers used by the system as
                        it uses WORD/DELWORD to interpret the input stream.

                        In these cases use GETWORDL instead.

                   See also BUF, GETWORDL, SOURCESTART, WORD

     DIRECTION     ( a1 - - - )

                   This 16-bit addressed 16-bit variable is used to set
                   whether the $SEARCH routine searches from its initial
                   position forwards or backwards in memory.

                   The default value stored in DIRECTION is 1, and this
                   causes searches to be in a forwards direction, towards
                   higher memory addresses.

                   A value of 0 stored in DIRECTION causes searches to be
                   made backward towards lower memory addresses.


     GETWORDL       ( l1 c1 _ _ _ l1 )

                   Similar to WORD, using delimiter c1, but taking l1 as
                   the start of its input.

                   The string is compiled at HERE, as with WORD and DELWORD,
                   but transferred to PAD, which is returned as l1.

                   This allows more flexible use of GETWORDL in those
                   circumstances when the parsing of a command line
                   including GETWORDL would cause immediate overwriting
                   of the GETWORDL string by the next use of WORD.

                   For similar reasons the input stream pointer >IN is not
                   altered by GETWORDL.

                   See also DELWORD, WORD

     WORD          ( c1 _ _ _ a1 )

                   Reads next text in input stream with delimiter c1 and
                   stores counted string at HERE with trailing blank.

                   The address of HERE is returned on stack as a1.

                   The start of the text to be read is determined by the
                   value stored in the variable BUF, and the input stream
                   pointer >IN, which is initially set to zero.

                   BUF = 0  Input stream is taken from TIB (Command line)
                   BUF = 1  Input stream is taken from Editor 1
                   BUF = 2  Input stream is taken from Editor 2
                   BUF = -1 Input stream is taken from Editor 3
                   BUF = -2 Input stream is taken from OUT Editor
                   BUF = 3  Input stream is taken from a memory buffer
                            whose 32-bit start address is in the double
                            length variable SOURCESTART.

                   N.B. Take care when using WORD in interactive mode rather
                        than within a COLON definition: you may upset the
                        internal pointers used by the system as it uses WORD
                        to interpret the input stream.

                        In these cases use GETWORDL instead.

                   See also BUF, DELWORD, WORDL, GETWORDL, SOURCESTART

     WORDL         ( c1 _ _ _ l1 )

                   Reads next text in input stream with delimiter c1 and
                   stores counted string at HERE with trailing blank.

                   The address of HERE is returned on stack as l1.

                   The start of the text to be read is determined by the
                   value stored in the variable BUF, and the input stream
                   pointer >IN, which is initially set to zero.

                   BUF = 0  Input stream is taken from TIB (Command line)
                   BUF = 1  Input stream is taken from Editor 1
                   BUF = 2  Input stream is taken from Editor 2
                   BUF = -1 Input stream is taken from Editor 3
                   BUF = -2 Input stream is taken from OUT Editor
                   BUF = 3  Input stream is taken from a memory buffer
                            whose 32-bit start address is in the double
                            length variable SOURCESTART.

                   N.B. Take care when using WORDL in interactive mode rather
                        than within a COLON definition: you may upset the
                        internal pointers used by the system as it uses WORD
                        to interpret the input stream.

                        In these cases use GETWORDL instead.

                   See also BUF, DELWORD, GETWORDL, SOURCESTART


------------
TERMINAL I/O
------------

     These functions relate to the use of text input and output in via
     HeliOS text "console" windows.

     HeliOS uses an extended version of the Amiga console device to give
     the most powerful automated text handling and I/O of any programming
     language on the Amiga.

     The HeliOS text handling system, with its "text stream" mechanism and
     superbly well featured input and output toolkit functions is more
     powerful than anything you would be able to create or yourself in
     many months of programming.

     All this power is available by the use of very simple commands, and in
     conjunction with the excellent HeliOS input event handling and string
     manipulation routines, the set of functions described below will enable
     you to write text applications more easily than ever before.

     All the facilities of text input and output can easily be attached to
     and removed from any Intuition window by the use of simple single word
     functions.

     To attach ALL the functionality of the HeliOS user input system to
     any window you simply use the word MAKEINWINDOW, and to restore this
     functionality to the main HeliOS interpreter environment you simply
     say FORTHINWINDOW.

     To attach ALL the functionality of the HeliOS text output system to
     any window you simply use the word MAKEOUTWINDOW, and to restore this
     functionality to the main HeliOS interpreter environment you simply
     say FORTHOUTWINDOW.

     These functions are detailed in the dictionary section on SCREENS AND
     WINDOWS.

     Notice that you can have different windows specified as "input" and
     "output" windows, but you can only have one "input" and one "output"
     window specified at any one time.


     #IN           ( _ _ _ d1 )

                   Displays cursor and EXPECTs keyboard input of a number
                   which is placed on the stack.

                   This function, unlike its companion function #REDO, does
                   not allow you to preset the number string, but always
                   clears it before presentation.

                   Check the variable DPL as required.

                   #IN is fairly versatile, so please read the following
                   carefully to take full advantage of its features.

                   #IN uses INSPECTL and can use FILLCHAR for "0" filled
                   fields, which is quite useful in some applications.

                   The length of the editable number field is set by the
                   dedicated variable #INSPAN.

                   #INSPAN can be anything from 1-32, but if it lies outside
                   this range the #IN function itself will automatically
                   reset #INSPAN to 32, with no error.

                   #IN behaviour is controlled by a "flag" variable #INFLAG.

                   #INFLAG has two actions, one on input and one on output.

                   On input #INFLAG tells #IN how to handle errors in
                   numeric entry.

                   If #INFLAG is set to non-zero BEFORE calling #IN, it
                   will cause #IN to return only when at least one character
                   has been entered and the number is legal with the current
                   number base.

                   i.e.

                   It will not allow a simple pressing of RETURN on a blank
                   field, or the entry of hex characters if base is decimal.

                   In case of error it will simply cause #IN to recycle
                   until a valid number is entered.

                   If #INFLAG is set to zero BEFORE calling #IN, it will
                   cause #IN to return when RETURN is pressed, whatever the
                   validity of the number entered.

                   In the case of error the variable #INFLAG is set to 0 for
                   "ERROR", and the number returned by #IN will be zero.

                   So...

                   If #INFLAG is set to non-zero BEFORE calling #IN, error
                   checking is enabled so that only a valid legal actual
                   number is returned.

                   If #INFLAG is set to 0 BEFORE calling #IN, error checking
                   is disabled so that #IN returns as soon as RETURN is
                   pressed.

                   #INFLAG also acts as an error flag on return from #IN.

                   If #INFLAG is non-zero on return, the #IN operation was
                   OK and the number returned by #IN is valid.

                   If #INFLAG is zero on return, the #IN operation was in
                   some way faulty and the number returned by #IN is zero,
                   and invalid.

                   There is a companion-function to #IN, called #REDO, which
                   allows you to re-edit an existing number. (See #REDO)

                   The constant #INBUFF returns a longword (32-bit) pointer
                   the 36 byte text buffer used by #IN and #REDO.

                   Because #IN/#REDO use INSPECTL on the #INBUFF buffer, you
                   can "in theory" preset the number string before calling
                   #IN/#REDO.

                   This is where the distinction between #REDO and #IN lies.

                   #IN always starts with the text buffer being cleared
                   and a new blank number entry field being presented to
                   the user.

                   #REDO always preserves the old number string in the text
                   buffer.

                   FILLCHAR is used to supply the "null" fill character.

                   So:

                   Use #REDO if you want to preset the #IN text buffer with
                   a number.

                   Use #IN if you want to initially clear the #IN text
                   buffer automatically every time.

                   See also #INBUFF, #INFLAG, #INSPAN, #REDO.

     #INBUFF       ( _ _ _ l1 )

                   The constant #INBUFF returns a longword (32-bit) pointer
                   the 36 byte text buffer used by #IN and #REDO.

                   See also #IN, #INFLAG, #INSPAN, #REDO.

     #INFLAG       ( _ _ _ a1 )

                   Returns the address a1 of the variable #INFLAG which
                   determines the behaviour of #IN.

                   #INFLAG has two actions, one on input and one on output.

                   On input #INFLAG tells #IN how to handle errors in
                   numeric entry.

                   If #INFLAG is set to non-zero BEFORE calling #IN, it
                   will cause #IN to return only when at least one character
                   has been entered and the number is legal with the current
                   number base.

                   i.e.

                   It will not allow a simple pressing of RETURN on a blank
                   field, or the entry of hex characters if base is decimal.

                   In case of error it will simply cause #IN to recycle
                   until a valid number is entered.

                   If #INFLAG is set to zero BEFORE calling #IN, it will
                   cause #IN to return when RETURN is pressed, whatever the
                   validity of the number entered.

                   In the case of error the variable #INFLAG is set to 0 for
                   "ERROR", and the number returned by #IN will be zero.

                   So...

                   If #INFLAG is set to non-zero BEFORE calling #IN, error
                   checking is enabled so that only a valid legal actual
                   number is returned.

                   If #INFLAG is set to 0 BEFORE calling #IN, error checking
                   is disabled so that #IN returns as soon as RETURN is
                   pressed.

                   #INFLAG also acts as an error flag on return from #IN.

                   If #INFLAG is non-zero on return, the #IN operation was
                   OK and the number returned by #IN is valid.

                   If #INFLAG is zero on return, the #IN operation was in
                   some way faulty and the number returned by #IN is zero,
                   and invalid.


                   See also #IN, #INBUFF, #INSPAN, #REDO.

     #INSPAN       ( _ _ _ a1 )

                   Returns the address a1 of the variable #INSPAN which
                   determines how many characters #IN accepts from the
                   keyboard.  Always reset #INSPAN to 10 after use.

                   See also #IN, #INBUFF, #INFLAG, #REDO.

     #REDO         ( _ _ _ d1 )

                   Displays cursor and EXPECTs keyboard input of a number
                   which is placed on the stack.

                   This function, unlike its companion function #IN, allows
                   you to preset the number string before presentation.

                   Check the variable DPL as required.

                   #REDO is fairly versatile, so please read the following
                   carefully to take full advantage of its features.

                   #REDO uses INSPECTL and can use FILLCHAR for "0" filled
                   fields, which is quite useful in some applications.

                   The length of the editable number field is set by the
                   dedicated variable #INSPAN.

                   #INSPAN can be anything from 1-32, but if it lies outside
                   this range the #REDO function itself will automatically
                   reset #INSPAN to 32, with no error.

                   #REDO behaviour is controlled by "flag" variable #INFLAG.

                   #INFLAG has two actions, one on input and one on output.

                   On input #INFLAG tells #REDO how to handle errors in
                   numeric entry.

                   If #INFLAG is set to non-zero BEFORE calling #REDO, it
                   will cause #REDO to return only when at least 1 character
                   has been entered and the number is legal with the current
                   number base.

                   i.e.

                   It will not allow a simple pressing of RETURN on a blank
                   field, or the entry of hex characters if base is decimal.

                   In case of error it will simply cause #REDO to recycle
                   until a valid number is entered.

                   If #INFLAG is set to zero BEFORE calling #REDO, it will
                   cause #REDO to return when RETURN is pressed, whatever
                   the validity of the number entered.

                   In the case of error the variable #INFLAG is set to 0 for
                   "ERROR", and the number returned by #REDO will be zero.

                   So...

                   If #INFLAG is set to non-zero BEFORE calling #REDO, error
                   checking is enabled so that only a valid legal actual
                   number is returned.

                   If #INFLAG is set to 0 BEFORE calling #REDO, error
                   checking is disabled so that #REDO returns as soon as
                   RETURN is pressed.

                   #INFLAG also acts as an error flag on return from #REDO.

                   If #INFLAG is non-zero on return, the #REDO operation was
                   OK and the number returned by #REDO is valid.

                   If #INFLAG is zero on return, the #REDO operation was in
                   some way faulty and the number returned by #REDO is zero,
                   and invalid.

                   There is a companion-function to #REDO, called #IN, which
                   allows you to edit only a new number. (See #IN)

                   The constant #INBUFF returns a longword (32-bit) pointer
                   the 36 byte text buffer used by #IN and #REDO.

                   Because #IN/#REDO use INSPECTL on the #INBUFF buffer, you
                   can "in theory" preset the number string before calling
                   #IN/#REDO.

                   This is where the distinction between #REDO and #IN lies.

                   #IN always starts with the text buffer being cleared
                   and a new blank number entry field being presented to
                   the user.

                   #REDO always preserves the old number string in the text
                   buffer.

                   FILLCHAR is used to supply the "null" fill character.

                   So:

                   Use #REDO if you want to preset the #IN text buffer with
                   a number.

                   Use #IN if you want to initially clear the #IN text
                   buffer automatically every time.

                   See also #INBUFF, #INFLAG, #INSPAN, #IN.

     $.            ( a1 _ _ _ )

                   Prints counted string stored at a1.

     $.L           ( l1 _ _ _ )

                   Prints counted string stored at l1.

     $?L           ( n1 _ _ _ padl )

                   Displays cursor and EXPECTs a keyboard string entry up to
                   n1 characters. Counted string is put at PADL, which is
                   returned.

     $?!L          ( l1 n1 _ _ _ )

                   Displays cursor and EXPECTs a keyboard string entry up to
                   n1 characters which is stored as a counted string at l1.

     $I?L          ( n1 _ _ _ padl )

                   Displays cursor and INSPECTs a keyboard string entry up to
                   n1 characters at PAD.

                   The string can be pre-stored at PAD in uncounted form.

                   The string is returned at PADL in counted form.

     $I?!L         ( l1 n1 _ _ _ )

                   Displays cursor and INSPECTs a keyboard string entry up to
                   n1 characters at PAD, having first copied the counted
                   string at l1 to PAD.

                   The entered string is copied back from PAD and returned
                   at l1 in counted form.

     $KEYL         ( _ _ _ padl )

                   Checks keyboard to see if any key is pressed, and if so
                   forms a single character counted string stored at PAD.

                   Otherwise if no keypress is detected 0 is stored at PAD.
                   In either case the address of PAD is returned.

     (.")          ( _ _ _ )

                   The run-time procedure compiled by ." which transmits the
                   following in line text to the output device.

     ."            ( _ _ _ )

                   Used in the form:

                   ." XXX"

                   Outputs the string XXX delimited by the " following.

                   Note the essential space after .".

     .$            ( _ _ _ )

                   Used in the form

                   .$ XXX$

                   or

                   .$ $XXX$

                   Outputs the string XXX delimited by the system string
                   delimiter ($ is the default).

                   Very similar to ." but more flexible because you can
                   include spaces in the string.

     .|            ( _ _ _ )

                   Used in the form

                   .| XXX|

                   or

                   .| |XXX|

                   Outputs the string XXX delimited by the "|" character
                   as a delimiter and adds a line feed.

                   Thus:

                   .| My line of text|

                   is a short way of saying:

                   .$ My line of text$ CR


     ?KEY          ( c1 _ _ _ flag )

                   Check to see if key generating character c1 is pressed.

                   (c1 = ASCII character code)

     ?TERMFLAG     ( _ _ _ l1 )

                   Returns longword address l1 of an internal variable which
                   if set causes the value of any user action to be latched
                   until ?TERMINAL is used.

                   Thus, storing 1 in ?TERMFLAG will allow you to check for
                   a user action even AFTER the action has ceased.

                   Using ?TERMINAL clears the latch.

     ?TERMINAL     ( _ _ _ c1 or 0 )

                   Check to see if any key is pressed.

                   Returns ASCII value of key character or 0 if no key is
                   pressed.

     AMIGAKEY      ( - - - n1 )

                   Returns:

                   n1 = 0 if neither Amiga key is being held down.
                   n1 = 1 if left Amiga key is being held down.
                   n1 = 2 if right Amiga key is being held down.
                   n1 = 3 if both Amiga keys are being held down.

                   This does not affect normal KEY or ?TERMINAL key
                   return values.

     BOLDOFF       ( _ _ _ )

                   Switch bold off.

     BOLDON        ( _ _ _ )

                   Switch bold on.

     BPENSET       ( n1 _ _ _ )

                   Set B-Pen to n1. ( Sets console colour.)

     CLEARHISTORY  ( _ _ _ )

                   Clear EXPECTL history store. See EXPECTL

     CONHOFFSET    ( - - - l1 )

                   Returns 32-bit address of initial Horizontal pixel offset
                   used by SCRWIN function to place the top left corner of a
                   console sub-window.

                   N.B.

                   This value only affects SCRWIN, and only affects the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished using offbeat values!.

                   See also :

                   GETCONORIGIN, SETCONORIGIN, FCONORIGIN, CONVOFFSET,
                   CONHSCALE, CONVSCALE

     CONHSCALE     ( - - - l1 )

                   Returns 32-bit address of Horizontal character multiplier
                   used by SCRWIN function to place the top left corner of a
                   console sub-window.

                   This relates to horizontal font resolution.

                   N.B.

                   This value only affects SCRWIN, and only affects the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished using offbeat values!.

                   See also :

                   GETCONORIGIN, SETCONORIGIN, FCONORIGIN, CONHOFFSET,
                   CONVOFFSET, CONVSCALE

     CONVOFFSET    ( - - - l1 )

                   Returns 32-bit address of initial Vertical downward pixel
                   offset used by SCRWIN function to place the top left corner
                   of a console sub-window.

                   N.B.

                   This value only affects SCRWIN, and only affects the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished using offbeat values!.

                   See also :

                   GETCONORIGIN, SETCONORIGIN, FCONORIGIN, CONHOFFSET,
                   CONHSCALE, CONVSCALE

     CONVSCALE     ( - - - l1 )

                   Returns 32-bit address of Vertical character multiplier
                   used by SCRWIN function to place the top left corner of a
                   console sub-window.

                   This relates to vertical font resolution.

                   N.B.

                   This value only affects SCRWIN, and only affects the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished using offbeat values!.

                   See also :

                   GETCONORIGIN, SETCONORIGIN, FCONORIGIN, CONHOFFSET,
                   CONVOFFSET, CONHSCALE

     CR            ( _ _ _ )

                   Transmits carriage return function to output.

     CURBK         ( n1 _ _ _ )

                   Move cursor back n1 places.

     CURDN         ( n1 _ _ _ )

                   Move cursor down n1 places.

     CURFW         ( n1 _ _ _ )

                   Move cursor forward n1 places.

     CURGET        ( _ _ _ n1 n2 )

                   Reads cursor position with respect to current window and
                   does not alter variables CURCOL and CURROW.

                   Returns n1=column, n2=row.

     CURHM         ( _ _ _ )

                   Move cursor to top left corner.

     CURNL         ( n1 _ _ _ )

                   Move to start of next line n1 times.

     CUROFF        ( _ _ _ )

                   Switch off cursor.

     CURON         ( _ _ _ )

                   Switch on cursor.

     CURPL         ( n1 _ _ _ )

                   Move to start of previous line n1 times.

     CURPOS        ( n1 n2 _ _ _ )

                   Sets n1=column and n2=row into the variables CURCOL and
                   CURROW and places cursor on screen in position in current
                   window.

                   N.B.

                   1=first position

     CURPUT        ( n1 n2 _ _ _ )

                   Sets cursor position with respect to current window and
                   does not alter variables CURCOL and CURROW.

                   Sets column=n1, row=n2.

                   N.B.

                   1=first position

     CURREAD       ( _ _ _ n1 n2 )

                   Reads cursor position with respect to current window into
                   the variables CURCOL and CURROW and returns n1=column,
                   n2=row.

     CURSAVE       ( _ _ _ )

                   Save current window cursor position into CURCOL and
                   CURROW.

     CURSET        ( _ _ _ )

                   Set cursor in window at position stored in CURCOL and
                   CURROW.

     CURSTAT       ( _ _ _ flag )

                   Returns cursor on off status for current stream.

     CURUP         ( n1 _ _ _ )

                   Move cursor up n1 places.

     DEL           ( n1 _ _ _ )

                   Delete n1 chars --> right.

     EDWINDOW      ( - - - a1 )

                   Returns a1, the address of a 32-bit variable which will
                   determine, if non-zero, the length of a screen window
                   within which a longer string can be edited using EXPECTL
                   or INSPECTL.

                   If you wish to use this sliding subwindow feature, all
                   you have to do is put your window length in EDWINDOW
                   before calling EXPECTL or INSPECTL.

                   Remember to reset EDWINDOW to zero after using it, to
                   avoid accidental errors later.

     EEL           ( _ _ _ )

                   Erase to end of line.

     EED           ( _ _ _ )

                   Erase to end of display.

     EMIT          ( c1 _ _ _ )

                   Output character c1 to current console text stream.

     EXPECTL       ( l1 n1 _ _ _ )

                   Fills n1 bytes of memory from address l1 with ASCII
                   spaces, displays cursor at current position and accepts
                   string input up to n1 characters.

                   The left and right cursor, delete and backdelete editor
                   functions are available to edit the input line, as well
                   as SHIFT-LEFT-CURSOR and SHIFT-RIGHT-CURSOR to move to
                   the start or end of the text line.

                   Pressing the <x> key along with either of the <Amiga>
                   keys will erase the whole buffer and return the cursor
                   to the start of the text edit field.

                   When return is pressed the string is left at l1 with
                   all trailing spaces suppressed and with following null.

                   A History feature accessed via the up and down cursor
                   keys is available.

                   (See ONHISTORY, OFFHISTORY, CLEARHISTORY)

                   A pictured input facility is included.

                   (See HOP, VHOP,HOPCOL,HOPROW, EDWINDOW and HOPSTART)

                   A keystroke filter is included.

                   (See KEYFILTER)

                   Character count is stored in SPAN.

                   Outputs c1 to current stream.

                   HOPCOL will contain the latest cursor position after exit.

                   See also INSPECTL.

     FCONORIGIN  ( - - - )

                   Resets pixel offsets used by SCRWIN function to place
                   the top left corner of a console sub-window.

                   i.e. Initial Horizontal pixel offset.
                        Initial Vertical downward pixel offset.
                        Horizontal character multiplier.
                        Vertical character multiplier.

                   NB.
                       These values only affect SCRWIN, and only affect the
                       top left corner placement of the sub-window.

                       It is important to remember to reset standard full
                       window/8-pixel-font values by using FCONORIGIN when
                       you are finished using offbeat values!.

                   See also:

                   SETCONORIGIN, GETCONORIGIN, CONHOFFSET, CONVOFFSET,
                   CONHSCALE, CONVSCALE

     FILEOFF       ( _ _ _ )

                   Switch off ALT file output.

     FILEON        ( _ _ _ )

                   Switch on ALT file output.

     FILLCHAR      ( _ _ _ a1 )

                   This is a variable which contains the ASCII character
                   which EXPECTL/INSPECTL will use to replace deleted
                   characters and do end-of-string fills.

                   Normally this will be the "space" character, obviously,
                   but it is occasionally desirable in some number input
                   applications to use "0" as a fill character.

     FPENSET       ( n1 _ _ _ )

                   Set F-Pen to n1. ( Sets console colour.)

     FSTATUS       ( _ _ _ )

                   Refresh HeliOS Status display.

     GETCONORIGIN  ( - - - n1 n2 n3 n4)

                   Get current pixel offsets used by SCRWIN function to place
                   the top left corner of a console sub-window.

                   n1 = Initial Horizontal pixel offset.
                   n2 = Initial Vertical downward pixel offset.
                   n3 = Horizontal character multiplier.
                   n4 = Vertical character multiplier.

                   Note that the pixel offsets may be positive or negative.

                   The character multipliers are pixel values by which the
                   window top left corner character positions specified in
                   SCRWIN are multiplied to give the pixel position for the
                   top left corner of the text window.

                   Character multipliers relate to horizontal and vertical
                   font resolution, and would normally each be set to 8 for
                   a standard 8x8 pixel font.

                   For example, if you set the vertical character multiplier
                   to 8, and the initial vertical downward pixel offset to
                   5, like this:

                   0 5 8 8 SETCONORIGIN

                   then say

                   20 12 40 8 SCRWIN

                   the top left corner of the text window will start at
                   vertical pixel position 101(=12x8+5).

                   N.B.

                   These values only affect SCRWIN, and only affect the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished using offbeat values!.

                   See also:

                   SETCONORIGIN, FCONORIGIN, CONHOFFSET, CONVOFFSET,
                   CONHSCALE, CONVSCALE

     HISTORY       ( n1 _ _ _ )

                   Switches on and off EXPECTL History feature.

                   If n1 = 0,  History is switched off.

                   If n1 = 1,  History is switched on.

                   Note that the internal function which gets HeliOS user 
                   input via the command lines automatically switches on 
                   the History feature.

     HOP           ( - - - a1 )

                   Returns a1, the address of a variable which EXPECTL will
                   use to determine whether to leave its editing action when
                   the user reaches the left or right end of the edit buffer.

                   If HOP = 0, EXPECTL will behave as normal and only return
                   after <RET> is pressed.

                   IF HOP is > 0, EXPECTL will return if the user reaches
                   either end of the edit buffer and then tries to cursor
                   further along.

                   If the user tried to go left, HOP is decremented.
                   If the user tried to go right, HOP is incremented.

                   This can be used to perform pictured input. effectively
                   allowing you to control movement between adjacent fields
                   in a series of on-screen areas forming parts of a linked
                   string input.

                   When using this feature always set HOP to a value greater
                   than 2, so that it will never be decremented to zero.

                   Note also that the variable HOPSTART will always contain
                   the position in the editor buffer which the user was at
                   when the HOP was taken. The value in HOPSTART will be used
                   to reset the editing position when the editor is entered
                   if HOP or VHOP are non-null. This allows you to keep track
                   of left and right movement and enter at the end of the
                   editor if required.

                   See also VHOP,HOPCOL,HOPROW,HOPSTART,INSPECTL and EXPECTL.

     HOPCOL        ( - - - a1 )

                   Returns a1, the address of a 16-bit variable which will
                   force the Cursor Column position to whatever value is in
                   HOPCOL if VHOP is being employed.

                   HOPCOL overrides HOPSTART for column position if it is
                   non-zero and VHOP is set.

                   HOPCOL will be added to normal start position.

                   HOPCOL will contain the latest cursor position after exit
                   from the EXPECTL/INSPECTL line editor.

     HOPROW        ( - - - a1 )

                   Returns a1, the address of a 16-bit variable which will
                   force the Cursor Row position to whatever value is in
                   HOPROW if VHOP is being employed.

                   HOPROW will be added to normal start position.

     HOPSTART      ( - - - a1 )

                   Returns a1, the address of a 32-bit variable which will
                   contain the position along the EXPECTL/INSPECTL editor
                   line where a HOP or VHOP was taken.

                   HOPSTART can also be used to set the position along the
                   editor line where the editing action will start upon first
                   entry to the editor. Simply insert the displacement along
                   the line required as a 32-bit number into HOPSTART before
                   calling EXPECTL/INSPECTL.

                   This will only be implemented if HOP or VHOP are non-null.

     INITFSTREAMS  (  _ _ _ )

                   Initialise HeliOS Stream system values.

     INITSTREAM    ( n1 _ _ _ )

                   Initialise Stream n1 values.

     INS           ( n1 _ _ _ )

                   Insert n1 chars --> right.

     INSPECTL      ( l1 n1 _ _ _ )

                   Displays cursor at current position and the n1 bytes
                   starting at memory address l1. String input is then
                   accepted to modify the displayed characters and as in
                   EXPECTL the full range of editor functions are available
                   to edit the input line.

                   (See EXPECTL for details)

                   When return is pressed the string is left at l1 with all
                   trailing spaces suppressed and with two zero bytes
                   following.

                   HOPCOL will contain the latest cursor position after exit

                   All the special features of EXPECTL are provided, and in
                   particular you will probably find that for pictured input
                   INSPECTL will prove more useful than EXPECTL.

                   PLEASE READ THE NOTES FOR EXPECTL, HOP, VHOP, EDWINDOW
                   HOPCOL, HOPROW, AND HOPSTART.

     INVOFF        ( _ _ _ )

                   Sets output for current stream to non-inverse video.

     INVON         ( _ _ _ )

                   Sets output for current stream to inverse video.

     ITALOFF       ( _ _ _ )

                   Switch italic off.

     ITALON        ( _ _ _ )

                   Switch italic on.

     KEY           ( _ _ _ c1 )

                   Waits for keyboard entry and returns character input.

     KEYCODE       ( _ _ _ c1 )

                   Returns current keycode in keyboard buffer.

     KEYFILTER     ( - - - a1 )

                   Returns the address a1 of the variable which determines
                   the action of the key filter incorporated in EXPECTL.

                   If KEYFILTER contains 0, no filter action will take place.

                   If you wish keys passed to EXPECTL to be filtered, place
                   the CFA of your filter routine in KEYFILTER. Remember to
                   switch off when you are finished!

                   Your filter routine will recieve the latest key pressed
                   on the stack, and can do whatever you require before
                   passing the value back.

                   If you wish to simply nullify a key value, simply replace
                   the stack value with 0, which will be ignored by EXPECTL.

     KEYLCASE      ( c1 _ _ _ c2 )

                   Translates c1 to a non-shifted character, c2.

                   Useful if you want to give the user the option of pressing
                   alphabetic keys in either case in response to prompts.

                   KEYLCASE converts either response to the same code.

     KEYS          ( _ _ _ )

                   Enters current window and transmits all keyboard input
                   to the display.

                   Exit using ESC.

     KEYUCASE      ( c1 _ _ _ c2 )

                   Translates c1 to a shifted upper case character, c2.

                   Useful if you want to give the user the option of pressing
                   alphabetic keys in either case in response to prompts.

                   KEYUCASE converts either response to the same code.

     LEFTMOUSE     ( _ _ _ flag )

                   Flags whether left mouse is currently pressed or not.

     LNDEL         ( _ _ _ )

                   Delete line.

     LNINS         ( _ _ _ )

                   Insert line.

     MAXCOL        (  _ _ _ a1 )

                   Variable holding maximum column value (set by WBOUNDS).

     MAXROW        (  _ _ _ a1 )

                   Variable holding maximum row value (set by WBOUNDS).

     OUTOFF        ( _ _ _ )

                   Switches off automatic OUT increment, whereby the 32-bit
                   variable OUT is incremented with each character output to
                   the console text output stream.

     OUTON         ( _ _ _ )

                   Switches on automatic OUT increment, whereby the 32-bit
                   variable OUT is incremented with each character output to
                   the console text output stream.

     PLAINON       ( _ _ _ )

                   Sets output for current stream to plain text.

     QUALIFIER     ( - - - a1 )

                   Variable (16-bit) holding Qualifier code of last keypress.

     RAWKEY        ( - - - a1 )

                   Variable (16-bit) holding RawKey code of last keypress.

     RIGHTMOUSE    ( _ _ _ flag )

                   Flags whether right mouse is currently pressed or not.

     SCRCLR        ( _ _ _ )

                   Clear current window and move cursor to top left.

     SCRDN         ( n1 _ _ _ )

                   Scroll down n1 lines.

     SCRUP         ( n1 _ _ _ )

                   Scroll up n1 lines.

     SCRWIN        ( n1 n2 n3 n4 _ _ _ )

                   Sets current stream window parameters and homes cursor.

                   n1 = Top left window corner screen column. (1=first)
                   n2 = Top left window corner screen row. (1=first)
                   n3 = Width in characters.
                   n4 = Height in characters.

     SETCONORIGIN  ( n1 n2 n3 n4 - - - )

                   Set up pixel offsets used by SCRWIN function to place the
                   top left corner of a console sub-window.

                   n1 = Initial Horizontal pixel offset.
                   n2 = Initial Vertical downward pixel offset.
                   n3 = Horizontal character multiplier.
                   n4 = Vertical character multiplier.

                   Note that the pixel offsets may be positive or negative.

                   The character multipliers are pixel values by which the
                   window top left corner character positions specified in
                   SCRWIN are multiplied to give the pixel position for the
                   top left corner of the text window.

                   Character multipliers relate to horizontal and vertical
                   font resolution, and would normally each be set to 8 for
                   a standard 8x8 pixel font.

                   For example, if you set the vertical character multiplier
                   to 8, and the initial vertical downward pixel offset to
                   5, like this:

                   0 5 8 8 SETCONORIGIN

                   then say

                   20 12 40 8 SCRWIN

                   the top left corner of the text window will start at
                   vertical pixel position 101(=12x8+5).

                   N.B.

                   These values only affect SCRWIN, and only affect the
                   top left corner placement of the sub-window.

                   It is important to remember to reset standard full
                   window/8-pixel-font values by using FCONORIGIN when
                   you are finished.

                   See also :

                   GETCONORIGIN, FCONORIGIN, CONHOFFSET, CONVOFFSET,
                   CONHSCALE, CONVSCALE

     SETGR         ( n1 _ _ _ )

                   Select Graphic rendition n1.

     SHIFTOFF      ( _ _ _ )

                   Switch shift off.

     SHIFTON       ( _ _ _ )

                   Switch shift on.

     SPACE         ( _ _ _ )

                   Transmits space function to output.

     SPACES        ( n1 _ _ _ )

                   Transmits n1 spaces to output.

     STREAM        ( n1 _ _ _ )

                   Sets current stream number, n1, from 0 to 9.

     STREAMNO      ( _ _ _ n1 )

                   Returns number of current output stream.

     TYPE          ( a1 n1 _ _ _ )

                   Outputs n1 characters starting at address a1.

     TYPEL         ( l1 d1 _ _ _ )

                   Outputs d1 characters starting at address l1.

     ULINEOFF      ( _ _ _ )

                   Switch uline off.

     ULINEON       ( _ _ _ )

                   Switch uline on.

     VHOP          ( - - - a1 )

                   Returns a1, the address of a variable which EXPECTL will
                   use to determine whether to leave its editing action when
                   the user presses the up or down cursor keys.

                   If VHOP = 0, EXPECTL will behave as normal and only return
                   after <RET> is pressed.

                   If the History function is switched on VHOP will not be
                   implemented.

                   IF VHOP is > 0, EXPECTL will return if the user presses
                   either the up or down cursor keys.

                   If the user presses up cursor key, VHOP is decremented.
                   If the user presses down cursor key, VHOP is incremented.

                   This can be used to perform pictured input. effectively
                   allowing you to control movement between adjacent fields
                   in a series of on-screen areas forming parts of a linked
                   string input.

                   When using this feature always set VHOP to a value greater
                   than 2, so that it will never be decremented to zero.

                   Note also that the variable HOPSTART will always contain
                   the position in the editor buffer which the user was at
                   when the HOP was taken. The value in HOPSTART will be used
                   to reset the editing position when the editor is entered
                   if HOP or VHOP are non-null. This allows you to keep track
                   of left and right movement and enter at the end of the
                   editor if required.

                   As an additional facility, if VHOP is non-zero the two
                   variables HOPCOL and HOPROW, if they are non-zero, will
                   be added to the cursor start position.

                   See also HOP,HOPCOL,HOPROW,HOPSTART,INSPECTL and EXPECTL.

     WBOUNDS       ( _ _ _ )

                   Update variables MAXCOL and MAXROW which represent the
                   boundaries of the current window.


-----
TOOLS
-----

     This section contains a miscellaneous "bag of tricks" which you would
     be advised to inspect from time to time: there are some very useful
     functions in here.

     $FINDEDIT     ( n1 _ _ _ )

                   Where:

                   n1 = The number of the HeliOS editor which will be used.

                   Enters Editor n1, loads a file, and searches for the
                   first occurence of a designated string.

                   The designated string is left in the editor Find string
                   gadget text buffer, ready for use in repeated searches.

                   The $DELNEXTL function is used internally to read a
                   following "search" string, and then $NEXTL is used to
                   read a following filename string.

                   The format for using $FINDEDIT is very simple.

                   For example, to load the file "S:startup-sequence" into
                   Editor3 and then find the first "mount" command, you
                   would say:

                   3 $FINDEDIT $mount$  S:startup-sequence
                               ^     ^ ^                  ^
                               |     | |                  |
                               |     | File name delimited by spaces
                               |     |
                               |     |
                        Search string delimited by system string delimiter

                   This is intended for easy use from the command line.

                   N.B.

                   1.

                   The number n1 must always lie in the range 1-4, and if
                   an out of range value is specified HeliOS will use "1"
                   instead of the illegal parameter supplied.

                   2.

                   If the editor already has a file installed in which
                   recent changes have not been saved, a warning prompt
                   will be issued allowing you to save the old file or
                   abort the operation.

                   3.

                   The filename string must not contain any spaces.

                   4.

                   The symbolic character "", which can be generated by
                   pressing <Alt>+<r>, will be automatically translated
                   for the purpose of the search into the <Return> code.

                   This allows you to make searches which specify the
                   position of a string relative to the end of a line.

                   5.

                   This word has a special behaviour if used from a macro
                   performing a HeliOS command.

                   In this case, all PRECEDING spaces and occurrences of
                   the "" pseudo-<Return> character are removed from the
                   Find string gadget text buffer AFTER the initial search
                   has completed.

                   This feature allows you to search for a specific string
                   using a "" as identifier, and then proceed to search
                   for any further occurrences of the search word embedded
                   in the text without needing to edit out the "" etc.

                   See also EDIT and (EDIT).

     (EDIT)        ( n1 l1 _ _ _ )

                   Where:

                   n1 = The number of the HeliOS editor which will be used.

                   l1 = The filename to be loaded (counted string).

                   This function enters Editor number n1 and loads a file
                   with name l1.

                   N.B.

                   1.

                   The number n1 must always lie in the range 1-4, and if
                   an out of range value is specified HeliOS will use "1"
                   instead of the illegal parameter supplied.

                   2.

                   If the editor already has a file installed in which
                   recent changes have not been saved, a warning prompt
                   will be issued allowing you to save the old file or
                   abort the operation.

                   See EDIT for a command line version of this function.

     ASSEMBLER     ( - - - )

                   Makes ASSEMBLER the context vocabulary.

     BELL          ( _ _ _ )

                   Flashes display as warning.

     CVLIST        ( _ _ _ )

                   Lists the CORE dictionary.

                   SPACE and ESC keys can be used to pause or halt listing.

                   See PAUSE.

     DELAY         ( n1 - - - )

                   Delays for n1 * 1/50 second.

     DISPLAY       ( flag - - - )

                   Turns on and off the display.

                   flag = 0 for Display Off
                   flag = 1 for Display On

     DUMP          ( a1 n1 _ _ _ )

                   Outputs n1 bytes of memory, starting at a1, in hexadecimal
                   and ASCII format.

                   Listing can be paused or halted by SPACE and ESC keys.

                   See PAUSE.

     DUMPL         ( l1 n1 _ _ _ )

                   Outputs n1 bytes of memory, starting at l1, in hexadecimal
                   and ASCII format.

                   Listing can be paused or halted by SPACE and ESC keys.

                   See PAUSE.

     EDIT          ( n1 _ _ _ )

                   Where:

                   n1 = The number of the HeliOS editor which will be used.

                   Enters Editor n1 and loads a file whose filename is
                   obtained using $NEXTL to read a following string.

                   The format for using EDIT is very simple.

                   For example, to load the file "S:startup-sequence" into
                   Editor3, you would say:

                   3 EDIT S:startup-sequence

                   This is intended for easy use from the command line.

                   N.B.

                   1.

                   The number n1 must always lie in the range 1-4, and if
                   an out of range value is specified HeliOS will use "1"
                   instead of the illegal parameter supplied.

                   2.

                   If the editor already has a file installed in which
                   recent changes have not been saved, a warning prompt
                   will be issued allowing you to save the old file or
                   abort the operation.

                   3.

                   The filename string must not contain any spaces.

                   See (EDIT) for a more general version of this function.

     ENDFORTH      ( _ _ _ )

                   Cleans up and leaves the HeliOS system.

     FORBID        ( _ _ _ )

                   Forbids task switching.

     HELIOSMPOINTER  ( flag(w) - - - )

                   The mouse pointer display within the HeliOS game
                   operating system can be enabled and disabled using
                   this routine:

                   Flag = 1 -> Mouse pointer is on

                   Flag = 0 -> Mouse pointer is off

                   Note that the REPORTMOUSE function must be used to
                   enable continuous mouse position updates.

     INTVERSION    ( - - - n1 )

                   Returns the version number of the intuition library in
                   use. If it is 34 or less, then you use 1.3 compatible
                   code.  If it is 37 or more, you must handle more recent
                   features such as screen taglists in your code.

     NOOP          ( _ _ _ )

                   Dummy word which does nothing.

     PAUSE         ( c1 _ _ _ flag )

                   Used to pause execution according to value of c1
                   which is typically a value returned by ?TERMINAL.

                   Can be used in the form:

                   ?TERMINAL PAUSE

                   PAUSE responds to ESC and SPACE keys as follows :

                   SPACE   - Pause execution until another SPACE or ESC
                             key is pressed. Second SPACE restarts execution.
                             Returns 0 on stack.

                   ESC     - Returns 1 on stack.


     PERMIT        ( _ _ _ )

                   Permits task switching.

     POINTER       ( l1 n1 - - - )

                   Where:

                   l1 = Window Handle
                   n1 = Control flag

                   Sets "Sleepy", "Normal" or "Null" mouse pointer imagery
                   for a designated window, using the control flag "n1" as
                   follows:

                   n1 = 0  = Sets "Standard" Intuition pointer imagery
                   n1 = 1  = Sets "Sleepy" Intuition pointer imagery
                   n1 = -1 = Sets "Invisible" Intuition pointer imagery

     PRTOFF        ( _ _ _ )

                   Switches off printer output.

     PRTON         ( _ _ _ )

                   Sends output to printer.

     RESETCOLOURS  ( - - - )

                   Resets HeliOS screen colours to original settings.

     RND           ( n1 - - - n2 )

                   Returns a random number, n2, where 0<=n2<=n1.

                   See also RNDX.

     RNDX          ( n1 - - - n2 )

                   Returns a semi-random number, n2, where 0<=n2<=n1.

                   This version of RND has a periodic bias which can give
                   useful and attractive results when used in graphics
                   colour control.

                   Try both and see.

     SETHELIOSINTS ( - - - )

                   Resets the standard HeliOS game system interrupts after
                   use of SETINT.

                   See also SETINT

     SETINT        ( l1 n1 - - - )

                   Where l1 = Pointer to your machine code interrupt routine
                         n1 = Interrupt level to be installed (1-7)

                   This routine can be used to set up any of the HeliOS
                   game system interrupts so that when the HeliOS operating
                   system takes over from AmigaDOS the installed interrupt
                   will become operational.

                   You might wish to use this facility if you want to make
                   use of the ability of the HeliOS system to close down
                   the OS and then run your own special game code.

                   The new interrupt must conform to the usual requirements
                   of Amiga interrupt code.

                   The new interrupt will only operate when you start the
                   HeliOS game system, and will not affect the ability of
                   HeliOS to restart the Amiga OS legally.

                   If you are going to change any of the HeliOS interrupts
                   in this way you might wish to change all of them, as
                   you may otherwise produce unpredictable results.

                   However, if you do wish to leave any of the HeliOS
                   interrupt handlers running, here is what they do:

                   Level1 = HeliOS game system master control
                   Level2 = HeliOS keyboard handler
                   Level3 = HeliOS game system master control
                   Level4 = Free
                   Level5 = Free
                   Level6 = HeliOS system timing
                   Level7 = Free

                   You can reset the standard HeliOS game system interrupts
                   using the command SETHELIOSINTS.

                   See also SETHELIOSINTS

     TIME          ( _ _ _ a1 n1 )

                   Gets the time for you and prepares a string in the same
                   format as seen on the status display.

                   Returns address a1 and count n1 ready for TYPE.

     TIMEOFF       ( _ _ _ )

                   Switches off time display update.

     TIMEON        ( _ _ _ )

                   Switches on time display update.

     UVLIST        ( _ _ _ )

                   Lists the USER dictionary.

                   SPACE and ESC keys can be used to pause or halt listing.

                   See PAUSE.

     VLIST         ( _ _ _ )

                   Lists the CORE and USER dictionaries.

                   SPACE and ESC keys can be used to pause or halt listing.

                   See PAUSE.

     WAITSPACE     ( _ _ _ )

                   Waits until SPACE is pressed before continuing execution.

                   Also responds to L-Mouse as equivalent to pressing SPACE.

     WAITYORN      ( _ _ _ 1 or 0 )

                   Waits until key is pressed and returns 1 for "Y",0 for
                   "N".  Also responds to L-Mouse as "Y".

                   Waits until a key is pressed and returns:

                   1 for "Y" or  "LMB"

                   0 for "N" or any other key.

     WORD!         ( a1 _ _ _ )

                   Stores the cfa of any predefined word into memory at a1.
                   Used in the form -  WORD! CHANGE  to store the cfa of
                   CHANGE into any location required.

                   Used for changing execution vector tables etc.

                   DO NOT USE INSIDE COLON DEFINITIONS!


-------------------
SCREENS AND WINDOWS
-------------------

   All these functions run under the control of the HeliOS system manager,
   and any windows or screens left open will automatically be tidied up for
   you upon exit from HeliOS.

   Remember that for the CLOSE functions to work the window or screen has
   to have been opened using the HeliOS system routines.

   Note that "WorkBench 2.0 and above" Amigas now have extensively updated
   Intuition functions which require a little extra effort on the part of
   the programmer.

   One thing which you will almost certainly use will be the extensions to
   the NEWSCREEN and NEWWINDOW structures to give access to TAG lists.

   The HeliOS NEWSCREEN and NEWWINDOW structures both have an EXTENSION
   field, as required, after the original data structure.

   If you wish to use TAG lists simply create your own tags and then plug
   the pointer to your list into the EXTENSION field of the intuition
   structure.

   Any window can be designated as the "current input window", the "current
   output window", or the "current GFX window".

   These functions can all be shared by one window, or may be allocated to
   different windows if you wish, but you can only have one of each of them
   specified at any one time.

   Allocation is simple, using the single word MAKEINWINDOW, MAKEOUTWINDOW,
   and MAKEGFXWINDOW functions.

   For example, to make a window the current input window simply use the
   word "MAKEINWINDOW".

   Once a window has been made the output window, the full range of HeliOS
   output stream handling functions is available within that window.

   Once a window has been made the current input window, HeliOS will
   automatically open an IDCMP and run a slave task to monitor input for
   you. Again all the usual HeliOS input facilities are available, and in
   general all you need do is check for user input using KEY and ?TERMINAL,
   which will give you special codes for menu or gadget action.

   The HeliOS Menu will automatically be transferred to any window which
   you designate as the current input window. This means that you can
   operate the HeliOS system from within the environment of any window
   you choose. If you do not wish to have the HeliOS Menu attached to
   your window, simply perform a "ClearMenuStrip" Intuition call on that
   window to remove the HeliOS Menu strip.

   When you next use FORTHINWINDOW the HeliOS Menu Strip will be restored.

   To perform the above mentioned Intuition function you need to do the
   following, assuming your window's handle is in the DVARIABLE "WINDOW":

   WINDOW D@  0 AREG D!    \ Window Handle -> 680xx Register A0
   INTUBASE -54 LIBRARY    \ Intuition "ClearMenuStrip" Library call

   Of course you can also set up your own Menu strip, in which case the
   HeliOS input manager will process Menu requests for you, sending the
   Menu code in response to your use of the word KEY if a Menu has been
   selected. The particular Menu selected can be found by using the word
   MENUNUMBER.

   See the section of the dictionary dealing with Mouse, Menu, and Gadget
   reports for full details.

   In all circumstances, when you wish to return to HeliOS after having
   redirected I/O, control can quickly be restored to the HeliOS window
   using FORTHINWINDOW and FORTHOUTWINDOW.

   To restore graphics output to the HeliOS environment use the expression:

   "FWINDOW MAKEGFXWINDOW"

   In general it has been made as easy as possible for the inexperienced
   programmer to open windows and carry out sophisticated input and output
   with a minimum of effort, with full access to all the HeliOS "extras",
   in any window, and on any screen.

   The graphics functions provided have also been automated as much as
   possible for ease of use by the beginner.

   More experienced programmers will be able to extend and diversify the
   basic vocabulary provided.


     ACTIVATEWINDOW ( l1 - - - )

                   Makes window d1 the current active window.

     CLOSEBMAP     ( l1 - - - )

                   Used to close a BitMap created using OPENBMAP.

                   This routine will safely accept a null parameter.

     CLOSERASINFO  ( l1 - - - )

                   Used to close a RasInfo created using OPENRASINFO.

                   This routine will safely accept a null parameter.

     CLOSEGAD      (  - - - )

                   Used after STDWINDOW, or HFWINDOW, to force window to have
                   a CLOSE gadget.

                   HeliOS will report use of the window CLOSE gadget by
                   setting GADGETNUMBER to -1 and setting the WINDOWCLOSE
                   variable.

                   See also WINDOWCLOSE.

     CLOSERPORT    ( l1 - - - )

                   Used to close a Rastport created using OPENRPORT.

                   This routine will safely accept a null parameter.

     CLOSESCREEN   ( l1 - - - )

                   Closes screen with handle l1.
                   Screen must have been opened by using OPENSCREEN.

                   This routine will safely accept a null parameter.

     CLOSEWINDOW   ( l1 - - - )

                   Closes window with handle l1.
                   Window must have been opened by OPENWINDOW.

                   This routine will safely accept a null parameter.

     DEPTHGAD      (  - - - )

                   Used after STDWINDOW, or HFWINDOW, to make your new window
                   have a system DEPTH gadget.

     DRAGGAD       (  - - - )

                   Used after STDWINDOW, or HFWINDOW, to make your new window
                   have a system DRAG gadget.

     FCONSOLE      ( _ _ _ l1 )   Returns HeliOS Console Handle.

     FORTHINWINDOW ( - - - )

                   Make HeliOS window the current input window.

     FORTHOUTWINDOW ( - - - )

                   Make HeliOS window the current output window.

     FBMAP         ( _ _ _ l1 )   Returns HeliOS Window BitMap

     FRPORT        ( _ _ _ l1 )   Returns HeliOS Window Rastport.

     FSCREEN       ( _ _ _ l1 )   Returns HeliOS Screen Handle.

     FWINDOW       ( _ _ _ l1 )   Returns HeliOS Window Handle.

     GETMASK       ( l1 - - - l2)

                   Where:

                   l1 = Source image BitMap structure
                   l2 = Created mask BitMap structure (or 0. for failure)

                   Returns a BitMap structure defining a single bitplane
                   mask image created from all the "set" pixels of the
                   Source BitMap.

     GIMMEZZ       (  - - - )

                   Used after STDWINDOW, or HFWINDOW, to make your new window
                   into a Gimmezerozero window.

     HFWINDOW      ( - - - )

                   Use after STDWINDOW to set up the appropriate parameters
                   in the system NewWindow structure for the window to open
                   on the HeliOS screen, or a custom screen.

                   Otherwise, if you use STDWINDOW alone, the window will
                   open on the workbench screen.

                   Note the importance of the correct sequence: STDWINDOW
                   comes first, followed by HFWINDOW.

                   STDWINDOW and HFWINDOW are quick methods of setting up
                   the HeliOS internal NewWindow structure, and are useful
                   for many simple applications.

                   For more specific applications you must set up the fields
                   of the HeliOS NewWindow structure individually.

                   Use WINDOWSTRUCT to get the HeliOS NewWindow structure.

                   N.B.

                   Note that the fields of the HeliOS internal NewWindow
                   and NewScreen structures are not automatically reset at
                   the start of each Interpret session: it is entirely your
                   responsibility to ensure that these structures are fully
                   initialised each time you use them.

                   See STDWINDOW, WINDOWSTRUCT.

     MAKEGFXRPORT  ( l1 l2 - - - )

                   Make RPort l2 the current GFX RPort.
                   The other parameter, l1, is a pointer to an Intuition
                   screen structure, which is required by some of the
                   standard HeliOS GFX routines.

     MAKEGFXWINDOW ( l1 - - - )

                   Make window with handle l1 the current GFX window.
                   See also MAKEGFXRPORT, which allows you to operate with
                   the graphics routines on a "disembodied" rastport.

     MAKEINWINDOW  ( l1 - - - )

                   Make window with handle l1 the current input window.

     MAKEOUTWINDOW ( l1 - - - )

                   Make window with handle l1 the current output window.

     MAKERPORT     ( l1 n1 - - - l2 )

                   Make a RastPort l2 and associate it with an existing
                   BitMap l1.

                   l1 = BitMap structure

                   l2 = RastPort structure

                   n1 = 1 if you require Area Rendering extras
                        e.g. TMPRAS etc.

                      = 0 if you do not require the above

                   Success returns Rastport pointer, failure returns zero.

                   Note1.

                   You must deallocate the RastPort using CLOSERPORT when
                   you have finished with it.

                   The CLOSERPORT function will automatically attempt to
                   close the associated BitMap too, provided that the
                   BitMap was originally created by a HeliOS function.

                   If the BitMap is part of an Intuition Screen or Window
                   it will NOT be deallocated by CLOSERPORT.

                   You can use the automatic BitMap deallocation feature of
                   CLOSERPORT to avoid having to close down the BitMap as a
                   separate operation.  However, note that if the BitMap is
                   automatically being closed down within some other "close"
                   function the CLOSERPORT function will automatically skip
                   over the BitMap closure.

                   You can force the CLOSERPORT function to skip the BitMap
                   deallocation, leaving the BitMap in place.  This can be
                   done by simply nulling the BitMap pointer in the RastPort
                   structure, like this:

                   0. MyRport D@ rp_BitMap INDEXD!L


                   Note2.

                   This routine is not overseen by the HeliOS system
                   housekeeping routines, so you must be careful to close
                   down the RastPort using CLOSERPORT when you are finished.


     MOVEWINDOW    ( l1 n1 n2 - - - )

                   Moves the window with windowhandle = l1 to a new position
                   specified by n1 as the horizontal and n2 as the vertical
                   DISPLACEMENTS FROM THE CURRENT POSITION.

                   Note that n1 and n2 do not specify absolute positions.

     OPENBMAP      ( n1 n2 n3 - - - l1 )

                   Tries to set up a BitMap with following parameters:

                    n1 = Bitmap width in pixels
                    n2 = Bitmap height in pixels
                    n3 = Number of bitplanes  (See Note 1. below).

                   Success returns a pointer to your new BitMap structure,
                   which has all its fields initialised and n3 bitplanes
                   allocated.

                   Failure returns zero.

                   Note 1.

                   If n3 is specified as a negative quantity, e.g. "-3",
                   instead of "3" to set 3 bitplanes, the software will
                   give you a special bitplane arrangement with all the
                   planes arranged continuously, end to end, in memory.

                   In other words this gives you a bitplane setup which
                   can be used as a BOB, and which can be very useful in
                   many circumstances.

                   Note 2.

                   This routine is not overseen by the HeliOS system
                   housekeeping routines, so you must be careful to close
                   down the BitMap using CLOSEBMAP when you are finished.

     OPENRASINFO   ( n1 n2 n3 - - - l1 )

                   Tries to set up a RasInfo, complete with allocated
                   BitMap structure and bitplanes, with the following
                   parameters:

                   n1 = Bitmap width in pixels
                   n2 = Bitmap height in pixels
                   n3 = Number of bitplanes  (See Note 1. below).

                   Success returns a pointer to the new RasInfo structure.

                   Failure returns zero.

                   Note 1.

                   If n3 is specified as a negative quantity, e.g. "-3"
                   instead of "3" to set 3 bitplanes, the software will
                   give you a special bitplane arrangement with all the
                   planes arranged continuously, end to end, in memory.

                   In other words this gives you a bitplane setup which
                   can be used as a BOB, and which can be very useful in
                   many circumstances.

                   Note 2.

                   This routine is not overseen by the HeliOS system
                   housekeeping routines, so you must be careful to close
                   down the RasInfo, using CLOSERASINFO, when you are
                   finished.

     OPENRPORT     ( n1 n2 n3 n4 - - - l1 )

                   Tries to set up a rastport with following parameters:

                   n1 = Bitmap width in pixels
                   n2 = Bitmap height in pixels
                   n3 = Number of bitplanes (See Note 1. Below)
                   n4 = 1 if you require Area Rendering extras eg TMPRAS etc
                      = 0 if you do not require the above

                   Success returns Rastport pointer, failure returns zero.

                   Note 1.

                   If n3 is specified as a negative quantity, e.g."-3"
                   instead of "3" to set 3 bitplanes, the software will
                   give you a special bitplane arrangement with all the
                   planes arranged continuously, end to end, in memory.

                   In other words this gives you a bitplane setup which
                   can be used as a BOB, and which can be very useful in
                   many circumstances.

                   Note 2.

                   This routine is not overseen by the HeliOS system
                   housekeeping routines, so you must be careful to close
                   down the Rastport using CLOSERPORT when you are finished.

     OPENSCREEN    ( a1 n2 n3 n4 - - - l1 (or 0. for failure) )

                   Opens a new screen and returns screen handle l1.

                   Returns 32-bit zero if operation fails.

                   Initial parameters are as follows:

                   a1 = Name string (counted) address in 16-bit form

                        A zero for this parameter will give you a screen
                        with no title.

                   n2 = Width
                   n3 = Height
                   n4 = Depth (bitplanes)

     OPENWINDOW    ( a1 n2 n3 n4 n5 n6 n7 - - - l1 (or 0. for failure) )

                   Opens a new window and returns window handle l1.

                   Returns 32-bit zero if operation fails.

                   Initial parameters are as follows:

                   a1 = Name string (counted) address in 16-bit form

                        A zero for this parameter will give you a window
                        with no title.

                   n2 = Left Edge
                   n3 = Top Edge
                   n4 = Width
                   n5 = Height
                   n6 = Depth (bitplanes)
                   n7 = Flag 1 or 0 - switches on or off superbitmap mode

                   See also STDWINDOW,HFWINDOW, and WINDOWSTRUCT.

     REFRESHWINDOW ( - - - a1)

                   A 16-bit variable used to enable the reporting of
                   Intuition REFRESHWINDOW events.

                   Each time the HeliOS Inuition event handler gets a
                   REFRESHWINDOW event it stores a value of 1 in this
                   variable.  By clearing REFRESHWINDOW first and then
                   checking its value you can test for the occurrence of
                   any new REFRESHWINDOW events.

     RESETCOLOURS  ( - - - )

                   Restores the default HeliOS screen colours.

                   See also GFXSETRGB and GFXGETRGB.

     SCRCOLS       ( n1 n2 - - - )

                   Used to assign Detail ( n1 ) and Block ( n2 ) pen colours
                   for your new screen.

     SCREENSTRUCT  ( - - - a1 )

                   Returns a1 as a 16-bit pointer to the NewScreen structure
                   used by the OPENSCREEN function.

                   This may be used to modify parameters of the structure
                   if required.

                   N.B.

                   There is an "Extension" field available at the end of
                   this structure which may be set to point to your own
                   TAGLIST using SETSCREENTAGS.

                   Note that the fields of the HeliOS internal NewWindow
                   and NewScreen structures are not automatically reset at
                   the start of each Interpret session: it is entirely your
                   responsibility to ensure that these structures are fully
                   initialised each time you use them.

                   See also SCRCOLS, SCRMODE, SETSCREENTAGS, STDSCREEN etc

     SCREENTOBACK  ( l1 - - - )

                   Implements an Intuition ScreenToBack call for the screen
                   l1.

     SCREENTOFRONT ( l1 - - - )

                   Implements an Intuition ScreenToFront call for the screen
                   l1.

     SCRMODE       ( n1 - - - )

                   Used to assign n1 to the viewmode field of the standard
                   HeliOS Screen structure.

     SETSCREENTAGS ( l1 - - - )

                   Where l1 is a pointer to a TAGLIST, or 0.

                   This word has two functions, acting as on on/off switch
                   for the use of screen TAGs.

                   If l1 <> 0  (i.e. l1 is a TAGLIST pointer)

                   Sets NS_EXTENDED flag in NewScreen.Type field of the
                   HeliOS NewScreen structure, then sets the "Extension"
                   field at the end of the NewScreen structure to point to
                   the address l1.

                   If l1 = 0

                   Clears NS_EXTENDED flag in NewScreen.Type field of the
                   HeliOS NewScreen structure, then sets the "Extension"
                   field at the end of the NewScreen structure to null.

                   See also SCRCOLS, SCRMODE, SCRSTRUCT, STDSCREEN etc

     SETTITLES     ( l1 l2 l3 - - - )

                   Calls the Intuition routine SetWindowTitles where :

                   l1 = Pointer to null-terminated uncounted new screen title.
                   l2 = Pointer to null-terminated uncounted new window title.
                   l3 = Window Handle

                   Note that if either title pointer is set to 0 that title
                   will be blank, and if either is -1 the existing title
                   will be left unchanged.

     SETWINDOWTAGS ( l1 - - - )

                   Where l1 is a pointer to a TAGLIST, or 0.

                   This word has two functions, acting as on on/off switch
                   for the use of window TAGs.

                   If l1 <> 0  (i.e. l1 is a TAGLIST pointer)

                   Sets NW_EXTENDED flag in HeliOS NewWindow structure,
                   then sets the "Extension" field at the end of the
                   NewWindow structure to point to the address l1.

                   If l1 = 0

                   Clears NW_EXTENDED flag in HeliOS NewWindow structure,
                   then sets the "Extension" field at the end of the
                   NewWindow structure to null.

                   See also GIMMEZZ, HFWINDOW, STDWINDOW, WINCOLS and
                   WINDOWSTRUCT.

     SIZEGAD       (  - - - )

                   Used after STDWINDOW, or HFWINDOW, to make your new
                   window have a system SIZE gadget.

     STDSCREEN     ( n1 - - - )

                   Sets up the system NewScreen structure to a standard
                   format.

                   If n1 = 0, screen is LORES, if n1 = 1 screen is HIRES.

                   For detailed reference, the STDSCREEN sets up the HeliOS
                   internal NewScreen structure as follows:

                   If stack flag is 0     0         -> SCRFLAGS
                   If stack flag is 1     V_HIRES   -> SCRFLAGS

                   0         -> SCRLEDGE
                   0         -> SCRTEDGE
                   1         -> SCRDPEN
                   3         -> SCRBPEN

                   NS_EXTENDED
                   CUSTOMSCREEN  -> SCRTYPE

                   TEXTATTR
                   (TOPAZ 8) -> SCRTEXT

                   0         -> SCRGADS
                   0         -> SCRBMAP
                   SCRTAGS   -> SCREXT

                   N.B.

                   Note that the fields of the HeliOS internal NewWindow
                   and NewScreen structures are not automatically reset at
                   the start of each Interpret session: it is entirely your
                   responsibility to ensure that these structures are fully
                   initialised each time you use them.

                   See also SCRCOLS, SCRMODE.

     STDWINDOW     ( - - - )

                   Sets up the system NewWindow structure to a standard
                   format for a normal WORKBENCH window.

                   Use this function first, to set up the structure if it
                   has been previously disturbed, then modify any particular
                   parameters you need to alter using the base address of
                   the system NewWindow structure pointed to by WINDOWSTRUCT.

                   If you require a window on the HeliOS screen use the
                   word HFWINDOW after using STDWINDOW.

                   No system gadgets are allocated to the new window unless
                   the subsidiary words CLOSEGAD, DEPTHGAD, DRAGGAD, or
                   SIZEGAD are used after STDWINDOW.

                   STDWINDOW and HFWINDOW are just quick methods of setting
                   up the HeliOS internal NewWindow structure, and are very
                   useful for many simple applications.

                   For more specific applications you must set up the fields
                   of the HeliOS NewWindow structure individually.

                   Use WINDOWSTRUCT to get the HeliOS NewWindow structure.

                   For detailed reference, the STDWINDOW sets up the HeliOS
                   internal NewWindow structure as follows:

                   SIZEBRIGHT
                   ACTIVATE
                   NOCAREREFRESH
                   NW_EXTENDED
                   NEWLOOKMENUS   -> WFLAGS

                   0         -> WDPEN
                   1         -> WBPEN
                   0         -> WIDCMP
                   0         -> WBMAP
                   0         -> WGADS
                   0         -> WIM
                   1         -> WSCRTYPE
                   0         -> WSCREEN
                   640       -> WMAXW
                   250       -> WMAXH
                   64        -> WMINHGT
                   64        -> WMINWID
                   WINTAGS   -> WINEXT

                   N.B.

                   Note that the fields of the HeliOS internal NewWindow
                   and NewScreen structures are not automatically reset at
                   the start of each Interpret session: it is entirely your
                   responsibility to ensure that these structures are fully
                   initialised each time you use them.

                   See also HFWINDOW, GIMMEZZ, SETWINDOWTAGS, WINCOLS,
                   WINQUIET, WINDOWSTRUCT etc

     WBENCHTOBACK  ( - - - )

                   Implements an Intuition WBenchToBack call.

     WBENCHTOFRONT ( - - - )

                   Implements an Intuition WBenchToFront call.

     WINCOLS       ( n1 n2 - - - )

                   Used after STDWINDOW, or HFWINDOW, to assign Detail (n1)
                   and Block (n2) pen colours in HeliOS NewWindow structure.

     WINDOWCLOSE   ( - - - a1 )

                   Returns a1, a variable which will contain the flag "1" if
                   the window close gadget of a window is pressed by the user.
                   Note two important provisos:

                   1.

                   You should remember to ensure that the variable is set
                   to zero at the start of your routine, when you open the
                   window. It is up to you to ensure that the variable is
                   cleared after it has been set by the user pressing the
                   close gadget.

                   2.

                   The variable will only be set if the window having the
                   close gadget is the current Input window, otherwise you
                   must look after gadget messages yourself and open your
                   own IDCMP.

                   HeliOS will also report use of the window CLOSE gadget by
                   setting GADGETNUMBER to -1.

                   See MAKEINWINDOW.

     WINDOWSTRUCT  ( - - - a1 )

                   Returns a1 as a 16-bit pointer to the NewWindow structure
                   used by the OPENWINDOW function.

                   This may be used to modify parameters of the structure
                   if required.

                   There is an "Extension" field available at the end of
                   this structure which may be set to point to your own
                   TAGLIST using SETWINDOWTAGS.

                   N.B.

                   Note that the fields of the HeliOS internal NewWindow
                   and NewScreen structures are not automatically reset at
                   the start of each Interpret session: it is entirely your
                   responsibility to ensure that these structures are fully
                   initialised each time you use them.

                   See also GIMMEZZ, HFWINDOW, STDWINDOW, WINCOLS, WINQUIET,
                   SETWINDOWTAGS etc.

     WINDOWTOBACK  ( l1 - - - )

                   Implements an Intuition WindowToBack call for the window
                   l1.

     WINDOWTOFRONT ( l1 - - - )

                   Implements an Intuition WindowToFront call for the window
                   l1.

     WINQUIET      ( - - - )

                   Used after STDWINDOW, or HFWINDOW, to cause the new
                   window to be inactive when opened.


-----------------
STRUCTURE CONTROL
-----------------

     These functions are explained in some detail in the tutorials, so you
     might wish to look at the examples given there to supplement the notes
     provided below.


     +LOOP         ( n1 _ _ _ )

                   Used in colon definitions in the form:

                   DO - - - - - n1 +LOOP

                   to implement a loop in which the index is incremented by
                   n1 each time the loop executes.

                   The branch back to DO occurs as long as the index remains
                   less than the limit if n1 > 0, or for as long as it is
                   greater than the limit if n1 < 0.

                   Note than n1 can be positive or negative for this word.

     /LOOP         ( n1 _ _ _ )

                   Used in colon definitions in the form:

                   DO - - - - - n1 /LOOP

                   to implement a loop in which the index is incremented by
                   n1 each time the loop executes.

                   The branch back to DO occurs as long as the index remains
                   less than the limit.

                   In this case n1 must always be positive (unsigned) and
                   the loop index can exceed 32767.

     AGAIN         ( _ _ _ )

                   Used in colon definitions in the form:

                   BEGIN - - - - - AGAIN

                   to set up a continuous loop between BEGIN and AGAIN.

                   The loop can only be exited by use of R> one level below.

     BEGIN         ( _ _ _ )

                   Used in colon definitions in the forms:

                   * BEGIN - - - - - UNTIL

                     Repeats if top stack value is "0" at UNTIL


                   * BEGIN - - - - - AGAIN


                     Repeats always

                   * BEGIN - - - - - WHILE - - - - - REPEAT

                     If WHILE finds a 0, it diverts execution to beyond
                     REPEAT, leaving the conditional structure.

                     If flag for WHILE is "true", execution is allowed to
                     continue through to REPEAT and then back to BEGIN.

                   BEGIN marks the start of a repeating section of code and
                   a return point for UNTIL, AGAIN, and REPEAT.

     DO            ( n1 n2 _ _ _ )

                   Where:

                   n1 = loop limit
                   n1 = loop index

                   Used in colon definitions to mark the start of and set up
                   a loop.

                   The loop limit n1 is pushed onto the return stack
                   followed by the loop index initial value n2.

                   The loop executes until the index is incremented by
                   LOOP or +LOOP to a value equal to or greater than the
                   loop limit.

                   See LOOP and +LOOP.

     ELSE          ( _ _ _ )

                   Used within a colon definition in the form:

                   IF - - - - - ELSE - - - - - THEN - - - - -

                   The ELSE part of the code (between ELSE and THEN)
                   executes only if the IF condition is false.

                   If the IF reads a true flag, the section between IF
                   and ELSE executes, after which ELSE will cause a jump
                   to THEN, skipping the section between ELSE and THEN.

     IF            ( flag _ _ _ )

                   Used in colon definitions to initiate conditional
                   execution.

                   If flag is true, the code immediately after IF will
                   execute up to ELSE (if present) then skip to THEN.

                   If flag is false then execution skips to ELSE (if ELSE
                   is present) and then the code from ELSE through to THEN
                   is executed.

                   If no ELSE is present the conditional execution merely
                   determines whether or not the code between IF and THEN
                   executes or is skipped.

                   For example:

                   IF      flag is true

                           do this

                   ELSE    if flag is false

                           do this

                   THEN    carry on.

     LEAP          ( _ _ _ )

                   Jump out of a DO - - - LOOP structure right into the next
                   level calling word. Use with caution.

     LEAVE         ( _ _ _ )

                   Exits a DO - - - LOOP structure by making the loop limit
                   equal to the index so that when LOOP is reached the loop
                   finishes.

     LOOP          ( _ _ _ )

                   Used in colon definitions to mark the end of a loop.

                   The loop index is incremented and execution returns to
                   DO if index is still less than limit.

     REPEAT        ( _ _ _ )

                   Used in colon definitions to force execution to return to
                   the point just after the word BEGIN.

     THEN          ( _ _ _ )

                   Used in colon definitions to mark the end of conditional
                   execution using IF and ELSE.

     UNTIL         ( flag _ _ _ )

                   Used in colon definitions to control a conditional branch
                   back to BEGIN.

                   If flag is false execution reverts to BEGIN, but if true
                   execution continues ahead.

     WHILE         ( flag _ _ _ )

                   Used in colon definitions to implement

                   BEGIN - - - WHILE - - - REPEAT

                   conditional structures.

                   If flag is "false", WHILE diverts execution to beyond
                   REPEAT, leaving the conditional structure.

                   If flag is "true", execution is allowed to continue
                   through to REPEAT and then back to BEGIN.

-------------------
AMIGADOS AND FILING
-------------------

  Some of the below listed functions are simple direct AmigaDOS calls and
  as such are unprotected and do not relate to the HeliOS internal file
  system. In this case it is up to the user to make sure everything is
  closed down on exit etc.

  Other functions operate through the HeliOS housekeeping system and are
  slightly better error protected.

  In the latter cases provision is made for automatically closing all files
  on exit from HeliOS, and an internal data structure keeps track of various
  file data which may be simply and efficiently accessed by the set of words
  provided for the purpose.

  If any function returns an error the variable DOSERROR will contain
  the error code returned by an AmigaDOS IOErr call. This provision applies
  equally to HeliOS functions or simple direct AmigaDOS function.

  In general all these functions should only be used with a reasonable
  knowledge of AmigaDOS and preferably with reference to the AmigaDOS
  manual.


     $DOSCMD       ( l1 _ _ _ )

                   Executes DOS/AREXX command stored as counted string at l1.

                   Note:

                   DOS/AREXX commands which run from the main interpreter
                   or editor, via menus etc., open their own CLI for output.

                   However, there is no output from DOSCMD/$DOSCMD, used
                   within software, when HeliOS is run from Workbench with
                   no parent CLI.

                   DOSCMD/$DOSCMD are designed for flexible use within a
                   program, and in this case you may not always WANT a CLI
                   opened automatically.

                   Hence these functions do ONLY what you ask, and provide
                   no further automatic behaviour so as to provide maximum
                   user control.


     ALTERNATE     ( l1 d1 _ _ _ )

                   Closes current ALT file and opens a new ALT file with
                   name l1 ( counted string ) and mode d1.

                   See FILEON, FILEOFF etc.

     BAKSET        ( n1 _ _ _ )

                   Switches On/Off BAK file generation according to value
                   of n1.

                   n1 = 0    -> BAK generation Off
                   n1 = 1    -> BAK generation On

     CLOSE         ( d1 _ _ _ )

                   AmigaDOS Close function. d1 = File Handle

                   This routine will safely accept a null parameter.

     CLOSEALT      ( _ _ _ )

                   Close ALT file.

     DELETEFILE    ( l1 _ _ _ d1 )

                   AmigaDOS DeleteFile function.

                   l1 = Filename ( Counted string ).
                   d1 = -1 for success, or 0 for failure.

     DOSCMD        ( _ _ _ )

                   Used in the form:

                   DOSCMD $AmigaDOS command string$

                   Executes following DOS/AREXX command delimited by
                   system string delimiter.

                   Note:

                   DOS/AREXX commands which run from the main interpreter
                   or editor, via menus etc., open their own CLI for output.

                   However, there is no output from DOSCMD/$DOSCMD, used
                   within software, when HeliOS is run from Workbench with
                   no parent CLI.

                   DOSCMD/$DOSCMD are designed for flexible use within a
                   program, and in this case you may not always WANT a CLI
                   opened automatically.

                   Hence these functions do ONLY what you ask, and provide
                   no further automatic behaviour so as to provide maximum
                   user control.


     EXISTS        ( l1 - - - f1 )

                   l1 = Filename ( counted string ).
                   f1 = 16-bit flag ( 1 for success, 0 for failure )

                   Attempts to get a lock for a file with the supplied name
                   and returns a flag indicating whether the file exists.

     FILECLOSE     ( l1 _ _ _ )

                   l1 = Filename ( counted string ).

                   Closes a file and updates HeliOS internal housekeeping.

                   This function MUST be used rather than CLOSE to close a
                   file opened with FILEOPEN which uses the HeliOS internal
                   housekeeping system.

                   The simple CLOSE function is merely an implementation of
                   the AmigaDOS CLOSE function and does not deal with the
                   HeliOS internal housekeeping system.

     FILEHANDLE    ( l1 _ _ _ d1 )

                   Takes Filename string (counted) l1 and returns the File
                   Handle d1.

                   Uses HeliOS internal housekeeping and only functions on
                   files recorded by using an HeliOS special function such
                   as FILEOPEN or FILESAVE.

     FILELOAD      ( d1 d2 d3 _ _ _ )

                   Loads file into memory buffer.

                   d1 = File Handle.
                   d2 = Buffer Start.
                   d3 = Count

                   This routine is rather similar to READ below, but the
                   difference is that FILELOAD is a slightly "higher level"
                   function and checks for errors, which it handles via
                   ABORT" etc.


     FILEMODE      ( d1 _ _ _ d2 )

                   Takes File Handle d1 and returns File Mode as d2.

                   Uses HeliOS internal housekeeping and only functions on
                   files recorded by using an HeliOS special function such
                   as FILEOPEN or FILESAVE.

     FILENAME      ( d1 _ _ _ l1 )

                   Takes File Handle d1 and returns Filename as the counted
                   string l1.

                   Uses HeliOS internal housekeeping and only functions on
                   files recorded by using an HeliOS special function such
                   as FILEOPEN or FILESAVE.

     FILEOFF       ( _ _ _ )

                   Switch off ALT file output.

     FILEON        ( _ _ _ )

                   Switch on ALT file output.

     FILEOPEN      ( l1 d1 _ _ _ d2 )

                   Opens a file l1 ( counted name string ), with mode d1,
                   and if successful returns d2 = File Handle.

                   Otherwise d2 = 0.

                   Updates HeliOS internal housekeeping.

                   Files opened using this function MUST be closed using
                   the FILECLOSE function rather than CLOSE, since these
                   functions update the HeliOS internal housekeeping system.

                   The simple CLOSE function is merely an implementation of
                   the AmigaDOS CLOSE function and does not deal with the
                   HeliOS internal housekeeping system.


     FILEREQUEST   ( n1 _ _ _ l1 or 0.)

                   Jumps into the HeliOS FileIO requester and gets a
                   FileName.

                   Returns l1 as a counted filename string or 0 if no valid
                   name is selected.

                   n1 dictates whether the request is to be a LOAD, SAVE, or
                   merely a general request.

                   n1 = 0  -> General FILENAME Request
                   n1 = 1  -> LOAD
                   n1 = -1 -> SAVE

     FILESAVE      ( d1 d2 d3 _ _ _ )

                   Save memory buffer to File.

                   d1 = Filename
                   d2 = Buffer Start.
                   d3 = Count

     FILESIZE      ( d1 _ _ _ d2 )

                   Takes File Handle d1 and returns File Size d2.

                   Uses HeliOS internal housekeeping and only functions on
                   files recorded by using an HeliOS special function such
                   as FILEOPEN or FILESAVE.

     IOERR         ( _ _ _ d1 )

                   AmigaDOS IOErr call. d1 = Error Return.

     LOCK          ( l1 d1 _ _ _ d2)

                   AmigaDOS Lock call.

                   l1 = Filename ( Counted string ).
                   d1 = Mode
                   d2 = Lock or 0 on failure.

     OPEN          ( l1 d1 _ _ _ d2 )

                   AmigaDOS OPEN function.

                   l1 = Filename ( Counted string ).
                   d1 = Mode
                   d2 = File Handle or 0 on failure.

     OPENALT       ( l1 d1 _ _ _ )

                   Opens a file l1 ( counted name string ), with mode d1,
                   and if successful stores File Handle in ALTOUT.

     READ          ( d1 d2 d3 _ _ _ d4 )

                   AmigaDOS READ function.

                   d1 = File Handle
                   d2 = Memory Buffer
                   d3 = Count
                   d4 = Actual Length or failure code.

     RENAME        ( l1 l2 _ _ _ d1 )

                   AmigaDOS RENAME function.

                   l1 = Old Name ( Counted string )
                   l2 = New Name ( Counted string )
                   d1 = Result ( Success or failure )

     SEEK          ( d1 d2 d3 _ _ _ d4 )

                   AmigaDOS SEEK function.

                   d1 = File Handle
                   d2 = Position
                   d3 = Mode
                   d4 = Position or failure code.

     UNLOCK        ( d1 _ _ _ )

                   AmigaDOS UNLOCK function.

                   d1 = Lock

                   This routine will safely accept a null parameter.

     WRITE         ( d1 d2 d3 _ _ _ d4 )

                   AmigaDOS WRITE function.

                   d1 = File Handle
                   d2 = Memory Buffer
                   d3 = Count
                   d4 = Returned Length, or failure code.

--------------------------------------
MOUSE, MENU, GADGET and TICKER REPORTS
--------------------------------------

     These events are reported via the IDCMP of the current HeliOS input
     window, and actions are taken at various levels of the system.

     HeliOS runs a slave task to monitor the IDCMP for you, returning
     general event codes to standard KEY and ?TERMINAL input words.

     More detailed menu or gadget information is available, after a menu
     or gadget event, via MENUNUMBER, GADEVENT and GADGETNUMBER.

     Some events will be controlled by special HeliOS functions, giving
     added functionality.

     For example, when the right mouse button is pressed, a HeliOS special
     MENULIMIT function will allow you to employ a dual-sensing mechanism
     for simultaneous Menu operation and ordinary RMB event sensing.

     MAKEINWINDOW can be used to transfer the complete HeliOS input system
     to any window of your choice, upon which an IDCMP will be opened for
     you fully automatically and a slave task will again monitor events and
     pass them on in the usual way.

     See MAKEINWINDOW, in the dictionary section on WINDOWS AND SCREENS.

     Mouse, menu, gadget, and ticker reports are sent to your software by
     using a simple system of codes passed to the input functions such as
     KEY and ?TERMINAL.

     The codes are as follows:

     Left mouse button pressed     = 1255
     Left mouse button released    = 1250
     Right mouse button pressed    = 1252
     Right mouse button released   = 1251
     Any Gadget pressed            = 1253
     Menu selection made           = 1254
     Ticker report                 = 1249

     These codes are merely sent to report the general occurrence of an
     event, and more specific information is delivered by such words as
     MENUNUMBER, GADGETNUMBER, GADEVENT, WINDOWCLOSE, or MOUSEDCLICK, which
     should be used to determine precise actions.

     Notice that within the normal HeliOS environment these functions will
     be manipulated by the system in such a way that some inputs may be
     switched in and out within the central Interactive HeliOS loop.

     However, once within your own routines, within your own window, all
     the functions will be under your control.

     See also AMIGAKEY, KEYCODE, LEFTMOUSE, RIGHTMOUSE


     EVENTOFF      ( _ _ _ )

                   Disables gadget, mouse, and menu reports.

     EVENTON       ( _ _ _ )

                   Enables gadget, mouse, and menu reports.

     GADEVENT      ( - - - d1)

                   Returns GADGETUP or GADGETDOWN event class when a GADGET
                   is used.

     GADGETNUMBER  ( _ _ _ n1 )

                   Returns n1 as a number formatted in exactly the same way
                   as a standard Intuition menu number.

                   The low order five bits of the word will all be set in
                   the case of the gadget number, as for menu number 31.

                   The actual gadget number is stored in the higher bits,
                   so that it can be decoded simply by shifting right 5
                   times if required.

                   However, you may well find it most useful to use the same
                   interpretive routine for both gadget and menu numbers and
                   this is best facilitated by simply regarding the gadget
                   number as a yet another menu number.

     GADGETOFF     ( _ _ _ )

                   Disables gadget reports.

     GADGETON      ( _ _ _ )

                   Enables gadget reports.

                   When you receive the "gadget" code using KEY or ?TERMINAL
                   (see above), the gadget number selected will be available
                   for your inspection by using the word GADGETNUMBER.

                   See also WINDOWCLOSE, in the section of the dictionary
                   dealing with windows, for the special treatment of the
                   window close gadget.

     JOY1CHANGE    ( - - - n1 )

                   Returns n1 which represents current overall status of
                   JOYSTICK if the JOYSTICK has moved from the position
                   it had when JOY1CHANGE was last called.

                   If JOYSTICK status has not changed, n1 will be -1.

                   In other words, this function reports any JOYSTICK
                   transitions (on or off) since it was last called.

                   This function needs to be called once initially to
                   set it up in a neutral status.

                   If JOYSTICK status has changed, n1 will have bits set
                   as follows:

                   Bit 0 = Up
                   Bit 1 = Down
                   Bit 2 = Left
                   Bit 3 = Right
                   Bit 4 = Unused
                   Bit 5 = Unused
                   Bit 6 = Unused
                   Bit 7 = Fire pressed (or left mousebutton)

     JOY1FIRE      ( - - - n1 )

                   Returns n1 which represents current firebutton status
                   of JOYSTICK.

                   n1 = 1 if JOYSTICK fire button is pressed
                   n1 = 0 if JOYSTICK fire button is not pressed

     JOY1LEFTRIGHT ( - - - n1 )

                   Returns n1 which represents current left/right status of
                   JOYSTICK.

                   n1 = -1 if JOYSTICK is held to the left
                   n1 = 1  if JOYSTICK is held to the right
                   n1 = 0  if JOYSTICK is held in central left/right
                           orientation

     JOY1STATE     ( - - - n1 )

                   Returns n1 which represents current overall status of
                   JOYSTICK.

                   The individual bits of n1 are set or cleared to indicate
                   the status of the JOYSTICK as follows:

                   Bit 7 also returns the status of the left mouse button.

                   Bit 0 = Up
                   Bit 1 = Down
                   Bit 2 = Left
                   Bit 3 = Right
                   Bit 4 = Unused
                   Bit 5 = Unused
                   Bit 6 = Unused
                   Bit 7 = Fire pressed (or left mousebutton)

     JOY1UPDOWN    ( - - - n1 )

                   Returns n1 which represents current up/down status of
                   JOYSTICK.

                   n1 = -1 if JOYSTICK is held to the top
                   n1 = 1  if JOYSTICK is held to the bottom
                   n1 = 0  if JOYSTICK is held in central up/down
                           orientation

     MENULIMIT     ( n1 - - - )

                   Where:

                   n1 = Number of Pixels from top of window.

                   Specifies the distance from the top of a window that
                   menu selection will occur.

                   The idea here is that the right mouse button will only
                   be used for menu operation when the mouse is within the
                   specified distance of the top of the window.

                   Below this position an ordinary RMB signal will be sent.

     MENUNUMBER    ( _ _ _ n1 )

                   Returns n1 as a standard Intuition menu number
                   representing the last menu selected.

                   See Intuition Reference Manual.

     MENUOFF       ( _ _ _ )

                   Disables menu reports.

     MENUON        ( _ _ _ )

                   Enables menu reports. When you receive the "menu" code
                   using KEY or ?TERMINAL (see above), the menu number
                   selected will be available for your inspection by using
                   the word MENUNUMBER.

     MOUSEBUTTON   ( _ _ _ n1 )

                   Returns n1 = intuimessage "im_code" value for the most
                   recent mouse button activity monitored by the HeliOS
                   IDCMP handler.

                   e.g. n1 = SELECTUP, SELECTDOWN, MENUUP, or MENUDOWN

     MOUSEDCLICK   ( _ _ _ n1 )

                   Returns n1 = 1 if last mouse button press was a double
                   click or n1 = 0 if it was a single click.

                   When you receive a mouse event code (for example using
                   KEY) obviously the system will not know whether there
                   is a double click until slightly after the first event.

                   To manage this situation the system delays for a short
                   time before returning the MOUSEDCLICK data. If you set
                   your mouse double click detection VERY slow you may find
                   that you need to insert a longer delay. If this is the
                   case the following method will suffice:

                   KEY            -> Detect event

                   10 DELAY       -> Short delay

                   MOUSEDCLICK    -> Check for double click

     MOUSEOFF      ( _ _ _ )

                   Disables input stream mouse button UP reports.

                   After using mouseoff no "UP" mouse-button activity, will
                   be reported to input functions such as KEY and ?TERMINAL.

                   Left and right mouse button "DOWN" presses will still be
                   reported.

     MOUSEON       ( _ _ _ )

                   Enables input stream mouse button UP reports.

                   After using MOUSEON any mouse button activity, left or
                   right, up or down, will be reported to input functions
                   such as KEY and ?TERMINAL.

                   The codes received are listed above.

                   Normally right mouse button presses will be consumed by
                   Intuition if you have a menu strip set.

                   N.B.

                   Left mouse reports are automatically enabled at all
                   times.

     MOUSEX        ( _ _ _ n1 )

                   Returns X-position of mouse when a mouse button was last
                   pressed.

     MOUSEY        ( _ _ _ n1 )

                   Returns Y-position of mouse when a mouse button was last
                   pressed.

     REPORTMOUSE   ( flag - - - )

                   Switches on and off continuous mouse position reporting.

                   Continuous mouse position reporting imposes quite large
                   system work overheads, and so this facility should not
                   be enabled unless necessary, and should be disabled as
                   soon as you have finished using it.

                   flag = 0 -> Switch off continous mouse position reporting
                   flag = 1 -> Switch on continous mouse position reporting

                   When switched on, this function will cause MOUSEX and
                   MOUSEY to be constantly updated.

                   The default condition is "Off".

     TICKACTION    ( - - - a1 )

                   A double length variable which returns a1, the storage
                   address for the longword (or null) which points to a
                   machine code subroutine to be executed by the "ticker".

                   If this variable is null the machine code tickaction will
                   be skipped.

                   See TICKS below for a more complete explanation.

     TICKFORTHACTION ( - - - a1 )

                   A single length variable which returns a1, the storage
                   address for the CFA of a HeliOS function to be executed
                   by the "ticker".

                   If this variable is null the HeliOS code tickaction will
                   be skipped.

                   See TICKS below for a more complete explanation.

     TICKS         ( n1 n2 _ _ _ )

                   Enables/disables tick reports and ticker code execution.

                   n1 = Ticker on/off switch and time interval value.
                   n2 = Switches on and off the ticker KEY reports.

                   If n1 = 0, ticker is disabled completely.

                   If n1 > 0, the ticker will be set to operate at a rate
                   of one tick every n1*(1/50sec).

                   ie. If n1 = 25, there will be 2 ticks per second.

                   If n2 = 0, there will be no ticker reports transmitted to
                   the KEY routine, and only the TICKACTION/TICKFORTHACTION
                   routines will be serviced by the ticker.

                   If n2 > 0, ticker reports will be passed to KEY.

                   The ticker will cause a code value of 1249 to be passed
                   to your event handler at each tick.

                   You can "wait" for these signals using the usual KEY or
                   ?TERMINAL words exactly as you would check for gadgets,
                   keypresses, or menu operation reports.

                   This feature allows your main task to sleep until your
                   predetermined interval timed reports come in, allowing
                   you to carry out any regular housekeeping required while
                   in general waiting for user action.

                   The TICKACTION/TICKFORTHACTION facility:

                   If the longword value stored in the variable TICKACTION
                   is non-null the ticker will execute a "JSR" to the code
                   pointed to by TICKACTION once every tick.

                   Thus, if you have a short section of machine code which
                   you wish to have executed every 1/50th of a second, just
                   insert the longword address of the start of your code
                   into TICKACTION and then switch on the ticker using the
                   code fragment:

                   1 0 TICKS

                   Note that your machine code should be kept as short as
                   possible, and must be terminated with the "RTS" opcode.

                   TICKFORTHACTION works in an identical way except that it
                   uses HeliOS code rather than machine code.

                   If the CFA of a HeliOS word is stored in TICKFORTHACTION
                   that word will be executed once every tick.

                   Note that:

                   1. Minimum ticker period = 1/50 second

                   2. Maximum ticker period = 1 second

                   See also TICKTIME, TICKACTION, and TICKFORTHACTION.

     TICKTIME      ( _ _ _ a1 )

                   Returns the address a1 of a 32-bit variable which contains
                   the TICKER timer period in microseconds.

                   This variable is automatically set by using TICKS, but if
                   you wish you can access the TICKTIME variable directly.

                   Note that TICKS sets this variable automatically, and you
                   can subsequently set any special value using TICKTIME after
                   TICKS has been used initially.

                   Note that:

                   1. Minimum ticker period = 1/50 second

                   2. Maximum ticker period = 1 second

                   See also TICKS, TICKACTION, and TICKFORTHACTION.

     WINDOWCLOSE   ( - - - a1 )

                   Returns a1, a variable which will contain the flag "1"
                   if the window close gadget of a window is pressed by the
                   user.

                   Note two important provisos:

                   1.

                   You should remember to ensure that the variable is set
                   to zero at the start of your routine, when you open the
                   window. It is up yo you to ensure that the variable is
                   cleared after it has been set by the user pressing the
                   close gadget.

                   2.

                   The variable will only be set if the window having the
                   close gadget is the current Input window, otherwise you
                   must look after gadget messages yourself and open your
                   own IDCMP. See MAKEINWINDOW.

--------
GRAPHICS
--------

     These are simple "graphics library" routines for general purpose
     graphical output using Amiga operating system routines.

     The HeliOS graphics routines make use extensively of the Amiga's
     built-in system graphics routines, but attempt to simplify the
     general operation and add a few helpful frills to make elementary
     graphics programming more easily approachable.

     Ultimately, of course, there are many very complex possible graphics
     applications which are best tackled by building required routines from
     the lowest level Amiga system software, for speed and control. This is
     obviously the province of the experienced programmer who will be best
     served by using the HeliOS Amiga library access system to call system
     routines directly.

     The simple HeliOS routines provided here do give you a very quick and
     easy method of general graphics rendering, and are well worth the small
     effort involved in getting to know them.

     Included are a few very fast "approximate" routines for calculating
     SIN, COS, ARCSIN and SQUARE ROOT functions. Using these can really
     help boost the speed of your graphics rendering.


     GFXARCSIN     ( n1 _ _ _ n2 )

                   Returns a value, n2, between 0 and 90 (i.e. in degrees)
                   for the angle whose sin is n1/32767.

                   This is a quick and approximate routine designed for fast
                   graphics applications where speed rather than absolute
                   accuracy is important.

     GFXAREACLOSE  ( _ _ _ )

                   Deallocates memory used by TMPRAS and AREAINFO structures
                   when no more area operations are required and you feel
                   the need to free memory tied up with these structures.

                   Note that these structures and buffers are automatically
                   allocated for you by the HeliOS system the first time you
                   use a routine which needs them, and will normally be
                   deallocated automatically whenever MAKEGFXWINDOW or
                   MAKEGFXRPORT are used.

     GFXAREADRAW   ( n1 n2 _ _ _ )

                   Sets another point in an area drawing shape at ( n1,n2 ).

     GFXAREAELLIPSE ( n1 n2 n3 n4 _ _ _ )

                   Draws an area filled ellipse into the TMPRAS buffer, with
                   parameters as follows:

                   n1 = Horiziontal centre coordinate
                   n2 = Vertical centre coordinate
                   n3 = Horizontal radius
                   n4 = Vertical radius

     GFXAREAEND    ( _ _ _ )

                   Concludes a series of area drawing commands, displays
                   area, and tidies up.

     GFXAREAMOVE   ( n1 n2 _ _ _ )

                   Starts a new area drawing shape at point ( n1,n2 ).

     GFXAREAPAT    ( l1 n1 _ _ _ )

                   Sets the current area pattern size to n1 and the pattern
                   pointer to l1.

     GFXBLTBMAP    ( l1 n1 n2 n3 n4 n5 n6 n7 n8 l2 l3 _ _ _ )

                   Blit between bitmaps.

                   Calls the Amiga graphics BltBitMap routine with the
                   following parameter allocations :

                   l1 = TempA Buffer
                   n1 = Mask
                   n2 = Minterm
                   n3 = Size X
                   n4 = Size Y
                   n5 = Source X
                   n6 = Source Y
                   n7 = Dest   X
                   n8 = Dest   Y
                   l2 = Source Bitmap
                   l3 = Destination Bitmap

                   Read the Amiga Graphics manual before using this.

     GFXBLTCLEAR   ( l1 d1 d2 - - - )

                   Performs the Amiga Graphics library BltClear function
                   with the following parameters:

                   l1 = Memory block pointer (must be word aligned!)
                   d1 = ByteCount
                   d2 = Flags

                   Read the Amiga Graphics manual before using this.

     GFXBLTPATTERN ( l1 n1 n2 n3 n4 n5 _ _ _ )

                   Performs the Amiga Graphics library BltPattern function
                   with the following parameters:

                   l1 = Two dimensional mask pattern
                   n1 = Top left corner X
                   n2 = Top left corner Y
                   n3 = Lower right corner X
                   n4 = Lower right corner Y
                   n5 = Width of mask in bytes

                   Read the Amiga Graphics manual before using this.

     GFXBLTTEMPLATE ( n1 n2 n3 n4 n5 n6 l1 l2 _ _ _ )

                   Performs "Cookie cut" on a shape in a rectangle to a
                   RastPort.

                   Calls the Amiga graphics BltTemplate routine with the
                   following parameter allocations :

                   n1 = Size X
                   n2 = Size Y
                   n3 = Source X
                   n4 = Source Modulo
                   n5 = Dest   X
                   n6 = Dest   Y
                   l1 = Source Plane Ptr
                   l2 = Destination RastPort

                   Read the Amiga Graphics manual before using this.

     GFXCOS        ( n1 _ _ _ n2 )

                   Returns a value, n2, between 0 and 32767, representing
                   the COS of angle n1 (in degrees) scaled by a factor of
                   32767.

                   This is a quick and approximate routine designed for
                   fast graphics applications where speed and not absolute
                   accuracy is important.

     GFXDRAW       ( n1 n2 _ _ _ )

                   Continues a line drawing with point ( n1,n2 ).

     GFXDRAWELLIPSE ( n1 n2 n3 n4 _ _ _ )

                   Draws an outline ellipse with parameters as follows:

                   n1 = Horiziontal centre coordinate
                   n2 = Vertical centre coordinate
                   n3 = Horizontal radius
                   n4 = Vertical radius

     GFXDSQROOT    ( d1 _ _ _ n1 )

                   Returns the single number square root of a double number
                   d1.

                   This is a quick and approximate routine designed for
                   fast graphics applications where speed and not absolute
                   accuracy is important.

     GFXFASTREADPIXEL ( l1 n1 n2 - - - n3 )

                   Reads a pixel pen colour fast.

                   l1 = BitMap
                   n1 = X-coordinate
                   n2 = Y-coordinate
                   n3 = Pen colour

                   Does not use Graphics Library or layers.

     GFXFASTWRITEPIXEL ( l1 n1 n2 n3 - - - )

                   Writes a pixel fast in simple overwrite drawing mode.

                   l1 = BitMap
                   n1 = X-coordinate
                   n2 = Y-coordinate
                   n3 = Pen colour

                   Does not use Graphics Library or layers.

     GFXGETRGB     ( n1 _ _ _ n2 n3 n4 )

                   Get RGB values for colour register n1 of the current
                   GFX Screen as follows:

                   n1 = Colour register
                   n2 = Red level
                   n3 = Green level
                   n4 = Blue level

     GFXLINEPAT    ( n1 _ _ _ )

                   Stores n1 as the current line pattern.

     GFXMOVE       ( n1 n2 _ _ _ )

                   Starts a new line drawing at point ( n1,n2 ).

     GFXORIGIN     ( n1 n2 _ _ _ )

                   Sets the origin for screen coordinates used by the HeliOS
                   pixel write, area move/draw, and line move/draw words.

                   For example, using this word you can set the 0,0 point of a
                   window to the centre of the display, if you wish, rather
                   than the top left corner.

                   Whenever the MAKEGFXWINDOW or MAKEGFXRPORT commands are
                   used the origin is reset to the top left corner using
                   "0 0 GFXORIGIN".

     GFXOUTLINE    ( flag _ _ _ )

                   Switches on or off outline mode for area drawing.

                   flag = 0 for Off, and 1 for On

     GFXPOLYDRAW   ( n1 a1 _ _ _ )

                   Draw lines from a table of (x,y) values.

                   n1 = Count of pairs of points in array
                   a1 = Pointer to first data pair

     GFXREAD      ( n1 n2 _ _ _ n3 )

                   Reads a pixel at point (n1,n2), returning colour n3.

                   Uses Graphics Library "ReadPixel".

     GFXRECTFILL   ( n1 n2 n3 n4 _ _ _ )

                   Carries out a rectangle fill operation with following
                   parameters:

                   n1 = X min
                   n2 = Y min
                   n3 = X max
                   n4 = Y max

     GFXRPORT      ( _ _ _ l1 )

                   Returns current GFX RPort l1.

     GFXSCREEN     ( _ _ _ l1 )

                   Returns current GFX Screen handle l1.

                   Note that the current GFX screen is simply the screen
                   associated with the current GFX window.

     GFXSCROLLRAST ( n1 n2 n3 n4 n5 n6 _ _ _ )

                   Carries out a rectangle scroll operation with following
                   parameters:

                   n1 = scroll X increment/decrement with respect to (0,0)
                   n2 = scroll Y increment/decrement with respect to (0,0)
                   n3 = X min
                   n4 = Y min
                   n5 = X max
                   n6 = Y max

     GFXSETAPEN    ( n1 _ _ _ )

                   Set primary pen to colour n1.

     GFXSETBPEN    ( n1 _ _ _ )

                   Set secondary pen to colour n1.

     GFXSETDMODE   ( n1 _ _ _ )

                   Set current drawing mode to n1.

     GFXSETOPEN    ( n1 _ _ _ )

                   Set outline pen to colour n1.

     GFXSETRAST    ( n1 _ _ _ )

                   Set whole raster to pen n1.

     GFXSETRGB     ( n1 n2 n3 n4 _ _ _ )

                   Set RGB values for colour as follows :

                   n1 = Colour register
                   n2 = Red level
                   n3 = Green level
                   n4 = Blue level

     GFXSIN        ( n1 _ _ _ n2 )

                   Returns a value, n2, between 0 and 32767, representing
                   the SIN of angle n1 (in degrees) scaled by a factor of
                   32767.

                   This is a quick and approximate routine designed for
                   fast graphics applications where speed and not absolute
                   accuracy is important.

     GFXSWAPWINDOW ( _ _ _ )

                   Used after setting up a double buffered display with the
                   word GFXTRAWINDOW.

                   Use MAKEGFXWINDOW to select your first rendering window
                   and draw your first image. Then use GFXSWAPWINDOW before
                   drawing the next image, and so on .............

                   One window will always be displayed whilst the other is
                   being drawn into. This is a very simple no frills window
                   swapping routine which has the virtue of simplicity and
                   works well enough for simple 3-D animated displays etc.

     GFXTEXT       ( n1 n2 _ _ _ )

                   Directly calls the Amiga Graphics library Text routine.

                   n1 = Pointer to text
                   n2 = Count

     GFXTRAWINDOW  ( l1 _ _ _ )

                   Makes the window with handle l1 a secondary window used
                   for simple double buffered displays.

                   To use this function proceed as follows:

                   First create two windows, both identically configured.

                   The primary window must first be made the GFXWINDOW and
                   GFXAREAEND should be used once to cause Area rendering
                   "extras" such as TMPRAS to be automatically set up. These
                   will be shared by both windows.

                   After doing this, use GFXTRAWINDOW with the secondary
                   window handle to set up the second window and the window
                   swapping mechanism.

                   Subsequent use of GFXSWAPWINDOW will cause one of the
                   windows to be rendered into whilst the other one is being
                   displayed, then vice versa. This is a very simple and not
                   fast or sophisticated method of getting a double buffered
                   display for "unseen" rendering and image switching. It is
                   useful for drawing animating, and displaying such things
                   as 3-D objects.

     GFXVPORT      ( _ _ _ l1 )

                   Returns current GFX VPort l1.

     GFXWAITBOVP   ( _ _ _ )

                   Wait until vertical beam reaches bottom of GFX viewport.

     GFXWAITTOF    ( _ _ _ )

                   Wait for the top of the next video frame.

     GFXWINDOW     ( _ _ _ l1 )

                   Returns current GFX Window handle l1.

     GFXWRITE      ( n1 n2 _ _ _ )

                   Writes a pixel at point (n1,n2).

                   Uses Graphics Library "WritePixel".

     MAKEGFXWINDOW ( l1 - - - )

                   Make window with handle l1 the current GFX window.
                   See also MAKEGFXRPORT, which allows you to operate with
                   the graphics routines on a "disembodied" rastport.


---------------------------------------------------
HELIOS MONOCHROME AND MULTICOLOURED BITMAPPED FONTS
---------------------------------------------------

     The HeliOS language has its own built-in bitmapped font text rendering
     system which provides the following special advantages:

     1. Easy design of fonts.
     2. Multi-coloured font options.
     3. Use in both the Amiga and HeliOS game operating systems.
     4. Stencilled font rendering allowing multi-coloured texture mapping.
     5. Uses only the CPU, with no blitter access whatever.
     6. Very simple to use routines for configuration and text output into
        either BitMaps or RastPorts.

     Although it was originally designed for use in games, the HeliOS
     bitmap font text system may actually be used both under the Amiga
     operating system and the HeliOS game operating system.

     This HeliOS text system does not employ the blitter for its rendering
     operations, and this makes it ideal for use with the HeliOS game system
     in circumstances where it is not possible to access the blitter: for
     example while the blitter is being used by the game sprite rendering
     engine.

     Because, for easy use with the HeliOS game system, the HeliOS text
     system intentionally uses only the CPU for all its operations, it can
     suffer from relatively slow rendering speed in certain circumstances if
     not used judiciously.  You may wish to experiment with various methods
     of text display to discover what works best in particular circumstances.

     The HeliOS system can render text using bitmapped font imagery supplied
     as a simple bitmap picture of all the font characters.

     Remember, a HeliOS font is simply a picture, nothing more, and can be
     created, edited, saved and loaded as a normal IFF picture file.

     The font imagery is loaded into memory as a simple bitmapped graphic
     using any of the standard HeliOS functions for loading graphics.

     The SETHELIOSFONT function is then used to set up the HeliOS bitmap
     font text system to use the loaded bitmapped graphical font.  The
     parameters of the new font are defined by a HeliOS "Font Definition"
     data structure.

     Note that if the input parameter to SETHELIOSFONT is zero the standard
     HeliOS system default 8x8 pixel font will be re-installed, and that
     this default font is always resident within the HeliOS system.

     The HeliOS font system always has the default font preset at startup
     time, but this is not automatically reset at the end of a program.

     HeliOS fonts are standard bitmapped graphics which can be created in
     any art package and saved/loaded as simple IFF pictures: this allows
     really easy design of new text font effects.

     A HeliOS font can be either:

     1. Monochrome      This is a monochrome bitmap which can be rendered in
                        various pen colours exactly like a normal Amiga font.

                        The pen colours for rendering monochrome fonts are
                        derived from:

                        a. The target rendering RastPort.

                           In this case they may be set using GFXSETAPEN
                           and GFXSETBPEN or by writing directly into the
                           RastPort structure.

                        or

                        b. Parameters specified in the special HeliOS text
                           functions which use HeliOS fonts.

     2. Multi-coloured  This is created as a multi-coloured bitmap image
                        having as many colours as your design requires.

                        Note that, as might be expected, only as many
                        bitplanes as the target display possesses will
                        actually be used when the font is finally rendered.


     Notes on the HeliOS "Font Definition" data structure:

     Firstly, here is the layout of the HeliOS font definition structure.

     Imagery BitMap pointer -> 4 bytes
     Mask    BitMap pointer -> 4 bytes
     Character cell width   -> 2 bytes
     Character cell height  -> 2 bytes
     Characters per row     -> 2 bytes
     Flags                  -> 2 bytes

     Total size = 16 bytes.

     An example of this in HeliOS code might be as follows.

     CREATEL MyFontDefinition

     MyFontBMap       D,
     MyFontMaskBMap   D,
     MyFontCharWidth   ,
     MyFontCharHeight  ,
     MyFontCharsPerRow ,
     MyFontFlags       ,

     This data structure specifies all required information about the
     bitmapped font imagery being installed into the HeliOS system.

     Firstly it specifies the imagery BitMap and a mask BitMap.

     The imagery BitMap must always be supplied, but the mask parameter
     may be left as null if required.  If supplied, the Mask BitMap must
     define a single bitplane monochrome image, the defined pixels of
     which will be used as a mask to specify visible pixels of the main
     font imagery bitmap.

     Important:

              It is a requirement that the font mask BitMap must have
              identical pixel dimensions to the font imagery BitMap.


     Note that there is a convenient HeliOS function called GETMASK which
     will automatically generate a mask bitmap from any supplied bitmap,
     so you can easily generate the mask for any font from the font bitmap
     itself.

     The use of a mask allows stencil operations to be employed.

     For example, the imagery bitmap may be actual character imagery or
     may be just a solid area of colour pattern information, in which case
     the Mask supplied may be used as a stencil to "cut out" characters
     from the solid background.

     A standard monochrome font bitmap image may be used as a mask to
     generate a multi-coloured font from a solid "coloured plane area"
     image bitmap.

     It is vitally important when using texture mapping and masks that the
     mask image and the font/texture image are of identical dimensions.
     Failure to observe this criterion will always result in incorrect font
     rendering, so remember that the pixel width and height of the mask
     must match those of the the main imagery bitmap exactly.

     Note that the Mask does NOT operate as a mask on data within the
     target display, and all characters are rendered to the screen in
     overwrite mode such that the whole of a rectangular character cell
     replaces the original screen background information.

     If you wish to render text with characters having a transparent
     background you should either render the text into a dummy sprite
     and then project that onto the screen or use a blitter operation
     from an intermediate "off screen projection" bitmap.

     The character cell width and height are simple pixel dimensions,
     and must be the same for all characters in the font.

     The "Characters per row" parameter specifies how many characters
     there are in each row of your supplied font BitMap, and is simply
     used to tell the HeliOS system how to extract character information
     from a font image.

     The "Flags" parameter tells the HeliOS system whether this font is a
     monochrome or multi-coloured font.

     Flags = 0 -> Monochrome
     Flags = 1 -> Multi-coloured


     Notes on the design of HeliOS fonts:

     HeliOS fonts are created as normal pictorial bitmap images in any
     Amiga paint package: the images of the font characters are simply
     drawn/painted in order into a graphical image.

     HeliOS fonts must be designed with exactly regular character cell
     sizes, and a full set of characters must be placed in normal ASCII
     character order in rows starting from the top left corner of the
     font image.

     Thus, a HeliOS font starts with the characters

     !"#$%&'()*+,-./0123456............etc.

     then proceeds through the whole of the ASCII character set.

     The "!" character must be in the top left (0,0 pixel position) cell,
     followed by the other characters in strict order proceeding from left
     to right.

     It is possible to construct a font image using either a single row of
     characters in a very short and wide bitmap, or using multiple rows in
     succeeding vertical order (as in an ordinary text layout).

     e.g.

     Single row layout:

     !"#$%&'()*+,-./0123456........................................etc.

     or

     Multiple row layout:

     !"#$%&'()*+
     ,-./0123456
     ...........
     ...........
     ...........
     .......etc.

     If you choose to use a multi-row layout you can employ whatever column
     and row dimensions you wish.  The only constraint is that the characters
     are all represented in strict ASCII order in columns reading from left
     to right and with rows proceeding down the page from top to bottom.

     The HeliOS font definition structure specifies the character cell pixel
     size and the number of characters per row, so that the system can easily
     extract graphical character cells from the supplied BitMap.

     -------------------------------------------------------------------

     Here are commands used to set up and render text using HeliOS fonts:

     HELIOSBMTEXT

     ( BitMap(l), TextString(l), TextLength(w), XPos(w), YPos(w), BPen(w),
       FPen(w) - - - )

     Note that the pen colours will only be used when rendering monochrome
     (not multi-coloured) HeliOS fonts.

     Renders the specified number of characters from a 32-bit addressed
     uncounted text string into the target BitMap.

     The top left corner of the display field is specified by "XPos" and
     "YPos", and the background and foreground colours are specified by
     "BPen" and "FPen".

     The font used will be the current HeliOS system bitmap font.


     HELIOSRPTEXT

     ( RastPort(l), TextString(l), TextLength(w) - - - )

     This function renders text into the destination RastPort supplied
     using the current HeliOS system bitmapped font.

     The text is rendered (exactly like ordinary "Graphics Library" text)
     at the current drawing position specified within the RastPort.  This
     can be set by the usual GFXMOVE command or (less wisely) by direct
     modification of the RastPort parameters.

     If the font used is a monochrome font the colour information for the
     background and foreground pens is also derived from the target RastPort
     parameters as with "Graphics Library" text.


     LEFTNUM

     ( BitMap(l), Number(l), FieldLength(w), XPos(w), YPos(w), BPen(w)
       FPen(w) - - - )

     Renders a 32-bit signed "Number" into the target "BitMap" in a
     left justified numeric display field "FieldLength" characters wide.

     The top left corner of the display field is specified by "XPos" and
     "YPos", and the background and foreground colours are specified by
     "BPen" and "FPen".

     Note that the pen colours will only be used when rendering monochrome
     (not multi-coloured) HeliOS fonts.

     The font used will be the current HeliOS system bitmap font.

     The "blank" characters in the numeric field will be rendered as
     the ASCII characters specified in the string NUMFILL.

     If the system default NUMFILL is used, all blank characters will be
     rendered as "0".

     See also RIGHTNUM and NUMFILL


     RIGHTNUM

     ( BitMap(l), Number(l), FieldLength(w), XPos(w), YPos(w), BPen(w)
       FPen(w) - - - )

     Renders a 32-bit signed "Number" into the target "BitMap" in a
     right justified numeric display field "FieldLength" characters wide.

     The top left corner of the display field is specified by "XPos" and
     "YPos", and the background and foreground colours are specified by
     "BPen" and "FPen".

     The font used will be the current HeliOS system bitmap font.

     Note that the pen colours will only be used when rendering monochrome
     (not multi-coloured) HeliOS fonts.

     The "blank" characters in the numeric field will be rendered as
     the ASCII characters specified in the string NUMFILL.

     If the system default NUMFILL is used, all blank characters will be
     rendered as "0".

     See also LEFTNUM and NUMFILL


     NUMFILL

     ( - - - l1 )

     Returns a 32-bit pointer to an address which itself contains a
     32-bit pointer to a string 16 characters in length which will be
     used as the numeric field fill character by the HeliOS operating
     system's justified number routines.

     Use NUMFILL like this:

     CREATEL MyNumFillChars <$ 0000000000000000$

     MyNumFillChars NUMFILL D!L

     The system default NUMFILL uses the ASCII "0" character as above,
     so if this is your requirement you do not need to reset NUMFILL.

     See also LEFTNUM and RIGHTNUM


     SETHELIOSFONT

     ( FontDefinition(l) - - - )

     Where FontDefinition(l) = Pointer to a HeliOS font definition structure.

     A null parameter restores the default HeliOS 8x8 pixel monochrome font.

     This command sets up the font to be used by the HeliOS bitmapped font
     text rendering system.

     See above for a description of the "Font Definition" data structure
     used to specify characteristics of the font to be installed.

     Note that if the input parameter to SETHELIOSFONT is zero the standard
     HeliOS system default 8x8 pixel font will be re-installed, and that
     this default font is always resident within the HeliOS system.

     The HeliOS font system always has the default font preset at startup
     time.


------
COPPER
------

     HeliOS contains simple to use commands for constructing Amiga copper
     lists, and these commands are used under the normal Amiga operating
     system.

     Once constructed, a copperlist can be used however you wish, whether
     under the Amiga operating system or under the HeliOS game operating
     system.

     In order to install a user copperlist under the HeliOS game operating
     system there are several special commands which are not dissimilar to
     counterparts used by the Amiga OS.  These commands are all listed and
     explained below, and ONLY function when the HeliOS operating system
     is being used.

     You do not need to specify any memory allocation when creating copper
     lists using the HeliOS functions below: you simply tell HeliOS to
     start building a copper list, and it will handle memory allocation
     automatically.

     HeliOS automatically allocates some initial memory and builds your
     copper list sequentially according to your commands, adjusting the
     memory allocation whenever required.

     When you have completed your copper list, you simply tell HeliOS to
     finish its copper construction.

     HeliOS will then move your new copper list to its own correctly sized
     memory buffer and tidy up, passing you a pointer to the new copperlist.

     You should NOT start to build a second copper list before you have
     finished a first one, but if you do HeliOS will automatically close
     and de-allocate the old copper list which was in progress.

     --------------------------------
     Example of building a copperlist
     --------------------------------

     0. DVARIABLE Copper
     0. DVARIABLE CopperLength

     : Create_Copper

     COPPERSTART Copper D!
     [ HEX ]
     0 B0 FFFE COPPERWAIT  DROP
     0 190 COPPERMOVE      DROP
     0 192 COPPERMOVE      DROP
     0 194 COPPERMOVE      DROP
     0 196 COPPERMOVE      DROP
     0 198 COPPERMOVE      DROP
     0 19A COPPERMOVE      DROP
     0 19C COPPERMOVE      DROP
     0 19E COPPERMOVE      DROP
     [ DECIMAL ]
     COPPEREND
     DFLAG
     IF
      CopperLength D!   Copper D!
     ELSE
      DDROP
      ." Copper Failed!"
     THEN
     ;

     : Free_Copper

     Copper D@ FREEMEMORY
     ;

     -------------------------------------------------------------------

     Here are the commands used for building copper lists:


     COPPERADD     ( Value(w) - - - flag )

                   A special "low-level" HeliOS copper construction command
                   which allows you to add construct "custom" copperlist
                   sequences however you wish.

                   This is a "toolkit" command which causes HeliOS to add the
                   value you have specified as the next 16-bit value in the
                   copper list under construction.

                   COPPERADD is a DANGEROUS command, since it is up to you
                   to ensure the correct format and sequence of any copper
                   commands inserted in this way!

                   The result "flag" indicates whether or not the operation
                   was successful.

     COPPEREND     ( - - - CopperStart(l), CopperLength(l) or null )

                   Ends the building of a copper list.

                   This command returns a 32-bit pointer to the start of the
                   final copper memory allocated by HeliOS and the 32-bit
                   length of the copperlist in bytes.

                   The COPPEREND command returns a SINGLE 32-bit null value
                   for failure.

     COPPERMOVE    ( Value(w), HardwareOffset(w) - - - flag(w) )

                   This command causes HeliOS to add a copper MOVE line to
                   the current copper list being built.

                   The first input parameter is the value you want to MOVE
                   into a hardware register.

                   The second input parameter is the offset of the target
                   register from $DFF000.

                   The result "flag" indicates whether or not the operation
                   was successful.

     COPPERSKIP    ( HWait(w), VWait(w), Ctrl(w) - - - flag(w) )

                   This command causes HeliOS to add a copper SKIP line to
                   the current copper list being built.

                   The input parameters are standard Amiga copper values,
                   and for details on how this works refer to any text on
                   constructing Amiga copper lists.

                   HeliOS handles "long" screen raster positions (>255)
                   automatically.

                   The result "flag" indicates whether or not the operation
                   was successful.

     COPPERSTART   ( - - - CopperStart(l) or null )

                   Starts building a copper list and, if necessary, removes
                   any partially built copper lists.

                   This command returns a 32-bit pointer to the start of the
                   initial copper memory allocated by HeliOS, or a 32-bit
                   null value for failure.

     COPPERWAIT    ( HWait(w), VWait(w), Ctrl(w) - - - flag(w) )

                   This command causes HeliOS to add a copper WAIT line to
                   the current copper list being built.

                   The input parameters are standard Amiga copper values,
                   and for details on how this works refer to any text on
                   constructing Amiga copper lists.

                   HeliOS handles "long" screen raster positions (>255)
                   automatically.

                   The result "flag" indicates whether or not the operation
                   was successful.


     *****************************************************************
     Commands for custom user-copperlists under the HeliOS game system
     *****************************************************************

     HeliOS runs a custom master copperlist which is constructed like a
     "ladder" with slots (or "rungs") where individual sub-copperlists may
     be located.

     HeliOS maintains an internal table which organises these sub-lists
     into the correct order of operation.

     When you add a new custom sub-copperlist, or copper strip as HeliOS
     calls it, the basic idea is that:

     1. HeliOS adds a pointer to your new user copperlist to its internal
        copper table.

     2. HeliOS sorts the copper table into correct order, checking to see
        which copper lists should come first.

     3. HeliOS relinks all the pointers in the master copperlist to include
        all the sub-copperlists in the correct order.

     There are three main commands for handling this process, and these are
     part of a number of Display functions by means of which HeliOS allows
     displays to be modified.

     All HeliOS display functions start and end with a 32-bit pointer to the
     current display structure on the stack.

     This allows you to construct fast economical sequences of commands
     without the necessity to repeatedly put the display pointer on the
     stack for each command.

     Remember to drop the display pointer off the stack after your last
     command!


     -----------------------------------------
     Example of adding a HeliOS sub-copperlist
     -----------------------------------------

     : AddCopper

     280 WAITBEAM
     Display Copper D@ ADDCOPPERSTRIP
     SORTSTRIPTABLE
     LINKSTRIPS
     DDROP
     ;


     ADDCOPPERSTRIP  ( Display(l), Copperlist(l) - - - Display(l) )

                   Adds your new copperlist pointer to the HeliOS copper
                   table.

     LINKSTRIPS      ( Display(l) - - - Display(l) )

                   Relinks all sub-copperlists into the master copperlist.

     REMCOPPERSTRIP  ( Display(l), Copperlist(l) - - - Display(l) )

                   Removes specified copperlist pointer from the HeliOS
                   copper table.

                   This function only removes the copperlist pointer from
                   the reference table and does not remove the copperlist
                   itself from the display.

                   To remove the copperlist finally from the display, you
                   need to call the REMCOPPERSTRIP function and then call
                   LINKSTRIPS.

                   This routine has built-in safety and can apply to an
                   already removed or not-added copperlist.

     SORTSTRIPTABLE  ( Display(l) - - - Display(l) )

                   Sorts all the sub-copperlists in the HeliOS copper table.

     *****************************************************************
     Simple HeliOS copper list utilities
     *****************************************************************

     -----
     CLIST   ( Display(l), CopperList#(n) - - - Pointer(l) )
     -----

     Returns a longword pointer to the position in the HeliOS display 
     internal copper list table specified by the CopperList# parameter.

     The copper list table contains pointers to actual copper lists, 
     stored in 4 byte cells in a simple linear list.  Note that it is 
     the cells in this table, and not the copperlists themselves, which 
     are pointed to by the result of this function.

     Using a CopperList# value of 0 will return a pointer to the storage
     location of the main primary display copperlist.

     ---------
     CLISTDUMP   ( CopperList(l), Lines#(n) - - - )
     ---------

     Where:

     CopperList   -> A 32-bit pointer to either:

                     1. The start of a copper list

                     2. The start of any instruction line of a copper list

     Lines#       -> Specifies how many lines will be sequentially "dumped".

                     A value of "-1" here will dump everything right up to
                     the end of the list.

     This command simply provides a fairly crude dump of the contents of a
     copper list in hexadecimal format with two 16-bit words per line.


--------
DEBUGGER
--------

There are several HeliOS words which control the action of the debugger
from within your program.  These words can be used to set up breakpoints
and conditional debugging etc.

See the "Debug.doc" file for more information on the debugger.


     SETDEBUG      ( cfa [or 0] - - - )

                   Used in the form:

                   FIND MYDEBUGWORD SETDEBUG

                   to make MYDEBUGWORD the subsequent debug action.

                   N.B.

                   To restore the system default debug action use:

                   0 SETDEBUG


     GETDEBUGLEVEL ( - - - n1 )

                   Returns n1, the current depth, or level, of the threaded
                   interpreter.

                   You can use this word to determine how many nested levels
                   deep your current execution word lies.

     SHOWDEBUGWORD ( n1 - - - )

                   This word will print to screen the name of the HeliOS
                   word which lies at level n1 in the current execution
                   thread.

                   If you use a value of "n1 = -1", a full list of the full
                   execution thread will be printed.

                   This is the default used by the system debug word.

     SETDEBUGPAUSE ( - - - )

                   Acts like the debug "Pause" button to enter debugger
                   paused state.

     SETDEBUGABORT ( - - - )

                   Acts like the debug "Abort" button to abort the debug
                   session.

     SETDEBUGSCREEN ( n1 - - - )

                   Where:

                   n1 = switch (1 for "On", 0 for "Off")

                   Acts like the debug "Screen" button to toggle screen
                   output mode.

     SETDEBUGBUFFER ( n1 - - - )

                   Where:

                   n1 = switch (1 for "On", 0 for "Off")

                   Acts like the debug "Buffer" button to toggle buffer
                   output mode.


     SETDEBUG#     ( n1 - - - )

                   Inserts a number n1 into the debug step number string
                   gadget and updates the step number.


     SETDEBUGSTEP  ( n1 - - - )

                   Where:

                   n1 = switch (1 for "On", 0 for "Off")

                   Sets the current status of the debug "Step" button.

************************************************************************
End of word definitions
************************************************************************

---------
* NOTES *
---------

 DELIMITER

         String operators which use the system string delimiter are
         marked by the reference { DELIMITER }.

         Here is a short list of these words:

         !TEXT  $  .$  $CONSTANT  $CONSTANTL  $VARIABLE  $VARIABLEL
         DELWORD  LIT$  LIT$L

         The delimiter can be altered or fetched by using DEL! or DEL@.

         The default delimiter character is $.

         This is in most cases more useful than using '"' or 'space' since
         it allows use of '"' and 'space' in the defined strings.

 Example 1.     The following example uses !TEXTL which reads a string taken
                from the input stream immediately after the word !TEXTL.

                !TEXTL $ Teststring $
                       ^            ^ Delimiter = $, the default value.
                      ^ Space always required to identify end of HeliOS word.

                The string " Teststring " is read by !TEXTL, from between
                the two $ delimiters, retaining the spaces at each end.

                If one of the characters of the required string were to be
                the character "$", then the system delimiter would have to
                be changed.

Example 2.      This example uses $CONSTANT to define the string constant
                STRINGSTORE which holds the string $STRING.

                In this case the system delimiter has to be changed from
                "$".

                42 DEL!   ( Sets system delimiter to ASCII 42 = * )

                $CONSTANT STRINGSTORE *$STRING*
                         ^           ^ Note spaces delimiting new name.
                                      ^       ^ New system delimiter.

************************************************************************
End of dictionary
************************************************************************
