  \ ***********************************************************
  \
  \      PARALLAX SCROLLING DUAL PLAYFIELD WITH TEXT DEMO
  \
  \ ***********************************************************
  \
  \ This code demonstrates how to create a display with multiple
  \ dual playfield slices and variable speed parallax scrolling.
  \
  \ This code builds upon the following Demos:
  \
  \ Demo1_SinglePF.src
  \ Demo2_SinglePFCopper.src
  \
  \ ***********************************************************



  \ ***********************************************************
  \ Re-initialise HeliOS dictionary to standard CORE vocabulary
  \ ***********************************************************

  \ This should always be used at the start of any program which
  \ is to be repeatedly recompiled.

  FORGET **CORE**

  \ *************************
  \ Load include symbol files
  \ *************************
  \
  \ These "include files" are pre-compiled (for speed) versions of the
  \ Amiga includes and the Helios system includes.
  \
  \ Uncomment the lines below for standalone compilation, but otherwise
  \ it is better to set these include files from the Helios Forth menus

  AMIGAINCLUDE HeliOS:HeliOS_AmigaInclude
  USERINCLUDE  HeliOS:HeliOS_UserInclude

  \ ****************************************
  \ Create display imagery file name strings
  \ ****************************************

  \ These files are ordinary IFF's (and may be "PowerPacked" if required)
  \
  \ The pictures here will be loaded into each of the display BitMaps.
  \

  $CONSTANTL Slice1APic $Helios:Source/Data/Pic1A$
  $CONSTANTL Slice1BPic $Helios:Source/Data/Pic1B$
  $CONSTANTL Slice2APic $Helios:Source/Data/Pic2A$
  $CONSTANTL Slice2BPic $Helios:Source/Data/Pic2B$
  $CONSTANTL Slice3Pic  $Helios:Source/Data/Pic3$

  \ **************************************
  \ Create display configuration constants
  \ **************************************
  \
  \ Collect all "display-specific" parameters here and generate "named"
  \ constants which make references easier than using numeric values.
  \
  \ Collecting these together here makes it easier to adjust things at any
  \ time without having to search source code to replace values individually.
  \


  256                      CONSTANT DisplayHeight      \ Full PAL display
  44                       CONSTANT DisplayTopLine     \ Display start

 \ The top slice is a scrolling display area with two 8-colour playfields
 \
 \ A-slice = foreground playfield and B-slice = background playfield
 \
 \ The B-slice has extra-wide horizontal raster size (640 pixels) to allow
 \ for horizontal scrolling, with an additional 320 pixels width to allow
 \ for horizontal smooth wrapping.
 \
 \ The A-slice does not scroll.
 \

  320                      CONSTANT Slice1Width        \ Lores width
  30                       CONSTANT Slice1Height       \ Top slice height
  30                       CONSTANT Slice1RasterHeight \ Raster=sliceheight
  WORDINCLUDE
  V_DUALPF                 CONSTANT Slice1Mode         \ Top slice screenmode
  LONGINCLUDE

  320                      CONSTANT Slice1ARasterWidth \ Raster=screenwidth
  3                        CONSTANT Slice1APlanes      \ A-slice bitplanes
  2 Slice1APlanes 1- LSL   CONSTANT Slice1AColours     \ A-slice colours

  640 320 +                CONSTANT Slice1BRasterWidth \ Scroll plane width
  3                        CONSTANT Slice1BPlanes      \ B-slice bitplanes

  \ The calculation below takes the number of bitplanes and calculates
  \ how many colours this represents.
  \
  \ One bitplane gives two colours.
  \
  \ Each additional bitplane multiplies the number of colours by two.
  \
  \ Performing a single LSL operation on any number multipies by 2, so we
  \ have a quick method of multiplying by two for our colour calculation.
  \
  \ In this case, we need "2 to the power 3", which is 2*2*2=8.
  \
  \ e.g.                              2*2*2
  \                                   ^ ^ ^
  \                                   Total number of planes = 3
  \
  \
  \ So, we take the first value two
  \
  \ e.g.                              2*2*2
  \                                   ^
  \                                  Initial start value of 2
  \
  \ and we now need to multiply it by two "the_number_of_planes minus_one"
  \ more times.
  \
  \ e.g.                              2*2*2
  \                                     ^ ^
  \                                     Total planes minus one
  \
  \
  \ So, Number of colours = 2 operated on by LSL NumberOfPlanes-1 times.
  \

  2 Slice1BPlanes 1- LSL   CONSTANT Slice1BColours     \ B-slice colours


 \ The middle slice is a scrolling play area and has two 8 colour playfields
 \
 \ A-slice = foreground playfield and B-slice = background playfield
 \
 \ Both these slices have extra-wide horizontal raster size to allow for
 \ horizontal scrolling (1280 pixels), and an additional 320 pixels for
 \ horizontal smooth wrapping.
 \
 \ These slices both also have 16 pixel extra border areas to allow
 \ rendering of partially off-screen BOBs, since this would normally be
 \ a main game play area.
 \

  320                      CONSTANT Slice2Width        \ Lores width
  170                      CONSTANT Slice2Height       \ Middle slice height
  170 32 +                 CONSTANT Slice2RasterHeight \ Middle bitplane height
  WORDINCLUDE
  V_DUALPF                 CONSTANT Slice2Mode         \ Middle screenmode
  LONGINCLUDE

  1280 320 + 32 +          CONSTANT Slice2ARasterWidth \ A-slice scroll-raster
  3                        CONSTANT Slice2APlanes      \ A-slice planes
  2 Slice2APlanes 1- LSL   CONSTANT Slice2AColours     \ A-slice colours

  640 320 + 32 +           CONSTANT Slice2BRasterWidth \ B-slice scroll-raster
  3                        CONSTANT Slice2BPlanes      \ B-slice planes
  2 Slice2BPlanes 1- LSL   CONSTANT Slice2BColours     \ B-slice colours

 \ The bottom slice is an ordinary single playfield with 32 colours

  640                      CONSTANT Slice3Width        \ Hires width
  640                      CONSTANT Slice3RasterWidth  \ Raster=screenwidth

  DisplayHeight
  Slice1Height -
  Slice2Height -           CONSTANT Slice3Height       \ Bottom slice height

  4                        CONSTANT Slice3Planes       \ Bottom slice planes
  2 Slice3Planes 1- LSL    CONSTANT Slice3Colours      \ Bottom slice colours
  WORDINCLUDE
  V_HIRES                  CONSTANT Slice3Mode         \ Bottom slice screenmode
  LONGINCLUDE

  \ ***********************
  \ Error handling routines
  \ ***********************

  \ This error handler allows all errors to be routed via a comprehensive
  \ sequential closedown routine, which is associated with the HeliOS
  \ system error handler word ERROR".
  \
  \ When ERROR" senses an error, it prints an associated error message
  \ delimited by '"' characters, and then closes everything down using the
  \ routine CLOSEDOWN below which you have supplied.
  \
  \ This simplifies errors checks to the use of a single word, ERROR", which
  \ displays a text message and closes eveything down.
  \

  0 VARIABLE (CLOSEDOWN)

  : ?CLOSEDOWNERROR

  IF
    CR
    CR
    TYPE
    CR
    CR
    ." Press <Space> to quit!"
    CR
    CR
    WAITSPACE
    (CLOSEDOWN) @EXECUTE
    QUIT
  ELSE
    DDROP
  THEN
  ;

  LATESTCFA VARIABLE ERROR1

  \ ********************************
  \ Create pointer storage variables
  \ ********************************

  \ Here we create a set of "pointers", initially set to a "null" value.
  \
  \ These "pointers" are set up as "long addresses" when various components
  \ of the display system are allocated and initialised.
  \
  \ Note that initially these are all set to zero, and we clear them back
  \ to zero when we de-allocate the associated resource.
  \
  \ These DPOINTERs are all initially set to "null" by using '0.'.
  \
  \ When we allocate memory or Amiga system resources in the program at
  \ run-time, these pointers are updated to contain the 32-bit address
  \ of the newly allocated resource.
  \
  \ Subsequently the symbolic DPOINTER name can be used in your code to
  \ represent the associated address.

  0. DPOINTER Display1             \ Main Display structure pointer
  0. DPOINTER Slice1               \ Slice 1 Slice structure pointer
  0. DPOINTER Slice2               \ Slice 2 Slice structure pointer
  0. DPOINTER Slice3               \ Slice 3 Slice structure pointer

  0. DPOINTER Slice1_ColorMap      \ Slice 1 ColourMap structure pointer
  0. DPOINTER Slice2_ColorMap      \ Slice 2 ColourMap structure pointer
  0. DPOINTER Slice3_ColorMap      \ Slice 3 ColourMap structure pointer

  0. DPOINTER Slice1A_RasInfo      \ Slice 1A RasInfo structure pointer
  0. DPOINTER Slice1B_RasInfo      \ Slice 1B RasInfo structure pointer
  0. DPOINTER Slice2A_RasInfo      \ Slice 2A RasInfo structure pointer
  0. DPOINTER Slice2B_RasInfo      \ Slice 2B RasInfo structure pointer
  0. DPOINTER Slice3_RasInfo       \ Slice 3  RasInfo structure pointer

  0. DPOINTER Slice1A_BMap         \ Slice 1A BitMap structure pointer
  0. DPOINTER Slice1B_BMap         \ Slice 1B BitMap structure pointer
  0. DPOINTER Slice2A_BMap         \ Slice 2A BitMap structure pointer
  0. DPOINTER Slice2B_BMap         \ Slice 2B BitMap structure pointer
  0. DPOINTER Slice3_BMap          \ Slice 3  BitMap structure pointer

  0. DPOINTER Slice1A_SliceControl \ Slice 1A SliceControl structure pointer
  0. DPOINTER Slice1B_SliceControl \ Slice 1B SliceControl structure pointer
  0. DPOINTER Slice2A_SliceControl \ Slice 2A SliceControl structure pointer
  0. DPOINTER Slice2B_SliceControl \ Slice 2B SliceControl structure pointer

  \ *************
  \ Colour tables
  \ *************

  \ Each colour entry requies 2 bytes of storage space

  CREATEL Slice1_ColorTable        \ Create longword pointer
  Slice1AColours 2* ALLOT          \ Allocate Slice1A colours * 2 bytes
  Slice1BColours 2* ALLOT          \ Allocate Slice1B colours * 2 bytes

  CREATEL Slice2_ColorTable        \ Create longword pointer
  Slice2AColours 2* ALLOT          \ Allocate Slice2A colours * 2 bytes
  Slice2BColours 2* ALLOT          \ Allocate Slice2B colours * 2 bytes

  CREATEL Slice3_ColorTable  Slice3Colours  2* ALLOT


  \ ***************************
  \ Synchronised display scroll
  \ ***************************

  \ This word is plugged into the interrupt driven SliceControl handler,
  \ so will always execute automatically every frame with perfect timing.

  : MoveDisplay

  DDROP                                           \ Drop SliceControl pointer

  1 0  Slice1A_SliceControl  SETFIELD2SCROLL      \ Set 1 pixel H-scroll

  RAWKEY @ 79 =
  IF
    QUALIFIER @ 8 AND                             \ Is <Ctrl> pressed?
    IF
      12
    ELSE
      4
    THEN
    DUP
       0  Slice2A_SliceControl  SETFIELD1SCROLL   \ Set foreground H-scroll
    2/ 0  Slice2A_SliceControl  SETFIELD2SCROLL   \ Set background H-scroll
  ELSE
    RAWKEY @ 78 =
    IF
    QUALIFIER @ 8 AND                             \ Is <Ctrl> pressed?
    IF
      -12
    ELSE
      -4
    THEN
    DUP
       0  Slice2A_SliceControl  SETFIELD1SCROLL \ Set foreground H-scroll
    2/ 0  Slice2A_SliceControl  SETFIELD2SCROLL \ Set background H-scroll
    THEN
  THEN
  ;

  LATESTCFA VARIABLE (MoveDisplay)                \ Store cfa address

  \ *************************************
  \ Copper strip for graduated background
  \ *************************************

  0. DVARIABLE Copper
  0. DVARIABLE CopperLength

  : AddCopper

  Display1
  Copper D@
  ADDCOPPERSTRIP
  SORTSTRIPTABLE
  LINKSTRIPS
  DDROP
  ;

  : RemCopper                      \ Remove custom copper list from display

  Display1                         \ We are removing CopperList from Display1
  Copper D@
  DFLAG
  IF
    REMCOPPERSTRIP
    LINKSTRIPS
    DDROP
  ELSE
    DDDROP
  THEN
  ;

  : Create_Copper

  COPPERSTART
  Copper D!
  0 [ DECIMAL ] 190 [ HEX ] FFFE COPPERWAIT  DROP   0100 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 194 [ HEX ] FFFE COPPERWAIT  DROP   0200 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 198 [ HEX ] FFFE COPPERWAIT  DROP   0300 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 202 [ HEX ] FFFE COPPERWAIT  DROP   0400 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 204 [ HEX ] FFFE COPPERWAIT  DROP   0500 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 208 [ HEX ] FFFE COPPERWAIT  DROP   0600 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 212 [ HEX ] FFFE COPPERWAIT  DROP   0700 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 216 [ HEX ] FFFE COPPERWAIT  DROP   0800 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 220 [ HEX ] FFFE COPPERWAIT  DROP   0900 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 224 [ HEX ] FFFE COPPERWAIT  DROP   0A00 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 228 [ HEX ] FFFE COPPERWAIT  DROP   0B00 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 232 [ HEX ] FFFE COPPERWAIT  DROP   0C00 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 236 [ HEX ] FFFE COPPERWAIT  DROP   0D00 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 240 [ HEX ] FFFE COPPERWAIT  DROP   0E00 192 COPPERMOVE  DROP
  0 [ DECIMAL ] 244 [ HEX ] FFFE COPPERWAIT  DROP   0F00 192 COPPERMOVE  DROP
  [ DECIMAL ]
  COPPEREND
  CopperLength D!   Copper D!
  ADDCOPPER
  ;

  : Free_Copper

  RemCopper
  Copper D@ FREEMEMORY
  ;

  \ ***********************************
  \ Create Display and Slice structures
  \ ***********************************

  \ This routine simple makes blank structures, which then need to be
  \ initialised in the CREATE_DISPLAY routine below.

  : CREATE_DSLICES

  DS_SIZEOF MAKESTRUCTURE Display1 MAKEPOINTER  \ Main "Display" structure

  SL_SIZEOF MAKESTRUCTURE Slice1   MAKEPOINTER  \ Top    "Slice" structure
  SL_SIZEOF MAKESTRUCTURE Slice2   MAKEPOINTER  \ Middle "Slice" structure
  SL_SIZEOF MAKESTRUCTURE Slice3   MAKEPOINTER  \ Bottom "Slice" structure
  ;

  : FREE_DSLICES

  Slice3    DDUP FREEMEMORY   CLEARPOINTER
  Slice2    DDUP FREEMEMORY   CLEARPOINTER
  Slice1    DDUP FREEMEMORY   CLEARPOINTER
  Display1  DDUP FREEMEMORY   CLEARPOINTER
  ;

  \ ******************************
  \ Create RasInfo structures etc.
  \ ******************************

  : CREATE_RASINFO

  \ First allocate and initialise complete RasInfo structures.
  \
  \ This routine automatically allocates all BitMaps etc.
  \

  Slice1ARasterWidth Slice1RasterHeight  Slice1APlanes   OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo1A"
  Slice1A_RasInfo MAKEPOINTER

  Slice1BRasterWidth Slice1RasterHeight  Slice1BPlanes   OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo1B"
  Slice1B_RasInfo MAKEPOINTER

  Slice2ARasterWidth Slice2RasterHeight Slice2APlanes    OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo2A"
  Slice2A_RasInfo MAKEPOINTER

  Slice2BRasterWidth Slice2RasterHeight Slice2BPlanes    OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo2B"
  Slice2B_RasInfo MAKEPOINTER

  Slice3RasterWidth  Slice3Height  Slice3Planes          OPENRASINFO
  DFLAG0= ERROR" Fail: RasInfo3"
  Slice3_RasInfo MAKEPOINTER

  \ Set invisible area "sprite margins" for middle slice RasInfo

  16              Slice2A_RasInfo         ri_RxOffset    INDEX!L
  16              Slice2A_RasInfo         ri_RyOffset    INDEX!L

  16              Slice2B_RasInfo         ri_RxOffset    INDEX!L
  16              Slice2B_RasInfo         ri_RyOffset    INDEX!L

  \ Link Dual Playfield RasInfo structures

  Slice1B_RasInfo Slice1A_RasInfo         ri_Next        INDEXD!L
  Slice2B_RasInfo Slice2A_RasInfo         ri_Next        INDEXD!L

  \ Store BitMap pointers - often useful for later reference

  Slice1A_RasInfo  ri_BitMap INDEXD@L Slice1A_BMap MAKEPOINTER

  Slice1B_RasInfo  ri_BitMap INDEXD@L Slice1B_BMap MAKEPOINTER

  Slice2A_RasInfo  ri_BitMap INDEXD@L Slice2A_BMap MAKEPOINTER

  Slice2B_RasInfo  ri_BitMap INDEXD@L Slice2B_BMap MAKEPOINTER

  Slice3_RasInfo   ri_BitMap INDEXD@L Slice3_BMap  MAKEPOINTER
  ;

  : FREE_RASINFO

  Slice3_RasInfo    DDUP CLOSERASINFO   CLEARPOINTER
  Slice2B_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice2A_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice1B_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  Slice1A_RasInfo   DDUP CLOSERASINFO   CLEARPOINTER
  ;

  \ ************************
  \ Create Slice Copperlists
  \ ************************

  \ This function builds the main display copperlist by:
  \
  \ 1. Initialising the individual Slice data structures
  \ 2. Calling MAKECOPSTRIP for each slice, to build Slice copperlists
  \ 3. Calling MAKEDISPLAY to build the master Display copperlist
  \

  : CREATE_DISPLAY

  \ First initialise main display structures

  Slice1                           Display1  DS_Slice     INDEXD!L

  Slice2                           Slice1    SL_Next      INDEXD!L
  Slice1Width                      Slice1    SL_DWidth    INDEX!L
  Slice1Height                     Slice1    SL_DHeight   INDEX!L
  DisplayTopLine                   Slice1    SL_DyOffset  INDEX!L
  Slice1A_RasInfo                  Slice1    SL_RasInfo   INDEXD!L
  Slice1_ColorMap                  Slice1    SL_ColorMap  INDEXD!L
  Slice1Mode                       Slice1    SL_Modes     INDEX!L

  Slice3                           Slice2    SL_Next      INDEXD!L
  Slice2Width                      Slice2    SL_DWidth    INDEX!L
  Slice2Height                     Slice2    SL_DHeight   INDEX!L
  Slice1Height DisplayTopLine + 1+ Slice2    SL_DyOffset  INDEX!L
  Slice2A_RasInfo                  Slice2    SL_RasInfo   INDEXD!L
  Slice2_ColorMap                  Slice2    SL_ColorMap  INDEXD!L
  Slice2Mode                       Slice2    SL_Modes     INDEX!L

  Slice3Width                      Slice3    SL_DWidth    INDEX!L
  Slice3Height                     Slice3    SL_DHeight   INDEX!L

  Slice1Height Slice2Height +
  DisplayTopLine + 2+              Slice3    SL_DyOffset  INDEX!L

  Slice3_RasInfo                   Slice3    SL_RasInfo   INDEXD!L
  Slice3_ColorMap                  Slice3    SL_ColorMap  INDEXD!L
  Slice3Mode                       Slice3    SL_Modes     INDEX!L

  \ Generate copper list information for each of the display slices

  Slice1 MAKECOPSTRIP
  D0= ERROR" Fail: Slice1CopStrip"
  Slice2 MAKECOPSTRIP
  D0= ERROR" Fail: Slice2CopStrip"
  Slice3 MAKECOPSTRIP
  D0= ERROR" Fail: Slice3CopStrip"

  \ Make display

  Display1 MAKEDISPLAY
  D0= ERROR" Fail: Display1"
  ;

  : FREE_DISPLAY

  Display1                 FREEDISPLAY
  Slice3                   FREECOPSTRIP
  Slice2                   FREECOPSTRIP
  Slice1                   FREECOPSTRIP
  ;

  \ ***************************************************
  \ Create SliceControl structures for scrolling slices
  \ ***************************************************

  \ SliceControl structures are used to control any slices which perform
  \ mapping or scrolling functions, or which require double or triple
  \ playfield buffering.
  \
  \ In this case we have two slices which scroll horizontally, each with
  \ automatic wrap.
  \
  \ The front middle slice playfield in this case is double buffered to
  \ allow smooth BOB rendering as a game main playfield.
  \
  \ The HeliOS SLICECONTROL functions are extremely powerful, since they
  \ handle all the double buffering and scrolling with automatic wrap.
  \

  : CREATE_SLICECONTROLS

  \ Make two top Dual-Playfield SliceControls, each playfield with standard
  \ single buffered bitmap displays, as indicated by "-1" parameters

  Slice1  -1 -1 -1 -1 MAKEDPSLICECONTROL
  DFLAG0= ERROR" Fail: SliceControl1"
  Slice1A_SliceControl MAKEPOINTER

  \ Get second dual playfield SliceControl pointer

  Slice1A_SliceControl SliceControl_DPSControl2 INDEXD@L
  Slice1B_SliceControl MAKEPOINTER

  \ Set BPLCON2 control value

  [ BIN ] 100100 [ DECIMAL ]
  Slice1A_SliceControl    SliceControl_BPLCON2     INDEX!L

  \ Set up rear playfield for automatic horizontal smooth wrapping

  1 Slice1B_SliceControl  SliceControl_HWrapFlag   INDEX!L

  \ Make middle two Dual-Playfield SliceControls, the rear playfield with
  \ a standard single buffered bitmap display, configured by "-1" parameters,
  \ and the front one with a double buffered display, configured by the 0
  \ parameters.

  Slice2  0  0 -1 -1 MAKEDPSLICECONTROL
  DFLAG0= ERROR" Fail: SliceControl2"
  Slice2A_SliceControl MAKEPOINTER

  \ Get second dual playfield slice control

  Slice2A_SliceControl    SliceControl_DPSControl2 INDEXD@L
  Slice2B_SliceControl MAKEPOINTER

  \ Set BPLCON2 control value

  [ BIN ] 100100 [ DECIMAL ]
  Slice2A_SliceControl    SliceControl_BPLCON2     INDEX!L

  \ Set up both playfields for automatic horizontal smooth wrapping

  1 Slice2A_SliceControl  SliceControl_HWrapFlag   INDEX!L
  1 Slice2B_SliceControl  SliceControl_HWrapFlag   INDEX!L

  \ Install display movement control word

  (MoveDisplay) @ Slice2A_SliceControl SliceControl_BeforeForth INDEX!L

  \ Install slice controls into HeliOS display control system

  Slice1A_SliceControl  INSTALLSLICECONTROL
  Slice1B_SliceControl  INSTALLSLICECONTROL
  Slice2A_SliceControl  INSTALLSLICECONTROL
  Slice2B_SliceControl  INSTALLSLICECONTROL
  ;

  : FREE_SLICECONTROLS

  CLEARSLICECONTROLS
  Slice2B_SliceControl  CLOSESLICECONTROL
  Slice2A_SliceControl  CLOSESLICECONTROL
  Slice1B_SliceControl  CLOSESLICECONTROL
  Slice1A_SliceControl  CLOSESLICECONTROL
  ;

  \ These routines load IFF pictures into supplied BitMaps, and correctly
  \ initialise the supplied ColorTables.
  \
  \ The ColorTables are then used to create initialised ColorMap structures.
  \

  : CREATE_IMAGERY

  Slice1A_BMap
  Slice1_ColorTable
  Slice1APic
  10
  2 DOSLIB
  10 <> ERROR" Fail: Slice1APic"

  Slice1B_BMap
  Slice1_ColorTable Slice1AColours 2 M* D+
  Slice1BPic
  10
  2 DOSLIB
  10 <> ERROR" Fail: Slice1BPic"

  Slice2A_BMap
  Slice2_ColorTable
  Slice2APic
  10
  2 DOSLIB
  10 <> ERROR" Fail: Slice2APic"

  Slice2B_BMap
  Slice2_ColorTable Slice2AColours 2 M* D+
  Slice2BPic
  10
  2 DOSLIB
  10 <> ERROR" Fail: Slice2BPic"

  Slice3_BMap
  Slice3_ColorTable
  Slice3Pic
  10
  2 DOSLIB
  10 <> ERROR" Fail: Slice3Pic"

  Slice1_ColorTable  Slice1AColours Slice1BColours + MAKECOLORMAP
  DFLAG0= ERROR" Fail: Slice1ColorMap"
  Slice1_ColorMap MAKEPOINTER

  Slice2_ColorTable  Slice2AColours Slice2BColours + MAKECOLORMAP
  DFLAG0= ERROR" Fail: Slice2ColorMap"
  Slice2_ColorMap MAKEPOINTER

  Slice3_ColorTable   Slice3Colours                  MAKECOLORMAP
  DFLAG0= ERROR" Fail: Slice3ColorMap"
  Slice3_ColorMap MAKEPOINTER
  ;

  : FREE_IMAGERY

  Slice3_ColorMap  DDUP FREECOLORMAP  CLEARPOINTER
  Slice2_ColorMap  DDUP FREECOLORMAP  CLEARPOINTER
  Slice1_ColorMap  DDUP FREECOLORMAP  CLEARPOINTER
  ;

  \ *********************
  \ Close down everything
  \ *********************

  : CLOSEDOWN

  FREE_COPPER
  FREE_SLICECONTROLS
  FREE_DISPLAY
  FREE_IMAGERY
  FREE_RASINFO
  FREE_DSLICES
  RESETERROR"
  ;

  LATESTCFA (CLOSEDOWN) !

  : TestDisplay

  SCRCLR
  CR

  ."        **********************************************************"
  CR 6 FPENSET
  ."             PARALLAX SCROLLING DUAL PLAYFIELD WITH TEXT DEMO"
  CR 1 FPENSET
  ."        **********************************************************"
  CR
  CR
  ."        This code demonstrates how to create a display with multiple"
  CR
  ."        dual playfield slices and variable speed parallax scrolling."
  CR
  CR
  ."        This code builds upon the following Demos:"
  CR
  CR
  ."        Demo1_SinglePF.src"
  CR
  ."        Demo2_SinglePFCopper.src"
  CR
  CR
  ."        **********************************************************"
  CR 6 FPENSET
  ."                  Press <Space> or <L-Mouse> to see Demo"
  CR 3 FPENSET
  ."            Use keyboard to change scroll speed and direction."
  CR
  ."        **********************************************************"
  CR

  WAITSPACE

  SCRCLR


  ERROR1 SETERROR"

  CREATE_DSLICES
  CREATE_RASINFO
  CREATE_IMAGERY
  CREATE_DISPLAY
  CREATE_SLICECONTROLS
  CREATE_COPPER

  HeliOS_On

  1 FrameRate !L

  Display1 SHOWDISPLAY

  1 0  Slice1A_SliceControl  SETFIELD2SCROLL   \ Set 1 pixel H-scroll
  4 0  Slice2A_SliceControl  SETFIELD1SCROLL   \ Set foreground H-scroll
  2 0  Slice2A_SliceControl  SETFIELD2SCROLL   \ Set background H-scroll

  WAITSPACE

  HeliOS_Off

  CLOSEDOWN
  ;

  TestDisplay
