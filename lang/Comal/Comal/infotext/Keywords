This is a quick reference to the built-in AmigaCOMAL keywords. 
After each keyword (typed in CAPS to allow you to scan them 
quickly) its syntax is shown, followed by at least one example. 
Notation used for displaying keyword syntax is a modified form of 
Backus-Naur notation, similar to that used by COMAL Today, COMAL 
Handbook, and the COMAL Kernal Standard. Generally its rules are: 
 
(a)Normal text not enclosed in < > is typed as shown (you may 
          type in caps or lower case regardless of how the text is 
          shown). 
 
(b)Items enclosed in < > are supplied by the user. The <> are not 
          typed. 
 
(c)Items enclosed in [ ] are optional. If used, do not type the 
          [ ]. 
 
(d)Items enclosed in { } are optional and may have several 
          occurances. If used, do not type the { }. 
 
(e)The | means "or". You choose one or the other of the items 
          divided by the |. 
 
(f)All punctuation should be typed as shown, including the ( ). 
 
Remember that the examples given are only example lines, not entire 
programs. They often require other COMAL statements to actually 
work, such as initialization or procedure and function definitions. 
 
//  
  // 
  // anything typed here 
 
ABS  
  abs(<numeric expression>) 
  PRINT abs(standard'number) 
 
ACS 
  acs(<numeric expression>) 
  temp:=acs(num1+num2) 
 
ALLOCATE 
  allocate(<pointer var>[,<num>]) 
  allocate(new@) 
 
AND  
  <expression> AND <expression> 
  IF number>0 AND number<100 THEN 
 
APPEND  
  OPEN [FILE] <file#>,<filename>,APPEND 
  OPEN FILE 2,"test",APPEND 
 
ARGARRAY$ 
  argarray$(<num>) 
  IF argarray$(-1)="CLI" THEN 
 
ARGNUM 
  argnum 
  IF argnum>0 THEN check'parm 
 
ASN 
  asn(<numeric expression>) 
  PRINT asn(numb) 
 
AT  
  PRINT AT <row>,<col>: [<print list>[<mark>]] 
  INPUT AT <row>,<col>[,<len>]:[<prompt>:][<vars>[<mark>]] 
  PRINT AT 1,1: "Section number:"; num; 
  INPUT AT 10,1,1:"Yes or No? ":reply$ 
 
ATN 
  atn(<numeric expression>) 
  PRINT atn(num1+num2) 
 
AUTO  
  AUTO [<start line>][,<increment>] 
  AUTO 9000 
  AUTO 100,100 
  AUTO ,5 
  AUTO 
 
BITAND  
  <argument> BITAND <argument> 
  show(bnum BITAND %00001000) 
 
BITOR  
  <argument> BITOR <argument> 
  PRINT (bnum BITOR flag) 
 
BITXOR  
  <argument> BITXOR <argument> 
  bnum=(num1+num2) BITXOR %10000000 
 
BYE  
  BYE 
  BYE 
 
CASE  
  CASE <control expression> [OF] 
  CASE reply$ OF 
  CASE choice OF 
 
CAT - converted to DIR. See DIR. 
 
CD - a short form of CHDIR. See CHDIR. 
 
CHAIN  
  CHAIN <filename> 
  CHAIN "menu" 
 
CHANGE 
  CHANGE [<line range>] <text1>,<text2> 
  CHANGE "zz","printout" 
 
CHDIR 
  CHDIR [<string>] 
  CHDIR "testprog" 
  CHDIR 
 
CHR$  
  chr$(<numeric expression>) 
  PRINT chr$(num) 
 
CLOSE  
  CLOSE [[FILE] <filenum>] 
  CLOSE FILE 2 
  CLOSE 
 
CLOSED  
  PROC <procname>[(params)] [CLOSED] 
  FUNC <funcname>[(params)] [CLOSED] 
  PROC newpage(header$) CLOSED 
  FUNC gcd(n1,n2) CLOSED 
 
CON  
  CON 
  CON 
 
COPY 
  COPY "<source filename>","<destination filename>" 
  COPY "test.sav","final.sav" 
 
COS  
  cos(<numeric expression>) 
  PRINT cos(number) 
 
CREATE  
  CREATE <filename>,<# records>,<record size> 
  CREATE "names",128,200 
 
CURCOL  
  curcol 
  column:=curcol 
 
CURROW  
  currow 
  row:=currow 
 
CURSOR  
  CURSOR <line>,<position> 
  CURSOR 1,1 
 
DATA  
  DATA <value>{,<value>} 
  DATA "Sam",134,"Fred",22,"Gloria",46 
 
DATE$ 
  date$ 
  PRINT "Year:";date$(1:4) 
 
DEALLOCATE 
  deallocate(<pointer var>) 
  deallocate(new@) 
 
DEL  
  DEL <range> 
  DEL 460 
  DEL pause 
 
DELETE  
  DELETE <filename> 
  DELETE "test5.sav" 
 
DIM  
  DIM <string var> OF <max char> 
  DIM <str array>(<index>) OF <max char> 
  DIM <array name>(<index>) 
  DIM name$ of 30 
  DIM players$(1:4) OF 10 
  DIM scores(min:max) 
 
DIR  
  DIR [<drive/dir>] 
  DIR 
 
DIR$ 
  dir$ 
  PRINT dir$ 
 
DISCARD  
  DISCARD 
  DISCARD 
 
DISPLAY  
  DISPLAY [<range>] [TO] [<filename>] 
  DISPLAY "names.lst" 
  DISPLAY init 
 
DIV  
  <dividend> DIV <divisor> 
  result=guess DIV count 
 
DO : see FOR and WHILE 
 
ELIF  
  ELIF <expression> [THEN] 
  ELIF reply$ IN "YyNn" THEN 
 
ELSE  
  ELSE 
  ELSE 
 
END  
  END [<message>] 
  END  "All Done." 
 
ENDCASE  
  ENDCASE 
  ENDCASE 
 
ENDFOR  
  ENDFOR [<control variable>] 
  ENDFOR sides# 
  ENDFOR increment 
 
ENDFUNC  
  ENDFUNC [<function name>] 
  ENDFUNC even 
 
ENDIF  
  ENDIF 
  ENDIF 
 
ENDLOOP  
  ENDLOOP 
  ENDLOOP 
 
ENDPROC  
  ENDPROC [<procedure name>] 
  ENDPROC show'item 
 
ENDRECORD 
  ENDRECORD 
  ENDRECORD 
 
ENDTRAP 
  ENDTRAP 
  ENDTRAP 
 
ENDWHILE  
  ENDWHILE 
  ENDWHILE 
 
ENTER  
  ENTER <filename> 
  ENTER "testing.lst" 
 
EOD  
  eod 
  WHILE NOT eod DO 
 
EOF  
  eof(<filenum>) 
  WHILE NOT eof(infile) DO 
 
ERR  
  err 
  CASE err OF 
 
ERRFILE 
  errfile 
  IF errfile=2 THEN 
 
ERRTEXT$ 
  errtext$[(<num>)] 
  PRINT ">>";errtext$;"<<" 
 
ESC  
  esc 
  TRAP ESC+|- 
  IF esc THEN 
  TRAP ESC- 
 
EXEC  
  [EXEC] <procname>[(<parameter list>)] 
  show'item(number) 
 
EXIT  
  EXIT [WHEN <condition>] 
  EXIT WHEN errors>3 
 
EXP  
  exp(<numeric expression>) 
  PRINT exp(number) 
 
EXPORT 
  EXPORT <var>{,<var>} 
  EXPORT riskrate 
 
EXTERNAL 
  PROC <name>[(<parms>)][EXTERNAL <file>] 
  FUNC <name>[(<parms>)][EXTERNAL <file>] 
  FUNC rec'size(name$) EXTERNAL "rec.ext" 
  PROC set'up EXTERNAL "setup.ext" 
 
FALSE  
  FALSE 
  ok:=FALSE 
 
FIELD 
  FIELD <string var> OF <max char> 
  FIELD <str array>(<index>) OF <max char> 
  FIELD <array name>(<index>) 
  FIELD <numeric variable name> 
  FIELD name$ of 30 
  FIELD players$(1:4) OF 10 
  FIELD scores(min:max) 
  FIELD diskkey# 
  FIELD filename!(108) 
 
FILE : see CLOSE, INPUT, OPEN, PRINT, READ, WRITE 
 
FIND  
  FIND "<text string>" 
  FIND " PROC " 
 
FLOAT 
  float(<numeric expression>) 
  float(5) 
 
FOR  
  FOR <var>:=<#> TO <#> [STEP <#>] DO [<statement>] 
  FOR x:=10 TO 1 STEP -1 DO PRINT x 
  FOR getin:=1 TO max DO getinput(getin) 
  FOR num:=1 TO total DO 
 
FREE 
  free 
  PRINT free 
 
FREEFILE 
  freefile 
  editfile:=freefile 
 
FUNC  
  FUNC <name>[(<parm>)] [CLOSED] 
  FUNC <name>[(<parm>)] EXTERNAL <filename> 
  FUNC call'answered EXTERNAL "call" 
  FUNC but'first$(text$) CLOSED 
  FUNC occurances#(text$,c$) 
 
GET$  
  get$(<filenum>,<# of characters>) 
  text$=get$(2,16) 
 
GLOBAL 
  GLOBAL <var>{,<var>} 
  GLOBAL person@,id#,found,press$(),after(,) 
 
GOTO  
  GOTO <label name> 
  GOTO jail 
 
HANDLER  
  HANDLER 
  HANDLER 
 
IF  
  IF <condition> THEN [<statement>] 
  IF reply$ IN "yYnN" THEN 
 
IMPORT 
  IMPORT <identifier> {,<identifier>} 
  IMPORT running'total 
 
IN  
  <string1> IN <string2> 
  IF guess$ IN word$ THEN winner 
 
INKEY$ 
  inkey$ 
  reply$:=inkey$ 
 
INOUT - see SELECT. 
 
INPUT 
  INPUT FILE <file#>[,<rec#>]: <var list> 
  INPUT [AT <row>,<col>[,<len>]:][<prompt>:]<vars>[<mark>] 
  INPUT FILE 2: text$ 
  INPUT AT 5,2,10:"ZIP CODE: ": zip'code, 
  INPUT "Age? ":age 
  INPUT reply$ 
 
INT  
  int(<numeric expression>) 
  tally:+int(number) 
 
KEY$ 
  key$ 
  WHILE key$<>"c" DO WAIT 
 
LABEL  
  [LABEL] <label name>: 
  months: 
 
LEN  
  len(<string expression>) 
  length=len(text$) 
 
LET 
  [LET] <var>:=<value> //numeric or string 
  [LET] <var>:+<value> //numeric or string - incremental 
  [LET] <num var>:-<value> //numeric only - decremental 
  count:=5 // assign a variable a value 
  name$:="none";sum:=0 // assign several variables separated by ; 
  reply$:+mark$ // concatenate mark$ onto end of reply$ 
  score:-1 // decrement score by 1 
  name$(2):="computer" // assign an element of array name$ 
 
LINK -- not a keyword, see USE. 
 
LIST  
  LIST [<range>] [TO] [<filename>] 
  LIST header 
  LIST "myprog.lst" 
  LIST pause "pause.lst" 
 
LISTPACK 
  LISTPACK [<package>] 
  LISTPACK 
  LISTPACK system 
 
LOAD  
  LOAD [<filename>] 
  LOAD "menu" 
 
LOG  
  log(<numeric expression>) 
  PRINT log(number); 
 
LOOP 
  LOOP [<num> TIMES [<simple statement>]] 
  LOOP 10 TIMES 
  LOOP 
 
MAIN 
  MAIN
  MAIN

MAKEDIR - converted to MKDIR. See MKDIR.

MAXINDEX
  maxindex(arrayname([,]))
  PRINT maxindex(table())
  firstone=maxindex(scores(,))

MEMWINDOW
  MEMWINDOW+|-
  MEMWINDOW+

MERGE 
  MERGE [<line#>[,<increment>]] <filename>
  MERGE "readrec.lst"
  MERGE 580,1 "checkout.lst"

MININDEX
  minindex(arrayname([,]))
  PRINT minindex(table())
  firstone=minindex(scores(,))

MKDIR
  MKDIR <string>
  MKDIR "final"

MOD 
  <dividend> MOD <divisor>
  rem16=number MOD 16

NEW
  NEW
  NEW

NEXT : converted to ENDFOR, see ENDFOR

NOT 
  NOT <condition>
  IF NOT ok THEN

NULL
  NULL
  NULL

OF : see CASE, DIM and FIELD

OPEN 
  OPEN [FILE] <file#>,<filename>,<mode>
  OPEN FILE 2,"scores",READ

OR 
  <condition> OR <condition>
  IF reply$<"a" OR reply$>"z" THEN

ORD 
  ord(<string expression>)
  a=ord("a")

OTHERWISE 
  OTHERWISE
  OTHERWISE

OUTPUT - see SELECT OUTPUT.

PAGE 
  PAGE
  PAGE

PASS
  PASS <string>
  PASS "info"

PEEK 
  peek(<memory address>)
  device=peek(4839)

PI 
  pi
  PRINT "Value of PI is";pi

POINTER
  POINTER <pointer var> [TO <var>]{,<pointer var> [TO <var>]}
  POINTER len%
  POINTER rec'ptr@ TO freezer'article@

POKE 
  poke(<memory address>,<contents>)
  poke(4839,13)

PRINT 
  PRINT [AT <row>,<col>:] [USING <form>:] <list>[<mark>]
  PRINT [FILE <#>[,<rec>]:][USING <form>:]<list>[<mark>]
  PRINT FILE 2: text$
  PRINT AT 9,1: USING "$###.##": amount

PROC 
  PROC <name>[(<parms>)] [CLOSED]
  PROC <name>[(<parms>)] [EXTERNAL <file>]
  PROC readrec(number)
  PROC compare(t1$,t2$) EXTERNAL "comp.ext"

RANDOM
  OPEN FILE <file#>,<filename>,RANDOM <record length>
  OPEN FILE 2,"subs",RANDOM 88

RANDOMIZE 
  RANDOMIZE [<seed>]
  RANDOMIZE
  RANDOMIZE 8

READ 
  READ [FILE <file#>[,<rec#>]:] <var list>
  OPEN [FILE] <filenum>,<filename>,READ
  READ name$,age
  READ FILE 2,record: name$,adr$,city$,st$
  OPEN FILE 3,filename$,READ

READWRITE
  OPEN [FILE] <num>,<filename$>,READWRITE
  OPEN FILE 3,filename$,READWRITE

RECORD
  RECORD <name>@
  RECORD person@

REF 
  REF <var>
  PROC alter(REF text$) CLOSED
  FUNC slide(REF text$)

RENAME 
  RENAME <old filename>,<new filename>
  RENAME "temp","final"

RENUM 
  RENUM [<target start>][,<increment>]
  RENUM 100
  RENUM ,5
  RENUM 9000,1

REPEAT 
  REPEAT
  REPEAT

REPORT 
  REPORT [<error code>]
  REPORT
  REPORT 256

RESTORE 
  RESTORE [<label>]
  RESTORE month'names
  RESTORE

RETRY
  RETRY
  RETRY

RETURN 
  RETURN [<value>]
  RETURN TRUE
  RETURN text$

RND 
  rnd [(<start num>,<end num>)]
  dice=rnd(1,6)+rnd(1,6)

ROUND
  round(<numeric expression>)
  print round(total)

RUN 
  RUN [<filename>]
  RUN
  RUN "menu"

RUNWINDOW
  RUNWINDOW+|-
  RUNWINDOW+

SAVE 
  SAVE <filename>
  SAVE "zombies"

SCAN 
  SCAN
  SCAN

SELECT 
  SELECT <direction> <type>
  SELECT OUTPUT loc$
  SELECT INPUT infile$
  SELECT INOUT "sp:"

SGN 
  sgn(<numeric expression>)
  flag=sgn(number)

SIN 
  sin(<numeric expression>)
  plot(sin(num),y)

SIZE 
  SIZE
  SIZE

SPC$ 
  spc$(<number of spaces>)
  PRINT spc$(39)

SQR 
  sqr(<numeric expression>)
  root=sqr(number)

STEP 
  STEP <numeric expression>
  FOR x=1 TO max STEP 2 DO

STEP
  STEP
  STEP

STOP 
  STOP [<message>]
  STOP "now inside PROC remove'blank"

STR$ 
  str$(<number>)
  zip$=str$(number)

TAB 
  TAB(<column number>)
  PRINT TAB(col), name$

TAN 
  tan(<numeric expression>)
  PRINT tan(number)

THEN 
  THEN
  IF NOT ok THEN RETURN FALSE
  ELIF errors>3 THEN

TIME$
  time$
  PRINT time$

TIMER
  timer
  starting=timer

TIMER
  TIMER <num>
  TIMER 0

TO 
  <start num> TO <end num>
  FOR x:=1 TO 4 DO

TRACE
  TRACE[+|-]
  TRACE-
  TRACE+
  TRACE

TRAP 
  TRAP
  TRAP

TRAP ESC 
  TRAP ESC+|-
  TRAP ESC- // disable stop/break key
  TRAP ESC+ // enable stop/break key

TRUE 
  TRUE
  RETURN TRUE

UNIT
  UNIT [<string expression>]
  UNIT data'drive$

UNIT$
  unit$
  current$:=unit$

UNTIL 
  UNTIL <condition>
  UNTIL reply$="q"

USE
  USE <package> [FROM <directory$>]
  USE system
  USE system FROM "AmigaCOMAL:"

USING 
  PRINT [AT <row>,<col>: ]USING <format$>: <var list>
  PRINT USING "##> $###.##": x, cash(x)
  PRINT AT 8,5: USING "##": item

VAL 
  val(<numeric string>)
  age=val(reply$)

VARSIZE
  varsize(<var>)
  temp:=varsize(name$)

WAIT
  WAIT [<num>]
  WAIT 2
  WAIT

WHEN 
  WHEN <list of values>
  WHEN "Jan","jan"
  WHEN 1,2

WHILE 
  WHILE <expression> [DO] [<statement>]
  WHILE NOT EOF(infile) DO process
  WHILE errors<3 DO

WRITE 
  WRITE FILE <file#>[,<rec#>]:<var>
  OPEN [FILE] <filenum>,<filename>,WRITE
  WRITE FILE 2: name$
  OPEN FILE 3,"scores",WRITE

ZONE 
  ZONE [<tab interval>]
  ZONE 5
  z:=ZONE
