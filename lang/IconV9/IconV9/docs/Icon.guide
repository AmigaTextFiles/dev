@database "Icon.guide"
@author "Bob Alexander -- Translation from HTML and Amiga sections by Marc Culler"
@(c) "Based on material from the ProIcon Reference Manual,
used by permission of the Bright Forest Company"
@$VER: Icon.guide 1.0

@toc Main

@node Main "Icon Programming Language Reference"

		@{b}Icon Programming Language Version 9.1@{ub}

	 		@{u}Reference Summaries@{uu}

	Help summaries are available for each of the Icon executable
	programs (icont, iconx), and for many aspects of the Icon
	language itself. A set of frequently asked questions about Icon
	is available at the URL:
	   http://www.cs.arizona.edu/icon/www/faq.html



		@{" Icon translator and linker            " link icont}
		@{" Icon interpreter                      " link iconx}
		@{" Amiga features                        " link amiga}
		@{" Summary of expressions and precedence " link expressions}
		@{" Summary of functions                  " link functions}
		@{" Summary of operations                 " link operations}
		@{" List of keywords                      " link keywords}
		@{" List of Icon datatypes                " link datatypes}
		@{" List of reserved words                " link reserved}
		@{" List of string escape sequences       " link escapes}
		@{" Abbreviations used in help files      " link abbreviations}
		@{" Bibliography and credits              " link about}
@endnode

@node icont
		@{b}Icon Translator@{ub}
@{i}Usage: @{ui}icont [option...] file... [-x] 
@{i}Options: @{ui}
-c        translate only, without linking
-E        preprocess only
-fs       prevent removal of all unreferenced declarations
          (same as "invocable all")
-o file   name the icode output file @{u}file@{uu}
-s        suppress progress messages
-t        give &trace an initial value of -1
-u        issue warnings for undeclared identifiers
-v n      set verbosity of output, where n = 
             0   suppress non-error output (same as -s)
             1   list procedure names (the default)
             2   also report the sizes of icode sections
                 (procedures, strings, and so forth)
             3   also list discarded globals
-x        execute after linking

@{i}Environment variables recognized by icont: @{ui}
@{u}Name         Default     Description@{uu}
IPATH           none     search path for link directives
LPATH           none     search path for $include directives

Search paths are blank-separated lists of directories. The
current directory is searched before a search path is used. 
@{i}See also: @{ui}@{"iconx -- Icon interpreter" link iconx}  @{" Amiga features " link amiga} 
@endnode

@node iconx
		@{b}Icon Interpreter@{ub}

The Icon interpreter is normally invoked automatically when the name
of an Icon program is entered as a command, but it can also be invoked
explicitly:

iconx icode-file-name [arguments for Icon program]

@{i}Environment variables recognized at runtime:@{ui}

Name         Default    Description
--------     -------    -----------------------
TRACE              0    Initial value for &trace.
NOERRBUF   undefined    If set, &errout is not buffered.
STRSIZE       500000    Initial size (bytes) of string region (strings).
BLKSIZE       500000    Initial size (bytes) of block region (most objects).
COEXPSIZE       2000    Size (long words) of co-expression blocks.
MSTKSIZE       10000    Size (long words) of main interpreter stack.
Default sizes may differ on some platforms.

@{i}See also: @{ui}@{"icont -- Icon translator and linker" link icont}  @{" Amiga features " link amiga} 
@endnode

@node amiga

	@{b}Using Icon on the Amiga@{ub}

This section describes special features of the Amiga implementation of
version 9 of the Icon programming language.

@{i}Running Icon from the Workbench:@{ui}
The Icon translator icont can be run from the Workbench by
double-clicking its tool icon in the bin drawer.  If you start the
interpreter in this way you will be presented with a file requester
with which to select the source (.icn) files to be translated.  The
requester supports multi-selection by shift-clicking the file names.
All of the selected file names will be passed to icont as arguments. 

You may also pass filename arguments to icont by selecting their icons.
This is done in the usual way: first click on the IconT tool icon then
shift-click the project icons of the source files.  Double-click the last
project icon to start icont.  (The process is like typing a command line:
first the command, then the arguments.  The final double-click is like
the carriage return.)  If you pass more than one argument you will be
given a file requester to select the name of the icode file.

It is not so easy to pass options from the Workbench, so this is done
by using an environment variable.  Whenever icont is started from the
Workbench it checks the environment variable @{i}IcontOptions@{ui} to get its
options.  Use @{i}Setenv@{ui}, for example from the "Execute Command ..." menu
item, to set the variable.  The value should be an AmigaDOS style
argument string based on the template:

NoLink/S,StrInv/S,Silent/S,Trace/S,UWarn/S,Output/K,Verbosity/K

The first five options are switches equivalent to -c -fs -s -t and -u.
The Ouput and Verbosity keywords are equivalent to -o and -v.  The
command 

Setenv IcontOptions NoLink Trace Output=myfile Verbosity=2

would make icont, when started from the Workbench, behave as if you
had invoked it from the command line as

icont -c -t -v4 -o myfile 

If the .info file @{b}ENV:Icon/def_Icode.info@{ub} exists on your system then icont
will use it to build a project icon for each icode file.  The Default Tool
will be set to Icon:bin/iconx, so you can execute your program by
double-clicking its project icon.  You can pass filename arguments as
with icont by shift clicking the corresponding Workbench icons.

The following ToolTypes are supported:

WINDOW STDIN STDOUT STDERR STRSIZE BLKSIZE MSTKSIZE

The WINDOW ToolType sets the geometry and features of the default
console window for your icon program.  Unless otherwise specified,
this window serves as the stdin, stdout and stderr streams for the
program.  Each of these streams may be redirected to either a file or
a window by using the corresponding ToolType.  The last three
ToolTypes determine the sizes of the memory blocks and main stack
allocated by iconx.  They are equivalent to the environment variables
with the same names. 

@{i}An integrated Icon programming environment:@{ui}
Both the interpreter and the translator use ARexx to implement an
integrated programming environment.  The mechanism is this: whenever
an error is encountered, the error message is posted as an ARexx Clip.
When either program exits with an error, it executes an ARexx script
to process the clips.  For example, the ARexx script might start your
favorite text editor and jump to the line containing the error.  The
names of the ARexx programs used by icont and iconx are, respectively,
@{b}ENV:Icon/IcontError.rexx@{ub} and @{b}ENV:Icon/IconxError.rexx@{ub}. If these
files do not exist then no action is taken on exit, although the clips
will still be posted as long as your resident ARexx process is
running. 

Two sample implementations of this scheme are included in the Icon
package.  One uses the @{b}memacs@{ub} editor.  Since @{b}memacs@{ub} does not open an
ARexx port, all that can (and is) done is to start the editor and jump
to the line containing the first error.  A more sophisticated system
is implemented using the SAS/C message browser @{b}scmsg@{ub} and the @{b}se@{ub}
editor.  In this case all the error clips are passed to the message
browser.  The error messages are displayed on your screen in the
@{b}scmsg@{ub} window.  Double-clicking on a line in this window causes the @{b}se@{ub}
editor to jump to the corresponding line in the source file. 

The ARexx Clips have names of the form <Program>Clip.<Number> where <Program>
is typically either Icont or Iconx and <Number> is the error count.  Thus
the clip IcontClip.3 would contain the third error encountered by icont
in a given run.  If there are multiple icont or iconx processes running
they each select a unique name by appending a single digit, so a clip named
Icont2Clip.4 would contain the fourth error encountered by the third instance
of icont.  (The name <Program> is also the name of the ARexx port used by
the program.  These are reply ports only - messages sent to them are ignored.)
The values of the error clips are string of the form

File: @{i}filename@{ui} Line: @{i}m @{ui}Number: @{i}n @{ui}Text: @{i}errormessage@{ui}

where @{i}m @{ui}is the line number of the error in the source file and @{i}n @{ui}
is the error number, for iconx, or 0 for icont. 

@{i}Pipes and handlers:@{ui}
The Amiga version of Icon implements pipes by using Per Bojsen's
APipe-Handler, which is included with the distribution.  Actually, if
you have APIPE: on your system then there is no need for the "p"
option to open(), since APIPE: allows any program (or script)
to open a pipe as if it were a standard file.  However, to maximize
the portability of Icon programs, the UNIX syntax is supported.  Thus,
for example,

open("List mydirectory", "p")

is equivalent to 

open("APIPE:List mydirectory", "r")

There are other Amiga handlers which should be useful to Icon programmers,
such as the TCP: handler that is distributed with the AmiTCP package.  With
the TCP: handler installed on your Amiga, the command

open("TCP:ftp.cs.arizona.edu/ftp", "rw") 

would allow your Icon program to converse with the ftp daemon at the
University of Arizona.

@endnode

@node expressions
	@{b}Icon Programming Language Expressions@{ub}

Expressions shown in order of decreasing precedence. Items in groups (as
separated by empty lines) have equal precedence. 

@{i}High Precedence Expressions:@{ui}

     (expr)                             grouping
     {expr1;expr2;...}                  compound
     @{" x(expr1,expr2,...)             " link invoke}  process argument list
     @{" x{expr1,expr2,...}             " link invoke_coexpr}  process argument list
     @{" [expr1,expr2,...]              " link create_list}  list
     @{" expr.F                         " link field}  field reference
     @{" expr1[expr2]                   " link subscript}  subscript
     @{" expr1[expr2:expr3]             " link section}  section
     @{" expr1[expr2+:expr3]            " link section_plus}  section
     @{" expr1[expr2-:expr3]            " link section_minus}  section

@{i}Prefix Expressions:@{ui}

     @{" not expr                       " link not}  success/failure reversal
     @{" | expr                         " link repeat_alternate}  repeated alternation
     @{" ! expr                         " link values}  element generation
     @{" * expr                         " link size}  size
     @{" + expr                         " link positive}  numeric value
     @{" - expr                         " link negative}  negative
     @{" . expr                         " link dereference}  value (dereference)
     @{" / expr                         " link null}  null
     @{" \ expr                         " link nonnull}  non-null
     @{" = expr                         " link tab_match}  match and tab
     @{" ? expr                         " link random}  random value
     @{" ~ expr                         " link complement}  cset complement
     @{" @ expr                         " link activate}  activation
     @{" ^ expr                         " link refresh}  refresh

@{i}Infix Expressions:@{ui}

     @{" expr1 \ expr2                  " link limit}  limitation
     @{" expr1 @ expr2                  " link transmit}  transmission
     @{" expr1 ! expr2                  " link invoke_list}  invocation

     @{" expr1 ^ expr2                  " link exponential}  power

     @{" expr1 * expr2                  " link product}  product
     @{" expr1 / expr2                  " link quotient}  quotient
     @{" expr1 % expr2                  " link remainder}  remainder
     @{" expr1 ** expr2                 " link intersection}  intersection

     @{" expr1 + expr2                  " link sum}  sum
     @{" expr1 - expr2                  " link difference}  numeric difference

     @{" expr1 ++ expr2                 " link union}  union
     @{" expr1 -- expr2                 " link set_difference}  cset or set difference

     @{" expr1 || expr2                 " link concatenation}  string concatenation
     @{" expr1 ||| expr2                " link list_concatenation}  list concatenation

     @{" expr1 < expr2                  " link num_lt}  numeric comparison
     @{" expr1 <= expr2                 " link num_le}  numeric comparison
     @{" expr1 = expr2                  " link num_eq}  numeric comparison
     @{" expr1 >= expr2                 " link num_ge}  numeric comparison
     @{" expr1 > expr2                  " link num_gt}  numeric comparison
     @{" expr1 ~= expr2                 " link num_ne}  numeric comparison
     @{" expr1 << expr2                 " link str_lt}  string comparison
     @{" expr1 <<= expr2                " link str_le}  string comparison
     @{" expr1 == expr2                 " link str_eq}  string comparison
     @{" expr1 >>= expr2                " link str_ge}  string comparison
     @{" expr1 >> expr2                 " link str_gt}  string comparison
     @{" expr1 ~== expr2                " link str_ne}  string comparison
     @{" expr1 === expr2                " link val_eq}  value comparison
     @{" expr1 ~=== expr2               " link val_ne}  value comparison

     @{" expr1 | expr2                  " link alternate}  alternation

     @{" expr1 to expr2 by expr3        " link to_by}  integer generation

     @{" expr1 := expr2                 " link assign}  assignment
     @{" expr1 <- expr2                 " link rev_assign}  reversible assignment
     @{" expr1 :=: expr2                " link exchange}  exchange
     @{" expr1 <-> expr2                " link rev_exchange}  reversible exchange
     @{" expr1 op:= expr2               " link aug_assign}  (augmented assignments)

     @{" expr1 ? expr2                  " link scan}  string scanning

     @{" expr1 &; expr2                 " link conjunction}  conjunction

@{i}Low Precedence Expressions:@{ui}

     @{" break [expr]                   " link break}  break from loop
     @{" case expr0 of {                " link case}  case selection
        expr1:expr2
        ...
        [default:exprn]
        }
     @{" create expr                    " link create}  co-expression creation
     @{" every expr1 [do expr2]         " link every}  iterate over generated values
     @{" fail                           " link fail}  failure of procedure
     @{" if expr1 then exp2 [else exp3] " link if}  if-then-else
     @{" next                           " link next}  go to top of loop
     @{" repeat expr                    " link repeat}  loop
     @{" return expr                    " link return}  return from procedure
     @{" suspend expr1 [do expr2]       " link suspend}  suspension of procedure
     @{" until expr1 [do expr2]         " link until}  until-loop
     @{" while expr1 [do expr2]         " link while}  while-loop

@endnode

@node positive
@{b}
	+N : N -- compute positive
@{ub}

	+N produces the numeric value of N.

@{i}See also: @{ui}@{" N1 + N2 " link sum}

@endnode

@node negative
@{b}
	-N : N -- compute negative
@{ub}

	-N produces the negative of N.

@{i}See also: @{ui}@{" N1 - N2 " link difference}

@endnode

@node complement
@{b}
	~c1 : c2 -- compute cset complement
@{ub}

	~c1 produces the cset complement of c1 with respect to &cset.
@endnode

@node tab_match
@{b}
	=s1 : s2 -- match string in scanning
@{ub}

	=s1 is equivalent to tab(match(s1)).

@{i}See also: @{ui}@{" match() " link match}, @{" tab() " link tab}, and @{" N1 = N2() " link num_eq}

@endnode

@node activate
@{b}
	@C : x -- activate co-expression
@{ub}

	@C produces the outcome of activating C.

@{i}See also: @{ui}@{" x @ C " link transmit}

@endnode

@node refresh
@{b}
	^C1 : C2 -- create refreshed co-expression
@{ub}

	^C1 produces a refreshed copy of C1.

@{i}See also: @{ui}@{" N1 ^ N2 " link exponential}

@endnode

@node size
@{b}
	*x : i -- compute size
@{ub}

	*x produces the size of x.

@{i}See also: @{ui}@{" N1 * N2 " link product}

@endnode

@node random
@{b}
	?x1 : x2 -- produce random value
@{ub}

	If x1 is an integer, ?x1 produces a number from a pseudo-random
	sequence. If x1 > 0, it produces an integer in the range 1 to x1,
	inclusive.  If x1 = 0, it produces a real number in the range
	0.0 to 1.0.

	If x1 is a string, ?x1 produces a randomly selected one-character
	substring of x1 that is a variable if x1 is a variable.

	If x1 is a list, table, or record, ?x1 produces a randomly selected
	element, which is a variable, from x1.

	If x1 is a set, ?x1 produces a randomly selected member of x1.

@{i}See also: @{ui}@{" s ? expr " link scan}

@endnode

@node values
@{b}
	!x1 : x2, x3, ..., xn -- generate values
@{ub}

	If x1 is a file, !x1 generates the remaining lines of x1.

	If x1 is a string, !x1 generates the one-character substrings of
	x1, and produces variables if x1 is a variable.

	If x1 is a list, table, or record, !x1 generates the elements,
	which are variables, of x1.  For lists and records, the order
	of generation is from the beginning to the end, but for tables
	it is unpredictable.

	If x1 is a set, !x1 generates the members of x1 in no predictable
	order.

@endnode

@node null
@{b}
	/x : x -- check for null value
@{ub}

	/x produces x if the value of x is the null value, but fails
	otherwise.  It produces a variable if x is a variable.

@{i}See also: @{ui}@{" N1 / N2 " link quotient}

@endnode

@node nonnull
@{b}
	\x : x -- check for non-null value
@{ub}

	\x produces x if the value of x is not the null value, but fails
	otherwise. If produces a variable if x is a variable.

@{i}See also: @{ui}@{" expr \ i " link limit}

@endnode

@node dereference
@{b}
	.x : x -- dereference variable
@{ub}

	.x produces the value of x.

@{i}See also: @{ui}@{" R.f " link field}

@endnode

@node sum
@{b}
	N1 + N2 : N3 -- compute sum
@{ub}

	N1 + N2 produces the sum of N1 and N2.

@{i}See also: @{ui}@{" +N " link positive}

@endnode

@node difference
@{b}
	N1 - N2 : N3 -- compute difference
@{ub}

	N1 - N2 produces the difference of N1 and N2.

@{i}See also: @{ui}@{" -N " link negative}

@endnode

@node product
@{b}
	N1 * N2 : N3 -- compute product
@{ub}

	N1 * N2 produces the product of N1 and N2.

@{i}See also: @{ui}@{" *N " link size}

@endnode

@node quotient
@{b}
	N1 / N2 : N3 -- compute quotient
@{ub}

	N1 / N2 produces the quotient of N1 and N2.

@{i}See also: @{ui}@{" /x " link null}

@endnode

@node remainder
@{b}
	N1 % N2 : N3 -- compute remainder
@{ub}

	N1 % N2 produces the remainder of N1 divided by N2.
	The sign of the result is the sign of N1.

@endnode

@node exponential
@{b}
	N1 ^ N2 : N3 -- compute exponential
@{ub}

	N1 ^ N2 produces N1 raised to the power N2.

@{i}See also: @{ui}@{" ^N " link refresh}, @{" exp() " link exp}, and @{" sqrt() " link sqrt}

@endnode

@node union
@{b}
	x1 ++ x2 : x3 -- compute cset or set union
@{ub}

	x1 ++ x2 produces the cset or set union of x1 and x2.

@endnode

@node set_difference
@{b}
	x1 -- x2 : x3 -- compute cset or set difference
@{ub}

	x1 -- x2 produces the cset or set difference of x1 and x2.

@endnode

@node intersection
@{b}
	x1 ** x2 : x3 -- compute cset or set intersection
@{ub}

	x1 ** x2 produces the cset or set intersection of x1 and x2.

@endnode

@node concatenation
@{b}
	s1 || s2 : s3 -- concatenate strings
@{ub}

	s1 || s2 produces a string consisting of s1 followed by s2.

@{i}See also: @{ui}@{" L1 ||| L2 " link list_concatenation}

@endnode

@node list_concatenation
@{b}
	L1 ||| L2 : L3 -- concatenate lists
@{ub}

	L1 ||| L2 produces a list consisting of the values in L1 followed by
	the values in L2.

@{i}See also: @{ui}@{" s1 || s2 " link concatenation}

@endnode

@node field
@{b}
	R.f : x -- get field of record
@{ub}

	R.f produces a variable for the f field of record R.

@{i}See also: @{ui}@{" .x " link dereference}

@endnode

@node transmit
@{b}
	x1 @ C : x2 -- transmit value to co-expression
@{ub}

	x1 @ C activates C, transmitting the value of x1 to it;
	it produces the outcome of activating C.

@{i}See also: @{ui}@{" @C " link activate}

@endnode

@node conjunction
@{b}
	x1 & x2 : x2 -- evaluate in conjunction
@{ub}

	x1 & x2 produces x2.  It produces a variable if x2 is a variable.

@endnode

@node num_gt
@{b}
	N1 > N2 : N2 -- compare numerically
@{ub}

	N1 > N2 produces N2 if N1 is numerically greater than N2, but fails otherwise.

@{i}See also: @{ui}@{" N1 >= N2 ", link num_ge}, @{" N1 = N2 " link num_eq}, @{" N1 <= N2 " link num_le}, @{" N1 < N2 " link num_lt}, and @{" N1 ~= N2 " link num_ne}

@endnode

@node num_ge
@{b}
	N1 >= N2 : N2 -- compare numerically
@{ub}

	N1 >= N2 produces N2 if N1 is numerically greater than or equal to
	N2, but fails otherwise.

@{i}See also: @{ui}@{" N1 > N2 " link num_gt}, @{" N1 = N2 " link num_eq}, @{" N1 <= N2 " link num_le}, @{" N1 < N2 " link num_lt}, and @{" N1 ~= N2 " link num_ne}

@endnode

@node num_eq
@{b}
	N1 = N2 : N2 -- compare numerically
@{ub}

	N1 = N2 produces N2 if N1 is numerically equal to N2, but fails otherwise.

@{i}See also: @{ui}@{" N1 > N2 " link num_gt}, @{" N1 >= N2 " link num_ge}, @{" N1 <= N2 " link num_le}, @{" N1 < N2 " link num_lt}, and @{" N1 ~= N2 " link num_ne}

@endnode

@node num_le
@{b}
	N1 <= N2 : N2 -- compare numerically
@{ub}

	N1 <= N2 produces N2 if N1 is numerically less than or equal to
	N2, but fails otherwise.

@{i}See also: @{ui}@{" N1 > N2 " link num_gt}, @{" N1 >= N2 " link num_ge}, @{" N1 = N2 " link num_eq}, @{" N1 < N2 " link num_lt}, and @{" N1~= N2 " link num_ne}

@endnode

@node num_lt
@{b}
	N1 < N2 : N2 -- compare numerically
@{ub}

	N1 < N2 produces N2 if N1 is numerically less than N2, but fails
        otherwise.

@{i}See also: @{ui}@{" N1 > N2 " link num_gt}, @{" N1 >= N2 " link num_ge}, @{" N1 = N2 " link num_eq}, @{" N1 <= N2 " link num_le}, and @{" N1~= N2 " link num_ne}

@endnode

@node num_ne
@{b}
	N1 ~= N2 : N2 -- compare numerically
@{ub}

	N1 ~= N2 produces N2 if N1 is not numerically equal to N2, but
	fails otherwise.

@{i}See also: @{ui}@{" N1 > N2 " link num_gt}, @{" N1 >= N2 " link num_ge}, @{" N1 = N2 ", link num_eq}, @{" N1 <= N2 " link num_le}, and @{" N1 < N2 " link num_lt}

@endnode

@node str_gt
@{b}
	s1 >> s2 : s2 -- compare lexically
@{ub}

	s1 >> s2 produces s2 if s1 is lexically greater than s2,
	but fails otherwise.

@{i}See also: @{ui}@{" s1 >>= s2 " link str_ge}, @{" s1 == s2 " link str_eq}, @{" s1 <<= s2 "link str_le}, @{" s1 << s2 " link str_lt}, and @{" s1 ~== s2 " link str_ne}

@endnode

@node str_ge
@{b}
	s1 >>= s2 : s2 -- compare lexically
@{ub}

	s1 >>= s2 produces s2 if s1 is lexically greater than or equal to
	s2, but fails otherwise.

@{i}See also: @{ui}@{" s1 >> s2 " link str_ge}, @{" s1 == s2 " link str_eq}, @{" s1 <<= s2 " link str_le}, @{" s1 << s2 " link str_lt}, and @{" s1 ~== s2 " link str_ne}

@endnode

@node str_eq
@{b}
	s1 == s2 : s2 -- compare lexically
@{ub}

	s1 == s2 produces s2 if s1 is lexically equal to s2, but fails
	otherwise.

@{i}See also: @{ui}@{" s1 >> s2 " link str_ge}, @{" s1 >>= s2 " link str_ge}, @{" s1 <<= s2 " link str_le}, @{" s1 << s2 " link str_lt}, and @{" s1 ~== s2 " link str_ne}

@endnode

@node str_le
@{b}
	s1 <<= s2 : s2 -- compare lexically
@{ub}

	s1 <<= s2 produces s2 if s1 is lexically less than or equal to
	s2, but fails otherwise.

@{i}See also: @{ui}@{" s1 >> s2 " link str_ge}, @{" s1 >>= s2 " link str_ge}, @{" s1 == s2 " link str_eq}, @{" s1 << s2 " link str_lt}, and @{" s1 ~== s2 " link str_ne}

@endnode

@node str_lt
@{b}
	s1 << s2 : s2 -- compare lexically
@{ub}

	s1 << s2 produces s2 if s1 is lexically less than s2, but fails
	otherwise.

@{i}See also: @{ui}@{" s1 >> s2 " link str_ge}, @{" s1 >>= s2 " link str_ge}, @{" s1 == s2 " link str_eq}, @{" s1 <<= s2 " link str_le}, and @{" s1 ~== s2 " link str_ne}

@endnode

@node str_ne
@{b}
	s1 ~== s2 : s2 -- compare lexically
@{ub}

	s1 ~== s2 produces s2 if s1 is not lexically equal to s2, but fails
	otherwise.

@{i}See also: @{ui}@{" s1 >> s2 " link str_ge}, @{" s1 >>= s2 " link str_ge}, @{" s1 == s2 " link str_eq}, @{" s1 <<= s2 " link str_le}, and @{" s1 << s2 " link str_lt}

@endnode

@node val_eq
@{b}
	s1 === s2 : s2 -- compare values
@{ub}

	x1 === x2 produces the value of x2 if x1 and x2 have the same value,
	but fails otherwise.

@{i}See also: @{ui}@{" x1 === x2 " link val_eq}

@endnode

@node val_ne
@{b}
	s1 ~=== s2 : s2 -- compare values
@{ub}

	x1 ~=== x2 produces the value of x2 if x1 and x2 do not have the same
	value, but fails otherwise.

@{i}See also: @{ui}@{" x1 ~=== x2 " link val_ne}

@endnode

@node assign
@{b}
	x1 := x2 : x1 -- assign value
@{ub}

	x1 := x2 assigns the value of x2 to x1 and produces the variable x1.

@{i}See also: @{ui}@{" x1 op:= x2 " link aug_assign}, @{" x1 :=: x2 " link exchange}, @{" x1 <- x2 " link rev_assign}, and @{" x1 <-> x2 " link rev_exchange}

@endnode

@node aug_assign
@{b}
	x1 op:= x2 : x1 -- augmented assignment
@{ub}

	x1 op:= x2 performs the operation x1 op x2 and assigns the 
	result to x1; it produces the variable x1.  There are augmented
	assignment operators for all infix operations except assignment
	operations.

@{i}See also: @{ui}@{" x1 := x2 " link assign}

@endnode

@node exchange
@{b}
	x1 :=: x2 : x1 -- exchange values
@{ub}

	x1 :=: x2 exchanges the values of x1 and x2 and produces the
	variable x1.

@{i}See also: @{ui}@{" x1 := x2 " link assign} and @{" x1 <-> x2 " link rev_exchange}

@endnode

@node rev_assign
@{b}
	x1 <- x2 : x1 -- assign value reversibly
@{ub}

	x1 <- x2 assigns the value of x2 to x1 and produces the variable
	x1.  It reverses the assignment if resumed.

@{i}See also: @{ui}@{" x1 := x2 " link assign} and @{" x1 <-> x2 " link rev_exchange}

@endnode

@node rev_exchange
@{b}
	x1 <-> x2 : x1 -- exchange values reversibly
@{ub}

	x1 <-> x2 exchanges the values of x1 and x2 and produces the
	variable x1.  It reverses the assignment if resumed.

@{i}See also: @{ui}@{" x1 <- x2 " link rev_assign} and @{" x1 :=: x2 " link exchange}

@endnode

@node to_by
@{b}
	i1 to i2 by i3 : i1, ..., in -- generate integers in sequence
@{ub}

	i1 to i2 by i3 generates the sequence of integers from i1 to i2
	in increments of i3.

	Default:
	i3  1 if by clause omitted

@{i}See also: @{ui}@{" seq() " link seq}

@endnode

@node create_list">
@{b}
	[x1, x2, ..., xn] : L -- create list
@{ub}

	[x1, x2, ..., xn] produces a list containing the values
	 x1, x2, ..., xn. [] produces an empty list.

@{i}See also: @{ui}@{" list() " link list}

@endnode

@node subscript
@{b}
	x1[x2] : x3 -- subscript
@{ub}

	If x1 is a string, x[x2] produces a one-character string
	consisting of character x2 of x1.  x1[x2] fails if x2 is out
	of range.  x1[x2] produces a variable if x1 is a variable.

	If x1 is a list, x1[x2] produces element x2 of x1.

	If x1 is a record, x1[x2] produces a field of x1 according to x2:
	if x2 is an integer, the x2th field is produced; if x2 is a
	string, the field named by the value of x2 is produced.

	If x1 is a table, x1[x2] produces the element corresponding to
	key x2 of x1.

	In all cases, x2 may be nonpositive.

	In all cases, the subscripting operation fails if the subscript
	is out of range.

@{i}See also: @{ui}@{" x[i1:i2] " link section}, @{" x[i1+:i2] " link section_plus}, and @{" x[i1-:i2] " link section_minus}

@endnode

@node section
@{b}
	x1[i1:i2] : x2 -- produce substring or list section
@{ub}

	If x1 is a string, x1[i1:i2] produces the substring of x1 between
	i1 and i2. x1[i1:i2] produces a variable if x1 is a variable.

	If x1 is a list, x1[i1:i2] produces a list consisting of the
	values of x1 in the given range.

	In either case, i1 and i2 may be nonpositive.

	In either case, the subscripting operation fails if a subscript
	is out of range.

@{i}See also: @{ui}@{" x[i] " link subscript}, @{" x[i1+:i2] " link section_plus}, and @{" x[i1-:i2] " link section_minus}

@endnode

@node section_plus
@{b}
	x1[i1+:i2] : x2 -- produce substring or list section
@{ub}

	If x1 is a string, x1[i1+:i2] produces the substring of x1
	between i1 and i1 + i2. x1[i1+:i2] produces a variable if x1
	is a variable.

	If x1 is a list, x1[i1+:i2] produces a list consisting of the 
	values of x1 in the given range.

	In either case, i1 and i2 may be nonpositive.

	In either case, the subscripting operation fails if a subscript
	is out of range.

@{i}See also: @{ui}@{" x[i] " link subscript}, @{" x[i1:i2] " link section}, and @{" x[i1-:i2] " link section_minus}

@endnode

@node section_minus
@{b}
	x1[i1-:i2] : x2 -- produce substring or list section
@{ub}

	If x1 is a string, x1[i1-:i2] produces the substring of x1
	between i1 and i1 - i2.  x1[i1-:i2] produces a variable if x1
        is a variable.

	If x1 is a list, x1[i1-:i2] produces a list consisting of the
	values of x1 in the given range.

	In either case, i1 and i2 may be nonpositive.

	In either case, the subscripting operation fails if a subscript
	is out of range.

@{i}See also: @{ui}@{" x[i] " link subscript}, @{" x[i1:i2] " link section}, and @{" x[i1+:i2] " link section_plus}

@endnode

@node invoke
@{b}
	x(x1, x2, ..., xn) : xm -- process argument list
@{ub}

	If x is a function or procedure, x(x1, x2, ..., xn) produces
	the outcome of calling x with arguments x1, x2, ..., xn.

	If x is an integer, x(x1, x2, ..., xn) produces the outcome of
	xi, but fails if i is out of the range 1, ..., n.  In this case,
	it produces a variable if xi is a variable; i may be nonpositive.

@{i}See also: @{ui}@{" x!L " link invoke_list}

@endnode

@node invoke_list
@{b}
	x!L -- process argument list
@{ub}

	If x is a function or procedure, x!L produces the outcome of
	calling x with the arguments in the list L.  If x is an integer,
	x!L produces L[x] but fails if x is out of range of L.

@{i}See also: @{ui}@{" x(...) " link invoke}

@endnode

@node invoke_coexpr
@{b}
	x{x1, x2, ..., xn} : xm -- process argument list as co-expressions
@{ub}

	x{x1, x2, ..., xn} is equivalent to
        x([create x1, create x2, ... create xn]).

@{i}See also: @{ui}@{" x(...) " link invoke}, @{" create expr " link create}

@endnode

@node break
@{b}
	break @{i}expr@{ui} : x -- break out of loop
@{ub}

	break @{i}expr @{ui}exits from the enclosing loop and produces the outcome
	of @{i}expr@{ui}.

	Default:
	@{i}expr @{ui}&null

@{i}See also: @{ui}@{" next " link next}

@endnode

@node case
@{b}
	case @{i}expr @{ui}of {...} : x -- select according to value
@{ub}

	case @{i}expr @{ui}of {...} produces the outcome of the @{b}case@{ub}
	clause that is selected by the value of @{i}expr@{ui}.

@endnode

@node create
@{b}
	create @{i}expr @{ui}: C -- select according to value


	create @{i}expr @{ui}produces a co-expression for @{i}expr@{ui}.

@endnode

@node every
@{b}
	every @{i}expr1 @{ui}do @{i}expr2 @{ui}-- generate every result
@{ub}

	every @{i}expr1 @{ui}do @{i}expr2 @{ui}evaluates @{i}expr2 @{ui}for each
	result generated by @{i}expr1@{ui}; it fails when @{i}expr1 @{ui}does
	not produce a result.  The @{b}do@{ub} clause is optional.

@endnode

@node fail
@{b}
	fail -- fail from procedure
@{ub}

	fail returns from the current procedure, causing the call to fail.

@endnode

@node if
@{b}
	if @{i}expr1 @{ui}then @{i}expr2 @{ui}else @{i}expr3 @{ui}: x -- select according to outcome
@{ub}

	if @{i}expr1 @{ui}then @{i}expr2 @{ui}else @{i}expr3 @{ui}produces the
	outcome of @{i}expr2 @{ui}if @{i}expr1 @{ui}succeeds, otherwise the outcome
	of @{i}expr3@{ui}.  The @{b}else@{ub} clause is optional.

@endnode

@node next
@{b}
	next -- go to beginning of loop
@{ub}

	next transfers control to the beginning of the enclosing loop.

@endnode

@node not
@{b}
	not @{i}expr @{ui}: n -- invert failure
@{ub}

	not @{i}expr @{ui}produces the null value if @{i}expr @{ui}fails,
	but fails if @{i}expr @{ui}succeeds.

@endnode

@node repeat
@{b}
	repeat @{i}expr @{ui}-- evaluate repeatedly
@{ub}

	repeat @{i}expr @{ui}evaluates @{i}expr @{ui}repeatedly.

@endnode

@node return
@{b}
	return @{i}expr @{ui}-- return from procedure
@{ub}

	return @{i}expr @{ui}returns from the current procedure, producing the
	outcome of @{i}expr@{ui}.

@endnode

@node suspend
@{b}
	suspend @{i}expr1 @{ui}do @{i}expr2 @{ui}-- suspend from procedure
@{ub}

	suspend @{i}expr1 @{ui}do @{i}expr2 @{ui}suspends from the current procedure,
	producing each result generated by @{i}expr1@{ui}.  If suspend is resumed,
	@{i}expr2 @{ui}is evaluated before resuming @{i}expr1@{ui}.
	The @{b}do@{ub} clause is optional.

@endnode

@node until
@{b}
	until @{i}expr1 @{ui}do @{i}expr2 @{ui}-- loop until result
@{ub}

	until @{i}expr1 @{ui}do @{i}expr2 @{ui}evaluates @{i}expr2 @{ui}each
	time @{i}expr1 @{ui}fails; it fails when @{i}expr1 @{ui}succeeds.
	The @{b}do@{ub} clause is optional.

@endnode

@node while
@{b}
	while @{i}expr1 @{ui}do @{i}expr2 @{ui}-- loop while result
@{ub}

	while @{i}expr1 @{ui}do @{i}expr2 @{ui}evaluates @{i}expr2 @{ui}each
	time @{i}expr1 @{ui}succeeds; it fails when @{i}expr1 @{ui}fails.
	The @{b}do@{ub} clause is optional.

@endnode

@node alternate
@{b}
	@{i}expr1 @{ui}| @{i}expr2 @{ui}: x1, x2, ... -- evaluate alternatives
@{ub}

	@{i}expr1 @{ui}| @{i}expr2 @{ui}generates the results for @{i}expr1@{ui}
	followed by the results for @{i}expr2@{ui}.

@endnode

@node repeat_alternate
@{b}
	|@{i}expr @{ui}-- evaluate repeatedly
@{ub}

	|@{i}expr @{ui}generates the results for @{i}expr@{ui}
	repeatedly, terminating if @{i}expr @{ui}fails.

@endnode

@node limit
@{b}
	@{i}expr @{ui}\ i : x1, x2, ..., xi -- limit generator
@{ub}

	@{i}expr @{ui}\ i generates at most i results from the outcome for
	@{i}expr@{ui}.

@endnode

@node scan
@{b}
	x ? @{i}expr @{ui}: x -- scan string
@{ub}

	x ? @{i}expr @{ui}saves the current subject and position and then sets them to
	the values of x and 1, respectively.  It then evaluates @{i}expr@{ui}.  The
	outcome is the outcome of @{i}expr@{ui}.  The saved values of the subject and
	position are restored on exit from @{i}expr @{ui}.

@endnode

@node functions

	@{b} Functions and datatypes of arguments and produced values:@{ub}
 

@{" abs(N) : N                              " link abs}  compute absolute value
@{" acos(r1) : r2                           " link acos}  compute arc cosine
@{" any(c,s,i1,i2) : i3                     " link any}  locate initial character
@{" args(p) : i                             " link args}  get number of procedure arguments
@{" asin (r1) : r2                          " link asin}  compute arc sine
@{" atan (r1,r2) : r3                       " link atan}  compute arc tangent
@{" bal(c1,c2,c3,s,i1,i2) : i3,i4,...,in    " link bal}  locate balanced characters
@{" callout(x,x1,x2,...,xn) : xm            " link callout}  call external function
@{" center(s1,i,s2) : s3                    " link center}  position string at center
@{" char(i) : s                             " link char}  produce character
@{" chdir(s) : n                            " link chdir}  change directory
@{" close(f) : f                            " link close}  close file
@{" collect(i1,i2) : n                      " link collect}  perform garbage collection
@{" copy(x1) : x2                           " link copy}  copy value
@{" cos(r1) : r2                            " link cos}  compute cosine
@{" cset(x)                                 " link cset}  convert to cset
@{" delay(i) : n                            " link delay}  delay execution
@{" delete(X,x) : X                         " link delete}  delete element
@{" detab(s1,i1,i2,...,in) : s2             " link detab}  remove tabs
@{" display(i,f) : n                        " link display}  display variables
@{" dtor(r1) : r2                           " link dtor}  convert degrees to radians
@{" entab(s1,i1,i2,...,in) : s2             " link entab}  insert tabs
@{" errorclear() : n                        " link errorclear}  clear error indication
@{" exit(i)                                 " link exit}  exit program
@{" exp(r1) : r2                            " link exp}  compute exponential
@{" find(s1,s2,i1,i2) : i3,i4,...,in        " link find}  find string
@{" flush(f) : n                            " link flush}  flush I/O buffer
@{" function() : s1,s2,...,sn               " link function}  generate function names
@{" get(L) : x                              " link get}  get value from list
@{" getch() : s                             " link getch}  get keyboard character
@{" getche() : s                            " link getche}  get and echo keyboard character
@{" getenv(s1) : s2                         " link getenv}  get value of environment variable
@{" iand(i1,i2) : i3                        " link iand}  compute bit-wise @{i}and @{ui}
@{" icom(i1) : i2                           " link icom}  compute bit-wise complement
@{" image(x) : s                            " link image}  produce string image
@{" insert(X,x1,x2) : X                     " link insert}  insert element
@{" integer(x) : i                          " link integer}  convert to integer
@{" ior(i1,i2) : i3                         " link ior}  compute bit-wise inclusive @{i}or @{ui}
@{" ishift(i1,i2) : i3                      " link ishift}  shift bits
@{" ixor(i1,i2) : i3                        " link ixor}  compute bit-wise exclusive @{i}or @{ui}
@{" kbhit() : n                             " link kbhit}  check for keyboard character
@{" key(T) : x1,x2,...,xn                   " link key}  generate keys from table
@{" left(s1,i,s2) : s3                      " link left}  position string at left
@{" list(i,x) : L                           " link list}  create list
@{" loadfunc (s1,s2) : p                    " link loadfunc}  load external function
@{" log(r1,r2) : r3                         " link log}  compute logarithm
@{" many(c,s,i1,i2) : i3                    " link many}  locate many characters
@{" map(s1,s2,s3) : s4                      " link map}  map characters
@{" match(s1,s2,i1,i2) : i3                 " link match}  match initial string
@{" member(X,x) : x                         " link member}  test for membership
@{" move(i) : s                             " link move}  move scanning position
@{" name(x) : s                             " link name}  produce name
@{" numeric(x) : N                          " link numeric}  convert to numeric
@{" open(s1,s2) : f                         " link open}  open file
@{" ord(s) : i                              " link ord}  produce ordinal
@{" pop(L) : x                              " link pop}  pop from list
@{" pos(i1) : i2                            " link pos}  test scanning position
@{" proc(x,i) : p                           " link proc}  convert to procedure
@{" pull(L) : x                             " link pull}  pull from list
@{" push(L,x1,x2,...,xn) : L                " link push}  push onto list
@{" put(L,x1,x2,...,xn) : L                 " link put}  put onto list
@{" read(f) : s                             " link read}  read line
@{" reads(f,i) : s                          " link reads}  read string
@{" real(x) : r                             " link real}  convert to real
@{" remove(s) : n                           " link remove}  remove file
@{" rename(s1,s2) : n                       " link rename}  rename file
@{" repl(s1,i) : s2                         " link repl}  replicate string
@{" reverse(s1) : s2                        " link reverse}  reverse string
@{" right(s1,i,s2) : s3                     " link right}  position string at right
@{" rtod(r1) : r2                           " link rtod}  convert radians to degrees
@{" runerr(i,x)                             " link runerr}  terminate with run-time error
@{" save(s) : i                             " link save}  save executable image
@{" seek(f,i) : f                           " link seek}  seek to position in file
@{" seq(i1,i2) : i3,i4,...                  " link seq}  generate sequence of integers
@{" set(L) : S                              " link set}  create set
@{" sin(r1) : r2                            " link sin}  compute sine
@{" sort(X,i) : L                           " link sort}  sort structure
@{" sortf(X,i) : L                          " link sortf}  sort list or set by field
@{" sqrt(r1) : r2                           " link sqrt}  compute square root
@{" stop(x1,x2,...,xn)                      " link stop}  stop execution
@{" string(x) : s                           " link string}  convert to string
@{" system(s) : i                           " link system}  call system function
@{" tab(i) : s                              " link tab}  set scanning position
@{" table(x) : T                            " link table}  create table
@{" tan(r1) : r2                            " link tan}  compute tangent
@{" trim(s1,c) : s2                         " link trim}  trim string
@{" type(x) : s                             " link type}  produce type name
@{" upto(c,s,i1,i2) : i3,i4,...,in          " link upto}  locate characters
@{" variable(s) : x                         " link variable}  produce variable
@{" where(f) : i                            " link where}  produce position in file
@{" write(x1,x2,...,xn) : xn                " link write}  write line
@{" writes(x1,x2,...,xn)                    " link writes}  write string

@endnode

@node abs
@{b}
	abs (N) : N  -- compute absolute value
@{ub}

	Produces the absolute value of N.

@endnode

@node acos
@{b}
	acos (r1) : r2 -- compute arc cosine
@{ub}

	Produces the arc cosine of r1 in the range of 0 to pi for r1 in the
	range of -1 to 1.

@{i}See also: @{ui}@{" cos() " link cos}

@endnode

@node any
@{b}
	any (c,s,i1,i2) : i3 -- locate initial character
@{ub}

	Succeeds and produces i1 + 1 if s[i1] is in c and i2 > i1, but fails
	otherwise.

	Defaults:
	s       &subject
	i1      &pos if s defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" many() " link many} and @{" match() " link match}

@endnode

@node args
@{b}
	args (p) : i -- get number of procedure arguments
@{ub}

	Produces the number of arguments for procedure p.  For built-in
	procedures with a variable number of arguments, the value produced is
	-1.  For declared procedures with a variable number of arguments, the
	value returned is the negative of the number of formal parameters.

@{i}See also: @{ui}@{" proc() " link proc}

@endnode

@node asin
@{b}
	asin (r1) : r2 -- compute arc sine
@{ub}

	Produces the arc sine of r1 in the range of -pi/2 to +pi/2 for r1 in
	the range of -1 to 1.

@{i}See also: @{ui}@{" sin() " link sin}

@endnode

@node atan
@{b}
	atan (r1,r2) : r3 -- compute arc tangent
@{ub}

	Produces the arc tangent of r1/r2 in the range -pi/2 to pi/2 with the
	sign of r1.


	Default:
	r2      1.0

@{i}See also: @{ui}@{" tan() " link tan}

@endnode

@node bal
@{b}
	bal (c1,c2,c3,s,i1,i2) : i3,i4,...,in -- locate balanced characters
@{ub}

	Generates the sequence of integer positions in s preceding a character
	of c1 in s[i1:i2] that is balanced with respect to the characters of c2
	and c3, but fails if there is no such position.


	Defaults:
	c1      &cset
	c2      '('
	c3      ')'
	s       &subject
	i1      &pos if s defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" find() " link find} and @{" upto() " link upto}

@endnode

@node callout
@{b}
	callout (x,x1,x2,...,xn) : xm -- call external function
@{ub}

	Calls the external function specified by x with arguments x1, x2, ...,
	xn.  The mechanism for locating the function specified by x is system
	dependent.

@endnode

@node center
@{b}
	center (s1,i,s2) : s3 -- position string at center
@{ub}

	Produces a string of size i in which s1 is centered, with s2 used for
	padding at left and right as necessary.


	Defaults:
	i       1
	s2      ' ' (blank)

@{i}See also: @{ui}@{" left() " link left} and @{" right() " link right}

@endnode

@node char
@{b}
	char (i) : s -- produce character
@{ub}

	Produces a string of length 1 consisting of the character whose
	internal representation is i.

@{i}See also: @{ui}@{" ord() " link ord}

@endnode
@node chdir
@{b}
	chdir (s) : n -- change directory
@{ub}

	Changes the directory to s but fails if there is no such directory
	or if the change cannot be made.

@endnode

@node close
@{b}
	close (f) : f -- close file
@{ub}

	Produces f after closing it unless f was opened with the pipe ("p")
	option, in which case the integer exit status of the command is
	returned.

@{i}See also: @{ui}@{" open() " link open}

@endnode

@node collect
@{b}
	collect (i1,i2) : n  -- perform garbage collection
@{ub}

	Causes a garbage collection in region i1, requesting i2 bytes of space
	in that region.  It fails if the requested space is not available. The
	regions are identified as follows:

                1               Static region
                2               String region
                3               Block region

	If i1 is 0, a collection is done, but no region is identified and i2
	has no effect.  The value of i2 is ignored for the static region.


	Defaults:
	i1      0
	i2      0

@endnode

@node copy
@{b}
	copy (x1) : x2 -- copy value
@{ub}

	Produces a copy of x1 if x1 is a structure; otherwise it produces x1.

@endnode

@node cos
@{b}
	cos (r1) : r2 -- compute cosine
@{ub}

	Produces the cosine of r1 in radians.

@{i}See also: @{ui}@{" acos() " link acos}

@endnode

@node cset
@{b}
	cset (x) -- convert to cset
@{ub}

	Produces a cset resulting from converting x, but fails if the
	conversion is not possible.

@endnode

@node delay
@{b}
	delay (i) : n -- delay execution
@{ub}

	Delays execution i milliseconds.

@endnode

@node delete
@{b}
	delete (X,x) : X -- delete element
@{ub}

	If X is a set, deletes x from X.  If X is a table, deletes the element
	for key x from X.  Produces X.

@{i}See also: @{ui}@{" insert() " link insert} and @{" member() " link member}

@endnode

@node detab
@{b}
	detab (s1,i1,i2,...,in) : s2 -- remove tabs
@{ub}

	Produces a string based on s1 in which each tab character is replaced
	by one or more blanks.  Tab stops are at i1, i2, ..., in, with
	additional stops obtained by repeating the last interval.


	Default:
	i1      9

@{i}See also: @{ui}@{" entab() " link entab}

@endnode

@node display
@{b}
	display (i,f) : n -- display variables
@{ub}

	Writes the image of the current co-expression and the values of the
	local variables in the current procedure call.  If i > 0, the local
	variables in the i preceding procedure calls are displayed as well.
	After all local variables are displayed, the values of global variables
	are displayed.  Output is written to f.


	Defaults:
	i       &level
	f       &errout

@endnode

@node dtor
@{b}
	dtor (r1) : r2 -- convert degrees to radians
@{ub}

	Produces the radian equivalent of r1 given in degrees.

@{i}See also: @{ui}@{" rtod() " link rtod}

@endnode

@node entab
@{b}
	entab (s1,i1,i2,...,in) : s2 -- insert tabs
@{ub}

	Produces a string based on s1 in which runs of blanks are replaced by
	tabs.  Tab stops are at i1, i2, ..., in, with additional stops obtained
	by repeating the last interval.


	Default:
	i1      9

@{i}See also: @{ui}@{" detab() " link detab}

@endnode

@node errorclear
@{b}
	errorclear () : n -- clear error indication
@{ub}

	Clears the indications of the last error.

@{i}See also: @{ui}@{" &error() " link keywords}

@endnode

@node exit
@{b}
	exit (i) -- exit program
@{ub}

	Terminates the program with exit status i.


	Default:
	i       normal exit (system dependent)

@{i}See also: @{ui}@{" stop() " link stop}

@endnode

@node exp
@{b}
	exp (r1) : r2 -- compute exponential
@{ub}

	Produces e raised to the power r1.

@{i}See also: @{ui}@{" log() " link log} and  @{" N1 ^ N2 " link exponential}

@endnode

@node find
@{b}
	find (s1,s2,i1,i2) : i3,i4,...,in -- find string
@{ub}

	Generates the sequence of integer positions in s2 at which s1 occurs as
	a substring in s2[i1:i2], but fails if there is no such position.


	Defaults:
	s2      &subject
	i1      &pos if s2 defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" bal() " link bal},  @{" match() " link match}, and  @{" upto() " link upto}

@endnode

@node flush
@{b}
	flush (f) : n -- flush I/O buffer
@{ub}

	Flushes the output buffers for f.

@endnode

@node function
@{b}
	function () : s1,s2,...,sn -- generate function names
@{ub}

	Generates the names of the Icon (built-in) functions.

@endnode

@node get
@{b}
	get (L) : x  -- get value from list
@{ub}

	Produces the leftmost element of L and removes it from L, but fails if
	L is empty; synonym for pop(L).

@{i}See also: @{ui}@{" pop() " link pop},  @{" pull() " link pull},  @{" push() " link push}, and  @{" put() " link put}

@endnode

@node getch
@{b}
	getch () : s  -- get keyboard character
@{ub}

	Waits until a character has been entered from the keyboard and then produces
	the corresponding one-character string. The character is not displayed.
	The function fails on an end of file.

@{i}See also: @{ui}@{" getche() " link getche} and  @{" kbhit() " link kbhit}

@endnode

@node getche
@{b}
	getche () : s  -- get and echo keyboard character
@{ub}

	Waits until a character has been entered from the keyboard and then produces
	the corresponding one-character string. The character is displayed.
	The function fails on an end of file.

@{i}See also: @{ui}@{" getch() " link getch} and  @{" kbhit() " link kbhit}

@endnode

@node getenv
@{b}
	getenv (s1) : s2 -- get value of environment variable
@{ub}

	Produces the value of environment variable s1, but fails if the
	variable is not set or environment variables are not supported.

@endnode

@node iand
@{b}
	iand (i1,i2) : i3 -- compute bit-wise @{i}and @{ui}
@{ub}

	Produces the bitwise @{i}and @{ui}of i1 and i2.

@{i}See also: @{ui}@{" icom() " link icom},  @{" ior() " link ior},  @{" ishift() " link ishift}, and  @{" ixor() " link ixor}

@endnode

@node icom
@{b}
	icom (i1) : i2 -- compute bit-wise complement
@{ub}

	Produces the bitwise complement (1's complement) of i1.

@{i}See also: @{ui}@{" iand() " link iand},  @{" ior() " link ior},  @{" ishift() " link ishift}, and  @{" ixor() " link ixor}

@endnode

@node image
@{b}
	image (x) : s -- produce string image
@{ub}

	Produces a string image of x.

@endnode

@node insert
@{b}
	insert (X,x1,x2) : X -- insert element
@{ub}

	If X is a table, inserts the key x1 with value x2 into X.  If X is a
	set, inserts x1 into X.  Produces X.


	Default:
	x2      &null

@{i}See also: @{ui}@{" delete() " link delete} and  @{" member() " link member}

@endnode

@node integer
@{b}
	integer (x) : i  -- convert to integer
@{ub}

	Produces the integer resulting from converting x, but fails if the
	conversion is not possible.

@{i}See also: @{ui}@{" numeric() " link numeric} and  @{" real() " link real}

@endnode

@node ior
@{b}
	ior (i1,i2) : i3 -- compute bit-wise inclusive @{i}or @{ui}
@{ub}

	Produces the bitwise inclusive @{i}or @{ui}of i1 and i2

@{i}See also: @{ui}@{" iand() " link iand},  @{" icom() " link icom},  @{" ishift() " link ishift}, and  @{" ixor() " link ixor}

@endnode

@node ishift
@{b}
	ishift (i1,i2) : i3  -- shift bits
@{ub}

	Produces the result of shifting the bits in i1 by i2 positions.
	Positive values of i2 shift to the left, negative to the right.
	Vacated bit positions are zero-filled.

@{i}See also: @{ui}@{" iand() " link iand},  @{" ior() " link ior},  @{" ior() " link ior}, and  @{" ixor() " link ixor}

@endnode

@node ixor
@{b}
	ixor (i1,i2) : i3 -- compute bit-wise exclusive @{i}or @{ui}
@{ub}

	Produces the bitwise exclusive @{i}or @{ui}of i1 and i2.

@{i}See also: @{ui}@{" iand() " link iand},  @{" icom() " link icom},  @{" ior() " link ior}, and  @{" ixor() " link ixor}

@endnode

@node kbhit
@{b}
	kbhit () : n -- check for keyboard character
@{ub}

	Succeeds if a character is available for getch() or getche() but fails
	otherwise.

@{i}See also: @{ui}@{" getch() " link getch} and  @{" getche() " link getche}

@endnode

@node key
@{b}
	key (T) : x1,x2,...,xn -- generate keys from table
@{ub}

	Generates the keys in table T.

@endnode

@node left
@{b}
	left (s1,i,s2) : s3  -- position string at left
@{ub}

	Produces a string of size i in which s1 is positioned at the left, with
	s2 used for padding on the right as necessary.


	Defaults:
	i       1
	s2      "" (blank)

@{i}See also: @{ui}@{" center() " link center} and  @{" right() " link right}

@endnode

@node list
@{b}
	list (i,x) : L -- create list
@{ub}

	Produces a list of size i in which each value is x.


	Defaults:
	i       0
	x       &null

@endnode

@node loadfunc
@{b}
	loadfunc (s1,s2) : p -- load external function
@{ub}

	Loads the function named s2 from the library file s1.  s2 must be a C or
	compatible function that provides a particular interface expected by
	loadfunc().

@endnode

@node log
@{b}
	log (r1,r2) : r3 -- compute logarithm
@{ub}

	Produces the logarithm of r1 to the base r2.


	Default:
	r2      e

@{i}See also: @{ui}@{" exp() " link exp}

@endnode

@node many
@{b}
	many (c,s,i1,i2) : i3 -- locate many characters
@{ub}

	Succeeds and produces the position in s after the longest initial sequence
	of characters in c in s[i1:i2].  It fails if s[i1] is not in c.


	Defaults:
	s       &subject
	i1      &pos if s defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" any() " link any} and  @{" match() " link match}

@endnode

@node map
@{b}
	map (s1,s2,s3) : s4  -- map characters
@{ub}

	Produces a string of size *s1 obtained by mapping characters of s1 that
	occur in s2 into corresponding characters in s3.


	Defaults:
	s2      string(&ucase)
	s3      string(&lcase)

@endnode

@node match
@{b}
	match (s1,s2,i1,i2) : i3 -- match initial string
@{ub}

	Produces i1 + *s1 if s1 == s2[i1+:*s1], but fails otherwise.


	Defaults:
	s2      &subject
	i1      &pos if s2 defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" =s " link tab_match},  @{" any() " link any}, and  @{" many() " link many}

@endnode

@node member
@{b}
	member (X,x) : x -- test for membership
@{ub}

	If X is a set, succeeds if x is a member of X, but fails otherwise.  If
	X is a table, succeeds if x is a key of an element in X, but fails
	otherwise.      Produces x if it succeeds.

@{i}See also: @{ui}@{" delete() " link delete} and  @{" insert() " link insert}

@endnode

@node move
@{b}
	move (i) : s -- move scanning position
@{ub}

	Produces &subject[&pos:&pos + i] and assigns i + &pos to &pos, but
	fails if i is out of range; reverses assignment to &pos if resumed.

@{i}See also: @{ui}@{" tab() " link tab}

@endnode

@node name
@{b}
	name (x) : s -- produce name
@{ub}

	Produces the name of the variable x.  If x is an identifier or a
	keyword that is a variable, the name of the identifier or keyword is
	produced.  If x is a record field reference, the record name and field
	name are produced with a separating period.  If x is a string, the name
	of the string and the subscript range are shown.  If x is a subscripted
	list or table, the type name followed by the subscripting expression is
	produced.

@{i}See also: @{ui}@{" variable() " link variable}

@endnode

@node numeric
@{b}
	numeric (x) : N  -- convert to numeric
@{ub}

	Produces an integer or real number resulting from converting x, but
	fails if the conversion is not possible.

@{i}See also: @{ui}@{" integer() " link integer} and  @{" real() " link real}

@endnode

@node open
@{b}
	open (s1,s2) : f -- open file
@{ub}

	Produces a file resulting from opening s1 according to options in s2,
	but fails if the file cannot be opened.  The options are:

        "r"   open for reading
        "w"   open for writing
        "a"   open for writing in append mode
        "b"   open for reading and writing
        "c"   create
        "t"   translate line termination sequences to linefeeds
        "u"   do not translate line termination sequences to linefeeds
        "p"   pipe to/from a command -- UNIX | AMIGA

	The default mode is to translate line termination sequences to
	linefeeds on input and conversely on output.  The untranslated mode
	should be used when reading and writing binary files.

	Default:
	s2      "rt";

@{i}See also: @{ui}@{" close() " link close}

@endnode

@node ord
@{b}
	ord (s) : i  -- produce ordinal
@{ub}

	Produces an integer (ordinal) between 0 and 255 that is the internal
	representation of the single character in s.

@{i}See also: @{ui}@{" char() " link char}

@endnode

@node pop
@{b}
	pop (L) : x -- pop from list
@{ub}

	Produces the leftmost element of L and removes it from L, but fails if L
	is empty; synonym for get(L). 

@{i}See also: @{ui}@{" get() " link get},  @{" pull() " link pull},  @{" push() " link push}, and  @{" put() " link put}

@endnode

@node pos
@{b}
	pos (i1) : i2 -- test scanning position 
@{ub}

	Produces &pos if &pos = i1, but fails otherwise. 

@{i}See also: @{ui}@{" &pos and &subject " link keywords}

@endnode

@node proc
@{b}
	proc (x,i) : p -- convert to procedure 
@{ub}

	Produces a procedure corresponding to the value of x, but fails if x does
	not correspond to a procedure. If x is the string name of an operator, i
	specifies the number of arguments: 1 for unary (prefix), 2 for binary (infix),
	and 3 for ternary. proc(x,0) produces the built-in function named x even
	if the global identifier having that name has been assigned another value.
	proc(x,0) fails if x is not the name of a function. 

	Default:
	i       1

@{i}See also: @{ui}@{" args() " link args}

@endnode

@node pull
@{b}
	pull (L) : x -- pull from list 
@{ub}

	Produces the rightmost element of L and removes it from L, but fails if
	L is empty. 

@{i}See also: @{ui}@{" get() " link get},  @{" pop() " link pop},  @{" push() " link push}, and  @{" put() " link put}

@endnode

@node push
@{b}
	push (L,x1,x2,...,xn) : L -- push onto list 
@{ub}

	Pushes x1, x2, ... onto the left end of L. Values are pushed in order from
	left to right, so xn becomes the first (leftmost) value on L. push(L) with
	no second argument pushes a null value onto L. 

@{i}See also: @{ui}@{" get() " link get},  @{" pop() " link pop},  @{" pull() " link pull}, and  @{" put() " link put}

@endnode

@node put
@{b}
	put (L,x1,x2,...,xn) : L -- put onto list 
@{ub}

	Puts x1, x2, ... onto the right end of L. Values are pushed in order from
	left to right, so xn becomes the last (rightmost) value on L. put(L) with
	no second argument puts a null value onto L. 

@{i}See also: @{ui}@{" get() " link get},  @{" pop() " link pop},  @{" pull() " link pull}, and  @{" push() " link push}

@endnode

@node read
@{b}
	read (f) : s -- read line 
@{ub}

	Produces the next line from f, but fails on end of file. 

	Default:
	f       &input

@{i}See also: @{ui}@{" reads() " link reads}

@endnode

@node reads
@{b}
	reads (f,i) : s -- read string 
@{ub}

	Produces a string consisting of the next i characters from f, or the remaining
	characters of f if fewer remain, but fails on an end of file. In reads(),
	unlike read(), line termination sequences have no special significance.
	reads() should be used for reading binary data. 

	Defaults:
	f       &input
	i       1

@{i}See also: @{ui}@{" read() " link read}

@endnode

@node real
@{b}
	real (x) : r -- convert to real 
@{ub}

	Produces a real number resulting from type conversion of x, but fails if
	the conversion is not possible. 

@{i}See also: @{ui}@{" integer() " link integer} and  @{" numeric() " link numeric}

@endnode

@node remove
@{b}
	remove (s) : n -- remove file 
@{ub}

	Removes (deletes) the file named s, but fails if s cannot be removed. 

@{i}See also: @{ui}@{" rename() " link rename}

@endnode

@node rename
@{b}
	rename (s1,s2) : n -- rename file 
@{ub}

	Renames the file named s1 to be s2, but fails if the renaming cannot be
	done. 

@{i}See also: @{ui}@{" remove() " link remove}

@endnode

@node repl
@{b}
	repl (s1,i) : s2 -- replicate string 
@{ub}

	Produces a string consisting of i concatenations of s1. 

@endnode

@node reverse
@{b}
	reverse (s1) : s2 -- reverse string 
@{ub}

	Produces a string consisting of the reversal of s. 

@endnode

@node right
@{b}
	right (s1,i,s2) : s3 -- position string at right 
@{ub}

	Produces a string of size i in which s1 is positioned at the right, with
	s2 used for padding on the left as necessary. 

	Defaults:
	i       1
	s2      " " (blank)

@{i}See also: @{ui}@{" center() " link center} and  @{" left() " link left}

@endnode

@node rtod
@{b}
	rtod (r1) : r2 -- convert radians to degrees 
@{ub}

	Produces the degree equivalent of r1 given in radians. 

@{i}See also: @{ui}@{" dtor() " link dtor}

@endnode

@node runerr
@{b}
	runerr (i,x) -- terminate with run-time error 
@{ub}

	Terminates program execution with error i and offending value x. 

	Default:
	x       no offending value</PRE>

@endnode

@node save
@{b}
	save (s) : i -- save executable image
@{ub}

	Saves an executable image of the current running program in the file
	named s and produces the size of the file, but fails if the file cannot
	be created.

@endnode

@node seek
@{b}
	seek (f,i) : f -- seek to position in file
@{ub}

	Seeks to position i in f, but fails if the seek cannot be performed.
	The first byte in the file is at position 1.  seek(f,0) seeks to the
	end of file f.

@{i}See also: @{ui}@{" where() " link where}

@endnode

@node seq
@{b}
	seq (i1,i2) : i3,i4,...  -- generate sequence of integers
@{ub}

	Generates an endless sequence of integers starting at i1 with
	increments of i2.

	Defaults:
	i1      1
	i2      1

@{i}See also: @{ui}@{" i1 to i2 by i3 " link to_by}

@endnode

@node set
@{b}
	set (L) : S  -- create set
@{ub}

	Produces a set whose members are the distinct values in the list L.

	Default:
	L       []

@endnode

@node sin
@{b}
	sin (r1) : r2 -- compute sine
@{ub}

	Produces the sine of r1 given in radians.

@{i}See also: @{ui}@{" asin() " link asin}

@endnode

@node sort
@{b}
	sort (X,i) : L -- sort structure
@{ub}

	Produces a list containing values from X.  If X is a list, record, or
	set, sort(X,i) produces the values of X in sorted order.  If X is a
	table, sort(X,i) produces a list obtained by sorting the elements of X,
	depending on the value of i.  For i = 1 or 2, the list elements are
	two-element lists of key/value pairs.  For i = 3 or 4, the list elements
	are alternating keys and values.  Sorting is by keys for i odd, by value
	for i even.

	Default:
	i       1

@{i}See also: @{ui}@{" sortf() " link sortf}

@endnode

@node sortf
@{b}
	sortf (X,i) : L  -- sort list or set by field
@{ub}

	Produces a sorted list of the values in X.      Sorting is primarily by
	type and in most respects is the same as with sort(X,i).  However,
	among lists and among records, two structures are ordered by comparing
	their ith fields.  i can be negative but not zero.      Two structures
	having the equal ith fields are ordered as they would be in regular
	sorting, but structures lacking an ith field appear before structures
	having them.

	Default:
	i       1

@{i}See also: @{ui}@{" sort() " link sort}

@endnode

@node sqrt
@{b}
	sqrt (r1) : r2 -- compute square root
@{ub}

	Produces the square root of r1.

@{i}See also: @{ui}@{" N1 ^ N2() " link exponential}

@endnode

@node stop
@{b}
	stop (x1,x2,...,xn)  -- stop execution
@{ub}

	Terminates program execution with an error status after writing strings
	x1,x2,...,xn.  If xi is a file, subsequent output is to xi.  Initial
	output is to standard error output.

	Default:
	xi      "" (empty string)

@{i}See also: @{ui}@{" exit() " link exit} and  @{" write() " link write}

@endnode

@node string
@{b}
	string (x) : s -- convert to string
@{ub}

	Produces a string resulting from converting x, but fails if the
	conversion is not possible.

@endnode

@node system
@{b}
	system (s) : i -- call system function
@{ub}

	Calls the C library function @{i}system() @{ui}to execute s and produces the
	resulting integer exit status.

@endnode

@node tab
@{b}
	tab (i) : s  -- set scanning position
@{ub}

	Produces &subject[&pos:i] and assigns i to &pos, but fails if i is out
	of range.  It reverses assignment to &pos if resumed.

@{i}See also: @{ui}@{" move() " link move}

@endnode

@node table
@{b}
	table (x) : T -- create table
@{ub}

	Produces a table with a default value x.

	Default:
	x       &null

@endnode

@node tan
@{b}
	tan (r1) : r2 -- compute tangent
@{ub}

	Produces the tangent of r1 given in radians.

@{i}See also: @{ui}@{" atan() " link atan}

@endnode

@node trim
@{b}
	trim (s1,c) : s2 -- trim string
@{ub}

	Produces a string consisting of the characters of s1 up to the trailing
	characters contained in c.

	Default:
	c       ' ' (blank)

@endnode

@node type
@{b}
	type (x) : s -- produce type name
@{ub}

	Produces a string corresponding to the type of x.

@endnode

@node upto
@{b}
	upto (c,s,i1,i2) : i3,i4,...,in  -- locate characters
@{ub}

	Generates the sequence of integer positions in s preceding a character
	of c in s[i1:i2].  It fails if there is no such position.

	Defaults:
	s       &subject
	i1      &pos if s defaulted, otherwise 1
	i2      0

@{i}See also: @{ui}@{" bal() " link bal} and  @{" find() " link find}

@endnode

@node variable
@{b}
	variable (s) : x -- produce variable
@{ub}

	Produces the variable for the identifier or keyword named s, but fails
	if there is no such variable.  Local identifiers override global
	identifiers.

@{i}See also: @{ui}@{" name() " link name}

@endnode

@node where
@{b}
	where (f) : i -- produce position in file
@{ub}

	Produces the current byte position in f.  The first byte in the file is
	at position 1.

@{i}See also: @{ui}@{" seek() " link seek}

@endnode

@node write
@{b}
	write (x1,x2,...,xn) : xn -- write line
@{ub}

	Writes strings x1,x2,...,xn with a line termination sequence added at
	the end.  If xi is a file, subsequent output is to xi.  Initial output
	is to standard output.

	Default:
	xi      "" (empty string)

@{i}See also: @{ui}@{" writes() " link writes}

@endnode

@node writes
@{b}
	writes (x1,x2,...,xn) -- write string
@{ub}

	Writes strings x1,x2,...,xn without a line termination sequence added
	at the end.  If xi is a file, subsequent output is to xi.  Initial
	output is to standard output.

	Default:
	xi      "" (empty string)

@{i}See also: @{ui}@{" write() " link write}

@endnode

@node operations

	@{b}Icon Programming Language Operations@{ub}


@{i}Prefix operations: @{ui}

	@{"  +N : N              " link positive}  compute positive
	@{"  -N : N              " link negative}  compute negative
	@{"  ~c1 : c2            " link complement}  compute cset complement
	@{"  =s1 : s2            " link tab_match}  match string in scanning
	@{"  @C : x              " link activate}  activate co-expression
	@{"  ^C1 : C2            " link refresh}  create refreshed co-expression
	@{"  *x : i              " link size}  compute size
	@{"  ?x1 : x2            " link random}  generate random value
	@{"  !x : x1,x2,...,xn   " link values}  generate values
	@{"  /x : x              " link null}  check for null value
	@{"  \x : x              " link nonnull}  check for non-null value
	@{"  .x : x              " link dereference}  dereference variable

@{i}Infix operations: @{ui}

	@{"  N1 + N2 : N3        " link sum}  compute sum
	@{"  N1 - N2 : N3        " link difference}  compute difference
	@{"  N1 * N2 : N3        " link product}  compute product
	@{"  N1 / N2 : N3        " link quotient}  compute quotient
	@{"  N1 % N2 : N3        " link remainder}  compute remainder
	@{"  N1 ^ N2 : N3        " link exponential}  compute exponential
	@{"  x1 ++ x2 : x3       " link union}  compute cset or set union
	@{"  x1 -- x2 : x3       " link set_difference}  compute cset or set difference
	@{"  x1 ** x2 : x3       " link intersection}  compute cset or set intersection
	@{"  s1 || s2 : s3       " link concatenation}  concatenate strings
	@{"  L1 ||| L2 : L3      " link list_concatenation}  concatenate lists
	@{"  R.F : x             " link field}  get field of record
	@{"  x1 @ C : x2         " link transmit}  transmission value to co-expression
	@{"  x1 & x2 : x2        " link conjunction}  evaluate in conjunction
	@{"  N1 < N2 : N2        " link num_lt}  compare numerically
	@{"  N1 <= N2 : N2       " link num_le}  compare numerically
	@{"  N1 = N2 : N2        " link num_eq}  compare numerically
	@{"  N1 >= N2 : N2       " link num_ge}  compare numerically
	@{"  N1 > N2 : N2        " link num_gt}  compare numerically
	@{"  N1 ~= N2 : N2       " link num_ne}  compare numerically
	@{"  s1 << s2 : s2       " link str_lt}  compare lexically
	@{"  s1 <<= s2 : s2      " link str_le}  compare lexically
	@{"  s1 == s2 : s2       " link str_eq}  compare lexically
	@{"  s1 >>= s2 : s2      " link str_ge}  compare lexically
	@{"  s1 >> s2 : s2       " link str_gt}  compare lexically
	@{"  s1 ~== s2 : s2      " link str_ne}  compare lexically
	@{"  x1 === x2 : x2      " link val_eq}  compare values
	@{"  x1 ~=== x2 : x2     " link val_ne}  compare values
	@{"  x1 := x2 : x1       " link assign}  assign value
	@{"  x1 op:= x2 : x1     " link aug_assign}  augmented assignment
	@{"  x1 :=: x2 : x1      " link exchange}  exchange values
	@{"  x1 <- x2 : x1       " link rev_assign}  assign value reversibly
	@{"  x1 <-> x2 : x1      " link rev_exchange}  exchange values reversibly


@endnode

@node keywords

	@{b}Icon Programming Language Keywords@{ub}


        &allocated : i1,i2,i3,i4    # accumulated bytes allocated
                                    # (total,static,string,block)
        &ascii : c                  # cset of ascii characters
        &clock : s                  # current time of day
        &collections : i1,i2,i3,i4  # collection count
                                    # (total,static,string,block)
        &cset : c                   # cset of all characters
        &current : C                # current co-expression
        &date : s                   # current date
        &dateline : s               # current date and time
        &digits : c                 # cset of digits 0-9
        &dump : i                   # if non-zero, causes dump on termination
        &e : r                      # base of natural logarithms, 2.71828...
        &error : i                  # run-time error conversion control
        &errornumber : i            # run-time error number
        &errortext : s              # run-time error message text
        &errorvalue : x             # run-time error offending value
        &errout : f                 # standard error output file
        &fail                       # fails
        &features : s1,s2,...,sn    # implementation features
        &file : s                   # current source code file name
        &host : s                   # string identifying host computer
        &input : f                  # standard input file
        &lcase : c                  # cset of lower case letters a-z
        &letters : c                # cset of all letters A-Za-z
        &level : i                  # level of current procedure call
        &line : i                   # current source code line number
        &main : C                   # main co-expression
        &null : n                   # the null value
        &output : f                 # standard output file
        &phi : r                    # The golden ratio, 1.61803...
        &pi : r                     # The value of pi, 3.14159...
        &pos : i                    # string scanning position
        &progname : s               # file name of the executing program
        &random : i                 # random number seed
        &regions : i1,i2,i3         # current region size
                                    # (static,string,block)
        &source : C                 # activator of current co-expression
        &storage : i1,i2,i3         # current bytes allocated
                                    # (static,string,block)
        &subject : s                # string scanning subject
        &time : i                   # current run time in milliseconds
        &trace : i                  # procedure tracing control
        &ucase : c                  # cset of upper case letters A-Z
        &version : s                # version of Icon

@endnode

@node datatypes

	@{b}Datatypes in the Icon Programming Language@{ub}

        null(n)         string(s)  co-expression(C)  table(T)
        integer(i)      cset(c)    procedure(p)      set(S)
        real(r)         file(f)    list(L)           @{i}record types@{ui}(R)

@{it}See also: @{ui} @{" Abbreviations " link abbreviations}

@endnode

@node reserved

	@{b}Reserved words in the Icon Programming Language@{ub}

        break    do     global  next       repeat   to
        by       else   if      not        return   until
        case     end    initial of         static   while
        create   every  link    procedure  suspend
        default  fail   local   record     then

@endnode

@node escapes

	@{b} Escapes in string and cset constants @{ub}

        \b      backspace               \v      vertical tab
        \d      delete(rubout)          \'      single quote
        \e      escape (altmode)        \&quot;      double quote
        \f      formfeed                \\      backslash
        \l      linefeed (newline)      \ddd    octal code
        \n      newline (linefeed)      \xdd    hexadecimal code
        \r      carriage return         \^c     control code
        \t      horizontal tab</PRE>

@endnode

@node abbreviations

	@{b} Abbreviations used in Icon help files (and other Icon literature)@{ub}

        c       cset            C       co-expression
        f       file            L       list
        i       integer         N       numeric (i or r)
        n       null            R       record (any record type)
        p       procedure       S       set
        r       real            T       table
        s       string          X       any structure type (L, R, S, or T)
        x       any type        F       field of record</PRE>

@endnode

@node about

	@{b}About the Icon Programming Language Reference Guide@{ub}

	These AmigaGuide reference pages were translated from HTML documents
	prepared by Bob Alexander.  They are based on material from the
	ProIcon reference manual, used by permission of the Bright Forest
	company.  Further information can be found in the following
	references:

	Griswold, Ralph E. and Madge T. Griswold.
	@{l}The Icon Programming Language, Second Edition,@{ul}
	Prentice-Hall, Inc., Englewood Cliffs, New Jersey.  1990.

	Griswold, Ralph  E., Clinton L. Jeffery, Gregg M. Townsend, and
	Kenneth Walker.
	@{l}Version 9.0 of the Icon Programming Language,@{ul}
	IPD236, Department of Computer Science, The University of Arizona.
	1994.

	Further information on the Icon Programming Language can be obtained
	from:

	http://www.cs.arizona.edu/icon/www/

	Department of Computer Science
	Gould-Simpson Building
	The University of Arizona
	Tucson, Arizona  85721
	U.S.A.

	(520) 621-6613
	e-mail: icon-project@cs.arizona.edu

@endnode
