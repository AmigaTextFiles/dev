Scheme In One Define.
 
The garbage collector, the name and other parts of this program are

 *                     COPYRIGHT (c) 1989 BY                              *
 *      PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.       *

Conversion  to  full scheme standard, characters, vectors, ports, complex &
rational numbers, and other major enhancments by

 *      Scaglione Ermanno, v. Pirinoli 16 IMPERIA P.M. 18100 ITALY        * 

Permission  to use, copy, modify, distribute and sell this software and its
documentation  for  any purpose and without fee is hereby granted, provided
that  the  above  copyright  notice appear in all copies and that both that
copyright   notice   and   this  permission  notice  appear  in  supporting
documentation,  and that the name of Paradigm Associates Inc not be used in
advertising or publicity pertaining to distribution of the software without
specific, written prior permission.

PARADIGM  DISCLAIMS  ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL  IMPLIED  WARRANTIES  OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
PARADIGM  BE  LIABLE  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


 Siod  is  an  interpreter for the algoritmic language SCHEME; the standard
followed  in  the  implementation  is  described  in  "TI  Scheme  Language
Reference  Manual"  and  follows  the  "Revised  Revised Report on Scheme".
Sorry  the  "Revised  3-rd  Report  on  Scheme"  is not available to me and
therefore I can not update Siod.

 Siod  is  a  pure  interpreter and no compilation is performed, and so the
evaluation,  especially  of  complex  procedures  is  very  slow even if it
requires only a small amount of memory to run.  Siod checks always the type
of  objects  before perform operation on them, the ispector allows the user
to  examine  the  contents of the stack frame and the environment in effect
when  an  error  or  a  breakpoint is entered and only a few procedures are
implemented  via  macro, so errors can be easily individuated even if there
isn't  a stack frame backtrace.  These features makes Siod an ideal tool to
learn  Scheme  and functional programming.  There isn't an esplicit control
of evaluation and therefore Siod requires a well dimensioned stack to work.
On  AMIGA  an  abnormal  termination  error  is  performed in case of stack
overflow.

 Other  major  problems on version 2.6:  Bignum isn't implemented, integers
are stored in a C-long until they overflows and then they are automatically
stored  in  a  C-double (numbers in siod are automatically stored in lowest
type  that  can  contain them with the minimum loss of information).  There
aren't  breakpoint  levels,  when an error occours the inspector is invoked
and  then  a  reset is performed.  Continuation aren't handled in the rigth
way  and  are implemented in term of the Common-LISP-like *throw and *catch
procedures,  and  so  they  hasn't an unlimited extent as prescribed by the
standard but are valid only inside the procedure invoked by call/cc.  Every
reset  reinitializes  the  *catch  list  and  every  *throw deletes all the
*catch's  that were set after the corrispondent one was.  Resets and errors
can   be  intercepted  by  the  user  via  the  non-standard  call-on-reset
procedure.     Currently    the    procedures    with-input-from-file   and
with-output-to-file  are  implemented using this mechanism and therefore if
you escape from the procedure using call/cc or *throw the file isn't closed
and  the  current  input  or  output isn't restored until the next reset or
error.   Siod  uses a fixed size heap and its performances depends on the C
stack.

 Siod's  memory  unit  is  called  cons  and is 10 bytes long, every scheme
object  is  contained  in a cons, and all the symbols with the same printed
representation  refers to the same cons (are interned).  The number of cons
available  to  Siod  cannot  be  changed  during the session due to a dirty
mechanism  of  garbage  collection, heritage of the original Paradigm code.
Siod  can  be  run  with  a  really  small  amount of memory to the cost of
frequent garbage collecting.  The discipline of garbage collecting followed
is  mark & sweep:  all the cons allocated are available in a singol heap to
the  user;  no  compaction  is  performed  but  this  isn't  a  problem  on
microcomputers.

 The options available to the user are:

        -h<number>   sets the number of cons in siod's
                     fixed-size heap.
                     Minimum 1000. Default 5000.
        -o<number>   sets the number of buckets in siod's
                     symbols hash table.
                     Minimum 1. Default 100.
        -f<number>   sets the number of buckets in siod's
                     integers hash table.
                     Minimum 1. Default 100.
        -i<filename> a file to be loaded in the high-speed
                     user-global-environment.
        -q           quiet flag.
        -s           small set of predefined functions.

 The  options  can be set also setting environment variables (using the DOS
command setenv):

SIOD-HEAP-SIZE  is equivalent to the -h option
SIOD-SYMTAB-SIZE  is equivalent to the -o option
SIOD-FIXTAB-SIZE  is equivalent to the -f option
SIOD-INIT-FILE  is equivalent to the -i option
SIOD-QUIET  if set to 1 is equivalent to the -q option
SIOD-SMALL  if set to 1 is equivalent to the -s option

 Options  settled  using  environment  variables are overrun by the options
specified in the command string.

 Symbols  with  the  same  printed  representation  are  stored at the same
address  using  a  hash table (symtab), the user-global-environment isn't a
proper environment but refers directly to the symbols contained in the hash
table,  for  this  reason  its  bindings cannot be showed even if it can be
accessed  by  the  procedures  like eval or load.  Provided there is a well
dimensioned  hash  table,  loading  or defining procedures directly in this
environment  can  increase greatly the speed of evaluation depending on the
number of procedures defined in the user-initial-environment.
 
  The  only  difference between integers and other numbers is that integers
are  interned,  so  two identical integers refers to the same heap cell and
therefore  can be compared using eq?.  This way each integer is stored only
once  saving  memory.   Also  identical  characters  are stored at the same
address  using  hash  tables.  The table for characters has 256 buckets and
can  contain all the characters of the extended ASCII code, therefore there
isn't any collision.  The size of the symtab and fixtab can be specified by
the  user;  collisions are handled with the chaining tecnique:  symbols and
integers  hashed  to the same bucket are stored into a linear list.  Tables
too  small  can reduce greately the speed of evaluation.  The procedure eq?
used  to  determine  if two objects are identical, gives always the correct
answer for interned objects.  Uninterned objects can be compared using eqv?
or  equal?.   NOTE:   integers  that  overflows the size of a C-long aren't
interned  and  cannot be compared with eq?  even if the integer?  predicate
returns true.

 The behaviour of the interpreter during the session is determined by three
variables that can be freely modified by the user:
   siod-debug-mode if set to #t cause the inspector to be invoked after an
                   error; if set to #f a reset is performed.
   siod-repl-mode  if set to #t cause the interpreter to print after the
                   evaluation of each command some information about the
                   memory usage and time needed else only the prompt is
                   printed.
   siod-gc-mode    if set to #t before and after each garbage collection the
                   interpreter prints a message showing also the time needed
                   and the number of cells collected.
If  siod is started with the -q option these three variables are set to #f
otherwise to #t.

 If  siod  is  started with the -s option only a small number of predefined
symbols are defined, and variables such nil true are not defined.  This can
be useful to run siod with a small number of cons (i.e.  1500) to use it as
a powerful calculator.

 On  AMIGA  the main program requires about 150k of mem and each cons is 10
bytes  long; run siod with -h10000 -o1000 -f500 will require less than 280k
and  works  fine on an old A500 not expanded leaving enough memory to run a
good  editor in background.  Vectors and strings requires additional memory
and  the  big  stack  size  needed  must  be  considered too.  The smallest
configuration  -h1000  -o1 -f1 requires less than 180k to run.  A suggested
configuration  is:   stack  size  50000, heap size 25000-50000, symtab size
1000-2000,  fixtab  size  500-5000  (depending  on  the  character  of  the
application to be run).

 When  siod  is  started  with  full-set  option  it  looks  in the current
directory    for    the    file    "siod.scm"   and   loads   it   in   the
user-global-environment,  then,  if  specified,  loads the init file; if is
started  with  the  small-set  option  loads  only the init file.  The file
"siod.scm"  should  not  be  loaded  in  small-set mode because it requires
procedures  not defined in that mode, the file small-siod.scm can be loaded
or specifiead as init file, providing some useful definition.

 Part  of  the runtime library is defined in separate files that are loaded
only  if necessary.  Siod looks for this files in the SIOD:  directory that
should  be  correctly  assigned.  This path can be changed editing the file
siod.scm  and  changing  the definition of the variable "path" in the first
line  this  variable  is used only inside the file siod.scm and then can be
redefined.

LANGUAGE DEFINITION

x any scheme object
n any number
r a rational number
m a complex number
i an integer
o a procedure
p a port
s a string
c a character
y a symbol
e an environment
l a list or a pair
v a vector

{x} an optional argument
x ... a list of argument
x1 the first arg in the arg-list
 ....
xn the n-th arg in the arg-list

<exp> any scheme expression
<pred> a scheme expression that returns #t or #f

NOTES: constants should not be modified, <exp> is identical to x the use of
one or the other indicates the tipical use in that context. Optional
arguments of subroutines of types 1 2 3 can be replaced by nil (non
standard), basic subroutines are defined also in -s mode, subroutine are
available only in full mode, the other are defined in the file siod.scm
directly or as autoload-from-file.

#\backspace (defined in siod.scm)
                constant.
#\escape (defined in siod.scm)
                constant.
#\newline (defined in siod.scm)
                constant.
#\page (defined in siod.scm)
                constant.
#\return (defined in siod.scm)
                constant.
#\rubout (defined in siod.scm)
                constant.
#\space (defined in siod.scm)
                constant.
#\tab (defined in siod.scm)
                constant.
* (basic subroutine)
        (* n ... )
                multiplies a list of numbers.
*the-non-printing-object* (constant)
	*the-non-printing-object*
		This is a value that if intercected by the standard
		scheme-top-level cause it not to print nothing.
+ (basic subroutine)
        (+ n ... )
                adds a list of numbers.
- (basic subroutine)
        (- n ... )
                subtracts a list of numbers.
-1+ (basic subroutine)
        (-1+ n)
                subtracts 1 from n. Is faster than (- n 1).
/ (basic subroutine)
        (/ n ... )
                divides a list of numbers.
1+ (basic subroutine)
        (1+ n)
                adds 1 to n. Is faster than (+ n 1).
< <= <> = > >= (basic subroutine)
        (op n n)
                compares two numbers.
abs (basic subroutine)
        (abs n)
                returns the absolute value of a number.
access (subroutine)
	(access y {e})
		returns the value of a symbol in an environment. If no
                environment is specified the current environment is used.
acos (basic subroutine)
        (acos n)
                returns the arcosine of a number.
add1 (subroutine)
        (add1 n)
		adds 1 to its argument.
alias (defined in siod.scm)
	(alias y1 y2)
		It is a macro that allows the symbol y1 to be used instead
                of y2 in every contest.
and (basic subroutine)
	(and <exp> ... )
		Performs the logical and of a list of expressions. It
                evaluates the expressions until they evaluates to #t and
                returns the value returned by the last exp or #f.
append (basic subroutine)
	(append l ... )
		Return the list obtained concatenating its arguments.
append! (subroutine)
	(append! l ... )
		Return the list obtained destructively concatenating its 
		arguments.
apply (subroutine)
	(apply o l)
		Evaluates the procedure o with the arguments of l.
apply-if (subroutine)
	(apply-if <pred> o x)
		Evaluates <pred> and if it returns a non-null value
		evaluates the procedure o with the result of <preed> as
		argument. If <pred> is #f returns x.
ascii->symbol (subroutine)
	(ascii->symbol i)
		Return an interned symbol whose printed representation is
                the character of ASCII code i.
asin (basic subroutine)
        (asin n)
                returns the arcosine of a number.
assert (defined in siod.scm)
	(assert <pred> x ... )
		Conditionally enters a breakpoint. If <pred> is #f prints
		every x and enters a breakpoint.
assoc assq assv (subroutine)
	(op x l)
		Returns the first pair in a list of pairs whose car
                component matches x. Assco uses equal? for comparison, assq
		uses eq? and assv eqv?.
atan (basic subroutine)
        (atan n)
                returns the arcotangent of a number.
atom? (basic subroutine)
	(atom? x)
		returns # if its arg is an atom (not a pair).
autoload-from-file (subroutine)
	(autoload-from-file s l {e})
		s is a string that names a file and l a list of variables.
		autoload-from-file loads the file s in the environment e
		the first time one of the variables contained in l is
		referenced. If e is omitted the file is loaded in the
		current environment.
begin (basic subroutine)
	(begin <exp> ... )
		Begin evaluates in sequence a list of expressions returning
		the value of the last <exp>.
begin0 (subroutine)
	(begin0 <exp> ... )
		Begin0 evaluates in sequence a list of expressions returning
		the value of the first <exp>.
boolean? (defined in siod.scm)
	(boolean? x)
		Checks if its arg is #t or #f.
c....r (defined in siod.scm as autoload-from-file)
	(c....r l)
		Performs a serie of car and cdr on a list. the .... can be
		any combination of the letters a and d, up to 4 characters,
		the a indicates a car and the d a cdr.
call-with-current-continuation (defined in siod.scm)
	(call-with-current-continuation o)
		o is a procedure of one argument. call/cc calls this
		procedure passing it a procedure of one argument that
		represent the future of evaluation at the moment call/cc
		was evaluated. When this procedure is invoked its argument
		is returned as result of call/cc. In Siod continuations are
		valid only inside the procedure invoked by call/cc.
call-with-input-file call-with-output-file 
    (defined in siod.scm as autoload-from-file)
	(op s o)
		o is a procedure of one argument, it opens the file
		specified by the string s (the first opens an input file
		and the second an output file), and then invokes o passing
		it the file as argument. If o returns the file is closed.
call/cc (defined in siod.scm)
	(call/cc o)
		Another name for call-with-current-continuation.
car (basic subroutine)
	(car l)
		Returns the car component of a pair.
case (subroutine)
	(case <exp1>
              (x <exp2> ...)
                 .....
              {(else <exp3> ...)})
		Case evaluates <exp1> an then compares the result with the
		x's until the comparison is #t, or finds the keyword else.
		The comparison is perfomed using eqv? if the x is an atom 
		and using memv? if is a pair. When the matching clause is
		found the exp's are evaluated in sequence and the value of
		the last exp returned as result of case.
cdr (basic subroutine)
	(cdr l)
		Returns the cdr component of a pair.
ceiling (basic subroutine)
	(ceiling n)
		Returns the smallest integer greater than or equal to n.
char->integer (basic subroutine)
	(char->integer c)
		Return the ascii code corrispondent to the character c.
char-ci<=? char-ci<? char-ci=? char-ci>=? char-ci>? 
    (defined in siod.scm as autoload-from-file)
	(op c c)
		compares two characters in a case insensitive way.
char-downcase char-upcase (subroutine)
	(op c)
		Forces a caracter to lowercase or uppercase.
char<=? char<? char=? char>=? char>?
    (defined in siod.scm as autoload-from-file)
	(op c c)
		compares two characters.
char? (basic subroutine)
	(char? x)
		Checks if its arg is a character.
close-input-port close-output-port (subroutine)
	(op p)
		Close a port.
closure? (subroutine)
	(closure? o)
		Checks if its arg is a closure (lambda named-lambda or
		fluid-lambda).
complex (basic subroutine)
	(complex n)
		Forces a number to complex.
complex? (basic subroutine)
	(complex? x)
		Checks if its arg is a complex number.
cond (basic subroutine)
	(cond (<pred> <exp1> ... )
                    .....
              {(else <exp2> ... )})
		Evaluates the pred's until one evaluates to #t or it finds
		the keyword else, then the corrispondent exp's are
		evaluated in sequence and the value of the last exp 
		returned.
cons (basic subroutine)
	(cons x1 x2)
		Creates a new pair with x1 as car and x2 as cdr.
cons-stream (defined in siod.scm as autoload-from-file)
	(cons-stream x1 x2)
		Creates a stream with x1 as head and x2 as tail. x2 isn't
		evaluated.
copy (subroutine)
	(copy l)
		Creates a copy of an entire tree of pairs.
cos (basic subroutine)
        (cos n)
                returns the cosine of a number.
current-input-port current-output-port 
    (defined in siod.scm as autoload-from-file)
	(op)
		Returns respectively the current input or output port.
define (basic subroutine)
	(define y)
	(define y <exp>)
        (define spec <exp> ... )
                spec: (y1 y2 ... {. y3}) | (spec y4 y5 ... {. y6})
		The first form defines a variable in the current
		environment frame without initialize it. The second first
		evaluates the exp and then defines a variable in the 
		current environment frame initializing it with the value
		returned by exp. The third is an abbreviated form to define
		procedures. 
		(define (y1 y2 ...) <exp>) is equivalent to:
                (define y1 (lambda (y2 ...) <exp>) and
                (define (((y1) y2) y3) <exp>) is equivalent to:
                (define y1 (lambda () (lambda (y2) (lambda (y3) <exp>)))).
delay (defined in siod.scm as autoload-from-file)
	(delay <exp>)
		Creates a delayed object. exp isn't evaluated. The object
		is memoized.
delayed-object? (defined in siod.scm as autoload-from-file)
	(delayed-object? x)
		Checks if itsarg is a delayed object.
delete! delq! (subroutine)
	(op x l)
		Destructively eliminates all the occurrences of x in l.
		The first uses equal? for comparison, the second eq?.
denominator (basic subroutine)
	(denominator r)
		Returns the denominator of a rational number.
display (basic subroutine)
	(display x {p})
		Prints x to a port. Strings are not enclosed in ", symbols
		are not slashified, characters are not preceeded by #\.
do (basic subroutine)
	(do ((y1 <exp1> <exp2>)
                 ....   )
            (<pred> <exp3> ...)
            <exp4> ...)
		Provides an iteration capability. First extends the
		environment with all the y1 bound to the exp1, then
		evaluates pred, if it is #f evaluates exp4 and the other
		expressions and then evaluates all the exp2 and in a second
		time binds the result to the corrispondent y1. After this
		evaluates back pred and repeats the process until pred
		evaluates #t at this point evaluates exp3 and the other
		expressions returning the value of the last.
dos-call (basic subroutine)
	(dos-call s)
		Passes a string to the DOS.
empty-stream? (defined in siod.scm as autoload-from-file)
	(empty-stream? x)
		Checks if its arg is an empty-stream.
environment-bindings (basic subroutine)
	(environment-bindings e)
		Returns the bindings of an environment. The bindings should
		not be modified. 
environment-parent (basic subroutine)
	(environment-parent e)
		Returns the parent of an environment. 
environment? (basic subroutine)
	(environment? x)
		Checks if its arg is an environment.
eof-object? (basic subroutine)
	(eof-object? x)
		Checks if its arg is an eof marker. Is the only way to
		identify an eof.
eq? (basic subroutine)
	(eq? x1 x2)
		Checks if x1 is identical to x2.
equal? (basic subroutine)
	(equal? x1 x2)
		Checks if x1 is equivalent to x2 verifing eventually all
		the components of lists and vectors.
eqv? (basic subroutine)
	(eqv? x1 x2)
		Checks if x1 is equivalent to x2 where x1 and x2 are
		non-pairs and non-vectors.
error (basic subroutine)
	(error s x ...)
		Cause an error of message s and sets errobj to the list of
		x's.
eval (basic subroutine)
	(eval <exp> {e})
		Evaluates an expression in an environment. If e is omitted
		the current environment is used instead.
even? (subroutine)
	(even? i)
		Checks if its arg is an even integer.
exit (subroutine)
	(exit)
		Exits Siod.
exp (basic subroutine)
        (exp n)
                returns e^n (e is the Eulero number).
explode (defined in siod.scm as autoload-from-file)
	(explode i)
	(explode s)
	(explode y)
		Returns a list of one character symbols corresponding to
		the characters of the printed representation of its
		argument. 
expt (basic subroutine)
	(expt n1 n2)
		Returns n1 powered to n2.
f (constant)
	f
		initialized to #f
false (constant)
	false
		initialized to #f
file-exists? (subroutine)
	(file-exists? s)
		Checks if exists a file named s.
file-length (defined in siod.scm as autoload-from-file)
	(file-length s)
		Returns the length in bytes of the file named s.
float (basic subroutine)
	(float n)
		Forces a number to float.
float? (basic subroutine)
	(float? x)
		Checks if its arg is a float number.
floor (basic subroutine)
	(floor n)
		Return the largest integer not greater than n.
fluid (subroutine)
	(fluid y)
		Access a symbol in the fluid environment.
fluid-bound? (subroutine)
	(fluid-bound? y)
		Returns #t if y is bound in the fluid environment.
fluid-lambda (subroutine)
	(fluid-lambda ({y1 ...} {. y2}) <exp> ...)
		Returns a closures whose arguments will be bound in the
		fluid environment. If y2 is specified all the arguments
		passed to the closure that exceed the number of arguments
		needed are bound to y2 in a list.
fluid-let (subroutine)
	(fluid-let ((y1 <exp1>)
                       ....   )
                   <exp2> ... )
		evaluates all the <exp1>, binds the results to the
		correspondent y in the fluid environment and then evaluates
		all the exp2 returning the value of the last exp.
flush-input (subroutine)
	(flush-input {p})
		clears an input port's buffer. If p is not specified the
		current input port is used instead.
for-each (subroutine)
	(for-each o l)
		o is a procedure of one argument. For-each applyes o to all
		the elements of l from left to rigth.
force (defined in siod.scm as autoload-from-file)
	(force x)
		Forces the evaluation of a delayed object. If the object
		has been forced previously the previous result is returned.
freesp (basic subroutine)
	(freesp)
		Returns the number of bytes available.
freeze (defined in siod.scm as autoload-from-file)
	(freeze <exp>)
		Return a thunk. <exp> isn't evaluated and not memoized.
gc (basic subroutine)
	(gc)
		Forces a garbage collection.
gcd (basic subroutine)
	(gcd i ...)
		Returns the greatest common divisor of a list of integers.
gensym (subroutine)
	(gensym)
	(gensym i)
	(gensym s)
		Generates a new uninterned symbol. The symbol is generated
		from a string and a counter if the arg is a string it
		replaces the current string, if it is an integer resets the
		counter.
get-file-position (subroutine)
	(get-file-position p)
		Returns the value of the file pointer associated to p.
getprop (subroutine)
	(getprop y1 y2)
		Looks for the property y2 in the proplist of y1.
head (defined in siod.scm as autoload-from-file)
	(head stream)
		Returns the head component of a stream.
if (basic subroutine)
	(if <pred> <exp1> <exp2>)
		Evaluates pred, if pred is #t evaluates exp1 else exp2.
imaginary (basic subroutine)
	(imaginary m)
		(returns the imaginary part of a complex number.
implode (defined in siod.scm as autoload-from-file)
	(implode l)
		l is a list composed by numbers, symbols or strings.
		Implode creates a symbol composed by the first character of
		the printed representation of strings and symbols or from
		the character of ASCII code correspondent to the integers 
		contained in the list.
input-port (fluid variable)
	(fluid input-port)
		Contains the default port used by the i/o routines. Must
		evaluate to a port or a fatal error occours.
input-port? (subroutine)
	(input-port? x)
		Checks if its arg is an input port.
inspect (basic subroutine)
	(inspect {e})
		The default inspector invoked after an error or in a
		breakpoint.
integer->char (basic subroutine)
	(integer->char i)
		Returns a character of ASCII code i.
integer->string (subroutine)
	(integer->string i1 i2)
		Returns a string containing the written representation of
		i1 expressed in base i2.
integer? (basic subroutine)
	(integer? x)
		Checks if its arg is an integer.
lambda (basic subroutine)
	(lambda ({y1 ...} {. y2}) <exp> ...)
		Creates a new closure of arguments y's and body exp's. If
		y2 is specified all the arguments exeeding the number of
		args needed are linked together in a list and bound to y2.
last-pair (subroutine)
	(last-pair l)
		Returns the last pair of a list.
lcm (basic subroutine)
	(lcm i ...)
		Returns the lowest common multiplier of a list of integers.
length (subroutine)
	(length l)
		Returns the length of a list.
let (basic subroutine)
	(let ((y <exp1>)
               .....    )
             <exp2> ...  )
		Evaluates all the exp's and then extends the environment
		binding each y with the result of the corresponding exp
		then evaluates all the exp2 and returns the value of the
		last exp.
let* (subroutine)
	(let* ((y1 <exp1>)
                  ....    )
              <exp2> ...   )
		Evaluates the first exp then extends the environment
		binding the result to the firs symbol, then evaluates in
		the extended environment the second symbol extending again
		the environment with the new binding, repeat thi for all
		the symbols and exp, then evaluates exp2 and the other exp
		returning yhe value of the last exp.
letrec (subroutine)
	(letrec ((y1 <exp1>)
                    ....    )
                <exp2> ...   )
		Extends the environment with all the ys, then evaluates all
		the exp in the extended environment and binds each y with 
		the result of the corresponding exp, then evaluates exp2
		and the other exp returning the value of the last exp.
list (basic subroutine)
	(list x ...)
		Returns a list composed of all its arguments.
list* (subroutine)
	(list x ...)
		Returns a dot-list (not nil terminated) composed of all its
                arguments.
list->stream (defined in siod.scm as autoload-from-file)
	(list->stream l)
		Returns a stream containing the elements of l.
list->string (subroutine)
	(list->string l)
		l is a list of characters. Retuns a string composed by the
		characters contained in l.
list->vector (subroutine)
	(list->vector l)
		Returns a vector containing the same elements of l.
list-ref (subroutine)
	(list-ref l n)
		Returns the n-th elements of l.
list-tail (subroutine)
	(list-tail l n)
		Returns the n-th pair of a list.
load (basic subroutine)
	(load s {e})
		Loads a file named s evaluating its expression in e. If e
		is not specified the current environment is used insead.
		The optional environment is not standard.
log (basic subroutine)
        (log n1 {n2})
                returns the logarithm of n1 in base n2. If n2 is omitted
                the natural logarithm is returned.
macro (basic subroutine)
	(macro y o)
		o is a procedure of one argument. Defines in the current
		environment y bound to a macro. When the macro is evaluated
		the current expression is passed to o and the result is
		evaluated instead. 
macro? (basic subroutine)
	(macro? y)
		Checks if its arg is a macro.
make-complex (basic subroutine)
	(make-complex n1 n2)
		Creates a new complex number with n1 as real part and n2 as
		imaginary part.
make-environment (defined in siod.scm)
	(make-environment <exp> ...)
		Creates a new environment, evaluates in it all the exp's
		and returns it.
make-rational (basic subroutine)
	(make-rational n1 n2)
		Creates a new rational number with n1 as numerator and n2
		as denominator.
make-string (subroutine)
	(make-string i {c})
		Creates a string composed by i occurrence of c or of blanks
		if c is omitted.
make-vector (subroutine)
	(make-vector i {x})
		Creates a vector composed by i occurrences of x or nil of x
		is omitted.
map (basic subroutine)
	(map o l)
		o is a procedure of one argument. Map applyes o to every
		element of l returning a list of the results.
mapc (subroutine)
	(mapc o l)
		The same as for-each.
mapcar (subroutine)
	(mapcar o l)
		The same as map.
max (basic subroutine)
	(max n ... )
		Returns the greatest of a list of numbers.
member memq memv (subroutine)
	(op x l)
		Returns the sublist beginning with the first occurrece of x
		in l. Member uses equal? for comparison, memq eq? memv
		eqv?.
min (basic subroutine)
	(min n ... )
		Return the smallest of a list of numbers.
minus (subroutine)
        (minus n)
                returns the opposite of a number.
modulo (basic subroutine)
	(modulo i1 i2)
		Returns the remainder of i1/i2 with the sign of i2.
named-lambda (subroutine)
	(named-lambda (y1 {y2 ...} {. y3}) <exp> ...)
		Creates a new closure of arguments y2 ... and body exp's.
		When it's evaluated the procedure is bound to its name
		allowing recusion and relatively faster speed of execution.
		If y3 is specified all the arguments exeeding the number of
		args needed are linked together in a list and bound to y3.
negative? (subroutine)
	(negative? n)
		Checks if its arg is a negative number.
newline (defined in siod.scm as autoload-from-file)
	(newline {p})
		Prints a newline on a port. If p is omitted the current
		output port is used instead.
nil (constant)
		initialized to #f.
not (subroutine)
	(not <exp>)
		Logically negates an expression.
null? (basic subroutine)
	(null? x)
		Checks if its arg is the empty list.
number->string (subroutine)
	(number->string n l)
		Return a string containing the written representation of n.
		l is a list specifing the format of n. Format allowed are:
		(int) express n as integer
		(heur) express n heuristically.
number? (basic subroutine)
	(number? x)
		Checks if its arg is a number.
numerator (basic subroutine)
	(numerator r)
		Returns the numerator part of a rational number.
odd? (subroutine)
	(odd? i)
		Checks if its arg is an odd integer.
open-binary-input-file open-binary-output-file 
    (defined in siod.scm as autoload-from-file)
	(op s)
		Returns a port bound to a binary file of name s. If the
		file does not exists is created, if exists
		open-binary-output-file overwrites it.
open-extend-file open-input-file open-output-file 
    (defined in siod.scm as autoload-from-file)
	(op s)
		Returns a port bound to a file named s. If the file does
		not exists is created, if does not exists open-extend-file
		append the output to the end of file, open-output-file
		overwrites it.
or (basic subroutine)
	(or <exp> ...)
		Performs a logical or between the exps. Evaluates the exp
		until they evaluates to #f and returns the value of the
		first exp that doesn't evaluates to #f or #f.
output-port (fluid variable)
	(fluid output-port)
		Contains the default port used by the i/o routines. Must
		evaluate to a port or a fatal error occours.
output-port? (subroutine)
	(output-port? x)
		Checks if its arg is an output port.
page (defined in siod.scm as autoload-from-file)
	(page {p})
		Prints a linefeed to a port if p is omitted the current
		output port is used instead.
pair? (subroutine)
	(pair? x)
		Checks if its arg is a pair.
pi (constant)
		The ratio of a circumference to its diameter.
port? (basic subroutine)
	(port? x)
		Checks if its arg is a port.
positive? (subroutine)
	(positive? n)
		Returns #t if its arg is greater than or equal to 0.
prin1 (subroutine)
	(prin1 x {p})
		The same as write.
princ (subroutine)
	(princ x {p})
		The same as display.
print (basic subroutine)
	(print x {p})
		Prints x to a port on a new line using write.
print-length (subroutine)
	(print-length x1 {x2})
		Calculates the number of characters needed to print x1
		using display. If x2 is specified and evaluates to #t uses
		write instead. x2 is not standard.
proc? (basic subroutine)
	(procedure? x)
		Checks if its arg is a subroutine, a special form or a
		closure.
procedure-environment (subroutine)
	(procedure-environment o)
		Returns the environment where o was defined.
procedure? (subroutine)
	(procedure? x)
		Checks if its arg is a subroutine or a special form.
proplist (subroutine)
	(proplist y)
		Returns the property-list associated to y.
putprop (subroutine)
	(putprop y1 x y2)
		Adds the prop y2 to the proplist of y1 with the value of x.
quasiquote (subroutine)
	(quasiquote x)
	`x
		Returns its arg unevaluated eventually evaluating the
		special forms , ,@ ,. unquote unquote-splicing contained in
		it. (unquote x) or ,x cause the x to be evaluated and
		inserted in the list instead of it. The arg of
		(unquote-splicing l) or ,@l must be a list and cause the
		elements of the list replace it without parenthesis. With
		,.l the splicing is destructive. Unquoting happens only at
		the first level of quasiquoting.
quote (basic subroutine)
	(quote x)
	'x
		Returns its argument unevaluated.
quotient (basic subroutine)
	(quotient i1 i2)
		Returns the quotient of i1/i2.
random (basic subroutine)
	(random i)
		Returns a random number between 0 and i-1.
randomize (basic subroutine)
	(randomize i)
		Start a new series of random numbers. If i is 0 the timer
		is used as seed.
rational (basic subroutine)
	(rational n)
		Forces a number to rational.
rational? (basic subroutine)
	(rational? x)
		Checks if its arg is a rational number.
read (basic subroutine)
	(read {p})
		Reads a scheme expression from a port. If p is omitted the
		current port is used instead.
read-char (subroutine)
	(read-char {p})
		Reads a character from a port. If p is omitted the current 
		port is used instead.
read-line (subroutine)
	(read-line {p})
		Returns a string containing a line read from a port. If p is
		omitted the current port is used instead.
real (basic subroutine)
	(real m)
		Returns the real part of a complex number.
real? (subroutine)
	(real? x)
		Checks if its arg is a real number (integer rational or
		float).
rec (defined in siod.scm)
	(rec y <exp>)
		Extend the environment binding y to exp and then evaluates
		exp and return it value.
remainder (basic subroutine)
	(remainder i1 i2)
		Returns the remainder of i1/i2 with the sign of i1.
remprop (subroutine)
	(remprop y1 y2)
		Removes The property y2 from the proplist of y1.
reset (subroutine)
	(reset)
		aborts evaluation restarting the current scheme-top-level
		loop.
reset-scheme-top-level (subroutine)
	(reset-scheme-top-level)
		Binds the fluid variable scheme-top-level to the default
		read-eval-print loop without starting it.
reverse (basic subroutine)
	(reverse l)
		Returns a list containing the same elements of l in reverse
		order.
reverse! (subroutine)
	(reverse l)
		Destructively returns a list containing the same elements
		of l in reverse order.
round (basic subroutine)
	(round n)
		Returns the integer closest to n.
runtime (subroutine)
	(runtime)
		Returns the time of day expressed in milliseconds.
scheme-reset (subroutine)
	(scheme-reset)
		Resets the fluid variable scheme-top-level to its default
		value and the fluid variables input-port output-port to the
		value of standard-input standard-output respectively. Then
		restarts the execution. Resets also the inspector to the
		default inspector and *error* to the default error handler.
scheme-top-level (fluid variable)
	(fluid scheme-top-level)
		contains the corrent top-level read-eval-print loop. Can be
		rebound by the user. If the procedure returns the system
		invokes it again.
sequence (subroutine)
	(sequence <exp> ...)
		The same as begin.
set! (basic subroutine)
	(set! y x)
	(set! (fluid y) x)
	(set! (vector-ref v i) x)
	(set! (access y {e}) x)
		The first form sets the binding of the symbol y in the
		current environment to x.
		The second sets the binding of the symbol y in the
		fluid environment to x.
		The third sets the i-th element of the vector v to x.
		The fourth sets the binding of the symbol y in the
		environment e to x. If e is omitted the current environment
		is used instead.
set-car! (basic subroutine)
	(set-car! l x)
		sets the car component of the pair l to x.
set-cdr! (basic subroutine)
	(set-cdr! l x)
		sets the cdr component of the pair l to x.
set-file-position! (subroutine)
	(set-file-position! p i1 i2)
		Positions the file pointer inside the file associated to p
		if i2 is 0 sets the file position to i1 bytes from the
		beginning of the file.
		if i2 is 1 sets the file position to i1 bytes from the
		current position of the file.
		if i2 is 2 sets the file position to i1 bytes from the
		end of the file.
set-fluid! (subroutine)
	(set-fluid! y x)
		Sets the binding of y in the fluid environment to x.
sin (basic subroutine)
	(sin n)
		Returns the sin of a number.
sort! (defined in siod.scm as autoload-from-file)
	(sort! l)
	(sort! v)
		Destructively sorts a list or a vector. It uses quicksort
		for vectors and merge-sort for lists.
sqrt (basic subroutine)
	(sqrt n)
		Returns the square root of a number.
standard-input (variable)
	standard-input
		Contains the standard input. Is initialized to the console.
		Must evaluate to a port or a fatal error occours.
standard-output (variable)
	standard-output
		Contains the standard output. Is initialized to the console.
		Must evaluate to a port or a fatal error occours.
stream->list (defined in siod.scm as autoload-from-file)
	(stream->list stream)
		Converts a finite stream to a list.
stream? (defined in siod.scm as autoload-from-file)
	(stream? x)
		Checks if its arg is a stream.
string->list (subroutine)
	(string->list s)
		returns a list composed of the characters contained in s.
string->number (subroutine)
	(string->number s y1 y2)
		Converts a string to a number. y1 represent the exactness
		but it is not implemented on siod and then is ininfluent.
		y2 is the radix and can be:
		'b indicates that s represents a binary number
                'd indicates that s represents a decimal number
                'o indicates that s represents an octal number
                'x indicates that s represents an hexadecimal number
string->symbol (subroutine)
	(string->symbol s)
		Returns a symbol of printed representation correspondent to
		the string s.
string->uninterned-symbol (subroutine)
	(string->uninterned-symbol s)
		Returns an uninterned symbol of printed representation 
		correspondent to the string s.
string-CI<? string-CI=? (defined in siod.scm as autoload-from-file)
	(op s1 s2)
		Compares two string in a case insensitive way.
string-append (basic subroutine)
	(string-append s ...)
		Returs the string obtained concatenating all its arg.
string-copy (subroutine)
	(string-copy s)
		Returns a new string identical to s.
string-fill! (subroutine)
	(string-fill! s {c})
		Replaces all the caracters in s with the character c. If c
		is omitted a blank is used.
string-length (basic subroutine)
	(string-length s)
		Returns the length of the string s.
string-null? (defined in siod.scm as autoload-from-file)
	(string-null? x)
		Checks if its arg is an empty string.
string-ref (basic subroutine)
	(string-ref s i)
		Returns the i-th character of the string s. The first
		character has index 0.
string-set! (basic subroutine)
	(string-set! s i c)
		Replaces the i-th character of the string s with the
		character c. The first character has index 0.
string<=? string<? string=? string>=? string>? 
    (defined in siod.scm as autoload-from-file)
	(op s1 s2)
		Compares two strings.
string? (basic subroutine)
	(string? x)
		Checks if its arg is a string.
sub1 (subroutine)
	(sub1 n)
		Subtracts 1 from its arg.
substring (basic subroutine)
	(substring s i1 i2)
		Returns a string that contains the part of the string s
		between i1 and i2-1.
substring-CI<? substring-CI=? (defined in siod.scm as autoload-from-file)
	(op s1 i1 i2 s2 i3 i4)
		Compares the substring of s1 between i1 and i2-1 and the
		substring of s2 between i3 and i4-1 in a character 
		insensitive way.
substring-fill! (defined in siod.scm as autoload-from-file)
	(substring-fill! s i1 i2 c)
		Replaces all the characters in the string s between i1 and
		i2-1 with the character c.
substring-find-next-char-in-set substring-find-previous-char-in-set 
	(op s1 i1 i2 c)
	(op s1 i1 i2 s2)
		Searches, in the substring of s1 between i1 and i2, the 
		first occurrence of the char c or of one of the characters 
		of the string s2. The first procedure searches starting 
		from i1 to i2 and the second from i2 to i1.
substring-move-left! substring-move-right! 
    (defined in siod.scm as autoload-from-file)
	(op s1 i1 i2 s2 i3)
		Copies the substring of s1 between i1 and i2-1 to s2
		starting at position i3. The first starts copying from the
		left to the rigth and the second from the rigth to the
		left. If s1 and s2 are different strings there is no 
		difference between the two procedures but if the string is
		the same and the indexes are overlapping the behaviour can
		be different. 
substring<? substring=? (defined in siod.scm as autoload-from-file)
	(op s1 i1 i2 s2 i3 i4)
		Compares the substring of s1 between i1 and i2-1 and the
		substring of s2 between i3 and i4-1.
symbol->ascii (subroutine)
	(symbol->ascii y)
		Returns the ascii code correspondent to the first character
		in the printed representation of the symbol.
symbol->string (subroutine)
	(symbol->string y)
		Returns a string containing the written representation of
		the symbol y.
symbol? (basic subroutine)
	(symbol? x)
		Checks if its arg is a symbol.
t (constant)
	t
		initialized to the value #t
true (constant)
	true
		initialized to the value #t
tail (defined in siod.scm as autoload-from-file)
	(tail stream)
		Forces the evaluation and returns the tail component of a
		stream. This component is memoized.
tan (basic subroutine)
        (tan n)
                returns the tangent of a number.
thaw (defined in siod.scm as autoload-from-file)
	(thaw o)
		Forces the evaluation of a thunk. Not memoized.
the-empty-stream (defined in siod.scm as autoload-from-file)
	the-empty-stream
		is a stream representing the end-of-stream tag.
the-environment (basic subroutine)
	(the-environment)
		Returns the current environment.
transcript-off (subroutine)
	(transcript-off)
		Terminates the recording of all the console i/o to the
		transcript file and closes it. 
		Non standard feature: returns #f if the transcript mode is
		already off otherwise #t.
transcript-on (subroutine)
	(transcript-on s)
		Opens a file named s and starts recording all the console
		i/o to that file.
truncate (basic subroutine)
	(truncate n)
		Returns the integer component of a number.
unbound? (subroutine)
	(unbound? y {e})
		Returns #t if the symbol y is not bound in the environment
		e. If e is omitted the current environment is used instead.
unquote (subroutine)
	(unquote <exp>)
	,<exp>
		Is valid only inside a quasiquote expression. Cause the exp
		to be evaluated and the result is inserted in the
		quasiquote expression instead of the unquote expression.
unquote-splicing (subroutine)
	(unquote-splicing <exp>)
	,@<exp>
		Is valid only inside a quasiquote expression. Cause the exp
		to be evaluated (it must evaluae to a list) and the result 
		is inserted in the quasiquote expression instead of the 
		unquote-splicing expression stripping away the parenthesis.
user-global-environment (constant)
	user-global-environment
		To this variable is bound the global environment whose
		bindings cannot be examinated.
user-initial-environment (constant)
	user-initial-environment
		In this environment are evaluated and defined the user
		procedures and commands.
vector (basic subroutine)
	(vector x ...)
		Returns a vector containing its args.
vector->list (subroutine)
	(vector->list v)
		Returns a list containing the same elements of the vector.
vector-fill! (subroutine)
	(vector-fill! v x)
		Replaces each element of v with the value of x.
vector-length (basic subroutine)
	(vector-length v)
		Returns the length of v.
vector-ref (basic subroutine)
	(vector-ref v i)
		Returns the i-th element of a vector. The first element of
		the vector has index 0.
vector-set! (basic subroutine)
	(vector-set! v i x)
		Sets the i-th element of a vector to the value of x. The 
		first element of the vector has index 0.
vector? (basic subroutine)
	(vector? x)
		Checks if its arg is a vector.
when (subroutine)
	(when <pred> <exp> ...)
		Evaluates pred if its value is #t evaluates all the 
		expression.
with-input-from-file with-output-to-file 
    (defined in siod.scm as autoload-from-file)
	(op s o)
		o is a thunk a procedure of no arguments. These procedures
		opens a file named s, replaces the current input or output
		port with this file and then invokes o. The file s is
		always closed and the current port restored. In Siod if you
		exit from o with an escape mechanism (call/cc or *thaw)
		this happens only at the first reset or error.
write (subroutine)
	(write x {p})
		Writes an expression to a port. The expression is written
		in such a way that if re-read into scheme using read will 
		produce the same object. Strings are enclosed in " and
		eventually slashed, symbols are slashed if necesary,
		characters are preceeded by a #\, objects like ports,
		environment, procedures, closures, etc that can not be
		re-read into scheme prints a #<name> where name is the name
		of the object. To convey some information to the user write
		prints also the type of procedures and the number of 
		arguments needed to a closure. Types of procedures are:
                            0 a procedure with 0 args
                            1 a procedure with 1 args
                            2 a procedure with 2 args
                            3 a procedure with 3 args
                            4 a procedure with more than 3
                            5 a special form
                            6 a special form
write-char (subroutine)
        (write-char c {p})
                writes a character to a port. If p is omitted the current
                output port is used.
writeln (basic subroutine)
        (writeln x ... )
                writes a list of objects to the current output port using
                display.
zero? (subroutine)
        (zero? n)
                checks if n is zero.

LANGUAGE EXTENSIONS, SYSTEM AND USER PACKAGES (non standard)

*cargs* (variable)
	*cargs*
		Inside a breakpoint it evaluates to the current stack
		frame.
*catch (subroutine)
	(*catch x <exp> ...)
		Sets a jump point of tag x, evaluates each exp and then
		removes the jump point. When a *throw jumps to the jump
		point removes all the jump points that have been set after
		it.
*cenv* (variable)
	*cenv*
		Inside a breakpoint it evaluates to the environment in 
		effect when the breakpoint was entered.
*error* (basic subroutine)
	(*error*)
		This is the default error handler. It flushes all the output
		port, checks the current input or output ports and
		eventually replaces them with the standard ports, prints the
		error message and if the variable sym_debug_mode is #t 
		invokes the inspector.
		When an error occours Siod sets the variables errobj
		*lasterr* *cenv* *cargs* and invokes *error*, when it
		returns siod sets the variables *cenv* and *cargs* to nil
		(they can point to very large an often useless structures 
		and the gc cannot deallocate them until something points to
		them) and performs a reset.
*lasterr* (variable)
	*lasterr*
		The last error message is bound by the system to this
		variable.
*on-reset* (variable)
	*on-reset*
		This variable is evaluated each time a reset is performed
                in the file siod.scm is initialized to the reset-handler
		contained in *on-reset-env*.
*on-reset-env* (constant)
	*on-reset-env*
		Contains a stack of thunks, procedures of 0 args that will
		be evaluated at the first reset. When a reset occours the
		first thunk is removed from the stack and then evaluated and
		so on until the stack is empty. Can be used by the user to
		intercept errors and resets. Each thunk is evaluated once.
*throw (subroutine)
	(*throw x1 x2)
		Jumps to the jump point marked by the tag x1, the value x2
		is returned by the corresponding *catch. All the jump
		points set after this are removed.
*tracer* (defined in siod.scm as autoload-from-file)
	(*tracer* s e)
		Used by the trace procedure.
1st 2nd 3rd 4th (defined in siod.scm as autoload-from-file)
	(op l)
		The same as car cadr caddr cadddr respectively.
bkpt (subroutine)
	(bkpt s x ...)
		Enters a breakpoint, sets the variables *cenv* *cargs* to
		the current stack frame and environment sets the errobj to
		the x's, prints s and all the x and invokes the standard 
		inspector.
break (defined in siod.scm as autoload-from-file)
	(break o {s})
		This is a debugging utility. o is a procedure, break modify 
		its code so that every time the procedure is entered the 
		optional string s is printed and a breakpoint entered. If
		the breakpoint ever returns the evaluation restarts 
		executing the body of the procedure. The break point is 
		entered after the environment has been extended with the 
		arguments.
call-on-reset (defined in siod.scm)
	(call-on-reset o)
		Adds the thunk o to the stack of thunks that will be
		executed at the next reset.
char-cmp (basic subroutine)
	(char-cmp c1 c2)
		Compares two characters. Returns 0 if c1=c2, a negative
		value if c1<c2, a positive value if c1>c2.
char-digit? char-lower-case? char-upper-case? 
    (defined in siod.scm as autoload-from-file)
	(op c)
		Checks if its arg is a character representing a digit, a
		lowercase letter or an uppercase letter respectively.
close-port (basic subroutine)
	(close-port p)
		Closes a port.
compose (defined in siod.scm)
	(compose o1 o2)
		Returns a procedure that is the equivalent of (o2 (o1 ..)).
cxr (subroutine)
	(cxr s l)
		Performs a series of car and cdr on the list l as specified
		by the string s, read from rigth to left. Every a
		corresponds to a car and every d to a cdr.
cycle (defined in siod.scm)
	(cycle <exp>)
		Evaluates indefinitely <exp>.
flush-port (subroutine)
	(flush-port p)
		Performs a fflush and a clearerr on the file pointer
		associated to the port.
for (defined in siod.scm)
	(for y <exp1> <exp2> <pred> 
             <exp3> ...)
		Extends the environment binding the symbol y to the value
		of exp1 then evaluates the pred if its value is #t returns
		otherwise evaluates the other exps and then evaluates exp2,
		binds the symbol y to its value and evaluates back the 
		pred.
gc-status (subroutine)
	(gc-status)
		Prints some informations on the system variables, the
		number of cons available, the number of buckets of the
		symbol table used and calculates the loading factor of the
		table.
nth (defined in siod.scm)
	(nth l i)
		The same as list-ref.
open-port (basic subroutine)
	(open-port s1 s2 i)
		Return a port associated with the file named s1. s2
		represents the open mode following the C-language
		convensions: "r" open a file in read mode, "w" open a file
		in write mode, "a" open a file in append mode, if a "+" is
		specified in the string the file is opened in read/write 
		mode and if a "b" is specified opens a binary file. If a
		file is opened in read/write mode, following the C-language
		convensions between a read and a write operation a fflush
		(flush-port in siod) should be performed. i specifies the
		bufferization of the file, if its value is positive a full
		bufferization is used with a 512 bytes buffer, if its value
		is negative a line bufferization is used and if is 0 the
		file is unbuffered.
procedure-code (subroutine)
	(procedure-code o)
		Returns the procedure code of o. The procedure code is a
		pair whose car is the arg-list and the cdr the body.
quit (basic subroutine)
	(quit)
		Exits siod.
repeat (defined in siod.scm)
	(repeat <exp> <pred>)
		Evaluates the exp and then the pred if its value is #t
		returns otherwise evaluates back th exp.
set-procedure-code! (subroutine)
	(set-procedure-code! o l)
		Replaces the procedure code of o with l. Must be used
		carefully. The procedure code is a pair whose car is
		the arg-list and the cdr the body.
siod-debug-mode (variable)
	siod-debug-mode
		If set to #t the inspector is invoked after each error.
siod-gc-mode (variable)
	siod-gc-mode
		If set to #t before and after each gc a message is printed.
siod-repl-mode (variable)
	siod-repl-mode
		If set to #t after the evaluation of each command some
		informations on the timing and the memory usage are printed.
stream-append (defined in siod.scm as autoload-from-file)
	(stream-append stream1 stream2)
		Returns a stream obtained concatenating stream1 and
		stream2.
stream-filter (defined in siod.scm as autoload-from-file)
	(stream-filter <pred> stream)
		Applies the pred to all the elements of a finite stream and
		returns a stream of that elements for which the result of
		the pred was #t.
stream-for-each (defined in siod.scm as autoload-from-file)
	(stream-map o stream)
		Applies the procedure o to all the elements of a finite 
		stream.
stream-map (defined in siod.scm as autoload-from-file)
	(stream-map o stream)
		Applies the procedure o to all the elements of a finite 
		stream returning a stream of the results.
stream-nth (defined in siod.scm as autoload-from-file)
	(stream-nth i stream)
		The same as stream-ref.
stream-ref (defined in siod.scm as autoload-from-file)
	(stream-ref i stream)
		Returns the i-th component of a stream.
string-cmp (basic subroutine)
	(string-cmp s1 s2)
		Compares two strings. The result is 0 if s1=s2, is positive
		if s1>s2, negative if s1<s2.
string-cmp-ci (subroutine)
	(string-cmp-ci s1 s2)
		Compares two strings in a case insensitive way. The result 
		is 0 if s1=s2, is positive if s1>s2, negative if s1<s2.
time-of-day (defined in siod.scm)
	(time-of-day)
		The same as runtime.
trace (defined in siod.scm as autoload-from-file)
	(trace o {s})
		This is a debugging utility o is a procedure, trace modify 
		its code so that every time the procedure is entered the 
		optional string s or the string "entering procedure " is
		printed and the contents of the last environment frame (the
		one that contains the argument bindings) is listed. Then 
		the execution restarts.
unbreak (defined in siod.scm as autoload-from-file)
	(unbreak o)
		Removes the break informations from o.
uncall-on-reset (defined in siod.scm)
	(uncall-on-reset o)
		Removes the thunk o from the stack of thunks that will be
		executed at the next reset using delq!.
untrace (defined in siod.scm as autoload-from-file)
	(untrace o)
		Removes the break informations from o.
vector-append (defined in siod.scm as autoload-from-file)
	(vector-append v1 v2)
		Returns a vector containing all the elements of v1 and v2.
vector-copy (defined in siod.scm as autoload-from-file)
	(vector-copy v)
		Returns a vector containing all the elements of v.
vector-for-each (defined in siod.scm as autoload-from-file)
	(vector-for-each v o)
		Applies the procedure o to all the elements of v.
vector-map (defined in siod.scm as autoload-from-file)
	(vector-map v o)
		Applies the procedure o to all the elements of v and
		returns avector of the results.
vector-reverse (defined in siod.scm as autoload-from-file)
	(vector-reverse v)
		Returns a vector containing the same elements as v but in
		reverse order.
vector-reverse! (defined in siod.scm as autoload-from-file)
	(vector-reverse! v)
		Destructively reverse the order of the elements of v.
while (subroutine)
	(while <pred> <exp> ...)
		Evaluates pred and if its alue is #t evaluates the exps and
		then evaluates back the pred.
