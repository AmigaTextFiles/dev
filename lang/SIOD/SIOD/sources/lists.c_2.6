/* Scheme In One Define.
 
The garbage collector, the name and other parts of this program are

 *                     COPYRIGHT (c) 1989 BY                              *
 *      PARADIGM ASSOCIATES INCORPORATED, CAMBRIDGE, MASSACHUSETTS.       *

Conversion  to  full scheme standard, characters, vectors, ports, complex &
rational numbers, and other major enhancments by

 *      Scaglione Ermanno, v. Pirinoli 16 IMPERIA P.M. 18100 ITALY        * 

Permission  to use, copy, modify, distribute and sell this software and its
documentation  for  any purpose and without fee is hereby granted, provided
that  the  above  copyright  notice appear in all copies and that both that
copyright   notice   and   this  permission  notice  appear  in  supporting
documentation,  and that the name of Paradigm Associates Inc not be used in
advertising or publicity pertaining to distribution of the software without
specific, written prior permission.

PARADIGM  DISCLAIMS  ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL  IMPLIED  WARRANTIES  OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
PARADIGM  BE  LIABLE  FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
IN  AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

*/

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <setjmp.h>
#include <signal.h>
#include <math.h>

#include "siod.h"

LISP cons(LISP x,LISP y)
{long flag;
 LISP z;
 flag=no_interrupt(1);
 NEWCELL(z,tc_cons);
 CAR(z) = x;
 CDR(z) = y;
 no_interrupt(flag);
 return(z);}

LISP consp(LISP x)
{if CONSP(x) return(truth);
 return(NIL);}

LISP car(LISP x)
{switch TYPE(x)
   {case tc_nil:
      return(NIL);
    case tc_cons:
      return(CAR(x));
    default:
      err("car",x,ERR_GEN_ARG | ERR_NPAI);}}

LISP cdr(LISP x)
{switch TYPE(x)
   {case tc_nil:
      return(NIL);
    case tc_cons:
      return(CDR(x));
    default:
      err("cdr",x,ERR_GEN_ARG | ERR_NPAI);}}

LISP setcar(LISP cell, LISP value)
{if NCONSP(cell) err("set-car!",cell,ERR_FIRST | ERR_NPAI);
 return(CAR(cell) = value);}

LISP setcdr(LISP cell,LISP value)
{if NCONSP(cell) err("set-cdr!",cell,ERR_FIRST | ERR_NPAI);
 return(CDR(cell) = value);}

LISP reverse(LISP l)
{LISP n,p;
 if (NNULLP(l) && NCONSP(l)) err("reverse",l,ERR_GEN_ARG | ERR_NPAI);
 n = NIL;
 for(p=l;CONSP(p);p=CDR(p)) n = cons(CAR(p),n);
 return(n);}

LISP reverseI(LISP l)
{LISP n,p;
 if (NNULLP(l) && NCONSP(l)) err("reverse!",l,ERR_GEN_ARG | ERR_NPAI);
 n = NIL;
 while(CONSP(l))
  {p = CDR(l);
   CDR(l) = n;
   n = l;
   l = p;}   
 return(n);}

LISP append(LISP args)
{LISP l,s,tmp;
 s=car(args);
 if (NNULLP(s) && NCONSP(s))
    err("append",s,ERR_FIRST | ERR_NPAI);
 for(l=cdr(args);CONSP(l);l=CDR(l))
  {tmp=CAR(l);
   if (NNULLP(tmp) && NCONSP(tmp)) 
      err("append",tmp,ERR_GEN_ARG | ERR_NPAI);
   s=append_rec(s,tmp);}
 return s;}

LISP append_rec(LISP x,LISP y)
{LISP k,*z;
 if NULLP(x) return(y);
 k = cons(car(x),y);
 x = cdr(x);
 z = &CDR(k);
 while(CONSP(x))
  {*z = cons(CAR(x),y);
   x = CDR(x);
   z = &CDR(*z);}
 if(NNULLP(x)) err("improper list to append",x,ERR_GEN);
 return k;}

LISP appendI(LISP args)
{LISP l,s,tmp;
 s=car(args);
 if (NNULLP(s) && NCONSP(s)) err("append!",s,ERR_FIRST | ERR_NPAI);
 for(l=cdr(args);CONSP(l);l=CDR(l))
  {tmp=CAR(l);
   if (NNULLP(tmp) && NCONSP(tmp)) err("append!",tmp,ERR_GEN_ARG | ERR_NPAI);
   s=appendI_rec(s,tmp);}
 return s;}

LISP appendI_rec(LISP x,LISP y)
{LISP list=x;
 while (CONSP(cdr(list)))
   list = CDR(list);
 if(NNULLP(cdr(list))) err("improper list to append!",x,ERR_GEN);
 CDR(list) = y;
 return x;}

LISP llist(LISP x)
{return x;}

LISP dotlist(LISP args)
{LISP l,t;
 for(l=args,t=NIL;CONSP(cdr(l));t=l,l = CDR(l));
 CDR(t) = CAR(l);
 return args;}

LISP cxr(LISP x,LISP y)
{LISP l;
 char *p;
 if (NNULLP(x) && NCONSP(x)) err("cxr",x,ERR_FIRST | ERR_NPAI);
 if NSTRINGP(y) err("cxr",y,ERR_SECOND | ERR_NSTR);
 p=SNAME(y);
 l=x;
 while(*p && CONSP(l))
  {if(*p=='a')
    l=CAR(l);
   else if(*p=='d')
    l=CDR(l);
   else
    err("wrong string to cxr",y,ERR_GEN);
   p++;}
 return l;}

LISP last_pair(LISP list)
{if (NNULLP(list) && NCONSP(list)) err("last-pair",list,ERR_GEN_ARG | ERR_NPAI);
 while (CONSP(CDR(list)))
   list = CDR(list);
 return (list);}

LISP list_ref(LISP x,LISP y)
{LISP l;
 unsigned int n;
 if (NNULLP(x) && NCONSP(x)) err("list-ref",x,ERR_FIRST | ERR_NPAI); 
 if (NINTNUMP(y)) err("list-ref",y,ERR_SECOND | ERR_NINT);
 if (INTNM(y)<0) err("list-ref",y,ERR_IND_RAN);
 l=x;
 for(n=INTNM(y);n>0;n--)
  l=cdr(l);
 return (car(l));}

LISP lenght(LISP x)
{LISP z;
 if (NNULLP(x) && NCONSP(x)) err("length",x,ERR_GEN_ARG | ERR_NPAI); 
 z = intcons(leng(x));
 return (z);}

long leng(LISP x)
{LISP l;
 long n;
 l=x;
 for(n=0;CONSP(l);n++)
  l=CDR(l);
 return (n);}

LISP copy_list(LISP x)
{LISP y,*z;
 y = NIL;
 z = &y;
 while(CONSP(x))
  {*z = cons(copy_list(CAR(x)),NIL);
   x = CDR(x);
   z = &CDR(*z);}
 *z = x;
 return y;}

LISP delete(LISP x,LISP list)
{LISP *z,l;
 if (NNULLP(list) && NCONSP(list)) err("delete!",x,ERR_SECOND | ERR_NPAI); 
 for(l=list,z = &list;CONSP(l);l = CDR(l))
  {if(equal(CAR(l),x)==truth)
     *z = CDR(l);
   else
     z = &CDR(*z);}
 return list;}

LISP delq(LISP x,LISP list)
{LISP *z,l;
 if (NNULLP(list) && NCONSP(list)) err("delq!",x,ERR_SECOND | ERR_NPAI); 
 for(l=list,z = &list;CONSP(l);l = CDR(l))
  {if(EQ(CAR(l),x))
     *z = CDR(l);
   else
     z = &CDR(*z);}
 return list;}

LISP nullp(LISP x)
{if EQ(x,NIL) return(truth);
 return(NIL);}

LISP atomp(LISP x)
{if NCONSP(x) return(truth);
 return(NIL);}

LISP list_tail(LISP x,LISP y)
{LISP l;
 unsigned int n;
 if (NNULLP(x) && NCONSP(x)) err("list-tail",x,ERR_FIRST | ERR_NPAI); 
 if (NINTNUMP(y)) err("list-tail",y,ERR_SECOND | ERR_NINT);
 if (INTNM(y)<0) err("list-tail",y,ERR_IND_RAN);
 l=x;
 for(n=INTNM(y);n>0;n--)
  l=cdr(l);
 return (l);}

LISP assq(LISP x,LISP alist)
{LISP l,tmp;
 if (NNULLP(alist) && NCONSP(alist)) err("assq",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {tmp = CAR(l);
    if (CONSP(tmp) && EQ(car(tmp),x)) return(tmp);}
 if EQ(l,NIL) return(NIL);
 err("improper list to assq",alist,ERR_GEN);}

LISP assv(LISP x,LISP alist)
{LISP l,tmp;
 if (NNULLP(alist) && NCONSP(alist)) err("assv",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {tmp = CAR(l);
    if (CONSP(tmp) && eql(car(tmp),x)) return(tmp);}
 if EQ(l,NIL) return(NIL);
 err("improper list to assv",alist,ERR_GEN);}

LISP assoc(LISP x,LISP alist)
{LISP l,tmp;
 if (NNULLP(alist) && NCONSP(alist)) err("assoc",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {tmp = CAR(l);
    if (CONSP(tmp) && equal(car(tmp),x)) return(tmp);}
 if EQ(l,NIL) return(NIL);
 err("improper list to assoc",alist,ERR_GEN);}

LISP member(LISP x,LISP alist)
{LISP l;
 if (NNULLP(alist) && NCONSP(alist)) err("member",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {if (equal(CAR(l),x)) return(l);}
 if EQ(l,NIL) return(NIL);
 err("improper list to member",alist,ERR_GEN);}

LISP memq(LISP x,LISP alist)
{LISP l;
 if (NNULLP(alist) && NCONSP(alist)) err("memq",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {if (EQ(CAR(l),x)) return(l);}
 if EQ(l,NIL) return(NIL);
 err("improper list to memq",alist,ERR_GEN);}

LISP memv(LISP x,LISP alist)
{LISP l;
 if (NNULLP(alist) && NCONSP(alist)) err("memv",x,ERR_SECOND | ERR_NPAI); 
 for(l=alist;CONSP(l);l=CDR(l))
   {if (eql(CAR(l),x)) return(l);}
 if EQ(l,NIL) return(NIL);
 err("improper list to memv",alist,ERR_GEN);}
