






- The Bonk Language Specification v1.0
- Created 8th June 1999
- (C) 1999-2000 Mr Tickle/Darkage (mrtickle@amiga4k.ndo.co.uk)









*** CONTENTS ***************************************************************

Contents

 1. Introduction
 
   1.0 About this document
   1.1 What is Bonk?
 
 2. The basics of Bonk
 
   2.0 Basic syntax rules
   2.1 Numeric expressions and Integer variables
   2.2 String expressions and String variables
   2.3 Labels and branching
   2.4 Boolean expressions and Condition testing
   2.5 Stack usage
   2.6 Dynamic Memory Allocation and Pointers
   
 3. Bonk reference
 
   3.0 Complete Bonk commandlist
 

*** CHAPTER ONE ************ INTRODUCTION **********************************

1.0 About this document
-----------------------

This document describes in detail the programming language "bonk". It does
not, however, include information on how to use any specific bonk
interpreter. For this information, refer to the document(s) included with
the interpreter for your specific machine.

This is the first revision of the Bonk specification. Please report any
errors or omissions to lumpbucket@yahoo.com.



1.1 What is Bonk?
-----------------

Bonk is a programming language. It is not particularily flexible, modern,
structured or readable. It is not object oriented and does not utilise
any industry standard API's. It doesnt support graphics, printing,
peripherals, or even filing. Bonk was created purely as a novelty language
of interest only to people who like to play with and collect programming
languages. If you liked FALSE or BRAINF**K, you'll probably like Bonk too :)

On the positive side, Bonk is a simple language to learn, its relatively
small command set can be used by clever programmers to achieve good
results, and it can be written as readably or obfuscated as you like.




*** CHAPTER TWO ************ THE BASICS OF BONK ****************************

2.0 Basic syntax rules
----------------------

In this document, the "Program" refers to the source being run through
the interpreter. A "Command" is a single action bonk can perform; they
are the building blocks of bonk (like procedures or functions). An
"Argument" is a parameter or option for a bonk command.

Bonk programs are run through an interpreter, rather than compiled. They
are stored in standard text files. You can put as many spaces, tabs,
comments, and carriage returns in the sourcecode as you like, because
they are all stripped before the program is run.

All commands are seperated by 1 (and only 1!!) semi colon. All commands
are one letter followed by arguments, and must be lower case. For example,
here is the classic "hello world" program in Bonk:

o"Hello, World!\n";

The "o" at the start is the command, which is short for "Output".
Comments in Bonk are stored between { and }, and they DO NOT NEST!!



2.1 Numeric expressions and Integer variables
---------------------------------------------

All numbers expressed in Bonk are signed 32bit longwords and are only
expressed in decimal. Bonk provides you with 26 32bit integer variables.
These are denoted with the percent (%) symbol, and range from %a to %z.
Upper case charactors CANNOT be used when refering to variables.

Bonk provides no "make equal to" operator for integer variables. To assign
a specific value to a bonk variable, you can do the following:

%a-%a+10;

This makes %a equal to %a-%a (which is 0) +10 (which is 10). This method
allows us to easily do things such as increment a variable:

%a+1;

There are a variety of operators which you can apply to ANY numeric
expression in bonk, and they are listed in this table:

        OPERATOR       DESCRIPTION                   EXAMPLE
        
           +           Add                           %a+1;
           -           Subtract                      %a-1;
           *           Multiply                      %a*2;
           /           Divide                        %a/2;
           «           Shift left                    %a«2;
           »           Shift right                   %a»2;
           !           Modulo                        %a!5;
           
All numeric expressions are evaluated left to right, but any brackets
are done first. Here are some example of valid expressions:

         EXPRESSION    ACTUAL VALUE
         
            10           10
            1+2*3        9
            1+(2*3)      7
            (1)          1
            
            

2.2 String expressions and String variables
-------------------------------------------

The start and end of strings are denoted by double quotes ("). Strings
can contain any ASCII charactor, but some charactors have special meanings,
as will be discussed a little later.

Bonk provides you with 26 string variables, which are denoted by the
dollar sign ($), and range from $a to $z. To assign a string of charactors
to a string variable, you use the equals sign (=), as shown:

$a="Hello";

At any point in any string, you can insert the contents of any string
or integer variable, simply by including its name. For example:

%a-%a+19;
$n="Peter";
$a="$n is %a years old";

Would make $a contain "Peter is 19 years old". Sharp eyed readers will
have spotted a limitation of this method; it would appear that you cannot
include a percent or dollar sign in strings, but Bonk has a trick up its
sleeve. The backslash (\) charactor is used in strings to insert other
"special" charactors. What is inserted in the string depends on what
follows the backslash. For example:

$a="100\% of people interviewed said Amiga rulez!";

Would make $a contain "100% of people interviewed said Amiga rulez!".
Here is a table showing what can be done with the backslash in strings:

       THIS...         WOULD INSERT
       
         \\                 \
         \$                 $
         \%                 %
         \n             Line Feed (10 on amiga; 13,10 on PC etc.)
         \e             ESC (char 27)

Another useful feature of string variables is that each charactor in
a string variable can also be used as an 8bit unsigned integer, by
making use of square brackets ("[" and "]"). For example:

$a[0]-$a[0]+65;     { makes $a start with the charactor "A" }
$a[%c+(2*%d)]*2;



2.3 Labels and branching
------------------------

A label is a position in a program which can be directly jumped to from
elsewhere. A label is marked with a ":" prefix, and is jumped to with
the "j" command. Labels can be any length you like, and are case
sensitive. Examples:

j skip;
o "This will never happen\n";
:skip;
o "But this will\n";



2.4 Boolean expressions and Condition testing
---------------------------------------------

All boolean equations are surrounded by brackets ( "(" and ")" ). You
can compare numeric expressions and string expressions with similar types
but not with each other. When comparing numeric expressions, you can
use the following comparators:

    COMPARATOR      DESCRIPTION
    
        =           Equal to
        !=          Not equal to
        >           Larger than
        <           Smaller than
        >=          Larger than or equal to
        <=          Smaller then or equal to
        
String comparisions can only use "=" and "!=", and the strings themselves
are ALWAYS contained within double quotes ("), for example:

("$b"="Hello")     { compares $b with Hello }

All boolean equations can be negated with the "!" operator, like this:

!(%a=%b)

Boolean equations can be joined with & (AND) or | (OR), like this:

((%a=1)&(%b=2))    { %a is 1, AND %b is 2 }
((%a=1)|(%b=2))    { %a is 1, OR %b is 2 }

Boolean expressions are evaluated with the "i" command. If the condition
being tested by "i" is found to be TRUE, the command that follows it
will be executed, otherwise it will be skipped. For example:

i(%a=1);o"If you can read this, \%a is 1!";

This is mostly used with the j command to provide conditional branching.

Here are some complex examples:

i((%a>=10)&("$b"="Lard"));jBlah;

^^^ Jumps to Blah if %a is larger than 10, and $b contains Lard.

i((%a>%b)&!((%c=%d)|(%e=%d)));jOok;

^^^ Jumps to ook if (%c=%d or %e=%d) is false and %a is larger than %b.



2.5 Stack Usage
---------------

The Bonk language also provides a stack facility to programs. This is
utilised via the "s" command. To push data onto the stack, we use
"s<data" and to pop data from the stack we use "s>variable".

You can push numbers, integer variables, labels and a special identifier
"pc". You can pop to integer variables, and to the special "pc" identifier.
"pc" is the program counter, much like the program counter on a cpu.
Although Bonk allows you to pop values from the stack to the pc, it is
important you only pop LABELS into pc, as it is impossible to pre-calculate
the "pc" location of a specific point in a program.

Valid push examples:

s<10;   { push 10 onto the stack }
s<%a;   { push %a onto the stack }
s<$n[2];
s<pc;   { push current pc onto the stack }
s<:end; { push the pc location of the label "end" onto the stack }



Valid pop examples:

s>%a;
s>pc;
s>$n[3];



You cant do the following:

s<100;
s>pc;    { this is now pointing somewhere crazy!!!! }

s>10;    { this makes no sense anyway :) }



Useful applications of the stack:

s<:label;
s>pc;      { jump to label using the PC }

s<10;s>%a; { alternative to %a-%a+10 }


The stack also provides a way of doing subroutines:

s<:return;jsubroutine;:return;
s<;return2;jsubroutine;:return2;
jend;

:subroutine;
o"This is a subroutine";
s>pc;

:end;
o"The End";



2.6 Dynamic Memory Allocation and Pointers
------------------------------------------

As well as the 26 string and variable pointers provided by bonk, you can
also dynamically allocate extra memory areas, and use integer variables
as pointers to access them. To allocate memory, we use the "a" command,
as follows:

a<memory size>,<integer variable>

Where <memory size> is the amount of memory to allocate and <integer
variable> is the variable to use when referencing this memory, for
example:

a1024,%a;

Would allocate 1k of memory and store a pointer to it in %a. This memory
will automatically be free'd when the bonk program exits, but to free it
manually we would use the "f" command, like this:

f%a;

To reference the memory, we use the integer variable like this:

%a[<offset>].x

where <offset> is the number of bytes from the start of the memory
allocation and .x is .b, .w, or .l (byte, 16 bit word, 32 bit word
respectively).

Examples:

a%s,%a;     { Allocate %s bytes and store pointer in %a }

s<%a[0].w;  { Push 16 bit word at start of memory block }
s>%a[10].w; { Pull 16 bit word to offset 10 }
s<%a[12].b; { Push byte at offset 12 (we still push 32bits, only 8 used) }
s>%a[24].l; { Pull long to offset 24 }

f%s;        { Free %s }

Remember that a full 32bit word is always pushed to or pulled from the
stack. If you push a 16bit word, the upper 16bits will be 0. If you pull
a 16bit word, the upper 16bits will be discarded. So, if you push -1.w,
and pull a longword, you'll get 65535, not -1.



*** CHAPTER THREE ********** BONK REFERENCE ********************************

3.0 Complete Bonk command list
------------------------------

 ==========================================================================

  : = Label
  
  This defines a label which can be jumped to with the j command.
  SEE ALSO "j"

 ==========================================================================

  a = Allocate memory block
  
  Allocates a block of memory and stores pointer in specified variable.
  Example:
  
  a2048,%a;      { Allocate 2048 bytes and store pointer in %a }
  
  SEE ALSO "f"

 ==========================================================================

  f = Free allocated memory block
  
  Frees a memory block allocated with the "a" command. If you try and
  free a pointer to memory that wasnt allocated with "a", it will report
  an error. example:
  
  f%a;  { free memory pointed to by %a }

 ==========================================================================

  g = Get byte from keyboard

  Gets a byte from the keyboard to a variable. Examples:

  g%a;       { Get byte into %a }
  g$a[%c];   { Get byte into element %c of $a }

 ==========================================================================

  i = If
  
  This tests a boolean expression. If the result is found to be true,
  the next command will be executed, otherwise it will be skipped.
  For example:
  
  i(%a=10);o"A is 10!";
  i!(%a=10);o"A is not 10!";

 ==========================================================================
  
  j = Jump
  
  This jumps to a label which has been defined with ":". For example:
  
  j skip;
  o "This will never happen\n";
  :skip;
  o "But this will\n";
  
 ==========================================================================
  
  o = Output string
  
  This outputs a string to the output window. For example:

  o"Hello, World\n";
  
 ==========================================================================

  r = Random
  
  This command puts a random number into the specified variable. The
  contents of this variable beforehand defines the maximum value of
  the number. For example:
  
  s<10;s>%a;
  r%a;         { %a now contains a random number from 0 to 10 }
 
 ==========================================================================
 
  s = Stack operation

  There are two stack operations, push and pull. To push something on the
  stack do:

  s<%a;

  To pull it back do:

  s>%a;

  You can push numbers, integer variables and a special identifier "PC" which
  is bonk's internal program counter. You can pull from the stack into
  integer variables or the "PC". You can also push "PC" addresses of labels.
  If you try to push a non existant label, you will push "zero".
  More examples:

  s<10;s>%a; { alternative to %a-%a+10 }
  s<pc;      { push pc on stack }
  s<:loop;   { push address of loop on the stack }

  With this command you can do subroutines:

  s<:return;jsubroutine;:return;
  s<:return2;jsubroutine;:return2;
  jend;

  :subroutine;
  o"Hello from subroutine!\n"
  s>pc;

  :end;
  
