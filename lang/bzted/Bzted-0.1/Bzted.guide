@DATABASE Bzted.guide
@$VER: Bzted.guide 0.1 (22.11.2025)
@AUTHOR: Grzegorz Kraszewski
@WORDWRAP
@WIDTH 80

@NODE Main "Bzted"
@{B}Bzted 0.1@{UB}
@{B}---------@{UB}

Recreational, stack based, concatenative programming language for m68k Amiga.

  @{" Language Features " LINK features}
  @{" Language Elements " LINK elements}

@{B}Installation@{UB}

Bzted requires no particular installation. Just copy it whereever you want.

@{B}Hello world!@{UB}

  main: { "Hello world!\\n" PutStr }

@{B}Usage@{UB}

  Bzted <source> [TO=<file>]

Bzted compiler compiles Bzted source into assembler source. Resulting assembler code is then assembled by an external assembler to executable file. Optional TO argument specifies name of the output file. If not given, Bzted takes the souce file name, removes ".bzt" extension if exists, then appends ".s" extension.

Vasm, GenAm and PhxAss have been tested as external assemblers.

Compiling with Vasm:

  Bzted helloworld.bzt
  Vasm -Fhunkexe -o helloworld helloworld.s

Compiling with GenAm:

  Bzted helloworld.bzt
  GenAm helloworld.s

Compiling with PhxAss:

  Bzted helloworld.bzt
  PhxAss helloworld.s
@ENDNODE

@NODE features "Language Features"
@{B}Language Features@{UB}
@{B}-----------------@{UB}

@{B}Stack based@{UB}

A program in Bzted consists of sequences of operators, which pull arguments from the data stack and push results back on the data stack. There are no standalone variables.

@{B}The standard library@{UB}

Bzted is strongly Amiga oriented, it has no abstract standard library, but instead the whole Amiga OS API (with a few exceptions) is its standard library. Let's repeat "Hello world" in Bzted:

  main: { "Hello world!\\n" PutStr }

In this example 'PutStr' is a system call from 'dos.library'. At the same time it is a Bzted operator, pulling a single string from the stack, printing it to the default output and putting success value back to the stack.

@{B}Static analysis@{UB}

Bzted is designed in a way, which allows deep static analysis of the code at compile time. For example size of the data stack may be precisely calculated by the compiler. It may also detect stack undeflows and other errors in the code.

@{B}Free code formatting@{UB}

The source code is a series of tokens. Tokens must be separated by at least one whitespace character. Whitespace characters are: space (ASCII 32), horizontal tab (ASCII 9), line feed (ASCII 10) and carriage return (ASCII 13). Whitespaces have no other purpose and may be used freely to format the code.

For people, who hate whitespaces around parentheses (inside or outside), there is an exception in the token separation rule. Parentheses-like operators '[ ] { }' have "implied" whitespaces before and after, so real whitespaces may be omitted.
@ENDNODE

@NODE elements "Language Elements"
@{B}Language Elements@{UB}
@{B}-----------------@{UB}

  @{" Comments     " LINK comments}
  @{" Numbers      " LINK numbers}
  @{" Strings      " LINK strings}
  @{" Functions    " LINK functions}
  @{" Data frames  " LINK dataframes}
  @{" Operators    " LINK operators}
  @{" System calls " LINK syscalls}
@ENDNODE

@NODE comments "Comments"
@{B}Comments@{UB}
@{B}--------@{UB}

'//' characters anywhere in a line start a comment to the end of line. An obvious exception is `//` sequence inside a string literal.

  // This is a full line comment.
  foo: {
    1         // pushes 1 on the stack
    +         // pulls two items from the stack, adds and pushes back
    "Inside a string // do not start a comment"
  }

Comments are eliminated very early in the complilation process, so their impact on compilation speed and compiler memory footprint is minimal.
@ENDNODE

@NODE numbers "Numbers"
@{B}Numbers@{UB}
@{B}-------@{UB}

A number in the code is an operator, which just put the number on the stack. Numbers in Bzted are 32-bit signed integers.

@{B}Decimal numbers@{UB}

Decimal numbers use usual notation, without any grouping separators. Negative numbers are prefixed with '-'. There should be no whitespaces between '-' and the first digit.

Optional '+' for positive numbers is allowed. Any number of leading zeros is allowed. Examples:

  38
  -938
  00003
  -00003
  +179
  93728732874784 // compiler error, outside of 32-bit signed range

@{B}Hexadecimal numbers@{UB}

Hexadecimal numbers are prefixed with '$', without any spaces. 'A-F' digits are case insensitive.

Minus sign is not allowed. Hexadecimal notation just describes a bit pattern of the number, so -1 is denoted as $FFFFFFFF.

Leading zeros are allowed.

  $0f
  $3AdEb       // mixed case, bad practice, but allowed
  $-4F         // error
  -$4F         // error

@{B}Binary numbers@{UB}

Binary numbers are prefixed with '%', without any spaces.

Minus sign is not allowed. Binary notation just describes a bit pattern of the number, so -1 is denoted as %11111111111111111111111111111111.

Leading zeros are allowed.

  %101
  %0
  %00001010
  -%0101       // error
  %-011101     // error

@ENDNODE

@NODE strings "Strings"
@{B}Strings@{UB}
@{B}-------@{UB}

A string literal is an operator, which places @{B}address@{UB} of the string on the stack. The string itself is a static object, existing for the whole execution of a program.

Strings may be delimited with apostrophes or doublequotes. When using apostrophes, doublequotes may be placed inside the string and vice versa.

  'A string.'
  "Another string."
  'This string can contain "doublequotes".'
  "This string can contain 'apostrophes'."

@{B}Multiline strings@{UB}

Strings can span multiple lines. Newline characters are literally put in the resulting string.

  'A
  B
   C'

Byte representation of the above string is hexadecimal `41 0A 42 0A 20 43 00`. Note how the space before 'C' has been put in the string too. Note also that strings in Bzted are null-terminated like in C language.

@{B}Charset encoding@{UB}

Classic Amiga does not support Unicode, but uses (mostly) ISO-8895 codepages. Bzted, as many programming languages for Amiga is "encoding ignorant", so it just uses a local codepage.
@ENDNODE

@NODE functions "Functions"
@{B}Functions@{UB}
@{B}---------@{UB}

Function in Bzted is an user defined operator. A function consists of a series of operators (built-in, user defined or system calls) enclosed in curly brackets. Such a function is anonymous, Bzted assigns some generated unique name to it. One can name a function, putting a name suffixed by colon before the function body.

  { 4 + }                // anonymous function
  func: { : + 89 + }     // function named "func"

Anonymous functions are used for conditional operator and loop operators.

A named function is just an operator, so can be used in other functions by its name.

  other: { 11 func 2 - }

@{B}Names@{UB}

Bzted itself allows for using almost any characters in function names. Obvious exceptions are whitespaces. Less obvious are '[]{}'. These characters have "implied spaces" around them, so effectively cut a name into meaningless parts. Comment marker '//' is another exception. String delimiters (apostrophe, doublequote) won't work too.

Current version of Bzted passes function names as labels to assembler unmodified. It means using funny characters in a function name can trigger assembler errors. On the other hand it limits possibility of overriding built-in operators, so some name encoding mechanism will be added in the future. For now limit yourself to letters, digits and underlines.

@{B}Name overriding@{UB}

User defined operators have precedence over built-in ones and system calls of the same name. While it sounds interesting, note that it is not overloading by types of arguments (as in C++), because Bzted is a typeless language, at least for now.

@ENDNODE

@NODE dataframes "Data Frames"
@{B}Data Frames@{UB}
@{B}-----------@{UB}

A data frame in Bzted is another kind of user defined operator. The difference in notation is to use square brackets instead of curly ones. The same as functions, data frames can be anonymous or named.

While a function puts its results on the stack, results of a data frame are stored in a preallocated memory area. Then, the @{B}address@{UB} of this area is put on the stack. A data frame operator has one result always, regardless of the number of values stored.

Anonymous data frames are useful for these system calls, which in C/C++ are variadic functions. For example Printf() call is defined in C as:

  LONG Printf(STRPTR format, ...)

In fact it gathers all arguments following 'format' in an array of 32-bit values and calls the real function, VPrintf() with address of this array:

  LONG VPrintf(STRPTR format, LONG *args)

In Bzted we have data frames for this, so it has just Printf, not VPrintf:

  "%s is %ld years old.\n" [ "John" 37 ] Printf

Another application of data frames is a taglist. It is an array of 32-bit values after all. Again C/C++ have two forms of taglist based functions: variadic one (without any suffix, or ending with "Tags"), and one taking an address of a taglist (ending with "A" or "TagList"). Bzted has only the first form:

  NULL [ WA_Width 500 WA_Height 300 WA_Title "Test window" TAG_END ] OpenWindowTags

@ENDNODE


@NODE syscalls "System Calls"
@{B}System Calls@{UB}
@{B}------------@{UB}

Selected AmigaOS system calls are treated as regular Bzted operators. They pop arguments from the stack and push results there. Order of arguments and results is the same as in the system AutoDocs. For example system function AllocMem() is defined in AutoDocs as follows:

  memoryBlock = AllocMem(byteSize, attributes)

In Bzted 'AllocMem' expects two arguments on the stack. Integer byte size should be put first, then integer attributes. The operator pulls these two arguments, then puts address of the allocated block on the stack. Example of calling it in Bzted:

  620 MEMF_ANY AllocMem

@{" List of recognized system calls " LINK callslist}

@{B}Opening and closing system libraries@{UB}

Opening and closing system libraries used is fully automatic. There is no need to declare anything or call OpenLibrary() by hand. The compiler reports a list of libraries used, with their minimal versions.

@{B}Unexpected results on the stack@{UB}

Unlike in C/C++, a return value of a system call (or any other function) can't be simply ignored. If it is not used, it has to be removed from the stack explicitly using '\\' operator. Common examples are Printf(), PutStr() and Close(). All of them do return a value, and this value is pushed on the stack.

@{B}Variable arguments@{UB}

@{"Data frames" LINK dataframes} are used to solve this problem.
@ENDNODE

@NODE callslist "List of recognized system calls"
@{B}System Calls@{UB}
@{B}------------@{UB}

Name             Library           MinVer  Args Results
-------------------------------------------------------
AllocMem         exec.library        33      2     1
Close            dos.library         33      1     1
CloseLibrary     exec.library        33      1     0
CloseWindow      intuition.library   33      1     0
Delay            dos.library         33      1     0
DisplayBeep      intuition.library   33      1     0
FGets            dos.library         36      3     1
FindTask         exec.library        33      1     1
Forbid           exec.library        33      0     0
FreeArgs         dos.library         36      1     0
FreeMem          exec.library        33      2     0
GetMsg           exec.library        33      1     1
IoErr            dos.library         33      0     1
Open             dos.library         33      2     1
OpenLibrary      exec.library        33      1     1
OpenWindowTags   intuition.library   36      2     1
PrintFault       dos.library         36      2     1
Printf           dos.library         36      2     1
PutStr           dos.library         36      1     1
Read             dos.library         33      3     1
ReadArgs         dos.library         36      3     1
ReplyMsg         exec.library        33      1     0
Seek             dos.library         33      3     1
WaitPort         exec.library        33      1     1
@ENDNODE

@NODE operators "Operators"
@{B}Operators@{UB}
@{B}---------@{UB}

Everything in Bzted is an operator. Operator may pop some values from stack, perform some operations on them and put results back onto the stack. There are three kinds of operators in Bzted:

  * User defined operators (known as @{"functions" LINK functions} and @{"data frames" LINK dataframes}),
  * System @{"calls" LINK syscalls},
  * Built-in operators, described below.

@{U}NOTE@{UU}: User defined operators override built-in ones and system calls of the same name. As usual with overriding, be sure you know, what you are doing. Note also that overriding a system call with your operator does not patch the operating system, it works only in your program.

  @{" Program flow control " LINK operators-flowcontrol}
  @{" Memory reading       " LINK operators-memread}
  @{" Arithmetic           " LINK operators-arithmetic}
  @{" Bit shifts           " LINK operators-bitshift}
  @{" Stack manipulation   " LINK operators-stack}

@ENDNODE

@NODE operators-flowcontrol "Program Flow Control Operators"
@{B}Program Flow Control Operators @{UB}
@{B}------------------------------ @{UB}

@{B}Conditional operator '?' @{UB}

The conditional operator must be followed by two code blocks (any of them may be also a data frame). The operator pops a value from the data stack. If it is not zero, the first code block is executed. The second block is executed otherwise.

  ? {@{I} if-block @{UI}} {@{I} else-block @{UI}}

Both the code blocks must have the same stack balance.

@{B}"while" loop operator '@>' @{UB}

The operator must be followed by one code block. The operator keeps popping a value from the stack, testing it against zero and executing the code block as long as the value tested is not zero. If it becomes zero, the block is skipped and execution continues after it.

  @> {@{I} loop-block @{UI}}

The loop can be executed zero or more times.

The loop code block must have the stack balance of 1, so the whole loop has the stack balance of 0.

@{B}"do-while" loop operator '<@' @{UB}

The operator is placed after a code block. The operator keeps popping a value from the data stack, testing it against zero and executing the code block as long as the value tested is not zero. If it becomes zero, execution continues after the operator.

  {@{I} loop-block @{UI}} <@

The loop is executed at least once.

The loop code block must have the stack balance of 1, so the whole loop has the stack balance of 0.
@ENDNODE

@NODE operators-memread "Memory Reading Operators"
@{B}Memory Reading Operators @{UB}
@{B}------------------------ @{UB}

The basic memory read operator is '*'. It pops a value from the the data stack and treats is as a memory address. It loads a 32-bit value from memory and pushes it onto the stack.

A set of versions of this operator is used to read shorter values (for example members of system structures):

  @{B}*b @{UB}- reads a signed byte and sign-extends it to 32 bits.
  @{B}*w @{UB}- reads a signed word and sign-extends it to 32 bits.
  @{B}*B @{UB}- reads an unsigned byte and zero-extends it to 32 bits.
  @{B}*W @{UB}- reads an unsigned word and zero-extends it to 32 bits.

@ENDNODE

@NODE operators-stack "Stack manipulation operators"
@{B}Stack manipulation operators @{UB}
@{B}---------------------------- @{UB}

@{B}Item removal - '\\' operator @{UB}

This operator removes the top item from the data stack and discards it.

@{B}Item duplication - ':' operators @{UB}

Basic operator for duplicating a stack item is ':'. It creates a copy of the top element and puts it on the top of stack.

One can also duplicate the second, the third and the fourth item on the stack, using operators ':2', ':3' and ':4' respectively. All of them put created copy on the top of stack.

Original   After  After  After  After
 stack       :      :2     :3     :4

             A      B      C      D
    A        A      A      A      A
    B        B      B      B      B
    C        C      C      C      C
    D        D      D      D      D

Each of these operators is a standalone entity, not one operator with a parameter. Operators like ':5' and so on are not defined.

@{B}Item extraction - '.' operators@{UB}

Extraction operators remove an item from the stack, and put it on the top of stack, without copying. It makes no sense for the top stack item, so '.' or '.1' operator is not defined. '.2' operator exchanges two top items of the stack (called "flip" in some languages).

Original   After  After  After
 stack       .2     .3     .4

    A        B      C      D
    B        A      A      A
    C        C      B      B
    D        D      D      C

Some languages call this operation "stack rotate left" by analogy to bit rotation instruction in a microprocessor.

@{B}Item insertion - ',' operators@{UB}

Insertion operators pull an item from the top of stack, and insert it lower in the stack, so it becomes an n-th item. No item copy is created. It makes no sense for the top stack item, so ',' or ',1' operator is not defined.
',2' operator exchanges two top items on the stack, so it is an equivalent of '.2'.

Original   After  After  After
 stack       ,2     ,3     ,4

    A        B      B      B
    B        A      C      C
    C        C      A      D
    D        D      D      A

Some languages call this operation "stack rotate right" by analogy to bit rotation instruction in a microprocessor.
@ENDNODE

@NODE operators-arithmetic "Arithmetic Operators"
@{B}Arithmetic Operators@{UB}
@{B}--------------------@{UB}

@{B}Addition '+'@{UB}

Removes two top values from the stack, adds them, puts result on the stack. Standard 32-bit addition with overflow.

4 9 +            // result: 13
-1 2 +           // result: 1
2147483647 2 +   // result: -2147483647 due to overflow

@{B}Subtraction '-'@{UB}

Removes two top values from the stack and subtract the top value from the second to top. Standard 32-bit subtraction with overflow.

4 9 -            // means 4 - 9 = -5
17 -6 -          // means 17 - (-6) = 23

@ENDNODE

@NODE operators-bitshift "Bit Shifting Operators"
@{B}Bit Shifting Operators@{UB}
@{B}----------------------@{UB}

@{B}Arithmetic shift left '<~'@{UB}

The top of the data stack is number of bytes to shift, the second value on the stack is one to be shifted. Shift result is pushed on the stack. New bits coming in from the right are zeros.

@{B}Arithmetic shift right '~>'@{UB}

The top of the data stack is number of bytes to shift, the second value on the stack is one to be shifted. Shift result is pushed on the stack. New bits coming in from the left are copies of bit 31 (the sign bit).

@ENDNODE
