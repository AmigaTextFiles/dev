;; FILE		"Gambit:docs/QuickTour"
;; IMPLEMENTS	An overview of the Gambit release 1.8 for AmigaDOS 1.3/2.0
;; AUTHOR	Kenneth A Dickey
;; DATE		1992 October 2
;; LAST UPDATED	1992 October 3


SYNOPSIS:
  INTRODUCTION
  INVOCATION & OPTIONS
  THE READ-EVAL-PRINT LOOP (Example)
  FUNCTION SYNOPSIS
  STANDARDS REFERENCES



=== INTRODUCTION ===

This is Gambit release 1.8 for the Amiga with AmigaDOS 1.3 or 2.0.
This is a full implementation of Scheme with some extensions.  It
conforms to IEEE P1178 and the Revised^4 Report on the Programming
Language Scheme (see REFERENCES, below).  The interpreter requires 1.5
MB and the compiler requires 3 MB of RAM to run (see INVOCATION &
OPTIONS, below).  This document is a quick overview/reference of the 
Gambit Scheme system, not a Scheme tutorial.



=== INVOCATION & OPTIONS ===


INVOCATION

To invoke the interpreter, put it in your C: directory, "assign SCM:
<your scheme source directory>" and type the interpreter's name from
the CLI (see INVOCATION OPTIONS, below).  I usually name the
interpreter "gsi".  You may want to name it "scheme".

There are several variants of the Gambit Scheme Interpreter to use:

  "gsi.68020+FPU" requires a 680[234]0 with floating point processing.

  "gsi.68k.emu" requires only a 68000 and does floating point (and 020)
    emulation. 

  "gsi.68k.small.emu" is like gsi.68k.emu, but loads the runtime from
    disk to save space.  It loads in 1.25 MB rather than in gsi.68k.emu's
    1.52 MB.  This version expects to load the runtime files from a
    directory "GAMBIT:runtime", so if you copy files to a hard disk, you
    should do the proper ASSIGN statement ("assign GAMBIT: <whatever>").
    The other versions have the runtime linked as part of the executable. 

Gsi looks for a file "init.scm" first in your S: directory, then in
the current directory.  If it finds such a file, it loads it and then
brings up the read-eval-print loop (REPL) prompt.


OPTIONS

You can invoke gsi with a simple command string to get a result:

> gsi "(/ 610728 1024.)"
596.4140625
>

All option flags are preceeded by "--".  The most important flags are
those which control how much heap space to allocate.

There are 2 heaps: a static heap and a dynamic heap.  

The static heap is where all compiled code is loaded.  Compiled code
module names by convention end in ".O", source code modules in ".scm",
so "foo.scm" compiles into "foo.O".  The runtime system requires ~340
KB.  The compiler requires an additional 600 KB.  To set the static
heap use the "-c" flag followed by the number of KB you want.  The
static heap is *not* garbage collected.

The dynamic heap holds all your dynamic data structures (interpreted
code and your data).  Make it as big as you can afford.  To set the
dynamic heap, use the "-h" flag followed by the number of KB you want.
Note that the dynamic heap is garbage collected and is divided into 2
subheaps or "semi-spaces" (A Stop-and-Copy collector is currently
used).  This means that if you allocate 500 KB to your dynamic heap,
your live data will be up to 250 KB.  Note that the interpreter also
allocates (malloc's) space for its own internal data structures.

Example: 
> gsi -- -h2000 -c1000
allocates 2 one-megabyte semispaces for the dynamic heap and reserves
one megabyte for loading compiled code (e.g. the compiler).

See file "docs/gsi.man" for further details and options.



=== THE READ-EVAL-PRINT LOOP (Example) ===

>gsi

Gambit (v1.8)

: (define (fact x)
    (cond ((= x 0) 1)
          ((= x 1) 1)
          ((> x 1) (* (fact (- x 1)) x))
          (else    (error "argument must be positive"))))
fact

: (trace fact)
fact

: (fact 10)
Entry (fact 10)
|Entry (fact 9)
| Entry (fact 8)
|  Entry (fact 7)
|  |Entry (fact 6)
|  | Entry (fact 5)
|  |  Entry (fact 4)
|  |  |Entry (fact 3)
|  |  | Entry (fact 2)
|  |  |  Entry (fact 1)
|  |  |  ==> 1
|  |  | ==> 2
|  |  |==> 6
|  |  ==> 24
|  | ==> 120
|  |==> 720
|  ==> 5040
| ==> 40320
|==> 362880
==> 3628800
3628800

: (untrace fact)
fact

: (pp fact)	;; NOTE: 'x is alpha-converted to 'x.1 by the macro-expander
(lambda (x.1)
  (cond ((= x.1 0) 1)
        ((= x.1 1) 1)
        ((> x.1 1) (* (fact (- x.1 1)) x.1))
        (else (error "argument must be positive"))))
#f

: (define f fact)
f

: (define fact "not the factorial function")
fact

: (f 5)
*** ERROR IN f -- Operator is not a PROCEDURE
(fact (- x 1))

1: ,?
,?        : Summary of commands
,+ and ,- : Move to next or previous frame of continuation
,<n>      : Move to particular frame (<n> <= 0)
,b        : Display frames of continuation (i.e. backtrace)
,p        : Display procedure attached to current frame
,e        : Display subproblem of current frame
,l        : Display list of local variables accessible in current frame
,t        : Transfer to top-level REP loop
,d        : Transfer to previous REP loop
,r        : Return from REP loop
,q        : Quit

1: ,b
0    f                         (fact (- x 1))
-1   (top level)               (f 5)
-2   ##read-eval-print
-3   ##dynamic-env-bind
-4   ###_kernel.startup

1: ,p
#[procedure f] =
(lambda (x.1)
  (cond ((= x.1 0) 1)
        ((= x.1 1) 1)
        ((> x.1 1) (* (fact (- x.1 1)) x.1))
        (else (error "argument must be positive"))))

1: ,l
x.1 = 5

1: (- x.1 1)
4

1: fact
"not the factorial function"

1: (set! fact f)
#[undefined]

1: ,r (fact (- x.1 1))
120

: (list (gensym) (gensym) (gensym))
(g1 g2 g3)

: (put 'bob 'eyes 'blue)
#f

: (put 'mary 'hair 'blond)
#f

: (get 'bob 'eyes)
blue

: (get 'mary 'eyes)
#f

: (define (series term)
    (let ((sum 0) (stop #f))
      (FUTURE (let loop ((i 0))
                (if (not stop)
                  (begin (set! sum (+ sum (term i))) (loop (+ i 1))))))
      (lambda (msg)
        (cond ((eq? msg 'value) sum)
              ((eq? msg 'stop)  (set! stop #t))
              (else             (error "unknown message" msg))))))
series

: (define pi (series (lambda (i) (/ 4. ((if (odd? i) - +) (+ (* i 2) 1))))))
pi

: (pi 'value)
3.141419882340216

: (pi 'value)
3.1415194471477133

: (pi 'value)
3.1416300745380195

: (pi 'value)
3.1415798589941843

: (pi 'stop)
#[undefined]

: (pi 'value)
3.1415815090449892

: (pi 'value)
3.1415815090449892

: ,q





=== FUNCTION SYNOPSIS ===


Here is a quick reference of the signatures of provided functions.
Aside from Extensions, there is no attempt at completeness.  It is
assumed that the user has a copy of R^4RS or the IEEE/ANSI standard.

Notation:
  <object>	any Scheme data object.
  <object>*	zero or more objects
  <object>+	one or more objects
  [<object>]	optional object


; EXTENSIONS

  (EXIT) -- exit the interpreter.

  (##SYSTEM <string>) -- Executes CLI command string
    e.g. (##system "dir #?.scm")

  (TRACE <proc>+ )   -- turns trace on  for <proc>(s) {SYNTAX}.
  (UNTRACE <proc>* ) -- turns trace off for <proc>(s) {SYNTAX}.  With
    no <proc> specified, turns off tracing for all trace'd procedures.

  (ERROR <message> <object>* ) -- invokes the debugger.  ",?" for help.

  (PP <object> [<output-port> [<width>]]) -- Pretty print object.  
    Prints source for interpreted code.

  (PRETTY-PRINT <object> [<output-port> [<width>]] ) -- like PP, but does
    *not* print source for code.

  (GENSYM [<symbol-or-string>] ) -- generates a symbol.
    Examples:
      (gensym)	    -> g1
      (gensym 'foo) -> foo2
      (gensym)	    -> g3

  (PUT <symbol> <key> <value>)     -- Known generally as "putprop"
  (GET <symbol> <key>)	-> <value> -- Known generally as "getprop"
    Examples:
      (put 'groceries 'beans 37)
      (put 'groceries 'milk 2)
      (get 'groceries 'beans) 	-> 37

  (LOAD <string>) -- rather than "foo.scm" <string> may be "foo",
   which looks first for "foo.O", then "foo.scm"

  (EVAL <expression>) -- If you don't know what this does, you should
    probably not use it.  You probably don't need to use it anyway...

  (SET-GC-REPORT <boolean>) -- If set to #t, reports when a storage
    reclamation occurs.  If set to #f (the default), gc is not reported.

  (OPEN-INPUT-STRING <string>)  -> <output-string-port>
  (OPEN-OUTPUT-STRING)		-> <input-string-port>
  (GET-OUTPUT-STRING <input-string-port>) -> <string>

  (##WEAK-CONS <obj1> <obj2>)	-> a weak cons
  (##WEAK-PAIR? <object>)	-> #t or #f
  (##WEAK-CAR <weak-pair>)	-> <obj1> or #f
  (##WEAK-CDR <weak-pair>)	-> <obj2>
    Weak pairs are a special object that behavies like a cons cell,
    except that the car pointer is weak.  This means that if no 
    "strong" ppointer is referencing an object denoted by the car
    slot, it will be collected after gc.  When collected, the car's
    value becomes #f.  The cdr slot is `normal'.  Note that a
    weak-pair is *not* a pair-- you must use the ##weak-* functions.
    I.e. you cannot take the CAR of a weak-pair, you must use
    ##weak-car.  Weak pointers are useful to keep track of things
    that you don't want to stay around just because you are keeping
    track of them (e.g. elements of a set with some property).

  (FUTURE <expression>) -> <future>
    Futures are a multi-processing construct.  The value is potentially
    calculated in parallel with other computations.  Futures may be
    stored in data structures.  Their value is guarenteed where it is
    first used ("touching" is implicit in this implementation).

Extensions for compiler users:

  (COMPILE <string> [ <option>* ] ) 
    options:
      ASM causes a commented assembly file to be generated
      PVM creates a file of Portable Virtual Machine instructions
      EXPANSION shows code after macro expansion
      VERBOSE causes a report of compile time actions to be displayed
      REPORT  reports on global variable usage
      DEBUG compiles in debug information (takes up a lot of space!) so that
            compiled code can be debugged like interpreted code.

  (MAKE-UNSCANNED-VECTOR <num-slots>) -- Creates a vector which is not
    scanned by the collector.  Useful for stashing C pointers and non-Scheme
    binary values.
  (UNSCANNED-VECTOR? v)		-> #t or #f
  (UNSCANNED-VECTOR-LENGTH uv)	-> <num-slots>
  (UNSCANNED-VECTOR-SET! uv index val)
  (UNSCANNED-VECTOR-REF  uv index) -- you should probably never use this!
    [The implementation is in "runtime/gsi.scm"].

  (REGISTER-FOR-FINALIZATION <object> <thunk>) -- After the next
    collection where <object> is no longer referenced, executes
    <thunk>.  Note that <thunk> cannot refer to <object> or it will
    never be collected.  This is useful for invoking destructors on C
    malloc'ed storage when windows close, etc.  Note that it is
    considered bad form to allocate storage within <thunk>.  [The
    implementation is in "runtime/gsi.scm"].

  
; SYNTAX

  (LAMBDA <name> <exp>+ )
  (LAMBDA (<name>* ) <exp>+ )
  (AND <object>*)
  (OR  <object>*)
  (IF <test-exp> <if-true> [<if-false>] )
  (COND (<test> <exp>* )... [(ELSE <exp>+)] )
  (CASE <key-exp> ((<datum>+ ) <exp>* )... [(ELSE <exp>+)] )
  (LET [<name>] ( (<vname> <value-exp>) ) <body-exp> )
  (LET*   ( (<vname> <value-exp>) ) <body-exp> )
  (LETREC ( (<vname> <value-exp>) ) <body-exp> )
  (BEGIN <expression>+ )
  (DO ( (<var> <init> <step>)... ) ( <test> <exp>* ) <exp>* )
  ;; Note also R^4RS syntax, below

; IEEE Scheme

  (NOT <object>)
  (BOOLEAN? <object>)

  (EQV? <obj1> <obj2>)
  (EQ? <obj1> <obj2>)
  (EQUAL? <obj1> <obj2>)

  (PAIR? <object>)
  (CONS <obj1> <obj2>)
  (CAR <pair>)
  (CDR <pair>)
  (SET-CAR! <pair> <object>)
  (SET-CDR! <pair> <object>)
  (CAAR  <list>)   (CADR  <list>)   (CDAR  <list>)   (CDDR <list>)
  (CAAAR <list>)   (CAADR <list>)   (CADAR <list>)   (CADDR <list>)
  (CDAAR <list>)   (CDADR <list>)   (CDDAR <list>)   (CDDDR <list>)
  (CAAAAR <list>)  (CAAADR <list>)  (CAADAR <list>)  (CAADDR <list>)
  (CADAAR <list>)  (CADADR <list>)  (CADDAR <list>)  (CADDDR <list>)
  (CDAAAR <list>)  (CDAADR <list>)  (CDADAR <list>)  (CDADDR <list>)
  (CDDAAR <list>)  (CDDADR <list>)  (CDDDAR <list>)  (CDDDDR <list>)
  (NULL? <object>)
  (LIST? <object>)
  (LIST <object>* )
  (LENGTH <list>)
  (APPEND <list>+ )
  (REVERSE <list>)
  (LIST-REF <list> <index>)
  (MEMQ  <object> <list>)
  (MEMV  <object> <list>)
  (MEMBER <object> <list>)
  (ASSQ  <object> <alist>)
  (ASSV  <object> <alist>)
  (ASSOC <object> <alist>)

  (SYMBOL? <object>)
  (SYMBOL->STRING <symbol>)  (STRING->SYMBOL <string>)

  (NUMBER? <object>)
  (COMPLEX? <object>)
  (REAL? <object>)
  (RATIONAL? <object>)
  (INTEGER? <object>)
  (EXACT? <number>)     (INEXACT? <number>)
  (=  <number>+ )
  (<  <number>+ )  (>  <number>+ )
  (<= <number>+ )  (>= <number>+ )
  (ZERO? <number>)
  (POSITIVE? <number>)  (NEGATIVE? <number>)
  (ODD? <number>)       (EVEN? <number>)
  (MAX <number>+ )      (MIN <number>+ )
  (+ <number>+ )
  (* <number>+ )
  (- <number>+ )
  (/ <number>+ )
  (ABS <number>)
  (QUOTIENT <num1> <num2>)  (REMAINDER <num1> <num2>)
  (MODULO <num1> <num2>)
  (GCD <number>* )          (LCM <number>* )
  (NUMERATOR <rational>)    (DENOMINATOR <rational>)
  (FLOOR <number>)          (CEILING <number>)
  (TRUNCATE <number>)       (ROUND <number>)
  (RATIONALIZE <num1> <num2>)
  (EXP <number>)            (LOG <number>)
  (SIN <number>)   (COS <number>)   (TAN <number>)
  (ASIN <number>)  (ACOS <number>)  (ATAN <number> [<number>])
  (SQRT <number>)
  (EXPT <num1> <num2>)
  (MAKE-RECTANGULAR <num1> <num2>)  (MAKE-POLAR <num1> <num2>)
  (REAL-PART <number>)       (IMAG-PART <number>)
  (MAGNITUDE <number>)       (ANGLE <number>)
  (EXACT->INEXACT <number>)  (INEXACT->EXACT <number>)
  (NUMBER->STRING <number>)  (STRING->NUMBER <string>)

  (CHAR? <object>)
  (CHAR=?  <char1> <char2>)  (CHAR-CI=?  <char1> <char2>)
  (CHAR<?  <char1> <char2>)  (CHAR-CI<?  <char1> <char2>)
  (CHAR>?  <char1> <char2>)  (CHAR-CI>?  <char1> <char2>)
  (CHAR<=? <char1> <char2>)  (CHAR-CI<=? <char1> <char2>)
  (CHAR>=? <char1> <char2>)  (CHAR-CI>=? <char1> <char2>)
  (CHAR-ALPHABETIC? <character>)
  (CHAR-NUMERIC?    <character>)
  (CHAR-WHITESPACE? <character>)
  (CHAR-UPPER-CASE? <character>)  (CHAR-LOWER-CASE? <character>)
  (CHAR->INTEGER <character>)     (INTEGER->CHAR    <integer>)
  (CHAR-UPCASE   <character>)     (CHAR-DOWNCASE    <character>)

  (STRING? <object>)
  (MAKE-STRING <length> [<character>] )
  (STRING <character>+ )
  (STRING-LENGTH <string>)
  (STRING-REF <string> <index>)
  (STRING-SET! <string> <index> <character>)
  (STRING=?  <string1> <string2>)  (STRING-CI=?  <string1> <string2>)
  (STRING<?  <string1> <string2>)  (STRING-CI<?  <string1> <string2>)
  (STRING>?  <string1> <string2>)  (STRING-CI>?  <string1> <string2>)
  (STRING<=? <string1> <string2>)  (STRING-CI<=? <string1> <string2>)
  (STRING>=? <string1> <string2>)  (STRING-CI>=? <string1> <string2>)
  (SUBSTRING <string> <start-index> <end-index>)
  (STRING-APPEND <string>+ )

  (VECTOR? <object>)
  (MAKE-VECTOR <length> [<object>] )
  (VECTOR <object>* )
  (VECTOR-LENGTH <vector>)
  (VECTOR-REF  <vector> <index>)
  (VECTOR-SET! <vector> <index> <object>)

  (PROCEDURE? <object>)
  (APPLY <procedure> <arg>* <arg-list>)
  (MAP   <procedure> <list>+ )
  (FOR-EACH <procedure> <list>+ )
  (CALL-WITH-CURRENT-CONTINUATION <one-argument-procedure>)

  (CALL-WITH-INPUT-FILE  <string> <procedure>)
  (CALL-WITH-OUTPUT-FILE <string> <procedure>)
  (INPUT-PORT? <object>)  (OUTPUT-PORT? <object>)
  (CURRENT-INPUT-PORT)    (CURRENT-OUTPUT-PORT)
  (OPEN-INPUT-FILE  <string>)       (OPEN-OUTPUT-FILE <string>)
  (CLOSE-INPUT-PORT  <input-port>)  (CLOSE-OUTPUT-PORT <output-port>)
  (EOF-OBJECT? <object>)
  (READ [<input-port>] )
  (READ-CHAR [<input-port>] )
  (PEEK-CHAR [<input-port>] )
  (WRITE   <object> [<output-port>] )
  (DISPLAY <object> [<output-port>] )
  (NEWLINE [<output-port>] )
  (WRITE-CHAR <character> [<output-port>] )


; R4RS Scheme

  (LIST-TAIL <list>)
  (STRING->LIST <string>)
  (LIST->STRING <list-of-characters>)
  (STRING-COPY  <string>)
  (STRING-FILL! <string> <character>)
  (VECTOR->LIST <vector>)
  (LIST->VECTOR <list>)
  (VECTOR-FILL! <vector> <object>)
  (DELAY <expression>)
  (FORCE <promise>)
  (WITH-INPUT-FROM-FILE <string> <thunk>)
  (WITH-OUTPUT-TO-FILE  <string> <thunk>)
  (CHAR-READY? [<input-port>] )
  (LOAD <string>)
  (TRANSCRIPT-ON <string>)
  (TRANSCRIPT-OFF)
  (DEFINE-SYNTAX <name> <transformer-spec>)  -- High-Level macros (only)
  (LET-SYNTAX    ( <syntax-spec>* ) <exp>+ ) -- see R^4RS, below
  (LETREC-SYNTAX ( <syntax-spec>* ) <exp>+ )



=== STANDARDS REFERENCES ===


IEEE Standard 1178-1990. "IEEE Standard for the Scheme Programming
Language", IEEE, New York, 1991, ISBN 1-55937-125-0 [1-800-678-IEEE:
order # SH14209].  -- now also an ANSI standard.

W. Clinger and J. Rees, eds., "Revised^4 Report on the Algorithmic
Language Scheme" (R^4RS), ACM LISP Pointers IV, 3 (July-September 1991).



;;			--- E O F ---			;;
