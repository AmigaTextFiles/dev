
   CSECT text

*_doit is called by callasm, with parameters
* offset (int), base (int), lreg (NODE *), larg (NODE *)
* according the Lattice Manual (v3.10) we have :
* top of stack :.....
*               offset  4(a7)
*               base    8(a7)
*               lreg
*               larg
* we must preserve d2-d7,a2-a7
* and we will return some value in d0



      XDEF    _doit
_doit
   movem.l 4(a7),d0-d1/a0-a1      ;offset=d0,base=d1,lreg=a0,larg=a1
   movem.l d2-d7/a2-a6,-(a7)   ;save C registers
   movea.l d1,a6         ;put the library base in a6. a1 is now free
   move.w d0,newjsr+2   ;code modification. this is bad!

* and now, let's examine the arguments (lreg in a0,larg in a1)
resumeload
   move.l a1,d0            ;(tst impossible with An) no more arguments
   beq endargs
   movea.l 2(a1),a4     ;car of larg in a4

* find wether it is a string (type 7) or an integer (type 5)
   cmpi.b #5,(a4)
   beq  caseinteger
   cmpi.b #7,(a4)
   beq  casestring
   bra shitty             ; should always of these types
caseinteger
   move.l 2(a4),param   ;store the integer
   bra findreg
casestring
   move.l 6(a4),param   ;store the (char *)

findreg
   movea.l 2(a0),a4          ;car of lreg
   move.l 2(a4),d0          ;integer value (no type-checking)
   movea.l 6(a0),a0          ;forward in lreg.
   movea.l 6(a1),a1          ;forward in larg.

   lsl.l  #2,d0             ;* 4 register's code
   movea.l #tabreg,A4       ;table of calls addresses
   movea.l 0(a4,d0.w),a4    ;indexing of register storage
   jmp    (a4)              ;store value


endargs
   movea.l speciala4,a4
   move.l  speciald0,d0
   movea.l  speciala0,a0
   movea.l  speciala1,a1
*we now have all our registers updated
newjsr
   JSR 0(a6)            ;the offset will be hand-modified (dirty)
*                        the result is usually in D0
   movem.l (a7)+,d2-d7/a2-a6      ;restore c-registers
   rts

* Loading parameters into registers.

* a0 is used in the loop as temporariry storage
rega0
   MOVE.L param,speciala0
   BRA    resumeload

* a1 is used in the loop as temporariry storage
rega1
   MOVE.L param,speciala1
   BRA    resumeload

rega2
   MOVE.L param,A2
   BRA    resumeload

rega3
   MOVE.L param,a3
   BRA    resumeload

* a4 is used in the loop as temporariry storage
rega4
   MOVE.L param,speciala4
   BRA    resumeload

rega5
   MOVE.L param,A5
   BRA    resumeload

* the user is mad. A6 must be the library base
rega6
   BRA    shitty

* A7 is the stack pointer. how could you pass an argument there ??
rega7
   BRA    shitty

* d0 is used in the loop as temporariry storage
regd0
   MOVE.L param,speciald0
   BRA    resumeload

regd1
   MOVE.L param,d1
   BRA    resumeload

regd2
   MOVE.L param,d2
   BRA    resumeload

regd3
   MOVE.L param,D3
   BRA    resumeload

regd4
   MOVE.L param,D4
   BRA    resumeload

regd5
   MOVE.L param,D5
   BRA    resumeload

regd6
   MOVE.L param,D6
   BRA    resumeload

regd7
   MOVE.L param,d7
   BRA    resumeload

*when some error occurred
shitty
   movem.l (a7)+,d2-d7/a2-a6      ;restore c-registers
   move.l #'ERRR',d0
   rts


      CSECT data
tabreg
   DC.L    rega0          ;index : 0
   DC.L    rega1
   DC.L    rega2
   DC.L    rega3
   DC.L    rega4
   DC.L    rega5
   DC.L    rega6
   DC.L    rega7
   DC.L    regd0          ;index: 8
   DC.L    regd1
   DC.L    regd2
   DC.L    regd3
   DC.L    regd4
   DC.L    regd5
   DC.L    regd6
   DC.L    regd7

param       DC.L 0
speciala0   DC.L 0
speciala1   DC.L 0
speciala4   DC.L 0
speciald0   DC.L 0

      END
