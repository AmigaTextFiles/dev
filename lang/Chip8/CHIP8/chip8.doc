
		AMIGA CHIP 8 INTERPRETER & DREAM MON V1.1
		=========================================

		      (C) PAUL HAYTER 1990,91

	Does anyone remember the RCA COSMAC VIP computer ?
	How about the DREAM 6800 or ETI 660 ?
	I'm not surprised if you don't. These were El-Cheapo 
Make-It-Yourself Hobbyist computers which appeared in the early 1980's. The 
COSMAC would be more widely known to U.S. Amiga owners. I'm not exactly 
sure whether you had to construct the COSMAC yourself, but the DREAM and 
ETI 660 both appeared in Australian Electronics Magazines as construction 
projects. What all these computers had in common was that they were 
disgustingly cheap (about $100), used a hex keypad, could produce ultra 
stingy 64 x 32 PIXEL (The ETI 660 had 64 x 48 OR 64 x 64 with a 
modification) graphics for display on a TV, had about ONE kilobyte of RAM, 
and all ran a pseudo high-level language called CHIP 8 (which was developed 
by RCA for showing off the COSMAC's graphics, I think).

	Somewhere along the way, my older brother made up a DREAM 6800. 
What a computer! Along with the construction articles for the DREAM & ETI 
660 were heaps of CHIP 8 game listings. Some of the games were only 200 
BYTES or so, so it didn't take forever to type them in. And the games were 
great fun. They weren't slow. And CHIP 8 was pretty much designed for 
making Classic style TV games anyway.

	Alas, the DREAM is now resting silently covered in dust. Even 
though I now have an Amiga, I somehow yearned to play those hopelessly 
simple games on the DREAM again. So I've made a CHIP 8 interpreter for the 
Amiga with a monitor interface (pretty much) identical to the monitor in 
the DREAM 6800.

DREAM MON
=========
	CHIP 8 can be started from Workbench or CLI. If from the CLI then

1> chip8

	Otherwise double click on its icon.

	You start up in the DREAM monitor environment. The screen is all 
black except for a white bar across the middle. The white bar shows the 
current 4 digit HEX ADDR followed by the HEX byte contents of that memory 
location (NB: these do not correspond to actual Amiga addresses). CHIP 8 in 
its original form only allowed addressing of a 4Kbyte block of RAM. My 
implementation does the same, so addresses 0000 thru 0FFF are the only 
valid ones. The DREAM MON has the following commands:

	RETURN,=,SPACE,+       :Advance the hex address by 1.
	-,BACKSPACE	       :Decrement the hex address by 1.
	M		       :Once you hit M you can type in a new
				4 digit hex address.
	G		       :Executes the CHIP 8 program from the
				current location.
	L		       :Loads a CHIP 8 source (?) file from disk.
				A file requester appears, so that you can
				can select a chip8 source file (*.c8).
	S		       :Saves a compressed file holding the entire
				4K CHIP8 workspace. Again a file requester
				appears allowing you to enter a new file
				name, or save as the old name.
	X		       :Exit back to the CLI.
	K		       :Klears memory.
	Any hex digit	       :Typing 2 hex digits in succession will
				enter that byte into the current location
				and auto advance the current address.

NOTE: DREAM MON starts up pointing to address 0200. This is the default
for a DREAM 6800. All programs written for the DREAM are usually entered
at 0200 onwards. However, programs for the ETI-660 are entered at 0600
onwards.

NOTE: CHIP 8 programs are saved by run length encoding the entire 4K
workspace. The compressor works best when the areas of memory which are not
used remain blank (= 00). So it is wise to use the Klear command before
you type a new program in.

An important thing to remember is that this monitor is VERY 
UN-USERFRIENDLY. You do not hit return after you enter a line. Nor can you 
correct errors in what you type. However, it is pretty much identical to 
the original DREAM MON.

CHIP 8 EMULATOR
===============
	After you've pressed G , a chip8 program will either end by itself
or stay in an infinite loop. If it is in an infinite loop, then you can
return to the DREAM MON by pressing the left mouse button.

CHIP 8
======
	CHIP 8 is a kind of high level machine code. No one these days can 
beleive that a machine code (the actual hex codes making up each 
instruction) could possibly be "high level", but it is! 

	Each instruction in CHIP 8 consists of 4 hex digits (one word). The 
1st hex digit determines the command to be executed, with the remaining 3 
digits forming the parameters of the command. The designers have tried to
make the first hex digit relate to the command. ie. D for the Display
command. Most instructions either operate on a variable and an immediate
constant or two variables or just one variable.

	If we liken CHIP8 to a microprocessor, what we have is a CPU with
a 4K address space, 16 x 1 byte registers V0 to VF, and one 12 bit memory
index pointer called I. You can load immediate with the 6XKK and AMMM
instructions. You can Jump with the 1MMM and BMMM instructions. You
can have subroutines with the 2MMM and 00EE instructions. All your
condition handling is done with the SKF instructions (usually followed
by a GOTO instruction. And the 8XY? instructions allow you to do most
arithmetic on the Variables V0 - VF. You have a sort of INKEY$ (from
BASIC) instruction with the EX9E and EXA1 instructions.
	The most powerful instruction is the DXYN instruction which
allows you to place a software sprite at any X,Y position on the screen.
The image is XORed onto the screen, so you just display it twice to
erase it.
	There are also special instructions to handle numeric output
(i.e. game scores). The FX33 instruction stores 3 bytes in memory starting
at I. The 3 bytes correspond to the 3 decimal digits of VX.
eg.

 0200	6AFE	VA=FE	(254 decimal)
 0202	A240	I=240
 0204	FA33	MI=DEQ,V3
 ...

This fragment will store 02 in location 240, 05 in location 241, & 04
in location 242. To use this information we use the FX65 instruction which
loads V0 thru VX from memory pointed to by I. For example, continuing the
above program:

 0206	F265	V0:V2=MI	{should set V0=02, V1=05, V2=04}
 ...

Now, to display this 3 digit number we use the FX29 instruction. This
sets the I pointer to point to a software sprite pattern corresponding
to the least most significant hex digit in VX. Continuing the above:

 0208	6410	V4=10
 020A	6508	V5=08
 020C	F029	I=DSP,V0	{I should point to the image of a 2}
 020E	D455	SHOW 5@V4,V5	{show a 2}
 0210	7404	V4=V4+04	{bump X coord}
 0212	F129	I=DSP,V1	{I should point to the image of a 5}
 0214	D455	SHOW 5@V4,V5	{show a 5}
 0216	7404	V4=V4+04	{bump X coord}
 0218	F229	I=DSP,V2	{I should point to the image of a 4}
 021A	D455	SHOW 5@V4,V5	{show a 4}
 021C	F000	STOP

	While I won't give a full explanation of how to program in CHIP-8, 
I will give a run down of the commands which my version understands.

 CODE	MNEMONIC	DESCRIPTION

 1MMM	GOTO MMM	Jump instruction at location MMM
 BMMM	GOTO MMM + V0	Jump to MMM + V0
 2MMM	DO MMM		Do CHIP8 subroutine at location MMM
 00EE	RETURN		Return from CHIP8 subroutine
 3XKK	SKF VX = KK	Skip next instruction if VX=KK
 4XKK	SKF VX <> KK	Skip if VX NOT = KK
 5XY0	SKF VX = VY	Skip if VX = VY
 9XY0	SKF VX <> VY	Skip if VX NOT = VY
 EX9E	SKF VX = KEY	Skip if Key Down = VX; Don't wait
 EXA1	SKF VX <> KEY	Skip if Key Down <> VX; Don't wait
 6XKK	VX = KK		Let Variable X = hex value KK
 CXKK	VX = RND.KK	Get random byte. AND with KK.
 7XKK	VX = VX + KK	Add (2's complement) KK to VX
 8XY0	VX = VY		Let VX = VY
 8XY1	VX = VX!VY	Logical OR VX with VY
 8XY2	VX = VX.VY	Logical AND VX with VY
 8XY3	VX = VX XOR VY	Logical exclusive OR VX with VY
 8XY4	VX = VX + VY	Add VY to VX. If result > FF then VF = 1
 8XY5	VX = VX - VY	Subtract VY. If VX < VY then VF = 0, else 1
 FX07	VX = TIME	Get current timer value
 FX0A	VX = KEY	Input hex keycode (wait for keypress)
 FX15	TIME = VX	Initialise timer; 01 = 20 millisecs
 FX18	TONE = VX	Bleep for 20 x VX millisecs (NOT YET IMPLEMENTED)
 AMMM	I = MMM		Set memory index pointer to MMM
 FX1E	I = I + VX	Add VX to memory pointer
 FX29	I = DSP, VX	Set pointer to show VX (Least significant digit)
 FX33	MI = DEQ, VX	Store 3 digit decimal equivalent of VX
 FX55	MI = V0:VX	Store V0 thru VX at I; I = I + X + 1
 FX65	V0:VX = MI	Load V0 thru VX at I; I = I + X + 1
 00E0	ERASE		Clear screen
 0MMM	CALL MMM	Call machine code at MMM (NOT IMPLEMENTED)
 DXYN	SHOW N @ VX,VY	Display N byte pattern at coord (VX,VY)
 0000	NOP		Do nothing
 F000	STOP		Return to Monitor

EXAMPLE PROGRAM
===============

	Just type the hex numbers in at the address shown.
	The following program moves a box diagonally across the screen.

 ADDR	BYTES

 0200	6A00	VA=00
 0202	6B00	VB=00
 0204	A210	I=210
 0206	DAB7 ->	SHOW 7@VA,VB
 0208	DAB7 |	SHOW 7@VA,VB
 020A	7A02 |	VA=VA+02
 020C	7B01 |	VB=VB+01
 020E	1206 --	GOTO 206
 0210	FF81	DATA FOR BOX
 0212	8181
 0214	8181
 0216	FF

GETTING STARTED
===============

	Run CHIP8. You should be presented with a blank screen, with a bar
halfway down showing the address $0200 and its contents. Use the left and
right arrow keys to step you forward/backward thru memory. Try pressing
some hex numbers. You'll only see the first one you type, as the memory
address auto advances after you've entered a byte value into it. You can
step backwards with the left arrow to see what you've entered.
	Try pressing K. This will clear the memory to all zeros, removing
any hex values you may have typed.
	Lets load a game. Press L. A file requester will pop up. If you
are not currently in the Chip8 directory, you will have to click on
a few directories until you arrive. Look at all the files ending in .c8  .
These are chip8 source files. Note that some end in 2.c8  and others end
in  6.c8  .The ones ending in 2.c8 MUST be executed (pressing G) at
address 0200. Conversely the ones ending in 6.c8 must be executed at 0600.
	Try selecting WipeOff2.C8 and clicking OK. Now to run the game, the
memory address on the screen must be 0200. If it is not, type the
following 5 keys:

	M  0  2  0  0

	To run the game just press G. This is a simple breakout game.
Press keys 4 and 6 to move the bat left and right. If at any time you
want to return to the DREAM monitor, press the left mouse button.

IN THIS DIRECTORY
=================

 CHIP8			The DREAM monitor and CHIP 8 emulator.
 CHIP8.s		Assembly source for the above.
 CHIP8.doc		This doc file.
The following games are from the original DREAM 6800 article.
 WipeOff2.c8		WipeOff. 4=left,6=right
 UFOIntercept2.c8	UFO Intercept. 4=shoot left,5=shoot middle
			6=shoot right.
 Kaleidescope6.c8	Kaleidescope. Move with 4,6,8,2 keys. 0 to start
 TankBattle6.c8		Tank Battle. Move with 4,6,8,2 keys, 5 =fire
 15puzzle2.c8		15 Puzzle. Use 4,6,8,2 keys to move tiles into
			blank spot.
 ExampleA2.c8		An example program.
 ExampleB2.c8		Another example.

NOTE: most chip8 games use the cursor keys on the number pad for direction
control.


CREDITS
=======

 Michael J Bauer for the DREAM 6800 computer (May, June, July, & August
1979 issues of Electronics Australia).
 Hugh Anderson & Graeme Teesdale for the ETI-660 computer (Mainly the
November 1981 issue of Electronics Today International)
 Whoever designed the RCA COSMAC VIP computer.

 Jukka Marin of Supervisor Software for his File Requester (AmigaLibDisk
#247).


	DISTRIBUTION
	============

		CHIP8 IS FREELY DISTRIBUTABLE. YOU CAN COPY IT AS
	MUCH AS YOU LIKE AS LONG AS THE FOLLOWING IS SATISFIED.
		1. ONLY A NOMINAL COPYING FEE IS CHARGED.
		2. IT IS NOT USED FOR COMMERCIAL PURPOSES.

	NOTE: THE DOC FILE MUST BE DISTRIBUTED WITH THE EXECUTABLE. THE
	      SOURCE FILES CAN OPTIONALLY BE DISTRIBUTED WITH THESE TOO.

	CORRESPONDENCE
	==============

		Please send any bug reports/ or correspondence to myself
	at the address below.

		Paul Hayter
		PO BOX 331
		Ballina
		2478
		Australia.
