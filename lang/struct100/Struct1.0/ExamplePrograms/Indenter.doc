                        Struct Indenter 1.1
                          by Roland Acton

  This program is designed to make life easier for Struct
programmers. It indents source code to make the program flow through
branches and loops more obvious.
  Set up the Struct compiler as described in the documentation, then
compile and link the Indenter program. Place the object code in your
C: directory as IndentStr. Now you can use the Indenter from the CLI
by typing:

IndentStr <source-file> <destination-file>

  The command line parsing code really isn't very good - unlike
other programs, you can't use spaces in the filenames, not even if
you surround them by quotes.
  The Indenter will properly indent the code in the source-file and
write it out to the destination-file. The source-file will not be
affected.
  There's a constant called INDENTAMOUNT which is defined near the
beginning of the program. This sets how many columns the Indenter
will shift a block of code by, if it decides to. It is originally
set to 2, but can be changed if you have a different preference.

HOW IT WORKS
------------
  The basic idea behind this program is easy to understand. We want
to pull in a line of code from the source file, strip off any
existing indentation (since this program may well have been used on
the file before), indent it by a certain amount, and then write the
line out. The "certain amount" is initially nothing, and shouldn't
change when the program reads in a "standard" statement like A=A+B,
but statements like For or Next will obviously change it.
  Consider this block of code, taken from the Indenter program
itself:

    libcall destfilehandle=open(destfilename,1006)
    if destfilehandle>0
      parsecommandline=1
    else
      libcall close(srcfilehandle)
      print addresskludge
      print destfilename
      addresskludge=addresskludge+20
      print addresskludge
      parsecommandline=0
    end if

  If we number the columns on our computer screen starting from 1,
the If, Else, and End If are in column 5. Everything between them
is in column 7. It's clear that this code is properly indented.
But how did the program decide where to put what?
  Notice what happened as we hit the If statement. From the Lib Call
command above it, we can see that we were moving happily along,
outputting everything at column 5. But then, AFTER the If, we
started putting things in column 7. Notice the symmetry with the End
If - we were outputting everything in column 7, and just BEFORE the
End if we started to put things in column 5.
  If we have an internal variable, call it INDENT, that controls the
current amount of indentation, what we should do becomes clear. An
If statement, or anything like it, should change the variable after
the line is output. An End If-type statement should change the
variable before the line is output.
  This is the Indenter's keyword table:

  bytedata (keywords) "IF",0,"FOR",0,"WHILE",0,"REPEAT",0,"LOOP",0
  bytedata "ZEROLOOP",0,"ASM",0
  bytedata "ELSE",0
  bytedata "ENDIF",0,"NEXT",0,"WEND",0,"UNTIL",0,"ENDLOOP",0
  bytedata "ZEND",0,"ENDASM",0

  Everything before the Else is an If-type statement, and everything
after it is an End If-type statement. The Else statement itself
falls into BOTH classes. When it's encountered, INDENT is
decremented, the Else is output, and INDENT goes back to whatever it
was before.
