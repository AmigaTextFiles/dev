







Volume I
Basic Programming Guide

CLIPS Version 6.0

June 2nd 1993













Software Technology Branch

Lyndon B. Johnson Space Center
CLIPS Basic Programming Guide
Version 6.0   June 2nd 1993

CONTENTS
Preface	xv
Acknowledgements	xix
Section 1 - Introduction	1
Section 2 - CLIPS Overview	3
2.1 Interacting with CLIPS	3
2.1.1 Top Level Commands	3
2.1.2 Automated Command Entry	4
2.1.3 Integration with Other Languages	4
2.2 Reference Manual Syntax	5
2.3 Basic Programming Elements	5
2.3.1 Data Types	5
2.3.2 Functions	9
2.3.3 Constructs	10
2.4 Data Abstraction	10
2.4.1 Facts	10
2.4.1.1 Ordered Facts	11
2.4.1.2 Non-ordered Facts	11
2.4.1.3 Initial Facts	12
2.4.2 Objects	13
2.4.2.1 Initial Objects	14
2.4.3 Global Variables	14
2.5 Knowledge Representation	14
2.5.1 Heuristic Knowledge - Rules	14
2.5.2 Procedural Knowledge	15
2.5.2.1 Deffunctions	16
2.5.2.2 Generic Functions	16
2.5.2.3 Object Message-Passing	16
2.5.2.4 Defmodules	17
2.6 CLIPS Object-Oriented Language	17
2.6.1 COOL Deviations from a Pure OOP Paradigm	17
2.6.2 Primary OOP Features	17
2.6.3 Instance-set Queries and Distributed Actions	18
Section 3 - Deftemplate Construct	19
3.1 Slot Default Values	20
3.2 Slot Default Constraints for Pattern-Matching	21
3.3 Slot Value Constraint Attributes	21
3.4 Implied Deftemplates	21
Section 4 - Deffacts Construct	23
Section 5 - Defrule Construct	25
5.1 Defining Rules	25
5.2 Basic Cycle Of Rule Execution	26
5.3 Conflict Resolution Strategies	26
5.3.1 Depth Strategy	27
5.3.2 Breadth Strategy	27
5.3.3 Simplicity Strategy	27
5.3.4 Complexity Strategy	28
5.3.5 LEX Strategy	28
5.3.6 MEA Strategy	29
5.3.7 Random Strategy	29
5.4 LHS Syntax	30
5.4.1 Pattern Conditional Element	30
5.4.1.1 Literal Constraints	31
5.4.1.2 Wildcards Single- and Multifield	33
5.4.1.3 Variables Single- and Multifield	35
5.4.1.4 Connective Constraints	37
5.4.1.5 Predicate Constraints	40
5.4.1.6 Return Value Constraints	42
5.4.1.7 Pattern-Matching with Object Patterns	44
5.4.1.8 Pattern-Addresses	46
5.4.2 Test Conditional Element	47
5.4.3 Or Conditional Element	48
5.4.4 And Conditional Element	49
5.4.5 Not Conditional Element	50
5.4.6 Exists Conditional Element	51
5.4.7 Forall Conditional Element	53
5.4.8 Logical Conditional Element	55
5.4.9 Automatic Addition and Reordering of LHS CEs	58
5.4.9.1 Rules Without Any LHS Pattern CEs	58
5.4.9.2 Test and Not CEs as the First CE of an And CE	58
5.4.9.3 Test CEs Following Not CEs	59
5.4.9.4 Or CEs Following Not CEs	60
5.4.9.5 Notes About Pattern Addition and Reordering	60
5.4.10 Declaring Rule Properties	60
5.4.10.1 The Salience Rule Property	61
5.4.10.2 The Auto-Focus Rule Property	61
Section 6 - Defglobal Construct	63
Section 7 - Deffunction Construct	65
Section 8 - Generic Functions	67
8.1 Note on the Use of the Term Method	67
8.2 Performance Penalty of Generic Functions	68
8.3 Order Dependence of Generic Function Definitions	68
8.4 Defining a New Generic Function	68
8.4.1 Generic Function Headers	69
8.4.2 Method Indices	69
8.4.3 Method Parameter Restrictions	70
8.4.4 Method Wildcard Parameter	71
8.5 Generic Dispatch	73
8.5.1 Applicability of Methods Summary	73
8.5.2 Method Precedence	74
8.5.3 Shadowed Methods	77
8.5.4 Method Execution Errors	77
8.5.5 Generic Function Return Value	77
Section 9 - CLIPS Object Oriented Language (COOL)	79
9.1 Background	79
9.2 Predefined System Classes	79
9.3 Defclass Construct	80
9.3.1 Multiple Inheritance	81
9.3.1.1 Multiple Inheritance Rules	82
9.3.2 Class Specifiers	84
9.3.2.1 Abstract and Concrete Classes	84
9.3.2.2 Reactive and Non-Reactive Classes	84
9.3.3 Slots	84
9.3.3.1 Slot Field Type	85
9.3.3.2 Default Value Facet	85
9.3.3.3 Storage Facet	86
9.3.3.4 Access Facet	87
9.3.3.5 Inheritance Propagation Facet	88
9.3.3.6 Source Facet	89
9.3.3.7 Pattern-Match Reactivity Facet	90
9.3.3.8 Visibility Facet	91
9.3.3.9 Create-Accessor Facet	92
9.3.3.10 Override-Message Facet	93
9.3.3.11 Constraint Facets	93
9.3.4 Message-handler Documentation	94
9.4 Defmessage-handler Construct	95
9.4.1 Message-handler Parameters	97
9.4.1.1 Active Instance Parameter	98
9.4.2 Message-handler Action	98
9.4.3 Daemons	100
9.4.4 Predefined System Message-handlers	101
9.4.4.1 Instance Initialization	101
9.4.4.2 Instance Deletion	101
9.4.4.3 Instance Display	102
9.4.4.4 Directly Modifying an Instance	103
9.4.4.5 Modifying an Instance using Messages	103
9.4.4.6 Directly Duplicating an Instance	103
9.4.4.7 Duplicating an Instance using Messages	104
9.5 Message Dispatch	104
9.5.1 Applicability of Message-handlers	105
9.5.2 Message-handler Precedence	105
9.5.3 Shadowed Message-handlers	106
9.5.4 Message Execution Errors	106
9.5.5 Message Return Value	107
9.6 Manipulating Instances	107
9.6.1 Creating Instances	107
9.6.1.1 Definstances Construct	109
9.6.2 Reinitializing Existing Instances	110
9.6.3 Reading Slots	112
9.6.4 Setting Slots	112
9.6.5 Deleting Instances	113
9.6.6 Delayed Pattern-Matching When Manipulating Instances	113
9.6.7 Modifying Instances	114
9.6.7.1 Directly Modifying an Instance with Delayed Pattern-Matching	114
9.6.7.2 Directly Modifying an Instance with Immediate Pattern-Matching	115
9.6.7.3 Modifying an Instance using Messages with Delayed Pattern-Matching	115
9.6.7.4 Modifying an Instance using Messages with Immediate Pattern-Matching	116
9.6.8 Duplicating Instances	116
9.6.8.1 Directly Duplicating an Instance with Delayed Pattern-Matching	116
9.6.8.2 Directly Duplicating an Instance with Immediate Pattern-Matching	117
9.6.8.3 Duplicating an Instance using Messages with Delayed Pattern-Matching	117
9.6.8.4 Duplicating an Instance using Messages with Immediate Pattern-Matching	119
9.7 Instance-set Queries and Distributed Actions	119
9.7.1 Instance-set Definition	121
9.7.2 Instance-set Determination	121
9.7.3 Query Definition	123
9.7.4 Distributed Action Definition	123
9.7.5 Scope in Instance-set Query Functions	124
9.7.6 Errors during Instance-set Query Functions	125
9.7.7 Halting and Returning Values from Query Functions	125
9.7.8 Instance-set Query Functions	125
9.7.8.1 Testing if Any Instance-set Satisfies a Query	125
9.7.8.2 Determining the First Instance-set Satisfying a Query	125
9.7.8.3 Determining All Instance-sets Satisfying a Query	126
9.7.8.4 Executing an Action for the First Instance-set Satisfying a Query	126
9.7.8.5 Executing an Action for All Instance-sets Satisfying a Query	127
9.7.8.6 Executing a Delayed Action for All Instance-sets	127
Section 10 - Defmodule Construct	129
10.1 Defining Modules	129
10.2 Specifying a Construct's Module	130
10.3 Specifying Modules	131
10.4 Importing and Exporting Constructs	131
10.4.1 Exporting Constructs	132
10.4.2 Importing Constructs	133
10.5 Importing and Exporting Facts and Instances	134
10.5.1 Specifying Instance-Names	134
10.6 Modules and Rule Execution	135
Section 11 - Constraint Attributes	137
11.1 Type Attribute	137
11.2 Allowed Constant Attributes	138
11.3 Range Attribute	139
11.4 Cardinality Attribute	139
11.5 Deriving a Default Value From Constraints	140
11.6 Constraint Violation Examples	140
Section 12 - Actions And Functions	143
12.1 Predicate Functions	143
12.1.1 Testing For Numbers	143
12.1.2 Testing For Floats	143
12.1.3 Testing For Integers	143
12.1.4 Testing For Strings Or Symbols	144
12.1.5 Testing For Strings	144
12.1.6 Testing For Symbols	144
12.1.7 Testing For Even Numbers	144
12.1.8 Testing For Odd Numbers	144
12.1.9 Testing For Multifield Values	145
12.1.10 Testing For External-Addresses	145
12.1.11 Comparing for Equality	145
12.1.12 Comparing for Inequality	145
12.1.13 Comparing Numbers for Equality	146
12.1.14 Comparing Numbers for Inequality	146
12.1.15 Greater Than Comparison	147
12.1.16 Greater Than or Equal Comparison	147
12.1.17 Less Than Comparison	148
12.1.18 Less Than or Equal Comparison	148
12.1.19 Boolean And	149
12.1.20 Boolean Or	149
12.1.21 Boolean Not	149
12.2 Multifield Functions	149
12.2.1 Creating Multifield Values	149
12.2.2 Specifying an Element	150
12.2.3 Finding an Element	150
12.2.4 Comparing Multifield Values	150
12.2.5 Deletion of Fields in Multifield Values	151
12.2.6 Creating Multifield Values from Strings.	151
12.2.7 Creating Strings from Multifield Values	152
12.2.8 Extracting a Sub-sequence from a Multifield Value	152
12.2.9 Replacing Fields within a Multifield Value	153
12.2.10 Inserting Fields within a Multifield Value	153
12.2.11 Getting the First Field from a Multifield Value	154
12.2.12 Getting All but the First Field from a Multifield Value	154
12.3 String Functions	154
12.3.1 String Concatenation	154
12.3.2 Symbol Concatenation	155
12.3.3 Taking a String Apart	155
12.3.4 Searching a String	155
12.3.5 Evaluating a Function within a String	156
12.3.6 Evaluating a Construct within a String	156
12.3.7 Converting a String to Uppercase	157
12.3.8 Converting a String to Lowercase	157
12.3.9 Comparing Two Strings	158
12.3.10 Determining the Length of a String	158
12.4 The CLIPS I/O System	158
12.4.1 Logical Names	159
12.4.2 Common I/O Functions	159
12.4.2.1 Open	159
12.4.2.2 Close	160
12.4.2.3 Printout	161
12.4.2.4 Read	161
12.4.2.5 Readline	162
12.4.2.6 Format	163
12.4.2.7 Rename	165
12.4.2.8 Remove	165
12.5 Math Functions	166
12.5.1 Standard Math Functions	166
12.5.1.1 Addition	166
12.5.1.2 Subtraction	166
12.5.1.3 Multiplication	167
12.5.1.4 Division	167
12.5.1.5 Integer Division	168
12.5.1.6 Maximum Numeric Value	168
12.5.1.7 Minimum Numeric Value	168
12.5.1.8 Absolute Value	169
12.5.1.9 Convert To Float	169
12.5.1.10 Convert To Integer	169
12.5.2 Extended Math Functions	170
12.5.2.1 Trigonometric Functions	171
12.5.2.2 Convert From Degrees to Grads	171
12.5.2.3 Convert From Degrees to Radians	172
12.5.2.4 Convert From Grads to Degrees	172
12.5.2.5 Convert From Radians to Degrees	172
12.5.2.6 Return the Value of _	173
12.5.2.7 Square Root	173
12.5.2.8 Power	173
12.5.2.9 Exponential	174
12.5.2.10 Logarithm	174
12.5.2.11 Logarithm Base 10	174
12.5.2.12 Round	175
12.5.2.13 Modulus	175
12.6 Procedural Functions	175
12.6.1 Binding Variables	175
12.6.2 If...then...else Function	177
12.6.3 While	178
12.6.4 Loop-for-count	178
12.6.5 Progn	179
12.6.6 Progn$	179
12.6.7 Return	180
12.6.8 Break	181
12.6.9 Switch	181
12.7 Miscellaneous Functions	182
12.7.1 Gensym	182
12.7.2 Gensym*	183
12.7.3 Setgen	183
12.7.4 Random	184
12.7.5 Seed	184
12.7.6 Time	184
12.7.7 Number of Fields or Characters in a Data Object	185
12.7.8 Determining the Restrictions for a Function	185
12.8 Deftemplate Functions	186
12.8.1 Getting the List of Deftemplates	186
12.8.2 Determining the Module in which a Deftemplate is Defined	186
12.9 Fact Functions	186
12.9.1 Creating New Facts	186
12.9.2 Removing Facts from the Fact-list	187
12.9.3 Modifying Template Facts	188
12.9.4 Duplicating Template Facts	188
12.9.5 Asserting a String	189
12.9.6 Getting the Fact-Index of a Fact-address	190
12.10 Deffacts Functions	190
12.10.1 Getting the List of Deffacts	190
12.10.2 Determining the Module in which a Deffacts is Defined	191
12.11 Defrule Functions	191
12.11.1 Getting the List of Defrules	191
12.11.2 Determining the Module in which a Defrule is Defined	191
12.12 Agenda Functions	191
12.12.1 Getting the Current Focus	191
12.12.2 Getting the Focus Stack	192
12.12.3 Removing the Current Focus from the Focus Stack	192
12.13 Defglobal Functions	193
12.13.1 Getting the List of Defglobals	193
12.13.2 Determining the Module in which a Defglobal is Defined	193
12.14 Deffunction Functions	194
12.14.1 Getting the List of Deffunctions	194
12.14.2 Determining the Module in which a Deffunction is Defined	194
12.15 Generic Function Functions	194
12.15.1 Getting the List of Defgenerics	194
12.15.2 Determining the Module in which a Generic Function is Defined	195
12.15.3 Getting the List of Defmethods	195
12.15.4 Type Determination	195
12.15.5 Existence of Shadowed Methods	196
12.15.6 Calling Shadowed Methods	196
12.15.7 Calling Shadowed Methods with Overrides	197
12.15.8 Calling a Specific Method	198
12.15.9 Getting the Restrictions of Defmethods	198
12.16 CLIPS Object-Oriented Language (COOL) Functions	199
12.16.1 Class Functions	199
12.16.1.1 Getting the List of Defclasses	199
12.16.1.2 Determining the Module in which a Defclass is Defined	200
12.16.1.3 Determining if a Class Exists	200
12.16.1.4 Superclass Determination	200
12.16.1.5 Subclass Determination	200
12.16.1.6 Slot Existence	201
12.16.1.7 Testing whether a Slot is Writable	201
12.16.1.8 Testing whether a Slot is Initializable	201
12.16.1.9 Testing whether a Slot is Public	201
12.16.1.10 Testing whether a Slot can be Accessed Directly	201
12.16.1.11 Message-handler Existence	202
12.16.1.12 Determining if a Class can have Direct Instances	202
12.16.1.13 Determining if a Class can Satisfy Object Patterns	202
12.16.1.14 Getting the List of Superclasses for a Class	202
12.16.1.15 Getting the List of Subclasses for a Class	203
12.16.1.16 Getting the List of Slots for a Class	203
12.16.1.17 Getting the List of Message-Handlers for a Class	204
12.16.1.18 Getting the List of Facets for a Slot	204
12.16.1.19 Getting the List of Source Classes for a Slot	205
12.16.1.20 Getting the Primitive Types for a Slot	206
12.16.1.21 Getting the Cardinality for a Slot	206
12.16.1.22 Getting the Allowed Values for a Slot	207
12.16.1.23 Getting the Numeric Range for a Slot	207
12.16.2 Message-handler Functions	208
12.16.2.1 Existence of Shadowed Handlers	208
12.16.2.2 Calling Shadowed Handlers	208
12.16.2.3 Calling Shadowed Handlers with Different Arguments	209
12.16.3 Definstances Functions	210
12.16.3.1 Getting the List of Definstances	210
12.16.3.2 Determining the Module in which a Definstances is Defined	210
12.16.4 Instance Manipulation Functions and Actions	210
12.16.4.1 Initializing an Instance	210
12.16.4.2 Deleting an Instance	211
12.16.4.3 Deleting the Active Instance from a Handler	211
12.16.4.4 Determining the Class of an Object	211
12.16.4.5 Determining the Name of an Instance	212
12.16.4.6 Determining the Address of an Instance	212
12.16.4.7 Converting a Symbol to an Instance-Name	212
12.16.4.8 Converting an Instance-Name to a Symbol	212
12.16.4.9 Predicate Functions	213
12.16.4.9.1 Testing for an Instance	213
12.16.4.9.2 Testing for an Instance-Address	213
12.16.4.9.3 Testing for an Instance-Name	213
12.16.4.9.4 Testing for the Existence an Instance	213
12.16.4.10 Reading a Slot Value	214
12.16.4.11 Setting a Slot Value	214
12.16.4.12 Multifield Slot Functions	214
12.16.4.12.1 Replacing Fields	214
12.16.4.12.2 Inserting Fields	215
12.16.4.12.3 Deleting Fields	215
12.17 Defmodule Functions	216
12.17.1 Getting the List of Defmodules	216
12.17.2 Setting the Current Module	216
12.17.3 Getting the Current Module	217
12.18 Sequence Expansion	217
12.18.1 Sequence Expansion and Rules	218
12.18.2 Multifield Expansion Function	219
12.18.3 Setting The Sequence Operator Recognition Behavior	219
12.18.4 Getting The Sequence Operator Recognition Behavior	219
12.18.5 Sequence Operator Caveat	220
Section 13 - Commands	221
13.1 Environment Commands	221
13.1.1 Loading Constructs From A File	221
13.1.2 Saving All Constructs To A File	221
13.1.3 Loading a Binary Image	221
13.1.4 Saving a Binary Image	222
13.1.5 Clearing CLIPS	222
13.1.6 Exiting CLIPS	223
13.1.7 Resetting CLIPS	223
13.1.8 Executing Commands From a File	223
13.1.9 Determining CLIPS Compilation Options	224
13.1.10 Calling the Operating System	224
13.1.11 Setting The Auto-Float Dividend Behavior	224
13.1.12 Getting The Auto-Float Dividend Behavior	225
13.1.13 Setting the Dynamic Constraint Checking Behavior	225
13.1.14 Getting the Dynamic Constraint Checking Behavior	225
13.1.15 Setting the Static Constraint Checking Behavior	225
13.1.16 Getting the Static Constraint Checking Behavior	225
13.1.17 Finding Symbols	226
13.2 Debugging Commands	226
13.2.1 Generating Trace Files	226
13.2.2 Closing Trace Files	226
13.2.3 Enabling Watch Items	227
13.2.4 Disabling Watch Items	228
13.2.5 Viewing the Current State of Watch Items	229
13.3 Deftemplate Commands	229
13.3.1 Displaying the Text of a Deftemplate	230
13.3.2 Displaying the List of Deftemplates	230
13.3.3 Deleting a Deftemplate	230
13.4 Fact Commands	230
13.4.1 Displaying the Fact-List	230
13.4.2 Loading Facts From a File	231
13.4.3 Saving The Fact-List To A File	231
13.4.4 Setting the Duplication Behavior of Facts	231
13.4.5 Getting the Duplication Behavior of Facts	232
13.5 Deffacts Commands	232
13.5.1 Displaying the Text of a Deffacts	232
13.5.2 Displaying the List of Deffacts	232
13.5.3 Deleting a Deffacts	233
13.6 Defrule Commands	233
13.6.1 Displaying the Text of a Rule	233
13.6.2 Displaying the List of Rules	233
13.6.3 Deleting a Defrule	234
13.6.4 Displaying Matches for a Rule	234
13.6.5 Setting a Breakpoint for a Rule	236
13.6.6 Removing a Breakpoint for a Rule	236
13.6.7 Displaying Rule Breakpoints	237
13.6.8 Refreshing a Rule	237
13.6.9 Setting the Incremental Reset Behavior	237
13.6.10 Getting the Incremental Reset Behavior	237
13.6.11 Determining the Logical Dependencies of a Pattern Entity	237
13.6.12 Determining the Logical Dependents of a Pattern Entity	238
13.7 Agenda Commands	238
13.7.1 Displaying the Agenda	238
13.7.2 Running CLIPS	239
13.7.3 Focusing on a Group of Rules	239
13.7.4 Stopping Rule Execution	239
13.7.5 Setting The Current Conflict Resolution Strategy	240
13.7.6 Getting The Current Conflict Resolution Strategy	240
13.7.7 Listing the Module Names on the Focus Stack	240
13.7.8 Removing all Module Names from the Focus Stack	240
13.7.9 Setting the Salience Evaluation Behavior	240
13.7.10 Getting the Salience Evaluation Behavior	241
13.7.11 Refreshing the Salience Value of Rules on the Agenda	241
13.8 Defglobal Commands	241
13.8.1 Displaying the Text of a Defglobal	241
13.8.2 Displaying the List of Defglobals	241
13.8.3 Deleting a Defglobal	242
13.8.4 Displaying the Values of Global Variables	242
13.8.5 Setting the Reset Behavior of Global Variables	242
13.8.6 Getting the Reset Behavior of Global Variables	243
13.9 Deffunction Commands	243
13.9.1 Displaying the Text of a Deffunction	243
13.9.2 Displaying the List of Deffunctions	243
13.9.3 Deleting a Deffunction	243
13.10 Generic Function Commands	243
13.10.1 Displaying the Text of a Generic Function Header	244
13.10.2 Displaying the Text of a Generic Function Method	244
13.10.3 Displaying the List of Generic Functions	244
13.10.4 Displaying the List of Methods for a Generic Function	244
13.10.5 Deleting a Generic Function	244
13.10.6 Deleting a Generic Function Method	245
13.10.7 Previewing a Generic Function Call	245
13.11 CLIPS Object-Oriented Language (COOL) Commands	246
13.11.1 Class Commands	246
13.11.1.1 Displaying the Text of a Defclass	246
13.11.1.2 Displaying the List of Defclasses	246
13.11.1.3 Deleting a Defclass	246
13.11.1.4 Examining a Class	247
13.11.1.5 Examining the Class Hierarchy	249
13.11.2 Message-handler Commands	250
13.11.2.1 Displaying the Text of a Defmessage-handler	250
13.11.2.2 Displaying the List of Defmessage-handlers	251
13.11.2.3 Deleting a Defmessage-handler	251
13.11.2.4 Previewing a Message	252
13.11.3 Definstances Commands	252
13.11.3.1 Displaying the Text of a Definstances	253
13.11.3.2 Displaying the List of Definstances	253
13.11.3.3 Deleting a Definstances	253
13.11.4 Instances Commands	253
13.11.4.1 Listing the Instances	253
13.11.4.2 Printing an Instance's Slots from a Handler	254
13.11.4.3 Saving Instances to a Text File	254
13.11.4.4 Saving Instances to a Binary File	254
13.11.4.5 Loading Instances from a Text File	255
13.11.4.6 Loading Instances from a Text File without Message Passing	255
13.11.4.7 Loading Instances from a Binary File	255
13.12 Defmodule Commands	256
13.12.1 Displaying the Text of a Defmodule	256
13.12.2 Displaying the List of Defmodules	256
13.13 Memory Management Commands	256
13.13.1 Determining the Amount of Memory Used by CLIPS	256
13.13.2 Determining the Number of Memory Requests Made by CLIPS	256
13.13.3 Releasing Memory Used by CLIPS	257
13.13.4 Conserving Memory	257
13.14 On-Line Help System	257
13.14.1 Using the CLIPS Help Facility	257
13.14.2 Finding the Help File	258
13.15 External Text Manipulation	258
13.15.1 External Text File Format	259
13.15.2 External Text Manipulation Functions	260
13.15.2.1 Fetch	261
13.15.2.2 Print-region	261
13.15.2.3 Toss	262
Appendix A - Glossary	263
Appendix B - Integrated Editor	273
Appendix C - Performance Considerations	277
C.1 Ordering of Patterns on the LHS	277
C.2 Deffunctions versus Generic Functions	278
C.3 Ordering of Method Parameter Restrictions	279
C.4 Instance-Addresses versus Instance-Names	279
C.5 Reading Instance Slots Directly	279
Appendix D - Differences Between Versions 5.1 and 6.0	281
Appendix E - Support Information	291
Appendix F - CLIPS Warning Messages	293
Appendix G - CLIPS Error Messages	295
Appendix H - CLIPS BNF	333
Appendix I - Reserved Function Names	341
Index	347

Preface

The History of CLIPS

The origins of the C Language Integrated Production System (CLIPS) date back to 1984 at NASA's Johnson Space Center. At this time, the Artificial Intelligence Section (now the Software Technology Branch) had developed over a dozen prototype expert systems applications using state-of-the-art hardware and software. However, despite extensive demonstrations of the potential of expert systems, few of these applications were put into regular use. This failure to provide expert systems technology within NASA's operational computing constraints could largely be traced to the use of LISP as the base language for nearly all expert system software tools at that time. In particular, three problems hindered the use of LISP based expert system tools within NASA: the low availability of LISP on a wide variety of conventional computers, the high cost of state-of-the-art LISP tools and hardware, and the poor integration of LISP with other languages (making embedded applications difficult).

The Artificial Intelligence Section felt that the use of a conventional language, such as C, would eliminate most of these problems, and initially looked to the expert system tool vendors to provide an expert system tool written using a conventional language. Although a number of tool vendors started converting their tools to run in C, the cost of each tool was still very high, most were restricted to a small variety of computers, and the projected availability times were discouraging. To meet all of its needs in a timely and cost effective manner, it became evident that the Artificial Intelligence Section would have to develop its own C based expert system tool.

The prototype version of CLIPS was developed in the spring of 1985 in a little over two months. Particular attention was given to making the tool compatible with expert systems under development at that time by the Artificial Intelligence Section. Thus, the syntax of CLIPS was made to very closely resemble the syntax of a subset of the ART expert system tool developed by Inference Corporation. Although originally modelled from ART, CLIPS was developed entirely without assistance from Inference or access to the ART source code.

The original intent of the prototype was to gain useful insight and knowledge about the construction of expert system tools and to lay the groundwork for the construction of a fully usable tool. The CLIPS prototype had numerous shortcomings, however, it demonstrated the feasibility of the project concept. After additional development, it became apparent that sufficient enhancements to the prototype would produce a low cost expert system tool that would be ideal for the purposes of training. Another year of development and internal use went into CLIPS improving its portability, performance, and functionality. A reference manual and user's guide were written during this time. The first release of CLIPS to groups outside of NASA, version 3.0, occurred in the summer of 1986.

Further enhancements transformed CLIPS from a training tool into a tool useful for the development and delivery of expert systems as well. Versions 4.0 and 4.1 of CLIPS, released respectively in the summer and fall of 1987, featured greatly improved performance, external language integration, and delivery capabilities. Version 4.2 of CLIPS, released in the summer of 1988, was a complete rewrite of CLIPS for code modularity. Also included with this release were an architecture manual providing a detailed description of the CLIPS software architecture and a utility program for aiding in the verification and validation of rule-based programs. Version 4.3 of CLIPS, released in the summer of 1989, added still more functionality.

Originally, the primary representation methodology in CLIPS was a forward chaining rule language based on the Rete algorithm (hence the Production System part of the CLIPS acronym). Version 5.0 of CLIPS, released in the spring of 1991, introduced two new programming paradigms: procedural programming (as found in languages such as C and Ada) and object-oriented programming (as found in languages such as the Common Lisp Object System and Smalltalk). The object-oriented programming language provided within CLIPS is called the CLIPS Object-Oriented Language (COOL). Version 5.1 of CLIPS, released in the fall of 1991, was primarily a software maintenance upgrade required to support the newly developed and/or enhanced X Window, MS-DOS, and Macintosh interfaces.

Because of its portability, extensibility, capabilities, and low-cost, CLIPS has received widespread acceptance throughout the government, industry, and academia. The development of CLIPS has helped to improve the ability to deliver expert system technology throughout the public and private sectors for a wide range of applications and diverse computing environments. CLIPS is being used by over 4,000 users throughout the public and private community including: all NASA sites and branches of the military, numerous federal bureaus, government contractors, universities, and many private companies. CLIPS is available at a nominal cost through COSMIC, the NASA software distribution center (for more on COSMIC, see appendix E of the Basic Programming Guide).

CLIPS Version 6.0

Version 6.0 of CLIPS contains five major enhancements. First, instances of user-defined classes in COOL can be pattern-matched on the left-hand side of rules. Second, CLIPS now contains considerable support for knowledge based systems software engineering. Support is now provided for building modular systems and many of the features previously available in CRSV are now directly supported in CLIPS (such as constraint consistency among uses of the same variable). Third, deftemplates can now have more than one multifield slot. Fourth, it is now possible to nest other conditional elements within a  and two new conditional elements,  and , are supported. Fifth, a Windows 3.1 CLIPS interface is now available for PC compatible computers. In addition, MS-DOS 286 and 386 versions of CLIPS are available which can use extended memory. For a detailed listing of differences between versions 5.1 and 6.0 of CLIPS, refer to appendix D of the Basic Programming Guide.


CLIPS Documentation

Three documents are provided with CLIPS.

•	The CLIPS Reference Manual which is split into the following parts: 

•	Volume I - The Basic Programming Guide, which provides the definitive description of CLIPS syntax and examples of usage. 

•	Volume II - The Advanced Programming Guide, which provides detailed discussions of the more sophisticated features in CLIPS and is intended for people with extensive programming experience who are using CLIPS for advanced applications.

•	Volume III - The Interfaces Guide, which provides information on machine-specific interfaces.

•	The CLIPS Users Guide which provides an introduction to CLIPS and is intended for people with little or no expert system experience. 

•	Volume I - Rules, which provides an introduction to rule-based programming using CLIPS. 

•	Volume II - Objects, which provides an introduction to object-oriented programming using COOL. 
 
•	The CLIPS Architecture Manual which provides a detailed description of the CLIPS software architecture. This manual describes each module of CLIPS in terms of functionality and purpose. It is intended for people with extensive programming experience who are interested in modifying CLIPS or who want to gain a deeper understanding of how CLIPS works.


Acknowledgements
As with any large project, CLIPS is the result of the efforts of numerous people. The primary contributors have been: Robert Savely, previous branch chief of the STB and now chief scientist of advanced software technology at JSC, who conceived the project and provided overall direction and support;  Chris Culbert, current branch chief of the STB, who managed the project, wrote the original CLIPS Reference Manual, and designed the original version of CRSV; Gary Riley, who designed and developed the rule-based portion of CLIPS, co-authored the CLIPS Reference Manual and CLIPS Architecture Manual, and developed the Macintosh interface for CLIPS; Brian Donnell, who designed and developed the CLIPS Object Oriented Language (COOL), co-authored the CLIPS Reference Manual and CLIPS Architecture Manual, and developed the previous MS-DOS interfaces for CLIPS; Bebe Ly, who was responsible for maintenance and enhancements to CRSV and is now responsible for developing the X Window interface for CLIPS; Chris Ortiz, who developed the Windows 3.1 interface for CLIPS; Dr. Joseph Giarratano of the University of Houston-Clear Lake, who wrote the CLIPS Users Guide; and Frank Lopez, who wrote the original prototype version of CLIPS.

Many other individuals contributed to the design, development, review, and general support of CLIPS, including: Jack Aldridge, Carla Armstrong, Paul Baffes, Ann Baker, Stephen Baudendistel, Les Berke, Tom Blinn, Marlon Boarnet, Dan Bochsler, Bob Brown, Barry Cameron, Tim Cleghorn, Major Paul Condit, Major Steve Cross, Andy Cunningham, Dan Danley, Mark Engelberg, Kirt Fields, Ken Freeman, Kevin Greiner, Ervin Grice, Sharon Hecht, Patti Herrick, Mark Hoffman, Grace Hua, Gordon Johnson, Phillip Johnston, Sam Juliano, Ed Lineberry, Bowen Loftin, Linda Martin, Daniel McCoy, Terry McGregor, Becky McGuire, Scott Meadows, C. J. Melebeck, Paul Mitchell, Steve Mueller, Cynthia Rathjen, Eric Raymond, Reza Razavipour, Marsha Renals, Monica Rua, Tim Saito, Gregg Swietek, Eric Taylor, James Villarreal, Lui Wang, Bob Way, Jim Wescott, Charlie Wheeler, and Wes White.

Section 1 - Introduction
This manual is the Basic Programming Guide for CLIPS. It is intended for users interested in the syntax of CLIPS. No previous expert system background is required, although a general understanding of computer languages is assumed. Section 2 of this manual provides an overview of the CLIPS language and basic terminology. Sections 3 through 11 provide additional details regarding the CLIPS programming language on topics such as rules and the CLIPS Object Oriented Programming Language (COOL). The types of actions and functions provided by CLIPS are defined in section 12. Finally, commands typically used from the CLIPS interactive interface are described in section 13.

The Basic Programming Guide documents just the basic CLIPS syntax. More advanced capabilities, such as user-defined functions, embedded applications, etc., are documented more fully in the Advanced Programming Guide. The Advanced Programming Guide is intended for users who have a complete knowledge of the CLIPS syntax and a programming background. It is not  necessary to read the Advanced Programming Guide to learn how to use CLIPS. CLIPS can be learned and simple expert systems can be built with the information provided in this manual.
Section 2 - CLIPS Overview
This section gives a general overview of CLIPS and of the basic concepts used throughout this manual.
2.1 INTERACTING WITH CLIPS
CLIPS expert systems may be executed in three ways: interactively using a simple, text-oriented, command prompt interface; interactively using a window/menu/mouse interface on certain machines; or as embedded expert systems in which the user provides a main program and controls execution of the expert system. Embedded applications are discussed in the Advanced Programming Guide. In addition, a series of commands can be automatically read directly from a file when CLIPS is first started or as the result of the batch command.

The generic CLIPS interface is a simple, interactive, text-oriented, command prompt interface for high portability. The standard usage is to create or edit a knowledge base using any standard text editor, save the knowledge base as one or more text files, exit the editor and execute CLIPS, then load the knowledge base into CLIPS. The interface provides commands for viewing the current state of the system, tracing execution, adding or removing information, and clearing CLIPS.

A more sophisticated window interface is available for the Macintosh, Windows 3.1, and X Window environments. All interface commands described in this section are available in the window interfaces. These interfaces are described in more detail in the Interfaces Guide.
2.1.1 Top Level Commands
The primary method for interacting with CLIPS in a non-embedded environment is through the CLIPS command prompt (or top level). When the "CLIPS>" prompt is printed, a command may be entered for evaluation. Commands may be function calls, constructs, global variables, or constants. If a function call is entered (see section 2.3.2), that function is evaluated and its return value is printed. Function calls in CLIPS use a prefix notation-the operands to a function always appear after the function name. Entering a construct definition (see section 2.3.3) at the CLIPS prompt creates a new construct of the appropriate type. Entering a global variable (see section 2.4.3) causes the value of the global variable to be printed. Entering a constant (see section 2.3.1) at the top level causes the constant to be printed (which is not very useful). For example, 

         CLIPS (V6.0 05/11/93)
CLIPS> (+ 3 4)
7
CLIPS> (defglobal ?*x* = 3)
CLIPS> ?*x*
3
CLIPS> red
red
CLIPS>

The previous example first called the addition function adding the numbers 3 and 4 to yield the result 7. A global variable ?*x* was then defined and given the value 3. The variable ?*x* was then entered at the prompt and its value of 3 was returned. Finally the constant symbol red was entered and was returned (since a constant evaluates to itself).
2.1.2 Automated Command Entry
Some operating systems allow additional arguments to be specified to a program when it begins execution. When the CLIPS executable is started under such an operating system, CLIPS can be made to automatically execute a series of commands read directly from a file. The command-line syntax for starting CLIPS and automatically reading commands from a file is as follows:
Syntax
clips -f <filename>

The -f is required, and <filename> is a file that contains CLIPS commands. If the exit command is included in the file, CLIPS will halt and the user is returned to the operating system after executing the commands in the file. If an exit command is not in the file, CLIPS will enter in its interactive state after executing the commands in the file. Commands in the file should be entered exactly as they would be interactively (i.e. opening and closing parentheses must be included and a carriage return must be at the end of the command). The -f command line option is equivalent to interactively entering a batch command as the first command to the CLIPS prompt. 
2.1.3 Integration with Other Languages
When using an expert system, two kinds of integration are important: embedding CLIPS in other systems, and calling external functions from CLIPS. CLIPS was designed to allow both kinds of integration.

Using CLIPS as an embedded application allows the easy integration of CLIPS with existing systems. This is useful in cases where the expert system is a small part of a larger task or needs to share data with other functions. In these situations, CLIPS can be called as a subroutine and information may be passed to and from CLIPS. Embedded applications are discussed in the Advanced Programming Guide.

It also may be useful to call external functions while executing a CLIPS construct or from the top-level of the interactive interface. CLIPS variables or literal values may be passed to an external function, and functions may return values to CLIPS. The easy addition of external functions allows CLIPS to be extended or customized in almost any way. The Advanced Programming Guide describes how to integrate CLIPS with functions or systems written in C as well as in other languages.
2.2 REFERENCE MANUAL SYNTAX
The terminology used throughout this manual to describe the CLIPS syntax is fairly common to computer reference manuals. Plain words or characters, particularly parentheses, are to be typed exactly as they appear. Bolded words or characters, however, represent a verbal description of what is to be entered. Sequences of words enclosed in single-angle brackets (called terms or non-terminal symbols), such as <string>, represent a single entity of the named class of items to be supplied by the user. A non-terminal symbol followed by a *, represents zero or more entities of the named class of items which must be supplied by the user. A non-terminal symbol followed by a +, represents one or more entities of the named class of items which must be supplied by the user. A * or + by itself is to be typed as it appears. Vertical and horizontal ellipsis (three dots arranged respectively vertically and horizontally) are also used between non-terminal symbols to indicate the occurrence of one or more entities. A term enclosed within square brackets, such as [<comment>], is optional (i.e. it may or may not be included). Vertical bars indicate a choice between multiple terms. White spaces (tabs, spaces, carriage returns) are used by CLIPS only as delimiters between terms and are ignored otherwise (unless inside double quotes). The ::= symbol is used to indicate how a non-terminal symbol can be replaced. For example, the following syntax description indicates that a <lexeme> can be replaced with either a <symbol> or a <string>.

<lexeme> ::= <symbol> | <string>

A complete BNF listing for CLIPS constructs along with some commonly used replacements for non-terminal symbols are listed in appendix H.
2.3 BASIC PROGRAMMING ELEMENTS
CLIPS provides three basic elements for writing programs: primitive data types, functions for manipulating data, and constructs for adding to a knowledge base.
2.3.1 Data Types
CLIPS provides eight primitive data types for representing information. These types are float, integer, symbol, string, externaladdress, factaddress, instancename and instanceaddress. Numeric information can be represented using floats and integers. Symbolic information can be represented using symbols and strings.

A .ib;number; consists only of digits (0-9), a decimal point (.), a sign (+ or -), and, optionally, an (e) for exponential notation with its corresponding sign. A number is either stored as a float; or an integer. Any number consisting of an optional sign followed by only digits is stored as an integer (represented internally by CLIPS as a C long integer). All other numbers are stored as floats (represented internally by CLIPS as a C double-precision float). The number of significant digits will depend on the machine implementation. Roundoff errors also may occur, again depending on the machine implementation. As with any computer language, care should be taken when comparing floating-point values to each other or comparing integers to floating-point values. Some examples of integers are

237	15	+12	-32

Some examples of floats are

237e3	15.09	+12.0	-32.3e-7

Specifically, integers use the following format:

<integer> ::= [+ | -] <digit>+

<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

Floating point numbers use the following format:

<float> ::= <integer> <exponent> |

            <integer> . [exponent]

            . <unsigned integer> [exponent]

            <integer> . <unsigned integer> [exponent]

<unsigned-integer> ::= <digit>+

<exponent> ::= e | E <integer>

A sequence of characters which does not exactly follow the format of a number is treated as a symbol (see the next paragraph).

A symbol in CLIPS is any sequence of characters that starts with any printable ASCII character and is followed by zero or more printable ASCII characters. When a delimiter is found, the symbol is ended. The following characters act as delimiters: any non-printable ASCII character (including spaces, tabs, carriage returns, and line feeds), a double quote, opening and closing parentheses "(" and ")", an ampersand "&", a vertical bar "|", a less than "<", and a tilde "~". A semicolon ";" starts a CLIPS comment (see section 2.3.3) and also acts as a delimiter. Delimiters may not be included in symbols with the exception of the "<" character which may be the first character in a symbol. In addition, a symbol may not begin with either the "?" character or the "$?" sequence of characters (although a symbol may contain these characters). These characters are reserved for variables (which are discussed later in this section). CLIPS is case sensitive (i.e. uppercase letters will match only uppercase letters). Note that numbers are a special case of symbols (i.e. they satisfy the definition of a symbol, but they are treated as a different data type). Some simple examples of symbols are

foo	Hello	B76-HI	bad_value

127A	456-93-039	@+=-%	2each

A string is a set of characters that starts with a double quote (") and is followed by zero or more printable characters. A string ends with double quotes. Double quotes may be embedded within a string by placing a backslash (\) in front of the character. A backslash may be embedded by placing two consecutive backslash characters in the string. Some examples are

"foo"	"a and b"	"1 number"	"a\"quote"

Note that the string "abcd" is not the same as the symbol abcd. They both contain the same characters, but are of different types. The same holds true for the instance name [abcd].

An externaladdress is the address of an external data structure returned by a function (written in a language such as C or Ada) that has been integrated with CLIPS. This data type can only be created by calling a function (i.e. it is not possible to specify an external-address by typing the value). In the basic version of CLIPS (which has no user defined external functions), it is not possible to create this data type. External-addresses are discussed in further detail in the ;Advanced Programming Guide. Within CLIPS, the printed representation of an external-address is 

<Pointer-XXXXXX>

where XXXXXX is the external-address.

A fact is a list of atomic values that are either referenced positionally (ordered facts) or by name (non-ordered or template facts). Facts are referred to by index or address; section 2.4.1 gives more details. The printed format of a factaddress is:

<Fact-XXX>

where XXX is the fact-index.

An instance is an object that is an instantiation or specific example of a class. Objects in CLIPS are defined to be floats, integers, symbols, strings, multifield values, externaladdresses, factaddresses or instances of a user-defined class. A userdefined class is created using the defclass construct. An instance of a user-defined class is created with the makeinstance function, and such an instance can be referred to uniquely by address. Within the scope of a module (see section 10.5.1), an instance can also be uniquely referred to by name. All of these definitions will be covered in more detail in Sections 2.4.2, 2.5.2.3, 2.6 and 9. An instancename is formed by enclosing a symbol within left and right brackets. Thus, pure symbols may not be surrounded by brackets. If the CLIPS Object Oriented Language (COOL) is not included in a particular CLIPS configuration, then brackets may be wrapped around symbols. Some examples of instance-names are:

[pump-1]	[foo]	[+++]	[123-890]

Note that the brackets are not part of the name of the instance; they merely indicate that the enclosed symbol is an instance-name. An instanceaddress can only be obtained by binding the return value of a function called instance-address or by binding a variable to an instance matching an object pattern on the LHS of a rule (i.e., it is not possible to specify an instance-address by typing the value). A reference to an instance of a user-defined class can either be by name or address; instance-addresses should only be used when speed is critical. Within CLIPS, the printed representation of an instance-address is 

<Instance-XXX>

where XXX is the name of the instance.

In CLIPS, a placeholder that has a value (one of the primitive data types) is referred to as a field. The primitive data types are referred to as singlefield values. A constant is a non-varying single field value directly expressed as a series of characters (which means that externaladdresses, factaddresses and instanceaddresses cannot be expressed as constants because they can only be obtained through function calls and variable bindings). A multifield value is a sequence of zero or more single field values. When displayed by CLIPS, multifield values are enclosed in parentheses. Collectively, single and multifield values are referred to as values. Some examples of multifield values are

(a)	(1 bar foo)	()	(x 3.0 "red" 567)

Note that the multifield value (a) is not the same as the single field value a. Multifield values are created either by calling functions which return multifield values, by using wildcard arguments in a deffunction, object message-handler, or method, or by binding variables during the pattern-matching process for rules. In CLIPS, a variable is a symbolic location that is used to store values. Variables are used by many of the CLIPS constructs (such as defrule, deffunction, defmethod, and defmessage-handler) and their usage is explained in the sections describing each of these constructs.
2.3.2 Functions
A function in CLIPS is a piece of executable code identified by a specific name which returns a useful value or performs a useful side effect (such as displaying information). Throughout the CLIPS documentation, the word function is generally used to refer only to functions which return a value (whereas commands and actions are used to refer to functions which have a side effect but generally do not return a value).

There are several types of functions. User defined functions and system defined functions are pieces of code that have been written in an external language (such as C, FORTRAN, or Ada) and linked with the CLIPS environment. System defined functions are those functions that have been defined internally by the CLIPS environment. User defined functions are functions that have been defined externally of the CLIPS environment. A complete list of system defined functions can be found in appendix I. 

The deffunction construct allows users to define new functions directly in the CLIPS environment using CLIPS syntax. Functions defined in this manner appear and act like other functions, however, instead of being directly executed (as code written in an external language would be) they are interpreted by the CLIPS environment. Deffunctions are also discussed in section 2.5.2.1 in the context of procedural knowledge representation.

Generic functions can be defined using the defgeneric and defmethod constructs. Generic functions allow different pieces of code to be executed depending upon the arguments passed to the generic function. Thus, a single function name can be overloaded with more than one piece of code. Generic functions are also discussed in section 2.5.2.2 in the context of procedural knowledge representation.

Function calls in CLIPS use a prefix notation - the arguments to a function always appear after the function name. Function calls begin with a left parenthesis, followed by the name of the function, then the arguments to the function follow (each argument separated by one or more spaces). Arguments to a function can be primitive data types, variables, or another function call. The function call is then closed with a right parenthesis. Some examples of function calls using the addition (+) and multiplication (*) functions are shown following.

(+ 3 4 5)
(* 5 6.0 2)
(+ 3 (* 8 9) 4)
(* 8 (+ 3 (* 2 3 4) 9) (* 3 4))

While a function refers to a piece of executable code identified by a specific name,  an expression refers to a function which has its arguments specified (which may or may not be functions calls as well). Thus the previous examples are expressions which make calls to the * and + functions.
2.3.3 Constructs
Several defining constructs appear in CLIPS: defmodule, defrule, deffacts, deftemplate, defglobal, deffunction, defclass, definstances, defmessagehandler, defgeneric, and defmethod. All constructs in CLIPS are surrounded by parentheses. The construct opens with a left parenthesis and closes with a right parenthesis. Defining a construct differs from calling a function primarily in effect. Typically a function call leaves the CLIPS environment unchanged (with some notable exceptions such as resetting or clearing the environment or opening a file). Defining a construct, however, is explicitly intended to alter the CLIPS environment by adding to the CLIPS knowledge base. Unlike function calls, constructs never have a return value.

As with any programming language, it is highly beneficial to comment CLIPS code. All constructs (with the exception of defglobal) allow a comment directly following the construct name. Comments also can be placed within CLIPS code by using a semicolon (;). Everything from the semicolon until the next return character will be ignored by CLIPS. If the semicolon is the first character in the line, the entire line will be treated as a comment. Examples of commented code will be provided throughout the reference manual. Semicolon commented text is not saved by CLIPS when loading constructs (however, the optional comment string within a construct is saved).
2.4 DATA ABSTRACTION
There are three primary formats for representing information in CLIPS: facts, objects and global variables.
2.4.1 Facts
Facts are one of the basic high-level forms for representing information in a CLIPS system. Each fact represents a piece of information which has been placed in the current list of facts, called the factlist. Facts are the fundamental unit of data used by rules (see section 2.5.1).

Facts may be added to the fact-list (using the assert command), removed from the fact-list (using the retract command), modified (using the modify command), or duplicated (using the duplicate command) through explicit user interaction or as a CLIPS program executes;. The number of facts in the fact-list  and the amount of information that can be stored in a fact is limited only by the amount of memory in the computer. If a fact is asserted into the fact-list that exactly matches an already existing fact, the new assertion will be ignored (however, this behavior can be changed, see sections 13.4.4 and 13.4.5).

Some commands, such as the retract, modify, and duplicate commands, require a fact to be specified. A fact can be specified either by factindex or factaddress. Whenever a fact is added (or modified) it is given a unique integer index called a fact-index. Fact-indices start at zero and are incremented by one for each new or changed fact. Whenever a reset or clear command is given, the fact-indices restart at zero. A fact may also be specified through the use of a fact-address. A fact-address can be obtained by capturing the return value of commands which return fact addresses (such as assert, modify, and duplicate) or by binding a variable to the fact address of a  fact which matches a pattern on the LHS of a rule (see section 5.4.1.8 for details).

A fact identifier is a shorthand notation for displaying a fact. It consists of the character "f", followed by a dash, followed by the fact-index of the fact. For example, f-10 refers to the fact with fact-index 10.

A fact is stored in one of two formats: ordered or non-ordered.
2.4.1.1 Ordered Facts
Ordered facts consist of a symbol followed by a sequence of zero or more fields separated by spaces and delimited by an opening parenthesis on the left and a closing parenthesis on the right. The first field of an ordered fact specifies a "relation" that applied to the remaining fields in the ordered fact. For example, (father-of jack bill) states that bill is the father of jack. 

Some examples of ordered facts are shown following.

(the pump is on)
(altitude is 10000 feet)
(grocery-list bread milk eggs) 

Fields in a non-ordered fact may be of any of the primitive data types (with the exception of the first field which must be a symbol), and no restriction is placed on the ordering of fields. The following symbols are reserved and should not be used as the first field in any fact (ordered or non-ordered): test, and, or, not, declare, logical, object, exists, and forall. These words are reserved only when used as a deftemplate name (whether explicitly defined or implied). These symbols may be used as slot names, however, this is not recommended. 
2.4.1.2 Non-ordered Facts
Ordered facts encode information positionally. To access that information, a user must know not only what data is stored in a fact but which field contains the data. Nonordered (or deftemplate) facts provide the user with the ability to abstract the structure of a fact by assigning names to each field in the fact. The deftemplate construct (see section 3) is used to create a template which can then be used to access fields by name. The deftemplate construct is analogous to a record or structure definition in programming languages such as Pascal and C.

The deftemplate construct allows the name of a template to be defined along with zero or more definitions of named fields or slots. Unlike ordered facts, the slots of a deftemplate fact may be constrained by type, value, and numeric range. In addition, default values can be specified for a slot. A slot consists of an opening parenthesis followed by the name of the slot, zero or more fields, and a closing parenthesis. Note that slots may not be used in an ordered fact and that positional fields may not be used in a deftemplate fact. 

Deftemplate facts are distinguished from ordered facts by the first field within the fact. The first field of all facts must be a symbol, however, if that symbol corresponds to the name of a deftemplate, then the fact is a deftemplate fact. The first field of a deftemplate fact is followed by a list of zero or more slots. As with ordered facts, deftemplate facts are enclosed by an opening parenthesis on the left and a closing parenthesis on the right.
 
Some examples of deftemplate facts are shown following.

(client (name "Joe Brown") (id X9345A))
(point-mass (x-velocity 100) (y-velocity -200))
(class (teacher "Martha Jones") (#-students 30) (Room "37A"))
(grocery-list (#-of-items 3) (items bread milk eggs))

Note that the order of slots in a deftemplate fact is not important. For example the following facts are all identical:

(class (teacher "Martha Jones") (#-students 30) (Room "37A"))
(class (#-students 30) (teacher "Martha Jones") (Room "37A"))
(class (Room "37A") (#-students 30) (teacher "Martha Jones"))

In contrast, note that the following ordered fact are not identical.

(class "Martha Jones" 30 "37A")
(class 30 "Martha Jones" "37A")
(class "37A" 30 "Martha Jones")

The immediate advantages of clarity and slot order independence for deftemplate facts should be readily apparent.

In addition to being asserted and retracted, deftemplate facts can also be modified and duplicated (using the modify and duplicate commands). Modifying a fact changes a set of specified slots within that fact. Duplicating a fact creates a new fact identical to the original fact and then changes a set of specified slots within the new fact. The benefit of using the modify and duplicate commands is that slots which don't change, don't have to be specified.
2.4.1.3 Initial Facts
The deffacts construct allows a set of a priori or initial knowledge to be specified as a collection of facts. When the CLIPS environment is reset (using the reset command) every fact specified within a deffacts construct in the CLIPS knowledge base is added to the factlist.
2.4.2 Objects
An object in CLIPS is defined to be a symbol, a string, a floating-point or integer number, a multifield value, an external-address or an instance of a user-defined class. Section 2.3.1 explains how to reference instances of user-defined classes. Objects are described in two basic parts: properties and behavior. A class is a template for common properties and behavior of objects which are instances of that class. Some examples of objects and their classes are:

Object (Printed Representation)
Class
Rolls-Royce
SYMBOL
"Rolls-Royce"
STRING
8.0
FLOAT
8
INTEGER
(8.0 Rolls-Royce 8 [Rolls-Royce])
MULTIFIELD
<Pointer- 00CF61AB>
EXTERNAL-ADDRESS
[Rolls-Royce]
CAR (a user-defined class)

Objects in CLIPS are split into two important categories: primitive types and instances of userdefined  classes. These two types of objects differ in the way they are referenced, created and deleted as well as how their properties are specified.

Primitive type objects are referenced simply by giving their value, and they are created and deleted implicitly by CLIPS as they are needed. Primitive type objects have no names or slots, and their classes are predefined by CLIPS. The behavior of primitive type objects is like that of instances of user-defined classes, however, in that you can define message-handlers and attach them to the primitive type classes. It is anticipated that primitive types will not be used often in an object-oriented programming (OOP) context; the main reason classes are provided for them is for use in generic functions. Generic functions use the classes of their arguments to determine which methods to execute; sections 2.3.2, 2.5.2.2 and 8 give more detail.

An instance of a user-defined class is referenced by name or address, and they are created and deleted explicitly via messages and special functions. The properties of an instance of a user-defined class are expressed by a set of slots, which the object obtains from its class. As previously defined, slots are named single field or multifield values. For example, the object Rolls-Royce is an instance of the class CAR. One of the slots in class CAR might be "price", and the Rolls-Royce object's value for this slot might be $75,000.00. The behavior of an object is specified in terms of procedural code called messagehandlers, which are attached to the object's class. Message-handlers and manipulation of objects are described in Section 2.5.2.3. All instances of a user-defined class have the same set of slots, but each instance may have different values for those slots. However, two instances which have the same set of slots do not necessarily belong to the same class, since two different classes can have identical sets of slots. 

The primary difference between object slots and template (or non-ordered) facts is the notion of inheritance. Inheritance allows the properties and behavior of a class to be described in terms of other classes. COOL supports multiple inheritance: a class may directly inherit slots and message-handlers from more than one class. Since inheritance is only useful for slots and message-handlers, it is often not meaningful to inherit from one of the primitive type classes, such as MULTIFIELD or NUMBER. This is because these classes cannot have slots and usually do not have message-handlers.

Further discussion on these topics can be found in Section 2.6, and a comprehensive description of the CLIPS Object-Oriented Language (COOL) can be found in Section 9.
2.4.2.1 Initial Objects
The definstances construct allows a set of a priori or initial knowledge to be specified as a collection of instances of user-defined classes. When the CLIPS environment is reset (using the reset command) every instance specified within a definstances construct in the CLIPS knowledge base is added to the instancelist.
2.4.3 Global Variables
The defglobal construct allows variables to be defined which are global in scope throughout the CLIPS environment. That is, a global variable can be accessed anywhere in the CLIPS environment and retains its value independent of other constructs. In contrast, some constructs (such as defrule and deffunction) allow local variables to be defined within the definition of the construct. These local variables can be referred to within the construct, but have no meaning outside the construct. A CLIPS global variable is similar to global variables found in procedural programming languages such as LISP, C and Ada. Unlike C and Ada, however, CLIPS global variables are weakly typed (they are not restricted to holding a value of a single data type).
2.5 KNOWLEDGE REPRESENTATION
CLIPS provides heuristic and procedural paradigms for representing knowledge. These two paradigms are discussed in this section. Object-oriented programming (which combines aspects of both data abstraction and procedural knowledge) is discussed in section 2.6.
2.5.1 Heuristic Knowledge - Rules
One of the primary methods of representing knowledge in CLIPS is a rule. Rules are used to represent heuristics, or "rules of thumb", which specify a set of actions to be performed for a given situation. The developer of an expert system defines a set of rules which collectively work together to solve a problem. A rule is composed of an antecedent and a consequent. The antecedent of a rule is also referred to as the if portion or the lefthand side (LHS) of the rule. The consequent of a rule is also referred to as the then portion or the righthand side (RHS) of the rule.

The antecedent of a rule is a set of conditions (or conditional elements) which must be satisfied for the rule to be applicable. In CLIPS, the conditions of a rule are satisfied based on the existence or non-existence of specified facts in the fact-list or specified instances of user-defined classes in the instance-list. One type of condition which can be specified is a pattern. Patterns consist of a set of restrictions which are used to determine which facts or objects satisfy the condition specified by the pattern. The process of matching facts and objects to patterns is called patternmatching. CLIPS provides a mechanism, called the inference engine, which automatically matches patterns against the current state of the fact-list and instance-list and determines which rules are applicable.

The consequent of a rule is the set of actions to be executed when the rule is applicable. The actions of applicable rules are executed when the CLIPS inference engine is instructed to begin execution of applicable rules. If more than one rule is applicable, the inference engine uses a conflict resolution strategy to select which rule should have its actions executed. The actions of the selected rule are executed (which may affect the list of applicable rules) and then the inference engine selects another rule and executes its actions. This process continues until no applicable rules remain.

In many ways, rules can be thought of as IF-THEN statements found in procedural programming languages such as C and Ada. However, the conditions of an IF-THEN statement in a procedural language are only evaluated when the program flow of control is directly at the IF-THEN statement. In contrast, rules act like WHENEVER-THEN statements. The inference engine always keeps track of rules which have their conditions satisfied and thus rules can immediately be executed when they are applicable. In this sense, rules are similar to exception handlers found in languages such as Ada.
2.5.2 Procedural Knowledge
CLIPS also supports a procedural paradigm for representing knowledge like that of more conventional languages, such as Pascal and C. Deffunctions and generic functions allow the user to define new executable elements to CLIPS that perform a useful side-effect or return a useful value. These new functions can be called just like the built-in functions of CLIPS. Message-handlers allow the user to define the behavior of objects by specifying their response to messages. Deffunctions, generic functions and messagehandlers are all procedural pieces of code specified by the user that CLIPS executes interpretively at the appropriate times. Defmodules allow a knowledge base to be partitioned.
2.5.2.1 Deffunctions
Deffunctions allow you to define new functions in CLIPS directly. In previous versions of CLIPS, the only way to have user-defined functions was to write them in some external language, such as C or Ada, and then recompile and relink CLIPS with the new functions. The body of a deffunction is a series of expressions similar to the RHS of a rule that are executed in order by CLIPS when the deffunction is called. The return value of a deffunction is the value of the last expression evaluated within the deffunction. Calling a deffunction is identical to calling any other function in CLIPS. Deffunctions are covered comprehensively in Section 7.
2.5.2.2 Generic Functions
Generic functions are similar to deffunctions in that they can be used to define new procedural code directly in CLIPS, and they can be called like any other function. However, generic functions are much more powerful because they can be overloaded. A generic function will do different things depending on the types (or classes) and number of its arguments. Generic functions are comprised of multiple components called methods, where each method handles different cases of arguments for the generic function. For example, you might overload the "+" operator to do string concatenation when it is passed strings as arguments. However, the "+" operator will still perform arithmetic addition when passed numbers. There are two methods in this example: an explicit one for strings defined by the user and an implicit one which is the standard CLIPS arithmetic addition operator. The return value of a generic function is the evaluation of the last expression in the method executed. Generic functions are covered comprehensively in Section 8.
2.5.2.3 Object Message-Passing
Objects are described in two basic parts: properties and behavior. Object properties are specified in terms of slots obtained from the object's class; slots are discussed in more detail in Section 2.4.2. Object behavior is specified in terms of procedural code called messagehandlers which are attached to the object's class. Objects are manipulated via message-passing. For example, to cause the Rolls-Royce object, which is an instance of the class CAR, to start its engine, the user must call the send function to send the message "start-engine" to the Rolls-Royce. How the Rolls-Royce responds to this message will be dictated by the execution of the message-handlers for "start-engine" attached to the CAR class and any of its superclasses. The result of a message is similar to a function call in CLIPS: a useful return value or side-effect.

Further discussion on message-handlers can be found in Section 2.6, and a comprehensive description of the CLIPS Object-Oriented Language (COOL) can be found in Section 9.
2.5.2.4 Defmodules
Defmodules allow a knowledge based to be partitioned. Every construct defined must be placed in a module. The programmer can explicitly control which constructs in a module are visible to other modules and which constructs from other modules are visible to a module. The visibility of facts and instances between modules can be controlled in a similar manner. Modules can also be used to control the flow of execution of rules. Defmodules are covered comprehensively in Section 10.
2.6 CLIPS OBJECT-ORIENTED LANGUAGE
This section gives a brief overview of the programming elements of the CLIPS Object-Oriented Language (COOL). COOL includes elements of data abstraction and knowledge representation. This section gives an overview of COOL as a whole, incorporating the elements of both concepts. Object references are discussed in Section 2.3.1, and the structure of objects is discussed in Sections 2.4.2 and 2.5.2.3. The comprehensive details of COOL are given in Section 9.
2.6.1 COOL Deviations from a Pure OOP Paradigm
In a pure OOP language, all programming elements are objects which can only be manipulated via messages. In CLIPS, the definition of an object is much more constrained: floating-point and integer numbers, symbols, strings, multifield values, external-addresses, fact-addresses and instances of user-defined classes. All objects may be manipulated with messages, except instances of user-defined classes, which must be. For example, in a pure OOP system, to add two numbers together, you would send the message "add" to the first number object with the second number object as an argument. In CLIPS, you may simply call the "+" function with the two numbers as arguments, or you can define message-handlers for the NUMBER class which allow you to do it in  the purely OOP fashion.

All programming elements which are not objects must be manipulated in a non-OOP utilizing function tailored for those programming elements. For example, to print a rule, you call the function ppdefrule; you do not send a message "print" to a rule, since it is not an object.
2.6.2 Primary OOP Features
There are five primary characteristics that an OOP system must possess: abstraction, encapsulation, inheritance, polymorphism and dynamic binding. An abstraction is a higher level, more intuitive representation for a complex concept. Encapsulation is the process whereby the implementation details of an object are masked by a well-defined external interface. Classes may be described in terms of other classes by use of inheritance. Polymorphism is the ability of different objects to respond to the same message in a specialized manner. Dynamic binding is the ability to defer the selection of which specific message-handlers will be called for a message until run-time.

The definitions of new classes allows the abstraction of new data types in COOL. The slots and message-handlers of these classes describe the properties and behavior of a new group of objects.

COOL supports encapsulation by requiring message-passing for the manipulation of instances of user-defined classes. An instance cannot respond to a message for which it does not have a defined message-handler.
 
COOL allows the user to specify some or all of the properties and behavior of a class in terms of one or more unrelated superclasses. This process is called multiple inheritance. COOL uses the existing hierarchy of classes to establish a linear ordering called the class precedence list for a new class. Objects which are instances of this new class can inherit properties (slots) and behavior (messagehandlers) from each of the classes in the class precedence list. The word precedence implies that properties and behavior of a class first in the list override conflicting definitions of a class later in the list.

One COOL object can respond to a message in a completely different way than another object; this is polymorphism. This is accomplished by attaching message-handlers with differing actions but which have the same name to the classes of these two objects respectively. 

Dynamic binding is supported in that an object reference (see section 2.3.1) in a send function call is not bound until run-time. For example, an instance-name or variable might refer to one object at the time a message is sent and another at a later time. 
2.6.3 Instance-set Queries and Distributed Actions
In addition to the ability of rules to directly pattern-match on objects, COOL provides a useful query system for determining, grouping  and performing actions on sets of instances of user-defined classes that meet user-defined criteria. The query system allows you to associate instances that are either related or not. You can simply use the query system to determine if a particular association set exists, you can save the set for future reference, or you can iterate an action over the set. An example of the use of the query system might be to find the set of all pairs of boys and girls that have the same age.

Section 3 - Deftemplate Construct
Ordered facts encode information positionally. To access that information, a user must know not only what data is stored in a fact but which field contains the data. Nonordered (or deftemplate) facts provide the user with the ability to abstract the structure of a fact by assigning names to each field found within the fact. The deftemplate construct is used to create a template which can then be used by non-ordered facts to access fields of the fact by name. The deftemplate construct is analogous to a record or structure definition in programming languages such as Pascal and C.

The syntax of  the deftemplate construct is:
Syntax
(deftemplate <deftemplate-name> [<comment>]
   <slot-definition>*)

<slot-definition> ::= <single-slot-definition> |
                      <multislot-definition>

<single-slot-definition> 
               ::= (slot <slot-name> 
                         <template-attribute>*)

<multislot-definition>   
               ::= (multislot <slot-name> 
                              <template-attribute>*)

<template-attribute> ::= <default-attribute> |
                         <constraint-attribute>

<default-attribute>  
               ::= (default ?DERIVE | ?NONE | <expression>*) |
                   (default-dynamic <expression>*)

Redefining a deftemplate will result in the previous definition being discarded. A deftemplate can not be redefined while it is being used (for example, by a fact or pattern in a rule). A deftemplate can have any number of single or multifeld slots. CLIPS always enforces the single and multifield definitions of the deftemplate. For example, it is an error to store (or match) multiple values in a single-field slot.

Example
(deftemplate object
   (slot name)
   (slot location)
   (slot on-top-of)
   (slot weight)
   (multislot contents))
3.1 SLOT DEFAULT VALUES
The <default-attribute> specifies the value to be used for unspecified slots of a template fact when an assert action is performed. One of two types of default selections can be chosen: default or dynamic-default.

The default attribute specifies a static default value. The specified expressions are evaluated once when the deftemplate is defined and the result is stored with the deftemplate. The result is assigned to the appropriate slot when a new template fact is asserted. If the keyword ?DERIVE is used for the default value, then a default value is derived from the constraints for the slot (see section 11.5 for more details). By default, the default attribute for a slot is (default ?DERIVE). If the keyword ?NONE is used for the default value, then a value must explicitly be assigned for a slot when an assert is performed. It is an error to assert a template fact without specifying the values for the (default ?NONE) slots.

The defaultdynamic attribute is a dynamic default. The specified expressions are evaluated every time a template facts is asserted, and the result is assigned to the appropriate slot.

A single-field slot may only have a single value for its default. Any number of values may be specified as the default for a multifield slot (as long as the number of values satisfies the cardinality attribute for the slot).
Example
CLIPS> (clear)
CLIPS> 
(deftemplate foo
   (slot w (default ?NONE))
   (slot x (default ?DERIVE))
   (slot y (default (gensym*)))
   (slot z (default-dynamic (gensym*))))
CLIPS> (assert (foo))

[TMPLTRHS1] Slot w requires a value because of its (default ?NONE) attribute.
CLIPS> (assert (foo (w 3)))
<Fact-0>
CLIPS> (assert (foo (w 4)))
<Fact-1>
CLIPS> (facts)
f-0     (foo (w 3) (x nil) (y gen1) (z gen2))
f-1     (foo (w 4) (x nil) (y gen1) (z gen3))
For a total of 2 facts.
CLIPS> 
3.2 SLOT DEFAULT CONSTRAINTS FOR PATTERN-MATCHING
Single-field slots that are not specified in a pattern on the LHS of a rule are defaulted to single-field wildcards (?) and multifield slots are defaulted to multifield wildcards ($?).
3.3 SLOT VALUE CONSTRAINT ATTRIBUTES
The syntax and functionality of single and multifield constraint attributes are described in detail in Section 11. Static and dynamic constraint checking for deftemplates is supported. Static checking is performed when constructs or commands using deftemplates slots are being parsed (and the specific deftemplate associated with the construct or command can be immediately determined). Template patterns used on the LHS of a rule are also checked to determine if constraint conflicts exist among variables used in more that one slot. Errors for inappropriate values are immediately signaled. References to factindexes made in commands such as modify and duplicate are considered to be ambiguous and are never checked using static checking. Static checking is enabled by default. This behavior can be changed using the setstaticconstraintchecking function. Dynamic checking is also supported. If dynamic checking is enabled, then new deftemplate facts have their values checked when added to the fact-list. This dynamic checking is disabled by default. This behavior can be changed using the setdynamicconstraintchecking function. If an violation occurs when dynamic checking is being performed, then execution will be halted.
Example
(deftemplate object
   (slot name
      (type SYMBOL)
      (default ?DERIVE))
   (slot location
      (type SYMBOL)
      (default ?DERIVE))
   (slot on-top-of
      (type SYMBOL)
      (default floor))
   (slot weight
      (allowed-values light heavy)
      (default light))
   (multislot contents
      (type SYMBOL)
      (default ?DERIVE)))
3.4 IMPLIED DEFTEMPLATES
Asserting or referring to an ordered fact (such as in a LHS pattern) creates an "implied" deftemplate with a single implied multifield slot. The implied multifield slot's name is not printed when the fact is printed. The implied deftemplate can be manipulated and examined identically to any user defined deftemplate (although it has no pretty print form).
Example
CLIPS> (clear)
CLIPS> (assert (foo 1 2 3))
<Fact-0>
CLIPS> (defrule yak (bar 4 5 6) =>)
CLIPS> (list-deftemplates)
initial-fact
foo
bar
For a total of 3 deftemplates.
CLIPS> (facts)
f-0     (foo 1 2 3)
For a total of 1 fact.
CLIPS>

Section 4 - Deffacts Construct
With the deffacts construct, a list of facts can be defined which are automatically asserted whenever the reset command is performed. Facts asserted through deffacts may be retracted or pattern-matched like any other fact. The initial factlist, including any defined deffacts, is always reconstructed after a reset command.
Syntax
(deffacts <deffacts-name> [<comment>]
   <RHS-pattern>*)

Redefining a currently existing deffacts causes the previous deffacts with the same name to be removed even if the new definition has errors in it. There may be multiple deffacts constructs and any number of facts (either ordered or deftemplate) may be asserted into the initial fact-list by each deffacts construct.

Dynamic expressions may be included in a fact by embedding the expression directly within the fact. All such expressions are evaluated when CLIPS is reset.
Example
(deffacts startup "Refrigerator Status"
   (refrigerator light on)
   (refrigerator door open)
   (refrigerator temp (get-temp)))

Upon startup and after a clear command, CLIPS automatically constructs the following deftemplate and deffacts.

(deftemplate initial-fact)

(deffacts initial-fact
   (initial-fact))

This deffacts provides a convenient method for starting the execution of a system - Rules that are given no conditional element are automatically given a pattern which matches the (initial-fact) fact. The initial-fact deffacts can be treated identically as any other deffacts defined by the user.


Section 5 - Defrule Construct
One of the primary methods of representing knowledge in CLIPS is a rule. A rule is a collection of conditions and the actions to be taken if the conditions are met. The developer of an expert system defines the rules which describe how to solve a problem. Rules execute (or fire) based on the existence or non-existence of facts or instances of user-defined classes. CLIPS provides the mechanism (the inference engine) which attempts to match the rules to the current state of the system (as represented by the factlist and instancelist) and applies the actions.

Throughout this section, the term pattern entity will be used to refer to either a fact or an instance of a user-defined class.
5.1 DEFINING RULES
Rules are defined using the defrule construct.
Syntax
(defrule <rule-name> [<comment>]
   [<declaration>]               ; Rule Properties
   <conditional-element>*        ; Left-Hand Side (LHS)
   =>
   <action>*)                    ; Right-Hand Side (RHS)
   
Redefining a currently existing defrule causes the previous defrule with the same name to be removed even if the new definition has errors in it. The LHS is made up of a series of conditional elements (CEs) which typically consist of pattern conditional elements (or just simply patterns) to be matched against pattern entities. An implicit and conditional element always surrounds all the patterns on the LHS. The RHS contains a list of actions to be performed when the LHS of the rule is satisfied. In addition, the LHS of a rule may also contain declarations about the rule's properties immediately following the rule's name and comment (see section 5.4.10 for more details). The arrow (=>) separates the LHS from the RHS. There is no limit to the number of conditional elements or actions a rule may have (other than the limitation placed by actual available memory). Actions are performed sequentially if, and only if, all conditional elements on the LHS are satisfied.

If no conditional elements are on the LHS, the pattern CE (initial-fact) or (initial-object) is automatically used. If no actions are on the RHS, the rule can be activated and fired but nothing will happen.

As rules are defined, they are incrementally reset. This means that CEs in newly defined rules can be satisfied by pattern entities at the time the rule is defined, in addition to pattern entities created after the rule is defined (see sections 13.1.7, 13.6.9, and 13.6.10 for more details). 
Example
(defrule example-rule   "This is an example of a simple rule"
   (refrigerator light on)
   (refrigerator door open)
   =>
   (assert (refrigerator food spoiled)))
5.2 BASIC CYCLE OF RULE EXECUTION
Once a knowledge base (in the form of rules) is built and the fact-list and instance-list is prepared, CLIPS is ready to execute rules. In a conventional language, the starting point, the stopping point, and the sequence of operations are defined explicitly by the programmer. With CLIPS, the program flow does not need to be defined quite so explicitly. The knowledge (rules) and the data (facts and instances) are separated, and the inference engine provided by CLIPS is used to apply the knowledge to the data. The basic execution cycle is as follows:

a)	If the rule firing limit has been reached or there is no current focus, then execution is halted. Otherwise, the top rule on the agenda of the module which is the current focus is selected for execution. If there are no rules on that agenda, then the current focus is removed from the focus stack and the current focus becomes the next module on the focus stack. If the focus stack is empty, then execution is halted, otherwise step a is executed again. See sections 5.4.10.2, 10.6, 12.2, and 13.7 for information on the focus stack and the current focus.

b)	The right-hand side (RHS) actions of the selected rule are executed. The use of the return function on the RHS of a rule may remove the current focus from the focus stack (see sections 10.6 and 12.6.7). The number of rules fired is incremented for use with the rule firing limit.

c)	As a result of step b, rules may be activated or deactivated. Activated rules (those rules whose conditions are currently satisfied) are placed on the agenda of the module in which they are defined. The placement on the agenda is determined by the salience of the rule and the current conflict resolution strategy (see sections 5.3, 5.4.10, 13.7.5, and 13.7.6). Deactivated rules are removed from the agenda. If the activations item is being watched (see section 13.2), then an informational message will be displayed each time a rule is activated or deactivated.

d)	If dynamic salience is being used, the salience values for all rules on the agenda are reevaluated (see sections 5.4.10, 13.7.9, and 13.7.10). Repeat the cycle beginning with step a.
5.3 CONFLICT RESOLUTION STRATEGIES
The agenda is the list of all rules which have their conditions satisfied (and have not yet been executed). Each module has its own agenda. The agenda acts similar to a stack (the top rule on the agenda is the first one to be executed). When a rule is newly activated, it's placement on the agenda is based (in order) on the following factors:

a)	Newly activated rules are placed above all rules of lower salience and below all rules of higher salience.

b)	Among rules of equal salience, the current conflict resolution strategy is used to determine the placement among the other rules of equal salience.

c)	If a rule is activated (along with several other rules) by the same assertion or retraction of a fact, and steps a and b are unable to specify an ordering, then the rule is arbitrarily (not randomly) ordered in relation to the other rules with which it was activated. Note, in this respect,  the order in which rules are defined has an arbitrary effect on conflict resolution (which is highly dependent upon the current underlying implementation of rules). Do not depend upon this arbitrary ordering for the proper execution of your rules.

CLIPS provides seven conflict resolution strategies: depth, breadth, simplicity, complexity, lex, mea, and random. The default strategy is depth. The current strategy can be set by using the setstrategy command (which will reorder the agenda based upon the new strategy).
5.3.1 Depth Strategy
Newly activated rules are placed above all rules of the same salience. For example, given that  fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-3 and rule-4 will be above rule-1 and rule-2 on the agenda. However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary.
5.3.2 Breadth Strategy
Newly activated rules are placed below all rules of the same salience. For example, given that  fact-a activates rule-1 and rule-2 and fact-b activates rule-3 and rule-4, then if fact-a is asserted before fact-b, rule-1 and rule-2 will be above rule-3 and rule-4 on the agenda. However, the position of rule-1 relative to rule-2 and rule-3 relative to rule-4 will be arbitrary.
5.3.3 Simplicity Strategy
Among rules of the same salience, newly activated rules are placed above all activations of rules with equal or higher specificity. The specificity of a rule is determined by the number of comparisons that must be performed on the LHS of the rule. Each comparison to a constant or previously bound variable adds one to the specificity. Each function call made on the LHS of a rule as part of the :, =, or test conditional element adds one to the specificity. The boolean functions and, or, and not do not add to the specificity of a rule, but their arguments do. Function calls made within a function call do not add to the specificity of a rule. For example, the following rule

(defrule example
   (item ?x ?y ?x)
   (test (and (numberp ?x) (> ?x (+ 10 ?y)) (< ?x 100)))
   =>)

has a specificity of 5. The comparison to the constant item, the comparison of ?x to its previous binding, and the calls to the numberp, <, and > functions each add one to the specificity for a total of 5. The calls to the and and + functions do not add to the specificity of the rule.
5.3.4 Complexity Strategy
Among rules of the same salience, newly activated rules are placed above all activations of rules with equal or lower specificity.
5.3.5 LEX Strategy
Among rules of the same salience, newly activated rules are placed using the OPS5 strategy of the same name. First the recency of the pattern entities that activated the rule is used to determine where to place the activation. Every fact and instance is marked internally with a "time tag" to indicate its relative recency with respect to every other fact and instance in the system. The pattern entities associated with each rule activation are sorted in descending order for determining placement. An activation with a more recent pattern entities is placed before activations with less recent pattern entities. To determine the placement order of two activations, compare the sorted time tags of the two activations one by one starting with the largest time tags. The comparison should continue until one activation's time tag is greater than the other activation's corresponding time tag. The activation with the greater time tag is placed before the other activation on the agenda.

If one activation has more pattern entities than the other activation and the compared time tags are all identical, then the activation with more time tags is placed before the other activation on the agenda. If two activations have the exact same recency, the activation with the higher specificity is placed above the activation with the lower specificity. Unlike OPS5, the not conditional elements in CLIPS have pseudo time tags which are used by the LEX conflict resolution strategy. The time tag of a not CE is always less than the time tag of a pattern entity, but greater than the time tag of a not CE that was instantiated after the not CE in question.

As an example, the following six activations have been listed in their LEX ordering (where the comma at the end of the activation indicates the presence of a not CE). Note that a fact's time tag is not necessarily the same as it's index (since instances are also assigned time tags), but if one fact's index is greater than another facts's index, then it's time tag is also greater. For this example, assume that the time tags and indices are the same. 

rule-6: f-1,f-4
rule-5: f-1,f-2,f-3,
rule-1: f-1,f-2,f-3
rule-2: f-3,f-1
rule-4: f-1,f-2,
rule-3: f-2,f-1

Shown following are the same activations with the fact indices sorted as they would be by the LEX strategy for comparison.

rule-6: f-4,f-1
rule-5: f-3,f-2,f-1,
rule-1: f-3,f-2,f-1
rule-2: f-3,f-1
rule-4: f-2,f-1,
rule-3: f-2,f-1
5.3.6 MEA Strategy
Among rules of the same salience, newly activated rules are placed using the OPS5 strategy of the same name. First the time tag of the pattern entity associated with the first pattern is used to determine where to place the activation. An activation thats first pattern's time tag is greater than another activations first pattern's time tag is placed before the other activation on the agenda. If both activations have the same time tag associated with the first pattern, then the LEX strategy is used to determine placement of the activation. Again, as with the CLIPS LEX strategy, negated patterns have pseudo time tags.

As an example, the following six activations have been listed in their MEA ordering (where the comma at the end of the activation indicates the presence of a negated pattern).

rule-2: f-3,f-1
rule-3: f-2,f-1
rule-6: f-1,f-4
rule-5: f-1,f-2,f-3,
rule-1: f-1,f-2,f-3
rule-4: f-1,f-2,
5.3.7 Random Strategy
Each activation is assigned a random number which is used to determine its placement among activations of equal salience. This random number is preserved when the strategy is changed so that the same ordering is reproduced when the random strategy is selected again (among activations that were on the agenda when the strategy was originally changed).
5.4 LHS SYNTAX
This section describes the syntax used on the LHS of a rule. The LHS of a CLIPS rule is made up of a series of conditional elements (CEs) that must be satisfied for the rule to be placed on the agenda. There are eight types of conditional elements: pattern CEs, test CEs, and CEs, or CEs, not CEs, exists CEs, forall CEs, and logical CEs. The pattern CE is the most basic and commonly used conditional element. Pattern CEs contain constraints which are used to determine if any pattern entities (facts or instances) satisfy the pattern. The test CE is used to evaluate expressions as part of the pattern-matching process. The and CE is used to specify that an entire group of CEs must all be satisfied. The or CE is used to specify that only one of a group of CEs must be satisfied. The not CE is used to specify that a CE must not be satisfied. The exists CE is used to test for the occurence of at least one partial match for a set of CEs. The forall CE is used to test that a set of CEs is satisfied for every partial match of a specified CE. Finally, the logical CE allows assertions of facts and the creation of instances on the RHS of a rule to be logically dependent upon pattern entities matching patterns on the LHS of a rule (truth maintenance).

Syntax
<conditional-element> ::= <pattern-CE> | 
                          <assigned-pattern-CE> | 
                          <not-CE> | 
                          <and-CE> |
                          <or-CE> |
                          <logical-CE> | 
                          <test-CE> |
                          <exists-CE> |
                          <forall-CE>
5.4.1 Pattern Conditional Element
Pattern conditional elements consist of a collection of field constraints, wildcards, and variables which are used to constrain the set of facts or instances which match the pattern CE. A pattern CE is satisfied by each and every pattern entity that satisfies its constraints. Field constraints are a set of constraints that are used to test a single field or slot of a pattern entity. A field constraint may consist of only a single literal constraint:literal;, however, it may also consist of several constraints connected together. In addition to literal constraints, CLIPS provides three other types of constraints: connective constraints, predicate constraints, and return value constraints. Wildcards are used within pattern CEs to indicate that a single field or group of fields can be matched by anything. Variables are used to store the value of a field so that it can be used later on the LHS of a rule in other conditional elements or on the RHS of a rule as an argument to an action.

The first field of any pattern must be a symbol and can not use any other constraints. This first field is used by CLIPS to determine if the pattern applies to an ordered fact, a template fact, or an instance. The symbol object is reserved to indicate an object pattern. Any other symbol used must correspond to a deftemplate name (or an implied deftemplate will be created). Slot names must also be symbols and can not contain any other constraints.

For object and deftemplate patterns, a single field slot can only contain one field constraint and that field constraint must only be able to match a single field (no multifield wildcards or variables). A multifield slot can contain any number of field constraints.

The examples and syntax shown in the following sections will be for ordered and deftemplate fact patterns. Section 5.4.1.7 will discuss differences between deftemplate patterns and object patterns. The following constructs are used by the examples.

(deffacts data-facts
  (data 1.0 blue "red")
  (data 1 blue)
  (data 1 blue red)
  (data 1 blue RED)
  (data 1 blue red 6.9))

(deftemplate person
  (slot name)
  (slot age)
  (multislot friends))

(deffacts people
  (person (name Joe) (age 20))
  (person (name Bob) (age 20))
  (person (name Joe) (age 34))
  (person (name Sue) (age 34))
  (person (name Sue) (age 20)))
5.4.1.1 Literal Constraints
The most basic constraint which can be used in a pattern CE is one which precisely defines the exact value that will match a field. This is called a literal constraint. A literal pattern CE consists entirely of constants such as floats, integers, symbols, strings, and instance names. It does not contain any variables or wildcards. All constraints in a literal pattern must be matched exactly by all fields of a pattern entity.

Syntax
An ordered pattern conditional element containing only literals has the following basic syntax:

(<constant-1> ... <constant-n>)

A deftemplate pattern conditional element containing only literals has the following basic syntax:

(<deftemplate-name> (<slot-name-1> <constant-1>)
                                        •
                                        •
                                        •
                    (<slot-name-n> <constant-n>))
Example 1
This example utilizes the data-facts deffacts shown in section 5.4.1.

CLIPS> (clear)
CLIPS> (defrule find-data (data 1 blue red) =>)
CLIPS> (reset)
CLIPS> (agenda)
0      find-data: f-3
For a total of 1 activation.
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data 1.0 blue "red")
f-2     (data 1 blue)
f-3     (data 1 blue red)
f-4     (data 1 blue RED)
f-5     (data 1 blue red 6.9)
For a total of 6 facts.
CLIPS>
Example 2
This example utilizes the person deftemplate and people deffacts shown in section 5.4.1.

CLIPS> (clear)
CLIPS> 
(defrule Find-Bob 
  (person (name Bob) (age 20)) 
  =>)
CLIPS>
(defrule Find-Sue
  (person (age 34) (name Sue))
  =>)
CLIPS> (reset)
CLIPS> (agenda)
0      Find-Sue: f-4
0      Find-Bob: f-2
For a total of 2 activations.
CLIPS> (facts)
f-0     (initial-fact)
f-1     (person (name Joe) (age 20) (friends))
f-2     (person (name Bob) (age 20) (friends))
f-3     (person (name Joe) (age 34) (friends))
f-4     (person (name Sue) (age 34) (friends))
f-5     (person (name Sue) (age 20) (friends))
For a total of 6 facts.
CLIPS> 
5.4.1.2 Wildcards Single- and Multifield
CLIPS has two wildcard symbols that may be used to match fields in a pattern. CLIPS interprets these wildcard symbols as standing in place of some part of a pattern entity. The singlefield wildcard, denoted by a question mark character (?), matches any value stored in exactly one field in the pattern entity. The multifield wildcard, denoted by a dollar sign followed by a question mark ($?), matches any value in zero or more fields in a pattern entity. Single-field and multifield wildcards may be combined in a single pattern in any combination. It is illegal to use a multifield wildcard in a single field slot of a deftemplate or object pattern. By default, an unspecified single-field slot in a deftemplate/object pattern is matched against an implied single-field wildcard. Similarly, an unspecified multifield slot in a deftemplate/object pattern is matched against an implied multifield-wildcard.

Syntax
An ordered pattern conditional element containing only literals and wildcards has the following basic syntax:

(<constraint-1> ... <constraint-n>)

where

<constraint> ::= <constant> | ? | $?

A deftemplate pattern conditional element containing only literals and wildcards has the following basic syntax:

(<deftemplate-name> (<slot-name-1> <constraint-1>)
                                        •
                                        •
                                        •
                    (<slot-name-n> <constraint-n>))
Example 1
This example utilizes the data-facts deffacts shown in section 5.4.1.

CLIPS> (clear)
CLIPS> 
(defrule find-data
  (data ? blue red $?)
  =>)
CLIPS> (reset)
CLIPS> (agenda)
0      find-data: f-5
0      find-data: f-3
For a total of 2 activations.
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data 1.0 blue "red")
f-2     (data 1 blue)
f-3     (data 1 blue red)
f-4     (data 1 blue RED)
f-5     (data 1 blue red 6.9)
For a total of 6 facts.
CLIPS> 
Example 2
This example utilizes the person deftemplate and people deffacts shown in section 5.4.1.

CLIPS> (clear)
CLIPS> 
(defrule match-all-persons
  (person)
  =>)
CLIPS> (reset)
CLIPS> (agenda)
0      match-all-persons: f-5
0      match-all-persons: f-4
0      match-all-persons: f-3
0      match-all-persons: f-2
0      match-all-persons: f-1
For a total of 5 activations.
CLIPS> (facts)
f-0     (initial-fact)
f-1     (person (name Joe) (age 20) (friends))
f-2     (person (name Bob) (age 20) (friends))
f-3     (person (name Joe) (age 34) (friends))
f-4     (person (name Sue) (age 34) (friends))
f-5     (person (name Sue) (age 20) (friends))
For a total of 6 facts.
CLIPS>

Multifield wildcard and literal constraints can be combined to yield some powerful pattern-matching capabilities. A pattern to match all of the facts that have the symbol YELLOW in any field (other than the first) could be written as

(data $? YELLOW $?)

Some examples of what this pattern would match are

(data YELLOW blue red green)
(data YELLOW red)
(data red YELLOW)
(data YELLOW)
(data YELLOW data YELLOW)

The last fact will match twice since YELLOW appears twice in the fact. The use of multifield wildcards should be confined to cases of patterns in which the single-field wildcard cannot create a pattern that satisfies the match required, since the multifield wildcard produces every possible match combination that can be derived from a pattern entity. This derivation of matches requires a significant amount of time to perform when compared to the time needed to perform a single-field match.
5.4.1.3 Variables Single- and Multifield
Wildcard symbols replace portions of a pattern and accept any value. The value of the field being replaced may be captured in a variable for comparison, display, or other manipulations. This is done by directly following the wildcard symbol with a variable name.

Syntax
Expanding on the syntax definition given in section 5.4.1.2 now gives:

<constraint> ::= <constant> | ? | $? |
                 <single-field-variable> |
                 <multifield-variable>

<single-field-variable> ::= ?<variable-symbol>

<multifield-variable>   ::= $?<variable-symbol>

where <variable-symbol> is similar to a symbol, except that it must start with an alphabetic character. Double quotes are not allowed as part of a variable name; i.e. a string cannot be used for a variable name. The rules for pattern-matching are similar to those for wildcard symbols. On its first appearance, a variable acts just like a wildcard in that it will bind to any value in the field(s). However, later appearances of the variable require the field(s) to match the binding of the variable. The binding will only be true within the scope of the rule in which it occurs. Each rule has a private list of variable names with their associated values; thus, variables are local to a rule. Bound variables can be passed to external functions. The $ operator has special significance on the LHS as a pattern-matching operator to indicate that zero or more fields need to be matched. In other places (such as the RHS of a rule), the $ in front of a variable indicates that sequence expansion should take place before calling the function. Thus, when passed as parameters in function calls (either on the LHS or RHS of a rule), multifield variables should not be preceded by the $ (unless sequence expansion is desired). All other uses of a multifield variable on the LHS of a rule, however, should use the $. It is illegal to use a multifield variable in a single field slot of a deftemplate/object pattern.
Example 1
CLIPS> (clear)
CLIPS> (reset)
CLIPS> (assert (data 2 blue green)
               (data 1 blue)
               (data 1 blue red))
<Fact-3>
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data 2 blue green)
f-2     (data 1 blue)
f-3     (data 1 blue red)
For a total of 4 facts.
CLIPS>
(defrule find-data-1
  (data ?x ?y ?z)
  =>
  (printout t ?x " : " ?y " : " ?z crlf))
CLIPS> (run)
1 : blue : red
2 : blue : green
CLIPS> 
Example 2
CLIPS> (reset)
CLIPS> (assert (data 1 blue)
               (data 1 blue red)
               (data 1 blue red 6.9))
<Fact-3>
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data 1 blue)
f-2     (data 1 blue red)
f-3     (data 1 blue red 6.9)
For a total of 4 facts.
CLIPS> 
(defrule find-data-1
  (data ?x $?y ?z)
  =>
  (printout t "?x = " ?x crlf
              "?y = " ?y crlf
              "?z = " ?z crlf
              "------" crlf))
CLIPS> (run)
?x = 1
?y = (blue red)
?z = 6.9
------
?x = 1
?y = (blue)
?z = red
------
?x = 1
?y = ()
?z = blue
------
CLIPS>

Once the initial binding of a variable occurs, all references to that variable have to match the value that the first binding matched. This applies to both single- and multifield variables. It also applies across patterns.
Example 3
CLIPS> (clear)
CLIPS> 
(deffacts data	
  (data red green)
  (data purple blue)
  (data purple green)	
  (data red blue green)
  (data purple blue green)
  (data purple blue brown))
CLIPS>   
(defrule find-data-1
  (data red ?x)
  (data purple ?x)
  =>)
CLIPS>
(defrule find-data-2
  (data red $?x)
  (data purple $?x)
  =>)
CLIPS> (reset)
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data red green)
f-2     (data purple blue)
f-3     (data purple green)
f-4     (data red blue green)
f-5     (data purple blue green)
f-6     (data purple blue brown)
For a total of 7 facts.
CLIPS> (agenda)
0      find-data-2: f-4,f-5
0      find-data-1: f-1,f-3
0      find-data-2: f-1,f-3
For a total of 3 activations.
CLIPS>
5.4.1.4 Connective Constraints
Three connective constraints are available for connecting individual constraints and variables to each other. These are the & (and), | (or), and ~ (not) connective constraints. The & constraint is satisfied if the two adjoining constraints are satisfied. The | constraint is satisfied if either of the two adjoining constraints is satisfied. The ~ constraint is satisfied if the following constraint is not satisfied. The connective constraints can be combined in almost any manner or number to constrain the value of specific fields while pattern-matching. The ~ constraint has highest precedence, followed by the & constraint, followed by the | constraint. Otherwise, evaluation of multiple constraints can be considered to occur from left to right.
Basic Syntax
Connective constraints have the following basic syntax:

<term-1>&<term-2> ... &<term-3>  

<term-1>|<term-2> ... |<term-3> 

~<term>

where <term> could be a single-field variable, multifield variable, constant, or connected constraint.

Syntax
Expanding on the syntax definition given in section 5.4.1.3 now gives:

<constraint> ::= ? | $? | <connected-constraint>

<connected-constraint> 
             ::= <single-constraint> |
                 <single-constraint> & <connected-constraint> |
                 <single-constraint> | <connected-constraint>

<single-constraint> ::= <term> | ~<term>

<term> ::= <constant> | 
           <single-field-variable> |
           <multifield-variable>

The & constraint typically is used only in conjunction with other constraints or variable bindings. Notice that connective constraints may be used together and/or with variable bindings. If the first term of a connective constraint is the first occurrence of a variable name, then the field will be constrained only by the remaining field constraints. The variable will be bound to the value of the field. If the variable has been bound previously, it is considered an additional constraint along with the remaining field constraints; i.e., the field must have the same value already bound to the variable and must satisfy the field constraints.
Example 1
CLIPS> (clear)
CLIPS> (deftemplate data-B (slot value))
CLIPS>  
(deffacts AB
  (data-A green)
  (data-A blue)
  (data-B (value red))
  (data-B (value blue)))
CLIPS> 
(defrule example1-1
  (data-A ~blue)
  =>)
CLIPS> 
(defrule example1-2
  (data-B (value ~red&~green))
  =>)
CLIPS> 
(defrule example1-3
  (data-B (value green|red))
  =>)
CLIPS> (reset)
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data-A green)
f-2     (data-A blue)
f-3     (data-B (value red))
f-4     (data-B (value blue))
For a total of 5 facts.
CLIPS> (agenda)
0      example1-2: f-4
0      example1-3: f-3
0      example1-1: f-1
For a total of 3 activations.
CLIPS> 
Example 2
CLIPS> (clear)
CLIPS> (deftemplate data-B (slot value))
CLIPS>  
(deffacts B
  (data-B (value red))
  (data-B (value blue)))
CLIPS> 
(defrule example2-1
  (data-B (value ?x&~red&~green))
  =>
  (printout t "?x in example2-1 = " ?x crlf))
CLIPS> 
(defrule example2-2
  (data-B (value ?x&green|red))
  =>
  (printout t "?x in example2-2 = " ?x crlf))
CLIPS> (reset)
CLIPS> (run)
?x in example2-1 = blue
?x in example2-2 = red
CLIPS>
Example 3
CLIPS> (clear)
CLIPS> (deftemplate data-B (slot value))
CLIPS> 
(deffacts AB
  (data-A green)
  (data-A blue)
  (data-B (value red))
  (data-B (value blue)))
CLIPS> 
(defrule example3-1
  (data-A ?x&~green)
  (data-B (value ?y&~?x))
  =>)
CLIPS> 
(defrule example3-2
  (data-A ?x)
  (data-B (value ?x&green|blue))
  =>)
CLIPS> 
(defrule example3-3
  (data-A ?x)
  (data-B (value ?y&blue|?x))
  =>)
CLIPS> (reset)
CLIPS> (facts)
f-0     (initial-fact)
f-1     (data-A green)
f-2     (data-A blue)
f-3     (data-B (value red))
f-4     (data-B (value blue))
For a total of 5 facts.
CLIPS> (agenda)
0      example3-3: f-1,f-4
0      example3-3: f-2,f-4
0      example3-2: f-2,f-4
0      example3-1: f-2,f-3
For a total of 4 activations.
CLIPS> 
5.4.1.5 Predicate Constraints
Sometimes it becomes necessary to constrain a field based upon the truth of a given boolean expression. CLIPS allows the use of a predicate constraint to restrict a field in this manner. The predicate constraint allows a predicate function (one returning the symbol FALSE for unsatisfied and a non-FALSE value for satisfied) to be called during the pattern-matching process. If the predicate function returns a nonFALSE value, the constraint is satisfied. If the predicate function returns the symbol FALSE, the constraint is not satisfied. A predicate constraint is invoked by following a colon with an appropriate function call to a predicate function. Typically, predicate constraints are used in conjunction with a connective constraint and a variable binding (i.e. you have to bind the variable to be tested and then connect it to the predicate constraint).
Basic Syntax
<function-call>

Syntax
Expanding on the syntax definition given in section 5.4.1.4 now gives:

<term> ::= <constant> | 
           <single-field-variable> |
           <multifield-variable> |
           :<function-call>

Multiple predicate constraints may be used to constrain a single field. Several predicate functions are provided by CLIPS (see section 12.2). Users also may develop their own predicate functions. 
Example 1
CLIPS> (clear)
CLIPS> 
(defrule example-1 
  (data ?x&:(numberp ?x))
  =>)
CLIPS> (assert (data 1) (data 2) (data red))
<Fact-2>
CLIPS> (agenda)
0      example-1: f-1
0      example-1: f-0
For a total of 2 activations.
CLIPS> 
Example 2
CLIPS> (clear)
CLIPS> 
(defrule example-2
  (data ?x&~:(symbolp ?x))
  =>)
CLIPS> (assert (data 1) (data 2) (data red))
<Fact-2>
CLIPS> (agenda)
0      example-2: f-1
0      example-2: f-0
For a total of 2 activations.
CLIPS> 
Example 3
CLIPS> (clear)
CLIPS> 
(defrule example-3
  (data ?x&:(numberp ?x)&:(oddp ?x))
  =>)
CLIPS> (assert (data 1) (data 2) (data red))
<Fact-2>
CLIPS> (agenda)
0      example-3: f-0
For a total of 1 activation.
CLIPS> 
Example 4
CLIPS> (clear)
CLIPS> 
(defrule example-4
  (data ?y)	
  (data ?x&:(> ?x ?y))
  =>)
CLIPS> (assert (data 3)  ; f-0
               (data 5)  ; f-1
               (data 9)) ; f-2
<Fact-2>
CLIPS> (agenda)
0      example-4: f-0,f-2
0      example-4: f-1,f-2
0      example-4: f-0,f-1
For a total of 3 activations.
CLIPS>
Example 5
CLIPS> (clear)
CLIPS> 
(defrule example-5
  (data $?x&:(> (length$ ?x) 2))
  =>)
CLIPS> (assert (data 1)      ; f-0
               (data 1 2)    ; f-1
               (data 1 2 3)) ; f-2
<Fact-2>
CLIPS> (agenda)
0      example-5: f-2
For a total of 1 activation.
CLIPS>
5.4.1.6 Return Value Constraints
It is possible to use the return value of an external function to constrain the value of a field. The return value constraint (=) allows the user to call external functions from inside a pattern. (This constraint is different from the comparison function which uses the same symbol. The difference can be determined from context.) The return value must be one of the primitive data types. This value is incorporated directly into the pattern at the position at which the function was called as if it were a literal constraint, and any matching patterns must match this value as though the rule were typed with that value. Note that the function is evaluated each time the constraint is checked (not just once).
Basic Syntax
=<function-call>

Syntax
Expanding on the syntax definition given in section 5.4.1.5 now gives:

<term> ::= <constant> | 
           <single-field-variable> |
           <multifield-variable> |
           :<function-call> |
           =<function-call>
Example 1
CLIPS> (clear)
CLIPS> (deftemplate data (slot x) (slot y))
CLIPS> 
(defrule twice
  (data (x ?x) (y =(* 2 ?x)))
  =>)
CLIPS> (assert (data (x 2) (y 4))  ; f-0
               (data (x 3) (y 9))) ; f-1
<Fact-1>
CLIPS> (agenda)
0      twice: f-0
For a total of 1 activation.
CLIPS>
Example 2
CLIPS> (clear)
CLIPS> 
(defclass DATA (is-a USER) 
   (role concrete) (pattern-match reactive) 
   (slot x (create-accessor write)))
CLIPS> 
(defrule return-value-example-2
   (object (is-a DATA)
           (x ?x1))
   (object (is-a DATA)
           (x ?x2&=(+ 5 ?x1)|=(- 12 ?x1)))
   =>)
CLIPS> (make-instance of DATA (x 4))
[gen1]
CLIPS> (make-instance of DATA (x 9))
[gen2]
CLIPS> (make-instance of DATA (x 3))
[gen3]
CLIPS> (agenda)
0      return-value-example-2: [gen3],[gen2]
0      return-value-example-2: [gen2],[gen3]
0      return-value-example-2: [gen1],[gen2]
For a total of 3 activations.
CLIPS> 
5.4.1.7 Pattern-Matching with Object Patterns
Instances of user-defined classes in COOL can be pattern-matched on the left-hand side of rules. Patterns can only match objects of classes which are defined before the pattern and which are in scope for the current module. Any classes which could have objects which match the pattern cannot be deleted or changed until the pattern is deleted. Even if a rule is deleted by its RHS, the classes bound to its patterns cannot be changed until after the RHS finishes executing.

When an instance is created or deleted, all patterns applicable to that object are updated. However, when a slot is changed, only those patterns which explicitly match on that slot are affected. Thus, one could use logical dependencies to hook to a change to a particular slot (rather than a change to any slot, which is all that is possible with deftemplates).

Changes to non-reactive slots or instances of non-reactive classes (see sections 9.3.2.2 and 9.3.3.7) will have no effect on rules. Also Rete network activity will not be immediately apparent after changes to slots are made if pattern-matching is being delayed through the use of the makeinstance, i.initialize-instance;, i.modify-instance;, i.message-modify-instance;, i.duplicate-instance;, i.message-duplicate-instance; or objectpatternmatchdelay functions.

Syntax
<object-pattern>       ::= (object <attribute-constraint>*)

<attribute-constraint> ::= (is-a <constraint>) |
                           (name <constraint>) |
                           (<slot-name> <constraint>*)

The is-a constraint is used for specifying class constraints such as "Is this object a member of class FOO?". The is-a constraint also encompasses subclasses of the matching classes unless specifically excluded by the pattern. The name constraint is used for specifying a specific instance on which to pattern-match. The evaluation of the name constraint must be of primitive type instance-name, not symbol. Multifield constraints (such as $?) cannot be used with the is-a or name constraints. Other than these special cases, constraints used in object slots work similarly to constraints used in deftemplate slots. As with deftemplate patterns, slot names for object patterns must be symbols and can not contain any other constraints.
Example 1
The following rules illustrate pattern-matching on an object's class.

(defrule class-match-1 
  (object)
  =>)

(defrule class-match-2
  (object (is-a FOO))
  =>)

(defrule class-match-3
  (object (is-a FOO | BAR))
  =>)

(defrule class-match-4
  (object (is-a ?x))
  (object (is-a ~?x))
  =>)

Rule class-match-1 is satisified by all instances of any reactive class. Rule class-match-2 is satisfied by all instances of class FOO. Rule class-match-3 is satisfied by all instances of class FOO or BAR. Rule class-match-4 will be satisfied by any two instances of mutually exclusive classes.
Example 2
The following rules illustrate pattern-matching on various attributes of an object's slots.

(defrule slot-match-1
  (object (width))
  =>)

(defrule slot-match-2
  (object (width ?))
  =>)

(defrule slot-match-3
  (object (width $?))
  =>)

Rule slot-match-1 is satisfied by all instances of reactive classes that contain a reactive width slot with a zero length multifield value. Rule slot-match-2 is satisfied by all instances of reactive classes that contain a reactive single or multifield width slot that is bound to a single value. Rule slot-match-3 is satisfied by all instances of reactive classes that contain a reactive single or multifield width slot that is bound to any number of values. Note that a slot containing a zero length multifield value would satisfy rules slot-match-1 and slot-match-3, but not rule slot-match-2 (because the value's cardinality is zero).
Example 3
The following rules illustrate pattern-matching on the slot values of an object.

(defrule value-match-1 
  (object (width 10)
  =>)

(defrule value-match-2
  (object (width ?x&:(> ?x 20)))
  =>)

(defrule value-match-3
  (object (width ?x) (height ?x))
  =>)

Rule value-match-1 is satisified by all instances of reactive classes that contain a reactive width slot with value 10. Rule value-match-2 is satisfied by all instances of reactive classes that contain a reactive width slot that has a value greater than 20. Rule value-match-3 is satisfied by all instances of reactive classes that contain a reactive width and height slots with the same value.
5.4.1.8 Pattern-Addresses
Certain RHS actions, such as retract and unmakeinstance, operate on an entire pattern CE. To signify which fact or instance they are to act upon, a variable can be bound to the factaddress or instanceaddress of a pattern CE. Collectively, fact-addresses and instance-addresses bound on the LHS of a rule are referred to as patternaddresses.
Syntax
<assigned-pattern-CE> ::= ?<variable-symbol> <- <pattern-CE>

The left arrow, <-, is a required part of the syntax. A variable bound to a fact-address or instance-address can be compared to other variables or passed to external functions. Variables bound to a fact or instance-address may later be used to constrain fields within a pattern CE, however, the reverse is not allowed. It is an error to bind a varible to a not CE.
Examples
(defrule dummy
   (data 1)
   ?fact <- (dummy pattern)
   =>
   (retract ?fact))

(defrule compare-facts-1    
   ?f1 <- (color ~red)
   ?f2 <- (color ~green)
   (test (neq ?f1 ?f2))
   =>
   (printout t "Rule fires from different facts" crlf))

(defrule compare-facts-2    
   ?f1 <- (color ~red)
   ?f2 <- (color ~green&:(neq ?f1 ?f2))
   =>
   (printout t "Rule fires from different facts" crlf))

(defrule print-and-delete-all-objects
   ?ins <- (object)
   =>
   (send ?ins print)
   (unmake-instance ?ins))
5.4.2 Test Conditional Element
Field constraints used within pattern CEs allow very descriptive constraints to be applied to pattern-matching. Additional capability is provided with the test conditional element. The test CE is satisfied if the function call within the test CE evaluates to a non-FALSE value and unsatisfied if the function call evaluates to FALSE. As with predicate constraints, the user can compare the variable bindings that already have occurred in any manner. Mathematical comparisons on variables (e.g., is the difference between ?x and ?y greater than some value?) and complex logical or equality comparisons can be done. External functions also can be called which compare variables in any way that the user desires.

Any kind of external function may be embedded within a test conditional element (or within field constraints). User-defined predicate functions must take arguments as defined in the Advanced Programming Guide. Several predicate functions are provided by CLIPS (see section 12.1). 
Syntax
<test-CE> ::= (test <function-call>)

Since the symbol test is used to indicate this type of conditional element, rules may not use the symbol test as the first field in a pattern CE. A test CE is evaluated when all proceeding CEs are satisfied. This means that a test CE will be evaluated more than once if the proceeding CEs can be satisfied by more than one group of pattern entities. In order to cause the reevaluation of a test CE, a pattern entity matching a CE prior to the test CE must be changed. The use of test CEs can cause additional CEs to be added to the rule. In addition, test CEs may also be automatically reordered by CLIPS. See section 5.4.9 for more details.
Example 1
This example checks to see if the difference between two numbers is greater than or equal to three:

CLIPS> (clear)
CLIPS> 
(defrule example-1
  (data ?x)
  (value ?y)
  (test (>= (abs (- ?y ?x)) 3))
  =>)
CLIPS> (assert (data 6) (value 9))
<Fact-1>
CLIPS> (agenda)
0      example-1: f-0,f-1
For a total of 1 activation.
CLIPS>
Example 2
This example checks to see if there is a positive slope between two points on a line.

CLIPS> (clear)
CLIPS> 
(deffunction positive-slope
   (?x1 ?y1 ?x2 ?y2)
   (< 0 (/ (- ?y2 ?y1) (- ?x2 ?x1))))
CLIPS> 
(defrule example-2
   (point ?a ?x1 ?y1)
   (point ?b ?x2 ?y2)
   (test (> ?b ?a))
   (test (positive-slope ?x1 ?y1 ?x2 ?y2))
   =>)
CLIPS> 
(assert (point 1 4.0 7.0) (point 2 5.0 9.0))
<Fact-1>
CLIPS> (agenda)
0      example-2: f-0,f-1
For a total of 1 activation.
CLIPS>
5.4.3 Or Conditional Element
The or conditional element allows any one of several conditional elements to activate a rule. If any of the conditional elements inside of the or CE is satisfied, then the or CE is satisfied. If all other LHS conditional elements are satisfied, the rule will be activated. Note that a rule will be activated for each conditional element with an or CE that is satisfied (assuming the other conditional elements of the rule are also satisfied). Any number of conditional elements may appear within an or CE. The or CE produces the identical effect of writing several rules with similar LHS's and RHS's.
Syntax
<or-CE> ::= (or <conditional-element>+) 
       
Again, if more than one of the conditional elements in the or CE can be met, the rule will fire multiple times, once for each satisfied combination of conditions.
Example
 (defrule system-fault
   (error-status unknown)
   (or (temp high)
       (valve broken)
       (pump (status off)))
   =>
   (printout t "The system has a fault." crlf))

Note that the above example is exactly equivalent to the following three (separate) rules:

(defrule system-fault
   (error-status unknown)
   (pump (status off))
   =>
   (printout t "The system has a fault." crlf))

(defrule system-fault
   (error-status unknown)
   (valve broken)
   =>
   (printout t "The system has a fault." crlf))

(defrule system-fault
   (error-status unknown)
   (temp high)
   =>
   (printout t "The system has a fault." crlf))
5.4.4 And Conditional Element
CLIPS assumes that all rules have an implicit and conditional element surrounding the conditional elements on the LHS. This means that all conditional elements on the LHS must be satisfied before the rule can be activated. An explicit and conditional element is provided to allow the mixing of and CEs and or CEs. This allows other types of conditional elements to be grouped together within or and not CEs. The and CE is satisfied if all of the CEs inside of the explicit and CE are satisfied. If all other LHS conditions are true, the rule will be activated. Any number of conditional elements may be placed within an and CE.
Syntax
<and-CE> ::= (and <conditional-element>+)
Example
(defrule system-flow
   (error-status confirmed)
   (or (and (temp high)
            (valve closed))
       (and (temp low)
            (valve open)))
   =>
   (printout t "The system is having a flow problem." crlf))

An and CE that has a test or not CE as its first CE has the pattern (initial-fact) or (initial-object) added as the first CE. Note that the LHS of any rule is enclosed within an implied and CE. For example, the following rule

(defrule nothing-to-schedule
  (not (schedule ?))
  =>
  (printout t "Nothing to schedule." crlf))

is converted to

(defrule nothing-to-schedule 
  (and (initial-fact) 
       (not (schedule ?)))
  =>
  (printout t "Nothing to schedule." crlf))
5.4.5 Not Conditional Element
Sometimes the lack of information is meaningful; i.e., one wishes to fire a rule if a pattern entity or other CE does not exist. The not conditional element provides this capability. The not CE is satisfied only if the conditional element contained within it is not satisfied. As with other conditional elements, any number of additional CEs may be on the LHS of the rule and field constraints may be used within the negated pattern.
Syntax
<not-CE> ::= (not <conditional-element>)

Only one CE may be negated at a time. Multiple patterns may be negated by using multiple not CEs. Care must be taken when combining not CEs with or and and CEs; the results are not always obvious!  The same holds true for variable bindings within a not CE. Previously bound variables may be used freely inside of a not CE. However, variables bound for the first time within a not CE can be used only in that pattern.
Examples
(defrule high-flow-rate
   (temp high)
   (valve open)
   (not (error-status confirmed))
   =>
   (printout t "Recommend closing of valve due to high temp"
               crlf))

   (defrule check-valve
   (check-status ?valve)
   (not (valve-broken ?valve))
   =>
   (printout t "Device " ?valve " is OK" crlf))

(defrule double-pattern
   (data red)
   (not (data red ?x ?x))
   =>
   (printout t "No patterns with red green green!" crlf ))

A not CE that contains a single test CE is converted such that the test CE is contained within an and CE and is preceded by the (initial-fact) or (initial-object) pattern. For example, the following conditional element

(not (test (> ?time-1 ?time-2)))

is converted to

(not (and (initial-fact)
          (test (> ?time-1 ?time-2))))

Note that it is much simpler just to convert the test CE to the following format:

(test (not (> ?time-1 ?time-2)))
5.4.6 Exists Conditional Element
The exists conditional element provides a mechanism for determining if a group of specified CEs is satisfied by a least one set of pattern entities.
Syntax
<exists-CE> ::= (exists <conditional-element>+)

The exists CE is implemented by replacing the exists keyword with two nested not CEs. For example, the following rule

(defrule example
   (exists (a ?x) (b ?x))
   =>)

is equivalent to the rule below

(defrule example
   (not (not (and (a ?x) (b ?x))))
   =>)

Because of the way the exists CE is implemented using not CEs, the restrictions which apply to CEs found within not CEs (such as binding a pattern CE to a fact-address) also apply to the CEs found within an exists CE. 
Example
Given the following constructs,

CLIPS> (clear)
CLIPS>
(deftemplate hero 
   (multislot name) 
   (slot status (default unoccupied)))
CLIPS> 
(deffacts goal-and-heroes
   (goal save-the-day)
   (hero (name Death Defying Man))
   (hero (name Stupendous Man))
   (hero (name Incredible Man)))
CLIPS> 
(defrule save-the-day
   (goal save-the-day)
   (exists (hero (status unoccupied)))
   =>
   (printout t "The day is saved." crlf))
CLIPS> 

the following commands illustrate that even though there are three facts which can match the second CE in the save-the-day rule, there is only one partial match generated.

CLIPS> (reset)
CLIPS> (agenda)
0      save-the-day: f-1,
For a total of 1 activation.
CLIPS> (facts)
f-0     (initial-fact)
f-1     (goal save-the-day)
f-2     (hero (name Death Defying Man) (status unoccupied))
f-3     (hero (name Stupendous Man) (status unoccupied))
f-4     (hero (name Incredible Man) (status unoccupied))
For a total of 5 facts.
CLIPS> (matches save-the-day)
Matches for Pattern 1
f-1
Matches for Pattern 2
f-0
Matches for Pattern 3
f-2
f-3
f-4
Partial matches for CEs 1 - 2
f-1,
Activations
f-1,
CLIPS> 
5.4.7 Forall Conditional Element
The forall conditional element provides a mechanism for determining if a group of specified CEs is satisfied for every occurence of another specified CE.
Syntax
<forall-CE> ::= (forall <conditional-element> 
                        <conditional-element>+)

The forall CE is implemented by replacing the forall keyword with combinations of not and and CEs. For example, the following rule

(defrule example
   (forall (a ?x) (b ?x) (c ?x))
   =>)

is equivalent to the rule below

(defrule example
   (not (and (a ?x)
             (not (and (b ?x) (c ?x)))))
   =>)

Because of the way the forall CE is implemented using not CEs, the restrictions which apply to CE found within not CEs (such as binding a pattern CE to a fact-address) also apply to the CEs found within an forall CE. 
Example
The following rule determines if every student has passed in reading, writing, and arithmetic by using the forall CE.

CLIPS> (clear)
CLIPS>
(defrule all-students-passed
   (forall (student ?name)
           (reading ?name)
           (writing ?name)
           (arithmetic ?name))
   =>
   (printout t "All students passed." crlf))
CLIPS> 

The following commands illustrate how the forall CE works in the all-students-passed rule. Note that initially the all-students-passed rule is satisfied because there are no students.

CLIPS> (reset)
CLIPS> (agenda)
0      all-students-passed: f-0,
For a total of 1 activation.
CLIPS>

After the (student Bob) fact is asserted, the rule is no longer satisfied since Bob has not passed reading, writing, and arithmetic.

CLIPS> (assert (student Bob))
<Fact-1>
CLIPS> (agenda)
CLIPS> 

The rule is still not satisfied after Bob has passed reading and writing, since he still has not passed arithmetic.

CLIPS> (assert (reading Bob) (writing Bob))
<Fact-3>
CLIPS> (agenda)
CLIPS> 

Once Bob has passed arithmetic, the all-students-passed rule is reactivated.

CLIPS> (assert (arithmetic Bob))
<Fact-4>
CLIPS> (agenda)
0      all-students-passed: f-0,
For a total of 1 activation.
CLIPS>

If a new student is asserted, then the rule is taken off the agenda, since John has not passed reading, writing, and arithmetic.

CLIPS> (assert (student John))
<Fact-5>
CLIPS> (agenda)
CLIPS> 

Removing both student facts reactivates the rule again.

CLIPS> (retract 1 5)
CLIPS> (agenda)
0      all-students-passed: f-0,
For a total of 1 activation.
CLIPS>
5.4.8 Logical Conditional Element
The logical conditional element provides a truth maintenance capability for pattern entities (facts or instances) created by rules which use the logical CE. A pattern entity created on the RHS (or as a result of actions performed from the RHS) can be made logically dependent upon the pattern entities which matched the patterns enclosed with the logical CE on the LHS of the rule. The pattern entities matching the LHS logical patterns provide logical support to the facts and instance created by the RHS of the rule. A pattern entity can be logically supported by more than one group of pattern entities from the same or different rules. If any one supporting pattern entities is removed from a group of supporting pattern entities (and there are no other supporting groups), then the pattern entity is removed.

If a pattern entity is created without logical support (e.g., from a deffacts, definstaces, as a top-level command, or from a rule without any logical patterns), then the pattern entity has unconditional support. Unconditionally supporting a pattern entity removes all logical support (without causing the removal of  the pattern entity). In addition, further logical support for an unconditionally supported pattern entity is ignored. Removing a rule that generated logical support for a pattern entity, removes the logical support generated by that rule (but does not cause the removal of the pattern entity if no logical support remains). 
Syntax
<logical-CE> ::= (logical <conditional-element>+)

The logical CE groups patterns together exactly as the explicit and CE does. It may be used in conjunction with the and, or, and not CEs. However, only the first N patterns of a rule can have the logical CE applied to them. For example, the following rule is legal

(defrule ok
   (logical (a))
   (logical (b))
   (c)
   =>
   (assert (d)))

whereas the following rules are illegal

(defrule not-ok-1
   (logical (a))
   (b)
   (logical (c))
   =>
   (assert (d)))

(defrule not-ok-2
   (a)
   (logical (b))
   (logical (c))
   =>
   (assert (d)))

(defrule not-ok-3
   (or (a)
       (logical (b)))
   (logical (c))
   =>
   (assert (d)))
Example
Given the following rules,

CLIPS> (clear)
CLIPS> 
(defrule rule1 
   (logical (a))
   (logical (b))
   (c)
   =>
   (assert (g) (h)))
CLIPS> 
(defrule rule2 
   (logical (d))
   (logical (e))
   (f)
   =>
   (assert (g) (h)))
CLIPS> 

the following commands illustrate how logical dependencies work.

CLIPS> (watch facts)
CLIPS> (watch activations)
CLIPS. (watch rules)
CLIPS> (assert (a) (b) (c) (d) (e) (f))
==> f-0     (a)
==> f-1     (b)
==> f-2     (c)
==> Activation 0      rule1: f-0,f-1,f-2
==> f-3     (d)
==> f-4     (e)
==> f-5     (f)
==> Activation 0      rule2: f-3,f-3,f-5
<Fact-5>
CLIPS> (run)
FIRE    1 rule2: f-3,f-4,f-5 ; 1st rule adds logical support
==> f-6     (g)
==> f-7     (h)
FIRE    2 rule1: f-0,f-1,f-2 ; 2nd rule adds further support
CLIPS> (retract 1)
<== f-0     (a)           ; Removes 1st support for (g) and (h)
CLIPS> (assert (h))       ; (h) is unconditionally supported
FALSE
CLIPS> (retract 3)
<== f-3     (d)              ; Removes 2nd support for (g)
<== f-6     (g)              ; (g) has no more support
CLIPS> (unwatch all)
CLIPS> 

As mentioned in section 5.4.1.7, the logical CE can be used with an object pattern to create pattern entities which are logically dependent on changes to specific slots in the matching instance(s) rather than all slots. This cannot be accomplished with template facts because a change to a template fact slot actually involves the retraction of the old template fact and the assertion of a new one, whereas a change to an instance slot is done in place. The example below illustrates this behavior:

CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (pattern-match reactive)
  (slot foo (create-accessor write))
  (slot bar (create-accessor write)))
CLIPS> 
(deftemplate A
  (slot foo)
  (slot bar))
CLIPS> 
(defrule match-A-s
  (logical (object (is-a A) (foo ?))
           (A (foo ?)))
=>
  (assert (new-fact)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (assert (A))
<Fact-0>
CLIPS> (watch facts)
CLIPS> (run)
==> f-1     (new-fact)
CLIPS> (send [a] put-bar 100)
100 
CLIPS> (agenda)
CLIPS> (modify 0 (bar 100))
<== f-0     (A (foo nil) (bar nil))
<== f-1     (new-fact)
==> f-2     (A (foo nil) (bar 100))
<Fact-2>
CLIPS> (agenda)
0      match-A-s: [a],f-2
For a total of 1 activation.
CLIPS> (run)
==> f-3     (new-fact)
CLIPS> (send [a] put-foo 100)
<== f-3     (new-fact)
100
CLIPS> (agenda)
0      match-A-s: [a],f-2
For a total of 1 activation.
CLIPS> (unwatch facts)
CLIPS> 
5.4.9 Automatic Addition and Reordering of LHS CEs
Under certain circumstances, CLIPS adds additional pattern CEs to rules (usually for the benefit of the pattern-matching algorithm used by CLIPS). There are two default patterns used by CLIPS: the initial-fact fact pattern and the initial-object instance pattern. The initial-fact pattern is

(initial-fact)

and the initial-object pattern is

(object (is-a INITIAL-OBJECT) (name [initial-object]))
5.4.9.1 Rules Without Any LHS Pattern CEs
The initial-fact pattern is added to any rule that has no patterns on its LHS (unless facts have been disabled by configuring CLIPS in which case the initial-object pattern is added to the LHS of the rule). For example, the following rule

(defrule example-1
   =>)

would be changed as follows.

(defrule example-1
   (initial-fact)
   =>)
5.4.9.2 Test and Not CEs as the First CE of an And CE
Test CEs and not CEs that are the first CE within an and CE have an initial-fact or an initial-object pattern added immediately before them. An initial-fact pattern is added if the first pattern CE preceding the CE in question is a fact pattern. An initial-object pattern is added if the first pattern CE preceding the CE in question is an object pattern. If there are no preceding pattern CEs, the type of pattern is determined by the succeeding pattern CEs using the same methodology. If there are no pattern CEs in the rule at all, then an initial-fact pattern is placed before the CE in question (unless facts have been disabled by configuring CLIPS in which case the initial-object pattern is added before the CE). For example, the following rules

(defrule example-2
   (test (> 80 (startup-value)))
   =>)

(defrule example-3
   (test (> 80 (startup-value)))
   (object (is-a MACHINE))
   =>)

(defrule example-4
   (machine ?x)
   (not (and (not (part ?x ?y))
             (inventoried ?x)))
   =>)

would be changed as follows.

(defrule example-2
   (initial-fact)
   (test (> 80 (startup-value)))
   =>)

(defrule example-3
   (object (is-a INITIAL-OBJECT) (name [initial-object]))
   (test (> 80 (startup-value)))
   (object (is-a MACHINE))
   =>)

(defrule example-4
   (machine ?x)
   (not (and (initial-fact)
             (not (part ?x ?y))
             (inventoried ?x)))
   =>)
5.4.9.3 Test CEs Following Not CEs
Test CEs that immediately follow a not CE are automatically moved by CLIPS behind the first pattern CE that precedes the not CE. For example, the following rule

(defrule example
   (a ?x)
   (not (b ?x))
   (test (> ?x 5))
   =>)

would be changed as follows.

(defrule example
   (a ?x)
   (test (> ?x 5))
   (not (b ?x))
   =>)
5.4.9.4 Or CEs Following Not CEs
If an or CE immediately follows a not CE, then the not/or CE combination is replaced with an and/not CE combination where each of the CEs contained in the original or CE is enclosed within a not CE and then all of the not CEs are enclosed within a single and CE. For example, the following rule

(defrule example
   (a ?x)
   (not (or (b ?x) 
            (c ?x)))
   =>)

would be changed as follows.

(defrule example
   (a ?x)
   (and (not (b ?x)) 
        (not (c ?x)))
   =>)
5.4.9.5 Notes About Pattern Addition and Reordering
There are several points which should be noted about the addition and reordering of pattern CEs: 1) The entire LHS of a rule is considered to be within an implicit and CE; 2) The conversion of the forall and exists CEs to equivalent not and and CEs is performed before patterns are added to the LHS of a rule; 3) In general, it is not very useful to have a test CE as the first CE within an and CE; and 4) The output of commands such as the matches command display information for the CEs that are actually added to the LHS of a rule and, because of reordering and implicit additions, may not reflect the rule exactly as defined by the user.
5.4.10 Declaring Rule Properties
This feature allows the properties or characteristics of a rule to be defined. The characteristics are declared on the LHS of a rule using the declare keyword. A rule may only have one declare statement and it must appear before the first conditional element on the LHS (as shown in section 5.1). 
Syntax
<declaration> ::= (declare <rule-property>+)

<rule-property> ::= (salience <integer-expression>) |
                    (auto-focus <boolean-symbol>)

<boolean-symbol> ::= TRUE | FALSE
5.4.10.1 The Salience Rule Property
 The salience rule property allows the user to assign a priority to a rule. When multiple rules are in the agenda, the rule with the highest priority will fire first. The declared salience value should be an expression that evaluates to an an integer in the range -10000 to +10000. Salience expressions may freely reference global variables and other functions (however, you should avoid using functions with side-effects). If unspecified, the salience value for a rule defaults to zero.
Example
(defrule test-1
   (declare (salience 99)) 	
   (fire test-1)
   =>
   (printout t "Rule test-1 firing." crlf))

(defrule test-2
   (declare (salience (+ ?*constraint-salience* 10))) 
   (fire test-2)
   =>
   (printout t "Rule test-2 firing." crlf))

Salience values can be evaluated at one of three times: when a rule is defined, when a rule is activated, and every cycle of execution (the latter two situations are referred to as dynamic salience). By default, salience values are only evaluated when a rule is defined. The setsalienceevaluation command can be used to change this behavior. Note that each salience evaluation method encompasses the previous method (i.e. if saliences are evaluated every cycle, then they are also evaluated when rules are activated or defined).
5.4.10.2 The Auto-Focus Rule Property
 The autofocus rule property allows an automatic focus command to be executed whenever a rule becomes activated. If the auto-focus property for a rule is TRUE, then a focus command on the module in which the rule is defined is automatically executed whenever the rule is activated. If the auto-focus property for a rule is FALSE, then no action is taken when the rule is activated. If unspecified, the auto-focus value for a rule defaults to FALSE.
Example
(defrule VIOLATIONS::bad-age
   (declare (auto-focus TRUE)) 	
   (person (name ?name) (age ?x&:(< ?x 0)))
   =>
   (printout t ?name " has a bad age value." crlf))

Section 6 - Defglobal Construct
With the defglobal construct, global variables can be defined, set, and accessed within the CLIPS environment. Global variables can be accessed as part of the pattern-matching process, but changing them does not invoke the patternmatching process. The bind function is used to set the value of global variables. Global variables are reset to their original value when the reset command is performed or when bind is called for the global with no values. This behavior can be changed using the setresetglobals function. Global variables can be removed by using the clear command or the undefglobal command. If the globals item is being watched (see section 13.2), then an informational message will be displayed each time the value of a global variable is changed.
Syntax
(defglobal [<defmodule-name>] <global-assignment>*)

<global-assignment> ::= <global-variable> = <expression>

<global-variable>   ::= ?*<symbol>*

There may be multiple defglobal constructs and any number of global variables may be defined in each defglobal statement. The optional <defmodule-name> indicates the module in which the defglobals will be defined. If none is specified, the globals will be placed in the current module. If a variable was defined in a previous defglobal construct, its value will be replaced by the value found in the new defglobal construct. If an error is encountered when defining a defglobal construct, any global variable definitions that occurred before the error was encountered will still remain in effect.

Commands that operate on defglobals such as ppdefglobal and undefglobal expect the symbolic name of the global without the astericks (e.g. use the symbol max when you want to refer to the global variable ?*max*).

Global variables may be used anyplace that a local variable could be used (with two exceptions). Global variables may not be used as a parameter variable for a deffunction, defmethod, or message-handler. Global variables may not be used in the same way that a local variable is used on the LHS of a rule to bind a value. Therefore, the following rule is illegal

(defrule example
   (fact ?*x*)
   =>)

The following rule, however, is legal.

(defrule example
   (fact ?y&:(> ?y ?*x*))
   =>)

Note that this rule will not necessarily be updated when the value of ?*x* is changed. For example, if ?*x* is 4 and the fact (fact 3) is added, then the rule is not satisfied. If the value of ?*x* is now changed to 2, the rule will not be activated.
Example
(defglobal
   ?*x* = 3
   ?*y* = ?*x*
   ?*z* = (+ ?*x* ?*y*)
   ?*q* = (create$ a b c))


Section 7 - Deffunction Construct
With the deffunction construct, new functions may be defined directly in CLIPS. Deffunctions are equivalent in use to other functions; see section 2.3.2 for more detail on calling functions in CLIPS. The only differences between user-defined external functions and deffunctions are that deffunctions are written in CLIPS and executed by CLIPS interpretively and user-defined external functions are written in an external language, such as C, and executed by CLIPS directly. Also, deffunctions allow the addition of new functions without having to recompile and relink CLIPS.

A deffunction is comprised of five elements: 1) a name, 2) an optional comment, 3) a list of zero or more required parameters, 4) an optional wildcard parameter to handle a variable number of arguments and 5) a sequence of actions, or expressions, which will be executed in order when the deffunction is called.
Syntax
(deffunction <name> [<comment>]
	(<regular-parameter>* [<wildcard-parameter>])
	<action>*)

<regular-parameter>	::= <single-field-variable>
<wildcard-parameter>	::= <multifield-variable>

A deffunction must have a unique name different from all other system functions and generic functions. In particular, a deffunction cannot be overloaded like a system function (see section 8 for more detail). A deffunction must be declared prior to being called from another deffunction, generic function method, object message-handler, rule, or the top level. The only exception is a self recursive deffunction.

A deffunction may accept exactly or at least a specified number of arguments, depending on whether a wildcard parameter is used or not. The regular parameters specify the minimum number of arguments that must be passed to the deffunction. Each of these parameters may be referenced like a normal single-field variable within the actions of the deffunction. If a wildcard parameter is present, the deffunction may be passed any number of arguments greater than or equal to the minimum. If no wildcard parameter is present, then the deffunction must be passed exactly the number of arguments specified by the regular parameters. All arguments to a deffunction that do not correspond to a regular parameter are grouped into a multifield value that can be referenced by the wildcard parameter. The standard CLIPS multifield functions, such as length and nth, can be applied to the wildcard parameter.
Example
CLIPS> (clear)
CLIPS> 
(deffunction print-args (?a ?b $?c)
	(printout t ?a " " ?b " and " (length ?c) " extras: " ?c
              crlf))
CLIPS> (print-args 1 2)
1 2 and 0 extras: ()
CLIPS> (print-args a b c d)
a b and 2 extras: (c d)
CLIPS> 

When a deffunction is called, its actions are executed in order. The return value of a deffunction is the evaluation of the last action. If a deffunction has no actions, its return value is the symbol FALSE. If an error occurs while the deffunction is executing, any actions not yet executed will be aborted, and the deffunction will return the symbol FALSE.

Deffunctions may be self and mutually recursive. Self recursion is accomplished simply by calling the deffunction from within its own actions. 
Example
(deffunction factorial (?a)
	(if (or (not (integerp ?a)) (< ?a 0)) then
		(printout t "Factorial Error!" crlf)
	 else
		(if (= ?a 0) then
			1
		 else
			(* ?a (factorial (- ?a 1))))))

Mutual recursion between two deffunctions requires a forward declaration of one of the deffunctions. A forward declaration is simply a declaration of the deffunction without any actions. In the following example, the deffunction foo is forward declared so that it may be called by the deffunction bar. Then the deffunction foo is redefined with actions that call the deffunction bar.
Example
(deffunction foo ())
(deffunction bar ()
	(foo))
(deffunction foo ()
	(bar))

Care should be taken with recursive deffunctions; too many levels of recursion can lead to an overflow of stack memory (especially on PC-type machines).

Section 8 - Generic Functions
With the defgeneric and defmethod constructs, new generic functions may be written directly in CLIPS. Generic functions are similar to deffunctions because they can be used to define new procedural code directly in CLIPS, and they can be called like any other function (see sections 2.3.2 and 7). However, generic functions are much more powerful because they can do different things depending on the types (or classes) and number of their arguments. For example, a "+" operator could be defined which performs concatenation for strings but still performs arithmetic addition for numbers. Generic functions are comprised of multiple components called methods, where each method handles different cases of arguments for the generic function. A generic function which has more than one method is said to be overloaded.

Generic functions can have system functions and user-defined external functions as implicit  methods. For example, an overloading of the "+" operator to handle strings consists of two methods: 1) an implicit one which is the system function handling numerical addition, and 2) an explicit  (user-defined) one handling string concatenation. Deffunctions, however, may not be methods of generic functions because they are subsumed by generic functions anyway. Deffunctions are only provided so that basic new functions can be added directly in CLIPS without the concerns of overloading. For example, a generic function which has only one method that restricts only the number of arguments is equivalent to a deffunction.

In most cases, generic function methods are not called directly (the function callspecificmethod described in section 12.15.8 can be used to do so, however). CLIPS recognizes that a function call is generic and uses the generic function's arguments to find and execute the appropriate method. This process is termed the generic dispatch. 
8.1 NOTE ON THE USE OF THE TERM METHOD
Most OOP systems support procedural behavior of objects either through message-passing (e.g. Smalltalk) or by generic functions (e.g. CLOS). CLIPS supports both of these mechanisms, although generic functions are not strictly part of COOL. A generic function may examine the classes of its arguments but must still use messages within the bodies of its methods to manipulate any arguments which are instances of user-defined classes. Section 9 gives more details on COOL. The fact that CLIPS supports both mechanisms leads to a confusion in terminology. In OOP systems which support message-passing only, the term method is used to denote the different implementations of a message for different classes. In systems which support generic functions only, however, the term method is used to denote the different implementations of a generic function for different sets of argument restrictions. To avoid this confusion, the term messagehandler is used to take the place of method in the context of messages. Thus in CLIPS, message-handlers denote the different implementations of a message for different classes, and  methods denote the different implementations of a generic function for different sets of argument restrictions.
8.2 PERFORMANCE PENALTY OF GENERIC FUNCTIONS
A call to a generic function is computationally more expensive than a call to a system function, user-defined external function or deffunction. This is because CLIPS must first examine the function arguments to determine which method is applicable. A performance penalty of 15%-20% is not unexpected. Thus, generic functions should not be used for routines for which time is critical, such as routines which are called within a while loop, if at all possible. Also, generic functions should always have at least two methods. Deffunctions or user-defined external  functions should be used when overloading is not required. A system or user-defined external function which is not overloaded will, of course, execute as quickly as ever, since the generic dispatch is unnecessary.
8.3 ORDER DEPENDENCE OF GENERIC FUNCTION DEFINITIONS
If a construct which uses a system or user-defined external function is loaded before a generic function which uses that function as an implicit method, all calls to that function from that construct will bypass the generic dispatch. For example, if a generic function which overloads the "+" operator is defined after a rule which uses the "+" operator, that rule will always call the "+" system function directly. However, similar rules defined after the generic function will use the generic dispatch.
8.4 DEFINING A NEW GENERIC FUNCTION
A generic function is comprised of a header (similar to a forward declaration) and zero or more methods. A generic function header can either be explicitly declared by the user or implicitly declared by the definition of at least one method. A method is comprised of six elements: 1) a name (which identifies to which generic function the method belongs), 2) an optional index, 3) an optional comment , 4) a set of parameter restrictions, 5) an optional wildcard parameter restriction to handle a variable number of arguments and 6) a sequence of actions, or expressions, which will be executed in order when the method is called. The parameter restrictions are used by the generic dispatch to determine a method's applicability to a set of arguments when the generic function is actually called. The defgeneric construct is used to specify the generic function header, and the defmethod construct is used for each of the generic function's methods.

Syntax
(defgeneric <name> [<comment>])

(defmethod <name> [<index>] [<comment>]
	(<parameter-restriction>* [<wildcard-parameter-restriction>])
	<action>*)

<parameter-restriction> 	::= 
				<single-field-variable> |
				(<single-field-variable> <type>* [<query>])

<wildcard-parameter-restriction>		::=
				<multifield-variable> |
				(<multifield-variable> <type>* [<query>])

<type>		::= <class-name>
<query>	::= <global-variable> |
			    <function-call>

A generic function must be declared, either by a header or a method, prior to being called from another generic function method, deffunction, object message-handler, rule, or the top level. The only exception is a self recursive generic function.
8.4.1 Generic Function Headers
A generic function is uniquely identified by name. In order to reference a generic function in other constructs before any of its methods are declared, an explicit header is necessary. Otherwise, the declaration of the first method implicitly creates a header. For example, two generic functions whose methods mutually call the other generic function (mutually recursive generic functions) would require explicit headers.
8.4.2 Method Indices
A method is uniquely identified by name and index, or by name and parameter restrictions. Each method for a generic function is assigned a unique integer index within the group of all methods for that generic function. Thus, if a new method is defined which has exactly the same name and parameter restrictions as another method, CLIPS will automatically replace the older method. However, any difference in parameter restrictions will cause the new method to be defined in addition to the older method. To replace an old method with one that has different parameter restrictions, the index of the old method can be explicitly specified in the new method definition. However, the parameter restrictions of the new method must not match that of another method with a different index. If an index is not specified, CLIPS assigns an index that has never been used by any method (past or current) of this generic function. The index assigned by CLIPS can be determined with the listdefmethods command (see section 13.10.4).
8.4.3 Method Parameter Restrictions
Each parameter for a method can be defined to have arbitrarily complex restrictions or none at all. A parameter restriction is applied to a generic function argument at run-time to determine if a particular method will accept the argument. A parameter can have two types of restrictions: type and query. A type restriction constrains the classes of arguments that will be accepted for a parameter. A query restriction is a user-defined boolean test which must be satisfied for an argument to be acceptable. The complexity of parameter restrictions directly affects the speed of the generic dispatch. 

A parameter that has no restrictions means that the method will accept any argument in that position. However, each method of a generic function must have parameter restrictions that make it distinguishable from all of the other methods so that the generic dispatch can tell which one to call at run-time. If there are no applicable methods for a particular generic function call, CLIPS will generate an error (see section 8.5.4 for more detail).

A type restriction allows the user to specify a list of types (or classes), one of which must match (or be a superclass of) the class of the generic function argument. If COOL is not installed in the current CLIPS configuration, the only types (or classes) available are: OBJECT, PRIMITIVE, LEXEME, SYMBOL, STRING, NUMBER, INTEGER, FLOAT, MULTIFIELD, FACT-ADDRESS and EXTERNAL-ADDRESS. Section 9 describes each of these system classes. With COOL, INSTANCE, INSTANCE-ADDRESS, INSTANCE-NAME, USER, INITIAL-OBJECT and any user-defined classes are also available. Generic functions which use only the first group of types in their methods will work the same whether COOL is installed or not. The classes in a type restriction must be defined already, since they are used to predetermine the precedence between a generic function's methods (see section 8.5.2 for more detail). Redundant classes are not allowed in restriction class lists. For example, the following method parameter's type restriction is redundant since INTEGER is a subclass of NUMBER.
Example
(defmethod foo ((?a INTEGER NUMBER)))

If the type restriction (if any) is satisfied for an argument, then a query restriction (if any) will be applied. The query restriction must either be a global variable or a function call. CLIPS evaluates this expression, and if it evaluates to anything but the symbol FALSE, the restriction is considered satisfied. Since a query restriction is not always satisfied, queries should not have any side-effects, for they will be evaluated for a method that may not end up being applicable to the generic function call. Since parameter restrictions are examined from left to right, queries which involve multiple parameters should be included with the rightmost parameter. This insures that all parameter type restrictions have already been satisfied. For example, the following method delays evaluation of the query restriction until the classes of both arguments have been verified.
Example
(defmethod foo ((?a INTEGER) (?b INTEGER (> ?a ?b))))

If the argument passes all these tests, it is deemed acceptable to a method. If all  generic function arguments are accepted by a method's restrictions, the method itself is deemed applicable to the set of arguments. When more than one method is applicable to a set of arguments, the generic dispatch must determine an ordering among them and execute the first one in that ordering. Method precedence is used for this purpose and will be discussed in section 8.5.2.
Example
In the following example, the first call to the generic function "+" executes the system operator "+", an implicit method for numerical addition. The second call executes the explicit method for string concatenation, since there are two arguments and they are both strings. The third call generates an error because the explicit method for string concatenation only accepts two arguments and the implicit method for numerical addition does not accept strings at all.

CLIPS> (clear)
CLIPS> 
(defmethod + ((?a STRING) (?b STRING))
	(str-cat ?a ?b))
CLIPS> (+ 1 2)
3
CLIPS> (+ "foo" "bar")
"foobar"
CLIPS> (+ "foo" "bar" "woz")
[GENRCEXE1] No applicable methods for +.
FALSE
8.4.4 Method Wildcard Parameter
A method may accept exactly or at least a specified number of arguments, depending on whether a wildcard parameter is used or not. The regular parameters specify the minimum number of arguments that must be passed to the method. Each of these parameters may be referenced like a normal single-field variable within the actions of the method. If a wildcard parameter is present, the method may be passed any number of arguments greater than or equal to the minimum. If no wildcard parameter is present, then the method must be passed exactly the number of arguments specified by the regular parameters. Method arguments which do not correspond to a regular parameter can be grouped into a multifield value that can be referenced by the wildcard parameter within the body of the method. The standard CLIPS multifield functions, such as length$ and expand$, can be applied to the wildcard parameter.

If multifield values are passed as extra arguments, they will all be merged into one multifield value referenced by the wildcard parameter. This is because CLIPS does not support nested multifield values.

Type and query restrictions can be applied to arguments grouped in the wildcard parameter similarly to regular parameters. Such restrictions apply to each individual field of the resulting multifield value (not the entire multifield). However, expressions involving the wildcard parameter variable may be used in the query. In addition, a special variable may be used in query restrictions on the wildcard parameter to refer to the individual arguments grouped into the wildcard: ?current-argument. This variable is only in scope within the query and has no meaning in the body of the method. For example, to create a version of the '+' operator which acts differently for sums of all even integers:
Example
CLIPS>
(defmethod +
  (($?any INTEGER (evenp ?current-argument)))
  (div (call-next-method) 2))
CLIPS> (+ 1 2)
3
CLIPS> (+ 4 6 4)
7
CLIPS> 

It is important to emphasize that query and type restrictions on the wildcard parameter are applied to every argument grouped in the wildcard. Thus in the following example, the > and length$ functions are actually called three times, since there are three arguments:
Example
CLIPS> (defmethod foo (($?any (> (length$ ?any) 2))) yes)
CLIPS> (foo 1 red 3)
yes
CLIPS> 

In addition, a query restriction will never be examined if there are no arguments in the wildcard parameter range. For example, the the previous methodwould be applicable to a call to the generic function with no arguments because the query restriction is never evaluated:
Example
CLIPS> (foo)
yes
CLIPS> 

Typically query restrictions applied to the entire wildcard parameter are testing the cardinality (the number of arguments passed to the method). In cases like this where the type is irrelevant to the test, the query restriction can be attached to a regular parameter instead to improve performance (see section 8.5.1). Thus the previous method could be improved as follows:
Example
CLIPS> (clear)
CLIPS> (defmethod foo ((?arg (> (length$ ?any) 1)) $?any) yes)
CLIPS> (foo)
[GENRCEXE1] No applicable methods for foo.
FALSE
CLIPS> 

This approach should not be used if the types of the arguments grouped by the wildcard must be verified prior to safely evaluating the query restriction.
8.5 GENERIC DISPATCH
When a generic function is called, CLIPS selects the method for that generic function with highest precedence for which parameter restrictions are satisfied by the arguments. This method is executed, and its value is returned as the value of the generic function. This entire process is referred to as the generic dispatch. Below is a flow diagram summary:




The solid arrows indicate automatic control transfer by the generic dispatch.

The dashed arrows indicate control transfer that can only be accomplished by the use or lack of the use of callnextmethod or .overridenextmethod
8.5.1 Applicability of Methods Summary
An explicit (user-defined) method is applicable to a generic function call if the following three conditions are met: 1) its name matches that of the generic function,  2) it accepts at least as many arguments as were passed to the generic function, and 3) every argument of the generic function satisfies the corresponding parameter restriction (if any) of the method.

Method restrictions are examined from left to right. As soon as one restriction is not satisfied, the method is abandoned, and the rest of the restrictions (if any) are not examined.

When a standard CLIPS system function is overloaded, CLIPS forms an implicit method definition corresponding to that system function. This implicit method is derived from the argument restriction string for the external DefineFunction2 call defining that function to CLIPS (see the Advanced Programming Guide). This string can be accessed with the function getfunctionrestrictions. The specification of this implicit method can be examined with the listdefmethods or getmethodrestrictions functions. The method that CLIPS will form for a system function can be derived by the user from the BNF given in this document. For example,

Syntax: (+ <number> <number>+)

would yield the following method for the '+' function:

(defmethod + ((?first NUMBER) (?second NUMBER) ($?rest NUMBER))
...)

The method definition is used to determine the applicability and precedence of the system function to the generic function call.

The following system functions cannot be overloaded, and CLIPS will generate an error if an attempt is made to do so.

activeduplicateinstance
delayeddoforallinstances
messagemodifyinstance
activeinitializeinstance
doforallinstances
modify
activemakeinstance
doforinstance
modifyinstance
activemessageduplicateinstance
duplicate
nexthandlerp
activemessagemodifyinstance
duplicateinstance
nextmethodp
activemodifyinstance
expand$
objectpatternmatchdelay
anyinstancep
findallinstances
overridenexthandler
assert
findinstance
overridenextmethod
bind
if
progn
break
makeinstance
progn$
callnexthandler
initializeinstance
return
callnextmethod
loopforcount
switch
callspecificmethod
messageduplicateinstance
while
8.5.2 Method Precedence
When two or more methods are applicable to a particular generic function call, CLIPS must pick the one with highest precedence for execution. Method precedence is determined when a method is defined; the listdefmethods function can be used to examine the precedence of methods for a generic function (see section 13.10).

The precedence between two methods is determined by comparing their parameter restrictions. In general, the method with the most specific parameter restrictions has the highest precedence. For example, a method which demands an integer for a particular argument will have higher precedence than a method which only demands a number. The exact rules of precedence between two methods are given in order below; the result of the first rule which establishes precedence is taken.

1) ) The parameter restrictions of both methods are positionally compared from left to right. In other words, the first parameter restriction in the first method is matched against the first parameter restriction in the second method, and so on. The comparisons between these pairs of parameter restrictions from the two methods determine the overall precedence between the two methods. The result of the first pair of parameter restrictions which specifies precedence is taken. The following rules are applied in order to a parameter pair; the result of the first rule which establishes precedence is taken.

1a) A regular parameter has precedence over a wildcard parameter.
1b) The most specific type restriction on a particular parameter has priority. A class is more specific than any of its superclasses.
1c) A parameter with a query restriction has priority over one that does not.

2) The method with the greater number of regular parameters has precedence.

3) A method without a wildcard parameter has precedence over one that does

4) A method defined before another one has priority.

If there are multiple classes on a single restriction, determining specificity is slightly more complicated. Since all precedence determination is done when the new method is defined, and the actual class of the generic function argument will not be known until run-time, arbitrary (but deterministic) rules are needed for determining the precedence between two class lists. The two class lists are examined by pairs from left to right, e.g. the pair of first classes from both lists, the pair of second classes from both lists and so on. The first pair containing a class and its superclass specify precedence. The class list containing the subclass has priority. If no class pairs specify precedence, then the shorter class list has priority. Otherwise, the class lists do not specify precedence between the parameter restrictions.
Example 1
; The system operator '+' is an implicit method 	; #1
; Its definition provided by the system is:
; (defmethod + ((?a NUMBER) (?b NUMBER) ($?rest NUMBER)))

(defmethod + ((?a NUMBER) (?b INTEGER)))			; #2
(defmethod + ((?a INTEGER) (?b INTEGER)))			; #3
(defmethod + ((?a INTEGER) (?b NUMBER)))			; #4
(defmethod + ((?a NUMBER) (?b NUMBER)
	($?rest PRIMITIVE)))			; #5
(defmethod + ((?a NUMBER) 
	(?b INTEGER (> ?b 2))))			; #6
(defmethod + ((?a INTEGER (> ?a 2)) 
	(?b INTEGER (> ?b 3))))			; #7
(defmethod + ((?a INTEGER (> ?a 2)) 
	(?b NUMBER)))				; #8

The precedence would be: #7,#8,#3,#4,#6,#2,#1,#5. The methods can be immediately partitioned into three groups of decreasing precedence according to their restrictions on the first parameter: A) methods which have a query restriction and a type restriction of INTEGER (#7,#8), B) methods which have a type restriction of INTEGER (#3,#4), and C) methods which have a type restriction of NUMBER (#1,#2,#5,#6). Group A has precedence over group B because parameters with query restrictions have priority over those that do not. Group B has precedence over group C because INTEGER is a subclass of NUMBER. Thus, the ordering so far is: (#7,#8),(#3,#4),(#1,#2,#5,#6). Ordering between the methods in a particular set of parentheses is not yet established.

The next step in determining precedence between these methods considers their restrictions on the second parameter. #7 has priority over #8 because INTEGER is a subclass of NUMBER. #3 has priority over #4 because INTEGER is a subclass of NUMBER. #6 and #2 have priority over #1 and #5 because INTEGER is a subclass of NUMBER. #6 has priority over #2 because it has a query restriction and #2 does not. Thus the ordering is now: #7,#8,#3,#4,#6,#2,(#1,#5).

The restriction on the wildcard argument yields that #1 (the system function implicit method) has priority over #5 since NUMBER is a sublclass of PRIMITIVE. This gives the final ordering: #7,#8,#3,#4,#6,#2,#1,#5.
Example 2
(defmethod foo ((?a NUMBER STRING)))	; #1
(defmethod foo ((?a INTEGER LEXEME)))	; #2

The precedence would be #2,#1. Although STRING is a subclass of LEXEME, the ordering is still #2,#1 because INTEGER is a subclass of NUMBER, and NUMBER/INTEGER is the leftmost pair in the class lists.
Example 3
(defmethod foo ((?a MULTIFIELD STRING)))	; #1
(defmethod foo ((?a LEXEME)))	; #2

The precedence would be #2,#1 because the classes of the first pair in the type restriction (MULTIFIELD/LEXEME) are unrelated and #2 has fewer classes in its class list.
Example 4
(defmethod foo ((?a INTEGER LEXEME)))	; #1
(defmethod foo ((?a STRING NUMBER)))	; #2

Both pairs of classes (INTEGER/STRING and LEXEME/NUMBER) are unrelated, and the class lists are of equal length. Thus, the precedence is taken from the order of definition: #1,#2.
8.5.3 Shadowed Methods
If one method must be called by another method in order to be executed, the first function or method is a said to be shadowed by the second method. Normally, only one method or system function will be applicable to a particular generic function call. If there is more than one applicable method, the generic dispatch will only execute the one with highest precedence. Letting the generic dispatch automatically handle the methods in this manner is called the declarative technique, for the declarations of the method restrictions dictate which method gets executed in specific circumstances. However, the functions callnextmethod and overridenextmethod (see section 12.15.6 and 12.15.7) may also be used which allow a method to execute the method that it is shadowing. This is called the imperative technique, since the method execution itself plays a role in the generic dispatch. This is not recommended unless it is absolutely necessary. In most circumstances, only one piece of code should need to be executed for a particular set of arguments. Another imperative technique is to use the function callspecificmethod to override method precedence (see section 12.15.8)
8.5.4 Method Execution Errors
If an error occurs while any method for a generic function call is executing, any actions in the current method not yet executed will be aborted, any methods not yet called will be aborted, and the generic function will return the symbol FALSE. The lack of any applicable methods for a set of generic function arguments is considered a method execution error.
8.5.5 Generic Function Return Value
The return value of a generic function is the return value of the applicable method with the highest precedence. Each applicable method that is executed can choose to ignore or capture the return value of any method that it is shadowing.

The return value of a particular method is the last action evaluated by that method.

Section 9 - CLIPS Object Oriented Language (COOL)
This section provides the comprehensive details of the CLIPS Object-Oriented Language (COOL). Sections 2.3.1, 2.4.2 and 2.5.2.3 explain object references and structure. Section 2.6 gives a high level overview of COOL. This section assumes a complete understanding of the material given in the listed sections.
9.1 BACKGROUND
COOL is a hybrid of features from many different OOP systems as well as new ideas. For example, object encapsulation concepts are similar to those in Smalltalk, and the Common Lisp Object System (CLOS) provides the basis for multiple inheritance rules. A mixture of ideas from Smalltalk, CLOS and other systems form the foundation of messages. Section 8.1 explains an important contrast between the terms method and messagehandler in CLIPS.
9.2 PREDEFINED SYSTEM CLASSES
COOL provides seventeen system classes: OBJECT, USER, INITIALOBJECT, PRIMITIVE, NUMBER, INTEGER, FLOAT, INSTANCE, INSTANCENAME, INSTANCEADDRESS, ADDRESS, FACTADDRESS, EXTERNALADDRESS, MULTIFIELD, LEXEME, SYMBOL and STRING. The user may not delete or modify any of these classes. The diagram illustrates the inheritance relationships between these classes.


All of these system classes except INITIAL-OBJECT are abstract classes, which means that their only use is for inheritance (direct instances of this class are illegal). None of these classes have slots, and, except for the class USER, none of them have message-handlers. However, the user may explicitly attach message-handlers all of the system classes except ofr INSTANCE, INSTANCE-ADDRESS and INSTANCE-NAME. The OBJECT class is a superclass of all other classes, including user-defined classes. All user-defined classes should (but are not required to) inherit directly or indirectly from the class USER, since this class has all of the standard system message-handlers, such as initialization and deletion, attached to it. Section 9.4 describes these system message-handlers.

The PRIMITIVE system class and all of its subclasses are provided mostly for use in generic function method restrictions, but message-handlers and new subclasses may be attached if desired. However, the three primitive system classes INSTANCE, INSTANCE-ADDRESS and INSTANCE-NAME are provided strictly for use in methods (particularly in forming implicit methods for overloaded system functions - see section 8.5.1) and as such cannot have subclasses or message-handlers attached to them.

The INITIAL-OBJECT class is provided for use by the default definstances initialobject in creating the default instance [initial-object] during the reset command. This system class is concrete and reactive to pattern-matching on the LHS of rules but is in other respects exactly like the system class USER. The instance [initial-object] is for use by the initial-object pattern (see section 5.4.9).
9.3 DEFCLASS CONSTRUCT
A defclass is a construct for specifying the properties (slots) and behavior (messagehandlers) of a class of objects. A defclass consists of five elements: 1) a name, 2) a list of superclasses from which the new class inherits slots and messagehandlers, 3) a specifier saying whether or not the creation of direct instances of the new class is allowed, 4) a specifier saying whether or not instances of this class can match object patterns on the LHS of rules and 5) a list of slots specific to the new class. All user-defined classes must inherit from at least one class, and to this end COOL provides predefined system classes for use as a base in the derivation of new classes.

Any slots explicitly given in the defclass override those gotten from inheritance. COOL applies rules to the list of superclasses to generate a class precedence list (see section 9.3.1) for the new class. Facets (see section 9.3.3) further describe slots. Some examples of facets include: default value, cardinality, and types of access allowed.
Syntax
Defaults are outlined.

(defclass <name> [<comment>]
  (is-a <superclass-name>+)
  [<role>]
  [<pattern-match-role>]
  <slot>*
  <handler-documentation>*)

<role>  ::= (role concrete | abstract)

<pattern-match-role> 
        ::= (pattern-match reactive | non-reactive)

<slot>  ::= (slot <name> <facet>*) |
            (single-slot <name> <facet>*) |
            (multislot <name> <facet>*)

<facet> ::=  <default-facet> | <storage-facet> |
             <access-facet> | <propagation-facet> | 
             <source-facet> | <pattern-match-facet> |
             <visibility-facet> | <create-accessor-facet>
             <override-message-facet> | <constraint-attributes>
 
<default-facet> ::= 
           (default ?DERIVE | ?NONE | <expression>*) |
           (default-dynamic <expression>*)

<storage-facet> ::= (storage local | shared)

<access-facet> 
       ::= (access read-write | read-only | initialize-only)

<propagation-facet> ::= (propagation inherit | no-inherit)

<source-facet> ::= (source exclusive | composite)

<pattern-match-facet> 
       ::= (pattern-match reactive | non-reactive)

<visibility-facet> ::= (visibility private | public)

<create-accessor-facet> 
     ::= (create-accessor ?NONE | read | write | read-write)

<override-message-facet> 
     ::= (override-message ?DEFAULT | <message-name>)
                                           
<handler-documentation> 
       ::= (message-handler <name> [<handler-type>])

<handler-type> ::= primary | around | before | after

Redefining an existing class deletes the current subclasses and all associated message-handlers. An error will occur if instances of the class or any of its subclasses exist.
9.3.1 Multiple Inheritance
If one class inherits from another class, the first class is a subclass of the second class, and the second class is a superclass of the first class. Every user-defined class must have at least one direct superclass, i.e. at least one class must appear in the isa portion of the defclass. Multiple inheritance occurs when a class has more than one direct superclass. COOL examines the direct superclass list for a new class to establish a linear ordering called the class precedence list. The new class inherits slots and message-handlers from each of the classes in the class precedence list. The word precedence implies that slots and messagehandlers of a class in the list override conflicting definitions of another class found later in the list. A class that comes before another class in the list is said to be more specific. All class precedence lists will terminate in the system class OBJECT, and most (if not all) class precedence lists for user-defined classes will terminate in the system classes USER and OBJECT. The class precedence list can be listed using the describeclass function (see section 13.11.1.4).
9.3.1.1 Multiple Inheritance Rules
COOL uses the inheritance hierarchy of the direct superclasses to determine the class precedence list for a new class. COOL recursively applies the following two rules to the direct superclasses:

1) A class has higher precedence than any of its superclasses.
2) A class specifies the precedence between its direct superclasses.

If more than one class precedence list would satisfy these rules, COOL chooses the one most similar to a strict preorder depth-first traversal. This heuristic attempts to preserve "family trees" to the greatest extent possible. For example, if a child inherited genetic traits from a mother and father, and the mother and father each inherited traits from their parents, the child's class precedence list would be: child mother maternal-grandmother maternal-grandfather father paternal-grandmother paternal-grandfather. There are other orderings which would satisfy the rules (such as child mother father paternal-grandfather maternal-grandmother paternal-grandmother maternal-grandfather), but COOL chooses the one which keeps the family trees together as much as possible.
Example 1
(defclass A (is-a USER))

Class A directly inherits information from the class USER. The class precedence list for A is: A USER OBJECT.
Example 2
(defclass B (is-a USER))

Class B directly inherits information from the class USER. The class precedence list for B is: B USER OBJECT.
Example 3
(defclass C (is-a A B))

Class C directly inherits information from the classes A and B. The class precedence list for C is: C A B USER OBJECT.
Example 4
(defclass D (is-a B A))

Class D directly inherits information from the classes B and A. The class precedence list for D is: D B A USER OBJECT.
Example 5
(defclass E (is-a A C))

By rule #2, A must precede C. However, C is a subclass of A and cannot succeed A in a precedence list without violating rule #1. Thus, this is an error.
Example 6
(defclass E (is-a C A))

Specifying that E inherits from A is extraneous, since C inherits from A. However, this definition does not violate any rules and is acceptable. The class precedence list for E is: E C A B USER OBJECT.
Example 7
(defclass F (is-a C B))

Specifying that F inherits from B is extraneous, since C inherits from B. The class precedence list for F is: F C A B USER OBJECT. The superclass list says B must follow C in F's class precedence list but not that B must immediately follow C.
Example 8
(defclass G (is-a C D))

This is an error, for it violates rule #2. The class precedence of C says that A should precede B, but the class precedence list of D says the opposite.
Example 9
(defclass H (is-a A))
(defclass I (is-a B))
(defclass J (is-a H I A B))

The respective class precedence lists of H and I are: H A USER OBJECT and I B USER OBJECT. If J did not have A and B as direct superclasses, J could have one of three possible class precedence lists: J H A I B USER OBJECT, J H I A B USER OBJECT or J H I B A USER OBJECT. COOL would normally pick the first list since it preserves the family trees (H A and I B) to the greatest extent possible. However, since J inherits directly from A and B, rule #2 dictates that the class precedence list must be J H I A B USER OBJECT.
9.3.2 Class Specifiers
9.3.2.1 Abstract and Concrete Classes
An abstract class is intended for inheritance only, and no direct instances of this class can be created. A concrete class can have direct instances. Using the abstract role specifier in a defclass will cause COOL to generate an error if makeinstance is ever called for this class. If the abstract or concrete descriptor for a class is not specified, it is determined by inheritance.
9.3.2.2 Reactive and Non-Reactive Classes
Objects of a reactive class can match object patterns in a rule. Objects of a nonreactive class can not match object patterns in a rule and are not considered when the list of applicable classes are determined for an object pattern. An abstract class cannot be reactive. If the reactive or non-reactive descriptor for a class is not specified, it is determined by inheritance.
9.3.3 Slots
Slots are placeholders for values associated with instances of a user-defined class. Each instance has a copy of the set of slots specified by the immediate class as well as any obtained from inheritance. Only available memory limits the number of slots. The name of a slot may be any symbol with the exception of the keywords is-a and name which are reserved for use in object patterns.

To determine the set of slots for an instance, the class precedence list for the instance's class is examined in order from most specific to most general (left to right). A class is more specific than its superclasses. Slots specified in any of the classes in the class precedence list are given to the instance, with the exception of noinherit slots (see section 9.3.3.5). If a slot is inherited from more than one class, the definition given by the more specific class takes precedence, with the exception of composite slots (see section 9.3.3.6).
Example
(defclass A (is-a USER)
	(slot fooA)
	(slot barA))

(defclass B (is-a A)
	(slot fooB)
	(slot barB))

The class precedence list of A is: A USER OBJECT. Instances of A will have two slots: fooA and barA. The class precedence list of B is: B A USER OBJECT. Instances of B will have four slots: fooB, barB, fooA and barA.

Just as slots make up classes, facets make up slots. Facets describe various features of a slot that hold true for all objects which have the slot: default value, storage, access, inheritance propagation, source of other facets, pattern-matching reactivity, visibility to subclass message-handlers, the automatic creation of message-handlers to access the slot, the name of the message to send to set the slot and constraint information. Each object can still have its own value for a slot, with the exception of shared slots (see section 9.3.3.3).
9.3.3.1 Slot Field Type
A slot can hold either a single-field or multifield value. By default, a slot is single-field. The keyword multislot specifies that a slot can hold a multifield value comprised of zero or more fields, and the keywords slot or singleslot specify that the slot can hold one value. Multifield slot values are stored as multifield values and can be manipulated with the standard multifield functions, such as nth$ and length$, once they are retrieved via messages. COOL also provides functions for setting multifield slots, such as slotinsert$ (see section 12.16.4.12.2). Single-field slots are stored as a CLIPS primitive type, such as integer or string.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(multislot foo (create-accessor read)
				(default abc def ghi)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (nth$ 2 (send [a] get-foo))
def
CLIPS>
9.3.3.2 Default Value Facet
The default and defaultdynamic facets can be used to specify an initial value given to a slot when an instance of the class is created or initialized. By default, a slot will have a default value which is derived from the slot's constraint facets (see sections 9.3.3.11 and 11.5). Default values are directly assigned to slots without the use of messages, unlike slot overrides in a makeinstance call (see section 9.6.1).

The default facet is a static default: the specified expression is evaluated once when the class is defined, and the result is stored with the class. This result is assigned to the appropriate slot when a new instance is created. If the keyword ?DERIVE is used for the default value, then a default value is derived from the constraints for the slot (see section 11.5 for more details). By default, the default attribute for a slot is (default ?DERIVE). If the keyword ?NONE is used for the default value, then the slot is not assigned a default value. Using this keyword causes makeinstance to require a slot-override for that slot when an instance is created. Note that in CLIPS 6.0, a slot now has a default even if one is not explicitly specified (unlike CLIPS 5.1). This could cause different behavior for CLIPS 5.1 programs using the initializeinstance function. The ?NONE keyword can be used to recover the original behavior for classes.

The default-dynamic facet is a dynamic default: the specified expression is evaluated every time an instance is created, and the result is assigned to the appropriate slot.
Example
CLIPS> (clear)
CLIPS> (setgen 1)
1
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot foo (default-dynamic (gensym))
			(create-accessor read)))
CLIPS> (make-instance a1 of A)
[a1]
CLIPS> (make-instance a2 of A)
[a2]
CLIPS> (send [a1] get-foo)
gen1
CLIPS> (send [a2] get-foo)
gen2
CLIPS>
9.3.3.3 Storage Facet
The actual value of an instance's copy of a slot can either be stored with the instance or with the class. The local facet specifies that the value be stored with the instance, and this is the default. The shared facet specifies that the value be stored with the class. If the slot value is locally stored, then each instance can have a separate value for the slot. However, if the slot value is stored with the class, all instances will have the same value for the slot. Anytime the value is changed for a shared slot, it will be changed for all instances with that slot.

A shared slot will always pick up a dynamic default value from a defclass when an instance is created or initialized, but the shared slot will ignore a static default value unless it does not currently have a value. Any changes to a shared slot will cause pattern-matching for rules to be updated for all reactive instances containing that slot.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot foo (create-accessor write)
			(storage shared)
			(default 1))
	(slot bar (create-accessor write)
			(storage shared)
			(default-dynamic 2))
	(slot woz (create-accessor write)
			(storage local)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print)
[a] of A
(foo 1)
(bar 2)
(woz nil)
CLIPS> (send [a] put-foo 56)
56
CLIPS> (send [a] put-bar 104)
104
CLIPS> (make-instance b of A)
[b]
CLIPS> (send [b] print)
[b] of A
(foo 56)
(bar 2)
(woz nil)
CLIPS> (send [b] put-foo 34)
34
CLIPS> (send [b] put-woz 68)
68
CLIPS> (send [a] print)
[a] of A
(foo 34)
(bar 2)
(woz nil)
CLIPS> (send [b] print)
[b] of A
(foo 34)
(bar 2)
(woz 68)
CLIPS>
9.3.3.4 Access Facet
There are three types of access facets which can be specified for a slot: readwrite, readonly, and initializeonly. The read-write facet is the default and says that a slot can be both written and read. The read-only facet says the slot can only be read; the only way to set this slot is with default facets in the class definition. The initialize-only facet is like read-only except that the slot can also be set by slot overrides in a makeinstance call (see section 9.6.1) and init message-handlers (see section 9.4). These privileges apply to indirect access via messages as well as direct access within messagehandler bodies (see section 9.4). Note: a read-only slot that has a static default value will implicitly have the shared storage facet.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot foo (create-accessor write)
			(access read-write))
	(slot bar (access read-only)
			(default abc))
	(slot woz (create-accessor write)
			(access initialize-only)))
CLIPS>
(defmessage-handler A put-bar (?value)
	(dynamic-put (sym-cat bar) ?value))
CLIPS> (make-instance a of A (bar 34))
[MSGFUN3] bar slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message-handler put-bar primary in class A
FALSE
CLIPS> (make-instance a of A (foo 34) (woz 65))
[a]
CLIPS> (send [a] put-bar 1)
[MSGFUN3] bar slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message-handler put-bar primary in class A
FALSE
CLIPS> (send [a] put-woz 1)
[MSGFUN3] woz slot in [a] of A: write access denied.
[PRCCODE4] Execution halted during the actions of message-handler put-bar primary in class A
FALSE
CLIPS> (send [a] print)
[a] of A
(foo 34)
(bar abc)
(woz 65)
CLIPS>
9.3.3.5 Inheritance Propagation Facet
An inherit facet says that a slot in a class can be given to instances of other classes that inherit from the first class. This is the default. The noinherit facet says that only direct instances of this class will get the slot.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot foo (propagation inherit))
	(slot bar (propagation no-inherit)))
CLIPS> (defclass B (is-a A))
CLIPS> (make-instance a of A)
[a]
CLIPS> (make-instance b of B)
[b]
CLIPS> (send [a] print)
[a] of A
(foo nil)
(bar nil)
CLIPS> (send [b] print)
[b] of B
(foo nil)
CLIPS>
9.3.3.6 Source Facet
When obtaining slots from the class precedence list during instance creation, the default behavior is to take the facets from the most specific class which gives the slot and give default values to any unspecified facets. This is the behavior specified by the exclusive facet. The composite facet causes facets which are not explicitly specified by the most specific class to be taken from the next most specific class. Thus, in an overlay fashion, the facets of an instance's slot can be specified by more than one class. Note that even though facets may be taken from superclasses, the slot is still considered to reside in the new class for purposes of visibility (see section 9.3.3.8). One good example of a use of this feature is to pick up a slot definition and change only its default value for a new derived class.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (multislot foo (access read-only)
                 (default a b c)))
CLIPS>
(defclass B (is-a A)
	(slot foo (source composite) ; multiple and read-only 
                               ; from class A
			(default d e f)))
CLIPS> (describe-class B)
===============================================================
***************************************************************
Abstract: direct instances of this class cannot be created.

Direct Superclasses: A
Inheritance Precedence: B A USER OBJECT
Direct Subclasses:
---------------------------------------------------------------
SLOTS : FLD DEF PRP ACC STO MCH SRC VIS CRT OVRD-MSG SOURCE(S)
foo   : MLT STC INH  R  LCL RCT CMP PRV NIL NIL      A B

Constraint information for slots:

SLOTS : SYM STR INN INA EXA FTA INT FLT
foo   :  +   +   +   +   +   +   +   +  RNG:[-oo..+oo] CRD:[0..+oo]
---------------------------------------------------------------
Recognized message-handlers:
init primary in class USER
delete primary in class USER
print primary in class USER
direct-modify primary in class USER
message-modify primary in class USER
direct-duplicate primary in class USER
message-duplicate primary in class USER
***************************************************************
===============================================================
CLIPS>
9.3.3.7 Pattern-Match Reactivity Facet
Normally, any change to a slot of an instance will be considered as a change to the instance for purposes of pattern-matching. However, it is possible to indicate that changes to a slot of an instance should not cause pattern-matching. The reactive facet specifies that changes to a slot trigger pattern-matching, and this is the default. The nonreactive facet specifies that changes to a slot do not affect pattern-matching.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (pattern-match reactive)
  (slot foo (create-accessor write)
            (pattern-match non-reactive)))
CLIPS> 
(defclass B (is-a USER)
  (role concrete)
  (pattern-match reactive)
  (slot foo (create-accessor write)
            (pattern-match reactive)))
CLIPS> 
(defrule Create
  ?ins<-(object (is-a A | B))
=>
  (printout t "Create " (instance-name ?ins) crlf))
CLIPS> 
(defrule Foo-Access
  ?ins<-(object (is-a A | B) (foo ?))
=>
  (printout t "Foo-Access " (instance-name ?ins) crlf))
CLIPS> (make-instance a of A)
[a]
CLIPS> (make-instance b of B)
[b]
CLIPS> (run)
Create [b]
Foo-Access [b]
Create [a]
CLIPS> (send [a] put-foo 1)
1
CLIPS> (send [b] put-foo 1)
1
CLIPS> (run)
Foo-Access [b]
CLIPS> 
9.3.3.8 Visibility Facet
Normally, only message-handlers attached to the class in which a slot is defined may directly access the slot. However, it is possible to allow message-handlers attached to superclasses or subclasses which inherit the slot to directly access the slot as well. Declaring the visibility facet to be private specifies that only the message-handlers of the defining class may directly access the slot, and this is the default. Declaring the visibility facet to be public specifies that the message-handlers of superclasses and subclasses which inherit the slot may also directly access the slot.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot foo (visibility private)))
CLIPS> 
(defclass B (is-a A)
  (role concrete))
CLIPS> 
(defmessage-handler B get-foo ()
  ?self:foo)
[MSGFUN6] Private slot foo of class A cannot be accessed directly by handlers attached to class B

[PRCCODE3] Undefined variable self:foo referenced in message-handler.

ERROR:
(defmessage-handler MAIN::B get-foo
   ()
   ?self:foo
   )
CLIPS> 
9.3.3.9 Create-Accessor Facet
In CLIPS 5.1, implicit slot-accessor message-handlers were created for every slot. This not true in CLIPS 6.0. The user must define their own message-handlers for reading and writing the slot. This was done because in most cases the accessors were not required; explicit message-handlers attached to the class of the slot directly accessed the slot anyway. However, the createaccessor facet instructs CLIPS to automatically create explicit message-handlers for reading and/or writing a slot. By default, no accessors are created. While these message-handlers are real message-handlers and can be manipulated as such, they have no pretty-print form and cannot be directly modified by the user.

If the value read is specified for the facet, CLIPS creates the following message-handler:

(defmessage-handler <class> get-<slot-name> primary ()
	?self:<slot-name>)

If the value write is specified for the facet, CLIPS creates the following message-handler for single-field slots:

(defmessage-handler <class> put-<slot-name> primary (?value)
	(bind ?self:<slot-name> ?value)

or the following message-handler for multifield slots:

(defmessage-handler <class> put-<slot-name> primary ($?value)
	(bind ?self:<slot-name> ?value)

If the value readwrite is specified for the facet, both the get- and one of the put- message-handlers are created.

If accessors are required that do not use static slot references (see sections 9.4.2, 9.6.3 and 9.6.4), then user must define them explicitly with the defmessage-handler construct.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo (create-accessor write))
  (slot bar))
CLIPS> (make-instance a of A (foo 36))
[a]
CLIPS> (make-instance b of A (bar 45))
[MSGFUN1] No applicable primary message-handlers found for put-bar.
FALSE
CLIPS> 
9.3.3.10 Override-Message Facet
There are several COOL support functions which set slots via use of message-passing, e.g., makeinstance, initializeinstance, messagemodifyinstance and messageduplicateinstance. By default, all these functions attempt to set a slot with the message called put-<slot-name>. However, if the user has elected not to use standard slot-accessors and wishes these functions to be able to perform slot-overrides, then the overridemessage facet can be used to indicate what message to send instead.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot special (override-message special-put)))
CLIPS>  
(defmessage-handler A special-put primary (?value)
  (bind ?self:special ?value))
CLIPS> (watch messages)
CLIPS> (make-instance a of A (special 65))
MSG >> special-put ED:1 (<Instance-a> 65)
MSG << special-put ED:1 (<Instance-a> 65)
MSG >> init ED:1 (<Instance-a>)
MSG << init ED:1 (<Instance-a>)
[a]
CLIPS> (unwatch messages)
CLIPS> 
9.3.3.11 Constraint Facets
The syntax and functionality of single and multifield constraint facets (attributes) are described in detail in Section 11. Static and dynamic constraint checking for classes and their instances is supported. Static checking is performed when constructs or commands which specify slot information are being parsed. Object patterns used on the LHS of a rule are also checked to determine if constraint conflicts exist among variables used in more that one slot. Errors for inappropriate values are immediately signaled. Static checking is enabled by default. This behavior can be changed using the setstaticconstraintchecking function. Dynamic checking is also supported. If dynamic checking is enabled, then new instances have their values checked whenever they are set (e.g. initialization, slot-overrides, and put- access). This dynamic checking is disabled by default. This behavior can be changed using the setdynamicconstraintchecking function. If an violation occurs when dynamic checking is being performed, then execution will be halted.

Regardless of whether static or dynamic checking is enabled, multifield values can never be stored in single-field slots. Single-field values are converted to a multifield value of length one when storing in a multifield slot. In addition, the evaluation of a function which has no return value is always illegal as a slot value.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (multislot foo (create-accessor write)
                 (type SYMBOL)
                 (cardinality 2 3)))
CLIPS> (make-instance a of A (foo 45))
[a]
CLIPS> (set-dynamic-constraint-checking TRUE)
FALSE
CLIPS> (make-instance a of A (foo red 5.0))
[CSTRNCHK1] (red 5.0) for slot foo of instance [a] found in put-foo primary in class A does not match the allowed types.
[PRCCODE4] Execution halted during the actions of message-handler put-foo primary in class A
FALSE
CLIPS> (make-instance a of A (foo red))
[CSTRNCHK1] (red) for slot foo of instance [a] found in put-foo primary in class A does not satisfy the cardinality restrictions.
[PRCCODE4] Execution halted during the actions of message-handler put-foo primary in class A
FALSE
CLIPS> 
9.3.4 Message-handler Documentation
COOL allows the user to forward declare the message-handlers for a class within the defclass statement. These declarations are for documentation only and are ignored by CLIPS. The defmessagehandler construct must be used to actually add message-handlers to a class. Message-handlers can later be added which are not documented in the defclass.
Example
CLIPS> (clear)
CLIPS> 
(defclass rectangle (is-a USER)
	(slot side-a (default 1))
	(slot side-b (default 1))
	(message-handler find-area))
CLIPS> 
(defmessage-handler rectangle find-area ()
	(* ?self:side-a ?self:side-b))
CLIPS>
(defmessage-handler rectangle print-area ()
	(printout t (send ?self find-area) crlf))
CLIPS>
9.4 DEFMESSAGE-HANDLER CONSTRUCT
Objects are manipulated by sending them messages via the function send. The result of a message is a useful return-value or side-effect. A defmessagehandler is a construct for specifying the behavior of a class of objects in response to a particular message. The implementation of a message is made up of pieces of procedural code called messagehandlers (or handlers for short). Each class in the class precedence list of an object's class can have handlers for a message. In this way, the object's class and all its superclasses share the labor of handling the message. Each class's handlers handle the part of the message which is appropriate to that class. Within a class, the handlers for a particular message can be further subdivided into four types or categories: primary, before, after and around. The intended purposes of each type are summarized in the chart below:

Type
Role for the Class
primary
Performs the majority of the work for the message
before
Does auxiliary work for a message before the primary handler executes
after
Does auxiliary work for a message after the primary handler executes
around
Sets up an environment for the execution of the rest of the handlers

Before and after handlers are for side-effects only; their return values are always ignored. Before handlers execute before the primary ones, and after message-handlers execute after the primary ones. The return value of a message is generally given by the primary message-handlers, but around handlers can also return a value. Around message-handlers allow the user to wrap code around the rest of the handlers. They begin execution before the other handlers and pick up again after all the other message-handlers have finished.

A primary handler provides the part of the message implementation which is most specific to an object, and thus the primary handler attached to the class closest to the immediate class of the object overrides other primary handlers. Before and after handlers provide the ability to pick up behavior from classes that are more general than the immediate class of the object, thus the message implementation uses all handlers of this type from all the classes of an object. When only the roles of the handlers specify which handlers get executed and in what order, the message is said to be declaratively implemented. However, some message implementations may not fit this model well. For example, the results of more than one primary handler may be needed. In cases like this, the handlers themselves must take part in deciding which handlers get executed and in what order. This is called the imperative technique. Around handlers provide imperative control over all other types of handlers except more specific around handlers. Around handlers can change the environment in which other handlers execute and modify the return value for the entire message. A message implementation should use the declarative technique if at all possible because this allows the handlers to be more independent and modular.

A defmessage-handler is comprised of seven elements: 1) a class name to which to attach the handler (the class must have been previously defined), 2) a message name to which the handler will respond, 3) an optional type (the default is primary), 4) an optional comment, 5) a list of parameters that will be passed to the handler during execution, 6) an optional wildcard parameter and 7) a series of expressions which are executed in order when the handler is called. The return-value of a message-handler is the evaluation of the last expression in the body.
Syntax
Defaults are outlined.

(defmessage-handler <class-name> <message-name> 
                   [<handler-type>] [<comment>]
	(<parameter>* [<wildcard-parameter>])
	<action>*)

<handler-type> 		::= around | before | primary | after
<parameter>			::= <single-field-variable>
<wildcard-parameter>	::= <multifield-variable>

Message-handlers are uniquely identified by class, name and type. Message-handlers are never called directly. When the user sends a message to an object, CLIPS selects and orders the applicable message-handlers attached to the object's class(es) and then executes them. This process is termed the message dispatch.
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (role concrete))
CLIPS> 
(defmessage-handler A delete before ()
	 (printout t "Deleting an instance of the class A..." crlf))
CLIPS> 
(defmessage-handler USER delete after ()
   (printout t "System completed deletion of an instance."
               crlf))
CLIPS> (watch instances)
CLIPS> (make-instance a of A)
==> instance [a] of A
[a]
CLIPS> (send [a] delete)
Deleting an instance of the class A...
<== instance [a] of A
System completed deletion of an instance.
TRUE
CLIPS> (unwatch instances)
CLIPS> 
9.4.1 Message-handler Parameters
A message-handler may accept exactly or at least a specified number of arguments, depending on whether a wildcard parameter is used or not. The regular parameters specify the minimum number of arguments that must be passed to the handler. Each of these parameters may be referenced like a normal single-field variable within the actions of the handler. If a wildcard parameter is present, the handler may be passed any number of arguments greater than or equal to the minimum. If no wildcard parameter is present, then the handler must be passed exactly the number of arguments specified by the regular parameters. All arguments to a handler that do not correspond to a regular parameter are grouped into a multifield value that can be referenced by the wildcard parameter. The standard CLIPS multifield functions, such as length$ and expand$, can be applied to the wildcard parameter.

Handler parameters have no bearing on the applicability of a handler to a particular message (see section 9.5.1). However, if the number of arguments is inappropriate, a message execution error (see section 9.5.4) will be generated when the handler is called. Thus, the number of arguments accepted should be consistent for all message-handlers applicable to a particular message.
Example
CLIPS> (clear)
CLIPS> 
(defclass CAR (is-a USER)
  (role concrete)
	(slot front-seat)
	(multislot trunk)
	(slot trunk-count))
CLIPS>
(defmessage-handler CAR put-items-in-car (?item $?rest)
	(bind ?self:front-seat ?item)
	(bind ?self:trunk ?rest)
	(bind ?self:trunk-count (length$ ?rest)))
CLIPS> (make-instance Pinto of CAR)
[Pinto]
CLIPS> (send [Pinto] put-items-in-car bag-of-groceries
        tire suitcase)
2
CLIPS> (send [Pinto] print)
[Pinto] of CAR
(front-seat bag-of-groceries)
(trunk tire suitcase)
(trunk-count 2)
CLIPS>
9.4.1.1 Active Instance Parameter
The term active instance refers to an instance which is responding to a message. All messagehandlers have an implicit parameter called ?self which binds the active instance for a message. This parameter name is reserved and cannot be explicitly listed in the message-handler's parameters, nor can it be rebound within the body of a message-handler.
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (role concrete))
CLIPS> (make-instance a of A)
[a]
CLIPS> 
(defmessage-handler A print-args (?a ?b $?c)
	(printout t (instance-name ?self) " " ?a " " ?b 
		" and " (length$ ?c) " extras: " ?c crlf))
CLIPS> (send [a] print-args 1 2)
[a] 1 2 and 0 extras: ()
CLIPS> (send [a] print-args a b c d)
[a] a b and 2 extras: (c d)
CLIPS>
9.4.2 Message-handler Actions
The body of a message-handler is a sequence of expressions that are executed in order when the handler is called. The return value of the message-handler is the result of the evaluation of the last expression in the body.

Handler actions may directly manipulate slots of the active instance. Normally, slots can only be manipulated by sending the object slot-accessor messages (see sections 9.3.3.9 and 9.4.3). However, handlers are considered part of the encapsulation (see section 2.6.2) of an object, and thus can directly view and change the slots of the object. There are several functions which operate implicitly on the active instance (without the use of messages) and can only be called from within a message-handler. These functions are discussed in section 12.16.

A shorthand notation is provided for accessing slots of the active instance from within a message-handler.
Syntax
?self:<slot-name>
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo (default 1))
  (slot bar (default 2)))
CLIPS>
(defmessage-handler A print-all-slots ()
  (printout t ?self:foo " " ?self:bar crlf))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print-all-slots)
1 2
CLIPS>

The bind function can also take advantage of this shorthand notation to set the value of a slot.
Syntax
(bind ?self:<slot-name> <value>*)
Example
CLIPS>
(defmessage-handler A set-foo (?value)
  (bind ?self:foo ?value))
CLIPS> (send [a] set-foo 34)
34
CLIPS> 

Direct slot accesses are statically bound to the appropriate slot in the defclass when the message-handler is defined. Care must be taken when these direct slot accesses can be executed as the result of a message sent to an instance of a subclass of the class to which the message-handler is attached. If the subclass has redefined the slot, the direct slot access contained in the message-handler attached to the superclass will fail.  That message-handler accesses the slot in the superclass, not the subclass.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot foo (create-accessor read)))
CLIPS> 
(defclass B (is-a A)
  (role concrete)
  (slot foo))
CLIPS> (make-instance b of B)
[b]
CLIPS> (send [b] get-foo)
[MSGPASS3] Static reference to slot foo of class A does not apply to [b] of B
[PRCCODE4] Execution halted during the actions of message-handler get-foo primary in class A
FALSE
CLIPS> 

In order for direct slot accesses in a superclass message-handler to apply to new versions of the slot in subclasses, the dynamic-put and dynamic-get (see sections 12.16.4.10 and 12.16.4.11) must be used. However, the subclass slot must have public visibility for this to work (see section 9.3.3.8).
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot foo))
CLIPS>
(defmessage-handler A get-foo ()
  (dynamic-get foo))
CLIPS> 
(defclass B (is-a A)
  (role concrete)
  (slot foo (visibility public)))
CLIPS> (make-instance b of B)
[b]
CLIPS> (send [b] get-foo)
nil
CLIPS> 
9.4.3 Daemons
Daemons are pieces of code which execute implicitly whenever some basic action is taken upon an instance, such as initialization, deletion, or reading and writing of slots. All these basic actions are implemented with primary handlers attached to the class of the instance. Daemons may be easily implemented by defining other types of message-handlers, such as before or after, which will recognize the same messages. These pieces of code will then be executed whenever the basic actions are performed on the instance.
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (role concrete))
CLIPS> 
(defmessage-handler A init before ()
	(printout t "Initializing a new instance of class A..." 
              crlf))
CLIPS> (make-instance a of A)
Initializing a new instance of class A...
[a]
CLIPS>
9.4.4 Predefined System Message-handlers
CLIPS defines seven primary message-handlers that are attached to the class USER. These handlers cannot be deleted or modified.
9.4.4.1 Instance Initialization
Syntax
(defmessage-handler USER init primary ())

This handler is responsible for initializing instances with class default values after creation. The makeinstance and initializeinstance functions send the init message to an instance (see sections 9.6.1 and 9.6.2); the user should never send this message directly. This handler is implemented using the initslots function (see section 12.13). User-defined init handlers should not prevent the system message-handler from responding to an init message (see section 9.5.3).
Example
CLIPS> (clear)
CLIPS> 
(defclass CAR (is-a USER)
  (role concrete)
  (slot price (default 75000))
  (slot model (default Corniche)))
CLIPS> (watch messages)
CLIPS> (watch message-handlers)
CLIPS> (make-instance Rolls-Royce of CAR)
MSG >> init ED:1 (<Instance-Rolls-Royce>)
HND >> init primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
HND << init primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
MSG << init ED:1 (<Instance-Rolls-Royce>)
[Rolls-Royce]
CLIPS> 
9.4.4.2 Instance Deletion
Syntax
(defmessage-handler USER delete primary ())

This handler is responsible for deleting an instance from the system. The user must directly send a delete message to an instance. User-defined delete message-handlers should not prevent the system message-handler from responding to a delete message (see section 9.5.3). The handler returns the symbol TRUE if the instance was successfully deleted, otherwise it returns the symbol FALSE.
Example
CLIPS> (send [Rolls-Royce] delete)
MSG >> delete ED:1 (<Instance-Rolls-Royce>)
HND >> delete primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
HND << delete primary in class USER
       ED:1 (<Stale Instance-Rolls-Royce>)
MSG << delete ED:1 (<Stale Instance-Rolls-Royce>)
TRUE
CLIPS>
9.4.4.3 Instance Display
Syntax
(defmessage-handler USER print primary ())

This handler prints out slots and their values for an instance.
Example
CLIPS> (make-instance Rolls-Royce of CAR)
MSG >> init ED:1 (<Instance-Rolls-Royce>)
HND >> init primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
HND << init primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
MSG << init ED:1 (<Instance-Rolls-Royce>)
[Rolls-Royce]
CLIPS> (send [Rolls-Royce] print)
MSG >> print ED:1 (<Instance-Rolls-Royce>)
HND >> print primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
[Rolls-Royce] of CAR
(price 75000)
(model Corniche)
HND << print primary in class USER
       ED:1 (<Instance-Rolls-Royce>)
MSG << print ED:1 (<Instance-Rolls-Royce>)
CLIPS> (unwatch messages)
CLIPS. (unwatch message-handlers)
CLIPS> 
9.4.4.4 Directly Modifying an Instance
Syntax
(defmessage-handler USER direct-modify primary
  (?slot-override-expressions))

This handler modifies the slots of an instance directly rather than using put- override messages to place the slot values. The slot-override expressions are passed as an EXTERNAL_ADDRESS data object to the direct-modify handler. This message is used by the functions modifyinstance and activemodifyinstance.
Example
The following around message-handler could be used to insure that all modify message slot-overrides are handled using put- messages.

(defmessage-handler USER direct-modify around
   (?overrides)
   (send ?self message-modify ?overrides))
9.4.4.5 Modifying an Instance using Messages
Syntax
(defmessage-handler USER message-modify primary
  (?slot-override-expressions)

This handler modifies the slots of an instance using put- messages for each slot update. The slot-override expressions are passed as an EXTERNAL_ADDRESS data object to the message-modify handler. This message is used by the functions messagemodifyinstance and activemessagemodifyinstance.
9.4.4.6 Directly Duplicating an Instance
Syntax
(defmessage-handler USER direct-duplicate primary
  (?new-instance-name ?slot-override-expressions))


This handler duplicates an instance without using put- messages to assign the slot-overrides. Slot values from the original instance and slot overrides are directly copied. If the name of the new instance created matches a currently existing instance-name, then the currently existing instance is deleted without use of a message. The slot-override expressions are passed as an EXTERNAL_ADDRESS data object to the direct-duplicate handler. This message is used by the functions duplicateinstance and activeduplicateinstance.
Example
The following around message-handler could be used to insure that all duplicate message slot-overrides are handled using put- messages.

(defmessage-handler USER direct-duplicate around
   (?new-name ?overrides)
   (send ?self message-duplicate ?new-name ?overrides))
9.4.4.7 Duplicating an Instance using Messages
Syntax
(defmessage-handler USER message-duplicate primary
  (?new-instance-name ?slot-override-expressions)

This handler duplicates an instance using messages. Slot values from the original instance and slot overrides are copied using put- and get- messages. If the name of the new instance created matches a currently existing instance-name, then the currently existing instance is deleted using a delete message. After creation, the new instance is sent an init message. The slot-override expressions are passed as an EXTERNAL_ADDRESS data object to the message-duplicate handler. This message is used by the functions messageduplicateinstance and activemessageduplicateinstance.
9.5 MESSAGE DISPATCH
When a message is sent to an object using the send function, CLIPS examines the class precedence list of the active instance's class to determine a complete set of message-handlers which are applicable to the message. CLIPS uses the roles (around, before, primary or after) and specificity of these message-handlers to establish an ordering and then executes them. A handler which is attached to a subclass of another message-handler's class is said to be more specific. This entire process is referred to as the message dispatch. Following is a flow diagram summary:








The solid arrows indicate automatic control transfer by the message dispatch system. 

The dashed arrows indicate control transfer that can only be accomplished by the use or lack of the use of callnexthandler (or overridenexthandler).
9.5.1 Applicability of Message-handlers
A message-handler is applicable to a message if its name matches the message, and it is attached to a class which is in the class precedence list of the class of the instance receiving the message. 
9.5.2 Message-handler Precedence
The set of all applicable message-handlers are sorted into four groups according to role, and these four groups are further sorted by class specificity. The around, before and primary handlers are ordered from most specific to most general, whereas after handlers are ordered from most general to most specific. 

The order of execution is as follows: 1) around handlers begin execution from most specific to most general (each around handler must explicitly allow execution of other handlers), 2) before handlers execute (one after the other) from most specific to most general 3) primary handlers begin execution from most specific to most general (more specific primary handlers must explicitly allow execution of more general ones), 4) primary handlers finish execution from most general to most specific, 5) after handlers execute (one after the other) from most general to most specific and  6) around handlers finish execution from most general to most specific.

There must be at least one applicable primary handler for a message, or a message execution error will be generated (see section 9.5.4).
9.5.3 Shadowed Message-handlers
When one handler must be called by another handler in order to be executed, the first handler is said to be shadowed by the second. An around handler shadows all handlers except more specific around handlers. A primary handler shadows all more general primary handlers.

Messages should be implemented using the declarative technique, if possible. Only the handler roles will dictate which handlers get executed; only before and after handlers and the most specific primary handler are used. This allows each handler for a message to be completely independent of the other messagehandlers. However, if around handlers or shadowed primary handlers are necessary, then the handlers must explicitly take part in the message dispatch by calling other handlers they are shadowing. This is called the imperative technique. The functions callnexthandler and overridenexthandler (see section 12.16.2) allow a handler to execute the handler it is shadowing. A handler can call the same shadowed handler multiple times.
Example
(defmessage-handler USER my-message around ()
	(call-next-handler))
(defmessage-handler USER my-message before ())
(defmessage-handler USER my-message ()
	(call-next-handler))
(defmessage-handler USER my-message after ())
(defmessage-handler OBJECT my-message around ()
	(call-next-handler))
(defmessage-handler OBJECT my-message before ())
(defmessage-handler OBJECT my-message ())
(defmessage-handler OBJECT my-message after ())

For a message sent to an instance of a class which inherits from USER, the diagram to the right illustrates the order of execution for the handlers attached to the classes USER and OBJECT. The brackets indicate where a particular handler begins and ends execution. Handlers enclosed within a bracket are shadowed. 




9.5.4 Message Execution Errors
If an error occurs at any time during the execution of a message-handler, any currently executing handlers will be aborted, any handlers which have not yet started execution will be ignored, and the send function will return the symbol FALSE.

A lack of applicable of primary message-handlers and a handler being called with the wrong number of arguments are common message execution errors.
9.5.5 Message Return Value
The return value of call to the send function is the return value of the most specific around handler, or the most specific primary handler if there are no around handlers. The return value of a handler is the result of the evaluation of the last action in the handler.

The return values of the before and after handlers are ignored; they are for side-effects only. An around handler can choose to ignore or capture the return value of the next most specific around or primary handler. A primary handler can choose to ignore or capture the return value of a more general primary handler.
9.6 MANIPULATING INSTANCES
Objects are manipulated by sending them messages. This is achieved by using the send function, which takes as arguments the destination object for the message, the message itself and any arguments which are to be passed to handlers. 
Syntax
(send <object-expression>
	<message-name-expression> <expression>*)

Section 2.4.2 explains object references. The return value of send is the result of the message as explained in section 9.5.5.

The slots of an object may be read or set directly only within the body of a messagehandler that is executing on behalf of a message that was sent to that object. This is how COOL implements the notion of encapsulation (see Section 2.6.2). Any action performed on an object by an external source, such as a rule or function, must be done with messages. There are two major exceptions: 1) objects which are not instances of user-defined classes (floating-point and integer numbers, symbols, strings, multifield values, fact-addresses and external-addresses) can be manipulated in the standard non-OOP manner of previous versions of CLIPS as well and 2) creation and initialization of an instance of a user-defined class are performed via the function makeinstance.
9.6.1 Creating Instances
Like facts, instances of user-defined classes must be explicitly created by the user. Likewise, all instances are deleted during the reset command, and they can be loaded and saved similarly to facts. All operations involving instances require message-passing using the send function except for creation, since the object does not yet exist. A function called makeinstance is used to create and initialize a new instance. This function implicitly sends an initialization message to the new object after allocation, and the user can customize instance initialization with daemons. make-instance also allows slotoverrides to change any predefined initialization for a particular instance. make-instance automatically delays all object pattern-matching activities for rules until all slot overrides have been processed. The function activemakeinstance can be used if delayed pattern-matching is not desired. active-make-instance remembers the current state of delayed pattern-matching, explicitly turns delay on, and then restores it to its previous state once all slot overrides have been processed.
Syntax
(make-instance <instance-definition>)
(active-make-instance <instance-definition>)

<instance-definition> ::= [<instance-name-expression>] of
						<class-name-expression>
						<slot-override>*
<slot-override>       ::= (<slot-name-expression> 								<expression>*)

The return value of make-instance is the name of the new instance on success or the symbol FALSE on failure. The evaluation of <instance-name-expression> can either be an instance-name or a symbol. If <instance-name-expression> is not specified, then the function gensym* will be called to generate the instance-name.

make-instance performs the following steps in order:

1) If an instance of the specified name already exists, that instance receives a delete message, e.g. (send <instance-name> delete). If this fails for any reason, the new instance creation is aborted. Normally, the handler attached to class USER will respond to this message (see section 9.4.5.2).
2) A new and uninitialized instance of the specified class is created with the specified name.
3) All slotoverrides are immediately evaluated and placed via put messages (see section 9.3.3.10), e.g. (send <instance-name> put-<slot-name> <expression>*). If there are any errors, the new instance is deleted.
4) The new instance receives the init message, e.g. (send <instance-name> init). Normally, the handler attached to class USER will respond to this message (see section 9.4.4.1). This handler calls the initslots function (see section 12.16.4.1). This function uses defaults from the class definition (if any) for any slots which do not have slot-overrides. The class defaults are placed directly without the use of messages. If there are any errors, the new instance is deleted.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
	(slot x (default 34)
          (create-accessor write))
	(slot y (default abc)))
CLIPS>
(defmessage-handler A put-x before (?value)
	(printout t "Slot x set with message." crlf))
CLIPS>
(defmessage-handler A delete after ()
	(printout t "Old instance deleted." crlf))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print)
[a] of A
(x 34)
(y abc)
CLIPS> (make-instance [a] of A (x 65))
Old instance deleted.
Slot x set with message.
[a]
CLIPS> (send [a] print)
a of A
(x 65)
(y abc)
CLIPS> (send [a] delete)
Old instance deleted.
TRUE
CLIPS> 
9.6.1.1 Definstances Construct
Similar to deffacts, the definstances construct allows the specification of instances which will be created every time the reset command is executed. On every reset all current instances receive a delete message, and the equivalent of a makeinstance function call is made for every instance specified in definstances constructs.
Syntax
(definstances <definstances-name> [active] [<comment>]
	<instance-template>*)
<instance-template> ::= (<instance-definition>)

A definstances cannot use classes which have not been previously defined. The instances of a definstances are created in order, and if any individual creation fails, the remainder of the definstances will be aborted. Normally, definstances just use the makeinstance function (which means delayed Rete activity) to create the instances. However, if this is not desired,then the active keyword can be specified after the definstances name so that the activemakeinstance function will be used.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER) (role concrete)
	 (slot x (create-accessor write) (default 1)))
CLIPS> 
(definstances A-OBJECTS 
	 (a1 of A)
   (of A (x 65)))
CLIPS> (watch instances)
CLIPS> (reset)
==> instance [initial-object] of INITIAL-OBJECT
==> instance [a1] of A
==> instance [gen1] of A
CLIPS> (reset)
<== instance [initial-object] of INITIAL-OBJECT
<== instance [a1] of A
<== instance [gen1] of A
==> instance [initial-object] of INITIAL-OBJECT
==> instance [a1] of A
==> instance [gen2] of A
CLIPS> (unwatch instances)
CLIPS> 

Upon startup and after a clear command, CLIPS automatically constructs the following definstances.

(definstances initial-object
   (initial-object of INITIAL-OBJECT))

The class INITIAL-OBJECT is a predefined system class that is a direct subclass of USER.

(defclass INITIAL-OBJECT
   (is-a USER)
   (role concrete)
   (pattern-match reactive))

The initial-object definstances and the INITIAL-OBJECT class are only defined if both the object system and defrules are enabled (see section 2 of the Advanced Programming Guide). The INITIAL-OBJECT class cannot be deleted, but the initial-object definstances can. See section 5.4.9 for details on default patterns which pattern-match against the initial-object instance.
9.6.2 Reinitializing Existing Instances
The initializeinstance function provides the ability to reinitialize an existing instance with class defaults and new slot-overrides. The return value of initialize-instance is the name of the instance on success or the symbol FALSE on failure. The evaluation of <instance-name-expression> can either be an instance-name, instance-address or a symbol. initialize-instance automatically delays all object pattern-matching activities for rules until all slot overrides have been processed. The function activeinitializeinstance can be used if delayed pattern-matching is not desired.
Syntax
(initialize-instance <instance-name-expression>
	<slot-override>*)

initialize-instance performs the following steps in order:

1) All slotoverrides are immediately evaluated and placed via put- messages (see section 9.3.3.10), e.g. (send <instance-name> put-<slot-name> <expression>*).
2) The instance receives the init message, e.g. (send <instance-name> init). Normally, the handler attached to class USER will respond to this message (see section 9.4.5.1). This handler calls the initslots function (see section 12.16.4.1). This function uses defaults from the class definition (if any) for any slots which do not have slot-overrides. The class defaults are placed directly without the use of messages. 

If no slot-override or class default specifies the value of a slot, that value will remain the same. Empty class default values allow initialize-instance to clear a slot.

If an error occurs, the instance will not be deleted, but the slot values may be in an inconsistent state.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
	(slot x (default 34)
          (create-accessor write))
	(slot y (default ?NONE)
          (create-accessor write))
	(slot z (create-accessor write)))
CLIPS> (make-instance a of A (y 100))
[a]
CLIPS> (send [a] print)
[a] of A
(x 34)
(y 100)
(z nil)
CLIPS> (send [a] put-x 65)
65
CLIPS> (send [a] put-y abc)
abc
CLIPS> (send [a] put-z "Hello world.")
"Hello world."
CLIPS> (send [a] print)
[a] of A
(x 65)
(y abc)
(z "Hello world.")
CLIPS> (initialize-instance a)
[a]
CLIPS> (send [a] print)
a of A
(x 34)
(y abc)
(z nil)
CLIPS>
9.6.3 Reading Slots
Sources external to an object, such as a rule or deffunction, can read an object's slots only by sending the object a message. Messagehandlers executing on the behalf of an object can either use messages or direct access to read the object's slots (see section 9.4.2). Several functions also exist which operate implicitly on the active instance for a message that can only be called by message-handlers, such as dynamicget (see section 12.16.4.10). 

Section 12.16 describes ways of testing for the existence of slots and their values.
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot x (create-accessor read)
          (default abc)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (sym-cat (send [a] get-x) def)
abcdef
CLIPS>
9.6.4 Setting Slots
Sources external to an object, such as a rule or deffunction, can write an object's slots only by sending the object a message. Several functions also exist which operate implicitly on the active instance for a message that can only be called by messagehandlers, such as dynamicput (see section 12.16.4.11). The bind function can also be used to set a slot's value from within a message-handler (see section 9.4.2).
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
	(role concrete)
	(slot x (create-accessor write)
          (default abc)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] put-x "New value.")
"New value."
CLIPS>
9.6.5 Deleting Instances
Sending the delete message to an instance removes it from the system. Within a message-handler, the deleteinstance function (see section 12.16) can be used to delete the active instance for a message.
Syntax
(send <instance> delete)
9.6.6 Delayed Pattern-Matching When Manipulating Instances
While manipulating instances (either by creating, modifying, or deleting), it is possible to delay pattern-matching activities for rules until after all of the manipulations have been made. This can be accomplished using the objectpatternmatchdelay function. This function acts identically to the progn function, however, any actions which could affect object pattern-matching for rules are delayed until the function is exited. This function's primary purpose is to provide some control over performance.
Syntax
(object-pattern-match-delay <action>*)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (pattern-match reactive))
CLIPS> 
(defrule match-A
  (object (is-a A))
=>)
CLIPS> (make-instance a of A)
[a]
CLIPS> (agenda)
0      match-A: [a]
For a total of 1 activation.
CLIPS> (make-instance b of A)
[b]
CLIPS> (agenda)
0      match-A: [b]
0      match-A: [a]
For a total of 2 activations.
CLIPS> 
(object-pattern-match-delay
   (make-instance c of A)
   (printout t "After c..." crlf)
   (agenda)
   (make-instance d of A)
   (printout t "After d..." crlf)
   (agenda))
After c...
0      match-A: [b]
0      match-A: [a]
For a total of 2 activations.
After d...
0      match-A: [b]
0      match-A: [a]
For a total of 2 activations.
CLIPS> (agenda)
0      match-A: [d]
0      match-A: [c]
0      match-A: [b]
0      match-A: [a]
For a total of 4 activations.
CLIPS> 
9.6.7 Modifying Instances
Four functions are provided for modifying instances. These functions allow instance slot updates to be performed in blocks without requiring a series of put- messages. Each of these functions returns the symbol TRUE if successful, otherwise the symbol FALSE is returned.
9.6.7.1 Directly Modifying an Instance with Delayed Pattern-Matching
The modifyinstance function uses the directmodify message to change the values of the instance. Object pattern-matching is delayed until all of the slot modifications have been performed.
Syntax
(modify-instance <instance> <slot-override>*)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo)
  (slot bar))
CLIPS> (make-instance a of A)
[a]
CLIPS> (watch all)
CLIPS> (modify-instance a (foo 0))
MSG >> direct-modify ED:1 (<Instance-a> <Pointer-0019CD5A>)
HND >> direct-modify primary in class USER.
       ED:1 (<Instance-a> <Pointer-0019CD5A>)
::= local slot foo in instance a <- 0
HND << direct-modify primary in class USER.
       ED:1 (<Instance-a> <Pointer-0019CD5A>)
MSG << direct-modify ED:1 (<Instance-a> <Pointer-0019CD5A>)
TRUE
CLIPS> (unwatch all)
CLIPS> 
9.6.7.2 Directly Modifying an Instance with Immediate Pattern-Matching
The activemodifyinstance function uses the directmodify message to change the values of the instance. Object pattern-matching occurs as slot modifications are being performed.
Syntax
(active-modify-instance <instance> <slot-override>*)
9.6.7.3 Modifying an Instance using Messages with Delayed Pattern-Matching
The messagemodifyinstance function uses the messagemodify message to change the values of the instance. Object pattern-matching is delayed until all of the slot modifications have been performed.
Syntax
(message-modify-instance <instance> <slot-override>*)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo)
  (slot bar (create-accessor write)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (watch all)
CLIPS> (message-modify-instance a (bar 4))
MSG >> message-modify ED:1 (<Instance-a> <Pointer-009F04A0>)
HND >> message-modify primary in class USER
       ED:1 (<Instance-a> <Pointer-009F04A0>)
MSG >> put-bar ED:2 (<Instance-a> 4)
HND >> put-bar primary in class A
       ED:2 (<Instance-a> 4)
::= local slot bar in instance a <- 4
HND << put-bar primary in class A
       ED:2 (<Instance-a> 4)
MSG << put-bar ED:2 (<Instance-a> 4)
HND << message-modify primary in class USER
       ED:1 (<Instance-a> <Pointer-009F04A0>)
MSG << message-modify ED:1 (<Instance-a> <Pointer-009F04A0>)
TRUE
CLIPS> (unwatch all)
CLIPS> 
9.6.7.4 Modifying an Instance using Messages with Immediate Pattern-Matching
The activemessagemodifyinstance function uses the messagemodify message to change the values of the instance. Object pattern-matching occurs as slot modifications are being performed.
Syntax
(active-message-modify-instance <instance> <slot-override>*)
9.6.8 Duplicating Instances
Four functions are provided for duplicating instances. These functions allow instance duplication and slot updates to be performed in blocks without requiring a series of put- messages. Each of these functions return the instance-name of the new duplicated instance if successful, otherwise the symbol FALSE is returned.

Each of the duplicate functions can optionally specify the name of the instance to which the old instance will be copied. If the name is not specified, the function will generate the name using the (gensym*) function. If the target instance already exists, it will be deleted directly or with a delete message depending on which function was called.
9.6.8.1 Directly Duplicating an Instance with Delayed Pattern-Matching
The duplicateinstance function uses the directduplicate message to change the values of the instance. Object pattern-matching is delayed until all of the slot modifications have been performed.
Syntax
(duplicate-instance <instance> [to <instance-name>]
                    <slot-override>*)
Example
CLIPS> (clear)
CLIPS> (setgen 1)
1
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo (create-accessor write))
  (slot bar (create-accessor write)))
CLIPS> (make-instance a of A (foo 0) (bar 4))
[a]
CLIPS> (watch all)
CLIPS> (duplicate-instance a)
MSG >> direct-duplicate ED:1 (<Instance-a> [gen1] <Pointer-00000000>)
HND >> direct-duplicate primary in class USER
       ED:1 (<Instance-a> [gen1] <Pointer-00000000>)
==> instance [gen1] of A
::= local slot foo in instance gen1 <- 0
::= local slot bar in instance gen1 <- 4
HND << direct-duplicate primary in class USER
       ED:1 (<Instance-a> [gen1] <Pointer-00000000>)
MSG << direct-duplicate ED:1 (<Instance-a> [gen1] <Pointer-00000000>)
[gen1]
CLIPS> (unwatch all)
CLIPS> 
9.6.8.2 Directly Duplicating an Instance with Immediate Pattern-Matching
The activeduplicateinstance function uses the directduplicate message to change the values of the instance. Object pattern-matching occurs as slot modifications are being performed.
Syntax
(active-duplicate-instance <instance> [to <instance-name>] 
                           <slot-override>*)
9.6.8.3 Duplicating an Instance using Messages with Delayed Pattern-Matching
The messageduplicateinstance function uses the messageduplicate message to change the values of the instance. Object pattern-matching is delayed until all of the slot modifications have been performed.
Syntax
(message-duplicate-instance <instance> [to <instance-name>]
                            <slot-override>*)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (slot foo (create-accessor write))
  (slot bar (create-accessor write)))
CLIPS> (make-instance a of A (foo 0) (bar 4))
[a]
CLIPS> (make-instance b of A)
[b]
CLIPS> (watch all)
CLIPS> (message-duplicate-instance a to b (bar 6))
MSG >> message-duplicate ED:1 (<Instance-a> [b] <Pointer-009F04A0>)
HND >> message-duplicate primary in class USER
       ED:1 (<Instance-a> [b] <Pointer-009F04A0>)
MSG >> delete ED:2 (<Instance-b>)
HND >> delete primary in class USER
       ED:2 (<Instance-b>)
<== instance [b] of A
HND << delete primary in class USER
       ED:2 (<Stale Instance-b>)
MSG << delete ED:2 (<Stale Instance-b>)
==> instance [b] of A
MSG >> put-bar ED:2 (<Instance-b> 6)
HND >> put-bar primary in class A
       ED:2 (<Instance-b> 6)
::= local slot bar in instance b <- 6
HND << put-bar primary in class A
       ED:2 (<Instance-b> 6)
MSG << put-bar ED:2 (<Instance-b> 6)
MSG >> put-foo ED:2 (<Instance-b> 0)
HND >> put-foo primary in class A
       ED:2 (<Instance-b> 0)
::= local slot foo in instance b <- 0
HND << put-foo primary in class A
       ED:2 (<Instance-b> 0)
MSG << put-foo ED:2 (<Instance-b> 0)
MSG >> init ED:2 (<Instance-b>)
HND >> init primary in class USER
       ED:2 (<Instance-b>)
HND << init primary in class USER
       ED:2 (<Instance-b>)
MSG << init ED:2 (<Instance-b>)
HND << message-duplicate primary in class USER
       ED:1 (<Instance-a> [b] <Pointer-009F04A0>)
MSG << message-duplicate ED:1 (<Instance-a> [b] <Pointer-009F04A0>)
[b]
CLIPS> (unwatch all)
CLIPS> 
9.6.8.4 Duplicating an Instance using Messages with Immediate Pattern-Matching
The activemessageduplicateinstance function uses the messageduplicate message to change the values of the instance. Object pattern-matching occurs as slot modifications are being performed.
Syntax
(active-message-duplicate-instance <instance> 
                                   [to <instance-name>] 
                                   <slot-override>*)

9.7 INSTANCE-SET QUERIES AND DISTRIBUTED ACTIONS
COOL provides a useful query system for determining and performing actions on sets of instances of user-defined classes that satisfy user-defined queries. The instance query system in COOL provides six functions, each of which operate on instance-sets determined by user-defined criteria:

Function
Purpose
any-instancep
Determines if one or more instance-sets satisfy a query
find-instance
Returns the first instance-set that satisfies a query
find-all-instances
Groups and returns all instance-sets which satisfy a query
do-for-instance
Performs an action for the first instance-set which satisfies a query
do-for-all-instances
Performs an action for every instance-set which satisfies a query as they are found
delayed-do-for-all-instances
Groups all instance-sets which satisfy a query and then iterates an action over this group

Explanations on how to form instance-set templates, queries and actions immediately follow, for these definitions are common to all of the query functions. The specific details of each query function will then be given. The following is a complete example of an instance-set query function:
Example



For all of the examples in this section, assume that the commands below have already been entered:
Example
CLIPS>
(defclass PERSON (is-a USER)
  (role abstract)
  (slot sex (access read-only)
            (storage shared))
  (slot age (type NUMBER)
            (visibility public)))
CLIPS>
(defmessage-handler PERSON put-age (?value)
  (dynamic-put age ?value))
CLIPS>
(defclass FEMALE (is-a PERSON)
  (role abstract)
  (slot sex (source composite)
            (default female)))
CLIPS>
(defclass MALE (is-a PERSON)
  (role abstract)
  (slot sex (source composite)
            (default male)))
CLIPS>
(defclass GIRL (is-a FEMALE)
  (role concrete)
  (slot age (source composite)
            (default 4)
            (range 0.0 17.9)))
CLIPS>
(defclass WOMAN (is-a FEMALE)
  (role concrete)
  (slot age (source composite)
            (default 25)
            (range 18.0 100.0)))
CLIPS>
(defclass BOY (is-a MALE)
  (role concrete)
  (slot age (source composite)
            (default 4)
            (range 0.0 17.9)))
CLIPS>
(defclass MAN (is-a MALE)
  (role concrete)
  (slot age (source composite)
            (default 25)
            (range 18.0 100.0)))
CLIPS>
(definstances PEOPLE
  (Man-1 of MAN (age 18))
  (Man-2 of MAN (age 60))
  (Woman-1 of WOMAN (age 18))
  (Woman-2 of WOMAN (age 60))
  (Woman-3 of WOMAN)
  (Boy-1 of BOY (age 8))
  (Boy-2 of BOY)
  (Boy-3 of BOY)
  (Boy-4 of BOY)
  (Girl-1 of GIRL (age 8))
  (Girl-2 of GIRL))
CLIPS> (reset)
CLIPS>
9.7.1 Instance-set Definition
An instanceset is an ordered collection of instances. Each instance-set member is an instance of a set of classes, called class restrictions, defined by the user. The class restrictions can be different for each instance-set member. The query functions use instance-set templates to generate instance-sets. An instance-set template is a set of instance-set member variables and their associated class restrictions. Instance-set member variables reference the corresponding members in each instance-set which matches a template. Variables may be used to specify the classes for the instance-set template, but if the constant names of the classes are specified, the classes must already be defined. Module specifiers may be included with the class names; the classes need not be in scope of the current module.
Syntax
<instance-set-template> 
      ::= (<instance-set-member-template>+)
<instance-set-member-template>
      ::= (<instance-set-member-variable> <class-restrictions>)
<instance-set-member-variable> ::= <single-field-variable>
<class-restrictions>           ::= <class-name-expression>+
Example
One instance-set template might be the ordered pairs of boys or men and girls or women. 

((?man-or-boy BOY MAN) (?woman-or-girl GIRL WOMAN))

This instance-set template could have been written equivalently:

((?man-or-boy MALE) (?woman-or-girl FEMALE))

Instance-set member variables (e.g. ?man-or-boy) are bound to instancenames.
9.7.2 Instance-set Determination
COOL uses straightforward permutations to generate instance-sets that match an instance-set template from the actual instances in the system. The rules are as follows:

1) When there is more than one member in an instance-set template, vary the rightmost members first.
2)  When there is more than one class that an instance-set member can be, iterate through the classes from left to right.
3) Examine instances of a class in the order that they were defined.
3a) Recursively examine instances of subclasses in the order that the subclasses were defined. If the specified query class was in scope of the current module, then only subclasses which are also in scope will be examined. Otherwise, only subclasses which are in scope of the module to which the query class belongs will be examined.
Example
For the instance-set template given in section 9.7.1, thirty instance-sets would be generated in the following order:

1.  [Boy-1] [Girl-1]
2.  [Boy-1] [Girl-2]
3.  [Boy-1] [Woman-1]
4.  [Boy-1] [Woman-2]
5.  [Boy-1] [Woman-3]
6.  [Boy-2] [Girl-1]
7.  [Boy-2] [Girl-2]
8.  [Boy-2] [Woman-1]
9.  [Boy-2] [Woman-2]
10. [Boy-2] [Woman-3]
11. [Boy-3] [Girl-1]
12. [Boy-3] [Girl-2]
13  [Boy-3] [Woman-1]
14. [Boy-3] [Woman-2]
15. [Boy-3] [Woman-3]

16. [Boy-4] [Girl-1]
17. [Boy-4] [Girl-2]
18. [Boy-4] [Woman-1]
19. [Boy-4] [Woman-2]
20. [Boy-4] [Woman-3]
21. [Man-1] [Girl-1]
22. [Man-1] [Girl-2]
23. [Man-1] [Woman-1]
24. [Man-1] [Woman-2]
25. [Man-1] [Woman-3]
26. [Man-2] [Girl-1]
27. [Man-2] [Girl-2]
28. [Man-2] [Woman-1]
29. [Man-2] [Woman-2]
30. [Man-2] [Woman-3]

Example
Consider the following instance-set template: 

((?f1 FEMALE) (?f2 FEMALE))

Twenty-five instance-sets would be generated in the following order:

1. [Girl-1] [Girl-1]
2. [Girl-1] [Girl-2]
3. [Girl-1] [Woman-1]
4. [Girl-1] [Woman-2]
5. [Girl-1] [Woman-3]
6. [Girl-2] [Girl-1]
7. [Girl-2] [Girl-2]
8. [Girl-2] [Woman-1]
9. [Girl-2] [Woman-2]
10.[Girl-2] [Woman-3]
11.[Woman-1] [Girl-1]
12.[Woman-1] [Girl-2]
13.[Woman-1] [Woman-1]
14.[Woman-1] [Woman-2]
15.[Woman-1] [Woman-3]
16.[Woman-2] [Girl-1]
17.[Woman-2] [Girl-2]
18.[Woman-2] [Woman-1]
19.[Woman-2] [Woman-2]
20.[Woman-2] [Woman-3]
21.[Woman-3] [Girl-1]
22.[Woman-3] [Girl-2]
23.[Woman-3] [Woman-1]
24.[Woman-3] [Woman-2]
25.[Woman-3] [Woman-3]

The instances of class GIRL are examined before the instances of class WOMAN because GIRL was defined before WOMAN.
9.7.3 Query Definition
A query is a user-defined boolean expression applied to an instance-set to determine if the instance-set meets further user-defined restrictions. If the evaluation of this expression for an instance-set is anything but the symbol FALSE, the instance-set is said to satisfy the query.
Syntax
<query> ::= <boolean-expression>
Example
Continuing the previous example, one query might be that the two instances in an ordered pair have the same age.

(= (send ?man-or-boy get-age) (send ?woman-or-girl get-age))

Within a query, slots of instance-set members can be directly read with a shorthand notation similar to that used in message-handlers (see section 9.4.2). If message-passing is not explicitly required for reading a slot (i.e. there are no accessor daemons for reads), then this second method of slot access should be used, for it gives a significant performance benefit.
Syntax
<instance-set-member-variable>:<slot-name>
Example
The previous example could be rewritten as:

(= ?man-or-boy:age ?woman-or-girl:age)

Since only instance-sets which satisfy a query are of interest, and the query is evaluated for all possible instance-sets, the query should not have any side-effects.
9.7.4 Distributed Action Definition
A distributed action is a user-defined expression evaluated for each instance-set which satisfies a query. Unlike queries, distributed actions must use messages to read slots of instance-set members. If more than one action is required, use the progn function (see section 12.6.5) to group them.
Action Syntax
<action> ::= <expression>
Example
Continuing the previous example, one distributed action might be to simply print out the ordered pair to the screen.

(printout t "(" ?man-or-boy "," ?woman-or-girl ")" crlf)
9.7.5 Scope in Instance-set Query Functions
An instance-set query function can be called from anywhere that a regular function can be called. If a variable from an outer scope is not masked by an instance-set member variable, then that variable may be referenced within the query and action. In addition, rebinding variables within an instance-set function action is allowed. However, attempts to rebind instance-set member variables will generate errors. Binding variables is not allowed within a query. Instance-set query functions can be nested. 
Example
CLIPS>
(deffunction count-instances (?class)
  (bind ?count 0)
  (do-for-all-instances ((?ins ?class)) TRUE
    (bind ?count (+ ?count 1)))
 ?count)
CLIPS>
(deffunction count-instances-2 (?class)
  (length (find-all-instances ((?ins ?class)) TRUE)))
CLIPS> (count-instances WOMAN)
3
CLIPS> (count-instances-2 BOY)
4
CLIPS>

Instance-set member variables are only in scope within the instance-set query function.  Attempting to use instance-set member variables in an outer scope will generate an error.
Example
CLIPS>
(deffunction last-instance (?class)
   (any-instancep ((?ins ?class)) TRUE)
   ?ins)

[PRCCODE3] Undefined variable ins referenced in deffunction.

ERROR:
(deffunction last-instance
   (?class)
   (any-instancep ((?ins ?class))
      TRUE)
   ?ins
   )
CLIPS> 
9.7.6 Errors during Instance-set Query Functions
If an error occurs during an instance-set query function, the function will be immediately terminated and the return value will be the symbol FALSE.
9.7.7 Halting and Returning Values from Query Functions
The functions break and return are now valid inside the action of the instance-set query functions doforinstance, doforallinstances and delayeddoforallinstances. The return function is only valid if it is applicable in the outer scope, whereas the break function actually halts the query.
9.7.8 Instance-set Query Functions
The instance query system in COOL provides six functions.  For a given set of instances, all six query functions will iterate over these instances in the same order (see section 9.7.2).  However, if a particular instance is deleted and recreated, the iteration order will change.
9.7.8.1 Testing if Any Instance-set Satisfies a Query
This function applies a query to each instance-set which matches the template. If an instance-set satisfies the query, then the function is immediately terminated, and the return value is the symbol TRUE. Otherwise, the return value is the symbol FALSE.
Syntax
(anyinstancep <instance-set-template> <query>)
Example
Are there any men over age 30?

CLIPS> (any-instancep ((?man MAN)) (> ?man:age 30))
TRUE
CLIPS>
9.7.8.2 Determining the First Instance-set Satisfying a Query
This function applies a query to each instance-set which matches the template. If an instance-set satisfies the query, then the function is immediately terminated, and the instance-set is returned in a multifield value. Otherwise, the return value is a zero-length multifield value. Each field of the multifield value is an instance-name representing an instance-set member.
Syntax
(findinstance <instance-set-template> <query>)
Example
Find the first pair of a man and a woman who have the same age.

CLIPS> 
(find-instance ((?m MAN) (?w WOMAN)) (= ?m:age ?w:age))
([Man-1] [Woman-1])
CLIPS>
9.7.8.3 Determining All Instance-sets Satisfying a Query
This function applies a query to each instance-set which matches the template. Each instance-set which satisfies the query is stored in a multifield value. This multifield value is returned when the query has been applied to all possible instance-sets. If there are n instances in each instance-set, and m instance-sets satisfied the query, then the length of the returned multifield value will be n * m. The first n fields correspond to the first instance-set, and so on. Each field of the multifield value is an instance-name representing an instance-set member. The multifield value can consume a large amount of memory due to permutational explosion, so this function should be used judiciously.
Syntax
(findallinstances <instance-set-template> <query>)
Example
Find all pairs of a man and a woman who have the same age.

CLIPS> 
(find-all-instances ((?m MAN) (?w WOMAN)) (= ?m:age ?w:age))
([Man-1] [Woman-1] [Man-2] [Woman-2])
CLIPS>
9.7.8.4 Executing an Action for the First Instance-set Satisfying a Query
This function applies a query to each instance-set which matches the template. If an instance-set satisfies the query, the specified action is executed, and the function is immediately terminated. The return value is the evaluation of the action. If no instance-set satisfied the query, then the return value is the symbol FALSE.
Syntax
(doforinstance <instance-set-template> <query> <action>)
Example
Print out the first triplet of different people that have the same age. The calls to neq in the query eliminate the permutations where two or more members of the instance-set are identical.

CLIPS> 
(do-for-instance ((?p1 PERSON) (?p2 PERSON) (?p3 PERSON))
  (and (= ?p1:age ?p2:age ?p3:age)
       (neq ?p1 ?p2)
       (neq ?p1 ?p3)
       (neq ?p2 ?p3))
  (printout t ?p1 " " ?p2 " " ?p3 crlf))
[Girl-2] [Boy-2] [Boy-3]
CLIPS>
9.7.8.5 Executing an Action for All Instance-sets Satisfying a Query
This function applies a query to each instance-set which matches the template. If an instance-set satisfies the query, the specified action is executed. The return value is the evaluation of the action for the last instance-set which satisfied the query. If no instance-set satisfied the query, then the return value is the symbol FALSE.
Syntax
(doforallinstances <instance-set-template> <query> <action>)
Example
Print out all triplets of different people that have the same age. The calls to str-compare limit the instance-sets which satisfy the query to combinations instead of permutations. Without these restrictions, two instance-sets which differed only in the order of their members would both satisfy the query.

CLIPS> 
(do-for-all-instances ((?p1 PERSON) (?p2 PERSON) (?p3 PERSON))
  (and (= ?p1:age ?p2:age ?p3:age)
    (> (str-compare ?p1 ?p2) 0)
    (> (str-compare ?p2 ?p3) 0))
  (printout t ?p1 " " ?p2 " " ?p3 crlf))
[Girl-2] [Boy-3] [Boy-2]
[Girl-2] [Boy-4] [Boy-2]
[Girl-2] [Boy-4] [Boy-3]
[Boy-4] [Boy-3] [Boy-2]
CLIPS>
9.7.8.6 Executing a Delayed Action for All Instance-sets
	Satisfying a Query
This function is similar to doforallinstances except that it groups all instance-sets which satisfy the query into an intermediary multifield value. If there are no instance-sets which satisfy the query, then the function returns the symbol FALSE. Otherwise, the specified action is executed for each instance-set in the multifield value, and the return value is the evaluation of the action for the last instance-set to satisfy the query. The intermediary multifield value is discarded. This function can consume large amounts of memory in the same fashion as findallinstances. This function should be used in lieu of do-for-all-instances when the action applied to one instance-set would change the result of the query for another instance-set (unless that is the desired effect).
Syntax
(delayeddoforallinstances <instance-set-template> 
  <query> <action>)
Example
Delete all boys with the greatest age. The test in this case is another query function which determines if there are any older boys than the one currently being examined. The action needs to be delayed until all boys have been processed, or the greatest age will decrease as the older boys are deleted.

CLIPS> (watch instances)
CLIPS>
(delayed-do-for-all-instances ((?b1 BOY)) 
  (not (any-instancep ((?b2 BOY)) 
         (> ?b2:age ?b1:age)))
  (send ?b1 delete))
<== instance [Boy-1] of BOY
TRUE
CLIPS> (unwatch instances)
CLIPS> (reset)
CLIPS> (watch instances)
CLIPS> 
(do-for-all-instances ((?b1 BOY)) 
  (not (any-instancep ((?b2 BOY)) 
         (> ?b2:age ?b1:age)))
  (send ?b1 delete))
<== instance [Boy-1] of BOY
<== instance [Boy-2] of BOY
<== instance [Boy-3] of BOY
<== instance [Boy-4] of BOY
TRUE
CLIPS> (unwatch instances)
CLIPS> 

Section 10 - Defmodule Construct
CLIPS provides support for the modular development and execution of knowledge bases with the defmodule construct. CLIPS modules allow a set of constructs to be grouped together such that explicit control can be maintained over restricting the access of the constructs by other modules. This type of control is similar to global and local scoping used in languages such as C or Ada (note, however, that the global scoping used by CLIPS is strictly hierarchical and in one direction only-if module A can see constructs from module B, then it is not possible for module B to see any of module A's constructs). By restricting access to deftemplate and defclass constructs, modules can function as blackboards, permitting only certain facts and instances to be seen by other modules. Modules are also used by rules to provide execution control.
10.1 DEFINING MODULES
Modules are defined using the defmodule construct.
Syntax
(defmodule <module-name> [<comment>] 
   <port-spec>*)

<port-specification> ::= (export <port-item>) |
                         (import <module-name> <port-item>)
                
<port-item>          ::= ?ALL |
                         ?NONE |
                         <port-construct> ?ALL |
                         <port-construct> ?NONE |
                         <port-construct> <construct-name>+ 

<port-construct>     ::= deftemplate | defclass |
                         defglobal | deffunction |
                         defgeneric

A defmodule cannot be redefined or even deleted once it is defined (with the exception of the MAIN module which can be redefined once). The only way to delete a module is with the clear command. Upon startup and after a clear command, CLIPS automatically constructs the following defmodule.

(defmodule MAIN)

All of the predefined system classes (see section 9.2) belong to the MAIN module. However, it is not necessary to import or export the system classes; they are always in scope. Discounting the previous exception, the predefined MAIN module does not import or export any constructs. However, unlike other modules, the MAIN module can be redefined once after startup or a clear command.

Example
(defmodule FOO
   (import BAR ?ALL)
   (import YAK deftemplate ?ALL)
   (import GOZ defglobal x y z)
   (export defgeneric +)
   (export defclass ?ALL))
10.2 SPECIFYING A CONSTRUCT'S MODULE
The module in which a constructs is placed can be specified when the construct is defined. The deffacts, deftemplate, defrule, deffunction, defgeneric, defclass, and definstances constructs all specify the module for the construct by including it as part of the name. The module of a defglobal construct is indicated by specifying the module name after the defglobal keyword. The module of a defmessage-handler is specified as part of the class specifier. The module of a defmethod is specified as part of the generic function specifier. For example, the following constructs would be placed in the DETECTION module.

   (defrule DETECTION::Find-Fault
      (sensor (name ?name) (value bad))
      =>
      (assert (fault (name ?name))))

   (defglobal DETECTION ?*count* = 0)
 
   (defmessage-handler DETECTION::COMPONENT get-charge ()
	  (* ?self:flux ?self:flow))
	  
   (defmethod DETECTION::+ ((?x STRING) (?y STRING))
	  (str-cat ?x ?y))

Example
CLIPS> (clear)
CLIPS> (defmodule A)
CLIPS> (defmodule B)
CLIPS> (defrule foo =>)
CLIPS> (defrule A::bar =>)
CLIPS> (list-defrules)
bar
For a total of 1 defrule.
CLIPS> (set-current-module B)
A
CLIPS> (list-defrules)
foo
For a total of 1 defrule.
CLIPS>
10.3 SPECIFYING MODULES
Commands such as undefrule and ppdefrule require the name of a construct on which to operate. In previous versions of CLIPS, constructs were always referred to by their name only, so it was sufficient just to pass the name of the construct to these commands. With modules, however, it is possible to have a construct with the same name in two different modules. The modules associated with a name can be specified either explicitly or implicitly. To explicitly specify a name's module the module name (a symbol) is listed followed by two colons, ::, and then the name is listed. The module name followed by :: is referred to as a module specifier. For example, MAIN::find-stuff, refers to the find-stuff construct in the MAIN module. A module can also be implicitly specified since there is always a "current" module. The current module is changed whenever a defmodule construct is defined or the setcurrentmodule function is used. The MAIN module is automatically defined by CLIPS and by default is the current module when CLIPS is started or after a clear command is issued. Thus the name find-stuff would implicitly have the MAIN module as its module when CLIPS is first started.

CLIPS> (clear)
CLIPS> (defmodule A)
CLIPS> (defglobal A ?*x* = 0)
CLIPS> (defmodule B)
CLIPS> (defglobal B ?*y* = 1)
CLIPS> (ppdefglobal y)
(defglobal B ?*y* = 1)
CLIPS> (ppdefglobal B::y)
(defglobal B ?*y* = 1)
CLIPS> (ppdefglobal x)
[PRNTUTIL1] Unable to find defglobal x
CLIPS> (ppdefglobal A::x)
(defglobal A ?*x* = 0)
CLIPS>
10.4 IMPORTING AND EXPORTING CONSTRUCTS
Unless specifically exported and imported, the constructs of one module may not be used by another module. A construct is said to be visible or within scope of a module if that construct can be used by the module. For example, if module B wants to use the foo deftemplate defined in module A, then module A must export the foo deftemplate and module B must import the foo deftemplate from module A.

CLIPS> (clear)
CLIPS> (defmodule A)
CLIPS> (deftemplate A::foo (slot x))
CLIPS> (defmodule B)
CLIPS> (defrule B::bar (foo (x 3)) =>)

[PRNTUTIL2] Syntax Error:  Check appropriate syntax for defrule

ERROR:
(defrule B::bar
   (foo (
CLIPS> (clear)
CLIPS> (defmodule A (export deftemplate foo))
CLIPS> (deftemplate A::foo (slot x))
CLIPS> (defmodule B (import A deftemplate foo))
CLIPS> (defrule B::bar (foo (x 3)) =>)
CLIPS>

CLIPS will not allow a module or other construct to be defined that causes two constructs with the same name to be visible within the same module.
10.4.1 Exporting Constructs
The export specification in a defmodule definition is used to indicate which constructs will be accessible to other modules importing from the module being defined. Only deftemplates, defclasses, defglobals, deffunctions, and defgenerics may be exported. A module may export any valid constructs that are visible to it (not just constructs that it defines).

There are three different types of export specifications. First, a module may export all valid constructs that are visible to it. This accomplished by following the export keyword with the ?ALL keyword. Second, a module may export all valid constructs of a particular type that are visible to it. This accomplished by following the export keyword with the name of the construct type followed by the ?ALL keyword. Third, a module may export specific constructs of a particular type that are visible to it. This accomplished by following the export keyword with the name of the construct type followed by the name of one or more visible constructs of the specified type. In the following code, defmodule A exports all of its constructs; defmodule B exports all of its deftemplates; and defmodule C exports the foo, bar, and yak defglobals.

(defmodule A (export ?ALL))

(defmodule B (export deftemplate ?ALL))

(defmodule C (export defglobal foo bar yak))

The ?NONE keyword may be used in place of the ?ALL keyword to indicate either that no constructs are exported from a module or that no constructs of a particular type are exported from a module.

Defmethods and defmessage-handlers cannot be explicitly exported. Exporting a defgeneric automatically exports all associated defmethods. Exporting a defclass automatically exports all associated defmessage-handlers. Deffacts, definstances, and defrules cannot be exported.
10.4.2 Importing Constructs
The import specification in a defmodule definition is used to indicate which constructs the module being defined will use from other modules. Only deftemplates, defclasses, defglobals, deffunctions, and defgenerics may be imported.

There are three different types of import specifications. First, a module may import all valid constructs that are visible to a specified module. This accomplished by following the import keyword with a module name followed by the ?ALL keyword. Second, a module may import all valid constructs of a particular type that are visible to a specified module. This accomplished by following the import keyword with a module name followed by the name of the construct type followed by the ?ALL keyword. Third, a module may import specific constructs of a particular type that are visible to it. This accomplished by following the import keyword with a module name followed by the name of the construct type followed by the name of one or more visible constructs of the specified type. In the following code, defmodule A imports all of module D's constructs; defmodule B imports all of module D's deftemplates; and defmodule C imports the foo, bar, and yak defglobals from module D.

(defmodule A (import D ?ALL))

(defmodule B (import D deftemplate ?ALL))

(defmodule C (import D defglobal foo bar yak))

The ?NONE keyword may be used in place of the ?ALL keyword to indicate either that no constructs are imported from a module or that no constructs of a particular type are imported from a module.

Defmethods and defmessage-handlers cannot be explicitly imported. Importing a defgeneric automatically imports all associated defmethods. Importing a defclass automatically imports all associated defmessage-handlers. Deffacts, definstances, and defrules cannot be imported.

A module must be defined before it is used in an import specification. In addition, if specific constructs are listed in the import specification, they must already be defined in the module exporting them. It is not necessary to import a construct from the module in which it is defined in order to use it. A construct can be indirectly imported from a module that directly imports and then exports the module to be used.
10.5 IMPORTING AND EXPORTING FACTS AND INSTANCES
Facts and instances are "owned" by the module in which their corresponding deftemplate or defclass is defined, not by the module which creates them. Facts and instances are thus visible only to those modules which import the corresponding deftemplate or defclass. This allows a knowledge base to be partitioned such that rules and other constructs can only "see" those facts and instances which are of interest to them. Note that the initial-fact deftemplate and the INITIAL-OBJECT defclass must explicitly be imported from the MAIN module. Rules which have the initial-fact or initial-object pattern added to their LHS (such as a rule thats first CE is a not CE) will not be activated unless the corresponding construct for the pattern is imported.

Example
CLIPS> (clear)
CLIPS> (defmodule A (export deftemplate foo bar))
CLIPS> (deftemplate A::foo (slot x))
CLIPS> (deftemplate A::bar (slot y))
CLIPS> (deffacts A::info (foo (x 3)) (bar (y 4)))
CLIPS> (defmodule B (import A deftemplate foo))
CLIPS> (reset)
CLIPS> (facts A)
f-1     (foo (x 3))
f-2     (bar (y 4))
For a total of 2 facts.
CLIPS> (facts B)
f-1     (foo (x 3))
For a total of 1 fact.
CLIPS>
10.5.1 Specifying Instance-Names
Instance-names are required to be unique within a particular module, but multiple instances of the same name may be in scope at any one time. The syntax of instance-names has been extended to allow module specifications (note that the left and right brackets in bold are to be typed and do not indicate an optional part of the syntax).

Syntax
<instance-name> ::= [<symbol>] |
                    [::<symbol>] |
                    [<module>::symbol>] 

Specifying just a symbol as the instance-name, such as [Rolls-Royce], will search for the instance in the current module only. Specifying only the :: before the name, such as [::Rolls-Royce], will search for the instance first in the current module and then recursively in the imported modules as defined in the module definition. Specifying both a symbol and a module name, such as [CARS::Rolls-Royce], searches for the instance only in the specified module. Regardless of which format is specified, the class of the instance must be in scope of the current module in order for the instance to be found.
10.6 MODULES AND RULE EXECUTION
Each module has its own pattern-matching network for its rules and its own agenda. When a run command is given, the agenda of the module which is the current focus is executed (note that the reset and clear commands make the MAIN module the current focus). Rule execution continues until another module becomes the current focus, no rules are left on the agenda, or the return function is used from the RHS of a rule. Whenever a module that was focused on runs out of rules on its agenda, the current focus is removed from the focus stack and the next module on the focus stack becomes the current focus. Before a rule executes, the current module is changed to the module in which the executing rule is defined (the current focus). The current focus can be changed by using the focus command. See sections 5.2, 5.4.10.2, 12.12, and 13.12 for more details. 

Example
CLIPS> (clear)
CLIPS> (defmodule MAIN (export ?ALL))
CLIPS> 
(defrule MAIN::focus-example
  =>
  (printout t "Firing rule in module MAIN." crlf)
  (focus A B))
CLIPS> 
(defmodule A (import MAIN deftemplate initial-fact))
CLIPS> 
(defrule A::example-rule
  =>
  (printout t "Firing rule in module A." crlf))
CLIPS> 
(defmodule B (import MAIN deftemplate initial-fact))
CLIPS> 
(defrule B::example-rule
  =>
  (printout t "Firing rule in module B." crlf))
CLIPS> (reset)
CLIPS> (run)
Firing rule in module MAIN.
Firing rule in module A.
Firing rule in module B.
CLIPS>



Section 11 - Constraint Attributes
This section describes the constraint attributes that can be associated with deftemplates and defclasses so that type checking can be performed on slot values when template facts and instances are created. The constraint information is also analyzed for the patterns on the LHS of a rule to determine if the specified constraints prevent the rule from ever firing.

Two types of constraint checking are supported: static and dynamic. When static constraint checking is enabled, constraint violations are checked when function calls and constructs are parsed.  This includes constraint checking  between patterns on the LHS of a rule when variables are used in more than one slot. When dynamic constraint checking is enabled, newly created data objects (such as deftemplate facts and instances) have their slot values checked for constraint violations. Essentially, static constraint checking occurs when a CLIPS program is loaded and dynamic constraint checking occurs when a CLIPS program is running. By default, static constraint checking is enabled and dynamic constraint checking is disabled. The default behavior can be changed by using the setstaticconstraintchecking and setdynamicconstraintchecking functions.

Unless dynamic constraint checking is enabled, constraint information associated with constructs is not saved when a binary image is created using the bsave command.

The general syntax for constraint attributes is shown following.
Syntax
<constraint-attribute> ::= <type-attribute> |
                           <allowed-constant-attribute> |
                           <range-attribute> |
                           <cardinality-attribute> 
11.1 TYPE ATTRIBUTE
The type attribute allows the types of values to be stored in a slot to be restricted.
Syntax
<type-attribute>     ::= (type <type-specification>)

<type-specification> ::= <allowed-type>+ | ?VARIABLE

<allowed-type> 
              ::= SYMBOL | STRING | LEXEME |
                  INTEGER | FLOAT | NUMBER | 
                  INSTANCE-NAME | INSTANCE-ADDRESS | INSTANCE |
                  EXTERNAL-ADDRESS | FACT-ADDRESS

Using NUMBER for this attribute is equivalent to using both INTEGER and FLOAT. Using LEXEME for this attribute is equivalent to using both SYMBOL and STRING. Using INSTANCE for this attribute is equivalent to using both INSTANCE-NAME and INSTANCE-ADDRESS. ?VARIABLE allows any type to be stored.
11.2 ALLOWED CONSTANT ATTRIBUTES
The allowed constant attributes allow the constant values of a specific type which can be stored in a slot to be restricted. The list of values provided should either be a list of constants of the specified type or the keyword ?VARIABLE which means any constant of that type is allowed. The allowed-values attribute allows the slot to be restricted to a specific set of values (encompassing all types). Note the difference between using the attribute (allowed-symbols red green blue) and (allowed-values red green blue). The allowed-symbols attribute states that if the value is of type symbol, then its value must be one of the listed symbols. The allowed-values attribute completely restricts the allowed values to the listed values.
Syntax
<allowed-constant-attribute> 
               ::= (allowed-symbols <symbol-list>) |
                   (allowed-strings <string-list>) |
                   (allowed-lexemes <lexeme-list> |
                   (allowed-integers <integer-list>) |
                   (allowed-floats <float-list>) |
                   (allowed-numbers <number-list>) |
                   (allowed-instance-names <instance-list>) |
                   (allowed-values <value-list>)

<symbol-list>  ::= <symbol>+ | ?VARIABLE

<string-list>  ::= <string>+ | ?VARIABLE

<lexeme-list>  ::= <lexeme>+ | ?VARIABLE

<integer-list> ::= <integer>+ | ?VARIABLE

<float-list>   ::= <float>+ | ?VARIABLE

<number-list>  ::= <number>+ | ?VARIABLE

<instance-name-list>  ::= <instance-name>+ | ?VARIABLE

<value-list>   ::= <constant>+ | ?VARIABLE

Specifying the allowed-lexemes attribute is equivalent to specifying constant restrictions on both symbols and strings. A string or symbol must match one of the constants in the attribute list. Type conversion from symbols to strings and strings to symbols is not performed. Similarly, specifying the allowed-numbers attribute is equivalent to specifying constant restrictions on both integers and floats. In CLIPS 5.1, type conversion of integers to floats and floats to integers was performed when using the allowed-numbers attribute (thus using allowed-numbers was not equivalent to using both the allowed-integers and allowed-floats attributes together). In CLIPS 6.0, this type conversion is now longer performed. The allowedinstances attribute found in CLIPS 5.1 is no longer supported. The allowedinstancenames attribute should be used in its place.
11.3 RANGE ATTRIBUTE
The range attribute allows a numeric range to be specified for a slot when a numeric value is used in that slot. If a numeric value is not used in that slot, then no checking is performed.
Syntax
<range-attribute>     ::= (range <range-specification> 
                                 <range-specification>)

<range-specification> ::= <number> | ?VARIABLE

Either integers or floats can be used in the range specification with the first value to the range attribute signifying the minimum allowed value and the second value signifying the maximum value. Integers will be temporarily converted to floats when necessary to perform range comparisons. If the keyword ?VARIABLE is used for the minimum value, then the minimum value is negative infinity (-_). If the keyword ?VARIABLE is used for the maximum value, then the maximum value is positive infinity (+_). The range attribute cannot be used in conjunction with the allowed-values, allowed-numbers, allowed-integers, or allowed-floats attributes.
11.4 CARDINALITY ATTRIBUTE
The cardinality attribute restricts the number of fields which can be stored in a multifield slot. This attribute can not be used with a single field slot. 
Syntax
<cardinality-attribute>    
                  ::= (cardinality <cardinality-specification> 
                                   <cardinality-specification>)

<cardinality-specification> ::= <integer> | ?VARIABLE

Only integers can be used in the cardinality specification with the first value to the cardinality attribute signifying the minimum number of fields which can be stored in the slot and the second value signifying the maximum number of fields which can be stored in the slot. If the keyword ?VARIABLE is used for the minimum value, then the minimum cardinality is zero. If the keyword ?VARIABLE is used for the maximum value, then the maximum cardinality is positive infinity (+_). If the cardinality is not specified for a multifield slot, then it is assumed to be zero to infinity. 

The minnumberofelements and maxnumberofelements attributes found in CLIPS 5.1 are no longer supported. The cardinality attribute should be used in their place.
11.5 DERIVING A DEFAULT VALUE FROM CONSTRAINTS
Default values for deftemplate and instance slots are automatically derived from the constraints for the slots if an explicit default value is not specified. The following rules are used (in order) to determine the default value for a slot with an unspecified default value. 
    
1)	The default type for the slot is chosen from the list of allowed types for the slot in the following order of precedence: SYMBOL, STRING, INTEGER, FLOAT, INSTANCE-NAME, INSTANCE-ADDRESS, FACT-ADDRESS, EXTERNAL-ADDRESS. 
                      
2)	If the default type has an allowed constant restriction specified (such as the allowed-integers attribute for the INTEGER type), then the first value specified in the allowed constant attribute is chosen as the default value.

3)	If the default value was not specified by step 2 and the default type is INTEGER or FLOAT and the range attribute is specified, then the minimum range value is used as the default value if it is not ?VARIABLE, otherwise, the maximum range value is used if it is not ?VARIABLE.

4)	If the default value was not specified by step 2 or 3, then the default default value is used. This value is nil for  type SYMBOL, "" for type STRING, 0 for type INTEGER, 0.0 for type FLOAT, [nil] for type INSTANCE-NAME, a pointer to a dummy instance for type INSTANCE-ADDRESS, a pointer to a dummy fact for type FACT-ADDRESS, and the NULL pointer for type EXTERNAL-ADDRESS.

5)	If the default value is being derived for a single field slot, then the default value derived from steps 1 through 4 is used. The default value for a multifield slot is a multifield value of length zero. However, if the multifield slot has a minimum cardinality greater than zero, then a multifield value with a length of the minimum cardinality is created and the default value which would be used for a single field slot is stored in each field of the multifield value.
11.6 CONSTRAINT VIOLATION EXAMPLES
The following examples illustrate some of the types of constraint violations that CLIPS can detect.
Example 1
CLIPS> 
(deftemplate bar 
   (slot a (type SYMBOL INTEGER))
   (slot b (type INTEGER FLOAT))
   (slot c (type SYMBOL STRING))) 
CLIPS> 
(defrule error
  (bar (a ?x))
  (bar (b ?x))
  (bar (c ?x))
  =>)

[RULECSTR1] Variable ?x in CE #3 slot c
has constraint conflicts which make the pattern unmatchable

ERROR:
(defrule error-4
   (bar (a ?x))
   (bar (b ?x))
   (bar (c ?x))
   =>)
CLIPS>

The first occurrence of the variable ?x in slot a of the first pattern restricts its allowed types to either a symbol or integer. The second occurrence of ?x in slot b of the second pattern further restricts its allowed types to only integers. The final occurence of ?x in the third pattern generates an error because slot c expects ?x to be either a symbol of a string, but its only allowed type is an integer.
Example 2
CLIPS> 
(deftemplate foo (multislot x (cardinality ?VARIABLE 3)))
CLIPS> 
(deftemplate bar (multislot y (cardinality ?VARIABLE 2)))
CLIPS> 
(deftemplate woz (multislot z (cardinality 7 ?VARIABLE)))
CLIPS> 
(defrule error
   (foo (x $?x))
   (bar (y $?y))
   (woz (z $?x $?y))
   =>)

[CSTRNCHK1] The group of restrictions found in CE #3
do not satisfy the cardinality restrictions for slot z

ERROR:
(defrule error
   (foo (x $?x))
   (bar (y $?y))
   (woz (z $?x $?y))
   =>)
CLIPS> 

The variable ?x, found in the first pattern, can have a maximum of  two fields. The variable ?y, found  in the second pattern, can have a maximum of three fields. Added together, both variables have a maximum of five fields. Since slot z in the the third pattern has a minimum cardinality of seven, the variables ?x and ?y cannot satisfy the minimum cardinality restriction for this slot.
Example 3
CLIPS> (deftemplate foo (slot x (type SYMBOL)))
CLIPS> 
(defrule error
   (foo (x ?x))
   (test (> ?x 10))
   =>)

[RULECSTR2] Previous variable bindings of ?x caused the type restrictions for argument #1 of the expression (> ?x 10)
found in CE #2 to be violated

ERROR:
(defrule error
   (foo (x ?x))
   (test (> ?x 10))
   =>)
CLIPS>

The variable ?x, found in slot x of the first pattern, must be a symbol. Since the > function expects numeric values for its arguments, an error occurs.

Section 12 - Actions And Functions
This section describes various actions and functions which may be used on the LHS and RHS of rules, from the top-level command prompt, and from other constructs such as deffunctions, defmessage-handlers, and defmethods. The terms functions, actions, and commands should be thought of interchangeably. However, when the term function is used it generally refers to a function which returns a value. The term action refers to a function having no return value but performing some basic operation as a side effect (such as printout). The term command refers to functions normally entered at the top-level command prompt (such as the reset command, which does not return a value, and the setstrategy command, which does return a value).
12.1 PREDICATE FUNCTIONS
The following functions perform predicate tests.
12.1.1 Testing For Numbers
The numberp function returns the symbol TRUE if its argument is a float or integer, otherwise it returns the symbol FALSE.
Syntax
(numberp <expression>)
12.1.2 Testing For Floats
The floatp function returns the symbol TRUE if its argument is a float, otherwise it returns the symbol FALSE.
Syntax
(floatp <expression>)
12.1.3 Testing For Integers
The integerp function returns the symbol TRUE if its argument is an integer, otherwise it returns the symbol FALSE.
Syntax
(integerp <expression>)
12.1.4 Testing For Strings Or Symbols
The lexemep function returns the symbol TRUE if its argument is a string or symbol, otherwise it returns the symbol FALSE.
Syntax
(lexemep <expression>)
12.1.5 Testing For Strings
The stringp function returns the symbol TRUE if its argument is a string, otherwise it returns the symbol FALSE.
Syntax
(stringp <expression>)
12.1.6 Testing For Symbols
The symbolp function returns the symbol TRUE if its argument is a symbol, otherwise it returns the symbol FALSE. This function may also be called using the name wordp.
Syntax
(symbolp <expression>)
12.1.7 Testing For Even Numbers
The evenp function returns the symbol TRUE if its argument is an even number, otherwise it returns the symbol FALSE.
Syntax
(evenp <expression>)
12.1.8 Testing For Odd Numbers
The oddp function returns the symbol TRUE if its argument is an odd number, otherwise it returns the symbol FALSE.
Syntax
(oddp <expression>)
12.1.9 Testing For Multifield Values
The multifieldp function returns the symbol TRUE if its argument is a multifield value, otherwise it returns the symbol FALSE. This function may also be called using the name sequencep.
Syntax
(multifieldp <expression>)
12.1.10 Testing For External-Addresses
The pointerp function returns the symbol TRUE if its argument is an external-address, otherwise it returns the symbol FALSE. External-address;es are discussed in further detail in the Advanced Programming Guide. 
Syntax
(pointerp <expression>)
12.1.11 Comparing for Equality
The eq function returns the symbol TRUE if its first argument is equal in value to all its subsequent arguments, otherwise it returns the symbol FALSE. Note that eq compares types as well as values. Thus, (eq 3 3.0) is FALSE since 3 is an integer and 3.0 is a float. 
Syntax
(eq <expression> <expression>+)
Example
CLIPS> (eq foo bar mumble foo)
FALSE
CLIPS> (eq foo foo foo foo)
TRUE
CLIPS> (eq 3 4)
FALSE
CLIPS>
12.1.12 Comparing for Inequality
The neq function returns the symbol TRUE if its first argument is not equal in value to all its subsequent arguments, otherwise it returns the symbol FALSE. Note that neq compares types as well as values. Thus, (neq 3 3.0) is TRUE since 3 is an integer and 3.0 is a float. 
Syntax
(neq <expression> <expression>+)
Example
CLIPS> (neq foo bar yak bar)
TRUE
CLIPS> (neq foo foo yak bar)
FALSE
CLIPS> (neq 3 a)
TRUE
CLIPS>
12.1.13 Comparing Numbers for Equality
The = function returns the symbol TRUE if its first argument is equal in value to all its subsequent arguments, otherwise it returns the symbol FALSE. Note that = compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(= <numeric-expression> <numeric-expression>+)
Example
CLIPS> (= 3 3.0)
TRUE
CLIPS> (= 4 4.1)
FALSE
CLIPS>
	
Portability Note
Because the precision of floating point numbers varies from one machine to another, it is possible for the numeric comparison functions to work correctly one machine and incorrectly on another. In fact, you should be aware, even if code is not being ported, that roundoff error can cause erroneous results. For example, the following expression erroneously returns the symbol TRUE because both numbers are rounded up to 0.6666666666666666667.

CLIPS> (= 0.66666666666666666666 0.66666666666666666667)
TRUE
CLIPS>
12.1.14 Comparing Numbers for Inequality
The <> function returns the symbol TRUE if its first argument is not equal in value to all its subsequent arguments, otherwise it returns the symbol FALSE. Note that <> compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(<> <numeric-expression> <numeric-expression>+)
Example
CLIPS> (<> 3 3.0)
FALSE
CLIPS> (<> 4 4.1)
TRUE
CLIPS>
	
Portability Note
See portability note in section 12.1.13.
12.1.15 Greater Than Comparison
The > function returns the symbol TRUE if for all its arguments, argument n-1 is greater than argument n, otherwise it returns the symbol FALSE. Note that > compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(> <numeric-expression> <numeric-expression>+)
Example
CLIPS> (> 5 4 3)
TRUE
CLIPS> (> 5 3 4)
FALSE
CLIPS>
	
Portability Note
See portability note in section 12.1.13.
12.1.16 Greater Than or Equal Comparison
The >= function returns the symbol TRUE if for all its arguments, argument n-1 is greater than or equal to argument n, otherwise it returns the symbol FALSE. Note that >= compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(>= <numeric-expression> <numeric-expression>+)
Example
CLIPS> (>= 5 5 3)
TRUE
CLIPS> (>= 5 3 5)
FALSE
CLIPS>
	
Portability Note
See portability note in section 12.1.13.
12.1.17 Less Than Comparison
The < function returns the symbol TRUE if for all its arguments, argument n-1 is less than argument n, otherwise it returns the symbol FALSE. Note that < compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(< <numeric-expression> <numeric-expression>+)
Example
CLIPS> (< 3 4 5)
TRUE
CLIPS> (< 3 5 4)
FALSE
CLIPS>
	
Portability Note
See portability note in section 12.1.13.
12.1.18 Less Than or Equal Comparison
The <= function returns the symbol TRUE if for all its arguments, argument n-1 is less than or equal to argument n, otherwise it returns the symbol FALSE. Note that <= compares only numeric values and will convert integers to floats when necessary for comparison. 
Syntax
(<= <numeric-expression> <numeric-expression>+)
Example
CLIPS> (<= 3 5 5)
TRUE
CLIPS> (<= 5 3 5)
FALSE
CLIPS>
	
Portability Note
See portability note in section 12.1.13.
12.1.19 Boolean And
The and function returns the symbol TRUE if each of its arguments evaluates to TRUE,  otherwise it returns the symbol FALSE. The and function performs short-circuited boolean logic. Each argument of the function is evaluated from left to right. If any argument evaluates to FALSE, then the symbol FALSE is immediately returned by the function. 
Syntax
(and <expression>+)
12.1.20 Boolean Or
The or function returns the symbol TRUE if any of its arguments evaluates to TRUE,  otherwise it returns the symbol FALSE. The or function performs short-circuited boolean logic. Each argument of the function is evaluated from left to right. If any argument evaluates to TRUE, then the symbol TRUE is immediately returned by the function. 
Syntax
(or <expression>+)
12.1.21 Boolean Not
The not function returns the symbol TRUE if its argument evaluates to FALSE,  otherwise it returns the symbol FALSE.
Syntax
(not <expression>)
12.2 MULTIFIELD FUNCTIONS
The following functions operate on multifield values.
12.2.1 Creating Multifield Values
This function appends any number of fields together to create a multifield value.
Syntax
	(create$ <expression>*)

The return value of create$ is a multifield value regardless of the number or types of arguments (single-field or multifield). Calling create$ with no arguments creates a multifield value of length zero. This function may also be called using the name create$.
Example
CLIPS (create$ hammer drill saw screw pliers wrench)
(hammer drill saw screw pliers wrench)
CLIPS> (create$ (+ 3 4) (* 2 3) (/ 8 4))
(7 6 2)
CLIPS>
12.2.2 Specifying an Element
The nth$ function will return a specified field from a multifield value.
Syntax
	(nth$ <integer-expression> <multifield-expression>)

where the first argument should be an integer from 1 to the number of elements within the second argument. The symbol nil will be returned if the first argument is greater than the number of fields in the second argument.
Example
CLIPS> (nth$ 3 (create$ a b c d e f g))
c
CLIPS>
12.2.3 Finding an Element
The member$ function will tell if a single field value is contained in a multifield value.
Syntax
(member$ <single-field-expression> <multifield-expression>)

If the first argument is one of the fields within the second argument, member$ will return the integer position of the field (from 1 to the length of the second argument). Otherwise, it will return FALSE.
Example
CLIPS> (member$ blue (create$ red 3 "text" 8.7 blue))
5
CLIPS> (member$ 4 (create$ red 3 "text" 8.7 blue))
FALSE
CLIPS>
12.2.4 Comparing Multifield Values
This function checks if one multifield value is a subset of another; i.e., if all the fields in the first multifield value are also in the second multifield value.
Syntax
(subsetp <multifield-expression> <multifield-expression>)

If the first argument is a subset of the second argument, the function returns TRUE; otherwise, it returns FALSE. The order of the fields is not considered. If the first argument is bound to a multifield of length zero, the subsetp function always returns TRUE.
Example
CLIPS> (subsetp (create$ hammer saw drill)
                (create$ hammer drill wrench pliers saw))
TRUE
CLIPS> (subsetp (create$ wrench crowbar)
                (create$ hammer drill wrench pliers saw))
FALSE
CLIPS>
12.2.5 Deletion of Fields in Multifield Values
This function deletes the specified range from a multifield value.
Syntax
(delete$ <multifield-expression> 
              <begin-integer-expression>
              <end-integer-expression>)

The modified multifield value is returned, which is the same as <multifield-expression> with the fields ranging from <begin-integer-expression> to <end-integer-expression> removed. To delete a single field, the begin range field should equal the end range field.
Example
CLIPS> (delete$ (create$ hammer drill saw pliers wrench) 3 4)    
(hammer drill wrench)
CLIPS> (delete$ (create$ computer printer hard-disk) 1 1)    
(printer hard-disk)
CLIPS>
12.2.6 Creating Multifield Values from Strings.
This function constructs a multifield value from a string by using each field in a string as a field in a new multifield value.
Syntax
(explode$ <string-expression>)

A new multifield value is created in which each delimited field in order in <string-expression> is taken to be a field in the new multifield value which is returned. A string with no fields creates a multifield value of length zero. Fields other than symbols, strings, integer, floats, or instances names (such as parentheses or variables) are converted to strings.
Example

CLIPS> (explode$ "hammer drill saw screw")
(hammer drill saw screw)
CLIPS> (explode$ "1 2 abc 3 4 \"abc\"  \"def\"")
(1 2 abc 3 4 "abc" "def")
CLIPS> (explode$ "?x ~ )")
("?x" "~" ")")
CLIPS>
12.2.7 Creating Strings from Multifield Values
This function creates a single string from a multifield value.
Syntax
(implode$ <multifield-expression>)

Each field in <multifield-expression> in order is concatenated into a string value with a single blank separating fields. The new string is returned.
Example
CLIPS> (implode$ (create$ hammer drill screwdriver))
"hammer drill screwdriver wrench pliers saw"
CLIPS> (implode$ (create$ 1 "abc" def "ghi" 2))
"1 "abc" def "ghi" 2"
CLIPS> (implode$ (create$ "abc       def         ghi"))
"abc def ghi"
CLIPS>
12.2.8 Extracting a Sub-sequence from a Multifield Value
This function extracts a specified range from a multifield value and returns a new multifield value containing just the sub-sequence.
Syntax
(subseq$ <multifield-value> 
              <begin-integer-expression> 
              <end-integer-expression>)

where the second and third arguments are integers specifying the begin and end fields of the desired sub-sequence in <multifield-expression>.
Example
CLIPS> (subseq$ (create$ hammer drill wrench pliers) 3 4)
(wrench pliers)
CLIPS> (subseq$ (create$ 1 "abc" def "ghi" 2) 1 1)
(1)
CLIPS>
12.2.9 Replacing Fields within a Multifield Value
This function replaces a range of field in a multifield value with a series of single-field and/or multifield values and returns a new multifield value containing the replacement values within the original multifield value.
Syntax
(replace$ <multifield-expression> 
               <begin-integer-expression> 
               <end-integer-expression> 
               <single-or-multi-field-expression>+)

where <begin-integer-expression> to <end-integer-expression> is the range of values to be replaced.
Example
CLIPS> (replace$ (create$ drill wrench pliers) 3 3 machete)
(drill wrench machete)
CLIPS> (replace$ (create$ a b c d) 2 3 x y (create$ q r s))
(a x y q r s d)
CLIPS>
12.2.10 Inserting Fields within a Multifield Value
This function inserts a series of single-field and/or multifield values at a specified location in a multifield value with and returns a new multifield value containing the inserted values within the original multifield value.
Syntax
(insert$ <multifield-expression> 
               <integer-expression>
               <single-or-multi-field-expression>+)

where <integer-expression> is the location where the values are to be inserted. This value must be greater than or equal to 1. A value of 1 inserts the new value(s) at the beginning of the <multifield-expression>. Any value greater than the length of the <multifield-expression> appends the new values to the end of the <multifield-expression>.
Example
CLIPS> (insert$ (create$ a b c d) 1 x)
(x a b c d)
CLIPS> (insert$ (create$ a b c d) 4 y z)
(a b c y z d)
CLIPS> (insert$ (create$ a b c d) 5 (create$ q r))
(a b c d q r)
CLIPS>

12.2.11 Getting the First Field from a Multifield Value
This function returns the first field of a multifield value as a multifield value
Syntax
(first$ <multifield-expression>)
Example
CLIPS> (first$ (create$ a b c))
(a)
CLIPS> (first$ (create$))
()
CLIPS>
12.2.12 Getting All but the First Field from a Multifield Value
This function returns all but the first field of a multifield value as a multifield value.
Syntax
(rest$ <multifield-expression>)
Example
CLIPS> (rest$ (create$ a b c))
(b c)
CLIPS> (rest$ (create$))
()
CLIPS>
12.3 STRING FUNCTIONS
The following functions perform operations that are related to strings.
12.3.1 String Concatenation
The strcat function will concatenates its arguments into a single string.
Syntax
(str-cat <expression>*)

Each <expression> should be one of the following types: symbol, string, float, integer, or instance-name.
Example
CLIPS> (str-cat "foo" bar)
"foobar"
CLIPS>
12.3.2 Symbol Concatenation
The symcat function will concatenate its arguments into a single symbol. It is functionally identical to the str-cat function with the exception that the returned value is a symbol and not a string.
Syntax
(sym-cat <expression>*)

Each <expression> should be one of the following types: symbol, string, float, integer, or instance-name.
12.3.3 Taking a String Apart
The substring function will retrieve a portion of a string from another string.
Syntax
(sub-string <integer-expression> <integer-expression> 
            <string-expression>)

where the first argument, counting from one, must be a number marking the beginning position in the string and the second argument must be a number marking the ending position in the string. If the first argument is greater than or equal to the second argument, a null string is returned.
Example
CLIPS> (sub-string 3 8 "abcdefghijkl")
"cdefgh"
CLIPS>
12.3.4 Searching a String
The strindex function will return the position of a string inside another string.
Syntax
(str-index  <lexeme-expression> <lexeme-expression>)

where the second argument is searched for the first occurrence of the first argument. The str-index function returns the integer starting position, counting from one, of the first argument in the second argument or returns the symbol FALSE if not found.
Example
CLIPS> (str-index "def" "abcdefghi")
4
CLIPS> (str-index "qwerty" "qwertypoiuyt")
1
CLIPS> (str-index "qwerty" "poiuytqwer")
FALSE
CLIPS>
12.3.5 Evaluating a Function within a String
The eval function evaluates the string as though it were entered at the command prompt.
Syntax
(eval  <string-or-symbol-expression>)

where the only argument is the command, constant, or global variable to be executed. NOTE: eval does not permit the use of local variables (except when the local variables are defined as part of the command such as with an instance query function), nor will it evaluate any of the construct definition forms (i.e., defrule, deffacts, etc.;). The return value is the result of the evaluation of the string (or FALSE if an error occurs).

The eval function is not available for binary-load only or run-time CLIPS configurations (see the Advanced Programming Guide).
Example
CLIPS> (eval "(+ 3 4)")
7
CLIPS> (eval "(create$ a b c)")
(a b c)
CLIPS>
12.3.6 Evaluating a Construct within a String
The build function evaluates the string as though it were entered at the command prompt.
Syntax
(build  <string-or-symbol-expression>)

where the only argument is the construct to be added. The return value is TRUE if the construct was added (or FALSE if an error occurs).

The build function is not available for binary-load only or run-time CLIPS configurations (see the Advanced Programming Guide).
Example
CLIPS> (clear)
CLIPS> (build "(defrule foo (a) => (assert (b)))")
TRUE
CLIPS> (rules)
foo
For a total of 1 rule.
CLIPS>    
12.3.7 Converting a String to Uppercase
The upcase function will return a string or symbol with uppercase alphabetic characters.
Syntax
(upcase <string-or-symbol-expression>)
Example
CLIPS> (upcase "This is a test of upcase")  
"THIS IS A TEST OF UPCASE"
CLIPS> (upcase A_Word_Test_for_Upcase)
A_WORD_TEST_FOR_UPCASE
CLIPS>
12.3.8 Converting a String to Lowercase
The lowcase function will return a string or symbol with lowercase alphabetic characters.
Syntax
(lowcase <string-or-symbol-expression>)
Example
CLIPS> (lowcase "This is a test of lowcase")  
"this is a test of lowcase"
CLIPS> (lowcase A_Word_Test_for_Lowcase)   
a_word_test_for_lowcase
CLIPS>
12.3.9 Comparing Two Strings
The strcompare function will compare two strings to determine their logical relationship (i.e., equal to, less than, greater than). The comparison is performed character-by-character until the strings are exhausted (implying equal strings) or unequal characters are found. The positions of the unequal characters within the ASCII character set are used to determine the logical relationship of unequal strings.
Syntax
(str-compare <string-or-symbol-expression> 
             <string-or-symbol-expression>)

This function returns an integer representing the result of the comparison (0 if the strings are equal, < 0 if the first argument < the second argument, and > 0 if the first argument > the second argument).
Example
CLIPS> (< (str-compare "string1" "string2") 0)
TRUE   ; since "1" < "2" in ASCII character set
CLIPS> (str-compare "abcd" "abcd")   
0
CLIPS>
12.3.10 Determining the Length of a String
The strlength function returns the length of a string as an integer.
Syntax
(str-length <string-or-symbol-expression>)
Example
CLIPS> (str-length "abcd")  
4
CLIPS> (str-length xyz)   
3
CLIPS>
12.4 THE CLIPS I/O SYSTEM
CLIPS uses a system called I/O routers to provide very flexible I/O while remaining portable. A more complete discussion of I/O routers is covered in the Advanced Programming Guide.
12.4.1 Logical Names
One of the key concepts of I/O routing is the use of logical names. Logical names allow reference to an I/O device without having to understand the details of the implementation of the reference. Many functions in CLIPS make use of logical names. A logical name can be either a symbol, a number, or a string. Several logical names are predefined by CLIPS and are used extensively throughout the CLIPS code. These are

Name	Description
stdin	The default for all user inputs. The read and readline functions read from stdin if t is specified as the logical name.

stdout	The default for all user outputs. The format and printout functions send output to stdout if t is specified as the logical name.

wclips	The CLIPS prompt is sent to this logical name.

wdialog	All informational messages are sent to this logical name.

wdisplay	Requests to display CLIPS information, such as facts or rules, are sent to this logical name.

werror	All error messages are sent to this logical name.

wwarning	All warning messages are sent to this logical name.

wtrace	All watch information is sent to this logical name (with the exception of compilations which is sent to wdialog).

Any of these logical names may be used anywhere a logical name is expected.
12.4.2 Common I/O Functions
CLIPS provides some of the most commonly needed I/O capabilities through several predefined functions.
12.4.2.1 Open
The open function allows a user to open a file from the RHS of a rule and attaches a logical name to it. This function takes three arguments: (1) the name of the file to be opened; (2) the logical name which will be used by other CLIPS I/O functions to access the file; and (3) an optional mode specifier. The mode specifier must be one of the following strings:

	Mode	Means
"r"	read access only
"w"	write access only
"r+"	read and write access
"a"	append access only

If the mode is not specified, a default of read access only is assumed. The access mode may not be meaningful in some operating systems.
Syntax
(open <file-name> <logical-name> [<mode>])

The <file-name> must either be a string or symbol and may include directory specifiers. If a string is used, the backslash (\) and any other special characters that are part of <file-name> must be escaped with a backslash. The logical name should not have been used previously. The open function returns TRUE if it was successful, otherwise FALSE.
Example
CLIPS> (open "myfile.clp" writeFile "w")
TRUE
CLIPS> (open "MS-DOS\\directory\\file.clp" readFile)
TRUE
CLIPS>
12.4.2.2 Close
The close function closes a file stream previously opened with the open command. The file is specified by a logical name previously attached to the desired stream.
Syntax
(close [<logical-name>])

If close is called without arguments, all open files will be closed. The user is responsible for closing all files opened during execution. If files are not closed, the contents are not guaranteed correct, however, CLIPS will attempt to close all open files when the exit command is executed. The close function returns TRUE if any files were successfully closed, otherwise FALSE.
Example
CLIPS> (open "myfile.clp" writeFile "w")
TRUE
CLIPS> (open "MS-DOS\\directory\\file.clp" readFile)
TRUE
CLIPS> (close writeFile)
TRUE
CLIPS> (close writeFile)
FALSE
CLIPS> (close)
TRUE
CLIPS> (close)
FALSE
CLIPS>
12.4.2.3 Printout
The function printout allows output to a device attached to a logical name. The logical name must be specified and the device must have been prepared previously for output (e.g., a file must be opened first). To send output to stdout, use a t for the logical name. 
Syntax
(printout <logical-name> <expression>*)

Any number of expressions may be placed in a printout to be printed. Each expression is evaluated and printed (with no spaces added between each printed expression). The symbol crlf used as an <expression> will force a carriage return/newline and may be placed anywhere in the list of expressions to be printed. The printout function strips quotation marks from around strings when it prints them. Factaddresses, instanceaddresses and externaladdresses can be printed by the printout function. This function has no return value.
Example
CLIPS> (printout t "Hello there!" crlf)
Hello There!
CLIPS> (open "data.txt" mydata "w")
TRUE
CLIPS> (printout mydata "red green")
CLIPS> (close)
TRUE
CLIPS>
12.4.2.4 Read
The read function allows a user to input information for a single field. All of the standard field rules (e.g., multiple symbols must be embedded within quotes) apply.
Syntax
(read [<logical-name>])

where <logical-name> is an optional parameter. If specified, read tries to read from whatever is attached to the logical file name. If <logical-name> is t or is not specified, the function will read from stdin. All the delimiters defined in section 2.3.1 can be used as delimiters. The read function always returns a primitive data type. Spaces, carriage returns, and tabs only act as delimiters and are not contained within the return value (unless these characters are included within double quotes as part of a string). If an end of file (EOF) is encountered while reading, read will return the symbol EOF. If errors are encountered while reading, the string "*** READ ERROR ***" will be returned.
Example
CLIPS> (open "data.txt" mydata "w")
TRUE
CLIPS> (printout mydata "red green")
CLIPS> (close)
TRUE
CLIPS> (open "data.txt" mydata)
TRUE
CLIPS> (read mydata)
red
CLIPS> (read mydata)
green
CLIPS> (read mydata)
EOF
CLIPS> (close)
TRUE
CLIPS>
12.4.2.5 Readline
The readline function is similar to the read function, but it allows a whole string to be input instead of a single field. Normally, read will stop when it encounters a delimiter. The  readline function only stops when it encounters a carriage return, a semicolon, or an EOF. Any tabs or spaces in the input are returned by readline as a part of the string. The readline function returns a string.
Syntax
(readline [<logical-name>])

where <logical-name> is an optional parameter. If specified, readline tries to read from whatever is attached to the logical file name. If <logical-name> is t or is not specified, the function will read from stdin. As with the read function, if an EOF is encountered, readline will return the symbol EOF. If an error is encountered during input, readline returns the string "*** READ ERROR ***".
Example
CLIPS> (open "data.txt" mydata "w")
TRUE
CLIPS> (printout mydata "red green")
CLIPS> (close)
TRUE
CLIPS> (open "data.txt" mydata)
TRUE
CLIPS> (readline mydata)
"red green"
CLIPS> (readline mydata)
EOF
CLIPS> (close)
TRUE
CLIPS>
12.4.2.6 Format
The format function allows a user to send formatted output to a device attached to a logical name. It can be used in place of printout when special formatting of output information is desired. Although a slightly more complicated function, format provides much better control over how the output is formatted. The format commands are similar to the printf statement in C. The format function always returns a string containing the formatted output. A logical name of nil may be used when the formatted return string is desired without writing to a device.
Syntax
(format <logical-name> <string-expression> <expression>*)

If t is given, output is sent to stdout. The second argument to format, called the control string, specifies how the output should be formatted. Subsequent arguments to format (the parameter list for the control string) are the expressions which are to be output as indicated by the control string. Format currently does not allow expressions returning multifield values to be included in the parameter list.

The control string consists of text and format flags. Text is output exactly as specified, and format flags describe how each parameter in the parameter list is to be formatted. The first format flag corresponds to the first value in the parameter list, the second flag corresponds to the second value, etc. The format flags must be preceded by a percent sign (%) and are of the general format

	%-M.Nx

where x is one of the flags listed below, the minus sign is an optional justification flag, and M and N are optional parameters which specify the field width and number of digits following the decimal place. If M is used, at least M characters will be output. If more than M characters are required to display the value, format expands the field as needed. If M starts with a 0 (e.g., %07d), a zero is used as the pad character; otherwise, spaces are used. If N is not specified, it defaults to six digits for floating-point numbers. If a minus sign is included before the M, the value will be left justified; otherwise the value is right justified.

Format Flags
d	Display parameter as a long integer. (The N specifier has no meaning.)

f	Display parameter as a floating-point number.

e	Display parameter as a floating-point using power of 10 notation.

g	Display parameter in the most general format, whichever is shorter.

o	Display parameter as an unsigned octal number. (The N specifier has no meaning.)

x	Display parameter as an unsigned hexadecimal number. (The N specifier has no meaning.)

s	Display parameter as a string. Strings will have the leading and trailing quotes stripped. (The N specifier has no meaning. Zero also cannot be used for the pad character.)

n	Put a new line in the output.

r	Put a carriage return in the output.

%	Put the percent character into the output.
Example
CLIPS> (format t "Hello World!%n")
Hello World!
"Hello World!
"
CLIPS> (format nil "Integer:     |%ld|" 12)
"Integer:     |12|"
CLIPS> (format nil "Integer:     |%4ld|" 12)
"Integer:     |  12|"
CLIPS> (format nil "Integer:     |%-04ld|" 12)
"Integer:     |12  |"
CLIPS> (format nil "Float:       |%f|" 12.01)
"Float:       |12.010000|"
CLIPS> (format nil "Float:       |%7.2f| "12.01)
"Float:       |  12.01| "
CLIPS> (format nil "Test:        |%e|" 12.01)
"Test:        |1.201000e+01|"
CLIPS> (format nil "Test:        |%7.2e|" 12.01)
"Test:        |1.20e+01|"
CLIPS> (format nil "General:     |%g|" 1234567890)
"General:     |1.23457e+09|"
CLIPS> (format nil "Hexadecimal: |%x|" 12)
"Hexadecimal: |c|"
CLIPS> (format nil "Octal:       |%o|" 12)
"Octal:       |14|"
CLIPS> (format nil "Symbols:     |%s| |%s|" value-a1 capacity)	
"Symbols:     |value-a1| |capacity|"
CLIPS> 
	
Portability Note
The format function uses the C function sprintf as a base. Some systems may not support sprintf or may not support all of these features, which may affect how format works.
12.4.2.7 Rename
The rename function is used to change the name of a file.
Syntax
(rename <old-file-name> <new-file-name>)

Both <old-file-name> and <new-file-name> must either be a string or symbol and may include directory specifiers. If a string is used, the backslash (\) and any other special characters that are part of either <old-file-name> or <new-file-name> must be escaped with a backslash. The rename function returns TRUE if it was successful, otherwise FALSE.

Portability Note
The rename function uses the ANSI C function rename as a base. If the ANSI_COMPILER flag was disabled when CLIPS was compiled, then this function will be non-functional and always return FALSE.
12.4.2.8 Remove
The remove function is used to delete a file.
Syntax
(remove <file-name>)

The <file-name> must either be a string or symbol and may include directory specifiers. If a string is used, the backslash (\) and any other special characters that are part of <file-name> must be escaped with a backslash. The remove function returns TRUE if it was successful, otherwise FALSE.

Portability Note
The remove function uses the ANSI C function remove as a base. If the ANSI_COMPILER flag was disabled when CLIPS was compiled, then this function will be non-functional and always return FALSE.
12.5 MATH FUNCTIONS
CLIPS provides several functions for mathematical computations. They are split into two packages: a set of standard math functions and a set of extended math functions.
12.5.1 Standard Math Functions
The standard math functions are listed below. These functions should be used only on numeric arguments. An error message will be printed if a string argument is passed to a math function.
12.5.1.1 Addition
The + function returns the sum of its arguments. Each of its arguments should be a numeric expression. Addition is performed using the type of the arguments provided unless mixed mode arguments (integer and float) are used. In this case, the function return value and integer arguments are converted to floats after the first float argument has been encountered. This function returns a float if any of its arguments is a float, otherwise it returns an integer.
Syntax
(+ <numeric-expression> <numeric-expression>+)
Example
CLIPS> (+ 2 3 4)
9
CLIPS> (+ 2 3.0 5)
10.0
CLIPS> (+ 3.1 4.7)
7.8
CLIPS>
12.5.1.2 Subtraction
The  function returns the value of the first argument minus the sum of all subsequent arguments. Each of its arguments should be a numeric expression. Subtraction is performed using the type of the arguments provided unless mixed mode arguments (integer and float) are used. In this case, the function return value and integer arguments are converted to floats after the first float argument has been encountered. This function returns a float if any of its arguments is a float, otherwise it returns an integer.
Syntax
(- <numeric-expression> <numeric-expression>+)
Example
CLIPS> (- 12 3 4)
5
CLIPS> (- 12 3.0 5)
4.0
CLIPS> (- 4.7 3.1)
1.6
CLIPS>
12.5.1.3 Multiplication
The * function returns the product of its arguments. Each of its arguments should be a numeric expression. Multiplication is performed using the type of the arguments provided unless mixed mode arguments (integer and float) are used. In this case, the function return value and integer arguments are converted to floats after the first float argument has been encountered. This function returns a float if any of its arguments is a float, otherwise it returns an integer.
Syntax
(* <numeric-expression> <numeric-expression>+)
Example
CLIPS> (* 2 3 4)
24
CLIPS> (* 2 3.0 5)
30.0
CLIPS> (* 3.1 4.7)
14.57
CLIPS>
12.5.1.4 Division
The / function returns the value of the first argument divided by each of the subsequent arguments. Each of its arguments should be a numeric expression. Division is performed using the type of the arguments provided unless mixed mode arguments (integer and float) are used. In this case, the function return value and integer arguments are converted to floats after the first float argument has been encountered. By default, the dividend (the first argument) is automatically converted to a floating point number so that the result is a floating pointer number. The function setautofloatdividend can be used to control this behavior. If for example, the auto-float feature is disabled, the expression (/ 4 3 4.0) evaluates to 0.25 as opposed to 0.333333333 if this feature were enabled. This function returns a float if any of its arguments is a float, otherwise it returns an integer. 
Syntax
(/ <numeric-expression> <numeric-expression>+)
Example
CLIPS> (/ 4 2)
2.0
CLIPS> (/ 4.0 2.0)
2.0
CLIPS> (/ 24 3 4)
2.0
CLIPS>
12.5.1.5 Integer Division
The div function returns the value of the first argument divided by each of the subsequent arguments. Each of its arguments should be a numeric expression. Each argument is automatically converted to an integer and integer division is performed. This function returns an integer. 
Syntax
(div <numeric-expression> <numeric-expression>+)
Example
CLIPS> (div 4 2)
2
CLIPS> (div 5 2)
2
CLIPS> (div 33 2 3 5)
1
CLIPS>
12.5.1.6 Maximum Numeric Value
The max function returns the value of its largest numeric argument. Each of its arguments should be a numeric expression. When necessary, integers are temporarily converted to floats for comparison. The return value will either be integer or float (depending upon the type of the largest argument). 
Syntax
(max <numeric-expression>+)
Example
CLIPS> (max 3.0 4 2.0)
4
CLIPS>
12.5.1.7 Minimum Numeric Value
The min function returns the value of its smallest numeric argument. Each of its arguments should be a numeric expression. When necessary, integers are temporarily converted to floats for comparison. The return value will either be integer or float (depending upon the type of the smallest argument). 
Syntax
(min <numeric-expression>+)
Example
CLIPS> (min 4 0.1 -2.3)
-2.3
CLIPS>
12.5.1.8 Absolute Value
The abs function returns the absolute value of its only argument (which should be a numeric expression). The return value will either be integer or float (depending upon the type the argument). 
Syntax
(abs <numeric-expression>)
Example
CLIPS> (abs 4.0)
4.0
CLIPS> (abs -2)
2
CLIPS>
12.5.1.9 Convert To Float
The float function converts its only argument (which should be a numeric expression) to type float and returns this value.
Syntax
(float <numeric-expression>)
Example
CLIPS> (float 4.0)
4.0
CLIPS> (float -2)
-2.0
CLIPS>
12.5.1.10 Convert To Integer
The integer function converts its only argument (which should be a numeric expression) to type integer and returns this value.
Syntax
(integer <numeric-expression>)
Example
CLIPS> (integer 4.0)
4
CLIPS> (integer -2)
-2
CLIPS>
12.5.2 Extended Math Functions
In addition to standard math functions, CLIPS also provides a large number of scientific and trigonometric math functions for more extensive computations. Although included in the generic version of CLIPS, if an expert system does not need these capabilities, these functions may be excluded from the executable element of CLIPS to provide more memory (see the Advanced Programming Guide).

Portability Note
These mathematical functions use the C library math.h. If the user's system does not support this library, the user needs to make some adjustments to math.c. The system-dependent math functions are called from CosFunction, SinFunction, etc. The user must change each of these to call the appropriate functions from his/her system. The user also must make sure that the functions CosFunction, SinFunction, etc., always return double-precision floating-point numbers. To link these functions, most compilers provide a separate math library that must be included during linking.
12.5.2.1 Trigonometric Functions
The following trigonometric functions take one numeric argument and return a floating-point number. The argument is expected to be in radians.
	
FUNCTION
RETURNS
acos
arccosine
acosh
hyperbolic arccosine
acot
arccotangent
acoth
hyperbolic arccotangent
acsc
arccosecant
acsch
hyperbolic arccosecant
asec
arcsecant
asech
hyperbolic arcsecant
asin
arcsine
asinh
hyperbolic arcsine
atan
arctangent
atanh
hyperbolic arctangent
cos
cosine
cosh
hyperbolic cosine
cot
cotangent
coth
hyperbolic tangent
csc
cosecant
csch
hyperbolic cosecant
sec
secant
sech
hyperbolic secant
sin
sine
sinh
hyperbolic sine
tan
tangent
tanh
hyperbolic tangent
Example
CLIPS> (cos 0)
1.0
CLIPS> (acos 1.0)
0.0
CLIPS>
12.5.2.2 Convert From Degrees to Grads
The deggrad function converts its only argument (which should be a numeric expression) from units of degrees to units of grads (360 degrees = 400 grads). The return value of this function is a float.
Syntax
(deg-grad <numeric-expression>)
Example
CLIPS> (deg-grad 90)
100.0
CLIPS>
12.5.2.3 Convert From Degrees to Radians
The degrad function converts its only argument (which should be a numeric expression) from units of degrees to units of radians (360 degrees = 2_ radians). The return value of this function is a float.
Syntax
(deg-rad <numeric-expression>)
Example
CLIPS> (deg-rad 180)
3.141592653589793
CLIPS>
12.5.2.4 Convert From Grads to Degrees
The graddeg function converts its only argument (which should be a numeric expression) from units of grads to units of degrees (360 degrees = 400 grads). The return value of this function is a float.
Syntax
(grad-deg <numeric-expression>)
Example
CLIPS> (grad-deg 100)
90.0
CLIPS>
12.5.2.5 Convert From Radians to Degrees 
The raddeg function converts its only argument (which should be a numeric expression) from units of radians to units of degrees (360 degrees = 2_ radians). The return value of this function is a float.
Syntax
(rad-deg <numeric-expression>)
Example
CLIPS> (rad-deg 3.141592653589793)
180.0
CLIPS>
12.5.2.6 Return the Value of _
The pi function returns the value of _ (3.141592653589793...) as a float.
Syntax
(pi)
Example
CLIPS> (pi)
3.141592653589793
CLIPS>
12.5.2.7 Square Root
The sqrt function returns the square root of its only argument (which should be a numeric expression) as a float.
Syntax
(sqrt <numeric-expression>)
Example
CLIPS> (sqrt 9)
3.0
CLIPS>
12.5.2.8 Power
The ** function raises its first argument to the power of its second argument and returns this value as a float.
Syntax
(** <numeric-expression> <numeric-expression>)
Example
CLIPS> (** 3 2)
9.0
CLIPS>
12.5.2.9 Exponential
The exp function raises the value e (the base of the natural system of logarithms, having a value of approximately 2.718...) to the power specified by its only argument and returns this value as a float.
Syntax
(exp <numeric-expression>)
Example
CLIPS> (exp 1)
2.718281828459045
CLIPS>
12.5.2.10 Logarithm
Given n (the only argument) and the value e is the base of the natural system of logarithms, the log function returns the float value x such that  the following equation is satisfied:

n = ex
Syntax
(log <numeric-expression>)
Example
CLIPS> (log 2.718281828459045)
0.9999999999999999
CLIPS>
12.5.2.11 Logarithm Base 10
Given n (the only argument), the log10 function returns the float value x such that  the following equation is satisfied:

n = 10x
Syntax
(log10 <numeric-expression>)
Example
CLIPS> (log10 100)
2.0
CLIPS>
12.5.2.12 Round
The round function rounds its only argument (which should be a numeric expression) toward the closest integer. If the argument is exactly between two integers, it is rounded down. The return value of this function is an integer.
Syntax
(round <numeric-expression>)
Example
CLIPS> (round 3.6)
4
CLIPS>
12.5.2.13 Modulus
The mod function returns the remainder of the result of dividing its first argument by its second argument (assuming that the result of division must be an integer). It returns an integer if both arguments are integers, otherwise it returns a float.
Syntax
(mod <numeric-expression> <numeric-expression>)
Example
CLIPS> (mod 5 2)
1
CLIPS> (mod 3.7 1.2)
0.1
CLIPS>
12.6 PROCEDURAL FUNCTIONS
The following are functions which provide procedural programming capabilities as found in languages such as Pascal, C and Ada.
12.6.1 Binding Variables
Occasionally, it is important to create new variables or to modify the value of previously bound variables on the RHS of a rule. The bind function provides this capability.
Syntax
(bind <variable> <expression>*)

where the first argument to bind, <variable>, is the local or global variable to be bound (it may have been bound previously). The bind function may also be used within a messagehandler's body to set a slot's value.

If no <expression> is specified, then local variables are unbound and global variables are reset to their original value. If one <expression> is specified, then the value of <variable> is set to the return value from evaluating <expression>. If more than one <expression> is specified, then all of the <expressions> are evaluated and grouped together as a multifield value and the resulting value is stored in <variable>.

 The bind function returns the symbol FALSE when a local variable is unbound, otherwise, the return value is the value to which <variable> is set.
Example 1
CLIPS> (defglobal ?*x* = 3.4)
CLIPS> ?*x*
3.4
CLIPS> (bind ?*x* (+ 8 9))
17
CLIPS> ?*x*
17
CLIPS> (bind ?*x* (create$ a b c d))
(a b c d)
CLIPS> ?*x*
(a b c d)
CLIPS> (bind ?*x* d e f)
(d e f)
CLIPS> ?*x*
(d e f)
CLIPS> (bind ?*x*)
3.4
CLIPS> ?*x*
3.4
CLIPS>
Example 2
CLIPS> 
(defclass A (is-a USER) 
   (role concrete) 
   (slot x) (slot y))
CLIPS> 
(defmessage-handler A init after () 
   (bind ?self:x 3)
   (bind ?self:y 4))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print)
[a] of A
(x 3)
(y 4)
CLIPS>
12.6.2 If...then...else Function
The if function provides an if...then...else structure to allow for conditional execution of a set of actions.
Syntax
(if <expression>
   then
      <action>*
   [else
      <action>*])

Any number of allowable actions may be used inside of the then or else portion, including another if...then...else structure. The else portion is optional. If <expression> evaluates to anything other than the symbol FALSE, then the actions associated with the then portion are executed. Otherwise, the actions associated with the else portion are executed. The return value of the if function is the value of the last <expression> or <action> evaluated.
Example
(defrule closed-valves
   (temp high)
   (valve ?v closed)
   =>
   (if (= ?v 6)
      then
      (printout t "The special valve " ?v " is closed!" crlf)
      (assert (perform special operation))
      else
      (printout t "Valve " ?v " is normally closed" crlf)))

Note that this rule could have been accomplished just as easily with two rules, and that it is usually better to accomplish this with two rules.

(defrule closed-valves-number-6
   (temp high)
   (valve 6 closed)
   =>
   (printout t "The special valve 6 is closed!" crlf)
   (assert (perform special operation)))

(defrule closed-valves-other-than-6
   (temp high)
   (valve ?v&~6 closed)
   =>
   (printout t "Valve " ?v " is normally closed" crlf))
12.6.3 While
The while function is provided to allow simple looping. Its use is similar to that of the if function.
Syntax
(while <expression> [do]
   <action>*)

Again, all predicate functions are available for use in while. Any number of allowable actions may be placed inside the while block, including if...then...else or additional while structures. The test is performed prior to the first execution of the loop. The actions within the while loop are executed until <expression> evaluates to the symbol FALSE. The while may optionally include the symbol do after the condition and before the first action. The break and return functions can be used to terminate the loop prematurely. The return value of this function is FALSE unless the return function is used to terminate the loop.
Example
(defrule open-valves
   (valves-open-through ?v)
   =>
   (while (> ?v 0)
      (printout t "Valve " ?v " is open" crlf)
      (bind ?v (- ?v 1))))
12.6.4 Loop-for-count
The loopforcount function is provided to allow simple iterative looping.
Syntax
(loop-for-count <range-spec> [do] <action>*)

<range-spec>  ::= <end-index> |
				(<loop-variable> [<start-index> <end-index>])
<start-index> ::= <integer-expression>
<end-index>   ::= <integer-expression>

Performs the given actions the number of times specified by <range-spec>. If <start-index> is not given, it is assumed to be one. If <start-index> is less than <end-index>, then the body of the loop is never executed. The integer value of the current iteration can be examined with the loop variable, if specified.The break and return functions can be used to terminate the loop prematurely. The return value of this function is FALSE unless the return function is used to terminate the loop. Variables from an outer scope may be used within the loop, but the loop variable (if specified) masks any outer variables of the same name. Loops can be nested.
Example
CLIPS> (loop-for-count 2 (printout t "Hello world" crlf))
Hello world
Hello world
FALSE
CLIPS>
(loop-for-count (?cnt1 2 4) do 
	(loop-for-count (?cnt2 1 3) do
		(printout t ?cnt1 " " ?cnt2 crlf)))
2 1
2 2
2 3
3 1
3 2
3 3
4 1
4 2
4 3
FALSE
CLIPS> 
12.6.5 Progn
The progn function evaluates all of its arguments and returns the value of the last argument;.
Syntax
(progn <expression>*)
Example
CLIPS> (progn (setgen 5) (gensym))
gen5
CLIPS>
12.6.6 Progn$
The progn$ function performs a set of actions for each field of a multifield value. The field of the current iteration can be examined with <loop-variable>, if specified. The index of the current iteration can be examined with <loop-variable>-index. The progn$ function can use variables from outer scopes, and the return and break functions can also be used within a progn$ as long as they are valid in the outer scope. The return value of this function is the return value of the last action performed for the last field in the multifield value.
Syntax
(progn$ <list-spec> <expression>*)

<list-spec> ::= 	<multifield-expression> |
				(<list-variable> <multifield-expression>)
Example
CLIPS> (progn$ (?field (create$ abc def ghi))
          (printout t "--> " ?field " " ?field-index " <--" crlf))
--> abc 1 <--
--> def 2 <--
--> ghi 3 <--
CLIPS> 
12.6.7 Return
The return function immediately terminates the currently executing deffunction, generic function method, message-handler, defrule RHS, or certain instance set query functions (doforinstance, doforallinstances and delayeddoforallinstances).  Without any arguments, there is no return value.  However, if an argument is included, its evaluation is given as the return value of the deffunction , method or message-handler.

The return function can only be used within the actions of deffunctions, methods and message-handlers, defrules,  or the instance set query functions previously listed. If used on the RHS of a rule, the current focus is removed from the focus stack. In addition, return should not be used as an argument to another function call. If used within an instance set query function, the return function is only valid if it is applicable in the outer scope of the query.
Syntax
(return [<expression>])
Example
CLIPS> 
(deffunction sign (?num)
  (if (> ?num 0) then
     (return 1))
  (if (< ?num 0) then
     (return -1))
  0)
CLIPS> (sign 5)
1
CLIPS> (sign -10)
-1
CLIPS> (sign 0)
0
CLIPS>
12.6.8 Break
The break function immediately terminates the currently iterating while loop, progn execution, or certain instance set query functions (doforinstance, doforallinstances and delayeddoforallinstances).

The break function can only be used within the actions of a while loop, progn execution, or the specified instance set queries previously listed.  Other uses will have no effect.  The break cannot be used within a progn unless it is valid for the outer scope of the progn. In addition, break should not be used as an argument to another function call.
Syntax
(break)
Example
CLIPS> 
(deffunction iterate (?num)
  (bind ?i 0)
  (while TRUE do
    (if (>= ?i ?num) then
       (break))
    (printout t ?i " ")
    (bind ?i (+ ?i 1)))
  (printout t crlf))
CLIPS> (iterate 1)
0
CLIPS> (iterate 10)
0 1 2 3 4 5 6 7 8 9
CLIPS>
12.6.9 Switch
The switch function allows a particular group of actions (among several groups of actions) to be performed based on a specified value.
Syntax
(switch <test-expression>
   <case-statement>
   <case-statement>+
   [<default-statement>])
                      
<case-statement> ::=
   (case <comparison-expression> then <action>*)
                         
<default-statement> ::= (default <action>*)

As indicated by the BNF, there must be at least two case statements, and the optional default statement must succeed all case statements. None of the case comparison expressions should be the same.

The switch function evaluates the <test-expression> first and then evaluates each <comparison-expression> in order of definition.  Once the evaluation of the <comparison-expression> is equivalent to the evaluation of the <test-expression>, the actions of that case are evaluated (in order) and the switch function is terminated.  If no cases are satisfied, the default actions (if any) are evaluated (in order).

The return value of the switch function is the last action evaluated in the switch function.  If no actions are evaluated, the return value is the symbol FALSE.
Example

CLIPS> (defglobal ?*x* = 0)
CLIPS> (defglobal ?*y* = 1)
CLIPS> 
(deffunction foo (?val)
  (switch ?val
  (case ?*x* then *x*)
  (case ?*y* then *y*)
  (default none)))
CLIPS> (foo 0)
*x*
CLIPS> (foo 1)
*y*
CLIPS> (foo 2)
none
CLIPS> 
12.7 MISCELLANEOUS FUNCTIONS
The following are additional functions for use within CLIPS.
12.7.1 Gensym
The gensym function returns a special, sequenced symbol that can be stored as a single field. This is primarily for tagging patterns that need a unique identifier, but the user does not care what the identifier is. Multiple calls to gensym are guaranteed to return different identifiers of the form

genX

where X is a positive integer. The first call to gensym returns gen1; all subsequent calls increment the number. Note that gensym is not reset after a call to clear. If users plan to use the gensym feature, they should avoid creating facts which include a user-defined field of this form.
Example
(assert (new-id (gensym) flag1 7))

which, on the first call, generates a fact of the form

(new-id gen1 flag1 7)
12.7.2 Gensym*
The gensym* function is similar to the gensym function, however, it will produce a unique symbol that does not currently exist within the CLIPS environment.
Example
CLIPS> (setgen 1)
1
CLIPS> (assert (gen1 gen2 gen3))
<Fact-0>
CLIPS> (gensym)
gen1
CLIPS> (gensym*)
gen4
CLIPS>
12.7.3 Setgen
The setgen function allows the user to set the starting number used by gensym and gensym*  (see sections 12.7.1 and 12.7.2).
Syntax
(setgen <integer-expression>)

where <num> must be a positive integer value and is the value returned by this function. All subsequent calls to gensym will return a sequenced symbol with the numeric portion of the symbol starting at <num>.
Example
CLIPS> (setgen 32)
32
CLIPS>

After this, calls to gensym will return gen32, gen33, etc.
12.7.4 Random
The random function returns a "random" integer value. It is patterned after the ANSI standard rand library function and therefore may not be available on all platforms.
Syntax
(random)
Example
(defrule roll-the-dice
   (roll-the-dice)
   =>
   (bind ?roll1 (+ (mod (random) 6) 1))
   (bind ?roll2 (+ (mod (random) 6) 1))
   (printout t "Your roll is:  " ?roll1 " " ?roll2 crlf))


Portability Note
If the ANSI_COMPILER flag has not been set, this function compiles to a non-functional stub that always returns zero.
12.7.5 Seed
The seed function seeds the random number generator. It is patterned after the ANSI standard seed library function and therefore may not be available on all platforms.
Syntax
(seed <integer-expression>)

where value is an integer and the function has no return value.

Portability Note
If the ANSI_COMPILER flag has not been set, this function compiles to a non-functional stub.
12.7.6 Time
The time function returns a floating-point value representing the elapsed seconds since the system reference time.
Syntax
(time)

Portability Note
Not all operating systems/compilers provide this function. The code is stored in the sysdep.c file, and the default coding for generic CLIPS is a non-functional stub that returns zero for the time.
12.7.7 Number of Fields or Characters in a Data Object
The length function returns an integer for the number of fields bound to a multifield value or the length in characters of a string or symbol.
Syntax
(length <string-symbol-or-multifield-expression>)

If the argument given to length is not the appropriate type, a negative one (-1) is returned. This function may also be called using the name length$.
Example
CLIPS> (length (create$ a b c d e f g))
7
CLIPS> (length "cat")
3
CLIPS> 
12.7.8 Determining the Restrictions for a Function
The getfunctionrestrictions function can be used to gain access to the restriction string associated with a CLIPS or user defined function. The restriction string contains information on the number and types of arguments that a function expects. See section 3.1 of the Advanced Programming Guide for the meaning of the characters which compose the restriction string.
Syntax
(get-function-restrictions <function-name>)
Example
CLIPS> (get-function-restrictions +)
"2*n"
CLIPS>
12.8 DEFTEMPLATE FUNCTIONS
The following functions provide ancillary capabilities for the deftemplate construct.
12.8.1 Getting the List of Deftemplates
The function get-deftemplate-list returns a multifield value containing the names of all deftemplate constructs that are currently defined.
Syntax
(getdeftemplatelist)
Example
CLIPS> (clear)
CLIPS> (get-deftemplate-list)
()
CLIPS> (deftemplate foo)
CLIPS> (deftemplate bar)
CLIPS> (get-deftemplate-list)
(foo bar)
CLIPS> 
12.8.2 Determining the Module in which a Deftemplate is Defined
This function returns the module in which the specified deftemplate name is defined.
Syntax
(deftemplatemodule <deftemplate-name>)
12.9 FACT FUNCTIONS
The following actions are used for assert, retracting, and modifying facts.
12.9.1 Creating New Facts
The assert action allows the user to add a fact to the fact-list. Multiple facts may be asserted with each call. If the facts item is being watched  (see section 13.2), then an informational message will be printed each time a fact is asserted.
Syntax
(assert <RHS-pattern>+)

Missing slots in a template fact  being asserted are assigned their default value (see section 3). If an identical copy of the fact already exists in the fact-list, the fact will not be added (however, this behavior can be changed, see sections 13.4.4 and 13.4.5). Note that in addition to constants, expressions can be placed within a fact to be asserted. The first field of a fact must be a symbol. The value returned of the assert function is the fact-address of the last fact asserted. If the assertion of the last fact causes an error, or if an identical copy of the fact already exists in the fact-list, then the symbol FALSE is returned.
Example
CLIPS> (clear)
CLIPS> (assert (color red))          
<Fact-0>
CLIPS> (assert (color blue) (value (+ 3 4)))
<Fact-2>
CLIPS> (assert (color red))
FALSE
CLIPS> (deftemplate status (slot temp) (slot pressure))
CLIPS> (assert (status (temp high)    
                       (pressure low)))
<Fact-3>
CLIPS> (facts)
f-0     (color red)
f-1     (color blue)
f-2     (value 7)
f-3     (status (temp high) (pressure low))
For a total of 4 facts.
CLIPS> 
12.9.2 Removing Facts from the Fact-list
The retract action allows the user to remove facts from the fact-list. Multiple facts may be retracted with a single retract statement. The retraction of a fact also removes all rules that depended upon that fact for activation from the agenda. Retraction of a fact may also cause the retraction of other facts which receive logical support from the retracted fact. If the facts item is being watched (see section 13.2), then an informational message will be printed each time a fact is retracted.
Syntax
(retract <retract-specifier>+ | *)

<retract-specifier> ::= <fact-specifier> | <integer-expression>

The term <retract-specifier> includes variables bound on the LHS to fact-addresses as described in section 5.4.1.8, or the factindex of the desired fact (e.g. 3 for the fact labeled f-3), or an expression which evaluates to a retract-specifier. If the symbol * is used as an argument, all facts will be retracted. Note that the number generally is not known during the execution of a program, so facts usually are retracted by binding them on the LHS of a rule. Only variable;s, fact indices, or the symbol * may be used in a retract. External functions may not be called. This function has no return value.
Example
(defrule change-valve-status
   ?f1 <- (valve ?v open)
   ?f2 <- (set ?v close)
   =>
   (retract ?f1 ?f2)
   (assert (valve ?v close)))
12.9.3 Modifying Template Facts
The modify action allows the user to modify template facts on the fact-list. Only one fact may be modified with a single modify statement. The modification of a fact is equivalent to retracting the present fact and asserting the modified fact. Therefore, any facts receiving logical support from a template fact are retracted (assuming no other support) when the template fact is modified and the new template fact loses any logical support that it previously had.
Syntax
(modify <fact-specifier> <RHS-slot>*)

The term <fact-specifier> includes variables bound on the LHS to fact-addresses as described in section 5.4.1.8 or the factindex of the desired fact (e.g. 3 for the fact labeled f-3). Note that the fact-index generally is not known during the execution of a program, so facts usually are modified by binding them on the LHS of a rule. Static deftemplate checking is not performed when a fact-index is used as the <fact-specifier> since the deftemplate being referenced is usually ambiguous. Only variables or fact indices may be used in a modify. External functions may not be called.  The value returned by this function is the fact-address of the newly modified fact. If the assertion of the newly modified fact causes an error, or if an identical copy of the newly modified fact already exists in the fact-list, then the symbol FALSE is returned.
Example
(defrule change-valve-status
   ?f1<-(status (valve open))
   ?f2<-(close-valve)
   =>
   (retract ?f2)
   (modify ?f1 (valve closed)))
12.9.4 Duplicating Template Facts
The duplicate action allows the user to duplicate deftemplate facts on the fact-list changing a group of specified fields. This command allows a new fact to be created by copying most of the fields of a source fact and then specifying the fields to be changed. Only one fact may be duplicated with a single duplicate statement. The duplicate command is similar to the modify command except the fact being duplicated is not retracted. 
Syntax
(duplicate <fact-specifier> <RHS-slot>*)

The term <fact-specifier> includes variables bound on the LHS to fact-addresses as described in section 5.4.1.8 or the factindex of the desired fact (e.g. 3 for the fact labeled f-3). Note that the fact-index generally is not known during the execution of a program, so facts usually are duplicated by binding them on the LHS of a rule. Static deftemplate checking is not performed when a fact-index is used as the <fact-specifier> since the deftemplate being referenced is usually ambiguous. Only variables or fact indices may be used in a duplicate. External functions may not be called. The value returned by this function is the fact-address of the newly duplicated fact. If the assertion of the newly duplicated fact causes an error, or if an identical copy of the newly duplicated fact already exists in the fact-list, then the symbol FALSE is returned.
Example
(defrule duplicate-part
   ?f1 <- (duplicate-part ?name)
   ?f2 <- (part (name ?name))
   =>
   (retract ?f1)
   (duplicate ?f2 (id (gensym*))))
12.9.5 Asserting a String
The assertstring function is similar to assert in that it will add a fact to the fact-list. However, assert-string takes a single string representing a fact (expressed in either ordered or deftemplate format ) and asserts it. Only one fact may be asserted with each assert-string statement.
Syntax
(assert-string <string-expression>)

If an identical copy of the fact already exists in the fact-list, the fact will not be added (however, this behavior can be changed, see sections 13.4.4 and 13.4.5). Fields within the fact may contain a string by escaping the quote character with a backslash. Note that this function takes a string and turns it into fields. If the fields within that string are going to contain special characters (such as a backslash), they need to be escaped twice (because you are literally embedding a string within a string and the backslash mechanism ends up being applied twice). Global variables and expressions can be contained within the string. The value returned by this function is the fact-address of the newly created fact. If the assertion of the newly created fact causes an error, or if an identical copy of the newly created fact already exists in the fact-list, then the symbol FALSE is returned.
Example
CLIPS> (clear)
CLIPS> (deftemplate foo (slot x) (slot y))
CLIPS> (assert-string "(status valve open)")
CLIPS> (assert-string "(light \"red\")")
CLIPS> (assert-string "(a\\b \"c\\\\d\")")
CLIPS> (assert-string "(foo (x 3))")
CLIPS> (assert-string "(foo (y 7))")
CLIPS> (facts)
f-0     (status valve open)
f-1     (light "red")
f-2     (a\b "c\d")
f-3     (foo (x 3) (y nil))
f-4     (foo (x nil) (y 7))
For a total of 5 facts.
CLIPS> 
12.9.6 Getting the Fact-Index of a Fact-address
The factindex function returns the fact-index (an integer) of a fact-address.
Syntax
(fact-index <fact-address>)
Example
(defrule print-fact-indices
   ?f <- ($?)
   =>
   (printout t (fact-index ?f) crlf))

12.10 DEFFACTS FUNCTIONS
The following functions provide ancillary capabilities for the deffacts construct.
12.10.1 Getting the List of Deffacts
The function get-deffacts-list returns a multifield value containing the names of all deffacts constructs that are currently defined.
Syntax
(getdeffactslist)
Example
CLIPS> (clear)
CLIPS> (get-deffacts-list)
(initial-fact)
CLIPS> (deffacts foo)
CLIPS> (get-deffacts-list)
(initial-fact foo)
CLIPS>
12.10.2 Determining the Module in which a Deffacts is Defined
This function returns the module in which the specified deffacts name is defined.
Syntax
(deffactsmodule <deffacts-name>)
12.11 DEFRULE FUNCTIONS
The following functions provide ancillary capabilities for the defrule construct.
12.11.1 Getting the List of Defrules
The function get-defrule-list returns a multifield value containing the names of all defrule constructs that are currently defined.
Syntax
(getdefrulelist)
Example
CLIPS> (clear)
CLIPS> (get-defrule-list)
()
CLIPS> (defrule foo =>)
CLIPS> (defrule bar =>)
CLIPS> (get-defrule-list)
(foo bar)
CLIPS>
12.11.2 Determining the Module in which a Defrule is Defined
This function returns the module in which the specified defrule name is defined.
Syntax
(defrulemodule <defrule-name>)
12.12 AGENDA FUNCTIONS
The following functions provide ancillary capabilities manipulating the agenda.
12.12.1 Getting the Current Focus
The function get-focus returns the module name of the current focus. If the focus stack is empty, then the symbol FALSE is returned.
Syntax
(getfocus)
Example
CLIPS> (clear)
CLIPS> (get-focus)
MAIN
CLIPS> (defmodule A)
CLIPS> (defmodule B)
CLIPS> (focus A B)
TRUE
CLIPS> (get-focus)
A
CLIPS>
12.12.2 Getting the Focus Stack
The function get-focus-stack returns all of the module names in the focus stack as a multifield value. A multifield value of length zero is returned if the focus stack is empty.
Syntax
(getfocusstack)
Example
CLIPS> (clear)
CLIPS> (get-focus-stack)
(MAIN)
CLIPS> (clear-focus-stack)
CLIPS> (get-focus-stack)
()
CLIPS> (defmodule A)
CLIPS> (defmodule B)
CLIPS> (focus A B)
TRUE
CLIPS> (get-focus-stack)
(A B)
CLIPS>
12.12.3 Removing the Current Focus from the Focus Stack
The function pop-focus removes the current focus from the focus stack and returns the module name of the current focus. If the focus stack is empty, then the symbol FALSE is returned.
Syntax
(popfocus)
Example
CLIPS> (clear)
CLIPS> (list-focus-stack)
MAIN
CLIPS> (pop-focus)
MAIN
CLIPS> (defmodule A)
CLIPS> (defmodule B)
CLIPS> (focus A B)
TRUE
CLIPS> (list-focus-stack)
A
B
MAIN
CLIPS> (pop-focus)
A
CLIPS> (list-focus-stack)
B
CLIPS>
12.13 DEFGLOBAL FUNCTIONS
The following functions provide ancillary capabilities for the defglobal construct.
12.13.1 Getting the List of Defglobals
The function get-defglobal-list returns a multifield value containing the names of all global variables that are currently defined.
Syntax
(getdefgloballist)
Example
CLIPS> (clear)
CLIPS> (get-defglobal-list)
()
CLIPS> (defglobal ?*x* = 3 ?*y* = 5)
CLIPS> (get-defglobal-list)
(x y)
CLIPS>
12.13.2 Determining the Module in which a Defglobal is Defined
This function returns the module in which the specified defglobal name is defined.
Syntax
(defglobalmodule <defglobal-name>)
12.14 DEFFUNCTION FUNCTIONS
The following functions provide ancillary capabilities for the deffunction construct.
12.14.1 Getting the List of Deffunctions
The function get-deffunction-list returns a multifield value containing the names of all deffunction constructs that are currently defined.
Syntax
(getdeffunctionlist)
Example
CLIPS> (clear)
CLIPS> (get-deffunction-list)
()
CLIPS> (deffunction foo ())
CLIPS> (deffunction bar ())
CLIPS> (get-deffunction-list)
(foo bar)
CLIPS>
12.14.2 Determining the Module in which a Deffunction is Defined
This function returns the module in which the specified deffunction name is defined.
Syntax
(deffunctionmodule <deffunction-name>)
12.15 GENERIC FUNCTION FUNCTIONS
The following functions provide ancillary capabilities for generic function methods.
12.15.1 Getting the List of Defgenerics
The function get-defgeneric-list returns a multifield value containing the names of all defgeneric constructs that are currently defined.
Syntax
(getdefgenericlist)
Example
CLIPS> (clear)
CLIPS> (get-defgeneric-list)
()
CLIPS> (defgeneric foo)
CLIPS> (defgeneric bar)
CLIPS> (get-defgeneric-list)
(foo bar)
CLIPS>
12.15.2 Determining the Module in which a Generic Function is Defined
This function returns the module in which the specified defgeneric name is defined.
Syntax
(defgenericmodule <defgeneric-name>)
12.15.3 Getting the List of Defmethods
The function get-defmethod-list returns a multifield value containing method name/indices pairs for all defmethod constructs that are currently defined. The optional generic-function name parameter restricts the methods return to only those of the specified generic function.
Syntax
(getdefmethodlist [<generic-function-name>])
Example
CLIPS> (clear)
CLIPS> (get-defmethod-list)
()
CLIPS> (defmethod foo ((?x STRING)))
CLIPS> (defmethod foo ((?x INTEGER)))
CLIPS> (defmethod bar ((?x STRING)))
CLIPS> (defmethod bar ((?x INTEGER)))
CLIPS> (get-defmethod-list)
(foo 1 foo 2 bar 1 bar 2)
CLIPS> (get-defmethod-list foo)
(foo 1 foo 2)
CLIPS>
12.15.4 Type Determination
The function type returns a symbol which is the name of the type (or class) of its of argument. This function is equivalent to the class function (see section 12.16.4.4), but, unlike the class function, it is available even when COOL is not installed.
Syntax
(type <expression>)
Example
CLIPS> (type (+ 2 2))
INTEGER
CLIPS> (defclass CAR (is-a USER) (role concrete))
CLIPS> (make-instance Rolls-Royce of CAR)
[Rolls-Royce]
CLIPS> (type Rolls-Royce)
SYMBOL
CLIPS> (type [Rolls-Royce])
CAR
CLIPS> 
12.15.5 Existence of Shadowed Methods
If called from a method for a generic function, the function next-methodp will return the symbol TRUE if there is another method shadowed (see section 8.5.3) by the current one. Otherwise, the function will return the symbol FALSE.
Syntax
(nextmethodp)
12.15.6 Calling Shadowed Methods
If the conditions are such that the function nextmethodp would return the symbol TRUE (see section 12.15.5), then calling the function call-next-method will execute the shadowed (see section 8.5.3) method. Otherwise, a method execution error will occur (see section 8.5.4). In the event of an error, the return value of this function is the symbol FALSE, otherwise it is the return value of the shadowed method. The shadowed method is passed the same arguments as the calling method.

A method may continue execution after calling call-next-method. In addition, a method may make multiple calls to call-next-method, and the same shadowed method will be executed each time.
Syntax
(callnextmethod)
Example
CLIPS> 
(defmethod describe ((?a INTEGER))
  (if (next-methodp) then
     (bind ?extension (str-cat " " (call-next-method)))
   else
     (bind ?extension ""))
  (str-cat "INTEGER" ?extension))
CLIPS> (describe 3)
"INTEGER"
CLIPS> 
(defmethod describe ((?a NUMBER))
  "NUMBER")
CLIPS> (describe 3)
"INTEGER NUMBER"
CLIPS> (describe 3.0)
"NUMBER"
CLIPS> 
12.15.7 Calling Shadowed Methods with Overrides
The function override-next-method is similar to call-next-method, except that new arguments can be provided. This allows one method to act as a wrapper for another and set up a special environment for the shadowed method. From the set of methods which are more general than the currently executing one, the most specific method which is applicable to the new arguments is executed.  (In contrast, callnextmethod calls the next most specific method which is applicable to the same arguments as the currently executing one received.)  A recursive call to the generic function itself should be used in lieu of override-next-method if the most specific of all methods for the generic function which is applicable to the new arguments should be executed.
Syntax
(overridenextmethod <expression>*)
Example
CLIPS> (clear)
CLIPS> 
(defmethod + ((?a INTEGER) (?b INTEGER))
  (override-next-method (* ?a 2) (* ?b 3)))
CLIPS> (list-defmethods +)
+ #2  (INTEGER) (INTEGER)
+ #SYS1  (NUMBER) (NUMBER) ($? NUMBER)
For a total of 2 methods.
CLIPS> (preview-generic + 1 2)
+ #2  (INTEGER) (INTEGER)
+ #SYS1  (NUMBER) (NUMBER) ($? NUMBER)
CLIPS> (watch methods)
CLIPS> (+ 1 2)
MTH >> +:#2  ED:1 (1 2)
MTH >> +:#SYS1  ED:2 (2 6)
MTH << +:#SYS1  ED:2 (2 6)
MTH << +:#2  ED:1 (1 2)
8
CLIPS> (unwatch methods)
CLIPS> 
12.15.8 Calling a Specific Method
The function call-specific-method allows the user to call a particular method of a generic function without regards to method precedence. This allows the user to bypass method precedence when absolutely necessary. The method must be applicable to the arguments passed. Shadowed methods can still be called via callnextmethod and overridenextmethod.  
Syntax
(callspecificmethod <generic-function> <method-index>
                      <expression>*)
Example
CLIPS> (clear)
CLIPS> 
(defmethod + ((?a INTEGER) (?b INTEGER))
  (* (- ?a ?b) (- ?b ?a)))
CLIPS> (list-defmethods +)
+ #2  (INTEGER) (INTEGER)
+ #SYS1  (NUMBER) (NUMBER) ($? NUMBER)
For a total of 2 methods.
CLIPS> (preview-generic + 1 2)
+ #2  (INTEGER) (INTEGER)
+ #SYS1  (NUMBER) (NUMBER) ($? NUMBER)
CLIPS> (watch methods)
CLIPS> (+ 1 2)
MTH >> +:#2  ED:1 (1 2)
MTH << +:#2  ED:1 (1 2)
-1
CLIPS> (call-specific-method + 1 1 2)
MTH >> +:#SYS1  ED:1 (1 2)
MTH << +:#SYS1  ED:1 (1 2)
3
CLIPS> (unwatch methods)
CLIPS> 
12.15.9 Getting the Restrictions of Defmethods
The function get-method-restrictions returns a multifield value containing information about the restrictions for the specified method using the following format: 

<minimum-number-of-arguments>
<maximum-number-of-arguments> (can be -1 for wildcards)
<number-of-restrictions>
<multifield-index-of-first-restriction-info>
      .
      .
      .
<multifield-index-of-nth-restriction-info>
<first-restriction-query> (TRUE or FALSE)
<first-restriction-class-count>
<first-restriction-first-class>
      .
      .
      .
<first-restriction-nth-class>
      .
      .
      .
<mth-restriction-class-count>
<mth-restriction-first-class>
      .
      .
      .
<mth-restriction-nth-class>

Syntax
(getmethodrestrictions <generic-function-name> 
                         <method-index>)
Example
CLIPS> (clear)
CLIPS> 
(defmethod foo 50 ((?a INTEGER SYMBOL) (?b (= 1 1)) $?c))
CLIPS> (get-method-restrictions foo 50)
(2 -1 3 7 11 13 FALSE 2 INTEGER SYMBOL TRUE 0 FALSE 0)
CLIPS>
12.16 CLIPS OBJECT-ORIENTED LANGUAGE (COOL) FUNCTIONS
The following functions provide ancillary capabilities for COOL.
12.16.1 Class Functions
12.16.1.1 Getting the List of Defclasses
The function get-defclass-list returns a multifield value containing the names of all defclass constructs that are currently defined.
Syntax
(getdefclasslist)
Example
CLIPS> (clear)
CLIPS> (get-defclass-list)
(FLOAT INTEGER SYMBOL STRING MULTIFIELD EXTERNAL-ADDRESS FACT-ADDRESS INSTANCE-ADDRESS INSTANCE-NAME OBJECT PRIMITIVE NUMBER LEXEME ADDRESS INSTANCE USER INITIAL-OBJECT)
CLIPS> (defclass FOO (is-a USER))
CLIPS> (defclass BAR (is-a USER))
CLIPS> (get-defclass-list)
(FLOAT INTEGER SYMBOL STRING MULTIFIELD EXTERNAL-ADDRESS FACT-ADDRESS INSTANCE-ADDRESS INSTANCE-NAME OBJECT PRIMITIVE NUMBER LEXEME ADDRESS INSTANCE USER INITIAL-OBJECT FOO BAR)
CLIPS>
12.16.1.2 Determining the Module in which a Defclass is Defined
This function returns the module in which the specified defclass name is defined.
Syntax
(defclassmodule <defclass-name>)
12.16.1.3 Determining if a Class Exists
This function returns the symbol TRUE if the specified class is defined, FALSE otherwise.
Syntax
(classexistp <class-name>)
12.16.1.4 Superclass Determination
This function returns the symbol TRUE if the first class is a superclass of the second class, FALSE otherwise.
Syntax
(superclassp <class1-name> <class2-name>)
12.16.1.5 Subclass Determination
This function returns the symbol TRUE if the first class is a subclass of the second class, FALSE otherwise.
Syntax
(subclassp <class1-name> <class2-name>)
12.16.1.6 Slot Existence
This function returns the symbol TRUE if the specified slot is present class, FALSE otherwise. If the inherit keyword is specified then the slot may be inherited, otherwise it must be directly defined in the specified class.
Syntax
(slot-existp <class> <slot> [inherit])
12.16.1.7 Testing whether a Slot is Writable 
This function returns the symbol TRUE if the specified slot in the specified class is writable (see section 9.3.3.4). Otherwise, it returns the symbol FALSE. An error is generated if the specified class or slot does not exist.
Syntax
(slotwritablep <class-expression> <slot-name-expression>)
12.16.1.8 Testing whether a Slot is Initializable
This function returns the symbol TRUE if the specified slot in the specified class is initializable (see section 9.3.3.4). Otherwise, it returns the symbol FALSE. An error is generated if the specified class or slot does not exist.
Syntax
(slotinitablep <class-expression> <slot-name-expression>)
12.16.1.9 Testing whether a Slot is Public
This function returns the symbol TRUE if the specified slot in the specified class is public (see section 9.3.3.8). Otherwise, it returns the symbol FALSE. An error is generated if the specified class or slot does not exist.
Syntax
(slotpublicp <class-expression> <slot-name-expression>)
12.16.1.10 Testing whether a Slot can be Accessed Directly
This function returns the symbol TRUE if the specified slot in the specified class can be accessed directly (see section 9.3.3.4). Otherwise, it returns the symbol FALSE. An error is generated if the specified class or slot does not exist.
Syntax
(slotdirectaccessp <class-expression> <slot-name-expression>)
12.16.1.11 Message-handler Existence
This function returns the symbol TRUE if the specified messagehandler is defined (directly only, not by inheritance) for the class, FALSE otherwise.
Syntax
Defaults are outlined.

(messagehandlerexistp <class-name> <handler-name> 	[<handler-type>])
<handler-type> ::= around | before | primary | after
12.16.1.12 Determining if a Class can have Direct Instances
This function returns the symbol TRUE if the specified class is abstract, i.e. the class cannot have direct instances, FALSE otherwise.
Syntax
(classabstractp <class-name>)
12.16.1.13 Determining if a Class can Satisfy Object Patterns
This function returns the symbol TRUE if the specified class is reactive, i.e. objects of the class can match object patterns, FALSE otherwise.
Syntax
(classreactivep <class-name>)
12.16.1.14 Getting the List of Superclasses for a Class
This function groups the names of the direct superclasses of a class into a multifield variable. If the optional argument "inherit" is given, indirect superclasses are also included. A multifield of length zero is returned if an error occurs.
Syntax
(classsuperclasses <class-name> [inherit])
Example
CLIPS> (class-superclasses INTEGER)
(NUMBER)
CLIPS> (class-superclasses INTEGER inherit)
(NUMBER PRIMITIVE OBJECT)
CLIPS>
12.16.1.15 Getting the List of Subclasses for a Class
This function groups the names of the direct subclasses of a class into a multifield variable. If the optional argument "inherit" is given, indirect subclasses are also included. A multifield of length zero is returned if an error occurs.
Syntax
(classsubclasses <class-name> [inherit])
Example
CLIPS> (class-subclasses PRIMITIVE)
(NUMBER LEXEME MULTIFIELD EXTERNAL-ADDRESS)
CLIPS> (class-subclasses PRIMITIVE inherit)
(NUMBER INTEGER FLOAT LEXEME SYMBOL STRING MULTIFIELD ADDRESS EXTERNAL-ADDRESS FACT-ADDRESS INSTANCE-ADDRESS INSTANCE INSTANCE-NAME)
CLIPS>
12.16.1.16 Getting the List of Slots for a Class
This function groups the names of the explicitly defined slots of a class into a multifield variable. If the optional argument "inherit" is given, inherited slots are also included. A multifield of length zero is returned if an error occurs.
Syntax
(classslots <class-name> [inherit])
Example
CLIPS> (defclass A (is-a USER) (slot x))
CLIPS> (defclass B (is-a A) (slot y))
CLIPS> (class-slots B)
(y)
CLIPS> (class-slots B inherit)
(x y)
CLIPS>
12.16.1.17 Getting the List of Message-Handlers for a Class
This function groups the class names, message names and message types of the message-handlers attached direct to class into a multifield variable (implicit slot-accessors are not included). If the optional argument "inherit" is given, inherited message-handlers are also included.  A multifield of length zero is returned if an error occurs.
Syntax
(getdefmessagehandlerlist <class-name> [inherit])
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER))
CLIPS> (defmessage-handler A foo ())
CLIPS> (get-defmessage-handler-list A)
(A foo primary)
CLIPS> (get-defmessage-handler-list A inherit)
(USER init primary USER delete primary USER print primary USER direct-modify primary USER message-modify primary USER direct-duplicate primary USER message-duplicate primary A foo primary)
CLIPS>
12.16.1.18 Getting the List of Facets for a Slot
This function returns a multifield listing the facet values for the specified slot (the slot can be inherited or explicitly defined for the class). A multifield of length zero is returned if an error occurs. Following is a table indicating what each field represents and its possible values:

Field
Meaning
Values
Explanation
1
Field Type
SGL/MLT
Single-field or multifield
2
Default Value
STC/DYN/NIL
Static, dynamic or none
3
Inheritance
INH/NIL
Inheritable by other classes or not
4
Access
RW/R/INT
Read-write, read-only or initialize-only
5
Storage
LCL/SHR
Local or shared
6
Pattern-Match
RCT/NIL
Reactive or non-reactive
7
Source
EXC/CMP
Exclusive or composite
8
Visibility
PUB/PRV
Public or private
9
Automatic Accessors
R/W/RW/NIL
Read, write, read-write or none
10
Override-Message
<message-name>
Name of message sent for slot-overrides

See section 9.3.3 for more details on slot facets.
Syntax
(slotfacets <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (slot x (access read-only)))
CLIPS> (defclass B (is-a A) (multislot y))
CLIPS> (slot-facets B x)
(SGL STC INH R LCL RCT EXC PRV NIL NIL)
CLIPS> (slot-facets B y)
(MLT STC INH RW LCL RCT EXC PRV NIL put-y)
CLIPS>  
12.16.1.19 Getting the List of Source Classes for a Slot
This function groups the names of the classes which provide facets for a slot of a class into a multifield variable.  In the case of an exclusive slot, this multifield will be of length one and contain the name of the contributing class. However, composite slots may have facets from many different classes (see section 9.3.3.6). A multifield of length zero is returned if an error occurs.
Syntax
(slotsources <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot x (access read-only)))
CLIPS> 
(defclass B (is-a A) 
  (slot x (source composite) 
          (default 100)))
CLIPS> (defclass C (is-a B))
CLIPS> (slot-sources A x)
(A)
CLIPS> (slot-sources B x)
(A B)
CLIPS> (slot-sources C x)
(A B)
CLIPS>
12.16.1.20 Getting the Primitive Types for a Slot
This function groups the names of the primitive types allowed for a slot into a multifield variable. A multifield of length zero is returned if an error occurs.
Syntax
(slottypes <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (slot y (type INTEGER LEXEME)))
CLIPS> (slot-types A y)
(INTEGER SYMBOL STRING)
CLIPS> 
12.16.1.21 Getting the Cardinality for a Slot
This function groups the minimum and maximum cardinality allowed for a multifield slot into a multifield variable. A maximum cardinality of infinity is indicated by the symbol +oo (the plus character followed by two lowercase o's-not zeroes). A multifield of length zero is returned for single field slots or if an error occurs.
Syntax
(slotcardinality <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot x)
  (multislot y (cardinality ?VARIABLE 5))
  (multislot z (cardinality 3 ?VARIABLE)))
CLIPS> (slot-cardinality A x)
()
CLIPS> (slot-cardinality A y)
(0 5)
CLIPS> (slot-cardinality A z)
(3 +oo)
CLIPS>  
12.16.1.22 Getting the Allowed Values for a Slot
This function groups the allowed values for a slot (specified in any of allowed-... facets for the slots) into a multifield variable. If no allowed-... facets were specified for the slot, then the symbol FALSE is returned. A multifield of length zero is returned if an error occurs.
Syntax
(slotallowedvalues <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot x)
  (slot y (allowed-integers 2 3) (allowed-symbols foo)))
CLIPS> (slot-allowed-values A x)
FALSE
CLIPS> (slot-allowed-values A y)
(2 3 foo)
CLIPS> 
12.16.1.23 Getting the Numeric Range for a Slot
This function groups the minimum and maximum numeric ranges allowed a slot into a multifield variable. A minimum value of infinity is indicated by the symbol -oo (the minus character followed by two lowercase o's-not zeroes). A maximum value of infinity is indicated by the symbol +oo (the plus character followed by two lowercase o's-not zeroes). The symbol FALSE is returned for slots in which numeric values are not allowed. A multifield of length zero is returned if an error occurs.
Syntax
(slotrange <class-name> <slot-name>)
Example
CLIPS> (clear)
CLIPS> 
(defclass A (is-a USER)
  (slot x)
  (slot y (type SYMBOL))
  (slot z (range 3 10)))
CLIPS> (slot-range A x)
(-oo +oo)
CLIPS> (slot-range A y)
FALSE
CLIPS> (slot-range A z)
(3 10)
CLIPS>
12.16.2 Message-handler Functions
12.16.2.1 Existence of Shadowed Handlers
This function returns the symbol TRUE if there is another message-handler available for execution, FALSE otherwise. If this function is called from an around handler and there are any shadowed handlers (see section 9.5.3), the return value is the symbol TRUE. If this function is called from a primary handler and there are any shadowed primary handlers, the return value is the symbol TRUE. In any other circumstance, the return value is the symbol FALSE.
Syntax
(nexthandlerp)
12.16.2.2 Calling Shadowed Handlers
If the conditions are such that the function nexthandlerp would return the symbol TRUE, then calling this function will execute the shadowed method. Otherwise, a message execution error (see section 9.5.4) will occur. In the event of an error, the return value of this function is the symbol FALSE, otherwise it is the return value of the shadowed handler. The shadowed handler is passed the same arguments as the calling handler.

A handler may continue execution after calling call-next-handler. In addition, a handler may make multiple calls to call-next-handler, and the same shadowed handler will be executed each time.
Syntax
(callnexthandler)
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (role concrete))
CLIPS>
(defmessage-handler A print-args ($?any)
  (printout t "A: " ?any crlf)
  (if (next-handlerp) then
     (call-next-handler)))
CLIPS>
(defmessage-handler USER print-args ($?any)
  (printout t "USER: " ?any crlf))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print-args 1 2 3 4)
A: (1 2 3 4)
USER: (1 2 3 4)
CLIPS>
12.16.2.3 Calling Shadowed Handlers with Different Arguments
This function is identical to callnexthandler except that this function can change the arguments passed to the shadowed handler.
Syntax
(overridenexthandler <expression>*)
Example
CLIPS> (clear)
CLIPS> (defclass A (is-a USER) (role concrete))
CLIPS>
(defmessage-handler A print-args ($?any)
  (printout t "A: " ?any crlf)
  (if (next-handlerp) then
     (override-next-handler (rest$ ?any))))
CLIPS>
(defmessage-handler USER print-args ($?any)
  (printout t "USER: " ?any crlf))
CLIPS> (make-instance a of A)
[a]
CLIPS> (send [a] print-args 1 2 3 4)
A: (1 2 3 4)
USER: (2 3 4)
CLIPS>
12.16.3 Definstances Functions
12.16.3.1 Getting the List of Definstances
The function get-definstances-list returns a multifield value containing the names of all definstances constructs that are currently defined.
Syntax
(getdefinstanceslist)
Example
CLIPS> (clear)
CLIPS> (get-definstances-list)
()
CLIPS> (definstances foo)
CLIPS> (definstances bar)
CLIPS> (get-definstances-list)
(foo bar)
CLIPS>
12.16.3.2 Determining the Module in which a Definstances is Defined
This function returns the module in which the specified definstances name is defined.
Syntax
(definstancesmodule <definstances-name>)
12.16.4 Instance Manipulation Functions and Actions
12.16.4.1 Initializing an Instance
This function implements the init message-handler attached to the class USER (see section 9.4.5.1). This function evaluates and places slot expressions given by the class definition that were not specified by slotoverrides in the call to makeinstance or initializeinstance (see section 9.6.1). This function should never be called directly unless an init message-handler is being defined such that the one attached to USER will never be called. However, such a definition is unusual and recommended only to advanced users. A user-defined class which does not inherit indirectly or directly from the class USER will require an init message-handler which calls this function in order for instances of the class to be created. If this function is called from an init message within the context of a make-instance or initialize-instance call and there are no errors in evaluating the class defaults, this function will return the address of the instance it is initializing. Otherwise, this function will return the symbol FALSE.
Syntax
(initslots)
12.16.4.2 Deleting an Instance
This function deletes the specified instances by sending them a delete message. The argument can be one or more instance-names, instance-addresses, or symbols (an instance-name without enclosing brackets). The instance specified by the arguments must exist (except in the case of "*"). If "*" is specified for the instance, all instances will be sent the delete message (unless there is an instance named "*"). This function returns the symbol TRUE if all instances were successfully deleted, otherwise it returns the symbol FALSE. Note, this function is exactly equivalent to sending the instance(s) the delete message directly and is provided only as an intuitive counterpart to the function retract for facts.
Syntax
(unmakeinstance <instance-expression>+)
12.16.4.3 Deleting the Active Instance from a Handler
This function operates implicitly on the active instance (see section 9.4.1.1) for a message, and thus can only be called from within the body of a messagehandler. This function directly deletes the active instance and is the one used to implement the delete handler attached to class USER (see section 9.4.5.2). This function returns the symbol TRUE if the instance was successfully deleted, otherwise the symbol FALSE.
Syntax
(deleteinstance)
12.16.4.4 Determining the Class of an Object
This function returns a symbol which is the name of the class of its argument. It returns the symbol FALSE on errors. This function is equivalent to the type function (see section 12.15.4).
Syntax
(class <object-expression>)
Example
CLIPS> (class 34)
INTEGER
CLIPS>
12.16.4.5 Determining the Name of an Instance
This function returns a symbol which is the name of its instance argument. It returns the symbol FALSE on errors. The evaluation of the argument must be an instance-name or instanceaddress of an existing instance.
Syntax
(instancename <instance-expression>)
12.16.4.6 Determining the Address of an Instance
This function returns the address of its instance argument. It returns the symbol FALSE on errors. The evaluation of <instance expression> must be an instance-name or instanceaddress of an existing instance. If <module> or * is not specified, the function searches only in the current module. If * is specified, the current module and imported modules are recursively searched. If <module> is specified, only that module is searched. The :: syntax cannot be used with the instance-name if <module> or * is specified.
Syntax
(instanceaddress [<module> | *] <instance-expression>)
12.16.4.7 Converting a Symbol to an Instance-Name
This function returns an instancename which is equivalent to its symbol argument. It returns the symbol FALSE on errors.
Syntax
(symboltoinstancename <symbol-expression>)
Example
CLIPS> (symbol-to-instance-name (sym-cat abc def))
[abcdef]
CLIPS>
12.16.4.8 Converting an Instance-Name to a Symbol
This function returns a symbol which is equivalent to its instancename argument. It returns the symbol FALSE on errors.
Syntax
(instancenametosymbol <instance-name-expression>)
Example
CLIPS> (instance-name-to-symbol [a])
a
CLIPS>
12.16.4.9 Predicate Functions
12.16.4.9.1 Testing for an Instance

This function returns the symbol TRUE if the evaluation of its argument is an instanceaddress or an instancename. Otherwise, it returns the symbol FALSE.
Syntax
(instancep <expression>)
12.16.4.9.2 Testing for an Instance-Address
This function returns the symbol TRUE if the evaluation of its argument is an instanceaddress. Otherwise, it returns the symbol FALSE.
Syntax
(instanceaddressp <expression>)
12.16.4.9.3 Testing for an Instance-Name
This function returns the symbol TRUE if the evaluation of its argument is an instancename. Otherwise, it returns the symbol FALSE.
Syntax
(instancenamep <expression>)
12.16.4.9.4 Testing for the Existence an Instance
This function returns the symbol TRUE if the specified instance exists. Otherwise, it returns the symbol FALSE. If the argument is an instance-name,  the function determines if an instance of the specified name exists. If the argument is an instance-address, the function determines if the specified address is still valid.
Syntax
(instanceexistp <instance-expression>)
12.16.4.10 Reading a Slot Value
This function returns the value of the specified slot of the active instance (see section 9.4.1.1). If the slot does not exist, the slot does not have a value or this function is called from outside a message-handler, this function will return the symbol FALSE and an error will be generated. This function differs from the ?self:<slot-name> syntax in that the slot is not looked up until the function is actually called. Thus it is possible to access different slots every time the function is executed (see section 9.4.2 for more detail). This function bypasses message-passing.
Syntax
(dynamicget <slot-name-expression>)
12.16.4.11 Setting a Slot Value
This function sets the value of the specified slot of the active instance (see section 9.4.1.1). If the slot does not exist, there is an error in evaluating the arguments to be placed or this function is called from outside a message-handler, this function will return the symbol FALSE and an error will be generated. Otherwise, the new slot value is returned. This function differs from the (bind ?self:<slot-name> <value>*) syntax in that the slot is not looked up until the function is actually called. Thus it is possible to access different slots every time the function is executed (see section 9.4.2 for more detail). This function bypasses message-passing.
Syntax
(dynamicput <slot-name-expression> <expression>*)
12.16.4.12 Multifield Slot Functions
The following functions allow convenient manipulation of multifield slots. There are three types of functions: replacing a range of fields with one or more new values, inserting one or more new values at an arbitrary point, and deleting a range of fields. For each type, there are two forms of functions: an external interface which sets the new value for the multifield slot with a put- message (see section 9.3.3.9), and an internal interface that can only be called from message-handlers which sets the slot for the active instance (see section 9.4.1.1) directly. Both forms read the original value of the slot directly without the use of a get- message. All of these functions return the new slot value on success and the symbol FALSE on errors.
12.16.4.12.1 Replacing Fields
Allows the replacement of a range of fields in a multifield slot value with one or more new values. The range indices must be from 1..n, where n is the number of fields in the multifield slot's original value and n > 0.
External Interface Syntax
(slotreplace$ <instance-expression> <mv-slot-name>
	<range-begin> <range-end> <expression>+)
Internal Interface Syntax
(directslotreplace$ <mv-slot-name>
	<range-begin> <range-end> <expression>+)
Example
CLIPS> 
(defclass A (is-a USER)
  (role concrete)
  (multislot mfs (default a b c d e)
                 (create-accessor write)))
CLIPS> (make-instance a of A)
[a]
CLIPS> (slot-replace$ a mfs 2 4 2 3 4)
(a 2 3 4 e)
CLIPS> 
12.16.4.12.2 Inserting Fields
Allows the insertion of one or more new values in a multifield slot value before a specified field index. The index must greater than or equal to 1. A value of 1 inserts the new value(s) at the beginning of the slot's value. Any value greater than the length of the slot's value appends the new values to the end of the slot's value.
External Interface Syntax
(slotinsert$ <instance-expression> <mv-slot-name>
	<index> <expression>+)
Internal Interface Syntax
(directslotinsert$ <mv-slot-name> <index> <expression>+)
Example
CLIPS> (initialize-instance a)
[a]
CLIPS> (slot-insert$ a mfs 2 4 2 3 4)
(a 4 2 3 4 b c d e)
CLIPS> 
12.16.4.12.3 Deleting Fields
Allows the deletion of a range of fields in a multifield slot value. The range indices must be from 1..n, where n is the number of fields in the multifield slot's original value and n > 0.
External Interface Syntax
(slotdelete$ <instance-expression> <mv-slot-name>
	<range-begin> <range-end>)
Internal Interface Syntax
(directslotdelete$ <mv-slot-name> <range-begin> <range-end>)
Example
CLIPS> (initialize-instance a)
[a]
CLIPS> (slot-delete$ a mfs 2 4)
(a e)
CLIPS> 
12.17 DEFMODULE FUNCTIONS
The following functions provide ancillary capabilities for the defmodule construct.
12.17.1 Getting the List of Defmodules
The function get-defmodule-list returns a multifield value containing the names of all defmodules that are currently defined.
Syntax
(getdefmodulelist)
Example
CLIPS> (clear)
CLIPS> (get-defmodule-list)
(MAIN)
CLIPS> (defmodule A)
CLIPS> (defmodule B)
CLIPS> (get-defmodule-list)
(MAIN A B)
CLIPS>
12.17.2 Setting the Current Module
This function sets the current module. It returns the name of the previous current module. If an invalid module name is given, then the current module is not changed and the name of the current module is returned.
Syntax
(setcurrentmodule <defmodule-name>)
12.17.3 Getting the Current Module
This function returns the name of the current module.
Syntax
(getcurrentmodule)
12.18 SEQUENCE EXPANSION
In the past, there has been no distinction between single-field and multifield variable references within function calls (as opposed to declaring variables for function parameters or variables used for pattern-matching). For example, for the rule:
                      
(defrule expansion
  (foo $?b)
  =>
  (printout t ?b crlf)
  (printout t $?b crlf))

would have given identical output for both printout statements in version 5.1 of CLIPS.

CLIPS> (assert (foo a b c))
<Fact-0>
CLIPS> (run)
(a b c)
(a b c)
CLIPS> 

Multifield variable references within function calls are now treated differently. The $ acts as a "sequence expansion" operator and has special meaning when applied to a global or local variable reference within the argument list of a function call. The $ means to take the fields of the multifield value referenced by the variable and treat them as separate arguments to the function as opposed to passing a single multifield value argument.

For example, using sequence expansion with the expansion rule would give the following output:

CLIPS> (assert (foo a b c))
<Fact-0>
CLIPS> (run)
(a b c)
abc
CLIPS> 

Using sequence expansion, the two printout statements on the RHS of the expansion rule are equivalent to:

(printout t (create$ a b c) crlf)
(printout t a b c crlf)

The $ operator also works with global variables. For example:
                      
CLIPS> (defglobal ?*x* = (create$ 3 4 5))
CLIPS> (+ ?*x*)
ERROR: Function + expected at least 2 argument(s)
CLIPS> (+ $?*x*)
12
CLIPS>

The sequence expansion operator is particularly useful for generic function methods.  Consider the ease now of defining a general addition function for strings.

(defmethod + (($?any STRING))
   (str-cat $?any))

By default, sequence expansion is disabled. This allows previously existing CLIPS programs to work correctly with version 6.0 of CLIPS. The behavior can be enabled using the set-sequence-operator-recognition function described in section 12.18.3. Old CLIPS code should be changed so that it works properly with sequence expansion enabled.
12.18.1 Sequence Expansion and Rules
Sequence expansion is allowed on the LHS of rules, but only within function calls. If a variable is specified in a pattern as a single or multifield variable, then all other references to that variable that are not within function calls must also be the same. For example, the following rule is not allowed

(defrule bad-rule-1
  (pattern $?x ?x $?x)
  =>)

The following rules illustrate appropriate use of sequence expansion on the LHS of rules.

(defrule good-rule-1
  (pattern $?x&:(> (length$ ?x) 1))
  (another-pattern $?y&:(> (length$ ?y) 1))
  (test (> (+ $?x) (+ $?y)))
  =>) 

The first and second patterns use the length$ function to determine that the multifields bound to ?x and ?y are greater than 1. Sequence expansion is not used to pass ?x and ?y to the length$ function since the length$ function expects a single argument of type multifield. The test CE calls the + function to determine the sum of the values bound to ?x and ?y. Sequence expansion is used for these function calls since the + function expects two or more arguments with numeric data values.

Sequence expansion has no affect within an assert, modify, or duplicate; however, it can be used with other functions on the RHS of a rule.
12.18.2 Multifield Expansion Function
The $ operator is merely a shorthand notation for the expand$ function call. For example, the function calls

(printout t $?b crlf) 

and

(printout t (expand$ ?b) crlf)

are identical.
Syntax
(expand$ <multifield-expression>)

The expand$ function is valid only within the argument list of a function call. The expand$ function (and hence sequence expansion) cannot be used as an argument to the following functions: expand$, return, progn, while, if, progn$, switch, loopforcount, assert, modify, duplicate and objectpatternmatchdelay.
12.18.3 Setting The Sequence Operator Recognition Behavior
This function sets the sequence operator recognition behavior. When this behavior is disabled (FALSE by default), multifield variables found in function calls are treated as a single argument. When this behaviour is enabled, multifield variables are expanded and passed as separate arguments in the function call. This behavior should be set before an expression references a multifield variable is encountered (i.e. changing the behavior does not retroactively change the behavior for previously encountered expressions). The return value for this function is the old value for the behavior.
Syntax
(setsequenceoperatorrecognition <boolean-expression>)
12.18.4 Getting The Sequence Operator Recognition Behavior
This function returns the current  value of the sequence operator recognition behavior (TRUE or FALSE).
Syntax
(getsequenceoperatorrecognition)
12.18.5 Sequence Operator Caveat
CLIPS normally tries to detect as many constraint errors as possible for a function call at parse time, such as bad number of arguments or types.  However, if the sequence expansion operator is used in the function call, all such checking is delayed until run-time (because the number and types of arguments can change for each execution of the call.) For example:

CLIPS> (deffunction foo (?a ?b))
CLIPS> (deffunction bar ($?a) (foo ?a))
ERROR: Function foo expected exactly 2 argument(s)

ERROR:
(deffunction bar
  ($?a)
  (foo ?a)
CLIPS> (deffunction bar ($?a) (foo $?a))
CLIPS> (bar 1)
ERROR: Function foo expected exactly 2 argument(s)
FALSE
CLIPS> (bar 1 2)
FALSE
CLIPS> 

Section 13 - Commands
This section describes commands primarily intended for use from the top-level command prompt. These commands may also be used from constructs and other places where functions can be used.
13.1 ENVIRONMENT COMMANDS
The following commands control the CLIPS environment.
13.1.1 Loading Constructs From A File
.Loads the constructs stored in the file specified by <file-name> into the environment. If the compilations item is being watched  (see section 13.2), then an informational message (including the type and name of the construct) will be displayed for each construct loaded. If the compilations item is not being watched, then a character is printed for each construct loaded ("*" for defrule, "$" for deffacts, "%" for deftemplate, ":" for defglobal, "!" for deffunction, "^" for defgeneric, "&" for defmethod, "#" for defclass, "~" for defmessage-handler, "@" for definstances, and "+" for defmodule). This function returns TRUE if the file was successfully loaded, otherwise FALSE is returned.
Syntax
(load <file-name>)
13.1.2 Saving All Constructs To A File
Saves all of the constructs (defrules, deffacts, deftemplates, etc.) in the current environment into the file specified by <file-name>. Note that deffunctions and generic functions are saved twice to the file. Because it is possible to create circular references among deffunctions and generic functions by redefining them, a forward declaration (containing no actions) of the functions is saved first to the file, and then the actual declaration (containing the actions) is saved. This function returns TRUE if the file was successfully saved, otherwise FALSE is returned. This function uses the pretty-print forms of the constructs.  If pretty-printing has been disabled by the conservemem command, then the save command will have no output.
Syntax
(save <file-name>)
13.1.3 Loading a Binary Image
Loads the constructs stored in the binary file specified by <file-name> into the environment. The specified file must have been created by bsave. Loading a binary image is quicker than using the load command to load a ASCII text file. A bload clears all constructs from the current CLIPS environment (as well as all facts and instances). Bload can be called at any time unless some constructs that bload will affect are in use (e.g. a deffunction is currently executing). The only constructive/destructive operation that can occur after a bload is the clear command or the bload command (which clears the current binary image). This means that constructs cannot be loaded or deleted while a bload is in effect. In order to add constructs to a binary image, the original ASCII text file must be reloaded, the new constructs added, and then another bsave must be performed. This function has no return value. This function returns TRUE if the file was successfully bloaded, otherwise FALSE is returned.

Binary images can be loaded into different compile-time configurations of CLIPS, as long as the same version of CLIPS is used and all the functions and constructs needed by the binary image are supported. In addition, binary images should theoretically work across different hardware platforms if internal data representations are equivalent (e.g. same integer size, same byte order, same floating-point format, etc). However, it is NOT recommended that this be attempted.
Syntax
(bload <file-name>)
13.1.4 Saving a Binary Image
Saves all of the constructs in the current environment into the file specified by <file-name>. The save file is written using a binary format which results in faster load time. The save file must be loaded via the bload command. A bsave may be performed at any time (except when a bload is in effect). The pretty print representation of a construct is not saved with a binary image (thus, commands like ppdefrule will show no output for any of the rules associated with the binary image). In addition, constraint information associated with constructs is not saved to the binary image unless dynamic constraint checking is enabled (using the setdynamicconstraintchecking command). This function returns TRUE if the file was successfully bsaved, otherwise FALSE is returned.
Syntax
(bsave <file-name>)
13.1.5 Clearing CLIPS
Clears CLIPS. Removes all constructs  and all associated data structures (such as facts and instances) from the CLIPS environment. A clear may be performed safely at any time, however, certain constructs will not allow themselves to be deleted while they are in use. For example, while deffacts are being reset (by the reset command), it is not possible to remove them using the clear command. Note that the clear command does not effect many environment characteristics (such as the current conflict resolution strategy). This function has no return value.
Syntax
(clear)
13.1.6 Exiting CLIPS
Quits CLIPS. This function has no return value.
Syntax
(exit)
13.1.7 Resetting CLIPS
Resets CLIPS. Removes all activations from the agenda, all facts from the fact-list and all instances of user-defined classes, then assigns global variables their initial values, asserts all facts listed in deffacts statements into the fact-list, creates all instances listed in definstances statements, sets the current module to the MAIN module and automatically focuses on the same module. Incremental reset is supported for rules. This means that rules can be activated from facts that were asserted before the rule was defined without performing a reset. A reset can be performed while rules are executing. Note that the reset command does not effect many environment characteristics (such as the current conflict resolution strategy). This function has no return value.
Syntax
(reset)
13.1.8 Executing Commands From a File
Allows "batch" processing of CLIPS interactive commands by replacing standard input with the contents of a file. Any command or function can be used in a batch file, as well as construct definitions and responses to read or readline function calls. The load command should be used in batch files rather than defining constructs directly. The load command expects only constructs and hence moves to the next construct when an error occurs. The batch command, however, moves on until it finds the next construct or command (and in the case of a construct this is likely to generate more errors as the remaining commands and functions in the construct are parsed). This function returns TRUE if the batch file was successfully executed, otherwise FALSE is returned. Note that the batch command operates by replacing standard input rather than by immediately executing the commands found in the batch file. In effect, if you execute a batch command from the RHS of a rule, the commands in that batch file will not be processed until control is returned to the top-level prompt.
Syntax
(batch <file-name>)
13.1.9 Determining CLIPS Compilation Options
Generates a textual description of the settings of the CLIPS compiler flags. This function has no return value.
Syntax
(options)
13.1.10 Calling the Operating System
The system function allows a call to the operating system. It is patterned after the system function provided to C on most UNIX systems. This function has no return value.
Syntax
(system <lexeme-expression>*)
Example
(defrule print-directory
   (print-directory  ?directory)
   =>
   (system "dir " ?directory));      Note space => "dir<space>"

Note that any spaces needed for a proper parsing of the system command must be added by the user in the call to system. Also note that the system command is not guaranteed to execute (e.g., the operating system may not have enough memory to spawn a new process).

Portability Note
Not all operating systems/compilers provide this function. The code is stored in the sysdep.c file, and the default coding for generic CLIPS is a nonfunctional stub that will compile on any machine. On some machines (such as an IBM PC running DOS), there may be insufficient memory available to spawn a subprocess to execute the system command. In such a case, the command will not be executed and the system command will return with no action taken.
13.1.11 Setting The Auto-Float Dividend Behavior
This function sets auto-float dividend behavior. When this behavior is enabled (TRUE by default) the dividend of the division function is automatically converted to a floating point number. The return value for this function is the old value for the behavior.
Syntax
(setautofloatdividend <boolean-expression>)
13.1.12 Getting The Auto-Float Dividend Behavior
This function returns the current  value of the auto-float dividend behavior (TRUE or FALSE).
Syntax
(getautofloatdividend)
13.1.13 Setting the Dynamic Constraint Checking Behavior
This function sets dynamic constraint checking behavior. When this behavior is disabled (FALSE by default), newly created data objects (such as deftemplate facts and instances) do not have their slot values checked for constraint violations. When this behavior is enabled (TRUE), the slot values are checked for constraint violations. The return value for this function is the old value for the behavior. Constraint information is not saved when using the bload and constructstoc command if dynamic constraint checking is disabled.
Syntax
(setdynamicconstraintchecking <boolean-expression>)
13.1.14 Getting the Dynamic Constraint Checking Behavior
This function returns the current value of the dynamic constraint checking behavior (TRUE or FALSE).
Syntax
(getdynamicconstraintchecking)
13.1.15 Setting the Static Constraint Checking Behavior
This function sets static constraint checking behavior. When this behavior is disabled (FALSE), constraint violations are not checked when function calls and constructs are parsed. When this behavior is enabled (TRUE by default), constraint violations are checked when function calls and constructs are parsed. The return value for this function is the old value for the behavior.
Syntax
(setstaticconstraintchecking <boolean-expression>)
13.1.16 Getting the Static Constraint Checking Behavior
This function returns the current value of the static constraint checking behavior (TRUE or FALSE).
Syntax
(getstaticconstraintchecking)
13.1.17 Finding Symbols
This command displays all symbols currently defined in CLIPS which contain a specified substring. This command has no return value.
Syntax
(apropos <lexeme>)
Example
CLIPS> (apropos pen)
dependents
mv-append
open
dependencies
CLIPS>

Portability Note
If the ANSI_COMPILER flag has been set to 0, then apropos only shows those symbols that begin with the specified substring.
13.2 DEBUGGING COMMANDS
The following commands control the CLIPS debugging features.
13.2.1 Generating Trace Files
Sends all information normally sent to the logical names wclips, wdialog, wdisplay, werror, wwarning, wtrace, and stdout to <file-name> as well as to their normal destination. Additionally, all information received from logical name stdin is also sent to <file-name> as well as being returned by the requesting function. This function returns TRUE if the dribble file was successfully opened, otherwise FALSE is returned.
Syntax
(dribbleon <file-name>)
13.2.2 Closing Trace Files
Stops sending trace information to the dribble file. This function returns TRUE if the dribble file was successfully closed, otherwise FALSE is returned.
Syntax
(dribbleoff)
13.2.3 Enabling Watch Items
This function causes messages to be displayed when certain CLIPS operations take place.
Syntax
(watch <watch-item>)

<watch-item> ::= all |
                 compilations | 
                 statistics |
                 focus |
                 messages |
                 deffunctions <deffunction-name>* |
                 globals <global-name>* |
                 rules <rule-name>* |
                 activations <rule-name>* |
                 facts <deftemplate-name>* |
                 instances <class-name>* |
                 slots <class-name>* |
                 message-handlers <handler-spec-1>* 
                                 [<handler-spec-2>]) |
                 generic-functions <generic-name>* |
                 methods <method-spec-1>* [<method-spec-2>]

<handler-spec-1> ::= <class-name> 
                                <handler-name> <handler-type>
<handler-spec-2> ::= <class-name> 
                              [<handler-name> [<handler-type>]]

<method-spec-1> ::= <generic-name> <method-index>
<method-spec-2> ::= <generic-name> [<method-index>]

If compilations are watched, the progress of construct definitions will be displayed.

If facts are watched, all fact assertions and retractions will be displayed. Optionally, facts associated with individual deftemplates can be watched by specifying one or more deftemplate names.

If rules are watched, all rule firings will be displayed. If activations are watched, all rule activations and deactivations will be displayed. Optionally, rule firings and activations associated with individual defrules can be watched by specifying one or more defrule names. If statistics are watched, timing information along with other information (average number of facts, average number of activations, etc.) will be displayed after a run. Note that the number of rules fired and timing information is not printed unless this item is being watch. If focus is watched, then changes to the current focus will be displayed.

If globals are watched, variable assignments to globals variables will be displayed. Optionally, variable assignments associated with individual defglobals can be watched by specifying one or more defglobal names. If deffunctions are watched, the start and finish of deffunctions will be displayed. Optionally, the start and end display associated with individual deffunctions can be watched by specifying one or more deffunction names.

If genericfunctions are watched, the start and finish of generic functions will be displayed. Optionally, the start and end display associated with individual defgenerics can be watched by specifying one or more defgeneric names. If methods are watched, the start and finish of individual methods within a generic function will be displayed. Optionally, individual methods can be watched by specifying one or more methods using a defgeneric name and a method index. When the method index is not specified, then all methods of the specified defgeneric will be watched. 

If instances are watched, creation and deletion of instances will be displayed. If slots are watched, changes to any instance slot values will be displayed. Optionally, instances and slots associated with individual concrete defclasses can be watched by specifying one or more concrete defclass names. If messagehandlers are watched, the start and finish of individual message-handlers within a message will be displayed. Optionally, individual message-handlers can be watched by specifying one or more message-handlers using a defclass name, a message-handler name, and a message-handler type. When the message-handler name and message-handler type are not specified, then all message-handlers for the specified class will be watched. When the message-handler type is not specified, then all message-handlers for the specified class with the specified message-handler name will be watched. If messages are watched, the start and finish of messages will be displayed.

For the watch items that allow individual constructs to be watched, if no constructs are specified, then all constructs of that type will be watched. If all constructs associated with a watch item are being watched, then newly defined constructs of the same type will also be watched. A construct retains its old watch state if it is redefined. If all is watched, then all other watch items will be watched. By default, only compilations are watched. The watch function has no return value.
Example
CLIPS> (watch rules)
CLIPS>
13.2.4 Disabling Watch Items
This function disables the effect of the watch command.
Syntax
(unwatch watch-item>)

This command is identical to the watch command with the exception that it disables watch items rather than enabling them. This function has no return value.
Example
CLIPS> (unwatch all)
CLIPS>
13.2.5 Viewing the Current State of Watch Items
This command displays the current state of watch items.
Syntax
(listwatchitems [<watch-item>])

This command displays the current state of all watch items. If called without the <watch-item> argument, the global watch state of all watch items is displayed. If called with the <watch-item> argument, the global watch state for that item is displayed followed by the individual watch states for each item of the specified type which can be watched. This function has no return value.
Example
CLIPS> (list-watch-items)
facts = off
instances = off
slots = off
rules = off
activations = off
messages = off
message-handlers = off
generic-functions = off
methods = off
deffunctions = off
compilations = on
statistics = off
globals = off
focus = off
CLIPS> (list-watch-items facts)
facts = off
MAIN:
   initial-fact = off
CLIPS>
13.3 DEFTEMPLATE COMMANDS
The following commands manipulate deftemplates.
13.3.1 Displaying the Text of a Deftemplate
Displays the text of a given deftemplate. This function has no return value.
Syntax
(ppdeftemplate <deftemplate-name>)
13.3.2 Displaying the List of Deftemplates
Displays the names of all deftemplates. This function has no return value.
Syntax
(listdeftemplates [<module-name>])

If <module-name> is unspecified, then the names of all deftemplates in the current module are displayed. If <module-name> is specified, then the names of all deftemplates in the specified module are displayed. If <module-name> is the symbol *, then the names of all deftemplates in all modules are displayed.
13.3.3 Deleting a Deftemplate
This function deletes a previously defined deftemplate.
Syntax
(undeftemplate <deftemplate-name>)

If the deftemplate is in use (for example by a fact or a rule), then the deletion will fail. Otherwise, no further uses of the deleted deftemplate are permitted (unless redefined). If the symbol * is used for <deftemplate-name>, then all deftemplates will be deleted (unless there is a deftemplate named *). This function has no return value.
13.4 FACT COMMANDS
The following commands display information about facts.
13.4.1 Displaying the Fact-List
Displays facts stored in the fact-list. 
Syntax
(facts [<module-name>]
       [<start-integer-expression> 
        [<end-integer-expression> 
         [<max-integer-expression>]]])

If <module-name> is not specified, then only facts visible to the current module will be displayed. If <module-name> is specified, then only facts visible to the specified module are displayed. If the symbol * is used for <module-name>, then facts from any module may be displayed. If the start argument is specified, only facts with fact-indices greater than or equal to this argument are displayed. If the end argument is specified, only facts with fact-indices less than or equal to this argument are displayed. If the max argument is specified, then no facts will be displayed beyond the specified maximum number of facts to be displayed. This function has no return value.
13.4.2 Loading Facts From a File
This function will assert a file of information as facts into the CLIPS fact-list. It can read files created with save-facts or any ASCII text file. Each fact should begin with a left parenthesis and end with a right parenthesis. Facts may span across lines and can be written in either ordered or deftemplate format. This function returns TRUE if the fact file was successfully loaded, otherwise FALSE is returned.
Syntax
(loadfacts <file-name>)
13.4.3 Saving The Fact-List To A File
This function saves all of the facts in the current fact-list into the file specified by <file-name>. External-address and fact-address fields are saved as strings. Instance-address fields are converted to instance-names. Optionally, the scope of facts to be saved can be specified. If <save-scope> is the symbol visible, then all facts visible to the current module are saved. If <save-scope> is the symbol local, then only those facts with deftemplates defined in the current module are saved. If <save-scope> is not specified, it defaults to local. If <save-scope> is specified, then one or more deftemplate names may also be specified. In this event, only those facts with associated with a corresponding deftemplate in the specified list will be saved. This function returns TRUE if the fact file was successfully saved, otherwise FALSE is returned.
Syntax
(savefacts <file-name> [<save-scope> <deftemplate-names>*])
                      
<save-scope> ::= visible | local
13.4.4 Setting the Duplication Behavior of Facts
This function sets fact duplication behavior. When this behavior is disabled (FALSE  by default), asserting a duplicate of a fact already in the fact-list produces no effect. When enabled (TRUE), the duplicate fact is asserted with a new fact-index. The return value for this function is the old value for the behavior.
Syntax
(setfactduplication <boolean-expression>)

Example
CLIPS> (get-fact-duplication)
FALSE
CLIPS> (watch all)
CLIPS> (assert (a))
==> f-0     (a)
<Fact-0>
CLIPS> (assert (a))
FALSE
CLIPS> (set-fact-duplication TRUE)
FALSE
CLIPS> (assert (a))
==> f-1     (a)
<Fact-1>
CLIPS>
13.4.5 Getting the Duplication Behavior of Facts
This function returns the current value of the fact duplication behavior (TRUE or FALSE).
Syntax
(getfactduplication)

13.5 DEFFACTS COMMANDS
The following commands manipulate deffacts.
13.5.1 Displaying the Text of a Deffacts
Displays the text of a given deffacts. This function has no return value.
Syntax
(ppdeffacts <deffacts-name>)
13.5.2 Displaying the List of Deffacts
Displays the names of all deffacts stored in the CLIPS environment.
Syntax
(listdeffacts [<module-name>])

If <module-name> is unspecified, then the names of all deffacts in the current module are displayed. If <module-name> is specified, then the names of all deffacts in the specified module are displayed. If <module-name> is the symbol *, then the names of all deffacts in all modules are displayed. This function has no return value.
13.5.3 Deleting a Deffacts
This function deletes a previously defined deffacts.
Syntax
(undeffacts <deffacts-name>)

All facts listed in the deleted deffacts construct will no longer be asserted as part of a reset. If the symbol * is used for <deffacts-name>, then all deffacts will be deleted (unless there exists a deffacts named *). The undeffacts command can be used to remove deffacts at any time. Exceptions: When deffacts are being reset as part of the reset command, they cannot be removed. This function has no return value.
13.6 DEFRULE COMMANDS
The following commands manipulate defrules.
13.6.1 Displaying the Text of a Rule
Displays the text of a given rule.
Syntax
(ppdefrule <rule-name>)

The pprule command can also be used for this purpose. This function has no return value. 
13.6.2 Displaying the List of Rules
Displays the names of all rules stored in the CLIPS environment.
Syntax
(listdefrules [<module-name>])

If <module-name> is unspecified, then the names of all defrules in the current module are displayed. If <module-name> is specified, then the names of all defrules in the specified module are displayed. If <module-name> is the symbol *, then the names of all defrules in all modules are displayed. This function has no return value.
13.6.3 Deleting a Defrule
This function deletes a previously defined defrule.
Syntax
(undefrule <defrule-name>)

If the defrule is in use (for example if it is firing), then the deletion will fail. If the symbol * is used for <defrule-name>, then all defrule will be deleted (unless there is a defrule named *). This function has no return value.
13.6.4 Displaying Matches for a Rule
For a specified rule, displays the list of the facts or instances which match each pattern in the rule's LHS, the partial matches for the rule, and the activations for the rule. Note that the patterns for which information is displayed include the patterns added or rearranged by CLIPS (see section 5.4.9). When listed as a partial match, the not, exists, and forall CEs are shown as a comma with no following pattern entity identifier (such as a fact-index or instance name). Other CEs contained within these CEs are not displayed as part of the information shown for a partial match. This function has no return value.
Syntax
(matches <rule-name>)
Example
The rule matches-example-1 has three patterns and none are added by CLIPS. Fact f-1 matches the first pattern, facts f-2 and f-3 match the the second pattern, and fact f-4 matches the third pattern. Issuing the run command will remove all of the rule's activations from the agenda.

CLIPS> (clear)
CLIPS> 
(defrule matches-example-1
   (a ?)
   (b ?)
   (c ?)
   =>)
CLIPS> (reset)
CLIPS> (assert (a 1) (b 1) (b 2) (c 1))
<Fact-4>
CLIPS> (facts)
f-0     (initial-fact)
f-1     (a 1)
f-2     (b 1)
f-3     (b 2)
f-4     (c 1)
For a total of 5 facts.
CLIPS> (run)
CLIPS>

The rule matches-example-2has four patterns of which one was added by CLIPS (the initial-fact pattern is added to the very beginning of the rule). The initial-fact, f-0, matches the first pattern, there are no matches for the second pattern (since there are no d facts), facts f-2 and f-3 match the third pattern, and fact f-4 matches the forth pattern.


CLIPS>
(defrule matches-example-2
   (not (d ?))
   (exists (b ?x)
           (c ?x))
   =>)
CLIPS>

Listing the matches for the rule matches-example-1 displays the matches for the patterns indicated previously. There are two partial matches which satisfy the first two patterns and two partial matches which satisfy all three patterns. Since all of the rule's activations were allowed to fire there are none listed.

CLIPS> (matches matches-example-1)
Matches for Pattern 1
f-1
Matches for Pattern 2
f-2
f-3
Matches for Pattern 3
f-4
Partial matches for CEs 1 - 2
f-1,f-3
f-1,f-2
Partial matches for CEs 1 - 3
f-1,f-2,f-4
f-1,f-3,f-4
Activations
 None
CLIPS>

Listing the matches for the rule matches-example-2 displays the matches for the patterns indicated previously. There is one partial match which satisfies the first two patterns (the initial-fact pattern and the not CE). The match for the second CE is indicated by the comma followed by no additional pattern entity identifier. There is also one partial match which satisfies the first three patterns (the initial-fact pattern, the not CE, and the exists CE). Again, the match for the third CE is indicated by a command followed by no additional pattern entity identifier. Since none of the rule's activations were allowed to fire they are listed. The list of activations will always be a subset of the partial matches for all of the rule's CEs.

CLIPS> (matches matches-example-2)
Matches for Pattern 1
f-0
Matches for Pattern 2
 None
Matches for Pattern 3
f-2
f-3
Matches for Pattern 4
f-4
Partial matches for CEs 1 - 2
f-0,
Partial matches for CEs 1 - 3
f-0,,
Activations
f-0,,
CLIPS> 
 13.6.5 Setting a Breakpoint for a Rule
Sets a breakpoint for a given rule. 
Syntax
(setbreak <rule-name>)

If a breakpoint is set for a given rule, execution will stop prior to executing that rule. At least one rule must fire before a breakpoint will stop execution. This function has no return value.
13.6.6 Removing a Breakpoint for a Rule
Removes a breakpoint for a given rule.
Syntax
(removebreak [<defrule-name>])

If no argument is given, then all breakpoints are removed. This function has no return value.
13.6.7 Displaying Rule Breakpoints
This command displays all the rules which have breakpoints set. This function has no return value.
Syntax
(showbreaks [<module-name>])

If <module-name> is unspecified, then the names of all rules having breakpoints in the current module are displayed. If <module-name> is specified, then the names of all rules having breakpoints in the specified module are displayed. If <module-name> is the symbol *, then the names of all rules having breakpoints in all modules are displayed.
13.6.8 Refreshing a Rule
Places all current activations of a given rule on the agenda. This function has no return value.
Syntax
(refresh <rule-name>)
13.6.9 Setting the Incremental Reset Behavior
This function sets the incremental reset behavior. When this behavior is enabled (TRUE by default), newly defined rules are updated based upon the current state of the fact-list. When disabled (FALSE), newly defined rules are only updated by facts added after the rule is defined. In order to prevent rules from obtaining an inconsistent state, the incremental reset behavior can only be changed when there are no rules currently defined. The return value for this function is the old value for the behavior.
Syntax
(setincrementalreset <boolean-expression>)
13.6.10 Getting the Incremental Reset Behavior
This function returns the current  value of the incremental reset behavior (TRUE or FALSE).
Syntax
(getincrementalreset)
13.6.11 Determining the Logical Dependencies of a Pattern Entity
The dependencies function lists the partial matches from which a pattern entity receives logical support. This function has no return value. 
Syntax
(dependencies <fact-or-instance-specifier>)

The term <fact-or-instance-specifier> includes variables bound on the LHS to fact-addresses or instance-addresses as described in section 5.4.1.8, the factindex of the desired fact (e.g. 3 for the fact labeled f-3), or the instance-name (e.g. [object]).
Example
(defrule list-dependencies
   ?f <- ($?)
   =>
   (dependencies ?f))
13.6.12 Determining the Logical Dependents of a Pattern Entity
The dependents function lists all pattern entities which receive logical support from a pattern entity. This function has no return value. 
Syntax
(dependents <fact-or-instance-specifier>)

The term <fact-or-instance-specifier> includes variables bound on the LHS to fact-addresses or instance-addresses as described in section 5.4.1.8, the factindex of the desired fact (e.g. 3 for the fact labeled f-3), or the instance-name (e.g. [object]).
Example
(defrule list-dependents
   ?f <- ($?)
   =>
   (dependents ?f))
13.7 AGENDA COMMANDS
The following commands manipulate agenda.
13.7.1 Displaying the Agenda
Displays all activations on the agenda. This function has no return value.
Syntax
(agenda [<module-name>])

If <module-name> is unspecified, then all activations in the current module (not the current focus) are displayed. If <module-name> is specified, then all activations on the agenda of the specified module are displayed. If <module-name> is the symbol *, then the activations on all agendas in all modules are displayed.
13.7.2 Running CLIPS
Starts execution of the rules. If the optional first argument is positive, execution will cease after the specified number of rule firings or when the agenda contains no rule activations. If there are no arguments or the first argument is a negative integer, execution will cease when the agenda contains no rule activations. If the focus stack is empty, then the MAIN module is automatically becomes the current focus. The run command has no additional effect if evaluated while rules are executing. Note that the number of rules fired and timing information is no longer printed after the completion of the run command unless the statistics item is being watched  (see section 13.2). If the rules item is being watched, then an informational message will be printed each time a rule is fired. This function has no return value.
Syntax
(run [<integer-expression>])
13.7.3 Focusing on a Group of Rules
Pushes one or more modules onto the focus stack. The specified modules are pushed onto the focus stack in the reverse order they are listed. The current module is set to the last module pushed onto the focus stack. The current focus is the top module of the focus stack. Thus (focus A B C) pushes C, then B, then A unto the focus stack so that A is now the current focus. Note that the current focus is different from the current module. Focusing on a module implies "remembering" the current module so that it can be returned to later. Setting the current module with the setcurrentmodule function changes it without remembering the old module. Before a rule executes, the current module is changed to the module in which the executing rule is defined (the current focus). This function returns a boolean value: FALSE if an error occurs, otherwise TRUE.
Syntax
(focus <module-name>+)
13.7.4 Stopping Rule Execution
The halt function may be used on the RHS of a rule to prevent further rule firing. It is called without arguments. After halt is called, control is returned from the run command. The agenda is left intact, and execution may be continued with a run command. This function has no return value.
Syntax
(halt)
13.7.5 Setting The Current Conflict Resolution Strategy
This function sets the current conflict resolution strategy. The default strategy is depth.
Syntax
(setstrategy <strategy>)

where <strategy> is either depth, breadth, simplicity, complexity, lex, mea, or random. The old conflict resolution strategy is returned. The agenda will be reordered to reflect the new conflict resolution strategy.
13.7.6 Getting The Current Conflict Resolution Strategy
This function returns the current conflict resolution strategy (depth, breadth, simplicity, complexity, lex, mea, or random).
Syntax
(getstrategy)
13.7.7 Listing the Module Names on the Focus Stack
The command list-focus-stack list all module names on the focus stack. The first name listed is the current focus.
Syntax
(listfocusstack)
13.7.8 Removing all Module Names from the Focus Stack
The command clear-focus-stack removes all module names from the focus stack.
Syntax
(clearfocusstack)
13.7.9 Setting the Salience Evaluation Behavior
This function sets the salience evaluation behavior. By default, salience values are only evaluated when a rule is defined. 
Syntax
(setsalienceevaluation <value>)

where <value> is either when-defined, when-activated, or every-cycle. The return value for this function is the old value for salience evaluation. The value when-defined forces salience evaluation at the time of rule definition. The value when-activation forces salience evaluation at the time of rule definition and upon being activated. The value every-cycle forces evaluation at the time of rule definition, upon being activated, and after every rule firing.
13.7.10 Getting the Salience Evaluation Behavior
This function returns the current salience evaluation behavior (when-defined, when-activated, or every-cycle).
Syntax
(getsalienceevaluation)
13.7.11 Refreshing the Salience Value of Rules on the Agenda
This function forces reevaluation of saliences of rules on the agenda regardless of the current salience evaluation setting. This function has no return value.
Syntax
(refreshagenda [<module-name>])

If <module-name> is unspecified, then the agenda in the current module is refreshed. If <module-name> is specified, then the agenda in the specified module is refreshed. If <module-name> is the symbol *, then the agenda in every module is refreshed.
13.8 DEFGLOBAL COMMANDS
The following commands manipulate defglobals.
13.8.1 Displaying the Text of a Defglobal
Displays the text required to define a given global variable. Note that unlike other constructs such as deffacts and definstances, defglobal definitions have no name associated with the entire construct. The variable name passed to ppdefglobal should not include the question mark or the asterisks (e.g. x is the variable name for the global variable ?*x*). This function has no return value.
Syntax
(ppdefglobal <global-variable-name>)
13.8.2 Displaying the List of Defglobals
Displays the names of all defglobals. This function has no return value.
Syntax
(listdefglobals [<module-name>])

If <module-name> is unspecified, then the names of all defglobals in the current module are displayed. If <module-name> is specified, then the names of all defglobals in the specified module are displayed. If <module-name> is the symbol *, then the names of all defglobals in all modules are displayed.
13.8.3 Deleting a Defglobal
This function deletes a previously defined defglobal.
Syntax
(undefglobal <defglobal-name>)

If the defglobal is in use (for example if it is referred to in a deffunction), then the deletion will fail. Otherwise, no further uses of the deleted defglobal are permitted (unless redefined). If the symbol * is used for <defglobal-name>, then all defglobals will be deleted (unless there is a defglobal named *). This function has no return value.
13.8.4 Displaying the Values of Global Variables
Displays the names and current values of all defglobals. This function has no return value.
Syntax
(showdefglobals [<module-name>])

If <module-name> is unspecified, then the names and values of all defglobals in the current module are displayed. If <module-name> is specified, then the names and values of all defglobals in the specified module are displayed. If <module-name> is the symbol *, then the names and values of all defglobals in all modules are displayed.
13.8.5 Setting the Reset Behavior of Global Variables
This function sets the reset global variables behavior. When this behavior is enabled (TRUE by default) global variables are reset to their original values when the reset command is performed. The return value for this function is the old value for the behavior.
Syntax
(setresetglobals <boolean-expression>)
13.8.6 Getting the Reset Behavior of Global Variables
This function returns the current  value of the reset global variables behavior (TRUE or FALSE).
Syntax
(getresetglobals)
13.9 DEFFUNCTION COMMANDS
The following commands manipulate deffunctions.
13.9.1 Displaying the Text of a Deffunction
Displays the text of a given deffunction. This function has no return value.
Syntax
(ppdeffunction <deffunction-name>)
13.9.2 Displaying the List of Deffunctions
Displays the names of all deffunctions stored in the CLIPS environment. This function has no return value.
Syntax
(listdeffunctions)
13.9.3 Deleting a Deffunction
This function deletes a previously defined deffunction.
Syntax
(undeffunction <deffunction-name>)

If the symbol * is used for <deffunction-name>, then all deffunctions will be deleted (unless there exists a deffunction called *). The undeffunction command can be used to remove deffunctions at any time. Exceptions: A deffunction may not be deleted when it is executing or when there is still a reference to it in another loaded construct, such as a rule RHS. This function has no return value.
13.10 GENERIC FUNCTION COMMANDS
The following commands manipulate generic functions.
13.10.1 Displaying the Text of a Generic Function Header
Displays the text of a given generic function header. This function has no return value.
Syntax
(ppdefgeneric <generic-function-name>)
13.10.2 Displaying the Text of a Generic Function Method
Displays the text of a given method.
Syntax
(ppdefmethod <generic-function-name> <index>)

where <index> is the method index (see section 8.4.2). This function has no return value.
13.10.3 Displaying the List of Generic Functions
Displays the names of all generic functions stored in the CLIPS environment. This function has no return value.
Syntax
(listdefgenerics)
13.10.4 Displaying the List of Methods for a Generic Function
If no name is given, this function lists all generic function methods in the CLIPS environment. If a name is given, then only the methods for the named generic function are listed. The methods are listed in decreasing order of precedence (see section 8.5.2) for each generic function. Method indices can be seen using this function. This function has no return value.
Syntax
(listdefmethods [<generic-function-name>])
13.10.5 Deleting a Generic Function
This function deletes a previously defined generic function.
Syntax
(undefgeneric <generic-function-name>)

If the symbol * is used for <generic-function-name>, then all generic functions will be deleted (unless there exists a generic function called *). This function removes the header and all methods for a generic function. The undefgeneric command can be used to remove generic functions at any time. Exceptions: A generic function may not be deleted when any of its methods are executing or when there is still a reference to it in another loaded construct, such as a rule RHS. This function has no return value.
13.10.6 Deleting a Generic Function Method
This function deletes a previously defined generic function method.
Syntax
(undefmethod <generic-function-name> <index>)

where <index> is the index of the method to be deleted for the generic function. If the symbol * is used for <index>, then all the methods for the generic function will be deleted. (This is different from the undefgeneric command because the header is not removed.)  If * is used for <generic-function-name>, then * must also be specified for <index>, and all the methods for all generic functions will be removed. This function removes the specified method for a generic function, but even if the method removed is the last one, the generic function header is not removed. The undefmethod command can be used to remove methods at any time. Exceptions: A method may not be deleted when it or any of the other methods for the same generic function are executing. This function has no return value.
13.10.7 Previewing a Generic Function Call
This debugging function lists all applicable methods for a particular generic function call in order of decreasing precedence (see section 8.5.2). The function listdefmethods is different in that it lists all methods for a generic function.
Syntax
(previewgeneric <generic-function-name> <expression>*)
 
This function does not actually execute any of the methods, but any side-effects of evaluating the generic function arguments and any query parameter restrictions (see section 8.4.3) in methods do occur. The output for the first example in section 8.5.2 would be as follows:

Example
CLIPS> (preview-generic + 4 5)
+ #7  (INTEGER <qry>) (INTEGER <qry>)
+ #8  (INTEGER <qry>) (NUMBER)
+ #3  (INTEGER) (INTEGER)
+ #4  (INTEGER) (NUMBER)
+ #6  (NUMBER) (INTEGER <qry>)
+ #2  (NUMBER) (INTEGER)
+ #SYS1  (NUMBER) (NUMBER) ($? NUMBER)
+ #5  (NUMBER) (NUMBER) ($? PRIMITIVE)
CLIPS> 
13.11 CLIPS OBJECT-ORIENTED LANGUAGE (COOL) COMMANDS
The following commands manipulate elements of COOL.
13.11.1 Class Commands
The following commands manipulate defclasses.
13.11.1.1 Displaying the Text of a Defclass
Displays the text of a given defclass. This function has no return value.
Syntax
(ppdefclass <class-name>)
13.11.1.2 Displaying the List of Defclasses
Displays the names of all defclasses stored in the CLIPS environment. This function has no return value.
Syntax
(listdefclasses)
13.11.1.3 Deleting a Defclass
This function deletes a previously defined defclass and all its subclasses from the CLIPS environment.
Syntax
(undefclass <class-name>)

If the symbol * is used for <class-name>, then all defclasses will be deleted (unless there exists a defclass called *). The undefclass command can be used to remove defclasses at any time. Exceptions: A defclass may not be deleted if it has any instances or if there is still a reference to it in another loaded construct, such as a generic function method. This function has no return value.
13.11.1.4 Examining a Class
This function provides a verbose description of a class including: abstract role (whether direct instances can be created or not), direct superclasses and subclasses, class precedence list, slots with all their facets and sources, and all recognized messagehandlers. This function has no return value.
Syntax
(describeclass <class-name>)
Example
CLIPS>  
(defclass CHILD (is-a USER)
  (role abstract)
  (multislot parents (cardinality 2 2))
  (slot age (type INTEGER)
            (range 0 18))
  (slot sex (access read-only)
            (type SYMBOL)
            (allowed-symbols male female)
            (storage shared)))
CLIPS>  
(defclass BOY (is-a CHILD)
  (slot sex (source composite)
            (default male)))
CLIPS>  
(defmessage-handler BOY play ()
   (printout t "The boy is now playing..." crlf))
CLIPS> (describe-class CHILD)
====================================================================
********************************************************************
Abstract: direct instances of this class cannot be created.

Direct Superclasses: USER
Inheritance Precedence: CHILD USER OBJECT
Direct Subclasses: BOY
--------------------------------------------------------------------
SLOTS   : FLD DEF PRP ACC STO MCH SRC VIS CRT OVRD-MSG    SOURCE(S)
parents : MLT STC INH RW  LCL RCT EXC PRV NIL put-parents CHILD
age     : SGL STC INH RW  LCL RCT EXC PRV NIL put-age     CHILD
sex     : SGL STC INH  R  SHR RCT EXC PRV NIL NIL         CHILD

Constraint information for slots:

SLOTS   : SYM STR INN INA EXA FTA INT FLT
parents :  +   +   +   +   +   +   +   +  RNG:[-oo..+oo] CRD:[2..2]
age     :                          +      RNG:[0..18] 
sex     :  #                              
-------------------------------------------------------------------
Recognized message-handlers:
init primary in class USER
delete primary in class USER
print primary in class USER
direct-modify primary in class USER
message-modify primary in class USER
direct-duplicate primary in class USER
message-duplicate primary in class USER
********************************************************************
====================================================================
CLIPS> 

The following table explains the fields and their possible values in the slot descriptions:

Field
Values
Explanation
FLD
SGL/MLT
Field type (single-field or multifield)
DEF
STC/DYN/NIL
Default value (static, dynamic or none)
PRP
INH/NIL
Propagation to subclasses (Inheritable or not inheritable)
ACC
RW/R/INT
Access (read-write, read-only or initialize-only)
STO
LCL/SHR
Storage (local or shared)
MCH
RCT/NIL
Pattern-match (reactive or non-reactive)
SRC
CMP/EXC
Source type (composite or exclusive)
VIS
PUB/PRV
Visibility (public or private)
CRT
R/W/RW/NIL
Automatically created accessors (read, write, read-write or none)
OVRD-MSG
<message-name>
Name of message sent for slot-overrides in make-instance, etc.
SOURCE(S)
<class-name>+
Source of slot (more than one class for composite)

In the constraint information summary for the slots, each of the columns shows one of the primitive data types . A + in the column means that any value of that type is allowed in the slot.  A # in the column means that some values of that type are allowed in the slot. Range and cardinality constraints are displayed to the far right of each slot's row. The following table explains the abbreviations used in the constraint information summary for the slots:

Abbreviation
Explanation
SYM
Symbol
STR
String
INN
Instance Name
INA
Instance Address
EXA
External Address
FTA
Fact Address
INT
Integer
FLT
Float
RNG
Range
CRD
Cardinality
13.11.1.5 Examining the Class Hierarchy
This function provides a rudimentary display of the inheritance relationships between a class and all its subclasses. Indentation indicates a subclass. Because of multiple inheritance, some classes may appear more than once. Asterisks mark classes which are direct subclasses of more than one class. With no arguments, this function starts with the root class OBJECT. This function has no return value.
Syntax
(browseclasses [<class-name>])
Example
CLIPS> (defclass a (is-a USER))
CLIPS> (defclass b (is-a USER))
CLIPS> (defclass c (is-a a b))
CLIPS> (defclass d (is-a USER))
CLIPS> (defclass e (is-a c d))
CLIPS> (defclass f (is-a e))
CLIPS> (browse-classes)
OBJECT
  PRIMITIVE
    NUMBER
      INTEGER
      FLOAT
    LEXEME
      SYMBOL
      STRING
    MULTIFIELD
    ADDRESS
      EXTERNAL-ADDRESS
      FACT-ADDRESS
      INSTANCE-ADDRESS *
    INSTANCE
      INSTANCE-ADDRESS *
      INSTANCE-NAME
  USER
    INITIAL-OBJECT
    a
      c *
        e *
          f
    b
      c *
        e *
          f
    d
      e *
        f
CLIPS> 
13.11.2 Message-handler Commands
The following commands manipulate defmessagehandlers.
13.11.2.1 Displaying the Text of a Defmessage-handler
Displays the text of a given defmessage-handler. This function has no return value.
Syntax
Defaults are outlined.

(ppdefmessagehandler <class-name> <handler-name>
	[<handler-type>])
<handler-type> ::= around | before | primary | after
13.11.2.2 Displaying the List of Defmessage-handlers
With no arguments, this function lists all handlers in the system. With one argument, this function lists all handlers for the specified class. If the optional argument "inherit" is given, inherited message-handlers are also included. This function has no return value. 
Syntax
(listdefmessagehandlers [<class-name> [inherit]])
Example
List all primary handlers in the system.

CLIPS> (defclass A (is-a USER))
CLIPS> (defmessage-handler A foo ())
CLIPS> (list-defmessage-handlers A)
foo primary in class A.
For a total of 1 message-handler.
CLIPS> (list-defmessage-handlers A inherit)
init primary in class USER.
delete primary in class USER.
print primary in class USER.
foo primary in class A.
For a total of 4 message-handlers.
CLIPS> 
13.11.2.3 Deleting a Defmessage-handler
This function deletes a previously defined message-handler.
Syntax
Defaults are outlined.

(undefmessagehandler <class-name> <handler-name>
	[<handler-type>])
<handler-type> ::= around | before | primary | after

An asterisk can be used to specify a wildcard for any of the arguments. (Wildcards will not work for the class name or handler name if there is a class or handler called *.)  The undefmessage-handler command can be used to remove handlers at any time. Exceptions: A handler may not be deleted when it or any of the other handlers for the same class are executing. This function has no return value.
Example
Delete all primary handlers in the system.

CLIPS> (undefmessage-handler * *)
CLIPS>
13.11.2.4 Previewing a Message
Displays a list of all the applicable message-handlers for a message sent to an instance of a particular class. The level of indentation indicates the number of times a handler is shadowed, and lines connect the beginning and ending portions of the execution of a handler if it encloses shadowed handlers. The right double-angle brackets indicate the beginning of handler execution, and the left double-angle brackets indicate the end of handler execution. Message arguments are not necessary for a preview since they do not dictate handler applicability.
Syntax
(previewsend <class-name> <message-name>)
Example
For the example in section 9.5.3, the output would be:

CLIPS> (preview-send USER my-message)
>> my-message around in class USER
| >> my-message around in class OBJECT
| | >> my-message before in class USER
| | << my-message before in class USER
| | >> my-message before in class OBJECT
| | << my-message before in class OBJECT
| | >> my-message primary in class USER
| | | >> my-message primary in class OBJECT
| | | << my-message primary in class OBJECT
| | << my-message primary in class USER
| | >> my-message after in class OBJECT
| | << my-message after in class OBJECT
| | >> my-message after in class USER
| | << my-message after in class USER
| << my-message around in class OBJECT
<< my-message around in class USER
CLIPS>
13.11.3 Definstances Commands
The following commands manipulate definstances.
13.11.3.1 Displaying the Text of a Definstances
Displays the text of a given definstances. This function has no return value.
Syntax
(ppdefinstances <definstances-name>)
13.11.3.2 Displaying the List of Definstances
Displays the names of all definstances stored in the CLIPS environment. This function has no return value.
Syntax
(listdefinstances)
13.11.3.3 Deleting a Definstances
This function deletes a previously defined definstances.
Syntax
(undefinstances <definstances-name>)

If the symbol * is used for <definstances-name>, then all definstances will be deleted (unless there exists a definstances called *). The undefinstances command can be used to remove definstances at any time. Exceptions: A definstances may not be deleted when any of the instances in it are being created. This function has no return value.
13.11.4 Instances Commands
The following commands manipulate instances of userdefined classes.
13.11.4.1 Listing the Instances
If no arguments are specified, all instances in scope of the current module are listed. If a module name is given, all instances within the scope of that module are given. If "*" is specified (and there is no module named "*"), all instances in all modules are listed (only instances which actually belong to classes of a module are listed for each module to prevent duplicates). If a class name is specified, only the instances for the named class are listed. If a class is specified, then the optional keyword inherit causes this function to list instances of subclasses of the class as well. This function has no return value.
Syntax
(instances [<module-name> [<class-name> [inherit]]])
13.11.4.2 Printing an Instance's Slots from a Handler
This function operates implicitly on the active instance (see section 9.4.1.1) for a message, and thus can only be called from within the body of a messagehandler. This function directly prints the slots of the active instance and is the one used to implement the print handler attached to class USER (see section 9.4.4.3). This function has no return value.
Syntax
(ppinstance)
13.11.4.3 Saving Instances to a Text File
This function saves all instances in the CLIPS environment to the specified file in the following format:

(<instance-name> of <class-name> <slot-override>*)
<slot-override> ::= (<slot-name> <single-field-value>*)

A slotoverride is generated for every slot of every instance, regardless of whether the slot currently holds a default value or not. External-address and fact-address slot values are saved as strings. Instance-address slot values are saved as instance-names. This function the number of instances saved.
Syntax
(saveinstances <file-name> 
		[local | visible [[inherit] <class>+])

By default, save-instances saves only the instances of all defclasses in the current module. Specifying visible saves instances for all classes within scope of the current module. Also, particular classes may be specified for saving, but they must be in scope according to the local or visible option. The inherit keyword can be used to force the saving of indirect instances of named classes as well (by default only direct instances are saved for named classes). Subclasses must still be in local or visible scope in order for their instances to be saved. Unless the inherit option is specified, only concrete classes can be specified. At least one class is required for the inherit option.

The file generated by this function can be loaded by either load-instances or restore-instances. save-instances does not preserve module information, so the instance file should be loaded into the module which was current when it was saved.
13.11.4.4 Saving Instances to a Binary File
The function bsave-instances works exactly like saveinstances except that the instances are saved in a binary format which can only be loaded with the function bloadinstances. The advantage to this format is that loading binary instances can be much faster than loading text instances for large numbers of instances. The disadvantage is that the file is not usually portable to other platforms.
Syntax
(saveinstances <file-name> 
		[local | visible [[inherit] <class>+])
13.11.4.5 Loading Instances from a Text File
This function loads instances from a file into the CLIPS environment. It can read files created with save-instances or any ASCII text file. Each instance should be in the format described in section 13.11.4.3. Calling load-instances is exactly equivalent to a series of makeinstance calls (in CLIPS version 5.1, slot access restrictions, such as read-only, were suspended during calls to load-instances). This function returns the number of instances loaded or -1 if it could not access the instance file.
Syntax
(loadinstances <file-name>)
13.11.4.6 Loading Instances from a Text File without Message Passing
The function restore-instances loads instances from a file into the CLIPS environment. It can read files created with saveinstances or any ASCII text file. Each instance should be in the format described in section 13.11.4.3. It is similar in operation to loadinstances, however, unlike load-instances, restore-instances does not use message-passing for deletions, initialization, or slot-overrides. Thus in order to preserve object encapsulation, it is recommended that restore-instances only be used with files generated by save-instances. This function returns the number of instances loaded or -1 if it could not access the instance file.
Syntax
(restoreinstances <file-name>)
13.11.4.7 Loading Instances from a Binary File
This function is similar to restoreinstances except that it can only work with files generated by bsaveinstances. See section 13.11.4.4 for a discussion of the merits of using binary instance files.
Syntax
(bloadinstances <file-name>)
13.12 DEFMODULE COMMANDS
The following commands manipulate defmodule constructs.
13.12.1 Displaying the Text of a Defmodule
Displays the text of a given defmodule. This function has no return value.
Syntax
(ppdefmodule <defmodule-name>)
13.12.2 Displaying the List of Defmodules
Displays the names of all defmodule constructs stored in the CLIPS environment. This function has no return value.
Syntax
(listdefmodules)
13.13 MEMORY MANAGEMENT COMMANDS
The following commands display CLIPS memory status information. CLIPS memory management is described more fully in the Advanced Programming Guide.
13.13.1 Determining the Amount of Memory Used by CLIPS
Returns an integer representing the number of bytes CLIPS has currently in-use or has held for later use. This number does not include operating system overhead for allocating memory.
Syntax
(memused)
13.13.2 Determining the Number of Memory Requests Made by CLIPS
Returns an integer representing the number of times CLIPS has requested memory from the operating system. If the operating system overhead for allocating memory is known, then the total memory used can be calculated by 

(+ (mem-used) (* <overhead-in-bytes> (mem-requests)))
Syntax
(memrequests)
13.13.3 Releasing Memory Used by CLIPS
Releases all free memory held internally by CLIPS back to the operating system. CLIPS will automatically call this function if it is running low on memory to allow the operating system to coalesce smaller memory blocks into larger ones. This function generally should not be called unless the user knows exactly what he/she is doing (since calling this function can prevent CLIPS from reusing memory efficiently and thus slow down performance). This function returns an integer representing the amount of memory freed to the operating system.
Syntax
(releasemem)
13.13.4 Conserving Memory
Turns on or off the storage of information used for save and pretty print commands. This can save considerable memory in a large system. It should be called prior to loading any constructs. This function has no return value. 
Syntax
(conservemem <value>)

where value is either on or off.
13.14 ON-LINE HELP SYSTEM
CLIPS provides an on-line help facility for use from the top-level interface. The help system uses CLIPS' external text manipulation capabilities (see section 13.15). Thus, it is possible to add or change entries in the help file or to construct new help files with information specific to the user's system.
13.14.1 Using the CLIPS Help Facility
The help facility displays menus of topics and prompts the user for a choice. It then references the help file for that information. The help facility can be called with or without a command-line topic.
Syntax
(help [<path>])

where <path> is the full path leading to a topic in the help tree. For example, for information on defrule syntax, the user would type: (help construct_summary defrule). The help function has no return value.

Each element or field in the path is delimited by white space, and the help facility is not case sensitive. In addition, the entire name of a field does not need to be specified. Only enough characters to distinguish the field from other choices in the menu are necessary (if there is a conflict, the help facility will pick the first one in the list). For instance, (help con def) would be sufficient for the above example.

A few special fields can be used while in the help facility.

^	Branch up one level.
?	When specified at the end of a path, this forces a display of the current menu, even on branch-ups.
<nil>	Giving no topic field will branch up one level.

A branch-up from the MAIN topic root node implies an exit from help.

By default, the help facility comes up in the MAIN topic root menu and the user may make a choice as described above. The prompt line always displays the name of the current menu. The help facility will branch through the help-tree until instructed to exit by a branch-up from the top level. The level always is reset to the MAIN topic upon exit from the help facility.

The first call to the help facility will take longer than successive calls while the system loads help information into an internal lookup table. All other calls to the help facility are very fast.
13.14.2 Finding the Help File
The help facility reads help information from a file during execution. Users may wish to change the location of the help file to meet the configuration of their system. The help-path function was provided to allow this.
Syntax
(helppath [<help-file-name>])

If no argument is specified, the function displays the name of the current help file. If an argument is specified, the help facility will use the new file name for future help references during this CLIPS session. To change the location of the help file permanently, a change must be made in the setup.h file, then CLIPS must be recompiled. The help-path function has no return value.
13.15 EXTERNAL TEXT MANIPULATION
CLIPS provides a set of functions to build and access a hierarchical lookup system for multiple external files. Each file contains a set of text entries in a special format that CLIPS can later reference and display. The basic concept is that CLIPS retains a "map" of the text file in memory and can easily pull sections of text from the file without having to store the whole file in memory and without having to sequentially search the file for the appropriate text.
13.15.1 External Text File Format
Each external text file to be loaded into CLIPS must be described in a particular way. Each topic entry in each file must be in the format shown following.
Syntax
<level-num> <entry-type> BEGIN-ENTRY- <topic-name>
		•
		•
Topic information in form to be displayed when referenced.
		•
		•
END-ENTRY

The delimiter strings (lines with BEGIN_ENTRY or END_ENTRY info) must be the only things on their lines. Embedded white space between the fields of the delimiters is allowed.

The first parameter, <level-num>, is the level of the hierarchical tree to which the entry belongs. The lower the number, the closer to the root level the topic is; i.e., the lowest level number indicates the root level. Subtopics are indicated by making the level number of the current topic larger than the previous entry (which is to be the parent). Thus, the tree must be entered in the file sequentially; i.e., a topic with all its subtopics must be described before going on to a topic at the same level. Entering a number less than that of the previous topic will cause the tree to be searched upwards until a level number is found which is less than the current one. The current topic then will be attached as a subtopic at that level. In this manner, multiple root trees may be created. Level number and order of entry in a file can indicate the order of precedence in which a list of subtopics that are all children of the same topic will be searched. Topics with the same level number will be searched in the order in which they appear in the file. Topics with lower-level numbers will be searched first.
Example
0MBEGIN-ENTRY-ROOT
 --  Text  --
END-ENTRY
2IBEGIN-ENTRY-SUBTOPIC1
 --  Text  --
END-ENTRY
1IBEGIN-ENTRY-SUBTOPIC2
 --  Text  --
END-ENTRY

In the above example, SUBTOPIC1 and SUBTOPIC2 are children of ROOT. However, in searching the children of ROOT, SUBTOPIC2 would be found first.

If the user wishes to access the information through the help facility (see section 13.14), the root node must be named MAIN. The contents of the MAIN menu may be changed.

The second parameter in the format defined above, the <entry-type>, must be a single capital letter, either M (for MENU) or I (for INFORMATION). Only MENU entries may have subtopics.

The third parameter defined above, the <topic-name>, can be any alphanumeric string of up to 80 characters. No white space can be embedded in the name.

Beginning a line with the delimiter "$$" forces the loader to treat the line as pure text, even if one of the key delimiters is in it. When the line is printed, the dollar signs are treated as blanks.
Example
0MBEGIN-ENTRY-ROOT1
 --  Root1 Text  --
END-ENTRY
1MBEGIN-ENTRY-SUBTOPIC1
 --  Subtopic1 Text  --
END-ENTRY
2IBEGIN-ENTRY-SUBTOPIC4
 --  Subtopic4 Text  --
END-ENTRY
1IBEGIN-ENTRY-SUBTOPIC2
 --  Subtopic2 Text  --
END-ENTRY
0IBEGIN-ENTRY-ROOT2
 --  Root2 Text  --
END-ENTRY
-1MBEGIN-ENTRY-ROOT3
 --  Root3 Text  --
END-ENTRY
0IBEGIN-ENTRY-SUBTOPIC3
 --  Subtopic3 Text  --
END-ENTRY

Tree Diagram of Above Example :

-> ROOT3 ---------> ROOT1 ---------> ROOT2 
     |               /   \
     |              /     \
     V             V       V
 SUBTOPIC3    SUBTOPIC1 SUBTOPIC2
                 |
                 |
                 V
             SUBTOPIC4
13.15.2 External Text Manipulation Functions
The following functions are used by the help facility (see section 13.14) and can be used by users to maintain their own information system.
13.15.2.1 Fetch
The function fetch loads the named file (which must be in the format defined in section 13.15.1) into the internal lookup table.
Syntax
(fetch <file-name>)

The function returns the number of entries loaded if the fetch succeeded. If the file could not be loaded or was loaded already, the function returns the symbol FALSE.
13.15.2.2 Print-region
The function print-region looks up a specified entry in a particular file which has been loaded previously into the lookup table and prints the contents of that entry to the specified output.
Syntax
(printregion <logical-name> <file-name> <topic-field>*)

where <logical-name> is a name previously attached to an output device. To send the output to stdout, specify t for the logical name. <file-name> is the name of the previously loaded file in which the entry is to be found, and the optional arguments, <topic-field>*, is the full path of the topic entry to be found.

Each element or field in the path is delimited by white space, and the function is not case sensitive. In addition, the entire name of a field does not need to be specified. Only enough characters to distinguish the field from other choices at the same level of the tree are necessary. If there is a conflict, the function will pick the first one in the list. A few special fields can be specified.

^ 	Branch up one level.
?	When specified at the end of a path, this forces a display of the current menu, even on branch-ups.
<nil>	Giving no topic field will branch up one level.

The level of the tree for a file remains constant between calls to print-region. All levels count from menu only. Information levels do not count for branching up or down. To access an entry at the root level after branching down several levels in a previous call or series of calls, an equal number of branches up must be executed.
Examples
To display the entry for ROOT SUBTOPIC from the file foo.lis on the screen, type

(print-region t "foo.lis" ROOT SUBTOPIC)

or, using less characters,

(print-region t "foo.lis" roo sub)

Only one entry can be accessed per print-region call. The function returns the symbol TRUE if the print-region succeeded. If the entry was not found, it returns FALSE.

CLIPS> (fetch "foo.lis")
7
CLIPS> (print-region t "foo.lis" roo sub)

 --  Subtopic3 Text  --
TRUE
CLIPS> (print-region t "foo.lis" "?")

 --  Root3 Text  --
TRUE
CLIPS> (print-region t "foo.lis" ^ root1 sub)

 --  Subtopic1 Text  --
TRUE
CLIPS> (print-region t "foo.lis" sub)

 --  Subtopic4 Text  --
TRUE
CLIPS> (print-region t "foo.lis" ^ subtopic2)

 --  Subtopic2 Text  --
TRUE
CLIPS> (print-region t "foo.lis" ^ root2)

 --  Root2 Text  --
TRUE
CLIPS> (toss "foo.lis")
TRUE
CLIPS> 
13.15.2.3 Toss
The function toss unloads the named file from the internal lookup table and releases the memory back to the system.
Syntax
(toss <file-name>)

The function returns the symbol TRUE if the toss succeeded. If the file was not on the lookup table, it returns FALSE.

Appendix A - Glossary
This section defines some of the terminology used throughout this manual.

abstraction
The definition of new classes to describe the common properties and behavior of a group of objects.


action
A function executed by a construct (such as the RHS of a rule) which typically has no return value, but performs some useful action (such as the printout action) (see section 12).


activation
A rule is activated if all of its conditional elements are satisfied and it has not yet fired based on a specific set of matching pattern entities that caused it to be activated. Note that a rule can be activated by more than one set of pattern entities. An activated rule that is placed on the agenda is called an activation.


active instance
The object responding to a message which can be referred to by ?self in the message's handlers.


agenda
A list of all rules that are presently ready to fire. It is sorted by salience values and the current conflict resolution strategy. The rule at the top of the agenda is the next rule that will fire.


antecedent
The LHS of a rule.


bind
The action of storing a value in a variable.


class
Template for describing the common properties (slots) and behavior (message-handlers) of a group of objects called instances of the class.


class precedence list
A linear ordering of classes which describes the path of inheritance for a class.


command
A function executed at the top-level command prompt (such as the reset command) typically having no return value.


command prompt
In the interactive interface, the "CLIPS>" prompt which indicates that CLIPS is ready for a command to be entered.


condition
A conditional element.


conditional
element
A restriction on the LHS of a rule which must be satisfied in order for the rule to be applicable (also referred to as a CE).

conflict resolution
strategy
A method for determining the order in which rules should fire among rules with the same salience. There are seven different conflict resolution strategies: depth, breadth, simplicity, complexity, lex, mea, and random.

consequent
The RHS of a rule.


constant
A non-varying single field value directly expressed as a series of characters.


constraint
In patterns, a constraint is a requirement that is placed on the value of a field from a fact or instance that must be satisified in order for the pattern to be satisfied. For example, the ~red constraint is satisfied if the field to which the constraint is applied is not the symbol red. The term constraint is also used to refer to the legal values allowed in the slots of facts and instances.


construct
A high level CLIPS abstraction used to add components to the knowledge base.


current focus
The module from which activations are selected to be fired.


current module
The module to which newly defined constructs that do not have a module specifier are added. Also is the default module for certain commands which accept as an optional argument a module name (such as list-defrules).


daemon
A message-handler which executes implicitly whenever some action is taken upon an object, such as initialization, deletion, or slot access.


deffunction
A non-overloaded function written directly in CLIPS.


deftemplate fact
A deftemplate name followed by a list of named fields (slots) and specific values used to represent a deftemplate object. Note that a deftemplate fact has no inheritance. Also called a non-ordered fact.


deftemplate object
An informal term for the entity described by a deftemplate. A  deftemplate object is simply an informal term for the collections of slots (without specific values) which define a deftemplate. Deftemplate objects do not have inheritance


deftemplate pattern
A list of named constraints (constrained slots). A deftemplate pattern describes the attributes and associated values of a deftemplate object. Also called a non-ordered pattern.


delimiter
A character which indicates the end of a symbol. The following characters act as delimiters: any non-printable ASCII character (including spaces, tabs, carriage returns, and line feeds), a double quote, opening and closing parenthesis "(" and ")", an ampersand "&", a vertical bar "|", a less than "<", a semicolon ";", and a tilde "~".


dynamic binding
The deferral of which message-handlers will be called for a message until run-time.


encapsulation
The requirement that all manipulation of instances of user-defined classes be done with messages.


expression
A function call with arguments specified.


external-address
The address of an external data structure returned by a function (written in a language such as C or Ada) that has been integrated with CLIPS (see section 2.3.1 for more details).


external function
A function written in an external language (such as C or Ada) defined by the user or provided by CLIPS and called from within CLIPS rules.


facet
A component of a slot specification for a class, e.g. default value and cardinality.


fact  
An ordered or deftemplate (non-ordered) fact. Facts are the data about which rules reason and represent the current state of the world.


fact-address  
A pointer to a fact obtained by binding a variable to the fact which matches a pattern on the LHS of a rule.


fact-identifier 
A shorthand notation for referring to a fact. It consists of the character "f", followed by a dash, followed by the fact-index of the fact.


fact-index  
A unique integer index used to identify a particular fact.


fact-list  
The list of current facts.


field
A placeholder (named or unnamed) that has a value.


fire
A rule is said to have fired if all of its conditions are satisfied and the actions then are executed.


float
A number that begins with an optional sign followed optionally in order by zero or more digits, a decimal point, zero or more digits, and an exponent (consisting of an e or E followed by an integer). A floating point number must have at least one digit in it (not including the exponent) and must either contain a decimal point or an exponent (see section 2.3.1 for more details).


focus
As a verb, refers to changing the current focus. As a noun, refers to the current focus.


focus stack
The list of modules that have been focused upon. The module at the top of the focus stack is the current focus. When all the activations from the current focus have been fired, the current focus is removed from the focus stack and the next module on the stack becomes the current focus.


function
A piece of executable code identified by a specific name which returns a useful value or performs a useful side effect. Typically only used to refer to functions which do return a value (whereas commands and actions are used to refer to functions which do not return a value).


generic dispatch
The process whereby applicable methods are selected and executed for a particular generic function call.


generic function
A function written in CLIPS which can do different things depending on what the number and types of its arguments.


inference engine
The mechanism provided by CLIPS which automatically matches patterns against the current state of the fact-list and list of instances and determines which rules are applicable.


inheritance
The process whereby one class can be defined in terms of other class(es).


instance
An object is an instance of a class. Throughout the documentation, the term instance usually refers to objects which are instances of user-defined classes.


instance (of a user-defined class)
An object which can only be manipulated via messages, i.e all objects except symbols, strings, integers, floats, multifields and external-addresses.


instance-address
The address of an instance of a user-defined class (see section 2.3.1 for more details).


instance-name
A symbol enclosed within left and right brackets (see section 2.3.1 for more details). An instance-name refers to an object of the specified name which is an instance of a user-defined class.


instance-set
An ordered collection of instances of user-defined classes. Each member of an instance-set is an instance of a set of classes, where the set can be different for each member.


instance-set distributed action
A user-defined expression which is evaluated for every instance-set which satisfies an instance-set query.


instance-set query
A user-defined boolean expression applied to an instance-set to see if it satisfies further user-defined criteria.


integer
A number that begins with an optional sign followed by one or more digits (see section 2.3.1 for more details).


LHS
Left-Hand Side. The set of conditional elements that must be satisfied for the actions of the RHS of a rule to be performed.


list
A group of items with no implied order.


logical name
A symbolic name that is associated with an I/O source or destination.


message
The mechanism used to manipulate an object.


message dispatch
The process whereby applicable message-handlers are selected and executed for a particular message.


message-handler
An implementation of a message for a particular class of objects.


message-handler precedence
The property used by the message dispatch to select between handlers when more than one is applicable to a particular message.


method
An implementation of a generic function for a particular set of argument restrictions.


method index
A shorthand notation for referring to a method with a particular set of parameter restrictions.


method precedence
The property used by the generic dispatch to select a method when more than one is applicable to a particular generic function call.


module
A workspace where a set of constructs can be grouped together such that explicit control can be maintained over restricting the access of the constructs by other modules. Also used to control the flow of execution of rules through the use of the focus command.


module specifier
A notation for specifying a module. It consists of a module name followed by two colons. When placed before a construct name, it's used to specify which module a newly defined construct is to be added to or to specify which construct a command will affect if that construct is not in the current module.


multifield
A sequence of unnamed placeholders each having a value.


multifield value
A sequence of zero or more single-field values.


non-ordered fact
A deftemplate fact.


number
An integer or float.


object
A symbol, a string, a floating-point or integer number, a multifield value, an external address or an instance of a user-defined class. 


order
Position is significant.


ordered fact
A sequence of unnamed fields.


ordered pattern
A sequence of constraints.


overload
The process whereby a generic function can do different things depending on the types and number of its arguments, i.e. the generic function has multiple methods.


pattern
A conditional element on the LHS of a rule which is used to match facts in the fact-list.


pattern entity
An item that is capable of matching a pattern on the LHS of a rule. Facts and instances are the only types of pattern entities available.


pattern-matching
The process of matching facts or instances to patterns on the LHS of rules.


polymorphism
The ability of different objects to respond to the same message in a specialized manner.


primitive type object
A symbol, string, integer, float, multifield or external-address.


relation
The first field in a fact or fact pattern. Synonomous with the associated deftemplate name.


RHS
Right-Hand Side. The actions to be performed when the LHS of a rule is satisfied.


rule
A collection of conditions and actions. When all patterns are satisfied, the actions will be taken.


salience
A priority number given to a rule. When multiple rules are ready for firing, they are fired in order of priority. The default salience is zero (0). Rules with the same salience are fired according to the current conflict resolution strategy.


sequence
An ordered list.


shadowed message-handler
A message-handler that must be explicitly called by another message-handler in order to execute.


shadowed method
A method that must be explicitly called by another method in order to execute.


single-field value
One of the primitive data types: float, integer, symbol, string, external-address, instance-name, or instance-address.


slot
Named single-field or multifield. To write a slot give the field name (attribute) followed by the field value. A single-field slot has one value, while a multifield slot has zero or more values. Note that a multifield slot with one value is strictly not the same as a single field slot. However, the value of a single-field slot (or variable) may match a multifield slot (or multifield variable) that has one field.


slot-accessor
Implicit message-handlers which provide read and write access to slots of an object.


specificity (class)
A class that precedes another class in a class precedence list is said to be more specific. A class is more specific than any of its superclasses.


specificity (rule)
A measure of how "specific" the LHS of a rule is in the pattern-matching process. The specificity is determined by the number of constants, variables, and function calls used within LHS conditional elements.


string
A set of characters that starts with double quotes (") and is followed by zero or more printable characters and ends with double quotes (see section 2.3.1 for more details).


subclass
If a class inherits from a second class, the first class is a subclass of the second class.


superclass
If a class inherits from a second class, the second class is a superclass of the first class.


symbol
Any sequence of characters that starts with any printable ASCII character and is followed by zero or more characters (see section 2.3.1 for more details).


top level
In the interactive interface, the "CLIPS>" prompt which indicates that CLIPS is ready for a command to be entered.


value
A single or multifield value.


variable
An symbolic location which can store a value.

Appendix B - Integrated Editor
CLIPS includes a fully integrated version of the full screen MicroEMACS editor. You may call the editor from CLIPS, compile full buffers or just sections of the editor (incremental compile), temporarily exit the editor back to CLIPS, or permanently exit the editor. Since the editor is full screen, portions of it are highly machine dependent. As it is currently set up, the editor will run on VAX VMS machines using VT100- or VT240-compatible terminals, UNIX systems which support TERMCAP, the IBM PC, and most IBM compatibles.

The editor may be called from CLIPS with the following command:

(edit ["<file-name>"])

The file name is optional. If one is given, that file would be loaded. If no file name is given, the editor is entered without loading a file. Once in the file, all of the EMACS commands listed below are applicable. To exit the editor and clear all buffers, use <Ctrl-Z> or <Ctrl-X><Ctrl-C>. To temporarily exit the editor and retain the information in the buffers, use <Ctrl-X> Q. To compile a rules section, mark a region and type <Ctrl-X><Ctrl-T>. To compile the entire buffer, use <Meta-T>. The editor can use extensive amounts of memory, and a flag is available in clips.h to remove all of the editor code.

When using the editor on multiuser machines like the VAX or many UNIX environments, be careful with the control S and control Q commands; they could conflict with terminal XON/XOFF communications. All control S commands have a work around built into the editor. The save file command, normally <Ctrl-X><Ctrl-S>, is also <Meta> Z. The forward search command, normally <Ctrl-S>, is also <Meta> J. The control Q command is rarely needed in a CLIPS file and, therefore, has no substitute.

Control Commands
<ctrl-@>	Set mark at current position.
<ctrl-A>	Move cursor to beginning of line.
<ctrl-B>	Move cursor BACK one character.
<ctrl-C>	Start a new interactive command shell. Be careful!
<ctrl-D>	DELETE character under cursor.
<ctrl-E>	Move cursor to END of line.
<ctrl-F>	Move cursor FORWARD one character.
<ctrl-G>	Abort any command.
<ctrl-H>	(backspace) delete previous character.
<ctrl-I>	Insert a TAB.
<ctrl-J>	Insert a CR-LF and indent next line.
<ctrl-K>	KILL (delete) to end of line.
<ctrl-L>	Redisplay screen.
<ctrl-M>	Insert a CR-LF.
<ctrl-N>	Move cursor to NEXT line.
<ctrl-O>	OPEN a new line.
<ctrl-P>	Move to PREVIOUS line.
<ctrl-Q>	QUOTE the next character (insert the next character typed).
<ctrl-R>	Reverse SEARCH.
<ctrl-S>	Forward SEARCH (also <Meta-J>).
<ctrl-T>	TRANSPOSE characters.
<ctrl-U>	Enter repeat count for next command.
<ctrl-V>	VIEW the next screen (scroll up one screen).
<ctrl-W>	KILL region (all text between cursor and last mark set).
<ctrl-X>	Extended command prefix - see below.
<ctrl-Y>	YANK (undelete) last text killed.
<ctrl-Z>	Quick save of file in current buffer (only) and exit.

Extended (Control-X) Commands
<ctrl-X>(	Begin keyboard Macro.
<ctrl-X>)	End keyboard Macro.
<ctrl-X>!	Execute a single external command.
<ctrl-X>=	Show current cursor column and line number.
<ctrl-X>:	Go to a specific line number.
<ctrl-X>1	Display current window only.
<ctrl-X>2	Split the current window.
<ctrl-X>B	Switch to a different BUFFER.
<ctrl-X>E	EXECUTE keyboard Macro.
<ctrl-X>F	Set FILL column.
<ctrl-X>K	KILL a buffer (other than current buffer).
<ctrl-X>M	MATCH parenthesis (or {} or []).
<ctrl-X>N	Move to NEXT window.
<ctrl-X>P	Move to PREVIOUS window.
<ctrl-X>R	Global search and REPLACE (backwards).
<ctrl-X>S	Global SEARCH and replace (forwards).
<ctrl-X>Z	Enlarge current window by repeat count <ctrl-U> lines.

<ctrl-X><ctrl-B>	Show active BUFFERS.
<ctrl-X><ctrl-C>	Exit without saving buffers.
<ctrl-X><ctrl-F>	FIND file. Load if not already in buffer.
<ctrl-X><ctrl-N>	Scroll current window up by repeat count lines.
<ctrl-X><ctrl-P>	Scroll current window down by repeat count lines.
<ctrl-X><ctrl-R>	RENAME file. Change file name for buffer.
<ctrl-X><ctrl-S>	SAVE (write) current buffer into its file.
<ctrl-X><ctrl-V>	VISIT a file. Read file and display in current window.
<ctrl-X><ctrl-W>	WRITE buffer to file. Option to change name of file.
<ctrl-X><ctrl-Z>	Reduce current window by repeat count lines.

Special characters
<del>	Delete previous character.
	(also <ctrl-H> on some terminals)
<esc>	Meta command prefix.
	(also <ctrl-[> on some terminals)

Meta Commands  (Activated by <esc> or <ctrl-[>)
<meta>!	Move current line to repeat count lines from top of window.
<meta>> 	Move cursor to end of buffer.
<meta><	Move cursor to beginning of buffer.
<meta>.	Set mark.
<meta>B	Move cursor BACK one word.
<meta>C	CAPITALIZE first letter of word.
<meta>D	DELETE next word.
<meta>F	Move cursor FORWARD one word.
<meta>J	SEARCH forward (same as <ctrl-S>).
<meta>L	LOWERCASE (lowercase) next word.
<meta>R	Query search and REPLACE (backwards).
<meta>S	Query SEARCH and replace (forwards).
<meta>U	UPPERCASE (uppercase) next word.
<meta>V	VIEW the previous screen (scroll down one screen).
<meta>W	COPY region into kill buffer.
<meta>Z	SAVE current buffer into file (same as <ctrl-X><ctrl-S>).
<meta><del>	DELETE previous word.

Appendix C - Performance Considerations
This appendix explains various techniques that the user can apply to a CLIPS program to maximize performance. Included are discussions of pattern ordering in rules, use of deffunctions in lieu of non-overloaded generic functions, parameter restriction ordering in generic function methods, and various approaches to improving the speed of message-passing and reading slots of instances.
C.1 ORDERING OF PATTERNS ON THE LHS
The issues which affect performance of a rule-based system are considerably different from those which affect conventional programs. This section discusses the single most important issue: the ordering of patterns on the LHS of a rule.

CLIPS is a rule language based on the RETE algorithm. The RETE algorithm was designed specifically to provide very efficient pattern-matching. CLIPS has attempted to implement this algorithm in a manner that combines efficient performance with powerful features. When used properly, CLIPS can provide very reasonable performance, even on microcomputers. However, to use CLIPS properly requires some understanding of how the pattern-matcher works.

Prior to initiating execution, each rule is loaded into the system and a network of all patterns that appear on the LHS of any rule is constructed. As facts and instances of reactive classes (referred to collectively as pattern entities) are created, they are filtered through the pattern network. If the pattern entities match any of the patterns in the network, the rules associated with those patterns are partially instantiated. When pattern entities exist that match all patterns on the LHS of the rule, variable bindings (if any) are considered. They are considered from the top to the bottom; i.e., the first pattern on the LHS of a rule is considered, then the second, and so on. If the variable bindings for all patterns are consistent with the constraints applied to the variables, the rules are activated and placed on the agenda.

This is a very simple description of what occurs in CLIPS, but it gives the basic idea. A number of important considerations come out of this. Basic pattern-matching is done by filtering through the pattern network. The time involved in doing this is fairly constant. The slow portion of basic pattern-matching comes from comparing variable bindings across patterns. Therefore, the single most important performance factor is the ordering of patterns on the LHS of the rule. Unfortunately, there are no hard and fast methods that will always order the patterns properly. At best, there seem to be three "quasi" methods for ordering the patterns.

1)	Most specific to most general. The more wildcards or unbound variables there are in a pattern, the lower it should go. If the rule firing can be controlled by a single pattern, place that pattern first. This technique often is used to provide control structure in an expert system; e.g., some kind of "phase" fact. Putting this kind of pattern first will guarantee that the rest of the rule will not be considered until that pattern exists. This is most effective if the single pattern consists only of literal constraints. If multiple patterns with variable bindings control rule firing, arrange the patterns so the most important variables are bound first and compared as soon as possible to the other pattern constraints. The use of phase facts is not recommended for large programs if they are used solely for controlling the flow of execution (use modules instead).

2)	Patterns with the lowest number of occurrences in the fact-list or instance-list should go near the top. A large number of patterns of a particular form in the fact-list or instance-list can cause numerous partial instantiations of a rule that have to be "weeded" out by comparing the variable bindings, a slower operation.

3)	Volatile patterns (ones that are retracted and asserted continuously) should go last, particularly if the rest of the patterns are mostly independent. Every time a pattern entity is created, it must be filtered through the network. If a pattern entity causes a partial rule instantiation, the variable bindings must be considered. By putting volatile patterns last, the variable bindings only will be checked if all of the rest of the patterns already exist.

These rules are not independent and commonly conflict with each other. At best, they provide some rough guidelines. Since all systems have these characteristics in different proportions, at a glance the most efficient manner of ordering patterns for a given system is not evident. The best approach is to develop the rules with minimal consideration of ordering. When the reasoning is fairly well verified, experiment with the patterns until the optimum configuration is found.

Another performance issue is the use of multifield variables and wildcards ($?). Although they provide a powerful capability, they must be used very carefully. Since they can bind to zero or more fields, they can cause multiple instantiations of a single rule. In particular, the use of multiple multifield variables in one pattern can cause a very large number of instantiations.

Some final notes on rule performance. Experience suggests that the user should keep the expert system "lean and mean." The list of pattern entities should not be used as a data base for storage of extraneous information. Store and pattern-match only on that information necessary for reasoning. Keep the pattern-matching to a minimum and be as specific as possible. Many short, simple rules perform better than long, complex rules and have the added benefit of being easier to understand and maintain.
C.2 DEFFUNCTIONS VERSUS GENERIC FUNCTIONS
Deffunctions execute more quickly than generic function because generic functions must first examine their arguments to determine which methods are applicable. If a generic function has only one method, a deffunction probably would be better. Care should be taken when determining if a particular function truly needs to be overloaded. In addition, if recompiling and relinking CLIPS is not prohibitive, user-defined external functions are even more efficient than deffunctions. This is because deffunction are interpreted whereas external functions are directly executed. For more details, see sections 7 and 8.2.
C.3 ORDERING OF METHOD PARAMETER RESTRICTIONS
When the generic dispatch examines a generic function's method to determine if it is applicable to a particular set of arguments, it examines that method's parameter restrictions from left to right. The programmer can take advantage of this by placing parameter restrictions which are less frequently satisfied than others first in the list. Thus, the generic dispatch can conclude as quickly as possible when a method is not applicable to a generic function call. If a group of restrictions are all equally likely to be satisfied, placing the simpler restrictions first, such as those without queries, will also allow the generic dispatch to conclude more quickly for a method that is not applicable. For more details, see section 8.4.3.
C.4 INSTANCE-ADDRESSES VERSUS INSTANCE-NAMES
COOL allows instances of user-defined classes to be referenced either by address or by name in functions which manipulate instances, such as message-passing with the send function. However, when an instance is referenced by name, CLIPS must perform an internal lookup to find the instanceaddress anyway. If the same instance is going to be manipulated many times, it might be advantageous to store the instance-address and use that as a reference. This will allow CLIPS to always go directly to the instance. For more details, see sections 2.4.2 and 12.16.4.6.
C.5 READING INSTANCE SLOTS DIRECTLY
Normally, message-passing must be used to read or set a slot of an instance. However, slots can be read directly within instanceset queries and messagehandlers, and they can be set directly within message-handlers. Accessing slots directly is significantly faster than message-passing. Unless message-passing is required (because of slot daemons), direct access should be used when allowed. For more details, see sections 9.4.2, 9.4.3, 9.4.4, 9.6.3, 9.6.4 and 9.7.3.

Appendix D - Differences Between Versions 5.1 and 6.0
Numerous changes and additions to CLIPS were made between version 5.1 and the  version 6.0. The primary additions were:

•	Rule/Object Integration: Instances of user-defined classes in COOL can be pattern-matched on the left-hand side of rules. For more information, see sections 5.4.1.7, 9.3.2.2, 9.3.3.7, 9.6.1, 9.6.2, 9.6.6, 9.6.7, and 9.6.8.

•	Defmodule Construct: The defmodule construct allows a knowledge base to be partioned. For more information, see section 10.

•	New Conditional Elements: Noti.conditional element:not; CEs may now contain CEs other than pattern CEs. The exists and forall CEs have been added. The initial-fact or initial-object pattern is added to rules which begin with a not or test CE. Connective constraints can be used with multifield variables. For more information, see sections 5.4.2, 5.4.5, 5.4.6, 5.4.7, and 5.4.9.

•	Constraint Checking: Static and dynamic constraint checking are supported to a much greater extent than in CLIPS 5.1. In addition to deftemplates, COOL also performs constraint checking. Many of the features previously available in CRSV are now directly supported in CLIPS. For more information, see sections 10, 13.1.13, 13.1.14, 13.1.15, and 13.1.16.

•	Deftemplate Enhancements: Deftemplates can now contain more than one multifield slot. For more information, see section 3.

•	Defclass Syntax - The syntax for the defclass construct has been considerably changed. The primary changes in the syntax are:

1) The abstract/concrete behavior of a clsass is now inherited if not explicitly specified (rather than defaulting to concrete). Since the system class USER is abstract, many class declarations from 5.1 code will have to be explicitly declared concrete.
2) All facets must be specified with name and value (rather than just value as in 5.1). For example, to declare a read-only slot now requires "(access read-only)" rather than "(read-only)".
3) The "single" and "multiple" facets have been removed. This information is now conveyed by the declaration of the slot: "(slot ...)" and "(single-slot ...)" are single-field slots and "(multislot ...)" is a multifield slot.

For more information, see section 9.3.

•	Windows 3.1 Interface and Extended Memory - A Windows 3.1 CLIPS interface is now available for PC compatible computers. See the section 2 of The Interfaces Guide for more details. In addition, MS-DOS 286 and 386 versions of CLIPS are available which can use extended memory.
Minor Changes

•	Sequence Expansion -  The $ symbol can now be used to expand the values contained within a multifield variable when calling a function such than multiple arguments are passed to the function rather than a single multifield argument. For more information, see section 12.18.

•	Generic Function Changes

•	Restrictions on Defmethod Wildcard Parameters -  Generic function method wildcard parameters can now be restricted with types and queries similarly to the regular parameters. For more information, see section 8.4.

•	Overloading System Functions -  If a system function is overloaded with a defgeneric, it is no longer automatically applicable with lowest precedence to a call to that generic function. An explicit method is formed for the system function corresponding to its BNF syntax restrictions. This method is used to determine the applicability and precedence of the system function to the generic function call. For more information, see  section 8.5.1.

•	COOL Changes

•	New COOL Predefined System Classes - There are a number of new predefined COOL system classes. They are INSTANCE, INSTANCE-ADDRESS, INSTANCE-NAME, ADDRESS, FACT-ADDRESS, EXTERNAL-ADDRESS. See section 9.2 for more details.

•	Class Descriptors -  The abstract/concrete class descriptors are now inherited (see section 9.3.2.1). This implies that any classes which directly inherit from the abstract system class USER must now explicitly specify the concrete role in order to have direct instances. The reactive and non-reactive class descriptors can be used to indicate which classes will match object patterns (see section 9.3.2.2).

•	Unbound Slots - COOL object slots are no longer allowed to be unbound. The function slotboundp has been removed.

•	New Slot Facets - Several new facets are available for slots: pattern-match, visibility, create-accessor and override-message (see section 9.3.3).

•	Implicit Slot-Accessors - Implicit slot-accessor message-handlers are no longer created for all slots in a defclass. The create-accessor slot facet can be used to automatically generate explicit message-handlers for accessing the slot's value (see section 9.3.3.9).

•	Accessing Slot Values - The bind function can directly set a slot's value from within a message-handler's body (see section 9.4.2). The visibility facet can be used to restrict access to a slot to message-handlers attached to the class in which the slot is defined (see section 9.3.3.8). Direct slot references of the form ?self:<slot-name> are now statically bound when the message-handler is parsed (see section 9.4.2). The functions dynamic-put and dynamic-get provide the previous behavior. In addition, the syntax ?self:<variable> is no longer allowed.

•	Return and Break from Instance-Set Queries - The return and break functions can be used within certain instance set query functions (see sections 9.7.7, 12.6.7, and 12.6.8).

•	Default Values for Instance Slots (see section 9.3.3.2)

•	Message-Handlers for Redefined Classes - Message-handlers attached to a class are now deleted when the class is redefined rather than being attached to the new definition (see section 9.3). This is because message-handlers can contain static references to slots within the defclass (see section 9.4.2).

•	Definstances Definition Order Dependence - Definstances can now only use classes which have been previously defined (see section 9.6.1.1).

•	New Functions for Setting Groups of Slots - Functions are provided for quickly changing a group of slots in an instance and duplicating an instance (see sections 9.6.7 and 9.6.8 ).

•	Watch Enhancements -  The watch and unwatch commands have been extended to allow individual constructs to be watched (see sections 13.2.3 and 13.2.4) The listwatchitems command allows the current state of watch items to be viewed (see section 13.2.5).

•	Deftemplate Syntax - For consistency, the keyword multislot should be used in place of the keyword multifield when defining multifield slots and the keyword slot should be used in place of the keyword field when defining single field slot. The keywords multifield and field are still supported, but should be considered archaic. For more information, see section 3.

•	Default Values - The use of the ?NONE keyword and the no-default facet for specifying default values has been changed. See sections 3.1, 9.3, and 9.3.3.2

•	Different Feature Behavior - A number of features now behave differently. They are:

	allowedinstances (see section 11.2)
	allowednumbers (see section 11.2)
	maxnumberoffields (see section 11.4)
	minnumberoffields (see section 11.4)
	
•	Assert and the Return Value Constraint - The return value constraint is no longer needed to evaluate expressions contained within an assert, modify, or duplicate command. See sections 12.9.1, 12.9.3, 12.9.4, and 5.4.1.6 for more details.

•	First Field of a Fact or Pattern Must be a Symbol - The first field of any fact (whether it is an ordered or template fact) or pattern must be a symbol (see sections 2.4.1.1 and 5.4.1).

•	Format %ld option - The %d option for the format function now prints all integers using a long integer format. The %ld option is no longer required to print integers in this format.

•	Bind Function Changes - The bind function can now be used to set the value of slots within message-handlers. By passing no arguments after the variable name, local variables can be unbound and global variables can be reset to their original value. Passing more than one value after the variable name automatically appends all of the arguments together as a multifield value. For more information, see section 12.6.1.

•	Instance Statistics - The average number of instances is now displayed after a run command if statistics are being watched.

•	Defrelation and Defexternal Constructs are No Longer Supported - The defexternal and defrelation constructs previously provided for use with CRSV are no longer supported.

•	Connective Constraints can be used with Multifield Variables - Connective constraints can now be used with multifield variables. See section 5.4.1 for more details.

•	Default Values for Deftemplates - The defaults values for deftemplates have been enhanced. The ?NONE keyword should be replaced with ?DERIVE. See section 3.1 for more details.

•	New Functions and Commands - A number of new functions and commands have been added. They are:
	
	activeduplicateinstance (see section 9.6.8.2)
	activeinitializeinstance (see section 9.6.2)
	activemakeinstance (see section 9.6.1)
	activemessageduplicateinstance (see section 9.6.8.4)
	activemessagemodifyinstance (see section 9.6.7.4)
	apropos (see section 13.11.17)
	bloadinstances (see section 13.11.4.4)
	bsaveinstances (see section 13.11.4.7)
	callspecificmethod (see section 12.15.8)
	classreactivep (see section 12.16.1.13)
	clearfocusstack (see section 13.7.8)
	defclassmodule (see section 12.16.1.2)
	deffactsmodule (see section 12.10.2)
	deffunctionmodule (see section 12.14.2)
	defgenericmodule (see section 12.15.2)
	defglobalmodule (see section 12.13.2)
	definstancesmodule (see section 12.16.3.2)
	defrulemodule (see section 12.11.2)
	deftemplatemodule (see section 12.8.2)
	duplicateinstance (see section 9.6.8.1)
	first$ (see section 12.2.11)
	focus (see section 13.7.3)
	getcurrentmodule (see section 12.17.3)
	getdefclasslist (see section 12.16.1.1)
	getdeffactslist (see section 12.10.1)
	getdeffunctionlist (see section 12.14.1)
	getdefgenericlist (see section 12.15.1)
	getdefgloballist (see section 12.13.1)
	getdefinstanceslist (see section 12.16.3.1)
	getdefmessagehandlerlist (see section 12.16.1.17)
	getdefmethodlist (see section 12.15.3)
	getdefmodulelist (see section 12.17.1)
	getdefrulelist (see section 12.11.1)
	getdeftemplatelist (see section 12.8.1)
	getfocus (see section 12.12.1)
	getfocusstack (see section 12.12.2)
	getfunctionrestrictions (see section 12.7.8)
	getmethodrestrictions (see section 12.15.9)
	getsequenceoperatorrecognition (see section 12.18.4)
	insert$ (see section 12.2.10)
	listdefmodules (see section 13.12.2)
	listfocusstack (see section 13.7.7)
	loopforcount (see section 12.6.4)
	messageduplicateinstance (see section 9.6.8.3)
	messagemodifyinstance (see section 9.6.7.3)
	modifyinstance (see section 9.6.7.1)
	objectpatternmatchdelay (see section 9.6.6)
	overridenextmethod (see section 12.15.7)
	popfocus (see section 12.12.3)
	ppdefmodule (see section 13.12.1)
	progn$ (see section 12.6.6)
	remove (see section 12.4.2.8)
	rename (see section 12.4.2.7)
	replace$ (see section 12.2.9)
	rest$ (see section 12.2.12)
	restoreinstances (see section 13.11.4.6)
	setcurrentmodule (see section 12.17.2)
	setsequenceoperatorrecognition (see section 12.18.3)
	showdefglobals (see section 13.8.4)
	slotallowedvalues (see section 12.16.1.22)
	slotcardinality (see section 12.16.1.21)
	slotdirectaccessp (see section 12.16.1.10)
	slotpublicp (see section 12.16.1.9)
	slotrange (see section 12.16.1.23)
	slottypes (see section 12.16.1.20)
	subseq$ (see section 12.2.8)
	switch (see section 12.6.9)
	undefglobal (see section 13.8.3)
	
•	Obsolete Functions - The following functions are considered obsolete, but are still supported. They should be replaced with the specified functions.

	strassert (use assertstring instead)
	directmvdelete (use directslotdelete$ instead)
	directmvinsert (use directslotinsert$ instead)
	directmvreplace (use directslotreplace$ instead)
	get (use dynamicget or ?self:<name> syntax instead)
	member (use member$ instead)
	mvappend (use create$ instead)
	mvdelete (use delete$ instead)
	mvreplace (use replace$ instead)
	mvslotdelete (use slotdelete$ instead)
	mvslotinsert (use slotinsert$ instead)
	mvslotreplace (use slotreplace$ instead)
	mvsubseq (use subseq$ instead)
	nth (use nth$ instead)
	put (use dynamicput or (bind ?self:<name> <value>*) syntax instead)
	strexplode (use explode$ instead)
	strimplode (use implode$ instead)
	subset (use subsetp instead)
                 
	The following functions are considered obsolete and are no longer supported. They should be replaced with the specified functions.
	
	classmessagehandlerexistp (use messagehandlerexistp instead)
	classmessagehandlers (use getdefmessagehandlerlist instead)
	classslotexistp (use slotexistp instead)
	getdynamicdeftemplatechecking (use getdynamicconstraintchecking instead)
	setdynamicdeftemplatechecking (use setdynamicconstraintchecking instead)
	trunc (use integer instead)
 
	The following functions are considered obsolete and are no longer supported. There is no replacement.

	crsvtraceoff 
	crsvtraceon 

•	Different Return Values - A number of new functions have different return values. They are:

	assert (see section 12.9.1)
	assertstring (see section 12.9.5)
	batch (see section 13.1.8)
	bload (see section 13.1.3)
	bsave (see section 13.1.4)
	classslots (see section 12.16.1.16)
	classsubclasses (see section 12.16.1.15)
	classsuperclasses (see section 12.16.1.14)
	dribbleoff (see section 13.2.2)
	dribbleon (see section 13.2.1)
	duplicate (see section 12.9.4)
	getdefmessagehandlerlist (see section 12.16.1.17)
	load (see section 13.1.1)
	loadfacts (see section 13.4.2)
	modify (see section 12.9.3)
	save (see section 13.1.2)
	savefacts (see section 13.4.3)
	slotfacets (see section 12.16.1.18)
	slotsources (see section 12.16.1.19)
	
•	Different Argument Types - A number of functions now accept a different number of arguments or different argument types. They are:

	agenda (see section 13.7.1)
	bind (see section 12.6.1)
	delete$ (see section 12.2.5)
	dependencies (see section 13.6.11)
	dependents (see section 13.6.12)
	facts (see section 13.4.1)
	instances (see section 13.11.4.1)
	listdeffacts (see section 13.5.2)
	listdefmessagehandlers (see section 13.11.2.2)
	listdefrules (see section 13.6.2)
	listdeftemplates (see section 13.3.2)
	makeinstance (see section 9.6.1)
	refreshagenda (see section 13.7.11)
	retract (see section 12.9.2)
	showbreaks (see section 13.6.7)
	slotexistp (see section 12.16.1.6)
	slotinitablep (see section 12.16.1.8)
	slotwritablep (see section 12.16.1.7)
	unmakeinstance (see section 12.16.4.2)
                     	
•	Different Function and Command Behavior - A number of functions and commands now behave differently. They are:  

	break (see section 12.6.8)
	describeclass (see section 13.11.1.4)
	directslotinsert$ (see section 12.16.4.12.2)
	format (see section 12.4.2.6, the %r format flag) 
	insert$ (see section 12.2.10)
	listdefglobals (see section 13.8.2)
	loadinstances (see section 13.11.4.5) 
	slotinsert$ (see section 12.16.4.12.2)
	return (see section 12.6.7)
	savefacts (see section 13.4.3)
	saveinstances (see section 13.11.4.3)
	strassert (see section 12.9.5)
	
•	Different Output - A number of functions have different output.

	describeclass (see section 13.11.1.4)
	slotfacets (see section 12.16.1.18)
	
•	New logical name - all warning messages are sent to the logical name wwarning (see section 12.4.1).

Appendix E - Support Information

CLIPS is available through the Computer Software Management and Information Center (COSMIC), which is the distribution point for NASA software. Price discounts are available to U.S. academic institutions. Further information can be obtained from

	COSMIC
	The University of Georgia
	382 E. Broad St.
	Athens, GA  30602

	Phone: (706) 542-3265
	FAX: (706) 542-4807
	Internet: service@cossack.cosmic.uga.edu

If you have problems using or installing CLIPS, the Software Technology Branch (STB) Help Desk can be contacted at (713) 286-8919 from 9:00 a.m. to 4:00 p.m. (Central Standard Time). Leave your name and number and a support person will get back to you. The STB Help Desk can also be reached via electronic mail at <stbprod@fdr.jsc.nasa.gov> or by FAX at (713) 280-3818. 

An electronic bulletin board containing information regarding CLIPS and other STB products can be reached 24 hours a day at (713) 280-3896 or (713) 280-3892. Communications information is 300, 1200, or 2400 baud, no parity, 8 data bits, and 1 stop bit.

An electronic conferencing facility is also available to CLIPS users. Subscribers to this facility may send questions, observations, answers, editorials, etc., in the form of electronic mail to the conference.  All subscribers will have a copy of these messages reflected back to them at their respective electronic mail addresses to process at their leisure. All that is required is that you have an electronic mail address that is accessible either directly on the Internet or via a gateway connected thereto (e.g., BITNET or NASAMAIL). To subscribe, simply send a single line message to listserv@cossack.cosmic.uga.edu saying SUBSCRIBE CLIPS-LIST (the hyphen is required).  The subject field is ignored but the address found in the 'Reply:', 'Reply to:', or 'From:' field will be entered in the distribution list.  Upon subscription you will receive a mail message instructing you how to participate in the conference from that point forward.

Usenet users can also find information and post 