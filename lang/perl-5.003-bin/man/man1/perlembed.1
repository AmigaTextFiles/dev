.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH PERLEMBED 1 "perl 5.003 with" "30/Jan/96" "Perl Programmers Reference Guide"
.IX Title "PERLEMBED 1"
.UC
.IX Name "perlembed - how to embed perl in your C program"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
perlembed \- how to embed perl in your C program
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Sh "\s-1PREAMBLE\s0"
.IX Subsection "\s-1PREAMBLE\s0"
Do you want to:
.Ip "\fBUse C from Perl?\fR  " 5
.IX Item "\fBUse C from Perl?\fR  "
Read the \fIperlcall\fR manpage and the \fIperlxs\fR manpage.
.Ip "\fBUse a \s-1UNIX\s0 program from Perl?\fR  " 5
.IX Item "\fBUse a \s-1UNIX\s0 program from Perl?\fR  "
Read about backquotes and the \f(CWsystem\fR entry in the \fIperlfunc\fR manpage and the \f(CWexec\fR entry in the \fIperlfunc\fR manpage.
.Ip "\fBUse Perl from Perl?\fR  " 5
.IX Item "\fBUse Perl from Perl?\fR  "
Read about the \f(CWdo\fR entry in the \fIperlfunc\fR manpage and the \f(CWeval\fR entry in the \fIperlfunc\fR manpage and the \f(CWuse\fR entry in the \fIperlmod\fR manpage 
and the \f(CWrequire\fR entry in the \fIperlmod\fR manpage.
.Ip "\fBUse C from C?\fR  " 5
.IX Item "\fBUse C from C?\fR  "
Rethink your design.
.Ip "\fBUse Perl from C?\fR  " 5
.IX Item "\fBUse Perl from C?\fR  "
Read on...
.Sh "\s-1ROADMAP\s0"
.IX Subsection "\s-1ROADMAP\s0"
the section on \fICompiling your C program\fR
.PP
There's one example in each of the five sections:
.PP
the section on \fIAdding a Perl interpreter to your C program\fR
.PP
the section on \fICalling a Perl subroutine from your C program\fR
.PP
the section on \fIEvaluating a Perl statement from your C program\fR
.PP
the section on \fIPerforming Perl pattern matches and substitutions from your C program\fR
.PP
the section on \fIFiddling with the Perl stack from your C program\fR
.PP
This documentation is \s-1UNIX\s0 specific.
.Sh "Compiling your C program"
.IX Subsection "Compiling your C program"
Every C program that uses Perl must link in the \fIperl library\fR.  
.PP
What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (\fI/usr/bin/perl\fR or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly\*(--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
\fIlib\fR directory.)
.PP
Your C program will\*(--usually\*(--allocate, \*(L"run\*(R", and deallocate a
\fIPerlInterpreter\fR object, which is defined in the perl library.  
.PP
If your copy of Perl is recent enough to contain this documentation
(5.002 or later), then the perl library (and \fIEXTERN.h\fR and
\fIperl.h\fR, which you'll also need) will
reside in a directory resembling this:
.PP
.Vb 1
\&    /usr/local/lib/perl5/your_architecture_here/CORE
.Ve
or perhaps just
.PP
.Vb 1
\&    /usr/local/lib/perl5/CORE
.Ve
or maybe something like
.PP
.Vb 1
\&    /usr/opt/perl5/CORE
.Ve
Execute this statement for a hint about where to find \s-1CORE\s0:
.PP
.Vb 1
\&    perl -e 'use Config; print $Config{archlib}'
.Ve
Here's how you might compile the example in the next section,
the section on \fIAdding a Perl interpreter to your C program\fR,
on a \s-1DEC\s0 Alpha running the \s-1OSF\s0 operating system:
.PP
.Vb 2
\&    % cc -o interp interp.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
\&    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
.Ve
You'll have to choose the appropriate compiler (\fIcc\fR, \fIgcc\fR, et al.)  and
library directory (\fI/usr/local/lib/...\fR)  for your machine.  If your
compiler complains that certain functions are undefined, or that it
can't locate \fI\-lperl\fR, then you need to change the path following the
\-L.  If it complains that it can't find \fIEXTERN.h\fR or \fIperl.h\fR, you need
to change the path following the \-I.  
.PP
You may have to add extra libraries as well.  Which ones?
Perhaps those printed by 
.PP
.Vb 1
\&   perl -e 'use Config; print $Config{libs}'
.Ve
.Sh "Adding a Perl interpreter to your C program"
.IX Subsection "Adding a Perl interpreter to your C program"
In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with \fIminiperlmain.c\fR,
from the source distribution.  Here's a bastardized, non-portable version of
\fIminiperlmain.c\fR containing the essentials of embedding:
.PP
.Vb 15
\&    #include <stdio.h>
\&    #include <EXTERN.h>               /* from the Perl distribution     */
\&    #include <perl.h>                 /* from the Perl distribution     */
\&    
\&    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
\&   
\&    int main(int argc, char **argv, char **env)
\&    {
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&        perl_parse(my_perl, NULL, argc, argv, env);
\&        perl_run(my_perl);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&    }
.Ve
Now compile this program (I'll call it \fIinterp.c\fR) into an executable:
.PP
.Vb 2
\&    % cc -o interp interp.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
\&    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
.Ve
After a successful compilation, you'll be able to use \fIinterp\fR just
like perl itself:
.PP
.Vb 6
\&    % interp
\&    print "Pretty Good Perl \en";
\&    print "10890 - 9801 is ", 10890 - 9801;
\&    <CTRL-D>
\&    Pretty Good Perl
\&    10890 - 9801 is 1089
.Ve
or
.PP
.Vb 2
\&    % interp -e 'printf("%x", 3735928559)'
\&    deadbeef
.Ve
You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in \fIargv[1]\fR before
calling \fIperl_run()\fR.  
.Sh "Calling a Perl subroutine from your C program"
.IX Subsection "Calling a Perl subroutine from your C program"
To call individual Perl subroutines, you'll need to remove the call to
\fIperl_run()\fR and replace it with a call to \fIperl_call_argv()\fR.
.PP
That's shown below, in a program I'll call \fIshowtime.c\fR.
.PP
.Vb 18
\&    #include <stdio.h>
\&    #include <EXTERN.h>
\&    #include <perl.h>                 
\&    
\&    static PerlInterpreter *my_perl;  
\&    
\&    int main(int argc, char **argv, char **env)
\&    {
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&    
\&        perl_parse(my_perl, NULL, argc, argv, env);
\&    
\&                                     /*** This replaces perl_run() ***/
\&        perl_call_argv("showtime", G_DISCARD | G_NOARGS, argv);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&    }
.Ve
where \fIshowtime\fR is a Perl subroutine that takes no arguments (that's the
\fIG_NOARGS\fR) and for which I'll ignore the return value (that's the 
\fIG_DISCARD\fR).  Those flags, and others, are discussed in the \fIperlcall\fR manpage.
.PP
I'll define the \fIshowtime\fR subroutine in a file called \fIshowtime.pl\fR:
.PP
.Vb 5
\&    print "I shan't be printed.";
\&    
\&    sub showtime {
\&        print time;
\&    }
.Ve
Simple enough.  Now compile and run:
.PP
.Vb 5
\&    % cc -o showtime showtime.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
\&    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
\&    
\&    % showtime showtime.pl
\&    818284590
.Ve
yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the \s-1UNIX\s0 epoch), and the moment I began writing this
sentence.
.PP
If you want to pass some arguments to the Perl subroutine, or
you want to access the return value, you'll need to manipulate the
Perl stack, demonstrated in the last section of this document: 
the section on \fIFiddling with the Perl stack from your C program\fR
.Sh "Evaluating a Perl statement from your C program"
.IX Subsection "Evaluating a Perl statement from your C program"
\s-1NOTE\s0: This section, and the next, employ some very brittle techniques
for evaluting strings of Perl code.  Perl 5.002 contains some nifty
features that enable A Better Way (such as with the \f(CWperl_eval_sv\fR entry in the \fIperlguts\fR manpage).
Look for updates to this document soon.
.PP
One way to evaluate a Perl string is to define a function (we'll call 
ours \fIperl_eval()\fR) that wraps around Perl's the \f(CWeval\fR entry in the \fIperlfunc\fR manpage.
.PP
Arguably, this is the only routine you'll ever need to execute
snippets of Perl code from within your C program.  Your string can be
as long as you wish; it can contain multiple statements; it can
use the \f(CWrequire\fR entry in the \fIperlmod\fR manpage or the \f(CWdo\fR entry in the \fIperlfunc\fR manpage to include external Perl
files.  
.PP
Our \fIperl_eval()\fR lets us evaluate individual Perl strings, and then 
extract variables for coercion into C types.  The following program, 
\fIstring.c\fR, executes three Perl strings, extracting an \f(CWint\fR from
the first, a \f(CWfloat\fR from the second, and a \f(CWchar *\fR from the third.
.PP
.Vb 39
\&   #include <stdio.h>
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&   
\&   static PerlInterpreter *my_perl;
\&   
\&   int perl_eval(char *string)
\&   {
\&     char *argv[2];
\&     argv[0] = string;
\&     argv[1] = NULL;
\&     perl_call_argv("_eval_", 0, argv);
\&   }
\&   
\&   main (int argc, char **argv, char **env)
\&   {
\&     char *embedding[] = { "", "-e", "sub _eval_ { eval $_[0] }" };
\&     STRLEN length;
\&   
\&     my_perl = perl_alloc();
\&     perl_construct( my_perl );
\&   
\&     perl_parse(my_perl, NULL, 3, embedding, env);
\&   
\&                                       /** Treat $a as an integer **/
\&     perl_eval("$a = 3; $a **= 2");
\&     printf("a = %d\en", SvIV(perl_get_sv("a", FALSE)));
\&   
\&                                       /** Treat $a as a float **/
\&     perl_eval("$a = 3.14; $a **= 2");
\&     printf("a = %f\en", SvNV(perl_get_sv("a", FALSE)));
\&   
\&                                       /** Treat $a as a string **/
\&     perl_eval("$a = 'rekcaH lreP rehtonA tsuJ'; $a = reverse($a); ");
\&     printf("a = %s\en", SvPV(perl_get_sv("a", FALSE), length));
\&   
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&   }
.Ve
All of those strange functions with \fIsv\fR in their names help convert Perl scalars to C types.  They're described in the \fIperlguts\fR manpage.
.PP
If you compile and run \fIstring.c\fR, you'll see the results of using
\fISvIV()\fR to create an \f(CWint\fR, \fISvNV()\fR to create a \f(CWfloat\fR, and
\fISvPV()\fR to create a string:
.PP
.Vb 3
\&   a = 9
\&   a = 9.859600
\&   a = Just Another Perl Hacker
.Ve
.Sh "Performing Perl pattern matches and substitutions from your C program"
.IX Subsection "Performing Perl pattern matches and substitutions from your C program"
Our \fIperl_eval()\fR lets us evaluate strings of Perl code, so we can
define some functions that use it to \*(L"specialize\*(R" in matches and
substitutions: \fImatch()\fR, \fIsubstitute()\fR, and \fImatches()\fR.
.PP
.Vb 1
\&   char match(char *string, char *pattern); 
.Ve
Given a string and a pattern (e.g. \*(L"m/clasp/\*(R" or \*(L"/\eb\ew*\eb/\*(R", which in
your program might be represented as \f(CW"/\e\eb\e\ew*\e\eb/"\fR),
returns 1 if the string matches the pattern and 0 otherwise.
.PP
.Vb 1
\&   int substitute(char *string[], char *pattern);
.Ve
Given a pointer to a string and an \*(L"=~\*(R" operation (e.g. \*(L"s/bob/robert/g\*(R" or 
\*(L"tr[A\-Z][a-z]"), modifies the string according to the operation,
returning the number of substitutions made.
.PP
.Vb 1
\&   int matches(char *string, char *pattern, char **matches[]);
.Ve
Given a string, a pattern, and a pointer to an empty array of strings,
evaluates \f(CW$string =~ $pattern\fR in an array context, and fills in
\fImatches\fR with the array elements (allocating memory as it does so), 
returning the number of matches found.
.PP
Here's a sample program, \fImatch.c\fR, that uses all three:
.PP
.Vb 137
\&   #include <stdio.h>
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&   
\&   static PerlInterpreter *my_perl;
\&   
\&   int eval(char *string)
\&   {
\&     char *argv[2];
\&     argv[0] = string;
\&     argv[1] = NULL;
\&     perl_call_argv("_eval_", 0, argv);
\&   }
\&   
\&   /** match(string, pattern)
\&    ** 
\&    ** Used for matches in a scalar context.
\&    **
\&    ** Returns 1 if the match was successful; 0 otherwise. 
\&    **/
\&   char match(char *string, char *pattern) 
\&   {
\&     char *command;
\&     command = malloc(sizeof(char) * strlen(string) + strlen(pattern) + 37);
\&     sprintf(command, "$string = '%s'; $return = $string =~ %s", 
\&        string, pattern); 
\&     perl_eval(command);
\&     free(command);
\&     return SvIV(perl_get_sv("return", FALSE));
\&   }
\&   
\&   /** substitute(string, pattern)
\&    **
\&    ** Used for =~ operations that modify their left-hand side (s/// and tr///)
\&    **
\&    ** Returns the number of successful matches, and
\&    ** modifies the input string if there were any.
\&    **/
\&   int substitute(char *string[], char *pattern) 
\&   {
\&     char *command;
\&     STRLEN length;
\&     command = malloc(sizeof(char) * strlen(*string) + strlen(pattern) + 35);
\&     sprintf(command, "$string = '%s'; $ret = ($string =~ %s)", 
\&        *string, pattern); 
\&     perl_eval(command);
\&     free(command);
\&     *string = SvPV(perl_get_sv("string", FALSE), length);
\&     return SvIV(perl_get_sv("ret", FALSE));
\&   }
\&   
\&   /** matches(string, pattern, matches)
\&    ** 
\&    ** Used for matches in an array context.
\&    **
\&    ** Returns the number of matches, 
\&    ** and fills in **matches with the matching substrings (allocates memory!)
\&    **/
\&   int matches(char *string, char *pattern, char **matches[]) 
\&   {
\&     char *command;
\&     SV *current_match;
\&     AV *array;
\&     I32 num_matches;
\&     STRLEN length;
\&     int i;
\&   
\&     command = malloc(sizeof(char) * strlen(string) + strlen(pattern) + 38);
\&     sprintf(command, "$string = '%s'; @array = ($string =~ %s)", 
\&        string, pattern); 
\&     perl_eval(command);
\&     free(command);
\&     array = perl_get_av("array", FALSE);
\&     num_matches = av_len(array) + 1; /** assume $[ is 0 **/
\&     *matches = (char **) malloc(sizeof(char *) * num_matches);
\&     for (i = 0; i <= num_matches; i++) {  
\&       current_match = av_shift(array);
\&       (*matches)[i] = SvPV(current_match, length);
\&     }
\&     return num_matches;
\&   }
\&   
\&   main (int argc, char **argv, char **env)
\&   {
\&     char *embedding[] = { "", "-e", "sub _eval_ { eval $_[0] }" };
\&     char *text, **matches;
\&     int num_matches, i;
\&     int j;
\&   
\&     my_perl = perl_alloc();
\&     perl_construct( my_perl );
\&   
\&     perl_parse(my_perl, NULL, 3, embedding, env);
\&   
\&     text = (char *) malloc(sizeof(char) * 486); /** A long string follows! **/
\&     sprintf(text, "%s", "When he is at a convenience store and the bill comes to some amount like 76 cents, Maynard is aware that there is something he *should* do, something that will enable him to get back a quarter, but he has no idea *what*.  He fumbles through his red squeezey changepurse and gives the boy three extra pennies with his dollar, hoping that he might luck into the correct amount.  The boy gives him back two of his own pennies and then the big shiny quarter that is his prize. -RICHH");  
\&   
\&     if (perl_match(text, "m/quarter/")) /** Does text contain 'quarter'? **/
\&       printf("perl_match: Text contains the word 'quarter'.\en\en");
\&     else 
\&       printf("perl_match: Text doesn't contain the word 'quarter'.\en\en");
\&   
\&     if (perl_match(text, "m/eighth/")) /** Does text contain 'eighth'? **/
\&       printf("perl_match: Text contains the word 'eighth'.\en\en");
\&     else 
\&       printf("perl_match: Text doesn't contain the word 'eighth'.\en\en");
\&   
\&                                       /** Match all occurrences of /wi../ **/
\&     num_matches = perl_matches(text, "m/(wi..)/g", &matches);
\&     
\&     printf("perl_matches: m/(wi..)/g found %d matches...\en", num_matches);
\&     for (i = 0; i < num_matches; i++) 
\&       printf("match: %s\en", matches[i]);
\&     printf("\en");
\&     for (i = 0; i < num_matches; i++) {
\&       free(matches[i]);
\&     }
\&     free(matches);
\&   
\&                                       /** Remove all vowels from text **/
\&     num_matches = perl_substitute(&text, "s/[aeiou]//gi");
\&     if (num_matches) {
\&       printf("perl_substitute: s/[aeiou]//gi...%d substitutions made.\en", 
\&        num_matches);
\&       printf("Now text is: %s\en\en", text);
\&     }
\&   
\&                                       /** Attempt a substitution
\&     if (!perl_substitute(&text, "s/Perl/C/")) {
\&       printf("perl_substitute: s/Perl/C...No substitution made.\en\en");
\&     }
\&   
\&     free(text);
\&   
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&   }
.Ve
which produces the output
.PP
.Vb 14
\&   perl_match: Text contains the word 'quarter'.
\&   
\&   perl_match: Text doesn't contain the word 'eighth'.
\&   
\&   perl_matches: m/(wi..)/g found 2 matches...
\&   match: will
\&   match: with
\&   
\&   perl_substitute: s/[aeiou]//gi...139 substitutions made.
\&   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts, Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck  qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH
\&   
\&   perl_substitute: s/Perl/C...No substitution made.
\&      
\&=head2 Fiddling with the Perl stack from your C program
.Ve
When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto \*(L"the Perl
stack\*(R", shut its eyes while some magic happens, and then pop the
results\*(--the return value of your Perl subroutine\*(--off the stack.
   
First you'll need to know how to convert between C types and Perl
types, with \fInewSViv()\fR and \fIsv_setnv()\fR and \fInewAV()\fR and all their
friends.  They're described in the \fIperlguts\fR manpage.
.PP
Then you'll need to know how to manipulate the Perl stack.  That's
described in the \fIperlcall\fR manpage.
.PP
Once you've understood those, embedding Perl in C is easy.  
.PP
Since C has no built-in function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, since Perl implements ** with C's \fIpow()\fR function).  First
I'll create a stub exponentiation function in \fIpower.pl\fR:
.PP
.Vb 4
\&    sub expo {
\&        my ($a, $b) = @_;
\&        return $a ** $b;
\&    }
.Ve
Now I'll create a C program, \fIpower.c\fR, with a function
\fIPerlPower()\fR that contains all the perlguts necessary to push the
two arguments into \fIexpo()\fR and to pop the return value out.  Take a
deep breath...
.PP
.Vb 43
\&    #include <stdio.h>
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&    
\&    static PerlInterpreter *my_perl;
\&    
\&    static void
\&    PerlPower(int a, int b)
\&    {
\&      dSP;                            /* initialize stack pointer      */
\&      ENTER;                          /* everything created after here */
\&      SAVETMPS;                       /* ...is a temporary variable.   */
\&      PUSHMARK(sp);                   /* remember the stack pointer    */
\&      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
\&      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
\&      PUTBACK;                      /* make local stack pointer global */
\&      perl_call_pv("expo", G_SCALAR); /* call the function             */
\&      SPAGAIN;                        /* refresh stack pointer         */
\&                                    /* pop the return value from stack */
\&      printf ("%d to the %dth power is %d.\en", a, b, POPi);
\&      PUTBACK;                               
\&      FREETMPS;                       /* free that return value        */
\&      LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
\&    }
\&    
\&    int main (int argc, char **argv, char **env) 
\&    {
\&      char *my_argv[2];
\&    
\&      my_perl = perl_alloc();
\&      perl_construct( my_perl );
\&    
\&      my_argv[1] = (char *) malloc(10);
\&      sprintf(my_argv[1], "power.pl");
\&    
\&      perl_parse(my_perl, NULL, argc, my_argv, env);
\&      
\&      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
\&    
\&      perl_destruct(my_perl);
\&      perl_free(my_perl);
\&    }
\&    
.Ve
Compile and run:
.PP
.Vb 5
\&    % cc -o power power.c -L/usr/local/lib/perl5/alpha-dec_osf/CORE 
\&    -I/usr/local/lib/perl5/alpha-dec_osf/CORE -lperl -lm
\&    
\&    % power 
\&    3 to the 4th power is 81.
.Ve
.SH "MORAL"
.IX Header "MORAL"
You can sometimes \fIwrite faster code\fR in C, but
you can always \fIwrite code faster\fR in Perl.  Since you can use
each from the other, combine them as you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jon Orwant \fI<orwant@media.mit.edu>\fR, with contributions from
Tim Bunce, Tom Christiansen, Dov Grobgeld, and Ilya Zakharevich.
.PP
December 18, 1995
.PP
Some of this material is excerpted from my book: \fIPerl 5 Interactive\fR, 
Waite Group Press, 1996 (ISBN 1-57169-064-6) and appears
courtesy of Waite Group Press.

.rn }` ''
