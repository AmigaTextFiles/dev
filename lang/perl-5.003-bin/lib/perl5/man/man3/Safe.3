.rn '' }`
''' $RCSfile$$Revision$$Date$
'''
''' $Log$
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
.ds L' '
.ds R' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds L' `
.ds R' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH Safe 3 "perl 5.003 with" "9/Sep/96" "Perl Programmers Reference Guide"
.IX Title "Safe 3"
.UC
.IX Name "Safe - Safe extension module for Perl"
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
.IX Header "NAME"
Safe \- Safe extension module for Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Safe extension module allows the creation of compartments
in which perl code can be evaluated. Each compartment has
.Ip "a new namespace" 8
.IX Item "a new namespace"
The \*(L"root\*(R" of the namespace (i.e. \*(L"main::") is changed to a
different package and code evaluated in the compartment cannot
refer to variables outside this namespace, even with run-time
glob lookups and other tricks. Code which is compiled outside
the compartment can choose to place variables into (or share
variables with) the compartment's namespace and only that
data will be visible to code evaluated in the compartment.
.Sp
By default, the only variables shared with compartments are the
\*(L"underscore\*(R" variables \f(CW$_\fR and \f(CW@_\fR (and, technically, the much less
frequently used \f(CW%_\fR, the _ filehandle and so on). This is because
otherwise perl operators which default to \f(CW$_\fR will not work and neither
will the assignment of arguments to \f(CW@_\fR on subroutine entry.
.Ip "an operator mask" 8
.IX Item "an operator mask"
Each compartment has an associated \*(L"operator mask\*(R". Recall that
perl code is compiled into an internal format before execution.
Evaluating perl code (e.g. via \*(L"eval\*(R" or \*(L"do \*(L'file'") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
Code evaulated in a compartment compiles subject to the
compartment's operator mask. Attempting to evaulate code in a
compartment which contains a masked operator will cause the
compilation to fail with an error. The code will not be executed.
.Sp
By default, the operator mask for a newly created compartment masks
out all operations which give \*(L"access to the system\*(R" in some sense.
This includes masking off operators such as \fIsystem\fR, \fIopen\fR,
\fIchown\fR, and \fIshmget\fR but does not mask off operators such as
\fIprint\fR, \fIsysread\fR and \fI<HANDL>\fR. Those file operators
are allowed since for the code in the compartment to have access
to a filehandle, the code outside the compartment must have explicitly
placed the filehandle variable inside the compartment.
.Sp
Since it is only at the compilation stage that the operator mask
applies, controlled access to potentially unsafe operations can
be achieved by having a handle to a wrapper subroutine (written
outside the compartment) placed into the compartment. For example,
.Sp
.Vb 5
\&    $cpt = new Safe;
\&    sub wrapper {
\&        # vet arguments and perform potentially unsafe operations
\&    }
\&    $cpt->share('&wrapper');
.Ve
.Sh "Operator masks"
.IX Subsection "Operator masks"
An operator mask exists at user-level as a string of bytes of length
\s-1MAXO\s0, each of which is either 0x00 or 0x01. Here, \s-1MAXO\s0 is the number
of operators in the current version of perl. The subroutine \fIMAXO()\fR
(available for export by package Safe) returns the number of operators
in the current version of perl. Note that, unlike the beta versions of
the Safe extension, this is a reliable count of the number of
operators in the currently running perl executable. The presence of a
0x01 byte at offset \fBn\fR of the string indicates that operator number
\fBn\fR should be masked (i.e. disallowed).  The Safe extension makes
available routines for converting from operator names to operator
numbers (and \fIvice versa\fR) and for converting from a list of operator
names to the corresponding mask (and \fIvice versa\fR).
.Sh "Methods in class Safe"
.IX Subsection "Methods in class Safe"
To create a new compartment, use
.PP
.Vb 1
\&    $cpt = new Safe;
.Ve
Optional arguments are (\s-1NAMESPACE\s0, \s-1MASK\s0), where
.Ip "\s-1NAMESPACE\s0" 8
.IX Item "\s-1NAMESPACE\s0"
is the root namespace to use for the compartment (defaults to
\*(L"Safe::Root000000000\*(R", auto-incremented for each new compartment); and
.Ip "\s-1MASK\s0" 8
.IX Item "\s-1MASK\s0"
is the operator mask to use (defaults to a fairly restrictive set).
.PP
The following methods can then be used on the compartment
object returned by the above constructor. The object argument
is implicit in each case.
.Ip "root (\s-1NAMESPACE\s0)" 8
.IX Item "root (\s-1NAMESPACE\s0)"
This is a get-or-set method for the compartment's namespace. With the
\s-1NAMESPACE\s0 argument present, it sets the root namespace for the
compartment. With no \s-1NAMESPACE\s0 argument present, it returns the
current root namespace of the compartment.
.Ip "mask (\s-1MASK\s0)" 8
.IX Item "mask (\s-1MASK\s0)"
This is a get-or-set method for the compartment's operator mask.
With the \s-1MASK\s0 argument present, it sets the operator mask for the
compartment. With no \s-1MASK\s0 argument present, it returns the
current operator mask of the compartment.
.Ip "trap (\s-1OP\s0, ...)" 8
.IX Item "trap (\s-1OP\s0, ...)"
This sets bits in the compartment's operator mask corresponding
to each operator named in the list of arguments. Each \s-1OP\s0 can be
either the name of an operation or its number. See opcode.h or
opcode.pl in the main perl distribution for a canonical list of
operator names.
.Ip "untrap (\s-1OP\s0, ...)" 8
.IX Item "untrap (\s-1OP\s0, ...)"
This resets bits in the compartment's operator mask corresponding
to each operator named in the list of arguments. Each \s-1OP\s0 can be
either the name of an operation or its number. See opcode.h or
opcode.pl in the main perl distribution for a canonical list of
operator names.
.Ip "share (\s-1VARNAME\s0, ...)" 8
.IX Item "share (\s-1VARNAME\s0, ...)"
This shares the \fIvariable\fR\|(s) in the argument list with the compartment.
Each \s-1VARNAME\s0 must be the \fBname\fR of a variable with a leading type
identifier included. Examples of legal variable names are \*(L'$foo\*(R' for
a scalar, \*(L'@foo\*(R' for an array, \*(L'%foo\*(R' for a hash, \*(L'&foo\*(R' for a
subroutine and \*(L'*foo\*(R' for a glob (i.e. all symbol table entries
associated with \*(L"foo\*(R", including scalar, array, hash, sub and filehandle).
.Ip "varglob (\s-1VARNAME\s0)" 8
.IX Item "varglob (\s-1VARNAME\s0)"
This returns a glob for the symbol table entry of \s-1VARNAME\s0 in the package
of the compartment. \s-1VARNAME\s0 must be the \fBname\fR of a variable without
any leading type marker. For example,
.Sp
.Vb 4
\&    $cpt = new Safe 'Root';
\&    $Root::foo = "Hello world";
\&    # Equivalent version which doesn't need to know $cpt's package name:
\&    ${$cpt->varglob('foo')} = "Hello world";
.Ve
.Ip "reval (\s-1STRING\s0)" 8
.IX Item "reval (\s-1STRING\s0)"
This evaluates \s-1STRING\s0 as perl code inside the compartment. The code
can only see the compartment's namespace (as returned by the \fBroot\fR
method). Any attempt by code in \s-1STRING\s0 to use an operator which is
in the compartment's mask will cause an error (at run-time of the
main program but at compile-time for the code in \s-1STRING\s0). The error
is of the form \*(L"%s trapped by operation mask operation...\*(R". If an
operation is trapped in this way, then the code in \s-1STRING\s0 will not
be executed. If such a trapped operation occurs or any other
compile-time or return error, then $@ is set to the error message,
just as with an \fIeval()\fR. If there is no error, then the method returns
the value of the last expression evaluated, or a return statement may
be used, just as with subroutines and \fBeval()\fR. Note that this
behaviour differs from the beta distribution of the Safe extension
where earlier versions of perl made it hard to mimic the return
behaviour of the \fIeval()\fR command.
.Ip "rdo (\s-1FILENAME\s0)" 8
.IX Item "rdo (\s-1FILENAME\s0)"
This evaluates the contents of file \s-1FILENAME\s0 inside the compartment.
See above documentation on the \fBreval\fR method for further details.
.Sh "Subroutines in package Safe"
.IX Subsection "Subroutines in package Safe"
The Safe package contains subroutines for manipulating operator
names and operator masks. All are available for export by the package.
The canonical list of operator names is the contents of the array
op_name defined and initialised in file \fIopcode.h\fR of the Perl
source distribution.
.Ip "ops_to_mask (\s-1OP\s0, ...)" 8
.IX Item "ops_to_mask (\s-1OP\s0, ...)"
This takes a list of operator names and returns an operator mask
with precisely those operators masked.
.Ip "mask_to_ops (\s-1MASK\s0)" 8
.IX Item "mask_to_ops (\s-1MASK\s0)"
This takes an operator mask and returns a list of operator names
corresponding to those operators which are masked in \s-1MASK\s0.
.Ip "opcode (\s-1OP\s0, ...)" 8
.IX Item "opcode (\s-1OP\s0, ...)"
This takes a list of operator names and returns the corresponding
list of opcodes (which can then be used as byte offsets into a mask).
.Ip "opname (\s-1OP\s0, ...)" 8
.IX Item "opname (\s-1OP\s0, ...)"
This takes a list of opcodes and returns the corresponding list of
operator names.
.Ip "fullmask" 8
.IX Item "fullmask"
This just returns a mask which has all operators masked.
It returns the string \*(L"\e1\*(R" x \fIMAXO()\fR.
.Ip "emptymask" 8
.IX Item "emptymask"
This just returns a mask which has all operators unmasked.
It returns the string \*(L"\e0\*(R" x \fIMAXO()\fR. This is useful if you
want a compartment to make use of the namespace protection
features but do not want the default restrictive mask.
.Ip "\s-1MAXO\s0" 8
.IX Item "\s-1MAXO\s0"
This returns the number of operators (and hence the length of an
operator mask). Note that, unlike the beta distributions of the
Safe extension, this is derived from a genuine integer variable
in the perl executable and not from a preprocessor constant.
This means that the Safe extension is more robust in the presence
of mismatched versions of the perl executable and the Safe extension.
.Ip "op_mask" 8
.IX Item "op_mask"
This returns the operator mask which is actually in effect at the
time the invocation to the subroutine is compiled. In general,
this is probably not terribly useful.
.Sh "\s-1AUTHOR\s0"
.IX Subsection "\s-1AUTHOR\s0"
Malcolm Beattie, mbeattie@sable.ox.ac.uk.

.rn }` ''
