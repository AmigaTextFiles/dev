<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Functions and Procedures</TITLE>
<META NAME="description" CONTENT="Functions and Procedures">
<META NAME="keywords" CONTENT="ref">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="ref.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html1217" HREF="node72.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="file:/usr/lib/latex2html/icons/next_motif.gif"></A> <A NAME="tex2html1215" HREF="node69.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="file:/usr/lib/latex2html/icons/up_motif.gif"></A> <A NAME="tex2html1211" HREF="node70.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="file:/usr/lib/latex2html/icons/previous_motif.gif"></A> <A NAME="tex2html1219" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="file:/usr/lib/latex2html/icons/contents_motif.gif"></A> <A NAME="tex2html1220" HREF="node72.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="file:/usr/lib/latex2html/icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html1218" HREF="node72.html">Index</A>
<B>Up:</B> <A NAME="tex2html1216" HREF="node69.html">The system unit</A>
<B> Previous:</B> <A NAME="tex2html1212" HREF="node70.html">TypesConstants and Variables</A>
<BR> <P>
<H1><A NAME="SECTION04120000000000000000">Functions and Procedures</A></H1>
<P>
<H2><A NAME="SECTION04121000000000000000">Abs</A></H2>
<P>
<A NAME="fuAbs">&#160;</A>
<A NAME="5065">&#160;</A>
<H3><A NAME="SECTION04121100000000000000">Declaration:</A></H3>
<P>
<tt>Function Abs  (X : Every numerical type)  : Every numerical type;</tt>
<H3><A NAME="SECTION04121200000000000000">Description:</A></H3>
<P>
<tt>Abs</tt> returns the absolute value of a variable. The result of the
function has the same type as its argument, which can be any numerical
type.
<H3><A NAME="SECTION04121300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION04121400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuRound">Round</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example1;

{ Program to demonstrate the Abs function. }

Var 
  r : real;
  i : integer;

begin
  r:=abs(-1.0);   { r:=1.0 }
  i:=abs(-21);    { i:=21 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04122000000000000000">Addr</A></H2>
<P>
<A NAME="fuAddr">&#160;</A>
<A NAME="5114">&#160;</A>
<H3><A NAME="SECTION04122100000000000000">Declaration:</A></H3>
<P>
<tt>Function Addr  (X : Any type)  : Pointer;</tt>
<H3><A NAME="SECTION04122200000000000000">Description:</A></H3>
<P>
<tt>Addr</tt> returns a pointer to its argument, which can be any type, or a
function or procedure name. The returned pointer isn't typed.
The same result can be obtained by the <tt>@</tt> operator, which can return a
typed pointer (<A NAME="tex2html31" HREF="../prog/prog.html">Programmer's guide</A>\). 
<H3><A NAME="SECTION04122300000000000000">Errors:</A></H3>
<P>
None
<H3><A NAME="SECTION04122400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSizeOf">SizeOf</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example2;

{ Program to demonstrate the Addr function. }

Const Zero : integer = 0;

Var p : pointer;
    i : Integer;

begin
  p:=Addr(p);     { P points to itself }
  p:=Addr(I);     { P points to I }
  p:=Addr(Zero);  { P points to 'Zero' }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04123000000000000000">Append</A></H2>
<P>
<A NAME="proAppend">&#160;</A>
<A NAME="5148">&#160;</A>
<H3><A NAME="SECTION04123100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Append  (Var F : Text) ;</tt>
<H3><A NAME="SECTION04123200000000000000">Description:</A></H3>
<P>
<tt>Append</tt> opens an existing file in append mode. Any data written to
<tt>F</tt> will be appended to the file. If the file didn't exist, it will be
created, contrary to the Turbo Pascal implementation of <tt>Append</tt>, where
a file needed to exist in order to be opened by
append.
<P>
Only text files can be opened in append mode.
<P>
<H3><A NAME="SECTION04123300000000000000">Errors:</A></H3>
<P>
If the file can't be created, a run-time error will be generated.
<H3><A NAME="SECTION04123400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proRewrite">Rewrite</A>,<A HREF="node71.html#proAppend">Append</A>, <A HREF="node71.html#proReset">Reset</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example3;

{ Program to demonstrate the Append function. }

Var f : text;

begin
  Assign (f,'test.txt');
  Rewrite (f);            { file is opened for write, and emptied }
  Writeln (F,'This is the first line of text.txt');
  close (f);
  Append(f);              { file is opened for write, but NOT emptied. 
                            any text written to it is appended.}
  Writeln (f,'This is the second line of text.txt');
  close (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04124000000000000000">Arctan</A></H2>
<P>
<A NAME="fuArctan">&#160;</A>
<A NAME="5187">&#160;</A>
<H3><A NAME="SECTION04124100000000000000">Declaration:</A></H3>
<P>
<tt>Function Arctan  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION04124200000000000000">Description:</A></H3>
<P>
<tt>Arctan</tt> returns the Arctangent of <tt>X</tt>, which can be any Real type.
The resulting angle is in radial units.
<H3><A NAME="SECTION04124300000000000000">Errors:</A></H3>
<P>
None
<H3><A NAME="SECTION04124400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSin">Sin</A>, <A HREF="node71.html#fuCos">Cos</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example4;

{ Program to demonstrate the ArcTan function. }

Var R : Real;

begin
  R:=ArcTan(0);      { R:=0 }
  R:=ArcTan(1)/pi;   { R:=0.25 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04125000000000000000">Assign</A></H2>
<P>
<A NAME="proAssign">&#160;</A>
<A NAME="5221">&#160;</A>
<H3><A NAME="SECTION04125100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Assign  (Var F; Name : String) ;</tt>
<H3><A NAME="SECTION04125200000000000000">Description:</A></H3>
<P>
<tt>Assign</tt> assigns a name to <tt>F</tt>, which can be any file type.
This call doesn't open the file, it just assigns a name to a file variable,
and marks the file as closed.
<H3><A NAME="SECTION04125300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION04125400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proRewrite">Rewrite</A>, <A HREF="node71.html#proAppend">Append</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example5;

{ Program to demonstrate the Assign function. }

Var F : text;

begin
  Assign (F,'');
  Rewrite (f);
  { The following can be put in any file by redirecting it
    from the command line.}
  Writeln (f,'This goes to standard output !');
  Close (f);
  Assign (F,'Test.txt');
  rewrite (f);
  writeln (f,'This doesn''t go to standard output !');
  close (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04126000000000000000">Blockread</A></H2>
<P>
<A NAME="proBlockread">&#160;</A>
<A NAME="5268">&#160;</A>
<H3><A NAME="SECTION04126100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Blockread  (Var F : File; Var Buffer; Var Count : Longint [; var
Result : Longint]) ;</tt>
<H3><A NAME="SECTION04126200000000000000">Description:</A></H3>
<P>
<tt>Blockread</tt> reads <tt>count</tt> or less records from file <tt>F</tt>. The
result is placed in <tt>Buffer</tt>, which must contain enough room for
<tt>Count</tt> records. The function cannot read partial records.
<P>
If <tt>Result</tt> is specified, it contains the number of records actually
read. If <tt>Result</tt> isn't specified, and less than <tt>Count</tt> records were
read, a run-time error is generated. This behavior can be controlled by the
<tt>{$i}</tt> switch. 
<H3><A NAME="SECTION04126300000000000000">Errors:</A></H3>
<P>
If <tt>Result</tt> isn't specified, then a run-time error is generated if less
than <tt>count</tt> records were read.
<H3><A NAME="SECTION04126400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proBlockwrite">Blockwrite</A>, <A HREF="node71.html#proClose">Close</A>, <A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proAssign">Assign</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example6;

{ Program to demonstrate the BlockRead and BlockWrite functions. }

Var Fin, fout : File;
    NumRead,NumWritten : Word;
    Buf : Array[1..2048] of byte;
    Total : Longint;

begin
  Assign (Fin, Paramstr(1));
  Assign (Fout,Paramstr(2));
  Reset (Fin,1);
  Rewrite (Fout,1);
  Total:=0;
  Repeat
    BlockRead (Fin,buf,Sizeof(buf),NumRead);
    BlockWrite (Fout,Buf,NumRead,NumWritten);
    inc(Total,NumWritten);
  Until (NumRead=0) or (NumWritten&lt;&gt;NumRead);
  Write ('Copied ',Total,' bytes from file ',paramstr(1));
  Writeln (' to file ',paramstr(2));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04127000000000000000">Blockwrite</A></H2>
<P>
<A NAME="proBlockwrite">&#160;</A>
<A NAME="5341">&#160;</A>
<H3><A NAME="SECTION04127100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Blockwrite  (Var F : File; Var Buffer; Var Count : Longint) ;</tt>
<H3><A NAME="SECTION04127200000000000000">Description:</A></H3>
<P>
<tt>BlockWrite</tt> writes <tt>count</tt> records from <tt>buffer</tt> to the file
 <tt>F</tt>. 
If the records couldn't be written to disk, a run-time error is generated.
This behavior can be controlled by the <tt>{$i}</tt> switch.
<P>
<H3><A NAME="SECTION04127300000000000000">Errors:</A></H3>
<P>
A run-time error is generated if, for some reason, the records couldn't be
written to disk.
<H3><A NAME="SECTION04127400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proBlockread">Blockread</A>,<A HREF="node71.html#proClose">Close</A>, <A HREF="node71.html#proRewrite">Rewrite</A>, <A HREF="node71.html#proAssign">Assign</A>
<P>
For the example, see <A HREF="node71.html#proBlockread">Blockread</A>.
<P>
<H2><A NAME="SECTION04128000000000000000">Chdir</A></H2>
<P>
<A NAME="proChdir">&#160;</A>
<A NAME="5373">&#160;</A>
<H3><A NAME="SECTION04128100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Chdir  (const S : string) ;</tt>
<H3><A NAME="SECTION04128200000000000000">Description:</A></H3>
<P>
<tt>Chdir</tt> changes the working directory of the process to <tt>S</tt>.
<H3><A NAME="SECTION04128300000000000000">Errors:</A></H3>
<P>
If the directory <tt>S</tt> doesn't exist, a run-time error is generated.
<H3><A NAME="SECTION04128400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proMkdir">Mkdir</A>, <A HREF="node71.html#proRmdir">Rmdir</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example7;

{ Program to demonstrate the ChDir function. }

begin
  {$I-}
  ChDir (ParamStr(1));
  if IOresult&lt;&gt;0 then 
    Writeln ('Cannot change to directory : ',paramstr (1));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION04129000000000000000">Chr</A></H2>
<P>
<A NAME="fuChr">&#160;</A>
<A NAME="5409">&#160;</A>
<H3><A NAME="SECTION04129100000000000000">Declaration:</A></H3>
<P>
<tt>Function Chr  (X : byte)  : Char;</tt>
<H3><A NAME="SECTION04129200000000000000">Description:</A></H3>
<P>
<tt>Chr</tt> returns the character which has ASCII value <tt>X</tt>.
<H3><A NAME="SECTION04129300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION04129400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuOrd">Ord</A>,<A HREF="node71.html#proStr">Str</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example8;

{ Program to demonstrate the Chr function. }

begin
  Write (chr(10),chr(13)); { The same effect as Writeln; } 
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041210000000000000000">Close</A></H2>
<P>
<A NAME="proClose">&#160;</A>
<A NAME="5449">&#160;</A>
<H3><A NAME="SECTION041210100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Close  (Var F : Anyfiletype) ;</tt>
<H3><A NAME="SECTION041210200000000000000">Description:</A></H3>
<P>
<tt>Close</tt> flushes the buffer of the file <tt>F</tt> and closes <tt>F</tt>.
After a call to <tt>Close</tt>, data can no longer be read from or written to
<tt>F</tt>.
<P>
To reopen a file closed with <tt>Close</tt>, it isn't necessary to assign the
file again. A call to <A HREF="node71.html#proReset">Reset</A> or <A HREF="node71.html#proRewrite">Rewrite</A> is sufficient.
<H3><A NAME="SECTION041210300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041210400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proRewrite">Rewrite</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example9;

{ Program to demonstrate the Close function. }

Var F : text;

begin
 Assign (f,'Test.txt');
 ReWrite (F);
 Writeln (F,'Some text written to Test.txt');
 close (f); { Flushes contents of buffer to disk, 
              closes the file. Omitting this may
              cause data NOT to be written to disk.}
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041211000000000000000">Concat</A></H2>
<P>
<A NAME="fuConcat">&#160;</A>
<A NAME="5505">&#160;</A>
<H3><A NAME="SECTION041211100000000000000">Declaration:</A></H3>
<P>
<tt>Function Concat  (S1,S2 [,S3, ... ,Sn])  : String;</tt>
<H3><A NAME="SECTION041211200000000000000">Description:</A></H3>
<P>
<tt>Concat</tt> concatenates the strings <tt>S1</tt>,<tt>S2</tt> etc. to one long
string. The resulting string is truncated at a length of 255 bytes.
<P>
The same operation can be performed with the <tt>+</tt> operation.
<H3><A NAME="SECTION041211300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041211400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuCopy">Copy</A>, <A HREF="node71.html#proDelete">Delete</A>, <A HREF="node71.html#proInsert">Insert</A>, <A HREF="node71.html#fuPos">Pos</A>, <A HREF="node71.html#fuLength">Length</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example10;

{ Program to demonstrate the Concat function. }
Var 
  S : String;
  
begin
  S:=Concat('This can be done',' Easier ','with the + operator !');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041212000000000000000">Copy</A></H2>
<P>
<A NAME="fuCopy">&#160;</A>
<A NAME="5559">&#160;</A>
<H3><A NAME="SECTION041212100000000000000">Declaration:</A></H3>
<P>
<tt>Function Copy  (Const S : String;Index : Integer;Count : Byte)  : String;</tt>
<H3><A NAME="SECTION041212200000000000000">Description:</A></H3>
<P>
<tt>Copy</tt> returns a string which is a copy if the <tt>Count</tt> characters
in <tt>S</tt>, starting at position <tt>Index</tt>. If <tt>Count</tt> is larger than
the length of the string <tt>S</tt>, the result is truncated.
<P>
If <tt>Index</tt> is larger than the length of the string <tt>S</tt>, then an
empty string is returned.
<H3><A NAME="SECTION041212300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041212400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proDelete">Delete</A>, <A HREF="node71.html#proInsert">Insert</A>, <A HREF="node71.html#fuPos">Pos</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example11;

{ Program to demonstrate the Copy function. }

Var S,T : String;

begin
  T:='1234567';
  S:=Copy (T,1,2);   { S:='12'   }
  S:=Copy (T,4,2);   { S:='45'   }
  S:=Copy (T,4,8);   { S:='4567' }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041213000000000000000">Cos</A></H2>
<P>
<A NAME="fuCos">&#160;</A>
<A NAME="5608">&#160;</A>
<H3><A NAME="SECTION041213100000000000000">Declaration:</A></H3>
<P>
<tt>Function Cos  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041213200000000000000">Description:</A></H3>
<P>
<tt>Cos</tt> returns the cosine of <tt>X</tt>, where X is an angle, in radians.
<H3><A NAME="SECTION041213300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041213400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuArctan">Arctan</A>, <A HREF="node71.html#fuSin">Sin</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example12;

{ Program to demonstrate the Cos function. }

Var R : Real;

begin
  R:=Cos(Pi);    { R:=-1 }
  R:=Cos(Pi/2);  { R:=0  }
  R:=Cos(0);     { R:=1  }    
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041214000000000000000">CSeg</A></H2>
<P>
<A NAME="fuCSeg">&#160;</A>
<A NAME="5642">&#160;</A>
<H3><A NAME="SECTION041214100000000000000">Declaration:</A></H3>
<P>
<tt>Function CSeg    : Word;</tt>
<H3><A NAME="SECTION041214200000000000000">Description:</A></H3>
<P>
<tt>CSeg</tt> returns the Code segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
<H3><A NAME="SECTION041214300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041214400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuDSeg">DSeg</A>, <A HREF="node71.html#fuSeg">Seg</A>, <A HREF="node71.html#fuOfs">Ofs</A>, <A HREF="node71.html#fuPtr">Ptr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example13;

{ Program to demonstrate the CSeg function. }

var W : word;

begin
  W:=CSeg; {W:=0, provided for comppatibility,
                  FPC is 32 bit.}
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041215000000000000000">Dec</A></H2>
<P>
<A NAME="proDec">&#160;</A>
<A NAME="5681">&#160;</A>
<H3><A NAME="SECTION041215100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Dec  (Var X : Any ordinal type[; Decrement : Longint]) ;</tt>
<H3><A NAME="SECTION041215200000000000000">Description:</A></H3>
<P>
<tt>Dec</tt> decreases the value of <tt>X</tt> with <tt>Decrement</tt>.
If <tt>Decrement</tt> isn't specified, then 1 is taken as a default.
<H3><A NAME="SECTION041215300000000000000">Errors:</A></H3>
<P>
A range check can occur, or an underflow error, if you try to decrease <tt>X</tt>
below its minimum value.
<H3><A NAME="SECTION041215400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proInc">Inc</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example14;

{ Program to demonstrate the Dec function. }

Var 
  I  : Integer;
  L  : Longint;
  W  : Word;
  B  : Byte;
  Si : ShortInt;

begin
 I:=1;
 L:=2;
 W:=3;
 B:=4;
 Si:=5;
 Dec (i);    { i:=0  }
 Dec (L,2);  { L:=0  }
 Dec (W,2);  { W:=1  }
 Dec (B,-2); { B:=6  }
 Dec (Si,0); { Si:=5 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041216000000000000000">Delete</A></H2>
<P>
<A NAME="proDelete">&#160;</A>
<A NAME="5721">&#160;</A>
<H3><A NAME="SECTION041216100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Delete  (var S : string;Index : Integer;Count : Integer) ;</tt>
<H3><A NAME="SECTION041216200000000000000">Description:</A></H3>
<P>
<tt>Delete</tt> removes <tt>Count</tt> characters from string <tt>S</tt>, starting
at position <tt>Index</tt>. All remaining characters are shifted <tt>Count</tt> 
positions to the left, and the length of the string is adjusted.
<P>
<H3><A NAME="SECTION041216300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041216400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuCopy">Copy</A>,<A HREF="node71.html#fuPos">Pos</A>,<A HREF="node71.html#proInsert">Insert</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example15;

{ Program to demonstrate the Delete function. }

Var 
  S : String;

begin
  S:='This is not easy !';
  Delete (S,9,4); { S:='This is easy !' }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041217000000000000000">Dispose</A></H2>
<P>
<A NAME="proDispose">&#160;</A>
<A NAME="5765">&#160;</A>
<H3><A NAME="SECTION041217100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Dispose  (P : pointer) ;</tt>
<H3><A NAME="SECTION041217200000000000000">Description:</A></H3>
<P>
<tt>Dispose</tt> releases the memory allocated with a call to <A HREF="node71.html#proNew">New</A>.
The pointer <tt>P</tt> must be typed. The released memory is returned to the
heap.
<H3><A NAME="SECTION041217300000000000000">Errors:</A></H3>
<P>
An error will occur if the pointer doesn't point to a location in the
heap.
<H3><A NAME="SECTION041217400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proNew">New</A>, <A HREF="node71.html#proGetmem">Getmem</A>, <A HREF="node71.html#proFreemem">Freemem</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example16;

{ Program to demonstrate the Dispose and New functions. }

Type SS = String[20];
     
     AnObj = Object
       I : integer;
       Constructor Init;
       Destructor Done;
       end;

Var 
  P : ^SS;
  T : ^AnObj;
  
Constructor Anobj.Init;

begin
 Writeln ('Initializing an instance of AnObj !');
end;

Destructor AnObj.Done;

begin
  Writeln ('Destroying an instance of AnObj !');
end;
  
begin
  New (P);
  P^:='Hello, World !';
  Dispose (P);
  { P is undefined from here on !}
  New(T,Init);
  T^.i:=0;
  Dispose (T,Done);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041218000000000000000">DSeg</A></H2>
<P>
<A NAME="fuDSeg">&#160;</A>
<A NAME="5805">&#160;</A>
<H3><A NAME="SECTION041218100000000000000">Declaration:</A></H3>
<P>
<tt>Function DSeg    : Word;</tt>
<H3><A NAME="SECTION041218200000000000000">Description:</A></H3>
<P>
<tt>DSeg</tt> returns the data segment register. In Free Pascal, it returns always a
zero, since Free Pascal is a 32 bit compiler.
<H3><A NAME="SECTION041218300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041218400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuCSeg">CSeg</A>, <A HREF="node71.html#fuSeg">Seg</A>, <A HREF="node71.html#fuOfs">Ofs</A>, <A HREF="node71.html#fuPtr">Ptr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example17;

{ Program to demonstrate the DSeg function. }

Var
  W : Word;

begin
  W:=DSeg; {W:=0, This function is provided for compatibility,
                  FPC is a 32 bit comiler.}
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041219000000000000000">Eof</A></H2>
<P>
<A NAME="fuEof">&#160;</A>
<A NAME="5848">&#160;</A>
<H3><A NAME="SECTION041219100000000000000">Declaration:</A></H3>
<P>
<tt>Function Eof  [(F : Any file type)]  : Boolean;</tt>
<H3><A NAME="SECTION041219200000000000000">Description:</A></H3>
<P>
<tt>Eof</tt> returns <tt>True</tt> if the file-pointer has reached the end of the
file, or if the file is empty. In all other cases <tt>Eof</tt> returns
<tt>False</tt>.
<P>
If no file <tt>F</tt> is specified, standard input is assumed.
<H3><A NAME="SECTION041219300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041219400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuEoln">Eoln</A>, <A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proRewrite">Rewrite</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example18;

{ Program to demonstrate the Eof function. }

Var T1,T2 : text;
    C : Char;

begin
  { Set file to read from. Empty means from standard input.}
  assign (t1,paramstr(1));
  reset (t1);
  { Set file to write to. Empty means to standard output. }
  assign (t2,paramstr(2));
  rewrite (t2);
  While not eof(t1) do
    begin
    read (t1,C);
    write (t2,C);
    end;
  Close (t1);
  Close (t2);  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041220000000000000000">Eoln</A></H2>
<P>
<A NAME="fuEoln">&#160;</A>
<A NAME="5900">&#160;</A>
<H3><A NAME="SECTION041220100000000000000">Declaration:</A></H3>
<P>
<tt>Function Eoln  [(F : Text)]  : Boolean;</tt>
<H3><A NAME="SECTION041220200000000000000">Description:</A></H3>
<P>
<tt>Eof</tt> returns <tt>True</tt> if the file pointer has reached the end of a
line, which is demarcated by a line-feed character (ASCII value 10), or if
the end of the file is reached.
In all other cases <tt>Eof</tt> returns <tt>False</tt>.
<P>
If no file <tt>F</tt> is specified, standard input is assumed.
It can only be used on files of type <tt>Text</tt>.
<H3><A NAME="SECTION041220300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041220400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuEof">Eof</A>, <A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proRewrite">Rewrite</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example19;

{ Program to demonstrate the Eoln function. }

begin
  { This program waits for keyboard input. }
  { It will print True when an empty line is put in,
    and false when you type a non-empty line.
    It will only stop when you press enter.}
  Writeln (eoln);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041221000000000000000">Erase</A></H2>
<P>
<A NAME="proErase">&#160;</A>
<A NAME="5948">&#160;</A>
<H3><A NAME="SECTION041221100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Erase  (Var F : Any file type) ;</tt>
<H3><A NAME="SECTION041221200000000000000">Description:</A></H3>
<P>
<tt>Erase</tt> removes an unopened file from disk. The file should be
assigned with <tt>Assign</tt>, but not opened with <tt>Reset</tt> or <tt>Rewrite</tt>
<H3><A NAME="SECTION041221300000000000000">Errors:</A></H3>
<P>
A run-time error will be generated if the specified file doesn't exist.
<H3><A NAME="SECTION041221400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proAssign">Assign</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example20;

{ Program to demonstrate the Erase function. }

Var F : Text;

begin
  { Create a file with a line of text in it}
  Assign (F,'test.txt');
  Rewrite (F);
  Writeln (F,'Try and find this when I''m finished !');
  close (f);
  { Now remove the file }
  Erase (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041222000000000000000">Exit</A></H2>
<P>
<A NAME="proExit">&#160;</A>
<A NAME="5983">&#160;</A>
<H3><A NAME="SECTION041222100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Exit  ([Var X : return type )] ;</tt>
<H3><A NAME="SECTION041222200000000000000">Description:</A></H3>
<P>
<tt>Exit</tt> exits the current subroutine, and returns control to the calling
routine. If invoked in the main program routine, exit stops the program.
<P>
The optional argument <tt>X</tt> allows to specify a return value, in the case
<tt>Exit</tt> is invoked in a function. The function result will then be
equal to <tt>X</tt>.
<H3><A NAME="SECTION041222300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041222400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proHalt">Halt</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example21;

{ Program to demonstrate the Exit function. }

Procedure DoAnExit (Yes : Boolean);

{ This procedure demonstrates the normal Exit }

begin
  Writeln ('Hello from DoAnExit !');
  If Yes then
    begin
    Writeln ('Bailing out early.');
    exit;
    end;
  Writeln ('Continuing to the end.');
end;

Function Positive (Which : Integer) : Boolean;

{ This function demonstrates the extra FPC feature of Exit : 
  You can specify a return value for the function }

begin
  if Which&gt;0 then
    exit (True)
  else
    exit (False);
end;   

begin
  { This call will go to the end }
  DoAnExit (False);
  { This call will bail out early }
  DoAnExit (True);
  if Positive (-1) then 
    Writeln ('The compiler is nuts, -1 is not positive.')
  else
    Writeln ('The compiler is not so bad, -1 seems to be negative.');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041223000000000000000">Exp</A></H2>
<P>
<A NAME="fuExp">&#160;</A>
<A NAME="6020">&#160;</A>
<H3><A NAME="SECTION041223100000000000000">Declaration:</A></H3>
<P>
<tt>Function Exp  (Var X : Real)  : Real;</tt>
<H3><A NAME="SECTION041223200000000000000">Description:</A></H3>
<P>
<tt>Exp</tt> returns the exponent of <tt>X</tt>, i.e. the number <tt>e</tt> to the
power <tt>X</tt>.
<H3><A NAME="SECTION041223300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041223400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuLn">Ln</A>, <A HREF="node71.html#fuPower">Power</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example22;

{ Program to demonstrate the Exp function. }

begin
  Writeln (Exp(1):8:2); { Should print 2.72 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041224000000000000000">Filepos</A></H2>
<P>
<A NAME="fuFilepos">&#160;</A>
<A NAME="6058">&#160;</A>
<H3><A NAME="SECTION041224100000000000000">Declaration:</A></H3>
<P>
<tt>Function Filepos  (Var F : Any file type)  : Longint;</tt>
<H3><A NAME="SECTION041224200000000000000">Description:</A></H3>
<P>
<tt>Filepos</tt> returns the current record position of the file-pointer in file
<tt>F</tt>. It cannot be invoked with a file of type <tt>Text</tt>.
<H3><A NAME="SECTION041224300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041224400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuFilesize">Filesize</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example23;

{ Program to demonstrate the FilePos function. }

Var F : File of Longint;
    L,FP : longint;
    
begin
  { Fill a file with data : 
    Each position contains the position ! }
  Assign (F,'test.dat');
  Rewrite (F);
  For L:=0 to 100 do
    begin
    FP:=FilePos(F);
    Write (F,FP);
    end;
  Close (F);
  Reset (F);
  { If ll goes well, nothing is displayed here. }
  While not (Eof(F)) do
    begin
    FP:=FilePos (F);
    Read (F,L);
    if L&lt;&gt;FP then 
      Writeln ('Something is wrong here ! : Got ',l,' on pos ',FP);
    end;
  Close (F);
  Erase (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041225000000000000000">Filesize</A></H2>
<P>
<A NAME="fuFilesize">&#160;</A>
<A NAME="6092">&#160;</A>
<H3><A NAME="SECTION041225100000000000000">Declaration:</A></H3>
<P>
<tt>Function Filesize  (Var F : Any file type)  : Longint;</tt>
<H3><A NAME="SECTION041225200000000000000">Description:</A></H3>
<P>
<tt>Filepos</tt> returns the total number of records in file <tt>F</tt>. 
It cannot be invoked with a file of type <tt>Text</tt>. (under LINUX, this
also means that it cannot be invoked on pipes.)
<P>
If <tt>F</tt> is empty, 0 is returned.
<P>
<H3><A NAME="SECTION041225300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041225400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuFilepos">Filepos</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example24;

{ Program to demonstrate the FileSize function. }

Var F : File Of byte;
    L : File Of Longint;

begin
  Assign (F,paramstr(1));
  Reset (F);
  Writeln ('File size in bytes : ',FileSize(F));
  Close (F);
  Assign (L,paramstr (1));
  Reset (L);
  Writeln ('File size in Longints : ',FileSize(L));
  Close (f);  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041226000000000000000">Fillchar</A></H2>
<P>
<A NAME="proFillchar">&#160;</A>
<A NAME="6130">&#160;</A>
<H3><A NAME="SECTION041226100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Fillchar  (Var X;Count : Longint;Value : char or byte); ;</tt>
<H3><A NAME="SECTION041226200000000000000">Description:</A></H3>
<P>
<tt>Fillchar</tt> fills the memory starting at <tt>X</tt> with <tt>Count</tt> bytes
or characters with value equal to <tt>Value</tt>.
<P>
<H3><A NAME="SECTION041226300000000000000">Errors:</A></H3>
<P>
No checking on the size of <tt>X</tt> is done.
<H3><A NAME="SECTION041226400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proFillword">Fillword</A>, <A HREF="node71.html#proMove">Move</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example25;

{ Program to demonstrate the FillChar function. }

Var S : String[10];
    I : Byte;
begin
  For i:=10 downto 0 do
    begin
    { Fill S with i spaces }
    FillChar (S,SizeOf(S),' ');
    { Set Length }
    S[0]:=chr(i);
    Writeln (s,'*');
    end;
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041227000000000000000">Fillword</A></H2>
<P>
<A NAME="proFillword">&#160;</A>
<A NAME="6172">&#160;</A>
<H3><A NAME="SECTION041227100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Fillword  (Var X;Count : Longint;Value : Word); ;</tt>
<H3><A NAME="SECTION041227200000000000000">Description:</A></H3>
<P>
<tt>Fillword</tt> fills the memory starting at <tt>X</tt> with <tt>Count</tt> words
with value equal to <tt>Value</tt>.
<P>
<H3><A NAME="SECTION041227300000000000000">Errors:</A></H3>
<P>
No checking on the size of <tt>X</tt> is done.
<H3><A NAME="SECTION041227400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proFillword">Fillword</A>, <A HREF="node71.html#proMove">Move</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example76;

{ Program to demonstrate the FillWord function. }

Var W : Array[1..100] of Word;

begin
  { Quick initialization of array W }
  FillWord(W,100,0);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041228000000000000000">Flush</A></H2>
<P>
<A NAME="proFlush">&#160;</A>
<A NAME="6211">&#160;</A>
<H3><A NAME="SECTION041228100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Flush  (Var F : Text) ;</tt>
<H3><A NAME="SECTION041228200000000000000">Description:</A></H3>
<P>
<tt>Flush</tt> empties the internal buffer of file <tt>F</tt> and writes the
contents to disk. The file is <i>not</i> closed as a result of this call.
<H3><A NAME="SECTION041228300000000000000">Errors:</A></H3>
<P>
If the disk is full, a run-time error will be generated.
<H3><A NAME="SECTION041228400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proClose">Close</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example26;

{ Program to demonstrate the Flush function. }

Var F : Text;

begin
  { Assign F to standard output }
  Assign (F,'');
  Rewrite (F);
  Writeln (F,'This line is written first, but appears later !');
  { At this point the text is in the internal pascal buffer,
    and not yet written to standard output }
  Writeln ('This line appears first, but is written later !');
  { A writeln to 'output' always causes a flush - so this text is 
    written to screen }
  Flush (f);
  { At this point, the text written to F is written to screen. }
  Write (F,'Finishing ');
  Close (f);  { Closing a file always causes a flush first } 
  Writeln ('off.');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041229000000000000000">Frac</A></H2>
<P>
<A NAME="fuFrac">&#160;</A>
<A NAME="6243">&#160;</A>
<H3><A NAME="SECTION041229100000000000000">Declaration:</A></H3>
<P>
<tt>Function Frac  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041229200000000000000">Description:</A></H3>
<P>
<tt>Frac</tt> returns the non-integer part of <tt>X</tt>.
<H3><A NAME="SECTION041229300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041229400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuRound">Round</A>, <A HREF="node71.html#fuInt">Int</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example27;

{ Program to demonstrate the Frac function. }

Var R : Real;

begin
  Writeln (Frac (123.456):0:3);  { Prints  O.456 }
  Writeln (Frac (-123.456):0:3); { Prints -O.456 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041230000000000000000">Freemem</A></H2>
<P>
<A NAME="proFreemem">&#160;</A>
<A NAME="6280">&#160;</A>
<H3><A NAME="SECTION041230100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Freemem  (Var P : pointer; Count : Longint) ;</tt>
<H3><A NAME="SECTION041230200000000000000">Description:</A></H3>
<P>
<tt>Freemem</tt> releases the memory occupied by the pointer <tt>P</tt>, of size
<tt>Count</tt>, and returns it to the heap. <tt>P</tt> should point to the memory
allocated to a dynamical variable.
<H3><A NAME="SECTION041230300000000000000">Errors:</A></H3>
<P>
An error will occur when <tt>P</tt> doesn't point to the heap.
<H3><A NAME="SECTION041230400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proGetmem">Getmem</A>, <A HREF="node71.html#proNew">New</A>, <A HREF="node71.html#proDispose">Dispose</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example28;

{ Program to demonstrate the FreeMem and GetMem functions. }

Var P : Pointer;
    MM : Longint;
    
begin
  { Get memory for P }
  MM:=MemAvail;
  Writeln ('Memory available before GetMem : ',MemAvail);
  GetMem (P,80);
  MM:=MM-Memavail;
  Write   ('Memory available after GetMem  : ',MemAvail);
  Writeln (' or ',MM,' bytes less than before the call.');
  { fill it with spaces }
  FillChar (P^,80,' ');
  { Free the memory again }                       
  FreeMem (P,80);
  Writeln ('Memory available after FreeMem : ',MemAvail);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041231000000000000000">Getdir</A></H2>
<P>
<A NAME="proGetdir">&#160;</A>
<A NAME="6324">&#160;</A>
<H3><A NAME="SECTION041231100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Getdir  (drivenr : byte;var dir : string) ;</tt>
<H3><A NAME="SECTION041231200000000000000">Description:</A></H3>
<P>
<tt>Getdir</tt> returns in <tt>dir</tt> the current directory on the drive
<tt>drivenr</tt>, where drivenr is 1 for the first floppy drive, 3 for the
first hard disk etc. A value of 0 returns the directory on the current disk.
<P>
On LINUX, <tt>drivenr</tt> is ignored, as there is only one directory tree.
<H3><A NAME="SECTION041231300000000000000">Errors:</A></H3>
<P>
An error is returned under DOS, if the drive requested isn't ready.
<H3><A NAME="SECTION041231400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proChdir">Chdir</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example29;

{ Program to demonstrate the GetDir function. }

Var S : String;

begin
  GetDir (0,S);
  Writeln ('Current directory is : ',S);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041232000000000000000">Getmem</A></H2>
<P>
<A NAME="proGetmem">&#160;</A>
<A NAME="6372">&#160;</A>
<H3><A NAME="SECTION041232100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Getmem  (var p : pointer;size : Longint) ;</tt>
<H3><A NAME="SECTION041232200000000000000">Description:</A></H3>
<P>
<tt>Getmem</tt> reserves <tt>Size</tt> bytes memory on the heap, and returns a
pointer to this memory in <tt>p</tt>. If no more memory is available, nil is
returned.
<H3><A NAME="SECTION041232300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041232400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proFreemem">Freemem</A>, <A HREF="node71.html#proDispose">Dispose</A>, <A HREF="node71.html#proNew">New</A>
<P>
For an example, see <A HREF="node71.html#proFreemem">Freemem</A>.
<P>
<H2><A NAME="SECTION041233000000000000000">Halt</A></H2>
<P>
<A NAME="proHalt">&#160;</A>
<A NAME="6397">&#160;</A>
<H3><A NAME="SECTION041233100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Halt  [(Errnum : byte] ;</tt>
<H3><A NAME="SECTION041233200000000000000">Description:</A></H3>
<P>
<tt>Halt</tt> stops program execution and returns control to the calling
program. The optional argument <tt>Errnum</tt> specifies an exit value. If
omitted, zero is returned.
<H3><A NAME="SECTION041233300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041233400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proExit">Exit</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example30;

{ Program to demonstrate the Halt function. }

begin
 Writeln ('Before Halt.');
 Halt (1); { Stop with exit code 1 }
 Writeln ('After Halt doesn''t get executed.');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041234000000000000000">Hi</A></H2>
<P>
<A NAME="fuHi">&#160;</A>
<A NAME="6428">&#160;</A>
<H3><A NAME="SECTION041234100000000000000">Declaration:</A></H3>
<P>
<tt>Function Hi  (X : Ordinal type)  : Word or byte;</tt>
<H3><A NAME="SECTION041234200000000000000">Description:</A></H3>
<P>
<tt>Hi</tt> returns the high byte or word from <tt>X</tt>, depending on the size
of X. If the size of X is 4, then the high word is returned. If the size is
2 then the high byte is retuned. 
<tt>hi</tt> cannot be invoked on types of size 1, such as byte or char.
<H3><A NAME="SECTION041234300000000000000">Errors:</A></H3>
<P>
None
<H3><A NAME="SECTION041234400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuLo">Lo</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example31;

{ Program to demonstrate the Hi function. }

var
  L : Longint;
  W : Word;
  
begin
  L:=1 Shl 16;     { = $10000 }
  W:=1 Shl 8;      { = $100 }
  Writeln (Hi(L)); { Prints 1 }
  Writeln (Hi(W)); { Prints 1 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041235000000000000000">High</A></H2>
<P>
<A NAME="fuHigh">&#160;</A>
<A NAME="6467">&#160;</A>
<H3><A NAME="SECTION041235100000000000000">Declaration:</A></H3>
<P>
<tt>Function High  (Type identifier or variable reference)  : Longint;</tt>
<H3><A NAME="SECTION041235200000000000000">Description:</A></H3>
<P>
 The return value of <tt>High</tt> depends on it's argument:
<OL>
<LI> If the argument is an ordinal type, <tt>High</tt> returns the lowest value in the range of the given ordinal 
type when it gets.
<LI> If the argument is an array type or an array type variable then 
<tt>High</tt> returns the highest possible value of it's index.
<LI> If the argument is an open array identifier in a function or
procedure, then <tt>High</tt> returns the highest index of the array, as if the
array has a zero-based index.
</OL><H3><A NAME="SECTION041235300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041235400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuHigh">High</A>, <A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuPred">Pred</A>, <A HREF="node71.html#fuSucc">Succ</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program example80;

{ Example to demonstrate the High and Low functions. }

Type TEnum = ( North, East, South, West );
     TRange = 14..55;
     TArray = Array [2..10] of Longint;
    
Function Average (Row : Array of Longint) : Real;

Var I : longint;
    Temp : Real;
   
   
begin
  Temp := Row[0];
  For I := 1 to High(Row) do
     Temp := Temp + Row[i];
  Average := Temp / (High(Row)+1);
end;
                  
Var A : TEnum;
    B : TRange;
    C : TArray;
    I : longint;
    
begin
  Writeln ('TEnum  goes from : ',Ord(Low(TEnum)),' to ', Ord(high(TEnum)),'.');
  Writeln ('A      goes from : ',Ord(Low(A)),' to ', Ord(high(A)),'.');
  Writeln ('TRange goes from : ',Ord(Low(TRange)),' to ', Ord(high(TRange)),'.');
  Writeln ('B      goes from : ',Ord(Low(B)),' to ', Ord(high(B)),'.');
  Writeln ('TArray index goes from : ',Ord(Low(TArray)),' to ', Ord(high(TArray)),'.');
  Writeln ('C index      goes from : ',Low(C),' to ', high(C),'.');
  For I:=Low(C) to High(C) do
    C[i]:=I;
  Writeln ('Average :',Average(c));  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041236000000000000000">Inc</A></H2>
<P>
<A NAME="proInc">&#160;</A>
<A NAME="6514">&#160;</A>
<H3><A NAME="SECTION041236100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Inc  (Var X : Any ordinal type[; Increment : Longint]) ;</tt>
<H3><A NAME="SECTION041236200000000000000">Description:</A></H3>
<P>
<tt>Inc</tt> increases the value of <tt>X</tt> with <tt>Increment</tt>.
If <tt>Increment</tt> isn't specified, then 1 is taken as a default.
<H3><A NAME="SECTION041236300000000000000">Errors:</A></H3>
<P>
A range check can occur, or an overflow error, if you try to increase <tt>X</tt>
over its maximum value.
<H3><A NAME="SECTION041236400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proDec">Dec</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example32;

{ Program to demonstrate the Inc function. }

Const
  C : Cardinal  = 1;
  L : Longint   = 1;
  I : Integer   = 1;
  W : Word      = 1;
  B : Byte      = 1;
  SI : ShortInt = 1;  
  CH : Char     = 'A';
  
begin
  Inc (C);     { C:=2    }
  Inc (L,5);   { L:=6    }
  Inc (I,-3);  { I:=-2   }
  Inc (W,3);   { W:=4    }
  Inc (B,100); { B:=101  }
  Inc (SI,-3); { Si:=-2  }
  Inc (CH,1);  { ch:='B' }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041237000000000000000">Insert</A></H2>
<P>
<A NAME="proInsert">&#160;</A>
<A NAME="6554">&#160;</A>
<H3><A NAME="SECTION041237100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Insert  (Var Source : String;var S : String;Index : integer) ;</tt>
<H3><A NAME="SECTION041237200000000000000">Description:</A></H3>
<P>
<tt>Insert</tt> inserts string <tt>S</tt> in string <tt>Source</tt>, at position
<tt>Index</tt>, shifting all characters after <tt>Index</tt> to the right. The
resulting string is truncated at 255 characters, if needed.
<H3><A NAME="SECTION041237300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041237400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proDelete">Delete</A>, <A HREF="node71.html#fuCopy">Copy</A>, <A HREF="node71.html#fuPos">Pos</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example33;

{ Program to demonstrate the Insert function. }

Var S : String;

begin
  S:='Free Pascal is difficult to use !';
  Insert ('NOT ',S,pos('difficult',S));
  writeln (s);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041238000000000000000">Int</A></H2>
<P>
<A NAME="fuInt">&#160;</A>
<A NAME="6597">&#160;</A>
<H3><A NAME="SECTION041238100000000000000">Declaration:</A></H3>
<P>
<tt>Function Int  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041238200000000000000">Description:</A></H3>
<P>
<tt>Int</tt> returns the integer part of any Real <tt>X</tt>, as a Real.
<H3><A NAME="SECTION041238300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041238400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuFrac">Frac</A>, <A HREF="node71.html#fuRound">Round</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example34;

{ Program to demonstrate the Int function. }

begin
  Writeln (Int(123.456):0:1);  { Prints  123.0 }
  Writeln (Int(-123.456):0:1); { Prints -123.0 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041239000000000000000">IOresult</A></H2>
<P>
<A NAME="fuIOresult">&#160;</A>
<A NAME="6634">&#160;</A>
<H3><A NAME="SECTION041239100000000000000">Declaration:</A></H3>
<P>
<tt>Function IOresult    : Word;</tt>
<H3><A NAME="SECTION041239200000000000000">Description:</A></H3>
<P>
IOresult contains the result of any input/output call, when the
<tt>{$i-}</tt> compiler directive is active, and IO checking is disabled. When the
flag is read, it is reset to zero.
<P>
If <tt>IOresult</tt> is zero, the operation completed successfully. If
non-zero, an error occurred. The following errors can occur:
<P>
DOS errors :
<P>
<DL ><DT><STRONG>2 </STRONG>
<DD> File not found.
<DT><STRONG>3 </STRONG>
<DD> Path not found.
<DT><STRONG>4 </STRONG>
<DD> Too many open files.
<DT><STRONG>5 </STRONG>
<DD> Access denied.
<DT><STRONG>6 </STRONG>
<DD> Invalid file handle.
<DT><STRONG>12 </STRONG>
<DD> Invalid file-access mode.
<DT><STRONG>15 </STRONG>
<DD> Invalid disk number.
<DT><STRONG>16 </STRONG>
<DD> Cannot remove current directory.
<DT><STRONG>17 </STRONG>
<DD> Cannot rename across volumes.
<P>
</DL>
<P>
I/O errors :
<P>
<DL ><DT><STRONG>100 </STRONG>
<DD> Error when reading from disk.
<DT><STRONG>101 </STRONG>
<DD> Error when writing to disk.
<DT><STRONG>102 </STRONG>
<DD> File not assigned.
<DT><STRONG>103 </STRONG>
<DD> File not open.
<DT><STRONG>104 </STRONG>
<DD> File not opened for input.
<DT><STRONG>105 </STRONG>
<DD> File not opened for output.
<DT><STRONG>106 </STRONG>
<DD> Invalid number.
<P>
</DL>
<P>
Fatal errors :
<P>
<DL ><DT><STRONG>150 </STRONG>
<DD> Disk is write protected.
<DT><STRONG>151 </STRONG>
<DD> Unknown device.
<DT><STRONG>152 </STRONG>
<DD> Drive not ready.
<DT><STRONG>153 </STRONG>
<DD> Unknown command.
<DT><STRONG>154 </STRONG>
<DD> CRC check failed.
<DT><STRONG>155 </STRONG>
<DD> Invalid drive specified..
<DT><STRONG>156 </STRONG>
<DD> Seek error on disk.
<DT><STRONG>157 </STRONG>
<DD> Invalid media type.
<DT><STRONG>158 </STRONG>
<DD> Sector not found.
<DT><STRONG>159 </STRONG>
<DD> Printer out of paper.
<DT><STRONG>160 </STRONG>
<DD> Error when writing to device.
<DT><STRONG>161 </STRONG>
<DD> Error when reading from device.
<DT><STRONG>162 </STRONG>
<DD> Hardware failure.
<P>
</DL><H3><A NAME="SECTION041239300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041239400000000000000">See also:</A></H3>
<P>
All I/O functions.
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example35;

{ Program to demonstrate the IOResult function. }

Var F : text;

begin
  Assign (f,paramstr(1));
  {$i-}
  Reset (f);
  {$i+}
  If IOresult&lt;&gt;0 then
    writeln ('File ',paramstr(1),' doesn''t exist')
  else
    writeln ('File ',paramstr(1),' exists');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041240000000000000000">Length</A></H2>
<P>
<A NAME="fuLength">&#160;</A>
<A NAME="6672">&#160;</A>
<H3><A NAME="SECTION041240100000000000000">Declaration:</A></H3>
<P>
<tt>Function Length  (S : String)  : Byte;</tt>
<H3><A NAME="SECTION041240200000000000000">Description:</A></H3>
<P>
<tt>Length</tt> returns the length of the string <tt>S</tt>,
which is limited to 255. If the strings <tt>S</tt> is empty, 0 is returned.
<P>
<EM>Note:</EM> The length of the string <tt>S</tt> is stored in <tt>S[0]</tt>.
<P>
<H3><A NAME="SECTION041240300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041240400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuPos">Pos</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example36;

{ Program to demonstrate the Length function. }

Var S : String;
    I : Integer;
    
begin
  S:='';
  for i:=1 to 10 do
    begin
    S:=S+'*';
    Writeln (Length(S):2,' : ',s);
    end;
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041241000000000000000">Ln</A></H2>
<P>
<A NAME="fuLn">&#160;</A>
<A NAME="6712">&#160;</A>
<H3><A NAME="SECTION041241100000000000000">Declaration:</A></H3>
<P>
<tt>Function Ln  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041241200000000000000">Description:</A></H3>
<P>
<tt>Ln</tt> returns the natural logarithm of the Real parameter <tt>X</tt>.
<tt>X</tt> must be positive.
<P>
<H3><A NAME="SECTION041241300000000000000">Errors:</A></H3>
<P>
An run-time error will occur when <tt>X</tt> is negative.
<H3><A NAME="SECTION041241400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuExp">Exp</A>, <A HREF="node71.html#fuPower">Power</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example37;

{ Program to demonstrate the Ln function. }

begin
  Writeln (Ln(1));      { Prints 0 }
  Writeln (Ln(Exp(1))); { Prints 1 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041242000000000000000">Lo</A></H2>
<P>
<A NAME="fuLo">&#160;</A>
<A NAME="6753">&#160;</A>
<H3><A NAME="SECTION041242100000000000000">Declaration:</A></H3>
<P>
<tt>Function Lo  (O : Word or Longint)  : Byte or Word;</tt>
<H3><A NAME="SECTION041242200000000000000">Description:</A></H3>
<P>
<tt>Lo</tt> returns the low byte of its argument if this is of type
<tt>Integer</tt> or
<tt>Word</tt>. It returns the low word of its argument if this is of type 
<tt>Longint</tt> or <tt>Cardinal</tt>.
<H3><A NAME="SECTION041242300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041242400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuChr">Chr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example38;

{ Program to demonstrate the Lo function. }

Var L : Longint;
    W : Word;

begin
  L:=(1 Shl 16) + (1 Shl 4);  { $10010 }
  Writeln (Lo(L));            { Prints 16 }
  W:=(1 Shl 8) + (1 Shl 4);   { $110   } 
  Writeln (Lo(W));            { Prints 16 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041243000000000000000">LongJmp</A></H2>
<P>
<A NAME="proLongJmp">&#160;</A>
<A NAME="6822">&#160;</A>
<H3><A NAME="SECTION041243100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure LongJmp  (Var env : Jmp_Buf; Value : Longint) ;</tt>
<H3><A NAME="SECTION041243200000000000000">Description:</A></H3>
<P>
<tt>LongJmp</tt> jumps to the adress in the <tt>env</tt> <tt>jmp_buf</tt>,
and resores the registers that were stored in it at the corresponding
<A HREF="node71.html#fuSetJmp">SetJmp</A> call.
<P>
In effect, program flow will continue at the <tt>SetJmp</tt> call, which will
return <tt>value</tt> instead of 0. If you pas a <tt>value</tt> equal to zero, it will be
converted to 1 before passing it on. The call will not return, so it must be 
used with extreme care.
<P>
This can be used for error recovery, for instance when a segmentation fault
occurred.
<H3><A NAME="SECTION041243300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041243400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSetJmp">SetJmp</A>
<P>
For an example, see <A HREF="node71.html#fuSetJmp">SetJmp</A>
<P>
<H2><A NAME="SECTION041244000000000000000">Low</A></H2>
<P>
<A NAME="fuLow">&#160;</A>
<A NAME="6850">&#160;</A>
<H3><A NAME="SECTION041244100000000000000">Declaration:</A></H3>
<P>
<tt>Function Low  (Type identifier or variable reference)  : Longint;</tt>
<H3><A NAME="SECTION041244200000000000000">Description:</A></H3>
<P>
 The return value of <tt>Low</tt> depends on it's argument:
<OL>
<LI> If the argument is an ordinal type, <tt>Low</tt> returns the lowest value in the range of the given ordinal 
type when it gets.
<LI> If the argument is an array type or an array type variable then 
<tt>Low</tt> returns the lowest possible value of it's index.
</OL><H3><A NAME="SECTION041244300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041244400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuHigh">High</A>, <A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuPred">Pred</A>, <A HREF="node71.html#fuSucc">Succ</A>
<P>
for an example, see <A HREF="node71.html#fuHigh">High</A>.
<P>
<H2><A NAME="SECTION041245000000000000000">Lowercase</A></H2>
<P>
<A NAME="fuLowercase">&#160;</A>
<A NAME="6880">&#160;</A>
<H3><A NAME="SECTION041245100000000000000">Declaration:</A></H3>
<P>
<tt>Function Lowercase  (C : Char or String)  : Char or String;</tt>
<H3><A NAME="SECTION041245200000000000000">Description:</A></H3>
<P>
<tt>Lowercase</tt> returns the lowercase version of its argument <tt>C</tt>.
If its argument is a string, then the complete string is converted to
lowercase. The type of the returned value is the same as the type of the
argument.
<H3><A NAME="SECTION041245300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041245400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuUpcase">Upcase</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example73;

{ Program to demonstrate the Lowercase function. }

Var I : Longint;

begin
  For i:=ord('A') to ord('Z') do
    write (lowercase(chr(i)));
  Writeln;
  Writeln (Lowercase('ABCDEFGHIJKLMNOPQRSTUVWXYZ'));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041246000000000000000">Mark</A></H2>
<P>
<A NAME="proMark">&#160;</A>
<A NAME="6913">&#160;</A>
<H3><A NAME="SECTION041246100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Mark  (Var P : Pointer) ;</tt>
<H3><A NAME="SECTION041246200000000000000">Description:</A></H3>
<P>
<tt>Mark</tt> copies the current heap-pointer to <tt>P</tt>.
<H3><A NAME="SECTION041246300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041246400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proGetmem">Getmem</A>, <A HREF="node71.html#proFreemem">Freemem</A>, <A HREF="node71.html#proNew">New</A>, <A HREF="node71.html#proDispose">Dispose</A>, <A HREF="node71.html#fuMaxavail">Maxavail</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example39;

{ Program to demonstrate the Mark and Release functions. }

Var P,PP,PPP,MM : Pointer;

begin
  Getmem (P,100);
  Mark (MM);
  Writeln ('Getmem 100   : Memory available : ',MemAvail,' (marked)');
  GetMem (PP,1000);
  Writeln ('Getmem 1000  : Memory available : ',MemAvail);
  GetMem (PPP,100000);
  Writeln ('Getmem 10000 : Memory available : ',MemAvail);
  Release (MM);
  Writeln ('Released     : Memory available : ',MemAvail);    
  { At this point, PP and PPP are invalid ! }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041247000000000000000">Maxavail</A></H2>
<P>
<A NAME="fuMaxavail">&#160;</A>
<A NAME="6957">&#160;</A>
<H3><A NAME="SECTION041247100000000000000">Declaration:</A></H3>
<P>
<tt>Function Maxavail    : Longint;</tt>
<H3><A NAME="SECTION041247200000000000000">Description:</A></H3>
<P>
<tt>Maxavail</tt> returns the size, in bytes, of the biggest free memory block in
the heap.
<P>
<EM>Remark:</EM> The heap grows dynamically if more memory is needed than is
available.
<H3><A NAME="SECTION041247300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041247400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proRelease">Release</A>, <A HREF="node71.html#fuMemavail">Memavail</A>,<A HREF="node71.html#proFreemem">Freemem</A>, <A HREF="node71.html#proGetmem">Getmem</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example40;

{ Program to demonstrate the MaxAvail function. }

Var
  P : Pointer;
  I : longint;
  
begin
  { This will allocate memory until there is no more memory}
  I:=0;
  While MaxAvail&gt;=1000 do
    begin
    Inc (I);
    GetMem (P,1000);
    end;
  { Default 4MB heap is allocated, so 4000 blocks 
    should be allocated. 
    When compiled with the -Ch10000 switch, the program
    will be able to allocate 10 block }
  Writeln ('Allocated ',i,' blocks of 1000 bytes'); 
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041248000000000000000">Memavail</A></H2>
<P>
<A NAME="fuMemavail">&#160;</A>
<A NAME="6996">&#160;</A>
<H3><A NAME="SECTION041248100000000000000">Declaration:</A></H3>
<P>
<tt>Function Memavail    : Longint;</tt>
<H3><A NAME="SECTION041248200000000000000">Description:</A></H3>
<P>
<tt>Memavail</tt> returns the size, in bytes, of the free heap memory.
<P>
<EM>Remark:</EM> The heap grows dynamically if more memory is needed than is
available.
<H3><A NAME="SECTION041248300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041248400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuMaxavail">Maxavail</A>,<A HREF="node71.html#proFreemem">Freemem</A>, <A HREF="node71.html#proGetmem">Getmem</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example41;

{ Program to demonstrate the MemAvail function. }

Var  
  P, PP : Pointer;

begin
  GetMem (P,100);
  GetMem (PP,10000);
  FreeMem (P,100);
  { Due to the heap fragmentation introduced
    By the previous calls, the maximum amount of memory
    isn't equal to the maximum block size available. } 
  Writeln ('Total heap available    (Bytes) : ',MemAvail);
  Writeln ('Largest block available (Bytes) : ',MaxAvail);  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041249000000000000000">Mkdir</A></H2>
<P>
<A NAME="proMkdir">&#160;</A>
<A NAME="7046">&#160;</A>
<H3><A NAME="SECTION041249100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Mkdir  (const S : string) ;</tt>
<H3><A NAME="SECTION041249200000000000000">Description:</A></H3>
<P>
<tt>Chdir</tt> creates a new  directory <tt>S</tt>.
<H3><A NAME="SECTION041249300000000000000">Errors:</A></H3>
<P>
If a parent-directory of directory <tt>S</tt> doesn't exist, a run-time error is generated.
<H3><A NAME="SECTION041249400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proChdir">Chdir</A>, <A HREF="node71.html#proRmdir">Rmdir</A>
<P>
For an example, see <A HREF="node71.html#proRmdir">Rmdir</A>.
<P>
<H2><A NAME="SECTION041250000000000000000">Move</A></H2>
<P>
<A NAME="proMove">&#160;</A>
<A NAME="7068">&#160;</A>
<H3><A NAME="SECTION041250100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Move  (var Source,Dest;Count : Longint) ;</tt>
<H3><A NAME="SECTION041250200000000000000">Description:</A></H3>
<P>
<tt>Move</tt> moves <tt>Count</tt> bytes from <tt>Source</tt> to <tt>Dest</tt>.
<H3><A NAME="SECTION041250300000000000000">Errors:</A></H3>
<P>
If either <tt>Dest</tt> or <tt>Source</tt> is outside the accessible memory for
the process, then a run-time error will be generated. With older versions of
the compiler, a segmentation-fault will occur. 
<H3><A NAME="SECTION041250400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proFillword">Fillword</A>, <A HREF="node71.html#proFillchar">Fillchar</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example42;

{ Program to demonstrate the Move function. }

Var S1,S2 : String [30];

begin
  S1:='Hello World !';
  S2:='Bye, bye    !';
  Move (S1,S2,Sizeof(S1));
  Writeln (S2);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041251000000000000000">New</A></H2>
<P>
<A NAME="proNew">&#160;</A>
<A NAME="7127">&#160;</A>
<H3><A NAME="SECTION041251100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure New  (Var P : Pointer[, Constructor]) ;</tt>
<H3><A NAME="SECTION041251200000000000000">Description:</A></H3>
<P>
<tt>New</tt> allocates a new instance of the type pointed to by <tt>P</tt>, and
puts the address in <tt>P</tt>.
<P>
If P is an object, then it is possible to
specify the name of the constructor with which the instance will be created.
<H3><A NAME="SECTION041251300000000000000">Errors:</A></H3>
<P>
If not enough memory is available, <tt>Nil</tt> will be returned.
<H3><A NAME="SECTION041251400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proDispose">Dispose</A>, <A HREF="node71.html#proFreemem">Freemem</A>, <A HREF="node71.html#proGetmem">Getmem</A>, <A HREF="node71.html#fuMemavail">Memavail</A>,
<A HREF="node71.html#fuMaxavail">Maxavail</A>
<P>
For an example, see <A HREF="node71.html#proDispose">Dispose</A>.
<P>
<H2><A NAME="SECTION041252000000000000000">Odd</A></H2>
<P>
<A NAME="fuOdd">&#160;</A>
<A NAME="7160">&#160;</A>
<H3><A NAME="SECTION041252100000000000000">Declaration:</A></H3>
<P>
<tt>Function Odd  (X : Longint)  : Boolean;</tt>
<H3><A NAME="SECTION041252200000000000000">Description:</A></H3>
<P>
<tt>Odd</tt> returns <tt>True</tt> if <tt>X</tt> is odd, or <tt>False</tt> otherwise.
<H3><A NAME="SECTION041252300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041252400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuAbs">Abs</A>, <A HREF="node71.html#fuOrd">Ord</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example43;

{ Program to demonstrate the Odd function. }

begin
  If Odd(1) Then 
    Writeln ('Everything OK with 1 !');
  If Not Odd(2) Then 
    Writeln ('Everything OK with 2 !'); 
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041253000000000000000">Ofs</A></H2>
<P>
<A NAME="fuOfs">&#160;</A>
<A NAME="7199">&#160;</A>
<H3><A NAME="SECTION041253100000000000000">Declaration:</A></H3>
<P>
<tt>Function Ofs  Var X  : Longint;</tt>
<H3><A NAME="SECTION041253200000000000000">Description:</A></H3>
<P>
<tt>Ofs</tt> returns the offset of the address of a variable.
<P>
This function is only supported for compatibility. In Free Pascal, it 
returns always the complete address of the variable, since Free Pascal is a 32 bit 
compiler.
<P>
<H3><A NAME="SECTION041253300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041253400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuDSeg">DSeg</A>, <A HREF="node71.html#fuCSeg">CSeg</A>, <A HREF="node71.html#fuSeg">Seg</A>, <A HREF="node71.html#fuPtr">Ptr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example44;

{ Program to demonstrate the Ofs function. }

Var W : Pointer;


begin
  W:=Pointer(Ofs(W)); { W contains its own offset. } 
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041254000000000000000">Ord</A></H2>
<P>
<A NAME="fuOrd">&#160;</A>
<A NAME="7240">&#160;</A>
<H3><A NAME="SECTION041254100000000000000">Declaration:</A></H3>
<P>
<tt>Function Ord  (X : Any ordinal type)  : Longint;</tt>
<H3><A NAME="SECTION041254200000000000000">Description:</A></H3>
<P>
<tt>Ord</tt> returns the Ordinal value of a ordinal-type variable <tt>X</tt>.
<H3><A NAME="SECTION041254300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041254400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuChr">Chr</A>, <A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuPred">Pred</A>, <A HREF="node71.html#fuHigh">High</A>, <A HREF="node71.html#fuLow">Low</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example45;

{ Program to demonstrate the Ord,Pred,Succ functions. }

Type
  TEnum = (Zero, One, Two, Three, Four);
  
Var 
  X : Longint;
  Y : TEnum;
  
begin
  X:=125;
  Writeln (Ord(X));  { Prints 125 }
  X:=Pred(X);
  Writeln (Ord(X));  { prints 124 }
  Y:= One;
  Writeln (Ord(y));  { Prints 1 }
  Y:=Succ(Y);
  Writeln (Ord(Y));  { Prints 2}
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041255000000000000000">Paramcount</A></H2>
<P>
<A NAME="fuParamcount">&#160;</A>
<A NAME="7281">&#160;</A>
<H3><A NAME="SECTION041255100000000000000">Declaration:</A></H3>
<P>
<tt>Function Paramcount    : Longint;</tt>
<H3><A NAME="SECTION041255200000000000000">Description:</A></H3>
<P>
<tt>Paramcount</tt> returns the number of command-line arguments. If no
arguments were given to the running program, <tt>0</tt> is returned.
<P>
<H3><A NAME="SECTION041255300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041255400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuParamstr">Paramstr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example46;

{ Program to demonstrate the ParamCount and ParamStr functions. }
Var 
  I : Longint;
  
begin
  Writeln (paramstr(0),' : Got ',ParamCount,' command-line parameters: ');
  For i:=1 to ParamCount do
    Writeln (ParamStr (i));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041256000000000000000">Paramstr</A></H2>
<P>
<A NAME="fuParamstr">&#160;</A>
<A NAME="7324">&#160;</A>
<H3><A NAME="SECTION041256100000000000000">Declaration:</A></H3>
<P>
<tt>Function Paramstr  (L : Longint)  : String;</tt>
<H3><A NAME="SECTION041256200000000000000">Description:</A></H3>
<P>
<tt>Paramstr</tt> returns the <tt>L</tt>-th command-line argument. <tt>L</tt> must
be between <tt>0</tt> and <tt>Paramcount</tt>, these values included.
The zeroth argument is the name with which the program was started.
<P>
<H3><A NAME="SECTION041256300000000000000">Errors:</A></H3>
<P>
 In all cases, the command-line will be truncated to a length of 255,
even though the operating system may support bigger command-lines. If you
want to access the complete command-line, you must use the <tt>argv</tt> pointer
to access the Real values of the command-line parameters.
<H3><A NAME="SECTION041256400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuParamcount">Paramcount</A>
<P>
For an example, see <A HREF="node71.html#fuParamcount">Paramcount</A>.
<P>
<H2><A NAME="SECTION041257000000000000000">Pi</A></H2>
<P>
<A NAME="fuPi">&#160;</A>
<A NAME="7349">&#160;</A>
<H3><A NAME="SECTION041257100000000000000">Declaration:</A></H3>
<P>
<tt>Function Pi    : Real;</tt>
<H3><A NAME="SECTION041257200000000000000">Description:</A></H3>
<P>
<tt>Pi</tt> returns the value of Pi (3.1415926535897932385).
<H3><A NAME="SECTION041257300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041257400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuCos">Cos</A>, <A HREF="node71.html#fuSin">Sin</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example47;

{ Program to demonstrate the Pi function. }

begin
  Writeln (Pi);         {3.1415926}
  Writeln (Sin(Pi));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041258000000000000000">Pos</A></H2>
<P>
<A NAME="fuPos">&#160;</A>
<A NAME="7388">&#160;</A>
<H3><A NAME="SECTION041258100000000000000">Declaration:</A></H3>
<P>
<tt>Function Pos  (Const Substr : String;Const S : String)  : Byte;</tt>
<H3><A NAME="SECTION041258200000000000000">Description:</A></H3>
<P>
<tt>Pos</tt> returns the index of <tt>Substr</tt> in <tt>S</tt>, if <tt>S</tt> contains
<tt>Substr</tt>. In case <tt>Substr</tt> isn't found, <tt>0</tt> is returned.
<P>
The search is case-sensitive.
<P>
<H3><A NAME="SECTION041258300000000000000">Errors:</A></H3>
<P>
None
<H3><A NAME="SECTION041258400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuLength">Length</A>, <A HREF="node71.html#fuCopy">Copy</A>, <A HREF="node71.html#proDelete">Delete</A>, <A HREF="node71.html#proInsert">Insert</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example48;

{ Program to demonstrate the Pos function. }

Var 
  S : String;

begin
  S:='The first space in this sentence is at position : ';
  Writeln (S,pos(' ',S));
  S:='The last letter of the alphabet doesn''t appear in this sentence ';
  If (Pos ('Z',S)=0) and (Pos('z',S)=0) then 
    Writeln (S);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041259000000000000000">Power</A></H2>
<P>
<A NAME="fuPower">&#160;</A>
<A NAME="7442">&#160;</A>
<H3><A NAME="SECTION041259100000000000000">Declaration:</A></H3>
<P>
<tt>Function Power  (base,expon : Real)  : Real;</tt>
<H3><A NAME="SECTION041259200000000000000">Description:</A></H3>
<P>
<tt>Power</tt> returns the value of <tt>base</tt> to the power <tt>expon</tt>. 
<tt>Base</tt> and <tt>expon</tt> can be of type Longint, in which case the 
result will also be a Longint.
<P>
The function actually returns <tt>Exp(expon*Ln(base))</tt>
<P>
<H3><A NAME="SECTION041259300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041259400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuExp">Exp</A>, <A HREF="node71.html#fuLn">Ln</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example78;

{ Program to demonstrate the Power function. }

begin
  Writeln (Power(exp(1.0),1.0):8:2); { Should print 2.72 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041260000000000000000">Pred</A></H2>
<P>
<A NAME="fuPred">&#160;</A>
<A NAME="7487">&#160;</A>
<H3><A NAME="SECTION041260100000000000000">Declaration:</A></H3>
<P>
<tt>Function Pred  (X : Any ordinal type)  : Same type;</tt>
<H3><A NAME="SECTION041260200000000000000">Description:</A></H3>
<P>
 <tt>Pred</tt> returns the element that precedes the element that was passed
to it. If it is applied to the first value of the ordinal type, and the
program was compiled with range checking on (<tt>{$R+}</tt>, then a run-time
error will be generated.
<P>
<H3><A NAME="SECTION041260300000000000000">Errors:</A></H3>
<P>
Run-time error 201 is generated when the result is out of
range.
<H3><A NAME="SECTION041260400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuPred">Pred</A>, <A HREF="node71.html#fuHigh">High</A>, <A HREF="node71.html#fuLow">Low</A>
<P>
for an example, see <A HREF="node71.html#fuOrd">Ord</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program example80;

{ Example to demonstrate the High and Low functions. }

Type TEnum = ( North, East, South, West );
     TRange = 14..55;
     TArray = Array [2..10] of Longint;
    
Function Average (Row : Array of Longint) : Real;

Var I : longint;
    Temp : Real;
   
   
begin
  Temp := Row[0];
  For I := 1 to High(Row) do
     Temp := Temp + Row[i];
  Average := Temp / (High(Row)+1);
end;
                  
Var A : TEnum;
    B : TRange;
    C : TArray;
    I : longint;
    
begin
  Writeln ('TEnum  goes from : ',Ord(Low(TEnum)),' to ', Ord(high(TEnum)),'.');
  Writeln ('A      goes from : ',Ord(Low(A)),' to ', Ord(high(A)),'.');
  Writeln ('TRange goes from : ',Ord(Low(TRange)),' to ', Ord(high(TRange)),'.');
  Writeln ('B      goes from : ',Ord(Low(B)),' to ', Ord(high(B)),'.');
  Writeln ('TArray index goes from : ',Ord(Low(TArray)),' to ', Ord(high(TArray)),'.');
  Writeln ('C index      goes from : ',Low(C),' to ', high(C),'.');
  For I:=Low(C) to High(C) do
    C[i]:=I;
  Writeln ('Average :',Average(c));  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041261000000000000000">Ptr</A></H2>
<P>
<A NAME="fuPtr">&#160;</A>
<A NAME="7534">&#160;</A>
<H3><A NAME="SECTION041261100000000000000">Declaration:</A></H3>
<P>
<tt>Function Ptr  (Sel,Off : Longint)  : Pointer;</tt>
<H3><A NAME="SECTION041261200000000000000">Description:</A></H3>
<P>
<tt>Ptr</tt> returns a pointer, pointing to the address specified by
segment <tt>Sel</tt> and offset <tt>Off</tt>.
<P>
<EM>Remark 1:</EM> In the 32-bit flat-memory model supported by Free Pascal, this
function is obsolete.
<P>
<EM>Remark 2:</EM> The returned address is simply the offset. If you recompile
the RTL with <tt>-dDoMapping</tt> defined, then the compiler returns the
following : <tt>ptr := pointer($e0000000+sel shl 4+off)</tt> under DOS, or
<tt>ptr := pointer(sel shl 4+off)</tt> on other OSes.
<P>
<H3><A NAME="SECTION041261300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041261400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuAddr">Addr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example59;

{ Program to demonstrate the Ptr function. }

Var P : ^String;
    S : String;
    
begin
  S:='Hello, World !';
  P:=Ptr(Seg(S),Longint(Ofs(S)));
  {P now points to S !}
  Writeln (P^);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041262000000000000000">Random</A></H2>
<P>
<A NAME="fuRandom">&#160;</A>
<A NAME="7577">&#160;</A>
<H3><A NAME="SECTION041262100000000000000">Declaration:</A></H3>
<P>
<tt>Function Random  [(L : Longint)]  : Longint or Real;</tt>
<H3><A NAME="SECTION041262200000000000000">Description:</A></H3>
<P>
<tt>Random</tt> returns a random number larger or equal to <tt>0</tt> and
strictly less than <tt>L</tt>.
<P>
If the argument <tt>L</tt> is omitted, a Real number between 0 and 1 is returned.
(0 included, 1 excluded)
<H3><A NAME="SECTION041262300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041262400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proRandomize">Randomize</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example49;

{ Program to demonstrate the Random and Randomize functions. }

Var I,Count,guess : Longint;
    R : Real;

begin
  Randomize; { This way we generate a new sequence every time 
               the program is run}
  Count:=0;
  For i:=1 to 1000 do 
    If Random&gt;0.5 then inc(Count);
  Writeln ('Generated ',Count,' numbers &gt; 0.5');
  Writeln ('out of 1000 generated numbers.');
  count:=0;
  For i:=1 to 5 do
    begin
    write ('Guess a number between 1 and 5 : ');
    readln(Guess);
    If Guess=Random(5)+1 then inc(count);
    end;
  Writeln ('You guessed ',Count,' out of 5 correct.');   
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041263000000000000000">Randomize</A></H2>
<P>
<A NAME="proRandomize">&#160;</A>
<A NAME="7634">&#160;</A>
<H3><A NAME="SECTION041263100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Randomize   ;</tt>
<H3><A NAME="SECTION041263200000000000000">Description:</A></H3>
<P>
<tt>Randomize</tt> initializes the random number generator of Free Pascal, by giving
a value to <tt>Randseed</tt>, calculated with the system clock.
<P>
<H3><A NAME="SECTION041263300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041263400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuRandom">Random</A>
<P>
For an example, see <A HREF="node71.html#fuRandom">Random</A>.
<P>
<H2><A NAME="SECTION041264000000000000000">Read</A></H2>
<P>
<A NAME="proRead">&#160;</A>
<A NAME="7651">&#160;</A>
<H3><A NAME="SECTION041264100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Read  ([Var F : Any file type], V1 [, V2, ... , Vn]) ;</tt>
<H3><A NAME="SECTION041264200000000000000">Description:</A></H3>
<P>
<tt>Read</tt> reads one or more values from a file <tt>F</tt>, and stores the
result in <tt>V1</tt>, <tt>V2</tt>, etc.; If no file <tt>F</tt> is specified, then
standard input is read.
<P>
If <tt>F</tt> is of type <tt>Text</tt>, then the variables <tt>V1, V2</tt> etc. must be
of type <tt>Char</tt>, <tt>Integer</tt>, <tt>Real</tt> or <tt>String</tt>.
<P>
If <tt>F</tt> is a typed file, then each of the variables must be of the type
specified in the declaration of <tt>F</tt>. Untyped files are not allowed as an
argument.
<H3><A NAME="SECTION041264300000000000000">Errors:</A></H3>
<P>
If no data is available, a run-time error is generated. This behavior can
be controlled with the <tt>{$i}</tt> compiler switch.
<H3><A NAME="SECTION041264400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proReadln">Readln</A>, <A HREF="node71.html#proBlockread">Blockread</A>, <A HREF="node71.html#proWrite">Write</A>, <A HREF="node71.html#proBlockwrite">Blockwrite</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example50;

{ Program to demonstrate the Read(Ln) function. }

Var S : String;
    C : Char;
    F : File of char;
    
begin
  Assign (F,'ex50.pp');
  Reset (F);
  C:='A';
  Writeln ('The characters before the first space in ex50.pp are : ');
  While not Eof(f) and (C&lt;&gt;' ') do
    Begin
    Read (F,C);
    Write (C);
    end;
 Writeln;   
 Close (F);
 Writeln ('Type some words. An empty line ends the program.');
 repeat 
   Readln (S);
 until S='';  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041265000000000000000">Readln</A></H2>
<P>
<A NAME="proReadln">&#160;</A>
<A NAME="7758">&#160;</A>
<H3><A NAME="SECTION041265100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Readln  [Var F : Text], V1 [, V2, ... , Vn]) ;</tt>
<H3><A NAME="SECTION041265200000000000000">Description:</A></H3>
<P>
<tt>Read</tt> reads one or more values from a file <tt>F</tt>, and stores the
result in <tt>V1</tt>, <tt>V2</tt>, etc. After that it goes to the next line in
the file (defined by the <tt>LineFeed (#10)</tt> character). 
If no file <tt>F</tt> is specified, then standard input is read.
<P>
The variables <tt>V1, V2</tt> etc. must be of type <tt>Char</tt>, <tt>Integer</tt>, 
<tt>Real</tt>, <tt>String</tt> or <tt>PChar</tt>.
<P>
<H3><A NAME="SECTION041265300000000000000">Errors:</A></H3>
<P>
If no data is available, a run-time error is generated. This behavior can
be controlled with the <tt>{$i}</tt> compiler switch.
<H3><A NAME="SECTION041265400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proRead">Read</A>, <A HREF="node71.html#proBlockread">Blockread</A>, <A HREF="node71.html#proWrite">Write</A>, <A HREF="node71.html#proBlockwrite">Blockwrite</A>
<P>
For an example, see <A HREF="node71.html#proRead">Read</A>.
<P>
<H2><A NAME="SECTION041266000000000000000">Release</A></H2>
<P>
<A NAME="proRelease">&#160;</A>
<A NAME="7806">&#160;</A>
<H3><A NAME="SECTION041266100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Release  (Var P : pointer) ;</tt>
<H3><A NAME="SECTION041266200000000000000">Description:</A></H3>
<P>
<tt>Release</tt> sets the top of the Heap to the location pointed to by
<tt>P</tt>. All memory at a location higher than <tt>P</tt> is marked empty.
<H3><A NAME="SECTION041266300000000000000">Errors:</A></H3>
<P>
A run-time error will be generated if <tt>P</tt> points to memory outside the
heap.
<H3><A NAME="SECTION041266400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proMark">Mark</A>, <A HREF="node71.html#fuMemavail">Memavail</A>, <A HREF="node71.html#fuMaxavail">Maxavail</A>, <A HREF="node71.html#proGetmem">Getmem</A>, <A HREF="node71.html#proFreemem">Freemem</A>
<A HREF="node71.html#proNew">New</A>, <A HREF="node71.html#proDispose">Dispose</A>
<P>
For an example, see <A HREF="node71.html#proMark">Mark</A>.
<P>
<H2><A NAME="SECTION041267000000000000000">Rename</A></H2>
<P>
<A NAME="proRename">&#160;</A>
<A NAME="7845">&#160;</A>
<H3><A NAME="SECTION041267100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Rename  (Var F : Any Filetype; Const S : String) ;</tt>
<H3><A NAME="SECTION041267200000000000000">Description:</A></H3>
<P>
<tt>Rename</tt> changes the name of the assigned file <tt>F</tt> to <tt>S</tt>.
<tt>F</tt>
must be assigned, but not opened.
<H3><A NAME="SECTION041267300000000000000">Errors:</A></H3>
<P>
A run-time error will be generated if <tt>F</tt> isn't assigned, 
or doesn't exist.
<H3><A NAME="SECTION041267400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proErase">Erase</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example77;

{ Program to demonstrate the Rename function. }
Var F : Text;

begin
  Assign (F,paramstr(1));
  Rename (F,paramstr(2));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041268000000000000000">Reset</A></H2>
<P>
<A NAME="proReset">&#160;</A>
<A NAME="7887">&#160;</A>
<H3><A NAME="SECTION041268100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Reset  (Var F : Any File Type[; L : Longint]) ;</tt>
<H3><A NAME="SECTION041268200000000000000">Description:</A></H3>
<P>
<tt>Reset</tt> opens a file <tt>F</tt> for reading. <tt>F</tt> can be any file type.
If <tt>F</tt> is an untyped or typed file, then it is opened for reading and 
writing. If <tt>F</tt> is an untyped file, the record size can be specified in 
the optional parameter <tt>L</tt>. Default a value of 128 is used.
<H3><A NAME="SECTION041268300000000000000">Errors:</A></H3>
<P>
If the file cannot be opened for reading, then a run-time error is
generated. This behavior can be changed by the <tt>{$i} </tt> compiler switch.
<H3><A NAME="SECTION041268400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proRewrite">Rewrite</A>, <A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proClose">Close</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example51;

{ Program to demonstrate the Reset function. }

Function FileExists (Name : String) : boolean;

Var F : File;

begin
  {$i-}
  Assign (F,Name);
  Reset (F);
  {$I+}
  FileExists:=(IoResult=0) and (Name&lt;&gt;'');
  Close (f);
end;

begin
  If FileExists (Paramstr(1)) then
    Writeln ('File found')
  else
    Writeln ('File NOT found');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041269000000000000000">Rewrite</A></H2>
<P>
<A NAME="proRewrite">&#160;</A>
<A NAME="7942">&#160;</A>
<H3><A NAME="SECTION041269100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Rewrite  (Var F : Any File Type[; L : Longint]) ;</tt>
<H3><A NAME="SECTION041269200000000000000">Description:</A></H3>
<P>
<tt>Rewrite</tt> opens a file <tt>F</tt> for writing. <tt>F</tt> can be any file type.
If <tt>F</tt> is an untyped or typed file, then it is opened for reading and 
writing. If <tt>F</tt> is an untyped file, the record size can be specified in 
the optional parameter <tt>L</tt>. Default a value of 128 is used.
<P>
if <tt>Rewrite</tt> finds a file with the same name as <tt>F</tt>, this file is
truncated to length <tt>0</tt>. If it doesn't find such a file, a new file is 
created.
<P>
<H3><A NAME="SECTION041269300000000000000">Errors:</A></H3>
<P>
If the file cannot be opened for writing, then a run-time error is
generated. This behavior can be changed by the <tt>{$i} </tt> compiler switch.
<H3><A NAME="SECTION041269400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proClose">Close</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example52;

{ Program to demonstrate the Rewrite function. }

Var F : File;
    I : longint;

begin
  Assign (F,'Test.dat');
  { Create the file. Recordsize is 4 } 
  Rewrite (F,Sizeof(I));
  For I:=1 to 10 do
    BlockWrite (F,I,1);
  close (f);
  { F contains now a binary representation of
    10 longints going from 1 to 10 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041270000000000000000">Rmdir</A></H2>
<P>
<A NAME="proRmdir">&#160;</A>
<A NAME="7995">&#160;</A>
<H3><A NAME="SECTION041270100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Rmdir  (const S : string) ;</tt>
<H3><A NAME="SECTION041270200000000000000">Description:</A></H3>
<P>
<tt>Rmdir</tt> removes the  directory <tt>S</tt>.
<H3><A NAME="SECTION041270300000000000000">Errors:</A></H3>
<P>
If <tt>S</tt> doesn't exist, or isn't empty, a run-time error is generated.
<P>
<H3><A NAME="SECTION041270400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proChdir">Chdir</A>, <A HREF="node71.html#proRmdir">Rmdir</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example53;

{ Program to demonstrate the MkDir and RmDir functions. }

Const D : String[8] = 'TEST.DIR';

Var S : String;

begin
  Writeln ('Making directory ',D);
  Mkdir (D);
  Writeln ('Changing directory to ',D);
  ChDir (D);
  GetDir (0,S);
  Writeln ('Current Directory is : ',S);
  WRiteln ('Going back');
  ChDir ('..');
  Writeln ('Removing directory ',D);
  RmDir (D);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041271000000000000000">Round</A></H2>
<P>
<A NAME="fuRound">&#160;</A>
<A NAME="8033">&#160;</A>
<H3><A NAME="SECTION041271100000000000000">Declaration:</A></H3>
<P>
<tt>Function Round  (X : Real)  : Longint;</tt>
<H3><A NAME="SECTION041271200000000000000">Description:</A></H3>
<P>
<tt>Round</tt> rounds <tt>X</tt> to the closest integer, which may be bigger or
smaller than <tt>X</tt>.
<H3><A NAME="SECTION041271300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041271400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuFrac">Frac</A>, <A HREF="node71.html#fuInt">Int</A>, <A HREF="node71.html#fuTrunc">Trunc</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example54;

{ Program to demonstrate the Round function. }

begin
  Writeln (Round(123.456));  { Prints 124  }
  Writeln (Round(-123.456)); { Prints -124 }
  Writeln (Round(12.3456));  { Prints 12   }
  Writeln (Round(-12.3456)); { Prints -12  }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041272000000000000000">Runerror</A></H2>
<P>
<A NAME="proRunerror">&#160;</A>
<A NAME="8071">&#160;</A>
<H3><A NAME="SECTION041272100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Runerror  (ErrorCode : Word) ;</tt>
<H3><A NAME="SECTION041272200000000000000">Description:</A></H3>
<P>
<tt>Runerror</tt> stops the execution of the program, and generates a
run-time error <tt>ErrorCode</tt>.
<H3><A NAME="SECTION041272300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041272400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proExit">Exit</A>, <A HREF="node71.html#proHalt">Halt</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example55;

{ Program to demonstrate the RunError function. }

begin
  { The program will stop end emit a run-error 106 }
  RunError (106);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041273000000000000000">Seek</A></H2>
<P>
<A NAME="proSeek">&#160;</A>
<A NAME="8110">&#160;</A>
<H3><A NAME="SECTION041273100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Seek  (Var F; Count : Longint) ;</tt>
<H3><A NAME="SECTION041273200000000000000">Description:</A></H3>
<P>
<tt>Seek</tt> sets the file-pointer for file <tt>F</tt> to record Nr. <tt>Count</tt>.
The first record in a file has <tt>Count=0</tt>. F can be any file type, except
<tt>Text</tt>. If <tt>F</tt> is an untyped file, with no specified record size, 128
is assumed.
<H3><A NAME="SECTION041273300000000000000">Errors:</A></H3>
<P>
A run-time error is generated if <tt>Count</tt> points to a position outside
the file, or the file isn't opened.
<H3><A NAME="SECTION041273400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuEof">Eof</A>, <A HREF="node71.html#fuSeekEof">SeekEof</A>, <A HREF="node71.html#fuSeekEoln">SeekEoln</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example56;

{ Program to demonstrate the Seek function. }

Var 
  F : File;
  I,j : longint;
  
begin
  { Create a file and fill it with data } 
  Assign (F,'test.dat');
  Rewrite(F); { Create file }
  Close(f);   
  FileMode:=2;
  ReSet (F,Sizeof(i)); { Opened read/write }
  For I:=0 to 10 do
    BlockWrite (F,I,1);
  { Go Back to the begining of the file }
  Seek(F,0);
  For I:=0 to 10 do
    begin
    BlockRead (F,J,1);
    If J&lt;&gt;I then 
      Writeln ('Error: expected ' ,i,', got ',j);
    end;
  Close (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041274000000000000000">SeekEof</A></H2>
<P>
<A NAME="fuSeekEof">&#160;</A>
<A NAME="8162">&#160;</A>
<H3><A NAME="SECTION041274100000000000000">Declaration:</A></H3>
<P>
<tt>Function SeekEof  [(Var F : text)]  : Boolean;</tt>
<H3><A NAME="SECTION041274200000000000000">Description:</A></H3>
<P>
<tt>SeekEof</tt> returns <tt>True</tt> is the file-pointer is at the end of the
file. It ignores all whitespace.
<P>
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-file marker is
reached.
If the end-of-file marker is reached, <tt>True</tt> is returned. Otherwise,
False is returned.
<P>
If the parameter <tt>F</tt> is omitted, standard <tt>Input</tt> is assumed.
<P>
<H3><A NAME="SECTION041274300000000000000">Errors:</A></H3>
<P>
A run-time error is generated if the file <tt>F</tt> isn't opened.
<H3><A NAME="SECTION041274400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuEof">Eof</A>, <A HREF="node71.html#fuSeekEoln">SeekEoln</A>, <A HREF="node71.html#proSeek">Seek</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example57;

{ Program to demonstrate the SeekEof function. }
Var C : Char;

begin
  { this will print all characters from standard input except
    Whitespace characters. }
  While Not SeekEof do
    begin
    Read (C);
    Write (C);
    end;
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041275000000000000000">SeekEoln</A></H2>
<P>
<A NAME="fuSeekEoln">&#160;</A>
<A NAME="8213">&#160;</A>
<H3><A NAME="SECTION041275100000000000000">Declaration:</A></H3>
<P>
<tt>Function SeekEoln  [(Var F : text)]  : Boolean;</tt>
<H3><A NAME="SECTION041275200000000000000">Description:</A></H3>
<P>
<tt>SeekEoln</tt> returns <tt>True</tt> is the file-pointer is at the end of the
current line. It ignores all whitespace.
<P>
Calling this function has the effect that the file-position is advanced
until the first non-whitespace character or the end-of-line marker is
reached.
If the end-of-line marker is reached, <tt>True</tt> is returned. Otherwise,
False is returned.
<P>
The end-of-line marker is defined as <tt>#10</tt>, the LineFeed character.
<P>
If the parameter <tt>F</tt> is omitted, standard <tt>Input</tt> is assumed.
<H3><A NAME="SECTION041275300000000000000">Errors:</A></H3>
<P>
A run-time error is generated if the file <tt>F</tt> isn't opened.
<H3><A NAME="SECTION041275400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuEof">Eof</A>, <A HREF="node71.html#fuSeekEof">SeekEof</A>, <A HREF="node71.html#proSeek">Seek</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example58;

{ Program to demonstrate the SeekEoln function. }
Var
  C : Char;

begin
  { This will read the first line of standard output and print
    all characters except whitespace. }
  While not SeekEoln do
    Begin
    Read (c);
    Write (c);
    end;
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041276000000000000000">Seg</A></H2>
<P>
<A NAME="fuSeg">&#160;</A>
<A NAME="8261">&#160;</A>
<H3><A NAME="SECTION041276100000000000000">Declaration:</A></H3>
<P>
<tt>Function Seg  Var X  : Longint;</tt>
<H3><A NAME="SECTION041276200000000000000">Description:</A></H3>
<P>
<tt>Seg</tt> returns the segment of the address of a variable.
<P>
This function is only supported for compatibility. In Free Pascal, it 
returns always 0, since Free Pascal is a 32 bit compiler, segments have no meaning.
<P>
<H3><A NAME="SECTION041276300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041276400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuDSeg">DSeg</A>, <A HREF="node71.html#fuCSeg">CSeg</A>, <A HREF="node71.html#fuOfs">Ofs</A>, <A HREF="node71.html#fuPtr">Ptr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example60;

{ Program to demonstrate the Seg function. }
Var 
  W : Word;

begin
  W:=Seg(W);  { W contains its own Segment}
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041277000000000000000">SetJmp</A></H2>
<P>
<A NAME="fuSetJmp">&#160;</A>
<A NAME="8300">&#160;</A>
<H3><A NAME="SECTION041277100000000000000">Declaration:</A></H3>
<P>
<tt>Function SetJmp  (Var Env : Jmp_Buf)  : Longint;</tt>
<H3><A NAME="SECTION041277200000000000000">Description:</A></H3>
<P>
<tt>SetJmp</tt> fills <tt>env</tt> with the necessary data for a jump back to the
point where it was called. It returns zero if called in this way.
<P>
If the function returns nonzero, then it means that a call to <A HREF="node71.html#proLongJmp">LongJmp</A>
with <tt>env</tt> as an argument was made somewhere in the program.
<P>
<H3><A NAME="SECTION041277300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041277400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proLongJmp">LongJmp</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>program example79;

{ Program to demonstrate the setjmp, longjmp functions }

procedure dojmp(var env : jmp_buf; value : longint);

begin
  value:=2;
  Writeln ('Going to jump !');
  { This will return to the setjmp call, 
    and return value instead of 0 }
  longjmp(env,value);
end;

var env : jmp_buf;

begin
  if setjmp(env)=0 then
    begin
    writeln ('Passed first time.');
    dojmp(env,2);
    end
  else
    writeln ('Passed second time.');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041278000000000000000">SetTextBuf</A></H2>
<P>
<A NAME="proSetTextBuf">&#160;</A>
<A NAME="8347">&#160;</A>
<H3><A NAME="SECTION041278100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure SetTextBuf  (Var f : Text; Var Buf[; Size : Word]) ;</tt>
<H3><A NAME="SECTION041278200000000000000">Description:</A></H3>
<P>
<tt>SetTextBuf</tt> assigns an I/O buffer to a text file. The new buffer is
located at <tt>Buf</tt> and is <tt>Size</tt> bytes long. If <tt>Size</tt> is omitted,
then <tt>SizeOf(Buf)</tt> is assumed.
<P>
The standard buffer of any text file is 128 bytes long. For heavy I/0
operations this may prove too slow. The <tt>SetTextBuf</tt> procedure allows
you to set a bigger buffer for your application, thus reducing the number of
system calls, and thus reducing the load on the system resources.
<P>
The maximum size of the newly assigned buffer is 65355 bytes.
<P>
<EM>Remark 1:</EM> Never assign a new buffer to an opened file. You can assign a
new buffer immediately after a call to <A HREF="node71.html#proRewrite">Rewrite</A>, <A HREF="node71.html#proReset">Reset</A> or
<tt>Append</tt>, but not after you read from/wrote to the file. This may cause
loss of data. If you still want to assign a new buffer after read/write
operations have been performed, flush the file first. This will ensure that
the current buffer is emptied.
<P>
<EM>Remark 2:</EM> Take care that the buffer you assign is always valid. If you
assign a local variable as a buffer, then after your program exits the local
program block, the buffer will no longer be valid, and stack problems may
occur.
<P>
<H3><A NAME="SECTION041278300000000000000">Errors:</A></H3>
<P>
No checking on <tt>Size</tt> is done.
<H3><A NAME="SECTION041278400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proAssign">Assign</A>, <A HREF="node71.html#proReset">Reset</A>, <A HREF="node71.html#proRewrite">Rewrite</A>, <A HREF="node71.html#proAppend">Append</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example61;

{ Program to demonstrate the SetTextBuf function. }

Var
  Fin,Fout : Text;
  Ch : Char;
  Bufin,Bufout : Array[1..10000] of byte;
  
begin
  Assign (Fin,paramstr(1));
  Reset (Fin);
  Assign (Fout,paramstr(2));
  Rewrite (Fout);
  { This is harmless before IO has begun }
  { Try this program again on a big file,
    after commenting out the following 2 
    lines and recompiling it. }
  SetTextBuf (Fin,Bufin);
  SetTextBuf (Fout,Bufout);
  While not eof(Fin) do
    begin
    Read (Fin,ch);
    write (Fout,ch);
    end;
  Close (Fin);
  Close (Fout);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041279000000000000000">Sin</A></H2>
<P>
<A NAME="fuSin">&#160;</A>
<A NAME="8409">&#160;</A>
<H3><A NAME="SECTION041279100000000000000">Declaration:</A></H3>
<P>
<tt>Function Sin  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041279200000000000000">Description:</A></H3>
<P>
<tt>Sin</tt> returns the sine of its argument <tt>X</tt>, where <tt>X</tt> is an
angle in radians.
<H3><A NAME="SECTION041279300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041279400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuCos">Cos</A>, <A HREF="node71.html#fuPi">Pi</A>, <A HREF="node71.html#fuExp">Exp</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example62;

{ Program to demonstrate the Sin function. }

begin
  Writeln (Sin(Pi):0:1);   { Prints 0.0 }
  Writeln (Sin(Pi/2):0:1); { Prints 1.0 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041280000000000000000">SizeOf</A></H2>
<P>
<A NAME="fuSizeOf">&#160;</A>
<A NAME="8447">&#160;</A>
<H3><A NAME="SECTION041280100000000000000">Declaration:</A></H3>
<P>
<tt>Function SizeOf  (X : Any Type)  : Longint;</tt>
<H3><A NAME="SECTION041280200000000000000">Description:</A></H3>
<P>
<tt>SizeOf</tt> Returns the size, in bytes, of any variable or type-identifier.
<P>
 <EM>Remark:</EM> this isn't Really a RTL function. Its result is calculated at
compile-time, and hard-coded in your executable.
<H3><A NAME="SECTION041280300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041280400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuAddr">Addr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example63;

{ Program to demonstrate the SizeOf function. }
Var
  I : Longint;
  S : String [10];

begin
  Writeln (SizeOf(I));  { Prints 4  }
  Writeln (SizeOf(S));  { Prints 11 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041281000000000000000">Sptr</A></H2>
<P>
<A NAME="fuSptr">&#160;</A>
<A NAME="8473">&#160;</A>
<H3><A NAME="SECTION041281100000000000000">Declaration:</A></H3>
<P>
<tt>Function Sptr    : Pointer;</tt>
<H3><A NAME="SECTION041281200000000000000">Description:</A></H3>
<P>
<tt>Sptr</tt> returns the current stack pointer.
<P>
<H3><A NAME="SECTION041281300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041281400000000000000">See also:</A></H3>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example64;

{ Program to demonstrate the SPtr function. }
Var
  P :Longint;

begin
  P:=Sptr; { P Contains now the current stack position. }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041282000000000000000">Sqr</A></H2>
<P>
<A NAME="fuSqr">&#160;</A>
<A NAME="8500">&#160;</A>
<H3><A NAME="SECTION041282100000000000000">Declaration:</A></H3>
<P>
<tt>Function Sqr  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041282200000000000000">Description:</A></H3>
<P>
<tt>Sqr</tt> returns the square of its argument <tt>X</tt>.
<H3><A NAME="SECTION041282300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041282400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSqrt">Sqrt</A>, <A HREF="node71.html#fuLn">Ln</A>, <A HREF="node71.html#fuExp">Exp</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example65;

{ Program to demonstrate the Sqr function. }
Var i : Integer;
    
begin
  For i:=1 to 10 do
    writeln (Sqr(i):3);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041283000000000000000">Sqrt</A></H2>
<P>
<A NAME="fuSqrt">&#160;</A>
<A NAME="8539">&#160;</A>
<H3><A NAME="SECTION041283100000000000000">Declaration:</A></H3>
<P>
<tt>Function Sqrt  (X : Real)  : Real;</tt>
<H3><A NAME="SECTION041283200000000000000">Description:</A></H3>
<P>
<tt>Sqrt</tt> returns the square root of its argument <tt>X</tt>, which must be
positive.
<H3><A NAME="SECTION041283300000000000000">Errors:</A></H3>
<P>
If <tt>X</tt> is negative, then a run-time error is generated.
<H3><A NAME="SECTION041283400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSqr">Sqr</A>, <A HREF="node71.html#fuLn">Ln</A>, <A HREF="node71.html#fuExp">Exp</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example66;

{ Program to demonstrate the Sqrt function. }

begin
  Writeln (Sqrt(4):0:3); { Prints 2.000 }
  Writeln (Sqrt(2):0:3); { Prints 1.414 }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041284000000000000000">SSeg</A></H2>
<P>
<A NAME="fuSSeg">&#160;</A>
<A NAME="8576">&#160;</A>
<H3><A NAME="SECTION041284100000000000000">Declaration:</A></H3>
<P>
<tt>Function SSeg    : Longint;</tt>
<H3><A NAME="SECTION041284200000000000000">Description:</A></H3>
<P>
 <tt>SSeg</tt> returns the Stack Segment. This function is only 
 supported for compatibolity reasons, as <tt>Sptr</tt> returns the
correct contents of the stackpointer.
<H3><A NAME="SECTION041284300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041284400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuSptr">Sptr</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example67;

{ Program to demonstrate the SSeg function. }
Var W : Longint;

begin
  W:=SSeg;  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041285000000000000000">Str</A></H2>
<P>
<A NAME="proStr">&#160;</A>
<A NAME="8606">&#160;</A>
<H3><A NAME="SECTION041285100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Str  (Var X[:NumPlaces[:Decimals]]; Var S : String) ;</tt>
<H3><A NAME="SECTION041285200000000000000">Description:</A></H3>
<P>
<tt>Str</tt> returns a string which represents the value of X. X can be any
numerical type.
<P>
The optional <tt>NumPLaces</tt> and <tt>Decimals</tt> specifiers control the
formatting of the string.
<H3><A NAME="SECTION041285300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041285400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proVal">Val</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example68;

{ Program to demonstrate the Str function. }
Var S : String;

Function IntToStr (I : Longint) : String;

Var S : String;

begin
 Str (I,S);
 IntToStr:=S;
end;

begin
  S:='*'+IntToStr(-233)+'*';
  Writeln (S);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041286000000000000000">Succ</A></H2>
<P>
<A NAME="fuSucc">&#160;</A>
<A NAME="8660">&#160;</A>
<H3><A NAME="SECTION041286100000000000000">Declaration:</A></H3>
<P>
<tt>Function Succ  (X : Any ordinal type)  : Same type;</tt>
<H3><A NAME="SECTION041286200000000000000">Description:</A></H3>
<P>
 <tt>Succ</tt> returns the element that succeeds the element that was passed
to it. If it is applied to the last value of the ordinal type, and the
program was compiled with range checking on (<tt>{$R+}</tt>, then a run-time
error will be generated.
<P>
<H3><A NAME="SECTION041286300000000000000">Errors:</A></H3>
<P>
Run-time error 201 is generated when the result is out of
range.
<H3><A NAME="SECTION041286400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuOrd">Ord</A>, <A HREF="node71.html#fuPred">Pred</A>, <A HREF="node71.html#fuHigh">High</A>, <A HREF="node71.html#fuLow">Low</A>
<P>
for an example, see <A HREF="node71.html#fuOrd">Ord</A>.
<P>
<H2><A NAME="SECTION041287000000000000000">Swap</A></H2>
<P>
<A NAME="fuSwap">&#160;</A>
<A NAME="8686">&#160;</A>
<H3><A NAME="SECTION041287100000000000000">Declaration:</A></H3>
<P>
<tt>Function Swap  (X)  : Type of X;</tt>
<H3><A NAME="SECTION041287200000000000000">Description:</A></H3>
<P>
<tt>Swap</tt> swaps the high and low order bytes of <tt>X</tt> if <tt>X</tt> is of
type <tt>Word</tt> or <tt>Integer</tt>, or swaps the high and low order words of
<tt>X</tt> if <tt>X</tt> is of type <tt>Longint</tt> or <tt>Cardinal</tt>.
<P>
The return type is the type of <tt>X</tt>
<H3><A NAME="SECTION041287300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041287400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuLo">Lo</A>, <A HREF="node71.html#fuHi">Hi</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example69;

{ Program to demonstrate the Swap function. }
Var W : Word;
    L : Longint;
    
begin
  W:=$1234;
  W:=Swap(W);
  if W&lt;&gt;$3412 then 
    writeln ('Error when swapping word !');
  L:=$12345678;
  L:=Swap(L);
  if L&lt;&gt;$56781234 then 
    writeln ('Error when swapping Longint !');
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041288000000000000000">Trunc</A></H2>
<P>
<A NAME="fuTrunc">&#160;</A>
<A NAME="8738">&#160;</A>
<H3><A NAME="SECTION041288100000000000000">Declaration:</A></H3>
<P>
<tt>Function Trunc  (X : Real)  : Longint;</tt>
<H3><A NAME="SECTION041288200000000000000">Description:</A></H3>
<P>
<tt>Trunc</tt> returns the integer part of <tt>X</tt>, 
which is always smaller than (or equal to)  <tt>X</tt>.
<H3><A NAME="SECTION041288300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041288400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuFrac">Frac</A>, <A HREF="node71.html#fuInt">Int</A>, <A HREF="node71.html#fuTrunc">Trunc</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example54;

{ Program to demonstrate the Trunc function. }

begin
  Writeln (Trunc(123.456));  { Prints 123  }
  Writeln (Trunc(-123.456)); { Prints -123 }
  Writeln (Trunc(12.3456));  { Prints 12   }
  Writeln (Trunc(-12.3456)); { Prints -12  }
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041289000000000000000">Truncate</A></H2>
<P>
<A NAME="proTruncate">&#160;</A>
<A NAME="8777">&#160;</A>
<H3><A NAME="SECTION041289100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Truncate  (Var F : file) ;</tt>
<H3><A NAME="SECTION041289200000000000000">Description:</A></H3>
<P>
<tt>Truncate</tt> truncates the (opened) file <tt>F</tt> at the current file
position.
<P>
<H3><A NAME="SECTION041289300000000000000">Errors:</A></H3>
<P>
Errors are reported by IOresult.
<H3><A NAME="SECTION041289400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proAppend">Append</A>, <A HREF="node71.html#fuFilepos">Filepos</A>,
<A HREF="node71.html#proSeek">Seek</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example71;

{ Program to demonstrate the Truncate function. }

Var F : File of longint;
    I,L : Longint;
    
begin
  Assign (F,'test.dat');
  Rewrite (F);
  For I:=1 to 10 Do 
    Write (F,I);
  Writeln ('Filesize before Truncate : ',FileSize(F));
  Close (f);
  Reset (F);
  Repeat
    Read (F,I);
  Until i=5;
  Truncate (F);
  Writeln ('Filesize after Truncate  : ',Filesize(F));
  Close (f);
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041290000000000000000">Upcase</A></H2>
<P>
<A NAME="fuUpcase">&#160;</A>
<A NAME="8813">&#160;</A>
<H3><A NAME="SECTION041290100000000000000">Declaration:</A></H3>
<P>
<tt>Function Upcase  (C : Char or string)  : Char or String;</tt>
<H3><A NAME="SECTION041290200000000000000">Description:</A></H3>
<P>
<tt>Upcase</tt> returns the uppercase version of its argument <tt>C</tt>.
If its argument is a string, then the complete string is converted to 
uppercase. The type of the returned value is the same as the type of the
argument.
<H3><A NAME="SECTION041290300000000000000">Errors:</A></H3>
<P>
None.
<H3><A NAME="SECTION041290400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#fuLowercase">Lowercase</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example72;

{ Program to demonstrate the Upcase function. }

Var I : Longint;

begin
  For i:=ord('a') to ord('z') do
    write (upcase(chr(i)));
  Writeln;
  { This doesn't work in TP, but it does in Free Pascal }
  Writeln (Upcase('abcdefghijklmnopqrstuvwxyz'));
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041291000000000000000">Val</A></H2>
<P>
<A NAME="proVal">&#160;</A>
<A NAME="8850">&#160;</A>
<H3><A NAME="SECTION041291100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Val  (const S : string;var V;var Code : word) ;</tt>
<H3><A NAME="SECTION041291200000000000000">Description:</A></H3>
<P>
<tt>Val</tt> converts the value represented in the string <tt>S</tt> to a numerical
value, and stores this value in the variable <tt>V</tt>, which 
can be of type <tt>Longint</tt>, <tt>Real</tt> and <tt>Byte</tt>.
<P>
If the conversion isn't succesfull, then the parameter <tt>Code</tt> contains
the index of the character in <tt>S</tt> which prevented the conversion.
<P>
The string <tt>S</tt> isn't allow to contain spaces.
<H3><A NAME="SECTION041291300000000000000">Errors:</A></H3>
<P>
If the conversion doesn't succeed, the value of <tt>Code</tt> indicates the
position where the conversion went wrong.
<H3><A NAME="SECTION041291400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proStr">Str</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example74;

{ Program to demonstrate the Val function. }
Var I, Code : Integer;

begin
  Val (ParamStr (1),I,Code);
  If Code&lt;&gt;0 then 
    Writeln ('Error at position ',code,' : ',Paramstr(1)[Code])
  else
    Writeln ('Value : ',I);  
end.</PRE>
<P>
</DL>}
<P>
<H2><A NAME="SECTION041292000000000000000">Write</A></H2>
<P>
<A NAME="proWrite">&#160;</A>
<A NAME="8933">&#160;</A>
<H3><A NAME="SECTION041292100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure Write  ([Var F : Any filetype;] V1 [; V2; ... , Vn)] ;</tt>
<H3><A NAME="SECTION041292200000000000000">Description:</A></H3>
<P>
<tt>Write</tt> writes the contents of the variables <tt>V1</tt>, <tt>V2</tt> etc. to
the file <tt>F</tt>. <tt>F</tt> can be a typed file, or a <tt>Text</tt> file.
<P>
If <tt>F</tt> is a typed file, then the variables <tt>V1</tt>, <tt>V2</tt> etc. must
be of the same type as the type in the declaration of <tt>F</tt>. Untyped files
are not allowed.
<P>
If the parameter <tt>F</tt> is omitted, standard output is assumed.
<P>
If <tt>F</tt> is of type <tt>Text</tt>, then the necessary conversions are done
such that the output of the variables is in human-readable format.
This conversion is done for all numerical types. Strings are printed exactly
as they are in memory, as well as <tt>PChar</tt> types. 
The format of the numerical conversions can be influenced through
the following modifiers:
<P>
<tt> OutputVariable : NumChars [: Decimals ]  </tt>
<P>
This will print the value of <tt>OutputVariable</tt> with a minimum of
<tt>NumChars</tt> characters, from which <tt>Decimals</tt> are reserved for the
decimals. If the number cannot be represented with <tt>NumChars</tt> characters,
<tt>NumChars</tt> will be increased, until the representation fits. If the
representation requires less than <tt>NumChars</tt> characters then the output
is filled up with spaces, to the left of the generated string, thus
resulting in a right-aligned representation.
<P>
If no formatting is specified, then the number is written using its natural
length, with a space in front of it if it's positive, and a minus sign if
it's negative.
<P>
Real numbers are, by default, written in scientific notation.
<P>
<H3><A NAME="SECTION041292300000000000000">Errors:</A></H3>
<P>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the <tt>{$i}</tt> switch. 
<H3><A NAME="SECTION041292400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proWriteLn">WriteLn</A>, <A HREF="node71.html#proRead">Read</A>, <A HREF="node71.html#proReadln">Readln</A>, <A HREF="node71.html#proBlockwrite">Blockwrite</A>
<P>
<H2><A NAME="SECTION041293000000000000000">WriteLn</A></H2>
<P>
<A NAME="proWriteLn">&#160;</A>
<A NAME="8997">&#160;</A>
<H3><A NAME="SECTION041293100000000000000">Declaration:</A></H3>
<P>
<tt>Procedure WriteLn  [([Var F : Text;] [V1 [; V2; ... , Vn)]] ;</tt>
<H3><A NAME="SECTION041293200000000000000">Description:</A></H3>
<P>
<tt>WriteLn</tt> does the same as <A HREF="node71.html#proWrite">Write</A> for text files, and emits a
Carriage Return - LineFeed character pair after that.
<P>
If the parameter <tt>F</tt> is omitted, standard output is assumed.
<P>
If no variables are specified, a Carriage Return - LineFeed character pair
is emitted, resulting in a new line in the file <tt>F</tt>.
<P>
<EM>Remark:</EM> Under LINUX, the Carriage Return character is omitted, as
customary in Unix environments.
<P>
<H3><A NAME="SECTION041293300000000000000">Errors:</A></H3>
<P>
If an error occurs, a run-time error is generated. This behavior can be
controlled with the <tt>{$i}</tt> switch. 
<H3><A NAME="SECTION041293400000000000000">See also:</A></H3>
<P>
<A HREF="node71.html#proWrite">Write</A>, <A HREF="node71.html#proRead">Read</A>, <A HREF="node71.html#proReadln">Readln</A>, <A HREF="node71.html#proBlockwrite">Blockwrite</A>
<P>
{
<DL ><DT><STRONG>Example</STRONG>
<DD>
<PRE>Program Example75;

{ Program to demonstrate the Write(ln) function. }

Var 
  F : File of Longint;
  L : Longint;
   
begin
  Write ('This is on the first line ! '); { No CR/LF pair! }
  Writeln ('And this too...');
  Writeln ('But this is already on the second line...');
  Assign (f,'test.dat');
  Rewrite (f);
  For L:=1 to 10 do 
    write (F,L); { No writeln allowed here ! }
  Close (f);
end.</PRE>
<P>
</DL>}
<P>
<HR><A NAME="tex2html1217" HREF="node72.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="file:/usr/lib/latex2html/icons/next_motif.gif"></A> <A NAME="tex2html1215" HREF="node69.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="file:/usr/lib/latex2html/icons/up_motif.gif"></A> <A NAME="tex2html1211" HREF="node70.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="file:/usr/lib/latex2html/icons/previous_motif.gif"></A> <A NAME="tex2html1219" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="file:/usr/lib/latex2html/icons/contents_motif.gif"></A> <A NAME="tex2html1220" HREF="node72.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="file:/usr/lib/latex2html/icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html1218" HREF="node72.html">Index</A>
<B>Up:</B> <A NAME="tex2html1216" HREF="node69.html">The system unit</A>
<B> Previous:</B> <A NAME="tex2html1212" HREF="node70.html">TypesConstants and Variables</A>
<P><ADDRESS>
<I>Michael Van Canneyt <BR>
Fri Sep 25 09:15:40 MEST 1998</I>
</ADDRESS>
</BODY>
</HTML>
