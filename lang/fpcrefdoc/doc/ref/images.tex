\batchmode
\documentclass{report}
\makeatletter
\usepackage{a4}
\usepackage{makeidx}
\usepackage{multicol}
\usepackage{html}
\usepackage{syntax}



\latex{





}

\latex{\usepackage{fpc}}
\latex{\usepackage{listings}\blankstringtrue\selectlisting{tp}\stringstyle{\ttfamily}\keywordstyle{\bfseries}
\prelisting{\sffamily\sloppy}}
\html{
















































}
\usepackage{fancyheadings}
\pagestyle{fancy}

\makeindex

\newenvironment {diagram}[2]{\begin{quote}\rule{0.5pt}{1ex}\rule[1ex]{\linewidth}{0.5pt}\rule{0.5pt}{1ex}\\ [-0.5ex]\textbf{#1}\\ [-0.5ex]}{\rule{0.5pt}{1ex}\rule{\linewidth}{0.5pt}\rule{0.5pt}{1ex}\end{quote}}

\newenvironment {mysyntdiag}{\begin{syntdiag}\setlength{\sdmidskip}{.5em}\sffamily\sloppy}{\end{syntdiag}}

\newenvironment {psyntax}[2]{\begin{diagram}{#1}{#2}\begin{mysyntdiag}}{\end{mysyntdiag}\end{diagram}}

\renewcommand {\litleft}{\bfseries\ }

\renewcommand {\ulitleft}{\bfseries\ }

\renewcommand {\syntleft}{\ }

\renewcommand {\litright}{\ \rule[.5ex]{.5em}{2\sdrulewidth}}

\renewcommand {\ulitright}{\ \rule[.5ex]{.5em}{2\sdrulewidth}}

\renewcommand {\syntright}{\ \rule[.5ex]{.5em}{2\sdrulewidth}}

\newcommand {\seesy}[1]{see diagram}

\newenvironment {FPCList}{\begin{description}}{\end{description}}

\newcommand {\functionl}[7]{
\subsection{#1}
\label{fu:#2}
\index{#1}
\subsubsection*{Declaration:}
\texttt {Function #1  #3  : #4;}
\subsubsection*{Description:}
#5
\subsubsection*{Errors:}
#6
\subsubsection*{See also:}
#7
}

\newcommand {\procedurel}[6]{
\subsection{#1}
\label{pro:#2}
\index{#1}
\subsubsection*{Declaration:}
\texttt {Procedure #1  #3 ;}
\subsubsection*{Description:}
#4
\subsubsection*{Errors:}
#5
\subsubsection*{See also:}
#6
}

\newcommand {\seefl}[2]{
\htmlref{#1}{fu:#2}
}

\newcommand {\seepl}[2]{
\htmlref{#1}{pro:#2}
}

\newcommand {\seef}[1]{\seefl{#1}{#1}}

\newcommand {\seep}[1]{\seepl{#1}{#1}}

\newcommand {\seet}[1]{
\htmlref{#1}{sec:types}
}

\newcommand {\seem}[2] {\texttt{#1} (#2) }

\newcommand {\var}[1]{\texttt {#1}}

\newcommand {\file}[1]{\textsf {#1}}

\newcommand {\Procedurel}[5]{\procedurel{#1}{#2}{}{#3}{#4}{#5}}

\newcommand {\Functionl}[6]{\functionl{#1}{#2}{}{#3}{#4}{#5}{#6}}

\newcommand {\procedure}[5]{\procedurel{#1}{#1}{#2}{#3}{#4}{#5}}

\newcommand {\function}[6]{\functionl{#1}{#1}{#2}{#3}{#4}{#5}{#6}}

\newcommand {\Procedure}[4]{\procedure{#1}{}{#2}{#3}{#4}}

\newcommand {\Function}[5]{\function{#1}{}{#2}{#3}{#4}{#5}}

\newcommand {\linux}{\textsc{LinuX} }

\newcommand {\dos}  {\textsc{dos} }

\newcommand {\msdos}{\textsc{ms-dos} }

\newcommand {\ostwo}{\textsc{os/2} }

\newcommand {\windowsnt}{\textsc{WindowsNT} }

\newcommand {\windows}{\textsc{Windows} }

\newcommand {\docdescription}[1]{}

\newcommand {\docversion}[1]{}

\newcommand {\unitdescription}[1]{}

\newcommand {\unitversion}[1]{}

\newcommand {\fpc}{Free Pascal }

\newcommand {\gnu}{gnu }

\newcommand {\progref}{\htmladdnormallink{Programmer's guide}{../prog/prog.html}\ }

\newcommand {\refref}{\htmladdnormallink{Reference guide}{../ref/ref.html}\ }

\newcommand {\userref}{\htmladdnormallink{Users' guide}{../user/user.html}\ }

\newcommand {\unitsref}{\htmladdnormallink{Unit reference}{../units/units.html}\ }

\newcommand {\seecrt}{\htmladdnormallink{CRT}{../crt/crt.html}}

\newcommand {\seelinux}{\htmladdnormallink{Linux}{../linux/linux.html}}

\newcommand {\seestrings}{\htmladdnormallink{strings}{../strings/strings.html}}

\newcommand {\seedos}{\htmladdnormallink{DOS}{../dos/dos.html}}

\newcommand {\seegetopts}{\htmladdnormallink{getopts}{../getopts/getopts.html}}

\newcommand {\seeobjects}{\htmladdnormallink{objects}{../objects/objects.html}}

\newcommand {\seegraph}{\htmladdnormallink{graph}{../graph/graph.html}}

\newcommand {\seeprinter}{\htmladdnormallink{printer}{../printer/printer.html}}

\newcommand {\seego}{\htmladdnormallink{GO32}{../go32/go32.html}}

\newenvironment {CodEx}{}{}

\newenvironment {FPCtable}[2]{\begin{table}\caption{#2}\begin{center}\begin{tabular}{#1}}{\end{tabular}\end{center}\end{table}}

\newenvironment {FPCltable}[3]{\begin{table}\caption{#2}\label{tab:#3}\begin{center}\begin{tabular}{#1}}{\end{tabular}\end{center}\end{table}}

\newcommand {\seec}[1]{chapter (\ref{ch:#1}) }

\newcommand {\sees}[1]{section (\ref{se:#1}) }

\renewcommand {\chaptermark}[1]{\markboth{#1}{}}

\renewcommand {\prelisting}{\sffamily}

\makeatother
\newenvironment{tex2html_wrap}{}{}
\newwrite\lthtmlwrite
\def\lthtmltypeout#1{{\let\protect\string\immediate\write\lthtmlwrite{#1}}}%
\newbox\sizebox
\textheight 50cm
\begin{document}
\pagestyle{empty}
\stepcounter{section}
\stepcounter{subsection}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{syntactical\ elements\ are\ like\ this}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\lit*{keywords\ are\ like\ this}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\<[b] \synt{this\ can\ be\ repeated} \\  \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\( 
\synt{First\ possibility} \\ 
\synt{Second\ possibility}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\begin{displaymath} 
\synt{First\ possibility} \\ 
\synt{Second\ possibility}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{part}
\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{letter} \( \lit*{A ... Z} \\  \lit*{a ... z} \) 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{digit}  \lit*{0 ... 9}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{hex\ digit} 
\( \lit*{0 ... 9} \\  \lit*{A ... F} \\  \lit*{a ...f} \) 
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{section}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{multicols}{4}{
\begin{verbatim}absolute
and
array
asm
begin
break
case
const
constructor
continue
destructor
dispose
div
do
downto
else
end
exit
false
file
for
function
goto
if
implementation
in
inherited
inline
interface
label
mod
new
nil
not
object
of
on
operator
or
packed
procedure
program
record
repeat
self
set
shl
shr
string
then
to
true
try
type
unit
until
uses
var
while
with
xor\end{verbatim}
\latex{\end{multicols}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{multicols}{4}{
\begin{verbatim}as
class
except
exports
finalization
finally
initialization
is
library
on
property
raise
try\end{verbatim}
\latex{\end{multicols}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{multicols}{4}{
\begin{verbatim}dispose
exit
export
false
new
popstack
true\end{verbatim}
\latex{\end{multicols}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{multicols}{4}{
\begin{verbatim}absolute
abstract
alias
assembler
cdecl
default
export
external
far
forward
index
name
near
override
pascal
popstack
private
protected
public
published
read
register
stdcall
virtual
write\end{verbatim}
\latex{\end{multicols}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{identifier} \begin{displaymath} \synt{letter} \\  \lit*{\_} \end{displaymath} 
\begin{rep}[b] \\ 
\(
\synt{letter} \\ 
\synt{digit} \\ 
\lit*{\_} 
\)
\end{rep}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{hex\ digit\ sequence} 
\begin{rep}[b] 
 \synt{hex\ digit} \\  
\end{rep} 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{bin\ digit\ sequence} 
\begin{rep}[b] 
 \begin{stack}
 \lit*{1} \\  \lit*{0} 
 \end{stack}
 \\  
\end{rep} 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{digit\ sequence} 
\begin{rep}[b] 
 \synt{digit} \\ 
\end{rep} 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unsigned\ integer} 
 \begin{stack}
  \synt{digit\ sequence} \\ 
  \lit*{\$} \synt{hex\ digit\ sequence} \\ 
  \lit*{\%} \synt{bin\ digit\ sequence}
 \end{stack}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppysign \begin{stack} \lit* + \\  \lit* - \end{stack}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unsigned\ real} \synt{digit\ sequence} 
\begin{displaymath}
    \lit . \synt{digit\ sequence} 
\end{displaymath}
\begin{displaymath}
 \synt{scale\ factor} 
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{scale\ factor} \begin{stack} \lit*{E} \\  \lit*{e} \end{stack}
\begin{stack}\\  \synt{sign} \end{stack} \synt{digit\ sequence}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unsigned\ number} \begin{stack} \synt{unsigned\ real} \\ 
\synt{unsigned\ integer} \end{stack}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{signed\ number} \begin{stack} \\  \synt{sign}  \end{stack}
\synt{unsigned\ number}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{label}  \( \synt{digit\ sequence} \\  \synt{identifier} \)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{character\ string} 
\begin{rep}[b] \( \synt{quoted\ string} \\  \synt{control\ string} \) \end{rep}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{quoted\ string} 
\lit*{'}
\begin{rep}[b] \synt{string\ character} \\   \end{rep}
\lit*{'}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{string\ character} 
\(
\tok{ Any character except ' or CR} \\ 
\lit*{''}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{control\ string} 
\begin{rep}[b]
\lit*{\#} \synt{unsigned\ integer} \\ 
\end{rep}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
 \synt{constant\ declaration}
\begin{rep}[b]
  \synt{identifier} \lit*= \synt{expression} \lit*; \\ 
\end{rep}  
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Const
  e = 2.7182818;  { Real type constant. }
  a = 2;          { Integer type constant. }
  c = '4';        { Character type constant. }
  s = 'This is a constant string'; {String type constant.}
  s = chr(32)
  ls = SizeOf(Longint);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}s := 'some other string';
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{typed\ constant\ declaration}
\begin{rep}[b]
  \synt{identifier} \lit*: \synt{type} \lit*= \synt{typed\ constant} \lit*; \\ 
\end{rep}  
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{typed\ constant}
\(
\synt{constant} \\ 
\synt{address\ constant} \\ 
\synt{array\ constant} \\ 
\synt{record\ constant} \\ 
\synt{procedural\ constant}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Const
  S : String = 'This is a typed constant string';
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}S := 'Result : '+Func;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Const 
  tt : array [1..3] of string[20] = ('ikke', 'gij', 'hij');
  ti : array [1..3] of Longint = (1,2,3);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  Point = record
    X,Y : Real
    end;

Const
  Origin : Point = (X:0.0 , Y:0.0); 
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{type\ declaration} \synt{identifier} \lit*= \synt{type} \lit* ;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{type}
\(
\synt{simple\ type} \\ 
\synt{string\ type} \\ 
\synt{structured\ type} \\ 
\synt{pointer\ type} \\ 
\synt{procedural\ type}\\ 
\synt{type\ identifier}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{simple\ type}
\(
\synt{ordinal\ type} \\ 
\synt{real\ type}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{real\ type} \synt{real\ type\ identifier}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{subsubsection}
\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{listing}B := True;
 B := False;
 B := 1<>2;  { Results in B := True }
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}...
 B := False;
 A := B and Func;
\end{listing}}\hbox{}\vfil

\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{enumerated\ type} \lit* ( 
\begin{rep}[b]
\(
\synt{identifier\ list} \\ 
\synt{assigned\ enum\ list}
\) \\ 
\lit*,
\end{rep} \lit )
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{identifier\ list}  
\begin{rep}[b]
\synt{identifier} \\ 
\lit*,
\end{rep}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{assigned\ enum\ list}  
\begin{rep}[b]
\synt{identifier} \lit*{:=} \synt{expression} \\ 
\lit*,
\end{rep}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  Direction = ( North, East, South, West );
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  EnumType = (one, two, three, forty := 40);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  EnumType = (one, two, three, forty := 40, thirty := 30);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  LargeEnum = ( BigOne, BigTwo, BigThree );
{$PACKENUM 1}
  SmallEnum = ( one, two, three );

Var S : SmallEnum;
    L : LargeEnum;

begin
  WriteLn ('Small enum : ',SizeOf(S));
  WriteLn ('Large enum : ',SizeOf(L));
end.
\end{listing}}\hbox{}\vfil

\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{subrange\ type} \synt{constant} \lit*{..} \synt{constant}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  Longint  = $80000000..$7fffffff;
  Integer  = -32768..32767;
  shortint = -128..127;
  byte     = 0..255;
  Word     = 0..65535;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  Days = (monday,tuesday,wednesday, thursday,friday,
          saturday,sunday);
  WorkDays = monday .. friday;
  WeekEnd = Saturday .. Sunday;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{section}
\stepcounter{subsection}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{string\ type} 
\lit*{string} 
  \begin{displaymath} 
    \lit*[ \synt{unsigned\ integer} \lit*] 
  \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
   NameString = String[10];
   StreetString = String;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}S := 'This is a string.';
S := 'One'+', Two'+', Three';
S := 'This isn''t difficult !';
S := 'This is a weird character : '#145' !';
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}program one;

var p : PChar;

begin
  P := 'This is a null-terminated string.';
  WriteLn (P);
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}program two;

const P : PChar = 'This is a null-terminated string.'

begin
  WriteLn (P);
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Program three;

Var S : String[30];
    P : PChar;

begin
  S := 'This is a null-terminated string.'#0;
  P := @S[1];
  WriteLn (P);
end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{structured\ type} 
\(
\synt{array\ type} \\ 
\synt{record\ type} \\ 
\synt{class\ type} \\ 
\synt{class\ reference\ type}\\ 
\synt{set\ type}\\ 
\synt{file\ type}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{array\ type}
\begin{displaymath} \lit*{packed} \end{displaymath} \lit*{array}\lit*[ 
\<[b] \synt{ordinal\ type} \\  \lit*, \> 
\lit*] \lit*{of} \synt{type}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  RealArray = Array [1..100] of Real;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
   APoints = array[1..100] of Array[1..3] of Real;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
   APoints = array[1..100,1..3] of Real;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{record\ type} \begin{displaymath} \lit*{packed} \end{displaymath} \lit*{record}
\begin{displaymath} \synt{field\ list} \end{displaymath} \lit*{end}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{field\ list} 
\( 
\synt{fixed\ fields} \\ 
\begin{displaymath} \synt{fixed\ fields} \lit*; \end{displaymath}  \synt{variant\ part}
\)
\begin{displaymath} \lit*; \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{fixed\ fields} 
\<[b] \synt{identifier\ list} \lit*: \synt{type} \\  \lit*; \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{variant\ part} 
\lit*{case}
\begin{displaymath} \synt{identifier} \lit*: \end{displaymath} 
\synt{ordinal\ type\ identifier} 
\lit*{of} \<[b] \synt{variant} \\  \lit*; \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{variant} \<[b] \synt{constant} \lit*, \> 
\lit*: \lit*( \begin{displaymath} \synt{field\ list} \end{displaymath} \lit*)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  Point = Record
          X,Y,Z : Real;
          end;
  RPoint = Record
          Case Boolean of
          False : (X,Y,Z : Real);
          True : (R,theta,phi : Real);
          end;
  BetterRPoint = Record
          Case UsePolar : Boolean of
          False : (X,Y,Z : Real);
          True : (R,theta,phi : Real);
          end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  MyRec = Record
          X : Longint;
          Case byte of
            2 : (Y : Longint;
                 case byte of
                 3 : (Z : Longint);
                 );
          end;     
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Program PackRecordsDemo;

type {$PackRecords 2}
     Trec1 = Record
       A : byte;
       B : Word;
       
     end;
     
     {$PackRecords 2{
     Trec1 = Record
       A : byte;
       B : Word;
       
     end;
     
     }$PackRecords 1{
     Trec2 = Record
       A : Byte;
       B : Word;
       end;

begin
  WriteLn ('Size Trec1 : ',SizeOf(Trec1));
  WriteLn ('Size Trec2 : ',SizeOf(Trec2));
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Size Trec1 : 4
Size Trec2 : 3
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}{$PackRecords 1{
     Trec2 = Record
       A : Byte;
       B : Word;
       end;

begin
  WriteLn ('Size Trec1 : ',SizeOf(Trec1));
  WriteLn ('Size Trec2 : ',SizeOf(Trec2));
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Size Trec1 : 4
Size Trec2 : 3
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}{$PackRecords 1}
     Trec2 = Record
       A : Byte;
       B : Word;
       end;
     {$PackRecords 1{
     Trec2 = Record
       A : Byte;
       B : Word;
       end;
     }$PackRecords 2{
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Trec2 = Packed Record
       A : Byte;
       B : Word;
       end;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{set\ type} \lit*{set} \lit*{of} \synt{ordinal\ type}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
    Junk = Set of Char;
  
    Days = (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
    WorkDays : Set of days;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}WorkDays := [ Mon, Tue, Wed, Thu, Fri];
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{file\ type} \lit*{file} \begin{displaymath} \lit*{of} \synt{type} \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
   Point = Record
     X,Y,Z : real;
     end;
   PointFile = File of Point;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{pointer\ type} \lit*\^{} \synt{type\ identifier}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Program pointers;

type 
  Buffer = String[255];
  BufPtr = ^Buffer;

Var B  : Buffer;
    BP : BufPtr;
    PP : Pointer;

etc..
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var p : ^Longint;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var p : array[0..Infinity] of Longint;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}program PointerArray;

var i : Longint;
    p : ^Longint;
    pp : array[0..100] of Longint;  

begin
  for i := 0 to 100 do pp[i] := i; { Fill array }
  p := @pp[0];                     { Let p point to pp }
  for i := 0 to 100 do 
    if p[i]<>pp[i] then 
      WriteLn ('Ohoh, problem !')
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Inc(P);
Dec(P);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var P : ^Longint;

...

 Inc (p);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}var  p1,p2 : ^Longint;
     L : Longint;

begin
  P1 := @P2;
  P2 := @L;
  L := P1-P2;
  P1 := P1-4;
  P2 := P2+4;
end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedural\ type} 
\( \synt{function\ header} \\  
   \synt{procedure\ header}
\)
\begin{displaymath} \lit*{of} \lit*{object} \end{displaymath}
\begin{displaymath} \lit* ; \synt{call\ modifiers} \end{displaymath} 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{function\ header} \lit*{function} \synt{formal\ parameter\ list}
\lit*: \synt{result\ type}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedure\ header} \lit*{procedure} \synt{formal\ parameter\ list}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{call\ modifiers} 
\( 
\lit*{register} \\ 
\lit*{cdecl}    \\ 
\lit*{pascal}   \\ 
\lit*{stdcall}  \\ 
\lit*{popstack}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type TOneArg = Procedure (Var X : integer);
     TNoArg = Function : Real;

var proc : TOneArg;
    func : TNoArg;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure printit (Var X : Integer);

begin
  WriteLn (x);
end;
...

P := @printit;
Func := @Pi;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type TOneArgCcall = Procedure (Var X : integer);cdecl;

var proc : TOneArgCcall;

Procedure printit (Var X : Integer);

begin
  WriteLn (x);
end;

begin
P := @printit;
end.
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\begin{displaymath} \lit*{packed} \end{displaymath}
\lit*{object} 
\begin{displaymath} heritage \end{displaymath}
\begin{displaymath} 
\begin{rep}[b]
  \synt{component\ list} \\  
  \synt{object\ visibility\ specifier} 
\end{rep} \lit*{end} 
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{heritage} \lit*( \synt{object\ type\ identifier} \lit* )
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{component\ list} 
\begin{displaymath} \<[b] \synt{field\ definition} \\  \> \end{displaymath}
\begin{displaymath} \<[b] \synt{method\ definition} \\  \> \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{field\ definition} \synt{identifier\ list} \lit*: \synt{type} \lit*;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{method\ definition} 
\( 
\synt{function\ header} \\ 
\synt{procedure\ header} \\ 
\synt{constructor\ header} \\ 
\synt{desctuctor\ header}
\)
\lit*; \synt{method\ directives} 
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{method\ directives}
\begin{displaymath}
\lit*{virtual} \lit*;
\end{displaymath}
\begin{displaymath} \synt{call\ modifiers} \lit*; \end{displaymath}
\begin{displaymath}
\lit*{abstract} \lit*;
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{object\ visibility\ specifier}
\( 
\lit*{private} \\ 
\lit*{public}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type MyObj = Object
       Procedure Doit;
       Field : Longint;
     end; 
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type MyObj = Object
      Public
       Procedure Doit;
      Private
       Field : Longint;
     end; 
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  TObj = packed object;
   Constructor init;
   ...
   end;
  Pobj = ^TObj;

Var PP : Pobj;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}Type TAnObject = Object
       AField : Longint;
       Procedure AMethod;
       end;

Var AnObject : TAnObject;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}AnObject.AField := 0;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure TAnObject.AMethod;

begin
  ...
  AField := 0;
  ...
end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure TAnObject.AMethod;

begin
  ...
  Self.AField := 0;
  ...
end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}With AnObject do
  begin
  Afield := 12;
  AMethod;
  end;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{constructor\ declaration}
\synt{constructor\ header} \lit* ; \synt{subroutine\ block}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{destructor\ declaration}
\synt{destructor\ header} \lit* ; \synt{subroutine\ block}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{constructor\ header}
\lit*{constructor} 
\( \synt{identifier} \\  \synt{qualified\ method\ identifier} \)
 \synt{formal\ parameter\ list}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{desctructor\ header}
\lit*{destructor} 
\( \synt{identifier} \\  \synt{qualified\ method\ identifier} \)
 \synt{formal\ parameter\ list}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  TObj = object;
   Constructor init;
   ...
   end;
  Pobj = ^TObj;

Var PP : Pobj;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}pp := new (Pobj,Init);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}new(pp,init);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}new (pp);
  pp^.init;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{section}
\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{listing}Type
  TParent = Object 
    ...
    procedure Doit;
    ...
    end;
  PParent = ^TParent;
  TChild = Object(TParent) 
    ...
    procedure Doit;
    ...
    end;
  PChild = ^TChild;  
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var ParentA,ParentB : PParent;
    Child           : PChild;

   ParentA := New(PParent,Init);
   ParentB := New(PChild,Init);
   Child := New(PChild,Init);

   ParentA^.Doit;
   ParentB^.Doit;
   Child^.Doit;
\end{listing}}\hbox{}\vfil

\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{listing}Type
  TParent = Object 
    ...
    procedure Doit;virtual;
    ...
    end;
  PParent = ^TParent;
  TChild = Object(TParent) 
    ...
    procedure Doit;virtual;
    ...
    end;
  PChild = ^TChild;  
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var ParentA,ParentB : PParent;
    Child           : PChild;

   ParentA := New(PParent,Init);
   ParentB := New(PChild,Init);
   Child := New(PChild,Init);

   ParentA^.Doit;
   ParentB^.Doit;
   Child^.Doit;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure TChild.Doit;

begin
  inherited Doit; 
  ...
end;
\end{listing}}\hbox{}\vfil

\stepcounter{subsubsection}
{\newpage\clearpage\samepage
\begin{listing}Type
  TParent = Object 
    ...
    procedure Doit;virtual;abstract;
    ...
    end;
  PParent=^TParent;
  TChild = Object(TParent) 
    ...
    procedure Doit;virtual;
    ...
    end;
  PChild = ^TChild;  
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var ParentA,ParentB : PParent;
    Child           : PChild;

   ParentA := New(PParent,Init);
   ParentB := New(PChild,Init);
   Child := New(PChild,Init);

   ParentA^.Doit;
   ParentB^.Doit;
   Child^.Doit;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\begin{displaymath} \lit*{packed} \end{displaymath}
\lit*{class} 
\begin{displaymath} heritage \end{displaymath}
\begin{displaymath} 
\begin{rep}[b]
  \synt{component\ list} \\  
  \synt{class\ visibility\ specifier} 
\end{rep} \lit*{end} 
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{heritage} \lit*( \synt{class\ type\ identifier} \lit* )
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{component\ list} 
\begin{displaymath} \<[b] \synt{field\ definition} \\  \> \end{displaymath}
\begin{displaymath} 
  \<[b] 
    \( 
      \synt{method\ definition} \\ 
      \synt{property\ definition}
    \) \\  
  \> 
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{field\ definition} \synt{identifier\ list} \lit*: \synt{type} \lit*;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{method\ definition} 
\( 
\begin{displaymath}
\lit*{class}
\end{displaymath}
\(
\synt{function\ header} \\ 
\synt{procedure\ header}
\) \\ 
\synt{constructor\ header} \\ 
\synt{desctuctor\ header}
\)
\lit*;
\begin{displaymath}
\lit*{virtual} \lit*;
\end{displaymath}
\begin{displaymath} \synt{call\ modifiers} \lit*; \end{displaymath}
\begin{displaymath}
\lit*{abstract} \lit*;
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{class\ visibility\ specifier}
\( 
\lit*{private}\\ 
\lit*{protected}\\ 
\lit*{public}\\ 
\lit*{published}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}ClassVar := ClassType.ConstructorName;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}Var  AnObject : TAnObject;

begin
  AnObject := TAnObject.Create;
  ANobject.AMethod;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{property\ definition}
\lit*{property} \synt{identifier} \begin{displaymath} \synt{property\ interface} \end{displaymath}
\synt{property\ specifiers}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{property\ interface}
\begin{displaymath} \synt{property\ parameter\ list}\end{displaymath} \lit*: \synt{type\ identifier}
\begin{displaymath}
\lit*{index} \synt{integer constant}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{property\ parameter\ list} \lit*[
\<[b] \synt{parameter\ declaration} \\  \lit; \> 
\lit*]
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{property\ specifiers}
\begin{displaymath} \synt{read\ specifier} \end{displaymath}
\begin{displaymath} \synt{write\ specifier} \end{displaymath}
\begin{displaymath} \synt{default\ specifier} \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{read\ specifier} \lit*{read} \synt{field\ or\ method}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{write\ specifier} \lit*{write} \synt{field\ or\ method}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{default\ specifier}
\( 
\lit*{default} \begin{displaymath} \synt{constant} \end{displaymath} \\ 
\lit*{nodefault}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{field\ or\ method}
\(
\synt{field\ identifier} \\ 
\synt{method\ identifier}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type
  MyClass = Class
    Private
    Field1 : Longint;
    Field2 : Longint;
    Field3 : Longint;
    Procedure  Sety (value : Longint);
    Function Gety : Longint; 
    Function Getz : Longint;
    Public
    Property X : Longint Read Field1 write Field2;
    Property Y : Longint Read GetY Write Sety;
    Property Z : Longint Read GetZ;
    end;

Var MyClass : TMyClass; 
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}WriteLn ('X : ',MyClass.X);
WriteLn ('Y : ',MyClass.Y);
WriteLn ('Z : ',MyClass.Z);
MyClass.X := 0;
MyClass.Y := 0;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}MyClass.Z := 0;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}uses objpas;

Type TPoint = Class(TObject)
       Private
       FX,FY : Longint;
       Function GetCoord (Index : Integer): Longint;
       Procedure SetCoord (Index : Integer; Value : longint); 
       Public
       Property X : Longint index 1 read GetCoord Write SetCoord;
       Property Y : Longint index 2 read GetCoord Write SetCoord;
       Property Coords[Index : Integer] Read GetCoord;
       end;

Procedure TPoint.SetCoord (Index : Integer; Value : Longint);

begin
  Case Index of
   1 : FX := Value;
   2 : FY := Value;
  end;
end;

Function TPoint.GetCoord (INdex : Integer) : Longint;

begin
  Case Index of
   1 : Result := FX;
   2 : Result := FY;
  end;
end;

Var P : TPoint;

begin
  P := TPoint.create;
  P.X := 2;
  P.Y := 3;
  With P do
    WriteLn ('X=',X,' Y=',Y);
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type TIntList = Class
      Private
      Function GetInt (I : Longint) : longint;
      Function GetAsString (A : String) : String;
      Procedure SetInt (I : Longint; Value : Longint;);
      Procedure SetAsString (A : String; Value : String);
      Public
      Property Items [i : Longint] : Longint Read GetInt 
                                             Write SetInt;
      Property StrItems [S : String] : String Read GetAsString 
                                              Write SetAsstring;
      end;

Var AIntList : TIntList;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}AIntList.Items[26] := 1;
AIntList.StrItems['twenty-five'] := 'zero';

WriteLn ('Item 26 : ',AIntList.Items[26]);
WriteLn ('Item 25 : ',AIntList.StrItems['twenty-five']);
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}AIntList.Items['twenty-five'] := 1;
AIntList.StrItems[26] := 'zero';
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Property Items[i : Longint]: Longint Read GetInt 
                                      Write SetInt; Default;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}AIntList.Items[26] := 1;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}AIntList[26] := 1;
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{expression}
\synt{simple\ expression}
\begin{displaymath} 
\(
 \verb*+ * +  \\ 
 \verb*+ <= + \\ 
 \verb*+ > +  \\ 
 \verb*+ >= + \\ 
 \verb*+ = +  \\ 
 \verb*+ <> + \\ 
 \verb*+ in + \\ 
 \verb*+ is + 
\)
\synt{simple\ expression}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{simple\ expression} 
\<[b] \synt{term} \\ 
\( 
 \lit* + \\ 
 \lit* - \\ 
 \lit*{or} \\ 
 \lit*{xor} 
\)
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}GraphResult<>grError
(DoItToday=Yes) and (DoItTomorrow=No);   
Day in Weekend
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}A + B
-Pi
ToBe or Not ToBe
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{term}
\<[b] \synt{factor} \\ 
\(
\verb*+ * + \\ 
\verb*+ / + \\ 
\lit*{div} \\ 
\lit*{mod} \\ 
\lit*{and} \\ 
\lit*{shl} \\ 
\lit*{shr} \\ 
\lit*{as} 
\)
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}2 * Pi
A Div B
(DoItToday=Yes) and (DoItTomorrow=No);   
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{factor}
\( \lit* ( \synt{expression} \lit*) \\ 
\synt{variable\ reference} \\ 
\synt{function\ call} \\ 
\synt{unsigned\ constant}\\ 
\lit*{not} \synt{factor} \\ 
\lit{sign} \synt{factor}\\ 
\synt{set\ constructor}\\ 
\synt{value\ typecast}\\ 
\synt{address\ factor}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unsigned\ constant} 
\( \synt{unsigned\ number} \\ 
   \synt{character\ string} \\ 
   \synt{constant\ identifier} \\ 
   \lit*{Nil}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{function\ call}
\( 
\synt{function\ identifier} \\ 
\synt{method\ designator} \\ 
\synt{qualified\ method\ designator}\\ 
\synt{variable\ reference}
\)
\begin{displaymath}
\synt{actual\ parameter\ list}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{actual\ parameter\ list}
\lit* ( 
\begin{displaymath}
\<[b] 
\synt{actual\ parameter} \\  
\lit* , 
\> 
\end{displaymath}
\lit* )
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{actual\ parameter} 
\( 
\synt{expression} \\  
\synt{variable\ reference}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type 
  FuncType = Function: Integer;

Var A : Integer;

Function AddOne : Integer;

begin
  A := A+1;
  AddOne := A;
end;

Var F : FuncType;
    N : Integer;

begin
  A := 0;
  F := AddOne; { Assign AddOne to F, Don't call AddOne}
  N := AddOne; { N := 1 !!}
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If F = AddOne Then
  DoSomethingHorrible;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If F = @AddOne Then
  WriteLn ('Functions are equal');
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If F()=Addone then
    WriteLn ('Functions return same values ');
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{set\ constructor} \lit* [ 
\begin{displaymath}
 \<[b] \synt{set\ group} \\  \lit* , \>
\end{displaymath}
\lit* ]
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{set\ group} \synt{expression} 
\begin{displaymath}
\lit* {..} \synt{expression}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}[today,tomorrow]
[Monday..Friday,Sunday]
[ 2, 3*2, 6*2, 9*2 ]
['A'..'Z','a'..'z','0'..'9']
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{value\ typecast} 
\synt{type\ identifier} 
\lit* ( 
\synt{expression} 
\lit* )
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Byte('A')
Char(48)
boolean(1)
longint(@Buffer)
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Integer('A')
Char(4875)
boolean(100)
Word(@Buffer)
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{address factor}
\lit* @
\( 
\synt{variable\ reference} \\ 
\synt{procedure\ identifier} \\ 
\synt{function\ identifier}\\ 
\synt{qualified\ method\ identifier}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Program tcast;

{$T-} { @ returns untyped pointer }
 
Type art = Array[1..100] of byte;

Var Buffer : longint;
    PLargeBuffer : ^art;
    
begin
 PLargeBuffer := @Buffer;
end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}I mod J = I - (I div J) * J
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}A shr 1  { same as A div 2, but faster}
Not 1    { equals -2 }
Not 0    { equals -1 }
Not -1   { equals 0  }
B shl 2  { same as B * 2 for integers }
1 or 2   { equals 3 }
3 xor 1  { equals 2 }
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}B := True or MaybeTrue;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}'This is ' + 'VERY ' + 'easy !'
  Dirname+'\' 
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var Dirname = Pchar;
...
  Dirname := Dirname+'\';
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{chapter}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{statement}
\begin{displaymath}
\synt{label} \lit*:
\end{displaymath}
\begin{displaymath}
\synt{simple\ statement}\\ 
\synt{structured\ statement}\\ 
\synt{asm\ statement}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{siple\ statement}
\(
\synt{assignment\ statement} \\ 
\synt{procedure\ statement} \\ 
\synt{goto\ statement}\\ 
\synt{raise\ statement}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{assignment\ statement}
\(
\synt{variable\ reference} \\ 
\synt{function\ identifier}
\)
\( 
\lit*{:=} \\ 
\lit*{+=} \\ 
\lit*{-=} \\ 
\lit*{*=} \\ 
\lit*{/=}
\)
\synt{expression}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}X := X+Y;
X+=Y;      { Same as X := X+Y, needs -Sc command line switch}
X/=2;      { Same as X := X/2, needs -Sc command line switch}
Done := False;
Weather := Good;
MyPi := 4* Tan(1);
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{procedure\ statement}
\(
\synt{procedure\ identifier} \\ 
\synt{method\ identifier} \\ 
\synt{qualified\ method\ identifier} \\ 
\synt{variable\ reference}
\)
\begin{displaymath}
\synt{actual\ parameter\ list}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Usage;
WriteLn('Pascal is an easy language !');  
Doit();
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{goto\ statement} \lit*{goto} \synt{label}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}var
  jumpto : label
...
Jumpto : 
  Statement;
...
Goto jumpto;
...
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{structured\ statement}
\(
\synt{compound\ statement}\\ 
\synt{repetitive\ statement}\\ 
\synt{conditional\ statement}\\ 
\synt{exception\ statement}\\ 
\synt{with\ statement}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{conditional\ statement}
\(
\synt{if\ statement}\\ 
\synt{case\ statement}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{repetitive\ statement}
\(
\synt{for\ statament}\\ 
\synt{repeat\ statement}\\ 
\synt{while\ statement}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{compound\ statement} 
\lit*{begin}
\<[b] \synt{statement} \\  \lit* ; \>
\lit*{end}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{case\ statement}
\lit*{case} \synt{expression} \lit*{of}
\<[b] case \\  \lit* ; \>
\begin{displaymath} \synt{else\ part} \end{displaymath} \begin{displaymath} \lit* ; \end{displaymath} 
\lit*{end}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{case} 
\<[b] 
  \synt{constant} \begin{displaymath} \lit*{..} \synt{constant} \end{displaymath} \\ 
\lit* ,
\>
\lit* :
\synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{else\ part} \lit* {else} \synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Var i : integer;
...

Case i of
 3 : DoSomething;
 1..5 : DoSomethingElse;
end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Case C of 
 'a' : WriteLn ('A pressed');
 'c' : WriteLn ('C pressed');
else
  WriteLn ('unknown letter pressed : ',C);
end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Case C of 
 'a','e','i','o','u' : WriteLn ('vowel pressed');
 'y' : WriteLn ('This one depends on the language');
else
  WriteLn ('Consonant pressed');
end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Case Number of 
 1..10   : WriteLn ('Small number');
 11..100 : WriteLn ('Normal, medium number');
else
 WriteLn ('HUGE number');
end;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{if\ statement}
\lit*{if}
\synt{expression}
\lit*{then} \synt{statement}
\begin{displaymath}
\lit*{else} \synt{statement}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If exp1 Then 
  If exp2 then 
    Stat1 
else 
  stat2;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If exp1 Then
   begin 
   If exp2 then 
      Stat1 
   else 
      stat2
   end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}{ NOT EQUIVALENT }
If exp1 Then
   begin 
   If exp2 then 
      Stat1 
   end
else 
   stat2
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}If Today in [Monday..Friday] then
  WriteLn ('Must work harder')
else
  WriteLn ('Take a day off.');
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{for\ statement} 
\lit*{for}
\synt{control\ variable}
\lit*{:=}
\synt{initial\ value}
\( 
  \lit*{to} \\ 
  \lit*{downto}
\)
\synt{final\ value}
\lit*{do}
\synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{control\ variable} \synt{variable\ identifier}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{initial\ value} \synt{expression}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{final\ value} \synt{expression}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}For Day := Monday to Friday do Work;
For I := 100 downto 1 do
  WriteLn ('Counting down : ',i);
For I := 1 to 7*dwarfs do KissDwarf(i); 
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{repeat\ statement}
\lit*{repeat}
\<[b] \synt{statement} \\  \lit* ; \>
\lit*{until}
\synt{expression}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}repeat
  WriteLn ('I =',i);
  I := I+2;
until I>100;

repeat
 X := X/2
until x<10e-3
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{while\ statement}
\lit*{while} \synt{expression} \lit*{do} \synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}I := I+2;
while i<=100 do
  begin
  WriteLn ('I =',i);
  I := I+2;
  end;

X := X/2;
while x>=10e-3 do
  X := X/2;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{with\ statement}
\<[b] \synt{variable\ reference} \\  \lit* , \>
\lit*{do}
\synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type Passenger = Record
       Name : String[30];
       Flight : String[10];
       end;

Var TheCustomer : Passenger;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}TheCustomer.Name := 'Michael';
TheCustomer.Flight := 'PS901';
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}With TheCustomer do
  begin
  Name := 'Michael';
  Flight := 'PS901';
  end;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}With A,B,C,D do Statement;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}With A do
 With B do
  With C do
   With D do Statement;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Program testw;

Type AR = record
      X,Y : Longint;
     end;
     
Var S,T : Ar;

begin
  S.X := 1;S.Y := 1;
  T.X := 2;T.Y := 2;
  With S,T do 
    WriteLn (X,' ',Y);
end.     
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{asm\ statement}
\lit*{asm}
\synt{assembler\ code}
\lit{end}
\begin{displaymath}
\synt{registerlist}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{registerlist}
\lit*[
\<[b] \synt{string constant} \\  \lit*, \>
\lit*]
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}asm
  Movl $1,Movl $0,addl end; ['EAX','EBX'];
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedure\ declaration}
\synt{procedure\ header} \lit* ;
\synt{subroutine\ block} \lit *;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedure\ header}
\lit*{procedure} 
\(
\synt{identifier}\\ 
\synt{qualified\ method\ identifier}
\)
\synt{formal\ parameter\ list}
\begin{displaymath} \synt{modifiers} \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{subroutine\ block}
\(
\synt{block}\\ 
\synt{external\ directive}\\ 
\synt{asm\ block}\\ 
\lit*{forward}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure DoSomething (Para : String);

begin
  Writeln ('Got parameter : ',Para);
  Writeln ('Parameter in upper case : ',Upper(Para));
end;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{function\ declaration}
\synt{function\ header} \lit* ;
\synt{subroutine\ block} \lit *;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{function\ header}
\lit*{function} 
\(
\synt{identifier}\\ 
\synt{qualified\ method\ identifier}
\)
\synt{formal\ parameter\ list}
\lit* : \( \synt{result\ type} \\  \lit*{string} \)
\begin{displaymath} \synt{modifiers} \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{subroutine\ block}
\(
\synt{block}\\ 
\synt{external\ directive}\\ 
\synt{asm\ block}\\ 
\lit*{forward}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{formal\ parameter\ list}
\lit*( \<[b] \synt{parameter\ declaration} \\  \lit* ; \> \lit*)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{parameter\ declaration}
\(
\synt{value\ parameter}\\ 
\synt{variable\ parameter}\\ 
\synt{constant\ parameter}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{value\ parameter}
\synt{identifier\ list} \lit*: 
\begin{displaymath} \lit*{array} \lit*{of} \end{displaymath}
\synt{parameter\ type}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{variable\ parameter}
\lit*{var} \synt{identifier\ list} 
\begin{displaymath}
\lit* :
\begin{displaymath}
\lit*{array}
\lit*{of}
\end{displaymath}
\synt{parameter\ type}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{constant\ parameter}
\lit*{const} \synt{identifier\ list} 
\begin{displaymath}
\lit* :
\begin{displaymath}
\lit*{array}
\lit*{of}
\end{displaymath}
\synt{parameter\ type}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}Row : Array of Integer;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Row : Array[1..N-1] of Integer;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Function Average (Row : Array of integer) : Real;

Var I : longint;
    Temp : Real;

begin
  Temp := Row[0];
  For I := 1 to High(Row) do 
    Temp := Temp + Row[i];
  Average := Temp / (High(Row)+1);
end;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}...
Dec(Var I : Longint;decrement : Longint);
Dec(Var I : Longint);
Dec(Var I : Byte;decrement : Longint);
Dec(Var I : Byte);
...
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}Program testforward;

Procedure First (n : longint); forward;

Procedure Second;
begin
  WriteLn ('In second. Calling first...');
  First (1);
end;

Procedure First (n : longint);
begin
  WriteLn ('First received : ',n);
end;

begin
  Second;
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Unit testforward;

interface

Procedure First (n : longint);
Procedure Second;

implementation

Procedure First (n : longint); forward;

Procedure Second;
begin
  WriteLn ('In second. Calling first...');
  First (1);
end;

Procedure First (n : longint);
begin
  WriteLn ('First received : ',n);
end;

end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{external\ directive}
\lit*{external}
\begin{displaymath}
  \synt{string\ constant}
  \begin{displaymath}
    \lit*{name} \synt{string\ constant}\\ 
    \lit*{index} \synt{integer\ constant}
  \end{displaymath}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}program CmodDemo;

{$Linklib c}

Const P : PChar = 'This is fun !';

Function strlen (P : PChar) : Longint; cdecl; external;

begin
  WriteLn ('Length of (',p,') : ',strlen(p))
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}external 'lname';
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}external 'lname' name Fname;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}external 'lname' Index Ind;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{asm\ block}
\lit*{assembler} \lit*;
\synt{declaration\ part}
\synt{asm\ statement}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{modifiers}
\<[b]
; 
 \( 
 \lit*{public} \\ 
 \lit*{alias} \synt{string\ constant}\\ 
 \lit*{interrupt} \\ 
 \lit*{call\ modifiers}
\)
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{call\ modifiers}
\(
\lit*{register}\\ 
\lit*{pascal}\\ 
\lit*{cdecl}\\ 
\lit*{stdcall}\\ 
\lit*{popstack}
\)
\end{syntdiag}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}Unit someunit;

interface

Function First : Real;

Implementation

Function First : Real;
begin
  First := 0;
end;

Function Second : Real; [Public];

begin
  Second := 1;
end;

end.
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}program CmodDemo;

{$LINKLIB c}

Const P : PChar = 'This is fun !';

Function strlen (P : PChar) : Longint; cdecl; external;

begin
  WriteLn ('Length of (',p,') : ',strlen(p))
end.
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}function DoSquare (X : Longint) : Longint; export;

begin
...
end;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}Program Aliases;

Procedure Printit; [Alias : 'DOIT'];

begin
  WriteLn ('In Printit (alias : "DOIT")');
end;

begin
  asm
  call DOIT
  end;
end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{program}
\synt{program\ header} 
\lit* ; 
\begin{displaymath} \synt{uses\ clause} \end{displaymath}
\synt{block}
\lit* .
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{program\ header}
\lit*{program} \synt{identifier}
\begin{displaymath} \lit* ( \synt{program\ parameters} \lit* )\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{program\ parameters} \synt{identifier\ list}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{uses\ clause}
\lit*{uses} \<[b] \synt{identifier} \\  \lit* , \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unit}
\synt{unit\ header}
\synt{interface\ part}
\synt{implementation\ part}
\begin{displaymath} \synt{initialization\ part} \end{displaymath}
\lit*{end} \lit* .
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{unit\ header} 
\lit*{unit}
\synt{unit\ identifier}
\lit* ;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{interface\ part} 
\<[b]
  \begin{displaymath}  \synt{constant\ declaration\ part} \\ 
      \synt{type\ declaration\ part}\\ 
      \synt{procedure\ headers\ part}
  \end{displaymath}
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedure\ headers\ part}
\( \synt{procedure\ header} \\  \synt{function\ header}\) \lit* ;
\begin{displaymath} \synt{call\ modifiers} \lit* ; \end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{implementation\ part}
\lit*{implementation}
\begin{displaymath} \synt{uses\ clause} \end{displaymath}
\synt{declaration\ part}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{initialization\ part}
  \lit*{begin} 
  \<[b] \synt{statement} \\  \lit* ; \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Unit UnitA;

interface

Uses UnitB;

implementation
end.

Unit UnitB

Uses UnitA;

implementation 
end.
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Unit UnitA;

interface

Uses UnitB;

implementation
end.

Unit UnitB

implementation 

Uses UnitA;

end.
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{block} \synt{declaration\ part} \synt{statement\ part}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{declaration\ part}
\<[b]
\begin{displaymath}
\synt{label\ declaration\ part}\\ 
\synt{constant\ declaration\ part}\\ 
\synt{type\ declaration\ part}\\ 
\synt{variable\ declaration\ part}\\ 
\synt{procedure/function\ declaration\ part}
\end{displaymath}
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{label\ declaration\ part}
\lit*{label}
\<[b]
\synt{label}\\ 
\lit* ,
\>
\lit* ;
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{constant\ declaration\ part}
\lit*{const}
\<[b]
  \(
    \synt{constant\ declaration}\\ 
    \synt{typed\ constant\ declaration}
  \)
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{type\ declaration\ part}
\lit*{type}
\<[b]
    \synt{type\ declaration}\\ 
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{variable\ declaration\ part}
\lit*{var}
\<[b]
    \synt{variable\ declaration}\\ 
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{procedure/function\ declaration\ part}
\<[b]
\(
    \synt{procedure\ declaration}\\ 
    \synt{function\ declaration}\\ 
    \synt{constructor\ declaration}\\ 
    \synt{destructor\ declaration}\\ 
\)
\>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{statement\ part}
\synt{compound\ statement}
\end{syntdiag}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}Program Demo;

Var X : Real;
{ X is real variable }
Procedure NewDeclaration

Var X : Integer;  { Redeclare X as integer}

begin
 // X := 1.234; {would give an error when trying to compile}
 X := 10; { Correct assigment}
end;

{ From here on, X is Real again}
begin
 X := 2.468;
end.
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}unit unitA;

interface
Type
  MyType = Real;

implementation
end.

Program prog;

Uses UnitA;
 
{ Redeclaration of MyType}
Type MyType = Integer;

Var A : Mytype;      { Will be Integer }
    B : UnitA.MyType { Will be real }

begin
end.
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy
\synt{raise\ statement}
\begin{displaymath}
  \synt{exception\ instance} 
  \begin{displaymath}
     \lit*{at} \synt{address\ expression}
  \end{displaymath}
\end{displaymath}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Type EDivException = Class(Exception);

Function DoDiv (X,Y : Longint) : Integer;

begin
  If Y=0 then 
    Raise EDivException.Create ('Division by Zero would occur');
  Result := X Div Y;
end;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{try\ statement}
\lit*{try}
\synt{statement\ list}
\lit*{except}
\synt{exception\ handling\ statements}
\lit*{end}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{statement\ list} 
\<[b] \synt{statement} \\  \lit*; \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{exception\ handling\ statements}
\(
\<[b] \synt{exception\ handler} \\  \lit*; \>
\begin{displaymath}
  \lit*{else} \synt{statement\ list}
\end{displaymath}
\synt{statement\ list}
\)
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\lit*{on} \begin{displaymath} \synt{identifier} \lit* : \end{displaymath} 
\synt{class\ type\ identifier}
\lit*{do}
\synt{statement}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Try
  Z := DoDiv (X,Y);
Except
  On EDivException do Z := 0;
end;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{try statement}
\lit*{try}
\synt{statement\ list}
\lit*{finally}
\synt{statement\ list}
\lit*{end}
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{syntdiag}\begin{tex2html_nowrap}\setlength{\sdmidskip}{.5em}\end{tex2html_nowrap}\sffamily\sloppy\synt{statement\ list}
\<[b] \synt{statement} \\  \lit*; \>
\end{syntdiag}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}Procedure Doit (Name : string);

Var F : Text;

begin
  Try
    Assign (F,Name);
    Rewrite (name);

    ... File handling ...

  Finally
    Close(F);
  end;  
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}Exception = class(TObject)
        private
          fmessage : string;
          fhelpcontext : longint;
        public
          constructor create(const msg : string);
          constructor createres(indent : longint);
          property helpcontext : longint read fhelpcontext write fhelpcontext;
          property message : string read fmessage write fmessage;
       end;

       ExceptClass = Class of Exception;

       { mathematical exceptions }
       EIntError = class(Exception);
       EDivByZero = class(EIntError);
       ERangeError = class(EIntError);
       EIntOverflow = class(EIntError);
       EMathError = class(Exception);
\end{listing}}\hbox{}\vfil

\stepcounter{chapter}
\stepcounter{section}
{\newpage\clearpage\samepage
\begin{listing}...
 Statements;
 ...
 Asm
   your asm code here
   ...
 end;
 ...
 Statements;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{part}
\stepcounter{chapter}
\stepcounter{section}
\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}shortint = -128..127;
Longint  = $80000000..$7fffffff;
integer  = -32768..32767;
byte     = 0..255;
word     = 0..65535;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}PChar = ^char;
  pPChar = ^PChar;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}jmp_buf = record
    ebx,esi,edi : Longint;
    bp,sp,pc : Pointer;
    end;
  PJmp_buf = ^jmp_buf;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}Const
  fmclosed = $D7B0;
  fminput  = $D7B1;
  fmoutput = $D7B2;
  fminout  = $D7B3;
  fmappend = $D7B4;

  filemode : byte = 2;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}const
  erroraddr : pointer = nil;
  errorcode : word = 0;
 { max level in dumping on error }
  max_frame_dump : word = 20;
\end{listing}}\hbox{}\vfil

\stepcounter{subsection}
{\newpage\clearpage\samepage
\begin{listing}var
  output,input,stderr : text;
  exitproc : pointer;
  exitcode : word;
  stackbottom : Longint;
  loweststack : Longint;
\end{listing}}\hbox{}\vfil

{\newpage\clearpage\samepage
\begin{listing}const
   seg0040 = $0040;
   segA000 = $A000;
   segB000 = $B000;
   segB800 = $B800;
\end{listing}}\hbox{}\vfil

\stepcounter{section}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{subsection}
\stepcounter{part}

\clearpage
\end{document}
