<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 3.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>Method invocation</TITLE>
<META NAME="description" CONTENT="Method invocation">
<META NAME="keywords" CONTENT="ref">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="ref.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html674" HREF="node28.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="file:/usr/lib/latex2html/icons/next_motif.gif"></A> <A NAME="tex2html672" HREF="node22.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="file:/usr/lib/latex2html/icons/up_motif.gif"></A> <A NAME="tex2html666" HREF="node26.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="file:/usr/lib/latex2html/icons/previous_motif.gif"></A> <A NAME="tex2html676" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="file:/usr/lib/latex2html/icons/contents_motif.gif"></A> <A NAME="tex2html677" HREF="node72.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="file:/usr/lib/latex2html/icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html675" HREF="node28.html">Visibility</A>
<B>Up:</B> <A NAME="tex2html673" HREF="node22.html">Objects</A>
<B> Previous:</B> <A NAME="tex2html667" HREF="node26.html">Methods</A>
<BR> <P>
<H1><A NAME="SECTION03450000000000000000">Method invocation</A></H1>
<P>
Methods are called just as normal procedures are called, only they have a 
object instance identifier prepended to them (see also chapter (<A HREF="node41.html#chStatements"><IMG  ALIGN=BOTTOM ALT="gif" SRC="file:/usr/lib/latex2html/icons/cross_ref_motif.gif"></A>)).
<P>
To determine which method is called, it is necessary to know the type of
the method. We treat the different types in what follows.
<P>
<H3><A NAME="SECTION03450100000000000000">Static methods</A></H3>
<P>
Static methods are methods that have been declared without a <tt>abstract</tt>
or <tt>virtual</tt> keyword. When calling a static method, the declared (i.e.
compile time) method of the object is used.
<P>
For example, consider the following declarations:
<BR><IMG WIDTH=576 HEIGHT=15 ALIGN=BOTTOM ALT="listing2102" SRC="img120.gif"><BR>
As it is visible, both the parent and child objects have a method called
<tt>Doit</tt>. Consider now the following declarations and calls:
<BR><IMG WIDTH=576 HEIGHT=113 ALIGN=BOTTOM ALT="listing2105" SRC="img121.gif"><BR>
Of the three invocations of <tt>Doit</tt>, only the last one will call
<tt>TChild.Doit</tt>, the other two calls will call <tt>TParent.Doit</tt>.
This is because for static methods, the compiler determines at compile 
time which method should be called. Since <tt>ParentB</tt> is of type
<tt>TParent</tt>, the compiler decides that it must be called with
<tt>TParent.Doit</tt>, even though it will be created as a <tt>TChild</tt>.
<P>
There may be times when you want the method that is actually called to
depend on the actual type of the object at run-time. If so, the method
cannot be a static method, but must be a virtual method.
<P>
<H3><A NAME="SECTION03450200000000000000">Virtual methods</A></H3>
<P>
To remedy the situation in the previous section, <tt>virtual</tt> methods are
created. This is simply done by appending the method declaration with the
<tt>virtual</tt> modifier.
<P>
Going back to the previous example, consider the following alternative
declaration:
<BR><IMG WIDTH=576 HEIGHT=13 ALIGN=BOTTOM ALT="listing2117" SRC="img122.gif"><BR>
As it is visible, both the parent and child objects have a method called
<tt>Draw</tt>. Consider now the following declarations and calls :
<BR><IMG WIDTH=576 HEIGHT=101 ALIGN=BOTTOM ALT="listing2120" SRC="img123.gif"><BR>
Now, different methods will be called, depending on the actual run-time type
of the object. For <tt>ParentA</tt>, nothing changes, since it is created as
a <tt>TParent</tt> instance. For <tt>Child</tt>, the situation also doesn't
change: it is again created as an instance of <tt>TChild</tt>.
<P>
For <tt>ParentB</tt> however, the situation does change: Even though it was
declared as a <tt>TParent</tt>, it is created as an instance of <tt>TChild</tt>.
Now, when the program runs, before calling <tt>Doit</tt>, the program
checks what the actual type of <tt>ParentB</tt> is, and only then decides which
method must be called. Seeing that <tt>ParentB</tt> is of type <tt>TChild</tt>,
<tt>TChild.Doit</tt> will be called.
<P>
The code for this run-time checking of the actual type of an object is
inserted by the compiler at compile time.
<P>
The <tt>TChild.Doit</tt> is said to <EM>override</EM> the <tt>TParent.Doit</tt>.
It is possible to acces the <tt>TParent.Doit</tt> from within the
varTChild.Doit, with the <tt>inherited</tt> keyword:
<BR><IMG WIDTH=576 HEIGHT=65 ALIGN=BOTTOM ALT="listing2140" SRC="img124.gif"><BR>
In the above example, when <tt>TChild.Doit</tt> is called, the first thing it
does is call <tt>TParent.Doit</tt>. You cannot use the inherited keyword on 
static methods, only on virtual methods.
<P>
<H3><A NAME="SECTION03450300000000000000">Abstract methods</A></H3>
<P>
An abstract method is a special kind of virtual method. A method can not be
abstract if it is not virtual (this is not obvious from the syntax diagram). 
You cannot create an instance of an object that has an abstract method. 
The reason is obvious: there is no method where the compiler could jump to !
<P>
A method that is declared <tt>abstract</tt> does not have an implementation for
this method. It is up to inherited objects to override and implement this 
method. Continuing our example, take a look at this:
<BR><IMG WIDTH=288 HEIGHT=54 ALIGN=BOTTOM ALT="listing2146" SRC="img125.gif"><BR>
As it is visible, both the parent and child objects have a method called
<tt>Draw</tt>. Consider now the following declarations and calls :
<BR><IMG WIDTH=576 HEIGHT=47 ALIGN=BOTTOM ALT="listing2149" SRC="img126.gif"><BR>
First of all, Line 4 will generate a compiler error, stating that you cannot
generate instances of objects with abstract methods: The compiler has
detected that <tt>PParent</tt> points to an object which has an abstract
method. Commenting line 4 would allow compilation of the program.
<P>
Remark that if you override an abstract method, you cannot call the parent
method with <tt>inherited</tt>, since there is no parent method; The compiler
will detect this, and complain about it, like this:
<PRE>testo.pp(32,3) Error: Abstract methods can't be called directly</PRE>
<P>
If, through some mechanism, an abstract method is called at run-time,
then a run-time error will occur. (run-time error 211, to be precise)
<P>
<HR><A NAME="tex2html674" HREF="node28.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="file:/usr/lib/latex2html/icons/next_motif.gif"></A> <A NAME="tex2html672" HREF="node22.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="file:/usr/lib/latex2html/icons/up_motif.gif"></A> <A NAME="tex2html666" HREF="node26.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="file:/usr/lib/latex2html/icons/previous_motif.gif"></A> <A NAME="tex2html676" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="file:/usr/lib/latex2html/icons/contents_motif.gif"></A> <A NAME="tex2html677" HREF="node72.html"><IMG WIDTH=43 HEIGHT=24 ALIGN=BOTTOM ALT="index" SRC="file:/usr/lib/latex2html/icons/index_motif.gif"></A> <BR>
<B> Next:</B> <A NAME="tex2html675" HREF="node28.html">Visibility</A>
<B>Up:</B> <A NAME="tex2html673" HREF="node22.html">Objects</A>
<B> Previous:</B> <A NAME="tex2html667" HREF="node26.html">Methods</A>
<P><ADDRESS>
<I>Michael Van Canneyt <BR>
Fri Sep 25 09:15:40 MEST 1998</I>
</ADDRESS>
</BODY>
</HTML>
