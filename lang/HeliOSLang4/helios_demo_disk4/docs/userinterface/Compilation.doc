
***************************************
Compiling and executing HeliOS programs
***************************************

HeliOS has a variety of compilation and execution functions.  Here we give
a short overview of these functions, and more information on the compilation
and execution of HelioS programs can be found in "StandAlonePrograms.doc".


*****************************************************
The HeliOS Interpreter has three modes of compilation
*****************************************************

Actually it would be more true to state that HeliOS has three modes of
saving, loading and running compiled HeliOS code.  The HeliOS Interpreter
menus have a "compile-mode" setting which determines which of the three
methods of generating compiled code files will be used.

The simplest mode of compilation is when the interpreter is used to
compile code into the dictionary for immediate use in the integrated
HeliOS environment.

Thus you can simply compile a program then test and run it etc.

The HeliOS Interpreter, once it has compiled some code, can then save out
the code in three different ways using a menu function called "PRESAVE".

Firstly, you can save (and reload) the current status of the HeliOS system,
which effectively allows you to compile, save, and reload current programs
from within the HeliOS interpreter.

HeliOS also allows you to save "overlay" files which consist of a block of
precompiled HeliOS code which can subsequently be run without the presence
of the main Interpreter program.  These overlay programs are executed by
using the separate HeliOS standalone execution program "HeliOS_exe".

Note that these modular overlays can also be generated using the standalone
HeliOS compiler program "HeliOS_cmp".

The main HeliOS Interpreter can also generate true single-file stand-alone
executable files.


***************
Executable size
***************

Effectively, whichever way you generate a HeliOS program, a typical HeliOS
stand-alone executable comes out at around 250k in size, which includes the
whole of the HeliOS support code.

This is obviously quite a large file size, but the files can be packed to
give a typical length of around 100k per single standalone HeliOS program.

The use of the overlay system, however, means that you can effectively use
just one standalone HeliOS "executive" program as a 100k "library", which is
used to run any number of tiny HeliOS code modules.

Note that the current version of the HeliOS execution software is not
re-entrant, so it cannot be used simultaneously by multiple programs.

HeliOS code modules are actually very compact indeed, with extremely large
programs taking less than 50k on average.

Using the stand-alone executive program you can have many tiny code modules
which are all run from the main executive, but you will always need at least
100k (packed) executable overhead to run a standalone HeliOS program.

Because of the very complex interlinking of many specialised functional
components within the internal structure of HeliOS, it is impossible to
change the system to generate small "selectively compiled" executables
while retaining the present system efficiency.  The only ways of partly
alleviating this situation involve radical design changes with certain
detrimental effects in other areas of performance.

We accept that this is one of the disadvantageous trade-offs of the HeliOS
language, but this has to be offset against the many advantages HeliOS has
over the languages like "C" which can selectively compile code.

Ultimately we believe that the many special advantages of HeliOS outweigh
the admitted disadvantage that HeliOS cannot generate stand-alone programs
very small in size.

Of course the executable size is really no problem at all from the point of
view of programming larger applications, but small programs generated from
HeliOS will always have an overly large 100k executable overhead.

Please let us know your opinions on this matter of executable file size,
and if it proves to be a major problem for a lot of users we will consider
options for changing to a more modular architecture which might offer a
partial solution to the problem.

****************************
Compilation versus execution
****************************

For those who aren't so sure about what this is all about, here is a very
simplistic discussion of the processes of compilation and code execution.

If you read the documentation on "Includes" you may still be unsure exactly
how speeds of compilation and execution are affected by various methods of
using symbolic values for numbers in your programs.

Beginners may be unclear as to the difference between the processes of
interpretation, compilation and execution, and even Forth "experts" will
not be aware of the unusual way in which HeliOS works internally.

This, briefly and simply, is what happens:


**************
Interpretation
**************

The HeliOS system reads your source code, or what you type at the command
line, and interprets its.  In other words it tries to understand it, and
if it cannot do so an error will obviously be reported.  It is here that
HeliOS can make use of the include files for symbol reference.


***********
Compilation
***********

Having "understood" the code, HeliOS proceeds to "compile" instructions for
the computer's CPU in a special internal format.  These special compiled
instructions are stored in an internal memory buffer of unlimited size.

The process of compilation has quite a lot of work to do as it generates
runnable units of code, and it also has to create a means of accessing this
code via further program instructions.  This is achieved using the HeliOS
"vocabulary" and "dictionary" lists.


**********
Vocabulary
**********

The "name" which you have associated with any particular function will be
stored in a special "quick-look-up" list called the "vocabulary", so that
HeliOS can respond when you use this name in future.  The vocabulary list
is stored separately and is only used by the interpreter.  When you create
a stand-alone program the vocabulary information is not necessary and so
is not included.  This differs from traditional Forth methods.


**********
Dictionary
**********

The HeliOS system uses an internal linkage table which associates
the ASCII vocabulary "names" with the appropriate compiled code.  This is
called the "dictionary", and is limited in size, so it is quite important
to conserve dictionary space.  The dictionary does NOT store the vocabulary
ASCII names themselves in HeliOS, nor does it store the execution code
or "body" of the HeliOS word.  Again, this is totally different from the
way traditional Forths were structured: it must be remembered that HeliOS
is radically different from other Forth-type languages in terms of internal
organisation.

Dictionary space should be conserved where possible, but HeliOS has
far fewer constraints than traditional Forth in this respect.  There is a
display of available dictionary space at all times in the HeliOS "status"
display, and you should always keep note of how this changes.

The dictionary in HeliOS is the nerve centre which organises all the other
elements of the system: rather like DNA it forms a compact encrypted
informational resource which defines how a program links together various
executable sub-units.  Dictionary space is used in proportion to how many
words you define, rather than by how long the words are, so you can create
HUGE programs which use relatively little dictionary space as long as each
of the program words does not use lots of tiny sub-word definitions.


*********
Execution
*********

Finally, you can "run" the program.  This is called "execution", and merely
involves the pre-compiled code being processed by the CPU.  This is a fast
process since all the hard work has been done during the compilation stage.

Please read "StandAlonePrograms.doc" for more information.

