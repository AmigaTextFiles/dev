<HTML>
<HEAD>
<TITLE>Jlint: java program checker</TITLE>

<UL>
<LI><A HREF = "#introduction">Introduction</A>
<LI><A HREF = "#antic.msg">Bugs detected by AntiC</A>

<UL>
<LI><A HREF = "#antic.scan.msg">Bugs in tokens</A>
<UL>
<LI><A HREF = "#antic.scan.octdig.msg">Octal digit expected</A>
<LI><A HREF = "#antic.scan.3dig.msg">May be more than three octal digits are specified</A>
<LI><A HREF = "#antic.scan.4dig.msg">May be more than four hex digits are specified for character constant</A></A>
<LI><A HREF = "#antic.scan.escape.msg">May be incorrect escape sequence</A>
<LI><A HREF = "#antic.scan.trigraph.msg">Trigraph sequence inside string</A>
<LI><A HREF = "#antic.scan.mbc.msg">Multibyte character constants are not portable</A>
<LI><A HREF = "#antic.scan.lsuf.msg">May be 'l' is used instead of '1' at the end of integer constant</A>
</UL>
<LI><A HREF = "#antic.pri.msg">Operators priorities</A>
<UL>
<LI><A HREF = "#antic.pri.susp.msg">May be wrong assumption about operators precedence</A>
<LI><A HREF = "#antic.pri.log.msg">May be wrong assumption about logical operators precedence</A>
<LI><A HREF = "#antic.pri.shift.msg">May be wrong assumption about shift operator priority</A>
<LI><A HREF = "#antic.pri.assign.msg">May be '=' used instead of '=='</A>
<LI><A HREF = "#antic.pri.assign.msg">May be skipped parentheses around assign operator</A>
<LI><A HREF = "#antic.pri.bitop.msg">May be wrong assumption about bit operation priority</A>
</UL>
<LI><A HREF = "#antic.body.msg">Statement body</A>
<UL>
<LI><A HREF = "#antic.body.loop.msg">May be wrong assumption about loop body</A>
<LI><A HREF = "#antic.body.if.msg">May be wrong assumption about IF body</A>
<LI><A HREF = "#antic.body.else.msg">May be wrong assumption about ELSE branch association</A>
<LI><A HREF = "#antic.body.switch.msg">Suspicious SWITCH without body</A>
<LI><A HREF = "#antic.body.case.msg">Suspicious CASE/DEFAULT</A>
<LI><A HREF = "#antic.body.break.msg">Possible miss of BREAK before CASE/DEFAULT</A>
</UL>
</UL>
<LI><A HREF = "#jlint.msg">Bugs detected by Jlint</A>
<UL>
<LI><A HREF = "#synchronization">Synchronization</A>
<UL>
<LI><A HREF="#deadlock.sync_loop">Loop <TT>id</TT>: invocation of synchronized method <TT>name</TT> can cause deadlock</A>
<LI><A HREF="#deadlock.loop">Loop <TT>LoopId/PathId</TT>: invocation of method <TT>name</TT> forms the loop in class dependency graph</A>
<LI><A HREF="#deadlock.wait">Method wait() can be invoked with monitor of other object locked</A>
<LI><A HREF="#deadlock.wait_path">Call sequence to method <TT>name</TT> can cause deadlock in wait()</A>
<LI><A HREF="#race_condition.nosync">Synchronized method <TT>name</TT> is overridden by non-synchronized method of derived class <TT>name</TT></A>
<LI><A HREF="#race_condition.concurrent_call">Method <TT>name</TT> can be called from different threads and is not synchronized</A>
<LI><A HREF="#race_condition.concurrent_access">Field <TT>name</TT> of class 
<TT>name</TT> can be accessed from different threads and is not volatile</A>
<LI><A HREF="#race_condition.run_nosync">Method <TT>name</TT> implementing 
'Runnable' interface is not synchronized</A>
<LI><A HREF="#wait_nosync.wait_nosync">Method <TT>name</TT> is called from 
non-synchronized method</A>
</UL>
<LI><A HREF="#inheritance">Inheritance</A>
<UL>
<LI><A HREF="#not_overridden.not_overridden">Method <TT>name</TT> is not overridden by method with the same name of derived class <TT>name</TT></A>
<LI><A HREF="#field_redefined.field_redefined">Component <TT>name</TT> in class <TT>name</TT> shadows one in base class <TT>name</TT></A>
<LI><A HREF="#shadow_local.shadow_local">Local variable <TT>name</TT> shadows 
component of class <TT>name</TT></A>
<LI><A HREF="#super_finalize.super_finalize">Method finalize() doesn't call 
super.finalize()</A>
</UL>
<LI><A HREF="#dataflow">Data flow</A>
<UL>
<LI><A HREF="#null_reference.null_param">Method <TT>name</TT> can be invoked 
with NULL as <TT>number</TT> parameter and this parameter is used without 
check for null</A>
<LI><A HREF="#null_reference.null_var">Value of referenced variable <TT>name</TT> may be NULL</A>
<LI><A HREF="#null_reference.null_ptr">NULL reference can be used</A>
<LI><A HREF="#zero_operand.zero_operand">Zero operand for operation</A>
<LI><A HREF="#zero_result.zero_result">Result of operation is always 0</A>
<LI><A HREF="#domain.shift_count">Shift with count <TT>relation</TT> than <TT>integer</TT></A>
<LI><A HREF="#domain.shift_range">Shift count range [<TT>min,max</TT>] 
is out of domain</A>
<LI><A HREF="#domain.conversion">Range of expression value has no intersection with <TT>target</TT> type domain</A>
<LI><A HREF="#truncation.truncation">Data can be lost as a result of truncation to <TT>type</TT></A>
<LI><A HREF="#overflow.overflow">May be type cast is not correctly applied</A>
<LI><A HREF="#redundant.same_result">Comparison always produces the same result</A>
<LI><A HREF="#redundant.disjoint_mask">Compared operands can be equal only when both of them are 0</A>
<LI><A HREF="#redundant.no_effect">Reminder always equal to the first operand</A>
<LI><A HREF="#short_char_cmp.short_char_cmp">Comparison of short with char</A>
<LI><A HREF="#string_cmp.string_cmp">Compare strings as object references</A>
<LI><A HREF="#weak_cmp.weak_cmp">Inequality comparison can be replaced with equality comparison</A>
<LI><A HREF="#incomp_case.incomp_case">Switch case constant <TT>integer</TT> can't be produced by switch expression</A>
<LI><A HREF="#bounds.neg_len">Array length <TT>[integer,integer]</TT> is less than zero</A>
<LI><A HREF="#bounds.maybe_neg_len">Array length <TT>[integer,integer]</TT> may be less than zero</A>
<LI><A HREF="#bounds.bad_index">Index <TT>[integer,integer]</TT> is out of array bounds</A>
<LI><A HREF="#bounds.maybe_bad_index">Index <TT>[integer,integer]</TT> may be out of array bounds</A>
</UL>
</UL>
<LI><A HREF = "#options">Command line options</A>
<UL>
<LI><A HREF = "#antic.opt">AntiC command line options</A>
<LI><A HREF = "#jlint.opt">Jlint command line options</A>
</UL>
<LI><A HREF = "#howto">How to build and use Jlint&AntiC</A>
<LI><A HREF = "#about">Release notes</A>
</UL>

<BODY>
<HR>
<H2><A NAME = "introduction">Introduction</A></H2>
Jlint will check your Java code and find bugs, inconsistencies
and synchronization problems by doing data flow analysis and building
lock graph.<P>

Jlint consists of two separate programs performing syntax and semantic 
verification. As far as Java mostly inherits C/C++ syntax and so 
inherits most of the problems caused by C syntax, the idea was
to create common syntax verifier for all C-family languages:
C, C++, Objective C and Java. This program was named <B><I>AntiC</I></B>,
because it fixes problems with C grammar, which can cause dangerous
programmer's bugs, undetected by compiler. By using hand-written scanner
and simple top-down parser, AntiC is able to detect such bugs as 
suspicious use of operators priorities, absence of break in switch 
code, wrong assumption about constructions bodies...<P>

Semantic verifier Jlint extracts information from Java class files. 
As far as Java class file has very well specified and simple format,
it greatly simplifies Jlint in comparison with source level verifiers, 
because development of Java grammar parser is not a simple task
(even through Java grammar is simpler and less ambiguous than C++ grammar).
Also dealing only with class files, protect Jlint from further Java extensions
(format of virtual byte instructions is more conservative). By using
debugging information Jlint can associate reported messages with Java sources.
<P>

Jlint performs local and global data flow analyses, calculating possible
values of local variables and catching redundant and suspicious
calculations. By performing global method invocation analysis, 
Jlint is able to detect invocation of method with possible "null"
value of formal parameter and using of this parameter in method
without check for "null". Jlint also builds lock dependency graph for classes 
dependencies and uses
this graph to detect situations, which can cause <I>deadlock</I> during 
multithreaded program execution. Except deadlocks, Jlint is able
to detect possible <I>race condition</I> problem, when different threads
can concurrently access the same variables.
Certainly Jlint can't catch all synchronization problems, but at least it
can do something, which can save you a lot of time, because 
synchronization bugs are the most dangerous bugs: non-deterministic,
and not always reproducible. Unfortunately Java compiler can't help
you with detecting synchronization bugs, may be Jlint can...<P>

Jlint uses smart approach to message reporting. All messages are 
grouped in categories, and it is possible to enable or disable reporting
messages of specific category as well as concrete messages. Jlint can remember
reported messages and do not report them once again when you run Jlint second
time. This feature is implemented by means of history file. If you 
specify <TT>-history</TT> option, then before reporting
a message, Jlint searches in this file if such message was already 
reported in the past. If so, then no message is reported and programmer will 
not have to spend time parsing the same messages several times. 
If message was not found in history file, it is reported and appended
to history file to eliminate reporting of this message in future.
Some messages refer to class/method name and are position independent,
while some messages are reported for specific statement in method's code.
Messages of second type will not be repeatedly reported only if
method's source is not changed.<P> 

<H2><A NAME = "antic.msg">Bugs detected by AntiC</A></H2>

Input of AntiC should be valid C/C++ or Java program with no syntax errors.
If there are some syntax errors in the program, AntiC can detect some of them
and produce error message, but it doesn't try to perform full syntax checking 
and can't recover after some errors. So in this chapter we discuss only the
messages produced by AntiC for program without syntax errors. 


<H3><A NAME = "antic.scan.msg">Bugs in tokens</A></H3>
<H4><A NAME = "antic.scan.octdig.msg">Octal digit expected</A></H4>
Sequence of digits in string or character constant preceded by '\\'
character contains non-octal digit:

<PRE>
     printf("\128");    
</PRE>

<H4><A NAME = "antic.scan.3dig.msg">May be more than three octal digits are specified</A></H4>
Sequence of digits in string or character constant preceded by '\\'
character contains more than three digits:

<PRE>  
    printf("\1234");    
</PRE>

<H4><A NAME = "antic.scan.4dig.msg">May be more than four hex digits are 
specified for character constant</A></H4>

String constant contains escape sequence for Unicode character, 
followed by character, which can be treated as hexadecimal digit:

<PRE>  
    System.out.println("\uABCDE:");     
</PRE>

<H4><A NAME = "antic.scan.escape.msg">May be incorrect escape sequence</A></H4>

Non-standard escape sequence is used in character or string constant:

<PRE>  
    printf("\x");       
</PRE>

<H4><A NAME = "antic.scan.trigraph.msg">Trigraph sequence inside string</A></H4>
Some C/C++ compilers still support trigraph sequences of ANSI C and replace
the following sequences of characters 
("??=", "??/", "??'", "??(", "??)", "??!", "??<", "??>") 
with the characters 
("#", "\", "^", "[", "]", "|", "{", "}") 
respectively. This feature may cause unexpected transformation of string 
constants:

<PRE> 
    char* p = "???=undefined";
</PRE>

<H4><A NAME = "antic.scan.mbc.msg">Multibyte character constants are not portable</A></H4>

Multibyte character constants are possible in C, but makes program non-portable.

<PRE> 
    char ch = 'ab';
</PRE>


<H4><A NAME = "antic.scan.lsuf.msg">May be 'l' is used instead of '1' at the end of integer constant</A></H4>

It is difficult to distinct lower case letter 'l' and digit '1'. As far as 
letter 'l' can be used as long modifier at the end of integer constant, 
it can be mixed with digit. It is better to use uppercase 'L':

<PRE>
    long l = 0x111111l;
</PRE>




<H3><A NAME = "antic.pri.msg">Operators priorities</A></H3>

<H4><A NAME = "antic.pri.susp.msg">May be wrong assumption about operators precedence</A></H4>

Several operators with non-intuitive clear precedence are used without
explicit grouping by parentheses. Sometimes programmer's assumption about 
operators priorities is not true, and in any case enclosing such operations in 
parentheses can only increase readability of program. Below is list of some
suspicious combinations of operators:

<PRE>
    x & y == z
    x && y & z
    x || y = z
</PRE>

<H4><A NAME = "antic.pri.log.msg">May be wrong assumption about logical 
operators precedence</A></H4>

Priority of logical AND operator is higher than priority of logical OR 
operator. So AND expression will be evaluated before OR expression even
if OR precedes AND:

<PRE>
    x || y && z 
</PRE>

<H4><A NAME = "antic.pri.shift.msg">May be wrong assumption about shift 
operator priority</A></H4>

Priority of shift is smaller than of arithmetic operators but less than 
of bit manipulation operators. It can cause wrong assumption about operands 
grouping:

<PRE>
    x>>y - 1
    x >> y&7
</PRE>

<H4><A NAME = "antic.pri.assign.msg">May be '=' used instead of '=='</A></H4>

Almost all C programmer did this bug, at least once in their life. 
It very easy to type '=' instead of '==' and not all C compilers
can detect this situation. Moreover this bug is inherited by Java:
the only restriction is that types of operands should be boolean:

<PRE>
    if (x = y) {}
</PRE>

<H4><A NAME = "antic.pri.assign.msg">May be skipped parentheses around assign operator</A></H4>

Assign operators have one of the smallest priorities. So if you want to test
result of assignment operation, you should enclose it in parentheses:

<PRE>
    if (x>>=1 != 0) {}
</PRE>

<H4><A NAME = "antic.pri.bitop.msg">May be wrong assumption about bit operation priority</A></H4>

Bit manipulation operators have smaller priority than compare operators.
If you, for example, extracting bits using bit AND operator, do not
forget to enclose it with parentheses, otherwise result of the expression
will be far from your expectation:

<PRE>
    if (x == y & 1) {}
</PRE>




<H3><A NAME = "antic.body.msg">Statement body</A></H3>

Almost all C statements can contain as its subpart either single statement or
block of statements (enclosed by braces). Unnoticed semicolon or wrong 
alignment can confuse programmer about real statement's body. 
And compiler can't produce any warnings, because it deals with stream of 
tokens, without information about code alignment.


<H4><A NAME = "antic.body.loop.msg">May be wrong assumption about loop body</A></H4>

This message is produced if loop body is not enclosed in braces and 
indentation of the statement following the loop is bigger than of loop
statement (i.e. it is shifted right):

<PRE>
while (x != 0) 
    x >>= 1;
    n += 1;
return x;
</PRE>

<H4><A NAME = "antic.body.if.msg">May be wrong assumption about IF body</A></H4>
This message is produced if IF body is not enclosed in braces and indentation 
of the statement following the IF construction is bigger than of IF 
statement itself (i.e. it is shifted right) or IF body is empty statement 
(';'):


<PRE>
    if (x > y);
    {
        int tmp = x;
        x = y;
        y = tmp; 
    }

    if (x != 0) 
        x = -x; sign = -1;
    sqr = x*x;
</PRE> 

<H4><A NAME = "antic.body.else.msg">May be wrong assumption about ELSE branch association</A></H4>

If there are no braces, then ELSE branch belongs to most inner IF. Sometimes 
programmers forget about it: 

<PRE>
    if (rc != 0) 
        if (perr) *perr = rc;
    else return Ok;
</PRE>

<H4><A NAME = "antic.body.switch.msg">Suspicious SWITCH without body</A></H4>

Switch statement body is not a block. With great probability it signals 
about some error in program:

<PRE>
    switch(j) { 
      case 1:
        ...
      case 2:
        switch(ch);  
        {
          case 'a':
          case 'b':
            ...
        }
    }
</PRE>

<H4><A NAME = "antic.body.case.msg">Suspicious CASE/DEFAULT</A></H4>

Case is found  in block not belonging to switch operator. Situations, 
where such possibility can be used are very rare:

<PRE>
    switch (n & 3) {
        do { 
            default:
                *dst++ = 0;
            case 3:
                *dst++ = *drc++;
            case 2:
                *dst++ = *drc++;
            case 1:
                *dst++ = *drc++;
        } while ((n -= 4) > 0;
    }
</PRE>

<H4><A NAME = "antic.body.break.msg">Possible miss of BREAK before CASE/DEFAULT
</A></H4>

AntiC performs some kind of control flow analysis to detect situations, where
control can be passed from one case branch to another (if programmer
forget about BREAK statement). Sometimes it is necessary to merge 
several branches. AntiC doesn't produce this message in following cases:

<OL>
<LI>Several cases point to the same statement:
<PRE>
    case '+':
    case '-':
      sign = 1;
      break;
</PRE>
<LI>Special <CODE>nobreak</CODE> macro is defined and used in switch statement:

<PRE>
    #define nobreak
    ...
    switch (cop) { 
      case sub:
        sp[-1] = -sp[1];
        nobreak;
      case add:
        sp[-2] += sp[-1]; 
        break;
        ...
}
</PRE>

<LI>Comment containing words "no break", "fall through" or "fall thru"
(spaces and case of latters are ignored) is placed before the case:

<PRE>
    switch (x) { 
      case do_some_extra_work:
        ...
        // fall thru
      case do_something:
        ...
    }
</PRE>
</OL>

In all other cases message is produced when control can be passed from
one switch branch to another:

<PRE>
    switch (action) { 
      case op_remove:
        do_remove(); 
      case op_insert:
        do_insert();
      case op_edit:
        do_edit();
    }
</PRE>



<H2><A NAME = "jlint.msg">Bugs detected by Jlint</A></H2>

There are three main groups of messages produced by Jlint:
<B><I>synchronization, inheritance</B></I> and <B><I>data flow</B></I>. 
These groups are distinguished by kind of analysis which is used
to detect problems, reported in this messages. Each group is in turn divided 
into several categories, which contains one or more messages. 
Such scheme of message classification is used to support
fine-grained selection of reported messages.<P>


<H3><A NAME = "synchronization">Synchronization</A></H3>

Parallel execution of several threads of control requires some 
synchronization mechanism to avoid access conflicts to shared data. 
Java approach to synchronization is based on using object monitors, controlled
by <CODE>synchronized</CODE> language construction. Monitor is always 
associated with object and prevents concurrent access to the object by using 
mutual exclusion strategy. Java also supports facilities for waiting and 
notification of some condition.<P>

Unfortunately, providing these synchronization primitives, Java compiler
and virtual machine are not able to detect or prevent synchronization problems.
Synchronization bugs are the most difficult bugs, because of non-deterministic
behavior of multithreaded program. There are two main sources of 
synchronization problems: deadlocks and race conditions.<P>

Situation in which one or more threads mutually lock each other is called 
deadlock. Usually the reason of deadlock is inconsistent order of 
resource locking by different threads. In Java case resources are object 
monitors and deadlock can be caused by some sequence of method invocations.
Let's look at the following example of multithreaded database server:

<PRE>
    class DatabaseServer { 
        public TransactionManager transMgr;
        public ClassManager       classMgr;
        ...
    }
    class TransactionManager { 
        protected DatabaseServer server;

        public synchronized void commitTransaction(ObjectDesc[] t_objects) {
            ...
            for (int i = 0; i < t_objects.length; i++) { 
                ClassDesc desc = server.classMgr.getClassInfo(t_objects[i]);
                ...
            }
            ...
        }
        ...
   }
   class ClassManager { 
        protected DatabaseServer server;
           
        public synchronized ClassDesc getClassInfo(ObjectDesc object) { 
            ...
        }
        public synchronized void addClass(ClassDesc desc) { 
            ObjectDesc t_objects;
            ...
            // Organized transaction to insert new class in database
            server.transMgr.commit_transaction(t_objects);
        }
    };
</PRE> 

If database server has one thread for each client and one client is committing
transaction while another client adds new class to database, then deadlock
can arise. Consider the following sequence:<P>

<OL>
<LI>Client A invokes method <CODE>TransactionManager.commitTransaction()</CODE>. 
While execution of this method monitor of TransactionManager object is locked.

<LI>Client B invokes method <CODE>ClassManager.addClass()</CODE> and
locks monitor of ClassManager object.

<LI>Method <CODE>TransactionManager.commitTransaction()</CODE> tries to invoke
method <CODE>ClassManager.getClassInfo()</CODE> but has to wait because this 
object is locked by another thread.

<LI>Method <CODE>ClassManager.addClass()</CODE> tries to invoke
method <CODE>TransactionManager.commitTransaction()</CODE> but has to wait 
because this object is locked by another thread.
</OL><P>

So we have deadlock and database server is halted and can't serve any client.
The reason of this deadlock is loop in locking graph. Let's explain it less 
formally. We will construct oriented graph G of monitor lock relations.
As far as locked resource are objects, so vertexes of this graph should be 
objects. But this analysis can't be done statically, because set of all object
instances is not known at compile time. So the only kind
of analysis, which Jlint is able to perform, is analysis of interclass
dependencies. So the vertexes of graph G will be classes. More precisely, 
each class C is represented by two vertexes: vertex C for class itself and 
vertex C' for metaclass. First kind of vertexes are used for dependencies
caused by instance methods invocation, and second - by static methods.
We will add edge (A,B) with mark "foo" to the graph if some synchronized 
method  <CODE>foo()</CODE> of class B, can be invoked directly or indirectly 
from  some synchronized method of class A for object other than 
<CODE>this</CODE>.
For example for the following classes:

<PRE>
    class A {
        public synchronized void f1(B b) { 
            b.g1();
            f1();
            f2();
        }
        public void f2(B b) { 
            b.g2();
        }
        public static synchronized void f3() { 
            B.g3();
        }
    }        
    class B { 
        public static A ap;
        public static B bp;
        public synchronized void g1() { 
            bp.g1();
        }
        public synchronized void g2() { 
            ap.f1();
        } 
        public static synchronized void g3() { 
            g3();
        }
    }
</PRE>


will add the following edges: 

<PRE>
      g1
A  --------> B,  because of invocation of b.g1() from A.f1() 

      g2
A  --------> B,  because of following call sequence: A.f1 -> A.f2 -> B.g2 

      g3
A' --------> B', because of invocation of b.g3() from A.f3() 

      g1
B  --------> B,  loop edge because of recursive call for non-this object in B.g1(). 

      f1
B  --------> A,  because of invocation of ap.f1() from B.g2()
</PRE>

Deadlock is possible only if there is loop in graph G. This condition is 
necessary, but not enough (presence of loop in graph G doesn't mean that
program is not correct and deadlock can happen during it's execution). 
So using this criterion Jlint can produce messages about deadlock probability 
in case where deadlock is not possible.<P>

As far as task of finding all loops in the graph belongs to the NP class, 
no efficient algorithm for reporting all such loops exists at this moment.
To do it work best and fast, Jlint uses restriction for number of loops, which 
pass through some graph vertex.<P>

There is another source of deadlock - execution of <CODE>wait()</CODE> method.
This method unlocks monitor of current object and waits until some other thread
notify it. Both methods <CODE>wait()</CODE> and <CODE>notify()</CODE>
should be called with monitor locked. When thread is awaken from wait state,
it tries to reestablish monitor lock and only after it can continue 
execution. The problem with <CODE>wait()</CODE> is that only one monitor is 
unlocked. If method executing <CODE>wait()</CODE> was invoked from synchronized
method of some other object O, monitor of this object O will not be released by
<CODE>wait</CODE>. If thread, which should notify sleeping thread, needs to
invoke some synchronized method of object O, we will have deadlock:
one thread is sleeping and thread, which can awoke it, waits until monitor
will be unlocked. Jlint is able to detect situations when <CODE>wait()</CODE>
method is called and more than one monitors are locked.<P>

But deadlock is not the only synchronization problem. Race condition or 
concurrent access to the same data is more serious problem. 
Let's look at the following class:

<PRE>
    class Account { 
        protected int balance; 
    
        public boolean get(int sum) {
            if (sum > balance) { 
                balance -= sum;
                return true;
            }
            return false;
        }
    }
</PRE>

What will happen if several threads are trying to get money from the same 
account? For example account balance is $100. First thread tries to get 
$100 from the account - check is ok. Then, before first thread can update
account balance, second thread tries to perform the same operation.
Check is ok again! This situation is called <I>race condition</I>,
because result depends on "speed" of threads execution.<P>

How can Jlint detect such situations? First of all Jlint builds
closure of all methods, which can be executed concurrently. The obvious 
candidates are synchronized methods and method <CODE>run</CODE> of classes
implemented <CODE>Runnable</CODE> protocol or inherited from 
<CODE>Thread</CODE> class. Then all other methods, which can be invoked from 
these methods, are marked as concurrent. This process repeats until no
more method can be added to concurrent closure. Jlint produces message
about non-synchronized access only if all of the following conditions
are true:<P>

<OL>
<LI>Method accessing field is marked as concurrent.
<LI>Field is not declared as <CODE>volatile</CODE> or <CODE>final</CODE>. 
<LI>Field doesn't belong to <CODE>this</CODE> object of the method.
<LI>It is not a field of just created object, which is accessed through local
variable.
<LI>Field can be accessed from methods of different classes.
</OL><P>
  
It is necessary to explain last two items. When object is created and 
initialized, usually only one thread can access this object through 
its local variables. So synchronization is not needed in this case.
The explanation of item 5 is that not all objects, which are accessed by 
concurrent threads, need to be synchronized (and can't be declared as
synchronized in some cases to avoid deadlocks). 
For example consider implementation of database set:

<PRE>
    class SetMember { 
        public SetMember next;
        public SetMember prev;
    }
    class SetOwner { 
        protected SetMember first;
        protected Setmember last;

        public synchronized void add_first(SetMember mbr) { 
            if (first == null) { 
                first = last = mbr;
                mbr.next = mbr.prev = null;
            } else { 
                mbr.next = first;
                mbr.prev = null;
                first.prev = mbr;
                first = mbr;
            }
        }
        public synchronized void add_last(SetMember mbr) {...}
        public synchronized void remove(SetMember mbr) {...}
    };
</PRE>

In this example <CODE>next</CODE> and <CODE>prev</CODE> components
of class <CODE>SetMemeber</CODE> can be accessed only from synchronized
methods of <CODE>SetOwner</CODE> class, so no access conflict is possible.
Rule 5 was included to avoid reporting of messages in situations like this.<P>

Rules for detecting synchronization conflicts by Jlint are not finally
defined, some of them can be refused or replaced, new candidates can be 
added. The main idea is to detect as much suspicious places as possible, while
not producing confusing messages for correct code.<P>


<H4><A NAME="deadlock.sync_loop">Loop <TT>id</TT>: invocation of synchronized method <TT>name</TT> can cause deadlock</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>deadlock</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>sync_loop</B></TD></TR>
</TABLE><P>

Loop in class graph G (see <A HREF="#synchronization">Synchronization</A>) is
detected. One such message is produced for each edge of the loop.
All loops are assigned unique identifier, so it is possible to 
distinguish messages for edges of one loop from another.


<H4><A NAME="deadlock.loop">Loop <TT>LoopId/PathId</TT>: invocation of method <TT>name</TT> forms the loop in class dependency graph</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>deadlock</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>loop</B></TD></TR>
</TABLE><P>

Reported invocation is used in call sequence from synchronized method of class
A to synchronized method <CODE>foo()</CODE> of class B, 
so that edge (A,B) is in class graph G 
(see <A HREF="#synchronization">Synchronization</A>). 
If method <CODE>foo()</CODE> is invoked directly, then only previous message
(sync_loop) is reported. But if call sequence includes some other invocations
(except invocation of <CODE>foo()</CODE>), then this message is produced for 
each element of call sequence. If several call paths exist for classes A, B
and method <CODE>foo()</CODE>, then all of them (but not more than specified
by <CODE>MaxShownPaths</CODE> parameter) are printed. <TT>PathId</TT> 
identifier is used to group messages for each path.<P>


<H4><A NAME="deadlock.wait">Method wait() can be invoked with monitor of other object locked</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>deadlock</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>wait</B></TD></TR>
</TABLE><P>

At the moment of <CODE>wait()</CODE> method invocations, more than one monitor
objects are locked by the thread. As far as wait unlocks only one monitor, 
it can be a reason of deadlock. 
Successive messages of type <B>wait_path</B> specify
call sequence, which leads to this invocation.
Monitors can be locked by invocation of synchronized method or by
explicit synchronized construction. Jlint handle both of the cases.<P>


<H4><A NAME="deadlock.wait_path">Call sequence to method <TT>name</TT> can cause deadlock in wait()</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>deadlock</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>wait_path</B></TD></TR>
</TABLE><P>

By the sequence of such messages Jlint informs about possible invocation chain,
which locks at least two object monitors and is terminated by method
calling <CODE>wait()</CODE>. As far as <CODE>wait()</CODE> unlocks only one 
monitor and suspend thread, this can cause deadlock.<P>


<H4><A NAME="race_condition.nosync">Synchronized method <TT>name</TT> is overridden by non-synchronized method of derived class <TT>name</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>race_condition</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>nosync</B></TD></TR>
</TABLE><P>

Method is declared as synchronized in base class, but is overridden in derived
class by non-synchronized method. It is not a bug, but suspicious place, 
because if base method is declared as synchronized, then it is expected that
this method can be called from concurrent threads and access some critical 
data. Usually the same is true for derived method, so disappearance of 
synchronized modifier looks suspiciously.<P> 

<H4><A NAME="race_condition.concurrent_call">Method <TT>name</TT> can be called from different threads and is not synchronized</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>race_condition</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>concurrent_call</B></TD></TR>
</TABLE><P>

Non-synchronized method is invoked from method marked as concurrent for
object other than <CODE>this</CODE> (for instance methods) or for class,
which is not base class of caller method class (for static methods). 
This message is reported only if invocation is not enclosed in synchronized 
construction and this method also can be invoked from methods of other classes.
<P>

<H4><A NAME="race_condition.concurrent_access">Field <TT>name</TT> of class 
<TT>name</TT> can be accessed from different threads and is not volatile</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>race_condition</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>concurrent_access</B></TD></TR>
</TABLE><P>

Field is accessed from method marked as concurrent. 
This message is produced only if:<P>

<OL>
<LI>Field belongs to the object other than 
<CODE>this</CODE> (for instance methods) or to classes which are not base for 
class of static method.
<LI>Field is not component of object previously created by <CODE>new</CODE>
and assigned to local variable.
<LI>Field is not marked as volatile or final.
<LI>Field can be accessed from methods of different classes.
</OL><P>

<H4><A NAME="race_condition.run_nosync">Method <TT>name</TT> implementing 
'Runnable' interface is not synchronized</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>race_condition</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>run_nosync</B></TD></TR>
</TABLE><P>

Method <CODE>run()</CODE> of class implementing <CODE>Runnable</CODE> interface
is not declared as synchronized. As far as different threads can be started
for the same object implementing <CODE>Runnable</CODE> interface, method
<CODE>run</CODE> can be executed concurrently and is first candidate
for synchronization.<P>

<H4><A NAME="wait_nosync.wait_nosync">Method <TT>name</TT> is called from 
non-synchronized method</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>wait_nosync</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>wait_nosync</B></TD></TR>
</TABLE><P>

Method <CODE>wait()</CODE> or <CODE>notify()</CODE> is invoked from method, 
which is not declared as synchronized. It is not surely a bug, because
monitor can be locked from other method, which directly or indirectly
invokes current method. But you should agree that it is not common case.<P> 


<H3><A NAME="inheritance">Inheritance</A></H3>

This group contains messages, 
which are caused by problems with class inheritance: such
as mismatch of methods profiles, components shadowing... As far as Jlint
deals with Java class file and there is no information about line number
in source file of class, field or method definition, Jlint can't show
proper place in source file where class, field or method, which cause the 
problem, is located. In case of methods, Jlint points to the line corresponds 
to the first instruction of the method. And for classes and fields, Jlint 
always refers in message to the first line in source file. Jlint assign
successive number (starting from 1) for all such message reported sequentially,
because Emacs skips all messages, reported for the same line, when you go to 
next message.<P>

<H4><A NAME="not_overridden.not_overridden">Method <TT>name</TT> is not overridden by method with the same name of derived class <TT>name</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>not_overridden</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>not_overridden</B></TD></TR>
</TABLE><P>

Derived class contains the method with the same name as in base class, but
profiles of these methods do not match. More precisely: message is 
reported when for some method of class A, exists
method with the same name in derived class B, but there is no method with
the same name in class B, which is compatible with definition of the method 
in class A (with the same number and types of parameters). 
Programmer writing this code may 
erroneously expect that method in derived class overrides method in base 
class and that virtual call of method of base class for object of derived 
class will cause execution method of the derived class.<P>


<H4><A NAME="field_redefined.field_redefined">Component <TT>name</TT> in class <TT>name</TT> shadows one in base class <TT>name</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>field_redefined</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>field_redefined</B></TD></TR>
</TABLE><P>

Field in derived class has the same name as field of some of base classes.
It can cause some problems because this two fields points to different 
locations and methods of base class will access one field, while methods
of derived class (and classes derived from it) will access another field. 
Sometimes it is what programmer expected, but in any case it will not
improve readability of program. <P>

<H4><A NAME="shadow_local.shadow_local">Local variable <TT>name</TT> shadows 
component of class <TT>name</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>shadow_local</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>shadow_local</B></TD></TR>
</TABLE><P>

Local variable of method shadows class component with the same name. 
As far as it is common practice in constructors to use formal parameters
with the same name as class components, Jlint detects situations, when
class field is explicitly accessed by using <CODE>this</CODE>
reference and doesn't report this message in this case:

<PRE>
    class A { 
        public int a;
        public void f(int a) { 
            this.a = a; // no message
        }
        public int g(int a) { 
            return a; // message "shadow_local" will be reported
        }
    }
</PRE><P>
            

<H4><A NAME="super_finalize.super_finalize">Method finalize() doesn't call 
super.finalize()</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>super_finalize</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>super_finalize</B></TD></TR>
</TABLE><P>

As it is mentioned in book "The Java Programming Language" by Ken Arnold
and James Gosling, calling of <CODE>super.finalize()</CODE> from 
<CODE>finalize()</CODE> is good practice of programming, 
even if base class doesn't define <CODE>finalize()</CODE> method. 
This makes class implementations less dependent from each other.<P>


<H3><A NAME="dataflow">Data flow</A></H3>

Jlint performs data flow analysis of Java byte code, calculating
possible ranges of values of expressions and local variables. 
For integer types, Jlint calculates minimal and maximal value of expression 
and mask of possibly set bits. For object variables attribute 
<CODE>null/not_null</CODE> is calculated, selecting variables which value can 
be <CODE>null</CODE>.
When value of expression is assigned to variable, 
these characteristics are copied to correspondent variable descriptor. 
Jlint handles control transfer instruction in special way: saving,
modifying, merging or restoring context depending on type of instruction.
Context in this consists of local variables states (minimal, maximal 
values and mask) and state of top of the stack (for handling ?: instruction).
Initially all local integer variable are considered to have minimum and maximum
properties equal to the range of correspondent type, and mask indicating
that all bits in this range can be set. Object variables attribute initially
is set to <CODE>not_null</CODE>. The same characteristics are always used
for class components, because Jlint is not able to perform full data flow
analysis (except checking for passing null value to formal parameter of 
methods). 
Table below summarizes actions performed by Jlint for handling 
control transfer instruction:<P>

<TABLE BORDER>
<TR>
<TH>Instruction type</TH> 
<TH>Correspondent Java construction</TH>
<TH>Action</TH></TR>
<TR>
<TD>Forward conditional jump</TD>
<TD>IF statement</TD>
<TD>Save current context. Modify current context in assumption that
condition is false (no jump). Modify saved context
in assumption that condition is true (jump takes place)</TD>
</TR>

<TR>
<TD>Forward unconditional jump</TD>
<TD>Start of loop, jump around ELSE branch of IF</TD>
<TD>Save current context</TD>
</TR>

<TD>Backward conditional jump</TD>
<TD>Loop statement condition</TD>
<TD>Modify context in assumption that condition is false (no jump)</TD>
</TR>

<TR>
<TD>Backward unconditional jump</TD>
<TD>Infinite loop</TD>
<TD>Do nothing</TD>
</TR>

<TR>
<TD>Label of forward jump</TD>
<TD>End of IF body or SWITCH case</TD>
<TD>If previous instruction is no-pass instruction (return, 
unconditional jump, throw exception) then restore saved context, 
otherwise merge current context with saved context (set minimum
property of integer variable to minimum of this property value 
in current and saved contexts, maximum - to maximum of
values in two contexts, and mask as join of masks in two context;
for object variable - mark it as "may contain null" if it is marked so
in one of contexts). If label corresponds to switch statement case,
and switch expression is single local variable, then update
properties of this variable by setting its minimum and maximum values 
and mask to value of case selector.</TD>
</TR>

<TR>
<TD>Label of backward jump</TD>
<TD>Start of loop body</TD>
<TD>Reset properties of all variables modified between this label
and backward jump instructions. Reset for integer variables means
setting minimum property to minimum value of correspondent type, ...
Reset for object variable clears mark "may contain null".</TD>
</TR>
</TABLE><P>


<H4><A NAME="null_reference.null_param">Method <TT>name</TT> can be invoked 
with NULL as <TT>number</TT> parameter and this parameter is used without 
check for null</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>null_reference</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>null_param</B></TD></TR>
</TABLE><P>

Formal parameter is used in the method without check for null
(component of object is accessed or method of this object is invoked), while
this method can be invoked with null as the value of this parameter (detected
by global data flow analysis). Example:

<PRE>
    class Node { 
        protected Node next;
        protected Node prev;
        public void link(Node after) { 
            next = after.next; // Value of 'after' parameter can be null
            prev = after;
            after.next = next.prev = this;
        }
    }
    class Container { 
        public void insert(String key) { 
            Node after = find(key);
            if (after == null) { 
                add(key);
            }   
            Node n = new Node(key);
            n.link(after); // after can be null
        }
    }
</PRE>

<H4><A NAME="null_reference.null_var">Value of referenced variable 
<TT>name</TT> may be NULL</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>null_reference</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>null_var</B></TD></TR>
</TABLE><P>

Variable is used in the method without check for null. 
Jlint detects that referenced variable was previously assigned 
<CODE>null</CODE> value or was found to be <CODE>null</CODE> in one of 
control paths in the method.<P>

Jlint can produce this message in some situations, when value of variable
can not actually be null:

<PRE>
    public int[] create1nVector(int n) { 
        int[] v = null;
        if (n > 0) { 
            v = new int[n];
        }
        for (int i = 0; i &lt; n; i++) { 
            v[i] = i+1; // message will be reported
        }
        return v;
    }
</PRE>


<H4><A NAME="null_reference.null_ptr">NULL reference can be used</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>null_reference</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>null_ptr</B></TD></TR>
</TABLE><P>

Constant <CODE>null</CODE> is used as left operand of '.' operation:

<PRE>
    public void printMessage(String msg) { 
        (msg != null ? new Message(msg) : null).Print();
    }
</PRE>



<H4><A NAME="zero_operand.zero_operand">Zero operand for operation</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>zero_operand</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>zero_operand</B></TD></TR>
</TABLE><P>

One of operands of binary operation is zero. 
This message can be produced for sequence of code like this:

<PRE>
    int x = 0;
    x += y;
</PRE>

<H4><A NAME="zero_result.zero_result">Result of operation is always 0</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>zero_result</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>zero_result</B></TD></TR>
</TABLE><P>

Jlint detects that for given operands, operation always produces zero
result. This can be caused by overflow for arithmetic operations or
by shifting all significant bits in shift operations or clearing all
bits by bit AND operation.<P>

<H4><A NAME="domain.shift_count">Shift with count <TT>relation</TT> than <TT>integer</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>domain</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>shift_count</B></TD></TR>
</TABLE><P>

This message is reported when minimal value of shift count operand exceeds
31 for int type and 63 for long type or maximal value of shift count operand 
is less than 0:

<PRE>
    if (x > 32) { 
        y >>= x; // Shift right with count greater than 32
    }
</PRE>

<H4><A NAME="domain.shift_range">Shift count range [<TT>min,max</TT>] 
is out of domain</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>domain</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>shift_count</B></TD></TR>
</TABLE><P>

Range of shift count operand is not within [0,31] for int type or
[0,63] for long type. Jlint doesn't produce this message when
distance between maximum and minimum values of shift count is greater than 255.
So this message will not be reported if shift count is just variable
of integer type:

<PRE>
    public int foo(int x, int y) { 
        x >>= y; // no message
        x >>= 32 - (y & 31); // range of count is [1,32]
    }
</PRE> 
    

<H4><A NAME="domain.conversion">Range of expression value has no intersection with <TT>target</TT> type domain</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>domain</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>conversion</B></TD></TR>
</TABLE><P>

Converted value is out of range of target type. This message can be reported 
not only for explicit conversions, but also for implicit conversions 
generated by compiler:

<PRE>
    int x = 100000;
    short s = x; // will cause this message
</PRE>




<H4><A NAME="truncation.truncation">Data can be lost as a result of truncation to <TT>type</TT></A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>truncation</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>truncation</B></TD></TR>
</TABLE><P>

This message is reported when significant bits can be lost as a result
of conversion from large integer type to smaller. Such conversions are 
always explicitly specified by programmer, so Jlint tries to reduce number of 
reported messages caused by data truncation. Example below shows when Jlint
produces this message and when not:

<PRE>
    public void foo(int x, long y) { 
        short s = (short)x; // no message
        char  c = (char)x;  // no message
        byte  b = (byte)y;  // no message
        b = (byte)(x & 0xff); // no message
        b = (byte)c; // no message
        c = (x & 0xffff); // no message
        x = (int)(y >>> 32); // no message


        b = (byte)(x >> 24);     // truncation
        s = (int)(x & 0xffff00); // truncation
        x = (int)(y >>> 1);      // truncation 
        s = (short)c;            // truncation 
    }
</PRE>


<H4><A NAME="overflow.overflow">May be type cast is not correctly applied</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>overflow</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>overflow</B></TD></TR>
</TABLE><P>

Result of operation, which has good chance to cause overflow 
(multiplication, left shift), is converted to long. As far as operation is performed with <CODE>int</CODE> operands, overflow can happen before conversion.
Overflow can be avoided by conversion of one of operation operands to long, 
so operation will be performed with <CODE>long</CODE> operands.
This message is produced not only for explicit type conversion done by 
programmer, but also for implicit type conversions performed by compiler:

<PRE>
    public long multiply(int a, int b) { 
        return a*b; // operands are multiplied as integers 
                    // and then result will be converted to long
    }
</PRE>


<H4><A NAME="redundant.same_result">Comparison always produces the same result</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>redundant</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>same_result</B></TD></TR>
</TABLE><P>

Using information about possible ranges of operands values, Jlint can
make a conclusion, that logical expression is always evaluated to the
same value (<CODE>true</CODE> or <CODE>false</CODE>):

<PRE>
     public void foo(int x) { 
         if (x > 0) { 
             ...
             if (x == 0) // always false
             {
             }
         }
     }
</PRE>  

<H4><A NAME="redundant.disjoint_mask">Compared operands can be equal only when both of them are 0</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>redundant</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>disjoint_mask</B></TD></TR>
</TABLE><P>

By comparing operands masks, Jlint makes a conclusion that 
operands of <CODE>==</CODE> or <CODE>!=</CODE> operations can be equal 
only when both of them are zero:

<PRE>
    public boolean foo(int x, int y) { 
        return ((x & 1) == y*2); // will be true only for x=y=0 
    }
</PRE>    


<H4><A NAME="redundant.no_effect">Reminder always equal to the first operand</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>redundant</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>redundant</B></TD></TR>
</TABLE><P>

This message is produced for <CODE>%</CODE> operation when right operand
is either greater either less than zero, and absolute value of left operand
is less than absolute value of right operand. In this case 
<CODE>x % y == x</CODE> or <CODE>x % y == -x</CODE>.<P>


<H4><A NAME="short_char_cmp.short_char_cmp">Comparison of short with char</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>short_char_cmp</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>short_char_cmp</B></TD></TR>
</TABLE><P>

Comparison of <CODE>short</CODE> operand with <CODE>char</CODE> operand.
As far as <CODE>char</CODE> type is unsigned, and is converted to 
<CODE>int</CODE> by filling high half of the word with 0, and 
<CODE>short</CODE> type is signed and is converted to <CODE>int</CODE> 
using sign extension, then symbols in range <CODE>0x8000...0xFFFF</CODE>
will not be considered equal in such comparison:

<PRE>
     boolean cmp() { 
        short s = (short)0xabcd;
        char c = (char)s;
        return (c == s); // false
     }
</PRE>


<H4><A NAME="string_cmp.string_cmp">Compare strings as object references</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>string_cmp</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>string_cmp</B></TD></TR>
</TABLE><P>

String operands are compared by <CODE>==</CODE> or <CODE>!=</CODE> operator.
As far as <CODE>==</CODE> returns <CODE>true</CODE> only if operands
point to the same object, so it can return false for two strings with same 
contents. The following function will return <CODE>false</CODE>
in JDK1.1.5:

<PRE>
    public boolean bug() {
        return Integer.toString(1) == Integer.toString(1);
    }
</PRE>


<H4><A NAME="weak_cmp.weak_cmp">Inequality comparison can be replaced with equality comparison</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>weak_cmp</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>weak_cmp</B></TD></TR>
</TABLE><P>

This message is produced in situations when ranges of compared operands
intersect only in one point. So inequality comparison can be replaced
with equality comparison. Such message can be caused by error in program,
when programmer has wrong assumption about ranges of compared operands.
But even if this inequality comparison is correct, replacing it with
equality comparison can make code more clear:

<PRE>
    public void foo(char c, int i) { 
        if (c &lt;= 0) { // is it a bug ?
            if ((i & 1) > 0) { // can be replaced with (i & 1) != 0
                ...
            } 
        }  
    }
</PRE>


<H4><A NAME="incomp_case.incomp_case">Switch case constant <TT>integer</TT> can't be produced by switch expression</A></H4>


<TABLE> 
<TR><TD>Message category:</TD> <TD><B>incomp_case</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>incomp_case</B></TD></TR>
</TABLE><P>

Constant in switch case is out of range of switch expression or
has incompatible bit mask with switch expression:

<PRE>
    public void select(char ch, int i) { 
        switch (ch) { 
          case 1:          
          case 2:          
          case 3:          
            ...
          case 256: // constant is out of range of switch expression
        }
        switch (i & ~1) { 
          case 0:  
          case 0xabcde:  
            ...
          case 1: // switch expression is always even
        }
    }
</PRE>
   

<H4><A NAME="bounds.neg_len">Array length <TT>[integer,integer]</TT> is less than zero</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>bounds</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>neg_len</B></TD></TR>
</TABLE><P>

Array with negative length is created. 

<PRE>
    int len = -1;
    char[] a = new char[len]; // negative array length
</PRE>


<H4><A NAME="bounds.maybe_neg_len">Array length <TT>[integer,integer]</TT> may be less than zero</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>bounds</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>maybe_neg_len</B></TD></TR>
</TABLE><P>

Range of length expression of created array contains negative values.
So it is possible that length of created array will be negative:

<PRE>
    public char[] create(int len) {
        if (len >= 0) { 
            return new char[len-1]; // length of created array may be negative
        }
        return NULL;
    }
</PRE> 

JLINT will not report this message if 
minimal value of length is less than -127 (to avoid messages for 
all expressions of sign types).<P>


<H4><A NAME="bounds.bad_index">Index <TT>[integer,integer]</TT> is out of array bounds</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>bounds</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>bad_index</B></TD></TR>
</TABLE><P>

Index expression is out of array bounds. This message means that 
index expression either always produce negative values either it's minimal 
value is greater or equal to maximal possible length of the accessed array:

<PRE>
    int len = 10;
    char[] s = new char[len];
    s[len] = '?'; // index out of the array bounds
</PRE>



<H4><A NAME="bounds.maybe_bad_index">Index <TT>[integer,integer]</TT> may be out of array bounds</A></H4>

<TABLE> 
<TR><TD>Message category:</TD> <TD><B>bounds</B></TD></TR>
<TR><TD>Message code:</TD> <TD><B>maybe_bad_index</B></TD></TR>
</TABLE><P>

Value of index expression can be out of array bounds.
This message is produced when either index expression can be negative or
it's maximal value is greater than maximal value of accessed array length.
JLINT doesn't produce this message when minimal value of index is less than
-127 or difference between maximal value of index and array length is greater 
or equal than 127.

<PRE>
    public void putchar(char ch) {
        boolean[] digits = new boolean[9];
        if (ch >= '0' && ch <= '9') { 
	    digits[ch-'0'] = true; // index may be out of range
	    digits[ch-'1'] = true; // index may be negative
	}
    }
</PRE>

 
<H2><A NAME = "options">Command line options</A></H2>

Both programs (AntiC and Jlint) accept list of files or directories 
separated by spaces in command line. Wildcards are permitted. 
If specified file is directory, then program will recursively 
scan all files in this directory, selecting only files with
known extensions (<TT>.java</TT>, <TT>.c</TT>,...) and subdirectories. 

<H3><A NAME = "antic.opt">AntiC command line options</A></H3>

<DL>
<DT>-java<DD>By default Jlint considers files with extension
".java" as Java sources and all other files as C/C++ sources. 
There are very few differences (from AntiC point of view) between Java and 
C++. The differences are mostly with set of tokens and Unicode character 
constants.
<DT>-tab <B><I>TAB-SIZE</I></B><DD>Set tabulation size. By default Jlint 
uses 8-character tabulation, but some editors (for example MVC)
by default use 4 characters tabulations.
</DL><P>

<H3><A NAME = "jlint.opt">Jlint command line options</A></H3>

Jlint option can be placed in any position in command line and takes
effect for verification of all successive files in command line. 
Option always overrides previous occurrence of the same option. 
Some options specify parameters of global analysis, which is performed after 
loading of all files, so only the last occurrence of such options takes 
effect.<P>

Options are always compared ignoring letters case and <TT>'_'</TT>
symbols. So the following two strings specify the same option:
<TT>-ShadowLocal</TT> and <TT>-shadow_local</TT>.<P>

All Jlint options are prefixed by <TT>'-'</TT> or <TT>'+'</TT>.
For options, which can be enabled or disabled, <TT>'+'</TT> means that option 
is enabled and <TT>'-'</TT> means that option is disabled. 
For options like <TT>source</TT> or <TT>help</TT> there is no
difference between <TT>'-'</TT> and <TT>'+'</TT>.<P>

<DL>
<DT>-source <I><B>path</B></I><DD>
Specifies path to source files. It is necessary to specify this option when
sources and class files are located in different directories. For example:
<TT>jlint -source /usr/local/jdk1.1.1/src /usr/local/jdk1.1.1/lib/classes.zip</TT>. 

<DT>-history <I><B>file</B></I><DD>
Specifies history file. Jlint will not repeatedly report messages,
which are present in history file. History file should be available for
reading/writing and is appended by new messages after each Jlint execution.
This messages will not be more reported in successive executions of Jlint
(certainly if <TT>-history</TT> options is present and specifies the same 
history file).

<DT>-max_shown_paths <I><B>number</B></I><DD>
Specifies number of different paths between two vertexes in class graph used
for detecting possible deadlocks 
(see <A HREF="#synchronization">Synchronization</A>). 
Default value of this parameter is 4.
Increasing of this value can increase time of verification for complex 
programs. 
 
<DT>-help<DD>
Output list of all options, including message categories. If option
<TT>+verbose</TT> was previously specified, then list of all messages
is also printed.  

<DT>(+-)verbose<DD>
Switch on/off verbose mode. In verbose mode Jlint outputs more information
about process of verification: names of verified files, warnings about
absence of debugging information...

<DT>(+-)<I><B>message_category</B></I><DD>
Enable or disable reporting of messages of specified category. 
It is possible to disable top level category and then enable some 
subcategories within this category. And visa-versa it is possible to 
disable some specific categories within top-level category.
It is also possible to disable concrete message codes within category.
Table below describes full hierarchy of messages. By default all categories are
enabled.

<DT>(+-)all<DD>
Enable/disable reporting of all messages. If <TT>-all</TT> is specified,
it is possible to enable reporting of some specific categories of messages.
For example to output only synchronization messages it is enough to specify
"<TT>-all +synchronization</TT>". 

<DT>(+-)<I><B>message_code</B></I><DD>
Enable or disable reporting of concrete message. 
Message will be reported if its category is enabled and 
message code is enabled. If there is only one message code in the 
category, then names of the category and message code are the same.
By default all messages are enabled.
</DL><P>

<TABLE BORDER ALIGN="CENTER"> 
<CAPTION>Jlint messages hierarchy</CAPTION>
<TR>
<TH>Top level category</TH>
<TH>subcategory</TH>
<TH>Message code</TH>
</TR>
<TR>
<TH ROWSPAN=9>Synchronization</TH>
<TH ROWSPAN=4>deadlock</TH>
<TD>syncLoop</TD>
</TR>
<TR><TD>loop</TD></TR>
<TR><TD>wait</TD></TR>
<TR><TD>waitPath</TD></TR>
<TR>
<TH ROWSPAN=4>raceCondition</TH>
<TD>noSync</TD>
</TR>
<TR><TD>concurrentCall</TD></TR>
<TR><TD>concurrentAccess</TD></TR>
<TR><TD>runNoSync</TD></TR>
<TR>
<TH>waitNoSync</TH><TD>waitNoSync</TD>
</TR>

<TR>
<TH ROWSPAN=4>Inheritance</TH>
<TH>notOverridden</TH><TD>notOverridden</TD>
</TR>
<TR><TH>fieldRedefined</TH><TD>fieldRedefined</TD></TR>
<TR><TH>shadowLocal</TH><TD>shadowLocal</TD></TR>
<TR><TH>superFinalize</TH><TD>superFinalize</TD></TR>

<TR>
<TH ROWSPAN=17>DataFlow</TH>
<TH ROWSPAN=3>nullReference</TH><TD>nullParam</TD>
</TR>
<TR><TD>nullVar</TD></TR>
<TR><TD>nullPtr</TD></TR>
<TR><TH>zeroOperand</TH><TD>zeroOperand</TD></TR>
<TR><TH>zeroResult</TH><TD>zeroResult</TD></TR>
<TR><TH ROWSPAN=3>domain</TH><TD>shiftCount</TD></TR>
<TR><TD>shiftRange</TD></TR>
<TR><TD>conversion</TD></TR>
<TR><TH>truncation</TH><TD>truncation</TD></TR>
<TR><TH>overflow</TH><TD>overflow</TD></TR>
<TR><TH ROWSPAN=3>redundand</TH><TD>sameResult</TD></TR>
<TR><TD>disjointMask</TD></TR>
<TR><TD>noEffect</TD></TR>
<TR><TH>shortCharCmp</TH><TD>shortCharCmp</TD></TR>
<TR><TH>stringCmp</TH><TD>stringCmp</TD></TR>
<TR><TH>weakCmp</TH><TD>weakCmp</TD></TR>
<TR><TH>incompCase</TH><TD>incompCase</TD></TR>
<TR><TH ROWSPAN=4>bounds</TH><TD>negLen</TD></TR>
<TR><TD>maybeNegLen</TD></TR>
<TR><TD>badIndex</TD></TR>
<TR><TD>maybeBadIndex</TD></TR>
</TABLE><P>


<H2><A NAME = "howto">How to build and use Jlint&AntiC</A></H2>

Jlint is written on C++, using almost no operation system dependent code,
so I hope it will not a problem to compile it on any system with C++ compiler.
Current release contains makefile for Unix with gcc and for Windows with
Microsoft Visual C++. In both cases it is enough to execute "make" to build
"antic" and "jlint" programs. Distributive for Windows already includes 
executable files.<P>

To use Jlint you need to compile first you Java sources to byte code.
As far as format of Java class is standard, you can use any available Java
compiler. It is preferable to make compiler to include debug information
in compiled classes (line table and local variables mapping). In this case
Jlint messages will be more detailed. If your are using Sun <B>javac</B>
compiler, required option is <TT>-g</TT>. Most of compilers by default
includes line table, but do not generate local variable table.
For example free Java compiler <B>guavac</B> can't generate it at all.
Some compilers (like Sun's  <B>javac</B>) can't generate line table if 
optimization is switch on. If you specify <TT>-verbose</TT> option to Jlint,
it will report when it can't find line or local variable table in the class 
file.<P>

Now Jlint and AntiC produce message in Emacs format: 
"<TT>file:line: message text</TT>".
So it is possible to walk through these messages in Emacs if you start 
Jlint or AntiC as compiler. You can change prefix <TT>MSG_LOCATION_PREFIX</TT> 
(defined in <A HREF="jlint.h">jlint.h</A>) from <TT>"%0s:%1d: "</TT> 
to one recognized by your favorite editor or IDE. All Jlint messages are
gathered in file <A HREF="jlint.msg">jlint.msg</A>, so you can easily 
change them (but recompilation is needed).<P>

AntiC also includes in the message position in the line. 
All AntiC messages are produced
by function <CODE>message_at(int line, int coln, char* msg)</CODE>, 
defined in file <A HREF="antic.c">antic.c</A>. 
You can change format of reported messages
by modifying this function.<P>


<H2><A NAME = "about">Release notes</A></H2>

Jlint is freeware and is distributed with sources and 
without any restrictions.
E-mail support is guaranteed. I will do my best to fix all reported bugs 
and extend Jlint functionality. Any suggestions and comments are welcome.
I will be also very glad if somebody add some more stuff to Jlint or
integrate it with some popular software development tools.
Also modification of texts of reported messages 
in order to make them more clear (sorry, english is not my native language) or 
localization to some other languages are welcome.
It can be also interesting to port Jlint to Java.
<P> 
 


<HR>
<P ALIGN="CENTER"><A HREF="http://www.ispras.ru/~knizhnik">
<B>Look for new version at my homepage</B></A><B> | </B>
<A HREF="mailto:knizhnik@altavista.net">
<B>E-mail me about bugs and problems</B></A></P>
</BODY>
</HTML>
