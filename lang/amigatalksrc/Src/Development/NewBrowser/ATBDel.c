/*
 *  Source machine generated by GadToolsBox V2.0b
 *  which is (c) Copyright 1991-1993 Jaba Development
 *
 *  GUI Designed by : Jim Steichen
 */

#include <exec/types.h>
#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>
#include <libraries/gadtools.h>
#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>
#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>
#include <string.h>
#include <clib/diskfont_protos.h>

#define GetString( g )      ((( struct StringInfo * )g->SpecialInfo )->Buffer  )

#define GD_ClassLV                             0
#define GD_CancelBt                            1
#define GD_RemoveMemBt                         2
#define GD_DeleteFileBt                        3
#define GD_DeleteClassBt                       4
#define GD_DeleteTxt                           5

#define DC_CNT 6

extern struct IntuitionBase *IntuitionBase;
extern struct Library       *GadToolsBase;


struct Screen         *Scr = NULL;
APTR                   VisualInfo = NULL;
struct Window         *DCWnd = NULL;
struct Gadget         *DCGList = NULL;
struct IntuiMessage    DCMsg;
struct Gadget         *DCGadgets[6];
UWORD                  DCLeft = 0;
UWORD                  DCTop = 14;
UWORD                  DCWidth = 632;
UWORD                  DCHeight = 328;
UBYTE                 *DCWdt = (UBYTE *)"Delete a Class from AmigaTalk...";
struct TextAttr       *Font, Attr;
UWORD                  FontX, FontY;
UWORD                  OffX, OffY;
struct TextFont       *DCFont = NULL;

struct IntuiText DCIText[] = {
	2, 0, JAM1,458, 10, NULL, (UBYTE *)"WARNING:  The severity of the action you", NULL,
	2, 0, JAM1,439, 23, NULL, (UBYTE *)"take increases the lower the button", NULL,
	2, 0, JAM1,366, 36, NULL, (UBYTE *)"is in the window!", NULL };

#define DC_TNUM 3

UWORD DCGTypes[] = {
	LISTVIEW_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	BUTTON_KIND,
	TEXT_KIND
};

PRIVATE int ClassLVClicked( void );
PRIVATE int CancelBtClicked( void );
PRIVATE int RemoveMemBtClicked( void );
PRIVATE int DeleteFileBtClicked( void );
PRIVATE int DeleteClassBtClicked( void );

struct NewGadget DCNGad[] = {
	6, 20, 289, 308, (UBYTE *)"Classes:", NULL, GD_ClassLV, PLACETEXT_ABOVE|NG_HIGHLABEL, NULL, (APTR)ClassLVClicked,
	301, 51, 79, 18, (UBYTE *)"_CANCEL!", NULL, GD_CancelBt, PLACETEXT_IN, NULL, (APTR)CancelBtClicked,
	301, 80, 278, 18, (UBYTE *)"Remove Class from Browser Memory", NULL, GD_RemoveMemBt, PLACETEXT_IN, NULL, (APTR)RemoveMemBtClicked,
	301, 111, 259, 18, (UBYTE *)"Delete Class Source File also", NULL, GD_DeleteFileBt, PLACETEXT_IN, NULL, (APTR)DeleteFileBtClicked,
	348, 266, 224, 18, (UBYTE *)"Delete Selected Class!", NULL, GD_DeleteClassBt, PLACETEXT_IN, NULL, (APTR)DeleteClassBtClicked,
	333, 240, 251, 17, (UBYTE *)"Class to Delete:", NULL, GD_DeleteTxt, PLACETEXT_ABOVE, NULL, NULL
};

ULONG DCGTags[] = {
	(GTLV_ShowSelected), NULL, (LAYOUTA_Spacing), 2, (TAG_DONE),
	(GT_Underscore), '_', (TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(TAG_DONE),
	(GTTX_Border), TRUE, (TAG_DONE)
};

UWORD DriPens[] = { ~0 };

// --------------------------------------------------------------------

PRIVATE int ClassLVClicked( void )
{
	/* routine when gadget "Classes:" is clicked. */
}

PRIVATE int CancelBtClicked( void )
{
	/* routine when gadget "_CANCEL!" is clicked. */
}

PRIVATE int RemoveMemBtClicked( void )
{
	/* routine when gadget "Remove Class from Browser Memory" is clicked. */
}

PRIVATE int DeleteFileBtClicked( void )
{
	/* routine when gadget "Delete Class Source File also" is clicked. */
}

PRIVATE int DeleteClassBtClicked( void )
{
	/* routine when gadget "Delete Selected Class!" is clicked. */
}

PRIVATE int DCCloseWindow( void )
{
	/* routine for "IDCMP_CLOSEWINDOW". */
}

PRIVATE int DCVanillaKey( void )
{
	/* routine for "IDCMP_VANILLAKEY". */
}
// --------------------------------------------------------------------

void DCRender( void )
{
	struct IntuiText	it;
	UWORD			cnt;

	ComputeFont( DCWidth, DCHeight );


	for ( cnt = 0; cnt < DC_TNUM; cnt++ ) {
		CopyMem(( char * )&DCIText[ cnt ], ( char * )&it, (long)sizeof( struct IntuiText ));
		it.ITextFont = Font;
		it.LeftEdge  = OffX + ComputeX( it.LeftEdge ) - ( IntuiTextLength( &it ) >> 1 );
		it.TopEdge   = OffY + ComputeY( it.TopEdge ) - ( Font->ta_YSize >> 1 );
		PrintIText( DCWnd->RPort, &it, 0, 0 );
	}
}

int HandleDCIDCMP( void )
{
	struct IntuiMessage	*m;
	int			(*func)();
	BOOL			running = TRUE;

	while( m = GT_GetIMsg( DCWnd->UserPort )) {

		CopyMem(( char * )m, ( char * )&DCMsg, (long)sizeof( struct IntuiMessage ));

		GT_ReplyIMsg( m );

		switch ( DCMsg.Class ) {

			case	IDCMP_REFRESHWINDOW:
				GT_BeginRefresh( DCWnd );
				DCRender();
				GT_EndRefresh( DCWnd, TRUE );
				break;

			case	IDCMP_CLOSEWINDOW:
				running = DCCloseWindow();
				break;

			case	IDCMP_VANILLAKEY:
				running = DCVanillaKey();
				break;

			case	IDCMP_GADGETUP:
			case	IDCMP_GADGETDOWN:
				func = ( void * )(( struct Gadget * )DCMsg.IAddress )->UserData;
				running = func();
				break;
		}
	}
	return( running );
}

int OpenDCWindow( void )
{
	struct NewGadget	ng;
	struct Gadget	*g;
	UWORD		lc, tc;
	UWORD		wleft = DCLeft, wtop = DCTop, ww, wh;

	ComputeFont( DCWidth, DCHeight );

	ww = ComputeX( DCWidth );
	wh = ComputeY( DCHeight );

	if (( wleft + ww + OffX + Scr->WBorRight ) > Scr->Width ) wleft = Scr->Width - ww;
	if (( wtop + wh + OffY + Scr->WBorBottom ) > Scr->Height ) wtop = Scr->Height - wh;

	if ( ! ( DCFont = OpenDiskFont( Font )))
		return( 5L );

	if ( ! ( g = CreateContext( &DCGList )))
		return( 1L );

	for( lc = 0, tc = 0; lc < DC_CNT; lc++ ) {

		CopyMem((char * )&DCNGad[ lc ], (char * )&ng, (long)sizeof( struct NewGadget ));

		ng.ng_VisualInfo = VisualInfo;
		ng.ng_TextAttr   = Font;
		ng.ng_LeftEdge   = OffX + ComputeX( ng.ng_LeftEdge );
		ng.ng_TopEdge    = OffY + ComputeY( ng.ng_TopEdge );
		ng.ng_Width      = ComputeX( ng.ng_Width );
		ng.ng_Height     = ComputeY( ng.ng_Height);

		DCGadgets[ lc ] = g = CreateGadgetA((ULONG)DCGTypes[ lc ], g, &ng, ( struct TagItem * )&DCGTags[ tc ] );

		while( DCGTags[ tc ] ) tc += 2;
		tc++;

		if ( NOT g )
			return( 2L );
	}

	if ( ! ( DCWnd = OpenWindowTags( NULL,
				WA_Left,	wleft,
				WA_Top,		wtop,
				WA_Width,	ww + OffX + Scr->WBorRight,
				WA_Height,	wh + OffY + Scr->WBorBottom,
				WA_IDCMP,	LISTVIEWIDCMP|BUTTONIDCMP|TEXTIDCMP|IDCMP_CLOSEWINDOW|IDCMP_VANILLAKEY|IDCMP_REFRESHWINDOW,
				WA_Flags,	WFLG_DRAGBAR|WFLG_DEPTHGADGET|WFLG_CLOSEGADGET|WFLG_SMART_REFRESH|WFLG_ACTIVATE|WFLG_RMBTRAP,
				WA_Gadgets,	DCGList,
				WA_Title,	DCWdt,
				WA_ScreenTitle,	"AmigaTalk Browser © 1998",
				WA_CustomScreen,	Scr,
				TAG_DONE )))
	return( 4L );

	GT_RefreshWindow( DCWnd, NULL );

	DCRender();

	return( 0L );
}

void CloseDCWindow( void )
{
	if ( DCWnd        ) {
		CloseWindow( DCWnd );
		DCWnd = NULL;
	}

	if ( DCGList      ) {
		FreeGadgets( DCGList );
		DCGList = NULL;
	}

	if ( DCFont ) {
		CloseFont( DCFont );
		DCFont = NULL;
	}
}

