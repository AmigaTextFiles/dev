/****h* TestBrowser.c [1.0] **********************************
*
* NAME
*    TestBrowser.c
*
* DESCRIPTION
*    Test program for the Browser in AmigaTalk V2.4+
*
* NOTES
*    Source machine generated by GadToolsBox V2.0b
*    which is (c) Copyright 1991-1993 Jaba Development
*
*    $VER: TestBrowser.c 1.0 (Sep-01-2003) by J.T. Steichen
**************************************************************
*
*/

#include <stdio.h>
#include <string.h>

#include <exec/types.h>

#include <AmigaDOSErrs.h>

#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/imageclass.h>
#include <intuition/gadgetclass.h>

#include <libraries/gadtools.h>

#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>

#include <clib/exec_protos.h>
#include <clib/intuition_protos.h>
#include <clib/gadtools_protos.h>
#include <clib/graphics_protos.h>
#include <clib/utility_protos.h>

#include "ATStructs.h"

#include "CPGM:GlobalObjects/CommonFuncs.h"

#include "TestBrowser.h" // Object Class Messages & Methods

#define TestBt  0

#define TB_CNT  1

struct IntuitionBase *IntuitionBase;
struct GfxBase       *GfxBase;
struct Library       *GadToolsBase;

PUBLIC APTR             VisualInfo = NULL;
PUBLIC struct CompFont  CFont      = { 0, };
PUBLIC struct TextAttr *Font, Attr = { 0, };
PUBLIC struct Screen   *Scr        = NULL;

PUBLIC char *PgmName     = NULL;
PUBLIC char *authorEMail = "jimbot@frontiernet.net";
PUBLIC char *authorName  = "J.T. Steichen";

PUBLIC int   Version = 2.4;

PUBLIC OBJECT *o_nil = NULL;

PUBLIC UBYTE em[256] = "", *ErrMsg = &em[0];

PUBLIC struct TagItem LoadTags[] = {

    ASLFR_Window,          NULL,   
    ASLFR_Screen,          NULL,
    ASLFR_TitleText,       NULL,
    ASLFR_InitialHeight,   300, // FR_HEIGHT,
    ASLFR_InitialWidth,    400, // FR_WIDTH,
    ASLFR_InitialTopEdge,  200, // FR_TOPEDGE,
    ASLFR_InitialLeftEdge, 200, // FR_LEFTEDGE,
    ASLFR_PositiveText,    NULL,
    ASLFR_NegativeText,    NULL,
    ASLFR_InitialPattern,  (ULONG) "#?",
    ASLFR_InitialFile,     (ULONG) "", // EMPTY_STRING,
    ASLFR_InitialDrawer,   (ULONG) "AmigaTalk:",
    ASLFR_Flags1,          FRF_DOPATTERNS,
    ASLFR_Flags2,          FRF_REJECTICONS,
    ASLFR_SleepWindow,     1,
    ASLFR_PrivateIDCMP,    1,
    ASLFR_PopToFront,      1,
    ASLFR_Activate,        1,

    TAG_DONE 
};

// -----------------------------------------------------

PRIVATE struct TagItem ScreenTags[] = {

    ASLSM_Window,           NULL,   
    ASLSM_Screen,           NULL,
    ASLSM_TitleText,        NULL,
    ASLSM_InitialHeight,    300, // FR_HEIGHT,
    ASLSM_InitialWidth,     400, // FR_WIDTH,
    ASLSM_InitialTopEdge,   200, // FR_TOPEDGE,
    ASLSM_InitialLeftEdge,  200, // FR_LEFTEDGE,
    
    ASLSM_InitialDisplayID,     0x40D2001,
    ASLSM_InitialDisplayWidth,  640,
    ASLSM_InitialDisplayHeight, 480,
    ASLSM_InitialDisplayDepth,  8,

    ASLSM_DoWidth,          1,
    ASLSM_DoHeight,         1,
    ASLSM_DoDepth,          1,
    
    ASLSM_MinWidth,         640, 
    ASLSM_MinHeight,        400, 

    ASLSM_PositiveText,     NULL,
    ASLSM_NegativeText,     NULL,

    ASLSM_SleepWindow,      1,
    ASLSM_PrivateIDCMP,     1,
    ASLSM_PopToFront,       1,
    ASLSM_Activate,         1,
    TAG_DONE 
};

PRIVATE struct Window   *TBWnd   = NULL;
PRIVATE struct Gadget   *TBGList = NULL;
PRIVATE struct Gadget   *TBGadgets[ TB_CNT ];

PRIVATE struct IntuiMessage TBMsg;

PRIVATE UWORD  TBLeft   = 145;
PRIVATE UWORD  TBTop    = 46;
PRIVATE UWORD  TBWidth  = 435;
PRIVATE UWORD  TBHeight = 110;
PRIVATE UBYTE *TBWdt    = "Test AmigaTalk Browser";


PRIVATE UWORD TBGTypes[] = { BUTTON_KIND };

PRIVATE int TestBtClicked( void );

PRIVATE struct NewGadget TBNGad[] = {

   145, 50, 105, 20, "Test _Browser", NULL, TestBt, 
   PLACETEXT_IN, NULL, (APTR) TestBtClicked
};

PRIVATE ULONG TBGTags[] = { GT_Underscore, '_', TAG_DONE };

PRIVATE UWORD DriPens[] = { 0xFFFF };

PRIVATE SYMBOL objSymbol = {
   
   1, 0xFFFFFFFD,
   "Object"
};

PRIVATE SYMBOL objFileSymbol = {
   
   1, 0xFFFFFFFD,
   "AmigaTalk:General/Object.st"
};

PRIVATE CLASS object = {

   1, 0xFFFFFFFF,
   &objSymbol, NULL,
   &objFileSymbol, NULL,
   NULL, NULL, // &msgArray, &methodArray,
   25,  25,
   NULL    
};


// -----------------------------------------------------------------

PUBLIC void CannotCreate( char *msg )
{
   UserInfo( msg, "Could NOT create:" );
   
   return;
}

PUBLIC int getFileLineCount( char *className )
{
   FILE   *srcFile = NULL;
   int     rval    = 0, ch;

   if (strncmp( className, "Object", 6 ) != 0)
      return( rval );
      
   if ((srcFile = fopen( "Amigatalk:General/Object.st", "r" )) == NULL)
      return( rval );

   ch = fgetc( srcFile );
   
   while (ch != EOF)
      {
      if (ch == '\n')
         rval++;
         
      ch = fgetc( srcFile );
      }

   fclose( srcFile );
                              
   return( rval );
}

PUBLIC char *symbol_value( SYMBOL *symbolPtr )
{
   return( symbolPtr->value );
}

PUBLIC CLASS *lookup_class( char *className )
{
   if (strncmp( className, "Object", 6 ) != 0)
      return( NULL );
   else
      return( &object );
}

PUBLIC int getNumberMethods( char *className )
{
//   CLASS  *objClass = lookup_class( className );
//   OBJECT *msgArray = objClass->message_names;

//   return( msgArray->size );

   return( 41 );
}

PUBLIC void ClearLVMNodeStrs( struct ListViewMem *lvm )
{
   int i, len = lvm->lvm_NumItems * lvm->lvm_NodeLength;
   
   for (i = 0; i < len; i++)
      *(lvm->lvm_NodeStrs + i) = '\0'; 

   return;
}

// ------------------------------------------------------------

PRIVATE int SetupScreen( void )
{
   ULONG modeID = 0L;
   
   Scr = GetActiveScreen();
   
   modeID = getScreenModeID( &ScreenTags[0], Scr, "TestBrowser Screen Mode:" );
   
   if ((Scr = OpenScreenTags( NULL, 

         SA_Left,        0,
         SA_Top,         0,
//         SA_Width,       800,
//         SA_Height,      600,
//         SA_Depth,       8,
         SA_Type,        CUSTOMSCREEN,
         SA_DisplayID,   modeID,
         SA_AutoScroll,  TRUE,
         SA_Pens,        &DriPens[0],
         SA_SharePens,   TRUE,
         SA_FullPalette, TRUE,
         SA_Title,       "TestBrowser",
         TAG_DONE )) == NULL)
      return( -1 );

   Font = &Attr;
   
   ComputeFont( Scr, Font, &CFont, 0, 0 );

   if ((VisualInfo = GetVisualInfo( Scr, TAG_DONE )) == NULL)
      return( -2 );

   return( 0 );
}

PRIVATE void CloseDownScreen( void )
{
   if (VisualInfo != NULL) 
      {
      FreeVisualInfo( VisualInfo );
      VisualInfo = NULL;
      }

   if (Scr != NULL) 
      {
      CloseScreen( Scr );
      Scr = NULL;
      }

   return;
}

PRIVATE int OpenTBWindow( void )
{
   struct NewGadget  ng;
   struct Gadget    *g;
   UWORD             lc, tc;
   UWORD             wleft = TBLeft, wtop = TBTop, ww, wh;

   ComputeFont( Scr, Font, &CFont, TBWidth, TBHeight );

   ww = ComputeX( CFont.FontX, TBWidth );
   wh = ComputeY( CFont.FontY, TBHeight );

   wleft = (Scr->Width  - TBWidth)  / 2;
   wtop  = (Scr->Height - TBHeight) / 2;

   if ((g = CreateContext( &TBGList )) == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < TB_CNT; lc++ ) 
      {

      CopyMem( (char *) &TBNGad[ lc ], (char *) &ng, 
               (long) sizeof( struct NewGadget )
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = Font;
      ng.ng_LeftEdge   = CFont.OffX + ComputeX( CFont.FontX, ng.ng_LeftEdge );
      ng.ng_TopEdge    = CFont.OffY + ComputeY( CFont.FontY, ng.ng_TopEdge );
      ng.ng_Width      = ComputeX( CFont.FontX, ng.ng_Width );
      ng.ng_Height     = ComputeY( CFont.FontY, ng.ng_Height);

      TBGadgets[ lc ] = g 
                      = CreateGadgetA( (ULONG) TBGTypes[ lc ], g, 
                                       &ng, 
                                       (struct TagItem *) &TBGTags[ tc ] 
                                     );

      while (TBGTags[ tc ] != TAG_DONE) 
         tc += 2;
      
      tc++;

      if (g == NULL)
         return( -2 );
      }

   if ((TBWnd = OpenWindowTags( NULL,

            WA_Left,         wleft,
            WA_Top,          wtop,
            WA_Width,        ww + CFont.OffX + Scr->WBorRight,
            WA_Height,       wh + CFont.OffY + Scr->WBorBottom,

            WA_IDCMP,        BUTTONIDCMP | IDCMP_CLOSEWINDOW | IDCMP_VANILLAKEY
              | IDCMP_REFRESHWINDOW,

            WA_Flags,        WFLG_DRAGBAR | WFLG_CLOSEGADGET | WFLG_SMART_REFRESH
              | WFLG_ACTIVATE | WFLG_RMBTRAP,

            WA_Gadgets,      TBGList,
            WA_Title,        TBWdt,
            WA_ScreenTitle,  "TestBrowser",
            WA_CustomScreen, Scr,
            TAG_DONE )) == NULL)
      return( -4 );

   GT_RefreshWindow( TBWnd, NULL );

   return( 0 );
}

PRIVATE void CloseTBWindow( void )
{
   if (TBWnd != NULL) 
      {
      CloseWindow( TBWnd );
      TBWnd = NULL;
   }

   if (TBGList != NULL) 
      {
      FreeGadgets( TBGList );
      TBGList = NULL;
   }

   return;
}


PRIVATE int TBCloseWindow( void )
{
   CloseTBWindow();
   
   return( FALSE );
}

PRIVATE int TestBtClicked( void )
{
   /* routine when gadget "Test _Browser" is clicked. */
   IMPORT int useBrowser( struct Window *parent, char *browserName );
   
   if (useBrowser( TBWnd, "AmigaTalk:C/TheBrowser" ) < 0)
      return( FALSE );
   else
      return( TRUE );
}

PRIVATE int TBVanillaKey( int whichKey )
{
   /* routine for "IDCMP_VANILLAKEY". */
   int rval = TRUE;
   
   switch (whichKey)
      {
      case 'b':
      case 'B':
         rval = TestBtClicked();
         break;
         
      case 'q':
      case 'Q':
      case 'x':
      case 'X':
         rval = FALSE;
         break;
      }
      
   return( rval );
}

PRIVATE int HandleTBIDCMP( void )
{
   struct IntuiMessage   *m;
   int                  (*func)( void );
   BOOL                   running = TRUE;

   while (running == TRUE)
      {
      if ((m = GT_GetIMsg( TBWnd->UserPort )) == NULL) 
         {
         (void) Wait( 1L << TBWnd->UserPort->mp_SigBit );

         continue;
         }

      CopyMem( (char *) m, (char *) &TBMsg, 
               (long) sizeof( struct IntuiMessage )
             );

      GT_ReplyIMsg( m );

      switch (TBMsg.Class) 
         {
         case   IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( TBWnd );
            GT_EndRefresh( TBWnd, TRUE );
            break;

         case   IDCMP_CLOSEWINDOW:
            running = TBCloseWindow();
            break;

         case   IDCMP_VANILLAKEY:
            running = TBVanillaKey( TBMsg.Code );
            break;

         case   IDCMP_GADGETUP:
            func    = (void *) ((struct Gadget *)TBMsg.IAddress)->UserData;
            running = func();
            break;
         }
      }

   return( running );
}

PRIVATE void FreeObjClass( void )
{
   FreeVec( object.methods );
   FreeVec( object.message_names );
   
   return;
}

PRIVATE void ShutdownProgram( void )
{
   CloseTBWindow();

   CloseDownScreen();

   CloseLibs();

   FreeObjClass();
   
   return;
}

PRIVATE int AllocObjClass( void )
{
   ULONG *msgs = NULL;
   ULONG *methods = NULL;
   
   msgs = (ULONG *) AllocVec( 45 * sizeof( ULONG ), MEMF_CLEAR | MEMF_ANY );
   
   if (msgs == NULL)
      return( -1 );
   
   methods = (ULONG *) AllocVec( 45 * sizeof( ULONG ), MEMF_CLEAR | MEMF_ANY );
   
   if (methods == NULL)
      {
      FreeVec( msgs );

      return( -2 );
      }
   
   msgs[0]  = 1;       msgs[1]  = 41;
   msgs[4]  = &omsg1;  msgs[5]  = &omsg2;  msgs[6]  = &omsg3;
   msgs[7]  = &omsg4;  msgs[8]  = &omsg5;  msgs[9]  = &omsg6;
   msgs[10] = &omsg7;  msgs[11] = &omsg8;  msgs[12] = &omsg9;
   msgs[13] = &omsg10; msgs[14] = &omsg11; msgs[15] = &omsg12;
   msgs[16] = &omsg13; msgs[17] = &omsg14; msgs[18] = &omsg15;
   msgs[19] = &omsg16; msgs[20] = &omsg17; msgs[21] = &omsg18;
   msgs[22] = &omsg19; msgs[23] = &omsg20; msgs[24] = &omsg21;
   msgs[25] = &omsg22; msgs[26] = &omsg23; msgs[27] = &omsg24;
   msgs[28] = &omsg25; msgs[29] = &omsg26; msgs[30] = &omsg27;
   msgs[31] = &omsg28; msgs[32] = &omsg29; msgs[33] = &omsg30;
   msgs[34] = &omsg31; msgs[35] = &omsg32; msgs[36] = &omsg33;
   msgs[37] = &omsg34; msgs[38] = &omsg35; msgs[39] = &omsg36;
   msgs[40] = &omsg37; msgs[41] = &omsg38; msgs[42] = &omsg39;
   msgs[43] = &omsg40; msgs[44] = &omsg41;

   object.message_names = &msgs[0];
   
   methods[0]  = 1;       methods[1]  = 41;
   methods[4]  = &omsg1;  methods[5]  = &omsg2;  methods[6]  = &omsg3;
   methods[7]  = &omsg4;  methods[8]  = &omsg5;  methods[9]  = &omsg6;
   methods[10] = &omsg7;  methods[11] = &omsg8;  methods[12] = &omsg9;
   methods[13] = &omsg10; methods[14] = &omsg11; methods[15] = &omsg12;
   methods[16] = &omsg13; methods[17] = &omsg14; methods[18] = &omsg15;
   methods[19] = &omsg16; methods[20] = &omsg17; methods[21] = &omsg18;
   methods[22] = &omsg19; methods[23] = &omsg20; methods[24] = &omsg21;
   methods[25] = &omsg22; methods[26] = &omsg23; methods[27] = &omsg24;
   methods[28] = &omsg25; methods[29] = &omsg26; methods[30] = &omsg27;
   methods[31] = &omsg28; methods[32] = &omsg29; methods[33] = &omsg30;
   methods[34] = &omsg31; methods[35] = &omsg32; methods[36] = &omsg33;
   methods[37] = &omsg34; methods[38] = &omsg35; methods[39] = &omsg36;
   methods[40] = &omsg37; methods[41] = &omsg38; methods[42] = &omsg39;
   methods[43] = &omsg40; methods[44] = &omsg41;

   object.methods = &methods[0];
   
   return( 0 );
}

PRIVATE int SetupProgram( void )
{
   if (AllocObjClass() < 0)
      return( -1 );
      
   if (OpenLibs() < 0)
      {
      FreeObjClass();

      return( -2 );
      }
      
   if (SetupScreen() < 0)
      {
      CloseLibs();

      FreeObjClass();

      return( -3 );
      }   

   if (OpenTBWindow() < 0)
      {
      ShutdownProgram();

      return( -4 );
      }   

   return( 0 );   
}

PUBLIC int main( int argc, char **argv )
{
   if (SetupProgram() < 0)
      {
      fprintf( stderr, "Could NOT set up %s!\n", argv[0] );

      return( IoErr() );
      }

   PgmName = argv[0];
   
   SetNotifyWindow( TBWnd );
   
   (void) HandleTBIDCMP();
   
   ShutdownProgram();
             
   return( RETURN_OK );
}

/* -------------------- END of TestBrowser.c file! ---------------- */
