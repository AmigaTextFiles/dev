/****h* AmigaTalk/IconDsp.c [3.0] *************************************
*
* NAME
*    IconDsp.c
*
* DESCRIPTION
*    Display information about a user-supplied Icon name.
*
* HISTORY
*    25-Oct-2004 - Added AmigaOS4 & gcc Support.
*
*    07-Jan-2003 - Moved all string constants to StringConstants.h
*
*    21-Mar-2002 Changed LayoutIconA() call to LayoutIcon() in 
*                ShowIconImages().
*
* NOTES:
*    FUNCTIONAL INTERFACE:
*       PUBLIC int IconInfoDisplay( DOPTR diskobject, char *iconName );
*
*    Source machine generated by GadToolsBox V2.0b
*    which is (c) Copyright 1991-1993 Jaba Development
*
*    GUI Designed by : Jim Steichen
*
*    $VER: IconDsp.c 3.0 (25-Oct-2004) by J.T. Steichen
***********************************************************************
*
*/

#include <stdio.h>
#include <string.h>

#include <exec/types.h>

#include <AmigaDOSErrs.h>

#include <intuition/intuition.h>
#include <intuition/classes.h>
#include <intuition/classusr.h>
#include <intuition/gadgetclass.h>
#include <intuition/imageclass.h>  // for IDS_NORMAL, etc.

#include <workbench/workbench.h>
#include <workbench/startup.h>
#include <workbench/icon.h>

#include <libraries/gadtools.h>

#include <graphics/displayinfo.h>
#include <graphics/gfxbase.h>

#ifdef  __SASC

# include <clib/exec_protos.h>
# include <clib/dos_protos.h>
# include <clib/intuition_protos.h>
# include <clib/gadtools_protos.h>
# include <clib/graphics_protos.h>
# include <clib/layers_protos.h>
# include <clib/utility_protos.h>
# include <clib/diskfont_protos.h>

IMPORT struct IntuitionBase *IntuitionBase;
IMPORT struct Library       *GadToolsBase;
IMPORT struct GfxBase       *GfxBase;
IMPORT struct Library       *IconBase;

#else

# define __USE_INLINE__

# include <proto/dos.h>
# include <proto/exec.h>
# include <proto/intuition.h>
# include <proto/gadtools.h>
# include <proto/graphics.h>
# include <proto/layers.h>
# include <proto/utility.h>
# include <proto/diskfont.h>

IMPORT struct Library *IntuitionBase;
IMPORT struct Library *GadToolsBase;
IMPORT struct Library *GfxBase;
IMPORT struct Library *IconBase;

IMPORT struct IconIFace *IIcon;

#endif

#include "FuncProtos.h"

#include "StringConstants.h"
#include "StringIndexes.h"

#include "CPGM:GlobalObjects/CommonFuncs.h"

#define IMAGEX 331 // Image BevelBox dimensions 
#define IMAGEY 19
#define IMAGEW 216
#define IMAGEH 284

typedef struct DiskObject *DOPTR;

// -------------------------------------------------------------------

IMPORT struct Screen        *Scr;
IMPORT struct Window        *ATWnd;
IMPORT struct TextAttr      *Font;
IMPORT struct CompFont       CFont;

IMPORT UBYTE                *PubScreenName;
IMPORT APTR                  VisualInfo;

IMPORT UBYTE                *SystemProblem;

// ---- Common Structures: -------------------------------------------

PRIVATE struct Library      *LayersBase = NULL;

PRIVATE struct TextFont     *IcFont  = NULL;
PRIVATE struct Window       *IcWnd   = NULL;
PRIVATE struct Gadget       *IcGList = NULL;

PRIVATE struct IntuiMessage  IcMsg   = { 0, };

#define TOOLSIZE 80

PRIVATE struct ListViewMem  *lvm     = NULL;
PRIVATE struct List          TList   = { 0, };

// ---- Common Functions: --------------------------------------------

PRIVATE UBYTE IcWdt[80] = { 0, };

SUBFUNC void CorrectTitle( char *oldTitle, char *iconName )
{
   sprintf( IcWdt, "%s%-45s", oldTitle, iconName );

   return;
}


SUBFUNC void CloseIcWindow( void )
{
   if (IcWnd) // != NULL) 
      {
      CloseWindow( IcWnd );
      IcWnd = NULL;
      }

   if (IcGList) // != NULL) 
      {
      FreeGadgets( IcGList );
      IcGList = NULL;
      }

   if (IcFont) // != NULL) 
      {
      CloseFont( IcFont );
      IcFont = NULL;
      }

   return;
}

SUBFUNC int IcVanillaKey( int whichkey )
{
   int rval = TRUE;
   
   switch (whichkey)
      {
      case SMALL_O_CHAR:
      case CAP_O_CHAR:

         CloseIcWindow();
         rval = FALSE;

         break;
      }
      
   return( rval );
}

SUBFUNC int CountTools( STRPTR *toolTypes )
{
   int rval = 0;
   
   while (*toolTypes && (StringLength( *toolTypes ) > 0))
      {
      rval++;
      toolTypes++;
      }
      
   return( rval );
}

/****i* CopyToolTypes() [1.8] *****************************************
*
* NAME
*    CopyToolTypes()
*
* DESCRIPTION
*    Copy the tools from an icon tooltypes list to a ListView buffer.
***********************************************************************
*
*/

SUBFUNC void CopyToolTypes( char *strs, DOPTR diskObj, int toolcount )
{
   STRPTR *tptr = diskObj->do_ToolTypes;
   int     i;
   
   for (i = 0; i < toolcount; i++)
      {
      StringCopy( &strs[i * TOOLSIZE], *tptr );

      tptr++;
      }

   return;
}

/****i* ShowIconImages() [2.1] ***************************************
*
* NAME
*    ShowIconImages()
*
* DESCRIPTION
*    Display the primary & alternate images of an icon at the given
*    coordinates.  Code is from WBStartup+
**********************************************************************
*
*/

SUBFUNC int ShowIconImages( DOPTR diskObj )
{
   struct Rectangle  rect1, rect2;

   struct Image *image = (struct Image *) diskObj->do_Gadget.GadgetRender;
   struct Image *altim = (struct Image *) diskObj->do_Gadget.SelectRender;

   LONG gotPalette     = FALSE;
   BOOL openedIconBase = FALSE;
//   LONG chk            = 0L;

   if ( !IconBase) // == NULL)
      {
#     ifdef  __SASC
      if (!(IconBase = OpenLibrary( "icon.library", 44L )))
         return( -2 );
#     else
      if ((IconBase = OpenLibrary( "icon.library", 50L )))
         {
	 if (!(IIcon = (struct IconIFace *) GetInterface( IconBase, "main", 1, NULL )))
	    {
            CloseLibrary( IconBase );
	    return( -2 );
	    }
	 else 
	    openedIconBase = TRUE;
	 }
#     endif
      else
         openedIconBase = TRUE;
      }
            
   IconControl( diskObj, ICONCTRLA_SetGlobalScreen, Scr,
                         ICONCTRLA_IsPaletteMapped, &gotPalette,
                         TAG_DONE
              );
   

   // Verify we have enough room for large icons:

   if (GetIconRectangle( IcWnd->RPort, diskObj, NULL,
                         &rect1, ICONDRAWA_Borderless, 
                         TAG_DONE ) != FALSE)
      {
      // use the rect1 values
      rect1.MinX = (IMAGEW     - rect1.MaxX) / 2 + IMAGEX;
      rect1.MinY = (IMAGEH / 2 - rect1.MaxY) / 2 + IMAGEY;
      rect1.MaxX = (rect1.MaxX <= IMAGEW    ) ? rect1.MaxX : IMAGEW;
      rect1.MaxY = (rect1.MaxY <= IMAGEH / 2) ? rect1.MaxY : IMAGEH / 2;
     
      rect2.MinX = (IMAGEW     - rect1.MaxX) / 2 + IMAGEX;

      rect2.MinY = (IMAGEH  / 2 - rect1.MaxY) / 2 + IMAGEY 
                   + IMAGEH / 2 + rect1.MaxY;

      rect2.MaxX = rect1.MaxX;
      rect2.MaxY = rect1.MaxY;
      }
   else
      {
      rect1.MinX = IMAGEX + 2;
      rect1.MinY = IMAGEY + 2;
      rect1.MaxX = IMAGEW - 2;
      rect1.MaxY = IMAGEH / 2 - 6;

      rect2.MinX = IMAGEX + 2;
      rect2.MinY = IMAGEY + 6 + IMAGEH / 2 + rect1.MaxY;
      rect2.MaxX = IMAGEW - 2;
      rect2.MaxY = IMAGEH / 2 - 6;
      }

   if (gotPalette == FALSE)
      {
      DrawImage( IcWnd->RPort, image, rect1.MinX, rect1.MinY );
      DrawImage( IcWnd->RPort, altim, rect2.MinX, rect2.MinY );
      }
   else
      {
      // This should make the Icon display with the correct colors:
      (void) LayoutIcon( diskObj, Scr, OBP_Precision, PRECISION_EXACT, TAG_DONE );
    
      DrawIconState( IcWnd->RPort, diskObj, NULL,
                     rect1.MinX, rect1.MinY,
                     IDS_NORMAL, 
                     ICONDRAWA_Borderless,      TRUE, 
                     ICONDRAWA_EraseBackground, FALSE,
                     TAG_DONE
                   );

      DrawIconState( IcWnd->RPort, diskObj, NULL,
                     rect2.MinX, rect2.MinY, 
                     IDS_SELECTED, 
                     ICONDRAWA_Borderless,      TRUE, 
                     ICONDRAWA_EraseBackground, FALSE,
                     TAG_DONE
                   );
      }

   if (openedIconBase == TRUE)
      {
#     ifdef __amigaos4__
      DropInterface( (struct Interface *) IIcon ); 
#     endif

      CloseLibrary( IconBase );
      }
      
   return( 0 );
}

// TTTT For Tool Icons: TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

#define TIStkSz    0
#define TIToolsLV  1
#define TIOkayBt   2
#define TIGCoords  3
#define TIILoc     4

#define TI_CNT     5

PRIVATE struct Gadget *TIGadgets[ TI_CNT ] = { NULL, };

PRIVATE UWORD  TILeft   = 30;
PRIVATE UWORD  TITop    = 16;
PRIVATE UWORD  TIWidth  = 550;
PRIVATE UWORD  TIHeight = 330;

PUBLIC  UBYTE *TIWdt    = NULL; // ID_TOOL_WTITLE;


PUBLIC struct IntuiText TIIText[] = {

   2, 0, JAM1,  71,  9, NULL, NULL, NULL,
   2, 0, JAM1, 438, 10, NULL, NULL, NULL 
};

#define TI_TNUM 2

PRIVATE UWORD TIGTypes[ TI_CNT ] = {

   NUMBER_KIND, LISTVIEW_KIND, BUTTON_KIND,
   TEXT_KIND,   TEXT_KIND
};

PRIVATE int TIOkayBtClicked(  void );

PUBLIC struct NewGadget TINGad[ TI_CNT ] = {

   160,  62,  61,  18, NULL, NULL, TIStkSz, 
   PLACETEXT_LEFT, NULL, NULL,

     6, 100, 319, 208, NULL, NULL, TIToolsLV, 
   PLACETEXT_ABOVE, NULL, NULL,

   210, 308,  63,  18, NULL, NULL, TIOkayBt, 
   PLACETEXT_IN, NULL, (APTR) TIOkayBtClicked,

   160,  19,  81,  17, NULL, NULL, TIGCoords, 
   PLACETEXT_LEFT, NULL, NULL,

   160,  40,  81,  17, NULL, NULL, TIILoc, PLACETEXT_LEFT, NULL, NULL
};

PRIVATE ULONG TIGTags[] = {

   GTNM_Border, FALSE, TAG_DONE,

   GTLV_ReadOnly, TRUE, LAYOUTA_Spacing, 2, TAG_DONE,

   GT_Underscore, UNDERSCORE_CHAR, TAG_DONE,

   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE
};

// -------------------------------------------------------------------

PRIVATE int TIOkayBtClicked( void )
{
   CloseIcWindow();
   
   return( FALSE );
}

PRIVATE void TIRender( void )
{
   struct IntuiText it;
   UWORD            cnt;

   ComputeFont( Scr, Font, &CFont, TIWidth, TIHeight );

   DrawBevelBox( IcWnd->RPort, 
                 CFont.OffX + ComputeX( CFont.FontX, IMAGEX ),
                 CFont.OffY + ComputeY( CFont.FontY, IMAGEY ),
                 ComputeX( CFont.FontX, IMAGEW ),
                 ComputeY( CFont.FontY, IMAGEH ),
                 GT_VisualInfo, VisualInfo, 
                 GTBB_Recessed, TRUE,
                 TAG_DONE
               );

   for ( cnt = 0; cnt < TI_TNUM; cnt++ ) 
      {
      CopyMem( (char *) &TIIText[ cnt ], (char *) &it,
               (long) sizeof( struct IntuiText )
             );

      it.ITextFont = Font;
      it.LeftEdge  = CFont.OffX + ComputeX( CFont.FontX, it.LeftEdge )
                     - (IntuiTextLength( &it ) >> 1);

      it.TopEdge   = CFont.OffY + ComputeY( CFont.FontY, it.TopEdge ) 
                     - (Font->ta_YSize >> 1);

      PrintIText( IcWnd->RPort, &it, 0, 0 );
      }

   return;
}

PRIVATE int OpenTIWindow( char *iconName )
{
   struct NewGadget  ng;
   struct Gadget    *g;
   UWORD             lc, tc;
   UWORD             wleft = TILeft, wtop = TITop, ww, wh;

   CorrectTitle( TIWdt, iconName );
   
   ComputeFont( Scr, Font, &CFont, TIWidth, TIHeight );

   ww = ComputeX( CFont.FontX, TIWidth );
   wh = ComputeY( CFont.FontY, TIHeight );

   if ((wleft + ww + CFont.OffX + Scr->WBorRight) > Scr->Width) 
      wleft = Scr->Width - ww;

   if ((wtop + wh + CFont.OffY + Scr->WBorBottom) > Scr->Height)
      wtop = Scr->Height - wh;

   if (!(IcFont = OpenDiskFont( Font ))) // == NULL)
      return( -5 );

   if (!(g = CreateContext( &IcGList ))) // == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < TI_CNT; lc++) 
      {
      CopyMem( (char *) &TINGad[ lc ], (char *) &ng,
               (long) sizeof( struct NewGadget )
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = Font;
      
      ng.ng_LeftEdge   = CFont.OffX + ComputeX( CFont.FontX,
                                                ng.ng_LeftEdge
                                              );
      
      ng.ng_TopEdge    = CFont.OffY + ComputeY( CFont.FontY, 
                                                ng.ng_TopEdge
                                              );
      
      ng.ng_Width      = ComputeX( CFont.FontX, ng.ng_Width );
      ng.ng_Height     = ComputeY( CFont.FontY, ng.ng_Height);

      TIGadgets[ lc ] = g 
                      = CreateGadgetA( (ULONG) TIGTypes[ lc ], 
                                       g, 
                                       &ng, 
                                       (struct TagItem *) &TIGTags[ tc ] 
                                     );

      while (TIGTags[ tc ] != TAG_DONE)
         tc += 2;

      tc++;

      if (!g) // == NULL)
         return( -2 );
      }

   if (!(IcWnd = OpenWindowTags( NULL,

                  WA_Left,      wleft,
                  WA_Top,       wtop,
                  WA_Width,     ww + CFont.OffX + Scr->WBorRight,
                  WA_Height,    wh + CFont.OffY + Scr->WBorBottom,
                
                  WA_IDCMP,     NUMBERIDCMP | LISTVIEWIDCMP | BUTTONIDCMP
                    | TEXTIDCMP | IDCMP_VANILLAKEY | IDCMP_REFRESHWINDOW,
                
                  WA_Flags,     WFLG_DRAGBAR | WFLG_DEPTHGADGET 
                    | WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_RMBTRAP,
                
                  WA_Gadgets,   IcGList,
                  WA_Title,     IcWdt,
                  WA_PubScreen,   Scr,

                  TAG_DONE )
      )) // == NULL)
      return( -4 );

   GT_RefreshWindow( IcWnd, NULL );

   TIRender();

   return( 0 );
}

PRIVATE int HandleTIIDCMP( void )
{
   struct IntuiMessage *m;
   int                (*func)( void );
   BOOL                 running = TRUE;

   while (running == TRUE)
      {
      if (!(m = GT_GetIMsg( IcWnd->UserPort ))) // == NULL) 
         {
         (void) Wait( 1L << IcWnd->UserPort->mp_SigBit );

         continue;
         }

      CopyMem( (char *) m, (char *) &IcMsg, 
               (long) sizeof( struct IntuiMessage )
             );

      GT_ReplyIMsg( m );

      switch (IcMsg.Class) 
         {
         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( IcWnd );
              TIRender();
            GT_EndRefresh( IcWnd, TRUE );
            break;

         case IDCMP_VANILLAKEY:
            running = IcVanillaKey( IcMsg.Code );
            break;

         case IDCMP_GADGETUP:
         case IDCMP_GADGETDOWN:
            func = (int (*)( void )) ((struct Gadget *) IcMsg.IAddress)->UserData;

            if (func) // != NULL)
               running = func();
            
            break;
         }
      }

   return( running );
}

SUBFUNC void SetToolGadgets( DOPTR diskObj, int toolcount )
{
   char coords[32] = { 0, }, loc[12] = { 0, };
   
   GT_SetGadgetAttrs( TIGadgets[ TIStkSz ], IcWnd, NULL,
                      GTNM_Number, diskObj->do_StackSize, TAG_DONE 
                    );

   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_Gadget.LeftEdge,
                    diskObj->do_Gadget.TopEdge,
                    diskObj->do_Gadget.Width,
                    diskObj->do_Gadget.Height
          );

   GT_SetGadgetAttrs( TIGadgets[ TIGCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   sprintf( loc, "(%4d,%4d)", 
                 diskObj->do_CurrentX,
                 diskObj->do_CurrentY
          );

   GT_SetGadgetAttrs( TIGadgets[ TIILoc ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &loc[0], TAG_DONE
                    );

   HideListFromView( TIGadgets[ TIToolsLV ], IcWnd );

   CopyToolTypes( lvm->lvm_NodeStrs, diskObj, toolcount );
      
   ModifyListView( TIGadgets[ TIToolsLV ], IcWnd, &TList, NULL );
   
   return;
}

PRIVATE int DisplayToolInfo( DOPTR diskobject, char *iconName )
{
   int toolcount = CountTools( diskobject->do_ToolTypes );

   if (!(lvm = Guarded_AllocLV( toolcount, TOOLSIZE ))) // == NULL)
      {
      ReportAllocLVError();
      }

   SetupList( &TList, lvm );
         
   LayoutIconA( diskobject, NULL, NULL ); // Fix Icon Colors??
   
   if (OpenTIWindow( iconName ) < 0)
      {
      NotOpened( 1 ); // IconCMsg( MSG_ID_ICONINFODSP_ICONDSP ) );

      return( -1 );
      }

   SetToolGadgets( diskobject, toolcount );

   (void) ShowIconImages( diskobject );
         
   (void) HandleTIIDCMP();
   
   CloseIcWindow();

   Guarded_FreeLV( lvm );
      
   return( 0 );
}

// TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

// PPPPP For Project, Device, Kick & AppIcon  Icons: PPPPPPPPPPPPPPPPPP

#define PIStkSz    0
#define PIToolsLV  1
#define PIOkayBt   2
#define PIGCoords  3
#define PIILoc     4
#define PIDefTool  5

#define PI_CNT     6

PRIVATE struct Gadget *PIGadgets[ PI_CNT ] = { NULL, };

PRIVATE UWORD  PILeft   = 30;
PRIVATE UWORD  PITop    = 16;
PRIVATE UWORD  PIWidth  = 550;
PRIVATE UWORD  PIHeight = 365;
PUBLIC  UBYTE *PIWdt    = NULL; // ID_PROJ_WTITLE;


PUBLIC struct IntuiText PIIText[] = {

   2, 0, JAM1,  79,  9, NULL, NULL, NULL,
   2, 0, JAM1, 438, 10, NULL, NULL, NULL 
};

#define PI_TNUM 2

PRIVATE UWORD PIGTypes[ PI_CNT ] = {

   NUMBER_KIND, LISTVIEW_KIND, BUTTON_KIND,
   TEXT_KIND,   TEXT_KIND,     TEXT_KIND
};

PRIVATE int PIOkayBtClicked( void );

PUBLIC struct NewGadget PINGad[ PI_CNT ] = {

   152, 100,  61,  18, NULL, NULL, PIStkSz, 
   PLACETEXT_LEFT, NULL, NULL,

     6, 132, 319, 208, NULL, NULL, PIToolsLV, 
   PLACETEXT_ABOVE, NULL, NULL,

   212, 343,  63,  18, NULL, NULL, PIOkayBt, 
   PLACETEXT_IN, NULL, (APTR) PIOkayBtClicked,

   152,  58,  81,  17, NULL, NULL, PIGCoords, 
   PLACETEXT_LEFT, NULL, NULL,

   152,  79,  81,  17, NULL, NULL, PIILoc, 
   PLACETEXT_LEFT, NULL, NULL,

     3,  36, 321,  17, NULL, NULL, PIDefTool, PLACETEXT_ABOVE, NULL, NULL
};

PRIVATE ULONG PIGTags[] = {

   GTNM_Border, FALSE, TAG_DONE,
   
   GTLV_ReadOnly, TRUE, LAYOUTA_Spacing, 2, TAG_DONE,
   
   GT_Underscore, UNDERSCORE_CHAR, TAG_DONE,
   
   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, TRUE, TAG_DONE
};

// --------------------------------------------------------------------

PRIVATE int PIOkayBtClicked( void )
{
   CloseIcWindow();
   
   return( FALSE );
}

PRIVATE void PIRender( void )
{
   struct IntuiText it;
   UWORD            cnt;

   ComputeFont( Scr, Font, &CFont, PIWidth, PIHeight );

   DrawBevelBox( IcWnd->RPort, 
                 CFont.OffX + ComputeX( CFont.FontX, IMAGEX ),
                 CFont.OffY + ComputeY( CFont.FontY, IMAGEY ),
                 ComputeX( CFont.FontX, IMAGEW ),
                 ComputeY( CFont.FontY, IMAGEH ),
                 GT_VisualInfo, VisualInfo,
                 GTBB_Recessed, TRUE,
                 TAG_DONE
               );

   for (cnt = 0; cnt < PI_TNUM; cnt++) 
      {
      CopyMem( (char *) &PIIText[ cnt ], (char *) &it,
               (long) sizeof( struct IntuiText )
             );

      it.ITextFont = Font;
      
      it.LeftEdge  = CFont.OffX + ComputeX( CFont.FontX, it.LeftEdge ) 
                     - (IntuiTextLength( &it ) >> 1);
      
      it.TopEdge   = CFont.OffY + ComputeY( CFont.FontY, it.TopEdge ) 
                     - (Font->ta_YSize >> 1);

      PrintIText( IcWnd->RPort, &it, 0, 0 );
      }

   return;
}

PRIVATE int OpenPIWindow( char *iconName )
{
   struct NewGadget  ng;
   struct Gadget    *g;
   UWORD             lc, tc;
   UWORD             wleft = PILeft, wtop = PITop, ww, wh;

   CorrectTitle( PIWdt, iconName );
   
   ComputeFont( Scr, Font, &CFont, PIWidth, PIHeight );

   ww = ComputeX( CFont.FontX, PIWidth );
   wh = ComputeY( CFont.FontY, PIHeight );

   if ((wleft + ww + CFont.OffX + Scr->WBorRight) > Scr->Width) 
      wleft = Scr->Width - ww;

   if ((wtop + wh + CFont.OffY + Scr->WBorBottom) > Scr->Height) 
      wtop = Scr->Height - wh;

   if (!(IcFont = OpenDiskFont( Font ))) // == NULL)
      return( -5 );

   if (!(g = CreateContext( &IcGList ))) // == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < PI_CNT; lc++)
      {
      CopyMem( (char *) &PINGad[ lc ], (char *) &ng,
               (long) sizeof( struct NewGadget )
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = Font;

      ng.ng_LeftEdge   = CFont.OffX + ComputeX( CFont.FontX, 
                                                ng.ng_LeftEdge
                                              );

      ng.ng_TopEdge    = CFont.OffY + ComputeY( CFont.FontY, 
                                                ng.ng_TopEdge
                                              );

      ng.ng_Width      = ComputeX( CFont.FontX, ng.ng_Width );
      ng.ng_Height     = ComputeY( CFont.FontY, ng.ng_Height);

      PIGadgets[ lc ] = g 
                      = CreateGadgetA( (ULONG) PIGTypes[ lc ], 
                                       g, 
                                       &ng, 
                                       (struct TagItem *) &PIGTags[ tc ]
                                     );

      while (PIGTags[ tc ] != TAG_DONE) 
         tc += 2;

      tc++;

      if (!g) // == NULL)
         return( -2 );
      }

   if (!(IcWnd = OpenWindowTags( NULL,

                  WA_Left,      wleft,
                  WA_Top,       wtop,
                  WA_Width,     ww + CFont.OffX + Scr->WBorRight,
                  WA_Height,    wh + CFont.OffY + Scr->WBorBottom,
                  
                  WA_IDCMP,     NUMBERIDCMP | LISTVIEWIDCMP | BUTTONIDCMP
                    | TEXTIDCMP | IDCMP_VANILLAKEY | IDCMP_REFRESHWINDOW,
                  
                  WA_Flags,     WFLG_DRAGBAR | WFLG_DEPTHGADGET
                    | WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_RMBTRAP,
                  
                  WA_Gadgets,   IcGList,
                  WA_Title,     IcWdt,
                  WA_PubScreen,	Scr,
                  TAG_DONE )
      
      )) // == NULL)
      return( -4 );

   GT_RefreshWindow( IcWnd, NULL );

   PIRender();

   return( 0 );
}

PRIVATE int HandlePIIDCMP( void )
{
   struct IntuiMessage *m;
   int                (*func)( void );
   BOOL                 running = TRUE;

   while (running == TRUE)
      {
      if (!(m = GT_GetIMsg( IcWnd->UserPort ))) // == NULL) 
         {
         (void) Wait( 1L << IcWnd->UserPort->mp_SigBit );

         continue;
         }

      CopyMem( (char *) m, (char *) &IcMsg, 
               (long) sizeof( struct IntuiMessage )
             );

      GT_ReplyIMsg( m );

      switch (IcMsg.Class)
         {
         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( IcWnd );
              PIRender();
            GT_EndRefresh( IcWnd, TRUE );
            break;

         case IDCMP_VANILLAKEY:
            running = IcVanillaKey( IcMsg.Code );
            break;

         case IDCMP_GADGETUP:
         case IDCMP_GADGETDOWN:
            func = (int (*)( void )) ((struct Gadget *) IcMsg.IAddress)->UserData;

            if (func) // != NULL)
               running = func();
		
            break;
         }
      }
	
   return( running );
}

SUBFUNC void SetProjectGadgets( DOPTR diskObj, int toolcount )
{
   char coords[32] = { 0, }, loc[12] = { 0, };
   
   GT_SetGadgetAttrs( PIGadgets[ PIStkSz ], IcWnd, NULL,
                      GTNM_Number, diskObj->do_StackSize, TAG_DONE 
                    );

   GT_SetGadgetAttrs( PIGadgets[ PIDefTool ], IcWnd, NULL,
                      GTTX_Text, diskObj->do_DefaultTool, TAG_DONE 
                    );

   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_Gadget.LeftEdge,
                    diskObj->do_Gadget.TopEdge,
                    diskObj->do_Gadget.Width,
                    diskObj->do_Gadget.Height
          );

   GT_SetGadgetAttrs( PIGadgets[ PIGCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   sprintf( loc, "(%4d,%4d)", 
                 diskObj->do_CurrentX,
                 diskObj->do_CurrentY
          );

   GT_SetGadgetAttrs( PIGadgets[ PIILoc ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &loc[0], TAG_DONE
                    );

   HideListFromView( PIGadgets[ PIToolsLV ], IcWnd );

   CopyToolTypes( lvm->lvm_NodeStrs, diskObj, toolcount );
      
   ModifyListView( PIGadgets[ PIToolsLV ], IcWnd, &TList, NULL );
   
   return;
}

PUBLIC UBYTE *prjIText = NULL;
PUBLIC UBYTE *devIText = NULL;
PUBLIC UBYTE *kckIText = NULL;
PUBLIC UBYTE *appIText = NULL;

PRIVATE int DisplayProjectIcon( DOPTR diskobject, char *iconName, int type )
{
   int toolcount = CountTools( diskobject->do_ToolTypes );

   switch (type)
      {
      case WBPROJECT:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_PROJ_WTITLE_ICONDSP ), 80 );
         PIIText[0].IText = prjIText;
         break;
         
      case WBDEVICE:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_DEVC_WTITLE_ICONDSP ), 80 );
         PIIText[0].IText = devIText;
         break;
         
      case WBKICK:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_KICK_WTITLE_ICONDSP ), 80 );
         PIIText[0].IText = kckIText;
         break;
         
      case WBAPPICON:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_APPI_WTITLE_ICONDSP ), 80 );
         PIIText[0].IText = appIText;
         break;
      
      default:   
         break;
      }

   if (!(lvm = Guarded_AllocLV( toolcount, TOOLSIZE ))) // == NULL)
      {
      ReportAllocLVError();
      }

   SetupList( &TList, lvm );
         
   if (OpenPIWindow( iconName ) < 0)
      {
      NotOpened( 1 ); // IconCMsg( MSG_ID_ICONINFODSP_ICONDSP ) );

      return( -1 );
      }

   SetProjectGadgets( diskobject, toolcount );

   (void) ShowIconImages( diskobject );
         
   (void) HandlePIIDCMP();
   
   CloseIcWindow();

   Guarded_FreeLV( lvm );
      
   return( 0 );
} 

// PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP

// DDDDD For Disk & Drawer Icons: DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

#define DIOkayBt   0
#define DIGCoords  1
#define DIILoc     2
#define DIWCoords  3
#define DIDefTool  4

#define DI_CNT     5

PRIVATE struct Gadget *DIGadgets[ DI_CNT ] = { NULL, };

PRIVATE UWORD  DILeft   = 30;
PRIVATE UWORD  DITop    = 16;
PRIVATE UWORD  DIWidth  = 550;
PRIVATE UWORD  DIHeight = 310;
PUBLIC  UBYTE *DIWdt    = NULL; // ID_DISK_WTITLE;

PUBLIC struct IntuiText DIIText[] = {

   2, 0, JAM1,  79,  9, NULL, NULL, NULL,
   2, 0, JAM1, 438, 10, NULL, NULL, NULL 
};

#define DI_TNUM 2

PRIVATE UWORD DIGTypes[ DI_CNT ] = {

   BUTTON_KIND, TEXT_KIND, TEXT_KIND,
   TEXT_KIND,   TEXT_KIND
};

PRIVATE int DIOkayBtClicked( void );

PUBLIC struct NewGadget DINGad[ DI_CNT ] = {

   193, 286,  63, 18, NULL, NULL, DIOkayBt, 
   PLACETEXT_IN, NULL, (APTR) DIOkayBtClicked,

   157,  63,  81, 17, NULL, NULL, DIGCoords, 
   PLACETEXT_LEFT, NULL, NULL,

   157,  91,  81, 17, NULL, NULL, DIILoc, 
   PLACETEXT_LEFT, NULL, NULL,
 
   157, 120,  81, 17, NULL, NULL, DIWCoords, 
   PLACETEXT_LEFT, NULL, NULL,
 
     6,  39, 318, 17, NULL, NULL, DIDefTool, 
   PLACETEXT_ABOVE, NULL, NULL
};

PRIVATE ULONG DIGTags[] = {

   GT_Underscore, UNDERSCORE_CHAR, TAG_DONE,

   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE,

   GTTX_Border, TRUE, TAG_DONE
};

// ------------------------------------------------------------------

PRIVATE int DIOkayBtClicked( void )
{
   CloseIcWindow();

   return( FALSE );
}

PRIVATE void DIRender( void )
{
   struct IntuiText it;
   UWORD            cnt;

   ComputeFont( Scr, Font, &CFont, DIWidth, DIHeight );

   DrawBevelBox( IcWnd->RPort, 
                 CFont.OffX + ComputeX( CFont.FontX, IMAGEX ),
                 CFont.OffY + ComputeY( CFont.FontY, IMAGEY ),
                 ComputeX( CFont.FontX, IMAGEW ),
                 ComputeY( CFont.FontY, IMAGEH ),
                 GT_VisualInfo, VisualInfo,
                 GTBB_Recessed, TRUE,
                 TAG_DONE
               );

   for (cnt = 0; cnt < DI_TNUM; cnt++) 
      {
      CopyMem( (char *) &DIIText[ cnt ], (char *) &it,
               (long) sizeof( struct IntuiText )
             );

      it.ITextFont = Font;

      it.LeftEdge  = CFont.OffX + ComputeX( CFont.FontX, it.LeftEdge ) 
                     - (IntuiTextLength( &it ) >> 1);

      it.TopEdge   = CFont.OffY + ComputeY( CFont.FontY, it.TopEdge ) 
                     - (Font->ta_YSize >> 1);

      PrintIText( IcWnd->RPort, &it, 0, 0 );
      }

   return;
}

PRIVATE int OpenDIWindow( char *iconName, int gcount )
{
   struct NewGadget  ng;
   struct Gadget    *g;
   UWORD             lc, tc;
   UWORD             wleft = DILeft, wtop = DITop, ww, wh;

   CorrectTitle( DIWdt, iconName );
   
   ComputeFont( Scr, Font, &CFont, DIWidth, DIHeight );

   ww = ComputeX( CFont.FontX, DIWidth );
   wh = ComputeY( CFont.FontY, DIHeight );

   if ((wleft + ww + CFont.OffX + Scr->WBorRight) > Scr->Width) 
      wleft = Scr->Width - ww;

   if ((wtop + wh + CFont.OffY + Scr->WBorBottom) > Scr->Height) 
      wtop = Scr->Height - wh;

   if (!(IcFont = OpenDiskFont( Font ))) // == NULL)
      return( -5 );

   if (!(g = CreateContext( &IcGList ))) // == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < gcount; lc++) 
      {
      CopyMem( (char *) &DINGad[ lc ], (char *) &ng,
               (long) sizeof( struct NewGadget )
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = Font;

      ng.ng_LeftEdge   = CFont.OffX + ComputeX( CFont.FontX,
                                                ng.ng_LeftEdge
                                              );

      ng.ng_TopEdge    = CFont.OffY + ComputeY( CFont.FontY,
                                                ng.ng_TopEdge
                                              );

      ng.ng_Width      = ComputeX( CFont.FontX, ng.ng_Width );
      ng.ng_Height     = ComputeY( CFont.FontY, ng.ng_Height);

      DIGadgets[ lc ] = g 
                      = CreateGadgetA( (ULONG) DIGTypes[ lc ], 
                                       g, 
                                       &ng, 
                                       (struct TagItem *) &DIGTags[ tc ]
                                     );

      while (DIGTags[ tc ] != TAG_DONE)
         tc += 2;
      
      tc++;

      if (!g) // == NULL)
         return( -2 );
      }

   if (!(IcWnd = OpenWindowTags( NULL,

                  WA_Left,       wleft,
                  WA_Top,        wtop,
                  WA_Width,      ww + CFont.OffX + Scr->WBorRight,
                  WA_Height,     wh + CFont.OffY + Scr->WBorBottom,

                  WA_IDCMP,      BUTTONIDCMP | TEXTIDCMP | IDCMP_GADGETDOWN
                    | IDCMP_INTUITICKS | IDCMP_MOUSEMOVE 
                    | IDCMP_MOUSEBUTTONS | IDCMP_VANILLAKEY
                    | IDCMP_REFRESHWINDOW,

                  WA_Flags,      WFLG_DRAGBAR | WFLG_DEPTHGADGET 
                    | WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_RMBTRAP,

                  WA_Gadgets,    IcGList,
                  WA_Title,      IcWdt,
                  WA_PubScreen,	Scr,
                  TAG_DONE )
      
      )) // == NULL)
      return( -4 );

   GT_RefreshWindow( IcWnd, NULL );

   DIRender();

   return( 0 );
}

PRIVATE int HandleDIIDCMP( void )
{
   struct IntuiMessage  *m;
   int                 (*func)( void );
   BOOL	                 running = TRUE;

   while (running == TRUE)
      {
      if (!(m = GT_GetIMsg( IcWnd->UserPort ))) // == NULL) 
         {
         (void) Wait( 1L << IcWnd->UserPort->mp_SigBit );

         continue;
         }

      CopyMem( (char *) m, (char *) &IcMsg, 
               (long) sizeof( struct IntuiMessage )
             );

      GT_ReplyIMsg( m );

      switch (IcMsg.Class)
         {
         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( IcWnd );
              DIRender();
            GT_EndRefresh( IcWnd, TRUE );
            break;

         case IDCMP_VANILLAKEY:
            running = IcVanillaKey( IcMsg.Code );
            break;

         case IDCMP_GADGETUP:
         case IDCMP_GADGETDOWN:
            func = (int (*)( void )) ((struct Gadget *) IcMsg.IAddress)->UserData;

            if (func) // != NULL)
               running = func();

            break;
         }
      }

   return( running );
}

SUBFUNC void SetDiskGadgets( DOPTR diskObj )
{
   char coords[32] = { 0, }, loc[12] = { 0, };
   
   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_Gadget.LeftEdge,
                    diskObj->do_Gadget.TopEdge,
                    diskObj->do_Gadget.Width,
                    diskObj->do_Gadget.Height
          );

   GT_SetGadgetAttrs( DIGadgets[ DIGCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   sprintf( loc, "(%4d,%4d)", 
                 diskObj->do_CurrentX,
                 diskObj->do_CurrentY
          );

   GT_SetGadgetAttrs( DIGadgets[ DIILoc ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &loc[0], TAG_DONE
                    );

   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_DrawerData->dd_NewWindow.LeftEdge,
                    diskObj->do_DrawerData->dd_NewWindow.TopEdge,
                    diskObj->do_DrawerData->dd_NewWindow.Width,
                    diskObj->do_DrawerData->dd_NewWindow.Height
          );

   GT_SetGadgetAttrs( DIGadgets[ DIWCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   return;
}

PUBLIC UBYTE *dskIText = NULL;
PUBLIC UBYTE *drwIText = NULL;

PRIVATE int DisplayDiskIcon( DOPTR diskobject, char *iconName, int type )
{
   int gcount = DI_CNT;
   
   switch (type)
      {
      case WBDISK:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_DISK_WTITLE_ICONDSP ), 80 );
         DIIText[0].IText = dskIText;
         break;
         
      case WBDRAWER:
         StringNCopy( PIWdt, IconCMsg( MSG_ID_DRAW_WTITLE_ICONDSP ), 80 );
         DIIText[0].IText = drwIText;
         gcount           = DI_CNT - 1; // Kill DefaultTool Gadget.
         break;
         
      default:   
         break;
      }
      
   if (OpenDIWindow( iconName, gcount ) < 0)
      {
      NotOpened( 1 ); // IconCMsg( MSG_ID_ICONINFODSP_ICONDSP ) );

      return( -1 );
      }

   if (type == WBDISK)
      SetDiskGadgets( diskobject );
   else
      {
      SetDiskGadgets( diskobject );

      GT_SetGadgetAttrs( DIGadgets[ DIDefTool ], IcWnd, NULL,
                         GTTX_Text, diskobject->do_DefaultTool, TAG_DONE 
                       );
      }
               
   (void) ShowIconImages( diskobject );
         
   (void) HandleDIIDCMP();
   
   CloseIcWindow();
   
   return( 0 );
} 

// DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD

// CCCCC For TrashCan Icons: CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC

#define CIOkayBt   0
#define CIGCoords  1
#define CIILoc     2
#define CIWCoords  3

#define CI_CNT     4

PRIVATE struct Gadget *CIGadgets[ CI_CNT ] = { NULL, };

PRIVATE UWORD  CILeft   = 30;
PRIVATE UWORD  CITop    = 16;
PRIVATE UWORD  CIWidth  = 550;
PRIVATE UWORD  CIHeight = 310;
PUBLIC  UBYTE *CIWdt    = NULL; // ID_TRSH_WTITLE;

PUBLIC struct IntuiText CIIText[] = {

   2, 0, JAM1,  85,  9, NULL, NULL, NULL,
   2, 0, JAM1, 438, 10, NULL, NULL, NULL
};

#define CI_TNUM 2

PRIVATE UWORD CIGTypes[ CI_CNT ] = {

   BUTTON_KIND, TEXT_KIND, TEXT_KIND, TEXT_KIND
};

PRIVATE int CIOkayBtClicked( void );

PUBLIC struct NewGadget CINGad[ CI_CNT ] = {
 
   185, 282, 63, 18, NULL, NULL, CIOkayBt, 
   PLACETEXT_IN, NULL, (APTR) CIOkayBtClicked,

   160,  23, 81, 17, NULL, NULL, CIGCoords, 
   PLACETEXT_LEFT, NULL, NULL,

   160,  45, 61, 17, NULL, NULL, CIILoc, 
   PLACETEXT_LEFT, NULL, NULL,

   160,  68, 81, 17, NULL, NULL, CIWCoords, 
   PLACETEXT_LEFT, NULL, NULL
};

PRIVATE ULONG CIGTags[] = {

   GT_Underscore, UNDERSCORE_CHAR, TAG_DONE,

   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE,
   GTTX_Border, FALSE, TAG_DONE
};   

// ------------------------------------------------------------------

PRIVATE int CIOkayBtClicked( void )
{
   CloseIcWindow();

   return( FALSE );
}

PRIVATE void CIRender( void )
{
   struct IntuiText it;
   UWORD            cnt;

   ComputeFont( Scr, Font, &CFont, CIWidth, CIHeight );

   DrawBevelBox( IcWnd->RPort, 
                 CFont.OffX + ComputeX( CFont.FontX, IMAGEX ),
                 CFont.OffY + ComputeY( CFont.FontY, IMAGEY ),
                 ComputeX( CFont.FontX, IMAGEW ),
                 ComputeY( CFont.FontY, IMAGEH ),
                 GT_VisualInfo, VisualInfo,
                 GTBB_Recessed, TRUE,
                 TAG_DONE
               );

   for (cnt = 0; cnt < CI_TNUM; cnt++)
      {
      CopyMem( (char *) &CIIText[ cnt ], (char *) &it,
               (long) sizeof( struct IntuiText )
             );

      it.ITextFont = Font;
      
      it.LeftEdge  = CFont.OffX + ComputeX( CFont.FontX, it.LeftEdge )
                     - (IntuiTextLength( &it ) >> 1);
      
      it.TopEdge   = CFont.OffY + ComputeY( CFont.FontY, it.TopEdge )
                     - (Font->ta_YSize >> 1);
      
      PrintIText( IcWnd->RPort, &it, 0, 0 );
      }

   return;
}

PRIVATE int OpenCIWindow( char *iconName )
{
   struct NewGadget  ng;
   struct Gadget    *g;
   UWORD             lc, tc;
   UWORD             wleft = CILeft, wtop = CITop, ww, wh;

   CorrectTitle( CIWdt, iconName );
   
   ComputeFont( Scr, Font, &CFont, CIWidth, CIHeight );

   ww = ComputeX( CFont.FontX, CIWidth );
   wh = ComputeY( CFont.FontY, CIHeight );

   if ((wleft + ww + CFont.OffX + Scr->WBorRight) > Scr->Width) 
      wleft = Scr->Width - ww;
   
   if ((wtop + wh + CFont.OffY + Scr->WBorBottom) > Scr->Height) 
      wtop = Scr->Height - wh;

   if (!(IcFont = OpenDiskFont( Font ))) // == NULL)
      return( -5 );

   if (!(g = CreateContext( &IcGList ))) // == NULL)
      return( -1 );

   for (lc = 0, tc = 0; lc < CI_CNT; lc++)
      {
      CopyMem( (char *) &CINGad[ lc ], (char *) &ng,
               (long) sizeof( struct NewGadget )
             );

      ng.ng_VisualInfo = VisualInfo;
      ng.ng_TextAttr   = Font;
      
      ng.ng_LeftEdge   = CFont.OffX + ComputeX( CFont.FontX,
                                                ng.ng_LeftEdge
                                              );
      
      ng.ng_TopEdge    = CFont.OffY + ComputeY( CFont.FontY,
                                                ng.ng_TopEdge
                                              );
      
      ng.ng_Width      = ComputeX( CFont.FontX, ng.ng_Width );
      ng.ng_Height     = ComputeY( CFont.FontY, ng.ng_Height);

      CIGadgets[ lc ] = g 
                      = CreateGadgetA( (ULONG) CIGTypes[ lc ],
                                       g, 
                                       &ng, 
                                       (struct TagItem *) &CIGTags[ tc ]
                                     );

      while (CIGTags[ tc ] != TAG_DONE)
         tc += 2;

      tc++;

      if (!g) // == NULL)
         return( -2 );
      }

   if (!(IcWnd = OpenWindowTags( NULL,

                  WA_Left,      wleft,
                  WA_Top,       wtop,
                  WA_Width,     ww + CFont.OffX + Scr->WBorRight,
                  WA_Height,    wh + CFont.OffY + Scr->WBorBottom,
                
                  WA_IDCMP,     BUTTONIDCMP | TEXTIDCMP | IDCMP_GADGETDOWN
                    | IDCMP_INTUITICKS | IDCMP_MOUSEMOVE
                    | IDCMP_MOUSEBUTTONS | IDCMP_VANILLAKEY
                    | IDCMP_REFRESHWINDOW,
                
                  WA_Flags,     WFLG_DRAGBAR | WFLG_DEPTHGADGET
                    | WFLG_SMART_REFRESH | WFLG_ACTIVATE | WFLG_RMBTRAP,

                  WA_Gadgets,     IcGList,
                  WA_Title,       IcWdt,
                  WA_PubScreen,	Scr,
                  TAG_DONE )
      )) // == NULL)
      return( -4 );

   GT_RefreshWindow( IcWnd, NULL );

   CIRender();

   return( 0 );
}

PRIVATE int HandleCIIDCMP( void )
{
   struct IntuiMessage *m;
   int                (*func)( void );
   BOOL	                running = TRUE;

   while (running == TRUE)
      {
      if (!(m = GT_GetIMsg( IcWnd->UserPort ))) // == NULL) 
         {
         (void) Wait( 1L << IcWnd->UserPort->mp_SigBit );

         continue;
         }

      CopyMem( (char *) m, (char *) &IcMsg,
               (long) sizeof( struct IntuiMessage )
             );

      GT_ReplyIMsg( m );

      switch (IcMsg.Class)
         {
         case IDCMP_REFRESHWINDOW:
            GT_BeginRefresh( IcWnd );
              CIRender();
            GT_EndRefresh( IcWnd, TRUE );
            break;

         case IDCMP_VANILLAKEY:
            running = IcVanillaKey( IcMsg.Code );
            break;

         case IDCMP_GADGETUP:
         case IDCMP_GADGETDOWN:
            func = (int (*) ( void )) ((struct Gadget *) IcMsg.IAddress)->UserData;

            if (func) // != NULL)
               running = func();

            break;
         }
      }

   return( running );
}

SUBFUNC void SetTrashCanGadgets( DOPTR diskObj )
{
   char coords[32] = { 0, }, loc[12] = { 0, };
   
   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_Gadget.LeftEdge,
                    diskObj->do_Gadget.TopEdge,
                    diskObj->do_Gadget.Width,
                    diskObj->do_Gadget.Height
          );

   GT_SetGadgetAttrs( CIGadgets[ CIGCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   sprintf( loc, "(%4d,%4d)", 
                 diskObj->do_CurrentX,
                 diskObj->do_CurrentY
          );

   GT_SetGadgetAttrs( CIGadgets[ CIILoc ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &loc[0], TAG_DONE
                    );

   sprintf( coords, "%4d,%4d,%4d,%4d", 
                    diskObj->do_DrawerData->dd_NewWindow.LeftEdge,
                    diskObj->do_DrawerData->dd_NewWindow.TopEdge,
                    diskObj->do_DrawerData->dd_NewWindow.Width,
                    diskObj->do_DrawerData->dd_NewWindow.Height
          );

   GT_SetGadgetAttrs( CIGadgets[ CIWCoords ], IcWnd, NULL,
                      GTTX_Text, (STRPTR) &coords[0], TAG_DONE
                    );

   return;
}

PRIVATE int DisplayTrashcanIcon( DOPTR diskobject, char *iconName )
{
   if (OpenCIWindow( iconName ) < 0)
      {
      NotOpened( 1 ); // IconCMsg( MSG_ID_ICONINFODSP_ICONDSP ) );

      return( -1 );
      }

   SetTrashCanGadgets( diskobject );

   (void) ShowIconImages( diskobject );
         
   (void) HandleCIIDCMP();
   
   CloseIcWindow();
   
   return( 0 );
} 

PUBLIC int IconInfoDisplay( DOPTR diskobject, char *iconName )
{
   int rval = RETURN_OK, type = diskobject->do_Type;
   
   switch (type)
      {
      case WBDISK:
      case WBDRAWER:
         rval = DisplayDiskIcon( diskobject, iconName, type );
         break;
         
      case WBTOOL:
         rval = DisplayToolInfo( diskobject, iconName );
         break;
         
      case WBPROJECT:
      case WBDEVICE:
      case WBKICK:
      case WBAPPICON:
         rval = DisplayProjectIcon( diskobject, iconName, type );
         break;

      case WBGARBAGE:
         rval = DisplayTrashcanIcon( diskobject, iconName );
         break;
      }
      
   return( rval );
}

/* --------------------- END of IconDsp.c file! ------------------- */
