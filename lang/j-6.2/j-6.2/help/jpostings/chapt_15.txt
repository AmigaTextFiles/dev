                                   Chapter 15

                           USING J : SOME APPLICATIONS


      analyzing complex verbs
      building arrays
      EEM responds about histograms
      polynomials in J
      Grade Down Columns of An Array
      WANTED: APL maximization function


*========================================
# analyzing complex verbs

+------------------
| Raul Deluth Miller-Rockwell
| <ROCKWELL.91Oct13200425@socrates.umd.edu>

Large programs in J demand some sort of mechanical assistance to cope
with them.  In particular, it is often very helpful to see exactly
what a verb is doing.

Attached is my first stab at anything like a debugger in J.  To use
it, you might first load up the code you wish to work with, then say:
   funs =. 4!:1, 3
   )sscript 'debug.js'
   ,' ''''".'' y. docify: '' ' : '' &> funs

[[NB. sws.  )sscript has been removed, use
   script=. 0!:2 &<
   sscript=. 0!:3 &<
   sscript 'debug.js'
]]
And then apply one of your test verbs to a [small] sample test object.

There are a number of inadequacies to the debug routines below.  They
should probably be organized differently.  The "undocify" utility
should probably invalidate the _orig_ version of the verb (to simplify
the process of updating the verb).  These utilities are only useful
for verb arguments.  These utilities have only been tested under 3.4,
and those tests have not been very extensive yet.  docify: and
undocify: might be more convenient if implemented as verbs instead of
adverbs.  Etc.

Also, I expect that these routines will not be useful for analyzing
themselves, so I tried to spread out the definitions so that they
might be read somewhat easier.  I doubt I've been successful.

Essentially, I use the hook ([ f) where f is a verb which creates side
effects (such as printing information about an argument), to
"transparently" document verbs while they are running.

Sample of use:
   )sscript 'j/debug2.js'
   test =. +/
   'test' docify:
   t =. test 1 2 3
entering 'test' integer $ 3
1 2 3

'test' integer $
6
   t
6
   'test' undocify:
   t =. test 1 2 3
   t
6

Here, both the argument and the result are integer.  The argument is a
vector of length three, and the result is a scalar.  If you used
'test' dyadically, you'd see both of the arguments as well as the
result.

I can think of lots of improvements (e.g. something to show the "level
of nesting" of debugged verbs), but I've been sitting on this for a
while already, and haven't been putting much time into upgrading it.
Feel free to make simplifications or improvements.

NB. sws.  edited to work under J 4.1

print:   =. 1!:2&2
read:    =. 1!:1
resolve: =. '(5!:1<x.)5!:0':1

eval:    =. ('''''".''r=.'',x.';'r') : 1
DEB:     =. #~ -.@('  '&E.)

NB. sws.   This was the original, but until doesn't work now...
NB. read_block: =. 0&=@#@] ` , ` (read:@(1"])) ` [ `: 1    ;&(0 1$' ')

NB.  sws.  this works, but just catenates togther
read_block: =.  ( ],(read:@(1"]))@] ) ^: (0&<@#@])

NB. sws this catenates and boxes stuff... not too elegant
r=. (read:@(1"]))
b=. 'y. ;~ (r <y.)' :11
u=. (0&<@#@>@ (0&{)@])
read_box: =. '|. _1 }. 1}. (b ^: u ) <y.' :11


NB. example:  d_type: 1 2
NB. "displayable" type of an object
NB. d_type:  =. (DEB:,' ',read_block: 99) : 11
d_type:  =. (DEB:,' ',read_block: ' ') : 11
   ' ' & ,
      @ >
      @ { & (;:'boolean literal integer floating complex boxed')
      @ ( ( <. 2 ^ i. 6)  & i.)
      @ (3!:0) y.

NB. example:  'label' p_label: 1 2
NB.  Print an arbitrary label, as well as the type and shape of argument
NB. p_label: =. (DEB:,' ',read_block: 99) :1
p_label: =. (DEB:,' ',read_block: ' ') :1
     print:@[
  print: @
  (' ' & ,: @
     (x.     & [
        ,
      d_type:
        ,
      '  $ ' & [
        ,
      ": @ $))

NB. example:  prefob: 'b'
NB.  Save verb 'name' as 'name_orig_', if not done yet.
NB.  Also return the alternate name (e.g. 'name_orig_')
prefob:  =. (read_box: 4) : ''
   o  =. y. , '_orig_'
   $. =. do }.~  0 < 4!:0 < o
do) (<o) =: y. resolve:
   o

NB.  Put quotes around a name (for emphasis)
enquote: =. ''''"], ], ''''"]

NB. example:  'b' docify:
NB.  Replace verb 'name' with a version which prints lots of
NB.  information about the arguments and the returned result.
NB. docify:  =. ('o=.prefob: x.' ; DEB:,' ',read_block: 99) :1
docify:  =. ('o=.prefob: x.' ; DEB:,' ',read_block: ' ') :1
   (<x.) =:
         (enquote: x.) p_label:
            @ (o resolve:)
            @ (('entering ',enquote: x.) p_label:)
   :
        (((enquote: x.),' x. ') p_label: @ [
            (enquote: x.) p_label: @ (o resolve:)
         ((enquote: x.),' y. ') p_label: @ ])
   "
      (o resolve:)

NB. example:  'b' undocify:
NB.  Undo the effects of docify:
undocify: =. ('o=. prefob: x.' ; '(<x.)=: o resolve:') :1


*========================================
# building arrays

+------------------
| Raul Rockwell
| <ROCKWELL.91Jun27004147@socrates.umd.edu>

If you build an array, recursively or iteratively, by catenating items
onto the array, it seems like J requires O(n^2) for array
construction.  If, instead of straight catenation, you use something
like ( cons=. ,&< ) you could construct a representation of the data
in O(n) time.  However, it is not readily apparent to me how to
convert such a representation into a flat array in linear time.

It might be possible to pull some stunts with enlist to remove all
structure, then using cut to restore structure, but I'm not sure how
fast enlist is (or how fast it ought to be).

Are there any good ways for dealing with this issue?


*========================================
#      EEM responds about histograms

+------------------
| Eugene McDonnell
| <1991Apr4.002028.24603@yrloc.ipsa.reuter.COM>


Given an array y of nonnegative integers, with maximum value x-1,
a histogram h giving the number of occurrences of each possible
value in the array may be obtained in J by:

    h =. <: , #/.~ (,y),i. x

By JOINING to the RAVEL of y a vector (i. x) of all possible
values, we are insured that the result contains a slot for each
possible value, whether it appears in y or not. This argument is
used (by virtue of the DUPLICATE adverb ~) as left and right
argument to COUNT (#) by KEY (/.), giving a count of the
occurrences of each possible value in the argument (the argument
is its own key). RAVELLING this and SUBTRACTING 1 (<:) from it
(to allow for the presence of i. x in the argument, which should
not add to the count) gives the desired result.


+------------------
| Joey Tuttle
| <1991Apr4.002052.24661@yrloc.ipsa.reuter.COM>


Nice trick -- as we discussed, this is something I have wanted to
do in APL for a long time.

When I tried your algorithm on (b=. ?64 64$466  -- the question off
of Net News that raised the issue) I got a ws full after 25 seconds
with j in a 2 meg partition on a Macintosh CX, not terribly
efficient (sigh).  Another thing I find uncomfortable about your
solution is the order of the result.  It has 0's in it for the
ordinal empty buckets (coming from JOINING the set of all values to
the argument) that makes sense, but the other values are in the
order they appear in the RAVEL of the array.  To make sense of the
result probably requires some sorting....  You can correct this
problem by putting the set of all values first, that and
eliminating the redundant ravel on the left of your expression
leaves

     h =. <: #/.~ (i.x),,y

Which produces a more understandable result.  On the other hand, if
you don't join all possible values to y, then at least the counts
appear in the nub order of y which seems reasonable.

Another advantage to not joining all possible values is that if the
possible number is large (e.g. 2^31, a common number) then it pays
not to count all the empty ones!  Clearly though,

     #/.~,y

is what I have asked for in the past in APL.  By making a special
performance case of (#/.~), a problem which has always been
"inappropriate for APL because of performance" could be solved very
nicely.  I suppose in a practical sense, I would want to associate
the result closely with the nub of y since a "real application"
like analysis of collected data would likely involve a very large
set of data and y would need to be segmented in a loop of some
kind.  Since the algorithm to do this probably generates a nub of
the set, perhaps it should be some varient of nub that returns the
nub and associated count.  Still leaves the interesting problem of
how to combine successive results...


+------------------
| Raul Rockwell
| <4APR91.20043819@uc780.umd.edu>

Joey Tuttle writes:
>
>     #/.~,y
>
>is what I have asked for in the past in APL.  By making a special
>performance case of (#/.~), a problem which has always been
>"inappropriate for APL because of performance" could be solved very
>nicely.

what's wrong with

    v =. /:, y
    k =. k # i. $k=. 1, (_1}.v) ~: 1}. v
 hist =. k - ($k){. 0,k

here, /:  is O(n log n)  (where n is the length of v)
and everything is is O(n)

Also note that k{v  is the nub of ,y

Yeah, this version will blow up if y is empty, but that is easily
handled (either as a special case, by coercing k, or by choosing a
different algorithm to check adjecency when computing k).



*========================================
# polynomials in J

+------------------
| Raul Rockwell
| <ROCKWELL.91Sep7172356@socrates.umd.edu>

Polynomials are a convenient way of representing a functions as data,
and J has a lot of stuff to support this kind of thing.  I've compiled
a batch of "polynomial" functions, and am presenting them here for
comment:

poly =. '':(#.|.)    "0 1

'poly' takes a polynomial (a list of coefficients) and some base
numbers and applies the polynomial to those arguments.  For example,
poly&1 2 1 would create a function equivalent to
'1 + (2*y.) + y.^2' : 11

Or, 10 100 poly 1 2 3
would yield 321 30201

Note that I've put the 'most significant' coeficients on the right.
This is an arbitrary decision.

padd =. +/@,:        "1

This one just adds polynomials:  1 1 padd 1 0 1 yields 2 1 1

psub =. -/@,:        "1

And, this one subtracts polynomials:  1 2 1 psub 1 1 yields 0 1 1

ptimes =. +//.@(*/)  "1

This multiplies polynomials:  1 2 1 ptimes 1 1 yields 1 3 3 1

read =. 1!:1
pdiv =. '':(read 4#1)&|.   "1
quotient =. i. 0
$. =. , (0 >. >: x. -&# y.=.,y.) # ,: $.
x. =. }. x. psub y. * divisor =. x. %&{. y.
quotient =. divisor,quotient

This one divides polynomials (and silently drops any remainder).  For
example, 1 3 3 1 pdiv 1 1  yields 1 2 1, or 1 4 3 pdiv 1 1 yields 1 3.
But also, 2 3 3 1 pdiv 1 1 yields 1 2 1.

pclean =. (i.&0@(0&=) }. ])&.]. "1

This function trims "high zeros" from a representation of a
polynomial.  Theoretically, I suppose, a polynomial could have a near
infinite quantity of zero coeficients.  Practically, when you have
several polynomials in a matrix, they tend to accumulate useless
zeros.  For example:
   [ p =. |: !/~ i. 4
1 0 0 0
1 1 0 0
1 2 1 0
1 3 3 1

   <@pclean p
+-+---+-----+-------+
|1|1 1|1 2 1|1 3 3 1|
+-+---+-----+-------+

pantibase =. ('':(read 9#1))  "2 1
antibase =. i. 0 0
k        =. #x.
$. =. , (#x.) # ,: $.
divisor   =. , (k =. k-1) { x.
quotient  =. y. pdiv divisor
nonzero   =. 0 ~: # pclean divisor
remainder =. pclean y. psub quotient ptimes^:nonzero divisor
y.        =. quotient [^:nonzero 0
antibase  =. remainder, antibase

This one is similar to antibase (#:), but works for polynomials
instead of scalars.  Basically, it accumulates remainders for a given
sequence of polynomials, and returns those (polynomial remainders) as
its result.
   4 ,: 1 1
1 1
1 1
1 1
1 1

   (4 # ,: 1 1) pantibase 1 3 3 1
1
0
0
0
   Note that each row of the result is itself a polynomial.

   (0 ,: 1 1 1) pantibase 1 1 2 1 1
1 0 1
0 0 0
but
   (0, 1 1 1 ,: 1 1 1) pantibase 1 1 2 1 1
1 0
0 _1
1 0

pderiv    =. }.         "1

This just takes the derivative of a polynomial.  (That this is so easy
is one of the attractions of polynomials).

   pderiv 3 2 1
2 1

pinteg    =. 0&,        "1

This finds an integral of a polynomial.  The arbitrary constant is 0,
by default, but you can use 'padd' to change that.

   pinteg 2 1
0 2 1

   3 0 padd pinteg 2 1
3 2 1

I haven't done anything very graceful with scalars with these
routines, and there may be some rough edges, as I keep tweaking the
code (thus allowing new bugs to creep in).

I haven't thought about fractional powers of polynomials, but integral
powers are fairly easy:
   1 1 1 & ptimes ^:(3) 1
1 3 6 7 6 3 1

Also, "polynomial factorials" are fairly easy to derive:
   pfact =. 'pclean ptimes/ (>: i. y.)#"(0) 1' : 11 " 0

   pfact 1 2 3 4 5
1 0 0  0  0  0  0  0 0 0 0
1 1 0  0  0  0  0  0 0 0 0
1 2 2  1  0  0  0  0 0 0 0
1 3 5  6  5  3  1  0 0 0 0
1 4 9 15 20 22 20 15 9 4 1

   1 poly pfact 1 2 3 4 5
1 2 6 24 120

Maybe this sort of thing is useful to somebody?


+------------------
| Raul Rockwell
| <ROCKWELL.91Sep19010310@socrates.umd.edu>

A week or so ago, I posted some polynomial functions.  Two of them
were horribly mistaken.  (gads, how embarrassing.)

here are corrected versions.

derivative =. }. @ ( * !@i.@# )         " 1     [[NB. apd. pderiv??]]
integral   =.      ( % !@i.@# ) @ (0&,) " 1     [[NB. apd. pinteg??]]


*========================================
# Grade Down Columns of An Array

+------------------
| Ann Simpson Chapin
| <33789@usc.edu> 21 Jun 91 03:57:51 GMT


Does anyone know how to grade down the columns of an array (rank 2) so that
each column of the array is graded down as if it is a separate vector?
I do not want to have to create an interative function, and I also do not
want to have to create separate vectors from each column, grade down each
vector, and then reconcatenate the vectors into the original array.

I have received several suggestions from various sources about creating
nested indicies into the array to solve the problem, but everyone I know
that has tried to solve this problem in a noniterative fashion has not
been able to.  If you can do this, please include the steps in your
response.  I am using APL Plus II on a 386 with plenty on memory and a
math coprocessor.....

Thanks,


+------------------
| L.J.Dickey
| <1991Jun21.060649.919@watmath.waterloo.edu>

In article <33789@usc.edu> ann@neuro.usc.edu (Ann Simpson Chapin) writes:
>Does anyone know how to grade down the columns of an array (rank 2) so that
>each column of the array is graded down as if it is a separate vector?

I have a solution to this problem.

>I do not want to have to create an interative function, and I also do not
>want to have to create separate vectors from each column, grade down each
>vector, and then reconcatenate the vectors into the original array.

Yeah, that would be a pain.

>I have received several suggestions from various sources about creating
>nested indicies into the array to solve the problem, but everyone I know
>that has tried to solve this problem in a noniterative fashion has not
>been able to.  If you can do this, please include the steps in your
>response.

Here are the steps in my solution, straight from a session script:

[[NB. sws.  you can replace NB: below by just NB. in current versions of J]]

   NB: =: '0 0$0' : 'x.'
   shape =. 4 5
   m =. (($?~)*/) shape       NB: 'Deal me a matrix.'
   m                          NB: 'What did I get?'
 6  7  1  2 18
13  4 15  3  0
16 19 12 17 14
 8 10 11  5  9
   r =. (\:"1)&.|:m           NB: 'Grade down each row under transpose.'
   c =. ($m)$i.}.$m           NB: 'Plain column selectors.'
   ( <"1 r,"_2 c ){m          NB: 'The desired result.'
16 19 15 17 18
13 10 12  5 14
 8  7 11  3  9
 6  4  1  2  0
   ( <"1 r,"_2 c )            NB: 'The indices.'
+---+---+---+---+---+
|2 0|2 1|1 2|2 3|0 4|
+---+---+---+---+---+
|1 0|3 1|2 2|3 3|2 4|
+---+---+---+---+---+
|3 0|0 1|3 2|1 3|3 4|
+---+---+---+---+---+
|0 0|1 1|0 2|0 3|1 4|
+---+---+---+---+---+

Comments:

The thing that makes this relatively easy in J is the way
the rank operator can be used to great advantage.
The first place this happens is in the expression
        \:"1
which means grade down each row.  I used this on each row of the
transpose, and then transposed the result back to get "r".
This was the most interesting part for me.

The second most interesting part was discovering how to
put the row indices and column indices together to generate
the subscripts used to select from the matrix.   For me, the
expression

   ( <"1 r,"_2 c )

was enlightening.

>           I am using APL Plus II on a 386 with plenty on memory and a
>math coprocessor.....
>
>Thanks, Ann

I am using J, Version 3.2 on my Atari Mega ST2.

Thank you, Ann, for posting such an interesting question.
I have learned a little more about J and the rank operator.


+------------------
| Raul Rockwell
| <ROCKWELL.91Jun21080548@socrates.umd.edu>

Ann Simpson Chapin:
   Does anyone know how to grade down the columns of an array (rank 2)
   so that each column of the array is graded down as if it is a
   separate vector?  I do not want to have to create an interactive
   function ..

   I am using APL Plus II on a 386 with plenty on memory and a math
   coprocessor.....

Well, if you were using J, I'd recommend something like
   \:~ "1  &.|: array

But since you're not, I'll try and describe a way to do this in
vanilla APL.  Basically, you coerce the array to a vector, sort the
vector in a way which preserves the original column order, then
reshape back to the original shape.

First off, you'll need the array in vector form.  You'll want all
members of a single column adjacent to each other, so you need to
transpose the array before you ravel it.  I'm going to give each
sentence twice -- once in psuedo-apl puns, and once in J.

   vec <- , (\) array
   vec =. , |:  array

Second off, you'll need to grade the array.  You want the grade to
preserve the original column ordering, so you need to normalize the
array, and add numbers to force the proper static ordering.

  normalized <- /|\  /|\ array
  normalized =. /:   /:  array

  colHorder <- - (R vec) x (R array)[0] / i (R array)[1]
  col_order =. - (# vec) * (0{$array)   # i. 1{$array

  grade <- \|/ colHorder + normalized
  grade =. \:  col_order + normalized

Finally, you need to restore the original shape of the array.  Note
that you need to do a transpose as well, which means that you need to
reshape using transposed dimensions.  (I'll just reverse the
dimensions here).

  sorted <- (\) ( (|) R array)R vec[grade]
  sorted =. |:  ( |.  $ array)$ grade{vec

voila.

As an aside, I haven't tested this code yet, but the basic concept is
sound.  I hope you can read it.  Also note that I've assumed origin 0
for the APL session -- I trust conversion to origin 1 is obvious, if
that is desired.

puns used here:
  <-   assignment
  (\)  transpose
  (|)  rotate
  R    rho
  H    delta
  x    times


+------------------
| Raul Rockwell
| <ROCKWELL.91Jun22124641@socrates.umd.edu>

Just a couple second thoughts on the sorting method I mentioned in my
last post.

First, one does not need to to transpose the array before ravelling
it.  Since the sort will totally reorder the array, and since the key
I provided results in a transposed array after sorting, the initial
transpose is redundant.  (Though it is probably useful conceptually).

Second, the normalization technique I used wouldn't work if you wanted
to maintain the relative positions of "identical" elements.  I think
this might be significant with floating point values, because of the
effects of comparison tolerance.

Also, I mistyped at least one bug into the code.

So, ammended code (same puns as before):

   vec <- , array
   vec =. , array

   normalized <- \|/ \|/ vec
   normalized =. \:  \:  vec

   colHorder <- - (R vec) x (R array)R i  (R array)[1]
   col_order =. - (# vec) * ($ array)$ i. 1{$ array

   grade <- \|/ colHorder + normalized
   grade =. \:  col_order + normalized

   sorted <- vec [  (\) ( (|) R array ) R grade ]
   sorted =. vec {~  |: (  |. $ array ) $ grade


(the typo in my prior post, by the way, was where I used 'array'
rather than 'vec' to compute 'normalized')

Finally note that my use of intermediate variables is purely
stylistic -- all of these values could be computed on the fly (though
there may be a significant cost associated with computing 'vec' on the
fly in some dialects of APL).


+------------------
| Robert Bernecky
| <1991Jun23.172018.4316@yrloc.ipsa.reuter.COM>

In article <33789@usc.edu> ann@neuro.usc.edu (Ann Simpson Chapin) writes:
>Does anyone know how to grade down the columns of an array (rank 2) so that
>each column of the array is graded down as if it is a separate vector?
>I do not want to have to create an interative function, and I also do not
>want to have to create separate vectors from each column, grade down each
>vector, and then reconcatenate the vectors into the original array.

>response.  I am using APL Plus II on a 386 with plenty on memory and a
>math coprocessor.....

As pointed out by LJ DIckey, you can use function rank if using a modern
dialect of APL (J or SHARP APL/PC). Otherwise, you can try this approach,
which I used back in the dark ages on a card sorter, IF your data
is small numbers such as student test scores, etc.

Consider the array x to be numbers in the range from 0 to 100.
Add 1000 to column one, 2000 to column two, etc. In SHARP APL, this
would be x+rank 1 (1000 times iota negative one take rho x).

Now ravel and upgrade, than take the 1000 residue.

Basically, each set of numbers sorts within the x000'th column.


+------------------
| L.J.Dickey
| <1991Jun24.001559.27591@watmath.waterloo.edu>

In article <1991Jun21.060649.919@watmath.waterloo.edu> I wrote:
>In article <33789@usc.edu> ann@neuro.usc.edu (Ann Simpson Chapin) writes:
>>Does anyone know how to grade down the columns of an array (rank 2) so that
>>each column of the array is graded down as if it is a separate vector?
>
>I have a solution to this problem.
> ...

Well, I have thought a little more about this and have learned some more.

Earlier, I presented this:

   NB: =: '0 0$0' : 'x.'
   shape =. 4 5
   m =. (($?~)*/) shape       NB: 'Deal me a matrix.'
   m                          NB: 'What did I get?'
   r =. (\:"1)&.|:m           NB: 'Grade down each row under transpose.'
   c =. ($m)$i.}.$m           NB: 'Plain column selectors.'
   ( <"1 r,"_2 c ){m          NB: 'The desired result.'

Here, I will show another solution that I found, a solution that
is far superior, in my opinion:

   (\:"1 m) {"1 m

This can be presented as a tacit function

   sbr =. {"1 ~ \:"1
   sbr m

and of course, as a consequence, the expression

   sbr &. |: m

does the desired task.  Finally, as was gently pointed
out by two kind readers, the expression

   \:~ "1 m

simply sorts by rows. So,

   \:~ "1 &. |: m

sorts by columns.  I suppose that when all else fails, RYFM. (*)


Further comments:

My original solution seems quite silly to me now, because of the
complicated structure that I needed to build.  I have not found
a use for the indices yet.  I am afraid that it will be just an
amusing exercise.

As before, the rank operator plays an essential role in each
of the above solutions.  But in these two solutions above,
strong primitives are used (sort and grade down)

                                                Lee Dickey

(*) Reference: ``Computer Wimp'', by John Baer. Ten Speed Press,
Berkeley (1983), ISBN 0-89815-101-5, p. 204.


*========================================
# WANTED: APL maximization function

+------------------
| Fred A Masterson
| <20114@brahms.udel.edu> 31 Mar 91 00:49:14 GMT


I am seeking an APL function that will maximize a function of
one variable, i.e., find the value of x that maximizes f(x).
Does anyone have one or know where one can be obtained?


+------------------
| Raul Rockwell
| <31MAR91.00533434@uc780.umd.edu>

Fred Masterson writes:
>I am seeking an APL function that will maximize a function of
>one variable, i.e., find the value of x that maximizes f(x).

Gee.. uh... could you maybe give a few more hints about the kind of
problem you are talking about?  Maybe we should just assume that x is
intended to be a floating-point scalar, and that any local maxima of f
is a suitable answer?

Also, how important is it that the routine be a "function"?  Often
interactive routines are quite powerful (and potentially instructive).


+------------------
| Sam Sirlin
| <1991Mar31.212330.28955@jato.jpl.nasa.gov>

In article <20114@brahms.udel.edu> fmaster@brahms.udel.edu (Fred A Masterson) writes:
>I am seeking an APL function that will maximize a function of
>one variable, i.e., find the value of x that maximizes f(x).

To do this once, a simple plot is pretty powerful. To automate this,
you need to decide a bunch of things such as

  - is the function differentiable (analytically or numerically) to
    some order?
  - is there a single maximum (no local maxima)?
  - do you know a priori bounds on a (finite) region that contains the
    desired maxima?

Given the last condition, a simple binary search works pretty fast and
is simple to code (I have one somewhere).


+------------------
| Fred A Masterson
| <16840@chopin.udel.edu> 1 Apr 91 02:51:19 GMT


In article <31MAR91.00533434@uc780.umd.edu> cs450a03@uc780.umd.edu writes:
>Fred Masterson writes:
>>I am seeking an APL function that will maximize a function of
>>one variable, i.e., find the value of x that maximizes f(x).
>
>Gee.. uh... could you maybe give a few more hints about the kind of
>problem you are talking about?  Maybe we should just assume that x is
>intended to be a floating-point scalar, and that any local maxima of f
>is a suitable answer?
>
>Also, how important is it that the routine be a "function"?  Often
>interactive routines are quite powerful (and potentially instructive).
>
>Raul Rockwell

O.K., here are the hints:

x is indeed a floating point scalar

a local maximum would be just fine

an interactive (no returned value) procedure would be fine

 