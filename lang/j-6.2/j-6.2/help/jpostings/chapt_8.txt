                                   Chapter 8

                             USING J : HOOK, FORK, ...


      the difference between f : '' and f@]
      DAGs for Hook, Fork, Compose, Atop, Dual
      Forks, Hooks and With in J
      Is hook really necessary?


*========================================
# the difference between f : '' and f@]

+------------------
| Raul Rockwell
| <ROCKWELL.91Jun6222025@socrates.umd.edu>

I used f :'' and f@] in my last post, and it's been bugging me that I
didn't make clear what the difference was (or what they have in
common).  By the way, the space, in (f :''), is necessary -- even
though I said f:'' in my other post...

Let  f  represent some J verb.  Then,
  f :'' x
and
  f@] x
and
  f x
should give you the same result.  But both of the derived verbs have
infinite rank, which can be important when using them to construct
other verbs.

However,
  x f :'' y
gives a domain error, while
  x f@] y
gives the same result as  f@] y


There, how's that?  A post which is probably totally incomprehensible
to someone not familiar with J, and probably totally obvious to an
experienced J programmer....  I hope somebody gets some use out of
this.


+------------------
| L.J.Dickey
| <1991Jun11.112527.13969@watmath.waterloo.edu>

In article <ROCKWELL.91Jun6222025@socrates.umd.edu>
        rockwell@socrates.umd.edu (Raul Rockwell) writes:
>I used f :'' and f@] in my last post ...

Along the same vein, comparing features in J:

The adverb "~" (double) has the effect of causing a monadic
function call to be treated dyadically by doubling the right
argument:

        f~ x   <-->   x f x

This is nice for building tables, for instance, as in
        +/ ~ i. 4
because you don't have to type the "i. 4" twice, and sometimes
it cuts down on the need for parentheses  (compare
        (i. 4) +/ i. 4
for example).

Now, to get to my point.
Double can be simulated by the hook.  Consider any function f,
and compare

        f ~ x
        f ] x

To take a specific example, consider these three function.
   pr =. +%
   f1 =. pr ~
   f2 =. pr ]
Then
   f1 4 5
4.25 5.2
   f2 4 5
4.25 5.2

Showing that the hook (used in f2) produces the same result as
the double (used in f1).  Of course the functions f1 and f1 are
not identical, since dyadic usages are different, as in
   4 f1 5
5.25
   4 f2 5
4.2



*========================================
# DAGs for Hook, Fork, Compose, Atop, Dual

+------------------
| L.J.Dickey
| <1991Jun9.125549.4554@watmath.waterloo.edu>


I am learning more about the power of J, in particular, more about the
various compositions of functions that J makes easy, and it has helped
me to have at hand a page showing DAGs (Directed Acyclic Graphs) of
some of these.

It was a recent posting by Raul Rockwell about the difference between
f : '' and f@], and that prompted me to think that you, gentle reader,
might find these diagrams helpful, too.  So, included below is an ascii
representation of my chart.  If you find this helpful, then I am pleased.

[[NB. apd. deleted see below]]

+------------------
| L.J.Dickey
| <1991Jun12.013028.29064@watmath.waterloo.edu>


A kind reader has pointed out that there were certain errors and
omissions, so I take this opportunity to post again, in the hopes of
making it right.  It was also pointed out that these Directed Acyclic
Graphs (DAGs) were Trees, so Trees they are.

Lee Dickey

  |%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|
  |%|                                |%|                                |%|
  |%|                                |%|                                |%|
  |%|             FORK               |%|             HOOK               |%|
  |%|             f g h              |%|             f g                |%|
  |%|                                |%|                                |%|
  |%|   (f g h) y      x (f g h) y   |%|    (f g) y        x (f g) y    |%|
  |%|                                |%|                                |%|
  |%|       g              g         |%|       f               f        |%|
  |%|      / \           /   \       |%|      / \             / \       |%|
  |%|     f   h         f      h     |%|     y   g           x   g      |%|
  |%|     |   |        / \    / \    |%|         |               |      |%|
  |%|     y   y       x   y  x   y   |%|         y               y      |%|
  |%|                                |%|                                |%|
  |%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|
  |%|                                |%|                                |%|
  |%|                                |%|                                |%|
  |%|             ATOP               |%|            COMPOSE             |%|
  |%|             f @ g              |%|             f & g              |%|
  |%|                                |%|                                |%|
  |%|   (f @ g) y      x (f @ g) y   |%|   (f & g ) y     x (f & g) y   |%|
  |%|                                |%|                                |%|
  |%|      f               f         |%|       f               f        |%|
  |%|      |               |         |%|       |              / \       |%|
  |%|      g               g         |%|       g             g   g      |%|
  |%|      |              / \        |%|       |             |   |      |%|
  |%|      y             x   y       |%|       y             x   y      |%|
  |%|                                |%|                                |%|
  |%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|%|
  |%|                                |%|
  |%|                                |%|
  |%|             DUAL               |%|
  |%|             f&.g               |%|
  |%|         (g^:_1) @ (f&g)        |%|
  |%|                                |%|
  |%|   (f&.g) y        x (f&.g) g   |%|
  |%|                                |%|
  |%|    g^:_1            g^:_1      |%|
  |%|      |                |        |%|
  |%|      f                f        |%|
  |%|      |               / \       |%|
  |%|      g              g   g      |%|
  |%|      |              |   |      |%|
  |%|      y              x   y      |%|
  |%|                                |%|
  |%|%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%|




*========================================
# Forks, Hooks and With in J

+------------------
| Kjell E Post
| <kjell.675944273@ygdrasil> 3 Jun 91

I've ordered the Tangible Math book and started to program in J, but find
the use of & (with) confusing, especially in conjunction with forks and hooks.

For instance, (0&,) and (,&0) seems to represent the trees

          ,                     ,
         / \                   / \
        0                         0

respectively.  Is there any reason why this notation was chosen, i.e.
what is the underlying functionality of '&'?

I'm also curious about the expressibility of '&', fork, and hook.
In particular, I'm interested in representing the following dag as a verb,
using only '&', '~', fork/hook, and the items in the dag.

           #
          / \
        +:   \
       /  \   \
      /     ,  \
     |     / \  \
     |   }.   1  |
     |    |      |
     `----=      |
         / \     |
        /   \    |
       ,     \   |
      / \     \ /
     0   +     ,
        / \   / \
           1     0              <--- Note: the empty leaves represents
                                           argument positions.


+------------------
| Raul Rockwell
| <ROCKWELL.91Jun3084928@socrates.umd.edu>

Kjell E Post:
   I've ordered the Tangible Math book and started to program in J,
   but find the use of & (with) confusing, especially in conjunction
   with forks and hooks.

   For instance, (0&,) and (,&0) seems to represent the trees
             ,                  ,
            / \                / \
           0                      0
   respectively.  Is there any reason why this notation was chosen, i.e.
   what is the underlying functionality of '&'?

Forks and hooks are types of verb phrases.  Given a verb phrase of the
form  v1 v2 v3  a fork will be constructed, and given a verb phrase of
the form  v2 v3  a hook will be constructed.  "Trees" involving  0  or
&  are neither forks nor hooks (0  is a noun and  &  is an adverb).

The "underlying functionality" of  &  is, roughly, that of binding an
object to a function.  If you bind a noun to a verb, as above, you
create an intransitive verb derived from the transitive form of the
original verb.  If you bind a verb to a verb  v1&v2  then the
intransitive form of v2 is used as a preprocessor for v1 (the
distinction between the transitive and intransitive form for v1 is
determined from context).


+------------------
| William Ricker
| <b6k78e.jss@wang.com> 5 Jun 91

rockwell@socrates.umd.edu (Raul Rockwell) writes:
[in answer to a question on representing a DAG with fork, hook, and &]

>Forks and hooks are types of verb phrases.  ... [expressions like]
> v1 v2 v3  [is] a fork [and]  v2 v3 [is] a hook [.]
>&  are neither forks nor hooks (0  is a noun and  &  is an adverb).
    I note that unless the fork or hook is the entire expression,
to indicate that it is a fork/hook parenthesis will be required, else it
will just execute left to right.

>The "underlying functionality" of  &  is, roughly, that of binding an
>object to a function.  If you bind a noun to a verb, as above, you
>create an intransitive verb derived from the transitive form of the
>original verb.  If you bind a verb to a verb  v1&v2  then the
>intransitive form of v2 is used as a preprocessor for v1 (the
>distinction between the transitive and intransitive form for v1 is
>determined from context).

In the fork and hook, it seems that the distinction between dyadic and monadic
(which I think is the same as you mean by transitive & instransitive) also
seems to be determined by context.  However, sometimes I want to express
   (v1 n1) v2 (v3 n2)
 as
    n1 (v1 v2 v3) n2
but if both v1 and v3 have dyadic interpretations, the parser seems to assume
I meant :
    (n1 v1 n2) v2 (n1 v2 n2)
which is the other fork.

This can be solved by & "with" and sufficient use of ()'s, or by the identity
combinator ] to make hook forcing the verb v1 to monadic case : (]v1).  the &
tree constructor is the natural translation, but the ] option is the only
method I've found so far to mark a verb usage as monadic case.
   Example: if I try to re-code a remove-blanks-from-string:
    trim=. '(-. '' ''=y.) # y. ' : ''
 or equivalently
    trim=. 'y. #~ -. '' ''=y. ' : ''
as an implicit or functional defintion, the "obvious" hook
    ftrim=. #~ (-. ' '&=)
doesn't work, because although I'm thinking of monadic -. as NOT, the parser
thinks dyadic set difference; and thus I get a double-hook not a hook
and composition of two monadics.  So I can do:
    ftrim=. #~ (-.  &(=&' '))
or, if I really want to do it with hooks,
    ftrim=. #~ ((]-.)' '&=)


+------------------
| Raul Rockwell
| <ROCKWELL.91Jun5225432@socrates.umd.edu>

William Ricker:
..     I note that unless the fork or hook is the entire expression,
.. to indicate that it is a fork/hook parenthesis will be required,
.. else it will just execute left to right.

Yeah, there are several different ways of combining functions.

.. In the fork and hook, it seems that the distinction between dyadic
.. and monadic (which I think is the same as you mean by transitive &
.. intransitive) also seems to be determined by context.

yeah, that's what I meant by transitive/intransitive.  And I don't
have a really good feel for cases like:
  n (f:'' g h) m

I think the rules on this got changed on me with one of the J version
changes, but I haven't played with it enough to pin it down.

.. However, sometimes I want to express (v1 n1) v2 (v3 n2) as n1 (v1
.. v2 v3) n2 but if both v1 and v3 have dyadic interpretations, the
.. parser seems to assume I meant: (n1 v1 n2) v2 (n1 v2 n2) which is
.. the other fork.

Actually,  (v1 n1) v2 (v3 n2)  isn't a fork, because n1 is a different
object than n2.  If you mean you want to construct a function  f
where  n1 f n2  computes the same result as  (v1 n1) v2 (v3 n2), I'd use
   f =. v1@[ v2 v3@]

.. Example: if I try to re-code a remove-blanks-from-string:
..     trim=. '(-. '' ''=y.) # y. ' : ''
..  or equivalently
..     trim=. 'y. #~ -. '' ''=y. ' : ''
.. as an implicit or functional defintion, the "obvious" hook
..     ftrim=. #~ (-. ' '&=)
.. doesn't work, because although I'm thinking of monadic -. as NOT,
.. the parser thinks dyadic set difference; and thus I get a
.. double-hook not a hook and composition of two monadics.

try
   ftrim=. #~  -.@(' '&=)

Note that  v@u  always uses the monadic definition of  v

   [two other working solutions by Bill Ricker elided]


+------------------
| Roger Hui
| <1991Jun11.000420.3398@yrloc.ipsa.reuter.COM>

Comments on recent postings by Kjell Post, Raul Rockwell, and Bill Wicker.

Expressions in J are better represented as trees than as DAGs.
For example, try representing  (a+b)*(b+c)  as a DAG.

&  , like all other conjunctions, accepts noun or verb arguments,
thereby giving rise to four possible cases of derivations.  In principle,
the four cases need not be related, nor do the monadic and dyadic defns.
   m & n    undefined
   m & v    with,     m&v y  is  m v y  ;  x m&v y  has empty domain
   u & n    with,     u&n y  is  y u n  ;  x u&n y  has empty domain
   u & v    compose,  u&v y  is  u v y  ;  x u&v y  is  (v x) u (v y)

Many useful verbs can be defined as  m&v  or  u&n  :
  0&-  negation     ^&0.5 square root    0&<     positive
  _1&* negation     10&^. base-10 log    a.&i.   ASCII code
  +&1  increment    0&{   first          -.&' '  remove blanks
  -&1  decrement    _1&{  last           2&(-~\) first difference

All verbs are ambivalent, although some verbs have empty monadic
or dyadic domains.  Whether the monadic or the dyadic definition of
a verb is applied, is determined by context, as defined by the first
three parsing rules in Table 2 of the dictionary.  These parsing rules
apply to all verbs (whatever their derivation).

In the fork (f g h), f and g are ambivalent, and whether f or h
have empty monadic or dyadic domains would not be "discovered"
until the derived verb is applied.  For  u=.f@[ g h@]  ,
  x u y                    u y
  x (f@[ g h@]) y          (f@[ g h@]) y          defn of u
  (x f@[ y) g (x h@] y)    (f@[ y) g (h@] y)      defn of fork
  (f x[y) g (h x]y)        (f [ y) g (h ] y)      defn of @
  (f x) g (h y)            (f y) g (h y)          defn of [ and ]

As in the above example, and as specified in the dictionary, a fork
(hook) is an isolated sequence of 3 verbs (2 verbs).  Parentheses may
be required to effect that isolation.

The explicit verb  trim=.'(-.'' ''=y.)#y.' : ''  can be stated tacitly
as  -.&' '  .  ("Explicit" because the argument is explicitly mentioned;
"tacit" because not.)  Translations more faithful to the original:
   -.@(' '&=) # [
   #~ -.@(' '&=)

As noted in Bill Ricker's msg,  #~ (-. ' '&=)  is not an equivalent
computation.  (-. ' '&=)  is a hook not because  -.  is dyadic
(it is ambivalent), but because the parsing rules specify that an
isolated sequence of 2 verbs is a hook.  This derives a verb v, whence
#~ v  is an isolated sequence of 2 verbs, and is another hook.

J 3.1 has an explicit-to-tacit translator:
   'x.+y.' : 11
+-+-+-+
|[|+|]|
+-+-+-+
   '(x.+y.)*(x.-y.)' : 11
+-------+-+-------+
|+-+-+-+|*|+-+-+-+|
||[|+|]|| ||[|-|]||
|+-+-+-+| |+-+-+-+|
+-------+-+-------+
   '+/y.' : 11
+-----+-+-+
|+-+-+|@|]|
||+|/|| | |
|+-+-+| | |
+-----+-+-+

   '(-.'' ''=y.)#y.' : 11
+--------------------+-+-+
|+--+-+-------------+|#|]|
||-.|@|+-------+-+-+|| | |
||  | ||+-+-+-+|@|]||| | |
||  | ||| |&|=|| | ||| | |
||  | ||+-+-+-+| | ||| | |
||  | |+-------+-+-+|| | |
|+--+-+-------------+| | |
+--------------------+-+-+

The last result is the verb  -.@((' '&=)@]) # ]  (a fork).  Not all
explicit verbs can be so translated.



*========================================
# Is hook really necessary?

+------------------
| Raul Rockwell
| <ROCKWELL.91Jul3181219@socrates.umd.edu>

hook =. f g
is semantically equivalent to
Hook =. [ f g@]

For the monadic case, it may be expressed simply as
HOOK =. [ f g

For the dyadic case, there is no significant difference between
   a (f g) b
and
   a  f g  b
where a and b are nouns.

Is the dyadic case of hook useful really useful?  If hook was removed
from APL, it would eliminate the confusion currently possible when
looking at a long train of functions.  (Further, there would by some
syntactic protection against minor typos).

What to other people think?


+------------------
| Eythan Weg
| <WEG.91Jul3194224@convx1.convx1.ccit.arizona.edu>

In article <ROCKWELL.91Jul3181219@socrates.umd.edu> rockwell@socrates.umd.edu
(Raul Rockwell) writes:

   hook =. f g
   is semantically equivalent to
   Hook =. [ f g@]

   For the monadic case, it may be expressed simply as
   HOOK =. [ f g

   For the dyadic case, there is no significant difference between
      a (f g) b
   and
      a  f g  b
   where a and b are nouns.

   Is the dyadic case of hook useful really useful?  If hook was removed
   from APL, it would eliminate the confusion currently possible when
   looking at a long train of functions.  (Further, there would by some
   syntactic protection against minor typos).

   What to other people think?

I have often found that the two are related.  In fact, (I think about
it as I am writing), the hook might be called right hook whose
existence might be (?) a result of the way APL is parsed (right to
left).  For I can write the following `left' hook in duality to the
above fork definition of the hook:

        f@] g [

It does not exist because I think there is no way to write it in simple
syntax as is used in the `right' hook.

Writing it explicitly you obtain

LEFT:    x f@] g [ y   is   (f y) g x

and

RIGHT:  x [  g f@] y  is     x g (f y)  which is x (g f) y

(some parentheses are extra)

It seems to me that fork is the fundamental concept.  I do not yet
know about typos and never will know about language design consequences.


Since I am writing I wonder how one get f in
   x f } y

to specify the locations where items of x are to be inserted.  I mean
something of a generic technique.  Often I find that I have to write y
as an operand in the definition of f.


Example:

        y=. ? 2 3$100

I want to replace any value in y less than 6 by 6.

        y=. ($y)$  6 (6&>:,y) &# } ,y

which is tasteless if not false.

What troubles me here is:
I do not like y to be part of f and I do not want to ravel y and if I
do I want it to flex back to its original shape on its own (maybe via &.).

Thanks,


+------------------
| L.J.Dickey
| <1991Jul4.045226.5150@watmath.waterloo.edu>

In article <ROCKWELL.91Jul3181219@socrates.umd.edu>
        rockwell@socrates.umd.edu (Raul Rockwell) writes:

>Is the dyadic case of hook useful really useful?  If hook was removed
>from APL, it would eliminate the confusion currently possible when
>looking at a long train of functions.  (Further, there would by some
>syntactic protection against minor typos).

I like the hook in certain instances, and have found that it
comes up more often than I expected that it would.  Here is
the classic example, used in continued fractions.  Perhaps
others will present other examples.

   (+%) /\ 10#1
1 2 1.5 1.66667 1.6 1.625 1.61538 1.61905 1.61765 1.61818

Yes, I find the hook useful.

Something else that I find fascinating (useful?) is the adverb
called "fix" ( "f." ).  It allows one to define their function
using several proverbs, and then fix the definition, as though
the proverbs had not been used.

Here is an example of what I am talking about.

   pr =. +%
   seq =. pr /\
   0 0$'  seq is defined in terms of pr'
   seq
+------+-+
|+--+-+|\|
||pr|/|| |
|+--+-+| |
+------+-+
   seq f.
+---------+-+
|+-----+-+|\|
||+-+-+|/|| |
|||+|%|| || |
||+-+-+| || |
|+-----+-+| |
+---------+-+
   seq =. seq f.
   seq 10#1
1 2 1.5 1.66667 1.6 1.625 1.61538 1.61905 1.61765 1.61818


+------------------
| Raul Rockwell
| <ROCKWELL.91Jul4024805@socrates.umd.edu>

L. J. Dickey:
   I like the hook in certain instances, and have found that it
   comes up more often than I expected that it would.  Here is
   the classic example, used in continued fractions.  Perhaps
   others will present other examples.

      (+%) /\ 10#1
   1 2 1.5 1.66667 1.6 1.625 1.61538 1.61905 1.61765 1.61818

Glurg... without hook that would be ([+%@]) /\ 10#1
ugly...

   Something else that I find fascinating (useful?) is the adverb
   called "fix" ( "f." ).  It allows one to define their function
   using several proverbs, and then fix the definition, as though the
   proverbs had not been used.

Yeah, but that does have a few non-obvious consequences, and possibly
even a bug associated with it.

For example:
   foo =. + 'x. y.' : 2 +
   foo 3
value error

And the display form of 'foo' has some non-standard characters in it
(that, I think, is a bug -- and, it can't be that hard to substitute
the standard two character names, can it?).

For the sake of completeness, here is how foo would have to be written
to get the definition it would have had in earlier versions of J:
   foo =. + '''x.''~f.  ''y.''~f.' : 2 +

Of course, you could more simply define foo as   foo =. ++
if foo had any practical value other than as an example.


+------------------
| Roger Hui
| <1991Jul5.034303.28680@yrloc.ipsa.reuter.COM>

In article <ROCKWELL.91Jul3181219@socrates.umd.edu> rockwell@socrates.umd.edu
(Raul Rockwell) writes:
>hook =. f g
>is semantically equivalent to
>Hook =. [ f g@]
>
>For the monadic case, it may be expressed simply as
>HOOK =. [ f g

We are aware that hook can be expressed easily in terms of
other primitives.  Moreover, considered in isolation, it is better
for hook to be defined as a conjunction (i.e. denoted by a symbol).
The current definition of hook permits any train of verbs to have
an interpretation.

>For the dyadic case, there is no significant difference between
>   a (f g) b
>and
>   a  f g  b
>where a and b are nouns.
>
>Is the dyadic case of hook really useful?

A difference between a(f g)b and a f g b, is that the former
can be composed with other verbs while the latter can't.

>                                                  If hook was removed
>from APL, it would eliminate the confusion currently possible when
>looking at a long train of functions.  (Further, there would by some
>syntactic protection against minor typos).

With a train of verbs, the rightmost three verbs resolves into a fork,
resulting in a shorter train of verbs.  Whether or not hook exists
does not change this fact.



+------------------
| Roger Hui
| <1991Jul5.034830.29042@yrloc.ipsa.reuter.COM>

In article <ROCKWELL.91Jul4024805@socrates.umd.edu> rockwell@socrates.umd.edu
(Raul Rockwell) writes:
>For example:
>   foo =. + 'x. y.' : 2 +
>   foo 3
>value error
>
>And the display form of 'foo' has some non-standard characters in it
>(that, I think, is a bug -- and, it can't be that hard to substitute
>the standard two character names, can it?).

This is indeed a bug, and had been fixed.

>For the sake of completeness, here is how foo would have to be written
>to get the definition it would have had in earlier versions of J:
>   foo =. + '''x.''~f.  ''y.''~f.' : 2 +

Actually, the earlier behaviour can be obtained by
   foo =. + '(x. y.) f.' : 2 +


+------------------
| Roger Hui
| <1991Jul6.132041.8745@yrloc.ipsa.reuter.COM>

In article <WEG.91Jul3194224@convx1.convx1.ccit.arizona.edu> weg@convx1.ccit.
arizona.edu (Eythan Weg) writes:

> I have often found that the two are related.  In fact, (I think about
> it as I am writing), the hook might be called right hook whose
> existence might be (?) a result of the way APL is parsed (right to
> left).  For I can write the following `left' hook in duality to the
> above fork definition of the hook:
>
>       f@] g [
>
> It does not exist because I think there is no way to write it in simple
> syntax as is used in the `right' hook.

When hook was defined (by Iverson & McDonnell), there was a choice:
   x (f g) y    is    x f g y          or
   x (f g) y    is    (f x) g y
I believe the decision in favor of the former is due to (+%)/ .
It's not a difficult decision because the "left hook" is simply   g~ f  .

> It seems to me that fork is the fundamental concept.  I do not yet
> know about typos and never will know about language design consequences.

Fork is fundamental.  One can show that an explicit sentence on
noun arguments x and y not involving x or y as arguments to operators,
can be written tacitly (without mention of x and y).  The proof
depends on fork.

> Since I am writing I wonder how one get f in
>    x f } y
> to specify the locations where items of x are to be inserted.  I mean
> something of a generic technique.  Often I find that I have to write y
> as an operand in the definition of f.
>
> Example:
>    y=. ? 2 3$100
> I want to replace any value in y less than 6 by 6.
>    y=. ($y)$  6 (6&>:,y) &# } ,y
> which is tasteless if not false.
>
> What troubles me here is:
> I do not like y to be part of f and I do not want to ravel y and if I
> do I want it to flex back to its original shape on its own (maybe via &.).

For this example, one could write:   y=.6>.y    (-:
Suppose p is a proposition (a boolean-valued verb).  x (p y)&(#&,)} y
replaces with x all cells of y where p y.  That y is often required
as part of the operand is a weakness of } .


+------------------
| Raul Rockwell
| <ROCKWELL.91Jul6172330@socrates.umd.edu>

Me:
   >For the sake of completeness, here is how foo would have to be written
   >to get the definition it would have had in earlier versions of J:
   >   foo =. + '''x.''~f.  ''y.''~f.' : 2 +

Roger Hui:
   Actually, the earlier behaviour can be obtained by
      foo =. + '(x. y.) f.' : 2 +

Yeah.  But that's not consistent with the 3.2 lazy function
resolution, is it?


+------------------
| Roger Hui
| <1991Jul7.154102.16243@yrloc.ipsa.reuter.COM>

In article <ROCKWELL.91Jul6172330@socrates.umd.edu> rockwell@socrates.umd.edu
(Raul Rockwell) writes:
>Me:
>   >For the sake of completeness, here is how foo would have to be written
>   >to get the definition it would have had in earlier versions of J:
>   >   foo =. + '''x.''~f.  ''y.''~f.' : 2 +
>Roger Hui:
>   Actually, the earlier behaviour can be obtained by
>      foo =. + '(x. y.) f.' : 2 +
>
>Yeah.  But that's not consistent with the 3.2 lazy function
>resolution, is it?

Raul, in   '(x. y.)f.' : 2   I was saying it in the simplest
way I know how, rather than adhering to some abstract principle.
At most, I would've said   'x.f. y.f.' : 2   .  The circumlocutory
'''x.''~f. ''y.''~f.' : 2   was genuinely surprising to me.


+------------------
| Raul Rockwell
| <ROCKWELL.91Jul8213756@socrates.umd.edu>


Roger Hui:
   Raul, in '(x. y.)f.' : 2 I was saying it in the simplest way I know
   how, rather than adhering to some abstract principle.  At most, I
   would've said 'x.f. y.f.' : 2 .  The circumlocutory
   '''x.''~f. ''y.''~f.' : 2 was genuinely surprising to me.

heh.

I found out today that what I *thought* I was accomplishing by that
level of indirection was a phantom.

What I wanted to be able to do was say
   a hook b
and not get a value error.

I think my confusion was that by the time I'd gotten around to trying
the 'var'~f. notation, I'd tried so many things that I inadvertently
re-used a recursively defined (but otherwise void) function.

Sorry about the confusion, folks -- my fault for not testing
thoroughly enough.  (And a cautionary tale for the casual experimenter
:-).


 