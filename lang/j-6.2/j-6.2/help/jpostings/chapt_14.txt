                                   Chapter 14

                               USING J : EXAMPLES


      The Perfect Shuffle
      Turing Machine emulator
      RE: WANTED: APL maximization function
      WANTED: APL-II way to sort array so each column is in descending order
      Simple J editor


*========================================
# Re: The Perfect Shuffle

+------------------
| Robert Bernecky
| <1991Nov13.165753.6760@yrloc.ipsa.reuter.COM>

In article <1991Nov7.235012.27648@uxa.ecn.bgu.edu> miss055@uxa.ecn.bgu.edu
 (James D. Hutchins) writes:
>
>Does anyone know where i can find some information on the "Perfect
>Shuffle" ?  I'm trying to do some research for a paper on this
>topic.  Any help would be greatly appreciated.

I'm not sure if your interest is in the shuffle itself, or in the
parallel computational aspects of it. The latter has already been
addressed by a previous poster, so I'll do the mundane task of
the former.

The Perfect Shuffle derives from taking a deck of cards, dividing it into
two equal piles, and shuffling them such that the two piles are perfectly
interleaved.

In J, we can do this as follows:

     deck =. 'abcdefghij'
     10 $ 0 1              NB: Handy boolean list
0 1 0 1 0 1 0 1 0 1
     /: 10$ 0 1            NB: /: is "upgrade"
0 2 4 6 8 1 3 5 7 9
     /: /: 10$ 0 1         NB: Double upgrade
0 5 1 6 2 7 3 8 4 9
     (/: /: 10 $ 0 1){deck  NB: use double upgrade result to index deck.
afbgchdiej

ps: There are shorter expressions of this in J, I believe, but
    the idea here was to present Perfect Shuffle, rather than to
    expound on J.



*========================================
# Turing Machine emulator

+------------------
| Raul Rockwell
| <ROCKWELL.91Jun11214249@socrates.umd.edu>


 A Turing machine emulator is not the most practical sort of program
 one could write, but in case anyone is interested, here's one I threw
 together recently.

 First, how to extract the program from this article: use )sscript file
 where "file" is the name of a file which contains this article.  J
 will reject all the invalid lines, but will execute every line which
 is a valid J sentence.

 One of the tricks you can pull with J is reading from standard input
 in a script, so my bootstrap loader looks like this:

read =. 1!:1

readblock =. (read 1 1 1 1) : ''
r=. 0 0 $ ''
loop) r=. r, l=. read 1
$.=. end [~:(0=#l) loop
end) r

[[NB. sws.  The following now works:

   readblock =. (read 1 1 1 1) : ''
r=. 0 0 $ ''
loop) r=. r, l=. read 1
$.=. ,>(0=#l){ loop;end
end) r
]]

 "readblock" is a verb which will read standard input up through the
 first blank line and return the result as a character matrix.  Part of
 the purpose of this article is to point out how easy it is to
 distribute J programs in news articles, so feel free to use this
 technique...


 Second item, just what *is* a Turing machine?

 Let's see, a Turing machine has a read/write head which is positioned
 over a tape.  At discrete units of time, it will either:
 (a) change the symbol under the read/write head
 (b) move to the next square on the left
 (c) move to the next square on the right
 (d) stop

 Which action it chooses depends on the symbol currently under the tape
 head, and the internal state of the machine.  So Turing microcode is
 generally expressed as a four element list:
 0 initial state of machine
 1     initial symbol under the tape head
 2         what action the machine takes
 3             final state of the machine.

 Being somewhat lazy, I decided to use numbers to represent Turing
 machine symbols.  I reserved negative numbers to represent tape head
 movement, _1 meaning move left, and _2 meaning move right.  The
 initial internal state of the machine is 0, and if the read head goes
 off the end of the tape, the tape is padded with zeros.  The machine
 halts when it reaches an internal-state/tape-symbol combination for
 which it has no microcode.

 So here are a few sample microcode instructions for a Turing machine:

MoveRightIf1 =. 3 1 _2 3
 This will scan right until the machine finds a non-1 cell.

MoveLeftIf1=.   4 1 _1 4
 This will scan left until the machine finds a non-1 cell.

 To connect them, I'll use
Set1=.          3 0 1 4
 In other words, if the machine finds a zero, it will change it to a
 one, and switch to internal state 4.

 Finally, to start, I'll assume I'm over a zero, and that the tape I
 want to play with is immediately to the right:
StartThis=.     0 0 _2 3

 Now, my machine description will consist of a two element boxed array.
 The first element is the microcode (in matrix form), and the second
 element is the initial tape.  Something like this:

[]   sample =. (>3 1 _2 3; 4 1 _1 4; 3 0 1 4; 0 0 _2 3) ; 0 1 1 1
 +--------+-------+
 |3 1 _2 3|0 1 1 1|
 |4 1 _1 4|       |
 |3 0  1 4|       |
 |0 0 _2 3|       |
 +--------+-------+

 After the machine runs, I'd expect that the tape would look like this:
 0 1 1 1 1

 (That assumes I don't make any typos coping my printout).  I think
 that should be enough documentation, here's the program:

usage =. readblock ''
print =. 1!:2&2
print 'Usage:'
print ' mode TM quads;tape'
print ' ------------------'
print ' mode is:  ''quiet'''
print '        or ''trace'''
print '        or ''step'''
print ' quads is the program'
print ' tape  is the data'

TM=. usage : (_1 1 }. readblock '')
X
X
X   'proverbial system calls'
Xread =. 1!:1
Xprint=. 1!:2 & 2
X
X   'determine noise level'
Xmode=.  1 i.~('quiet';'trace';'step')e. ;: x.
Xcontinue=. >(loop;trace;step;abort) {~ mode
X
X   'unpack machine and tape description'
X('prefixes';'cursor') =. y.
X
Xsuffixes   =. 2 3 {"1 prefixes
Xprefixes   =. 0 1 {"1 prefixes
X
Xright_tape =. 1 }. cursor
Xcursor     =. 1 {. cursor
Xleft_tape  =. i. 0
X
Xstate      =. 0
Xend        =. #prefixes
X
X   'begin execution'
X$.=. continue
Xabort) $:$.=.''
X
Xstep) print left_tape;state;cursor,right_tape
X      ". read 1
X      $. =. loop
X
Xtrace) print left_tape;state;cursor,right_tape
X
Xloop)  next =. prefixes i. state, cursor
X       $.=. halt  [^:(next=end)  eval
Xeval)   ('action';'state')=. next{suffixes
X        $.=. move  [^:(action<0)  set
Xset)     cursor =. action
X         $.=. continue
X
Xmove)    $.=. goleft  [^:(action=_1)  goright
Xgoright)  left_tape =.  left_tape,cursor
X          cursor=.  1{. right_tape
X          right_tape =. 1}. right_tape
X          $.=. continue
X
Xgoleft)   right_tape =.  cursor,right_tape
X          cursor =. _1{. left_tape
X          left_tape =. _1}. left_tape
X          $.=.continue
X
Xhalt)   left_tape;state;cursor,right_tape

 One final comment, the descriptions of the machine, while it is running
 and afterwords are three element boxed lists.  The first element is
 the tape to the left of the read/write head.  The second element is
 the internal state of the machine.  The third element is the tape cell
 under the head, and the tape to the right of that.

 So, if you executed 'quiet' TM sample, you should get a result like:
 ++-+---------+
 ||4|0 1 1 1 1|
 ++-+---------+

[[NB. sws. I get

++-+-------+
||0|0 1 1 1|
++-+-------+

but I won't try to figure out why!
]]

 Hopefully, I've not made any mistakes typing this in...


+------------------
| Raul Rockwell
| <ROCKWELL.91Jun15151436@socrates.umd.edu>

I wrote:
   One of the tricks you can pull with J is reading from standard
   input in a script, so my bootstrap loader looks like this:

   read =. 1!:1

   readblock =. (read 1 1 1 1) : ''
   r=. 0 0 $ ''
   loop) r=. r, l=. read 1
   $.=. end [~:(0=#l) loop
   end) r

AARRRRGGGGHHHHH!!!!!!!!

the second line from the bottom should read:
$.=. end [^:(0=#l) loop

[Mr. Hui, please, please, please, could you port J to HP/PA?  I
wouldn't have this sort of problem if I had a working version of J on
this system.  [Incidentally, anyone in Toronto have telnet access that
they could let Mr. Hui use to do the port???]]

Finally, I've re-written the TM emulator in a more concise and [I
think] clearer fashion, maybe once I'm sure I've got a copy of it that
is totally debugged I'll re-post.

*sigh*



*========================================
# RE: WANTED: APL maximization function

+------------------
| Raul Rockwell
| <1APR91.21504259@uc780.umd.edu>

Fred Masterson writes:
>>>I am seeking an APL function that will maximize a function of
>>>one variable, i.e., find the value of x that maximizes f(x).
>x is indeed a floating point scalar
>a local maximum would be just fine
>an interactive (no returned value) procedure would be fine

Well, like the guy said, a couple postings back, plotting a graph
works wonders.  Other than that, it looks like some variant on
Newton's method should work fine...

Lets say I assume that f is a scalar function.  (so I can give it a
list of arguments and it will give me back a corresponding list of
results).  I'll also going to freely mix J and APL puns...

[[NB. sws. This isn't really a function that can just be scripted into J, but
  NB.      in principle it should work if converted into explicit definition
  NB.      form.
]]
      _
      V x =. max_x seed
[1]  'seed contains the lower bound and upper bound for the interval'
[2]  'you wish to test.  If you like, just use i. 0'
[3]   n   =. 30
[4]   lower_bound =. <./ seed
[5]   upper_bound =. >./ seed
[6]  loop)
[7]   arg    =. lower_bound + (upper_bound-lower_bound) * (i. n+1) % n
[8]   result =. f arg
[9]   k =.   result i. >./result
[10]  seed =. arg {~ 1>. n<. _1 0 1 + k
[11]  lower_bound =. <./ seed
[12]  upper_bound =. >./ seed
[13]  $. =. ((lower_bound = upper_bound) # loop), end
[14] end)
[15] _ (+/seed) % 3
     V

Now, I just threw this thing together, totally untested and so on.
But this is such a sleepy group anyways...
[[NB. apd. Te mood of this last sentence is surely linked to the date
]]

Tradeoffs:  I am guessing that "f" isn't going to be incredibly
expensive, if it is, you'll want to do something a lot more concerned
about the number of times f gets evaluated.

The loop structure is so I could come up with something that looks
almost decent in either J or APL.

I don't expect this thing to be very fast, in any event (inverting
functions by trial and error is never particularly efficient).

Quicky J to APL reference
[1] and [2] are comments
<. is min (floor)  >. is max (ceiling)
/ is reduce        #  is compress (in APL they are both / )
=. is assign to local variable
*  is multiply
loop)  and end)  are line labels
$. =.  is the equivalent of ->
{~     is indexing:  list[indices]
_1     is negative 1
max_x  would be maxHx (maxDELTAx) if I did this in real APL

----------------------------------------------------------------------

I just use built in comparison tolerance to decide when it's done.

Also, you could shorten variable names and squash the thing onto
fewer lines, if that pleases you.

If you're really ambitious, you could even test it :-)



*========================================
# WANTED: APL-II way to sort array so each column is in descending order

+------------------
| A J Annala
| <31931@usc> 13 Apr 91 23:16:49 GMT


Hello:

I'm a new APL-II user with a small problem.  Could some please suggest a
generic function to reorder each column of an array in descending order
where the array is two dimensional.  i would prefer the solution not be
iterative and not require breaking the columns into separate vectors.

Thanks,


+------------------
| Eythan Weg
| <WEG.91Apr14120440@convx1.convx1.ccit.arizona.edu>

In article <13APR91.22583472@uc780.umd.edu> cs450a03@uc780.umd.edu
(Raul Rockwell) writes:


   A Analla writes:

   >Could some please suggest a generic function to reorder each column
   >of an array in descending order where the array is two dimensional.
   >I would prefer the solution not be iterative and not require breaking
   >the columns into separate vectors.

   Well, in general, if you want to order the columns independently, you
   are already treating them as separate vectors.

   If you are using J, I'd suggest something like:
      \:"1&.|: array
   [... stuff deleted ]
I would think to add just a small ~ in front of array.  Without it, you
will get the permutations for such reorderings.

    Raul Rockwell

Incidentally, how does one write this function in APL2?


+------------------
| Raul Rockwell
| <13APR91.22583472@uc780.umd.edu>

A Analla writes:

>Could some please suggest a generic function to reorder each column
>of an array in descending order where the array is two dimensional.
>I would prefer the solution not be iterative and not require breaking
>the columns into separate vectors.

Well, in general, if you want to order the columns independently, you
are already treating them as separate vectors.

If you are using J, I'd suggest something like:
   \:"1&.]: array

[[NB. sws. the above has a typo. To sort an array this way use

   index=. \:"1&.|: array
   sortedArray=. index {"1&.|: array

]]
However, if you are using vs-apl, I'd recommend you write a function
which iterates over the columns:

_
V Y <- F Y ;LP ;N
  ->(LP <- ((minus1 take rho Y)rho LOOP), END)[N <- quadIO]

LOOP:Y[;N] <- Y[gradedown Y;N]
  ->LP[N <- N+1]

END:
_
V

I could go on, but maybe you could say what version of APL you are
working with?

Or maybe I misunderstood your problem?


+------------------
| Raul Rockwell
| <17APR91.20220134@uc780.umd.edu>

Ethyn Weg writes;


>Underlying my original question regarding the APL2 method is the sense
>that you often need auxiliary functions where in J you can do without.
>Is this a general feeling?  Now often you need a subroutine that in J
>can be part of a main verb, not cluttering the workspace.

J has a number of design features that allow you to create and use
auxiliary functions in-place.  Not the least of which is indexing as a
function, rather than a syntactic special case.

I'd say that in APL2, functions are second rate objects (and
operators are third rate).

> It pleases me aesthetically that you can work this way.  I wonder if
>using internal or external subroutines have different implications
>regarding performance.

By external subroutines do you mean functions bound to a name, as
opposed to functions defined dynamically?

I think if the problem you are working on can be expressed more
concisely, you'd probably also see performance implications.  (I'm
thinking specifically of language manipulation routines, such as
symbolic math routines and partial evaluators such as compilers).

Just an opinion though, at this stage.


+------------------
| Greg P. Jaxon
| <1991Apr19.145007.2201@csrd.uiuc.edu>

>> mix[K] is the left inverse of split[K], so just  mix[#IO] F" split[#IO] A.
>Is this solution correct?  Don't you have to insert a new first dimension
>and therefore the axis for mix should be fractional?
The axes given to Mix (aka Disclose) name the NEW axs in the result array
which will hold the axes of the items of the argument array.  If you split
them out with enclose[K], you can put them back with disclose[K].

>Underlying my original question regarding the APL2 method is the sense
>that you often need auxiliary functions where in J you can do without.
>Is this a general feeling?
I've only been really annoyed by Indexing not being a 'function' and
by '/' no longer being a function.  In the sort problem, we only need
the auxillary function for the indexing step, call it INX:
     mix[#IO] INX" grdn" split[#IO] A

> I wonder if using
>internal or external subroutines have different implications
>regarding performance.
>Eythan Weg
Some: there's less hope of optimizing across the routine boundary.
In APLB we found an efficient way to drive user-defined functions
under control of primitive operators that made simple fns like INX
10 times faster when driven by (e.g.) the Each operator, than they
are when driven by an equivalent loop. - We only enter and exit INX
once!

Robert Frey suggests:
> A[; grdn rotate A]    (surely you mean transpose, not rotate/reverse)
> A[; grdn[1] A]
I'm not sure about the last one, but in either case one permutation
vector is being applied to all the columns, the question asks for
the columns to be individually sorted so that each one is in descending
order.

To turn the philosophy discussion around, what do you think about
doing the split and mix steps up in the user-accessible data domain?
I kind of like seeing those intermediate data organizations, it gives
me a handle on what I need to do next.  In dictionary APL (and I think
in J), more of this work is done silently inside the rank operator,
where I'll grant you it can be a lot more efficient; but much more
obscure!


+------------------
| Robert Bernecky
| <1991Apr19.193342.20318@yrloc.ipsa.reuter.COM>

In article <1991Apr17.151913.4891@csrd.uiuc.edu> jaxon@sp27.csrd.uiuc.edu (Greg
P. Jaxon) writes:
>cs450a03@uc780.umd.edu writes:
>
>>>Incidentally, how does one write this function in APL2?
>> you could write a function F to sort vector
>>then do:
>>         transpose mix  F each  split[quadIO] array
>>You might be able to do something with mix and brackets to avoid the
>>transpose, but I don't know what exactly, off the top of my head.
>>Raul Rockwell
>

This seems to reflect the basic difference in theology between APL2 and
the SHARP APL/J world:

APL2 uses split or partitioned enclose to create an array of arrays,
applies some operation at one level down to each of those results, then
uses mix or disclose to restore the data to its original depth.

J and SAPL consider the operation to be defined on arrays of some particular
rank, and then extends to higher rank arrays in a uniform manner. The Rank
conjunction is used with these operations, when needed, to modidy that
behavior.

Effectively, J applies a different operation to the same data.

APL2 applies the same function to different data.

I believe that J is going to be easier to optimize for better performance
in this area, having done some of that optimization for SHARP APL in
the dim past.


+------------------
| Raul Rockwell
| <19APR91.21375678@uc780.umd.edu>

Greg Jaxon writes:

>To turn the philosophy discussion around, what do you think about
>doing the split and mix steps up in the user-accessible data domain?
>I kind of like seeing those intermediate data organizations, it gives
>me a handle on what I need to do next.

I don't think that is much of an issue at all.  What I find most
annoying about split is that it always forces me to deal with vectors.

>In dictionary APL (and I think in J), more of this work is done
>silently inside the rank operator, where I'll grant you it can be a
>lot more efficient; but much more obscure!

Obscure is in the mind of the beholder ;-)

Personally, I find the J forms _easier_ to remember, because they have
(to me) more of an internal consistency.  Also, you can do real well
visualising J operators by using innocuous functions like <  or ] to
see what's happening structurally.


*========================================
# Simple J editor

+------------------
| L.J.Dickey
| <1990Dec20.215905.28000@watmath.waterloo.edu>

Frederick Way, of Case Western Reserve University, has constructed
this editor using J.  It uses the "/" and "," conventions known
to some APLers.  Here is Fred's (edited) letter.

 From fxw3@cwns4.INS.CWRU.Edu  Tue Dec 18 12:47:18 1990
 Date: Tue, 18 Dec 90 12:47:06 -0500
 From: fxw3@po.CWRU.Edu (Frederick Way)
 Subject: Voila!

 VOILA!!!!

 A trivial "/" (delete character) and "," (insert text) editor for J
 that seems to work:

    L0=.'$.=.s#$.}:s=.0 0 1 1 0{.~3*_1+2*0=#inp=.1!:1 (1)}:y. 1!:2 (2)'
    L1=.'y.=.(/:(i.#y.),($cac)#inp i.'',''){y.,cac=.}.inp#~cv=.+./\inp='','''
    L2=.'$:(-.''/''=(#y.){.(-.cv)#inp)#y.'
    L3=.'y.'
    edit=.(L0,L1,L2,:L3) ::''

[[
   NB. sws. this works now
    e=.'$.=.s#$.[s=.0 0 1 1 0{.~3*_1+2*0=#inp=.1!:1 (1)[y. 1!:2 (2)'
    e=.e,:'y.=.(/:(i.#y.),($cac)#inp i.'',''){y.,cac=.}.inp#~cv=.+./\inp='','''
    e=.e,'edit (-.''/''=(#y.){.(-.cv)#inp)#y.'
    e=.e,'y.'
    edit=. e : ''
]]
 Holiday cheers,


 