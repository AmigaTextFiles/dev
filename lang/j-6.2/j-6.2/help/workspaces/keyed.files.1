From emclean@sfsuvax1.sfsu.edu Thu Jun 17 11:49 EDT 1993
From: emclean@sfsuvax1.sfsu.edu (Emmett McLean)
Message-Id: <9306171548.AA05229@sfsuvax1.sfsu.edu>
Subject: Re: Improved keyed files for J
To: ljdickey@math (L.J. Dickey)
Date: Thu, 17 Jun 93 8:48:03 PDT
Status: R

 ...

  In rectrospect I should have made delete be 50!:55 instead of 50!:6
  but this minor change doesn't seem worth announcing another revised
  version.

#!/bin/sh
# This is a shell archive (produced by shar 3.50)
# To extract the files from this archive, save it to a file, remove
# everything above the "!/bin/sh" line above, and type "sh file_name".
#
# made 06/14/1993 16:26 UTC by emclean@sfsuvax1.sfsu.edu
# Source directory /usr/cp2/emclean/pkg/files2
#
# existing files will NOT be overwritten unless -c is specified
#
# This shar contains:
# length  mode       name
# ------ ---------- ------------------------------------------
#   5988 -rw------- jk.c
#   2551 -rw------- key1.js
#   1042 -rw------- key2.js
#   1614 -rwx------ key.doc
#
# ============= jk.c ==============
if test -f 'jk.c' -a X"$1" != X"-c"; then
	echo 'x - skipping jk.c (File already exists)'
else
echo 'x - extracting jk.c (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'jk.c' &&
X
/* ---------------------------------------------------------------------- */
/*                                                                        */
/* Mike Powell's keyed file programs                                      */
/* interfaced with J by emclean@vax1.sfsu.edu                             */
/*                                                                        */
/* June 13 , 1993                                                         */
/* Most of the changes below were suggested or made because of            */
/* Eythan Weg who did some testing on these programs. (Thanks.)           */
/* Fixed bug in kcpy                                                      */
/* Added function declarations                                            */
/* Fixed F1RANK statment in kput                                          */
/* Changed 50!:0(create)                                                  */
/*         50!:2(put)                                                     */
/*         50!:4(copy)                                                    */
/* To return 1 upon successful execution                                  */
/* Changed 50!:2(put) to write over obsolete data for a key               */
/* Fixed jcob typo in diff_x.c to jkey                                    */
X
#include "j.h"
#define IAV(x) (I)*AV(x)
X   
static A kcrt();          /* 50!:0  create                                 */
static A kget();          /* 50!:1  get                                    */
static A kput();          /* 50!:2  put                                    */
static A kdir();          /* 50!:3  dir                                    */
static A kcpy();          /* 50!:4  copy                                   */
static A kdel();          /* 50!:5  delete                                 */
static A kers();          /* 50!:6  erase                                  */
X
static I kvs(); 
static A kmwrite();
static A knwrite();
X
I kvs(w) A w;{A m,n;I t;
X RZ(w);if(!i0(tally(ope(w))))R 0;
X m=ope(w);if(!(BOX&AT(w)&&(AN(m)>=0)&&AT(m)&CHAR))R 0 ;
X n=eq(scc(' '),m);if(!i0(match(df1(n,bslash(slash(ds(COR)))),n)))R 0;
X R 1;
}
static F1(kcrt){PROLOG;A m,n,o;
X F1RANK(0,kcrt,0);RZ(w);ASSERT(kvs(w),EVDOMAIN);
X m=lrep(iota(sc(0)));n=lrep(reitem(v2(0,3),sc(0)));
X o=over(sc(1024),over(sc(1536),over(shape(n),sc(1024))));
X o=lrep(reitem(v2(2,3),over(sc(512),over(shape(m),o))));
X o=over(take(sc(512),o),over(take(sc(1024),m),take(sc(1024),n)));
X jfwrite(o,w);EPILOG(sc(1));
}
static F2(kget){PROLOG;A m,n,o;
X F2RANK(RMAXL,0,kget,0);RZ(a&&w);ASSERT(kvs(w),EVDOMAIN);
X m=exec1(jiread(over(w,box(v2(0,512)))));
X ASSERT(2==AR(m)&&6==AN(m),EVFACE);
X n=exec1(jiread(over(w,box(from(v2(0,1),from(sc(0),m))))));
X o=exec1(jiread(over(w,box(from(v2(0,1),from(sc(1),m))))));
X EPILOG(exec1(jiread(over(w,box(ravel(from(v2(0,1),from(indexof(n,box(a)),o))))))));
}
static F1(kmwrite){PROLOG;A m,n;RZ(w);
X m=from(sc(0),w);w=ope(from(sc(1),w));n=over(jfsize(m),shape(w));
X w=take(tymes(sc(512),ceil1(divide(shape(w),sc(400)))),w);
X m=(A)jfappend(w,m);EPILOG(over(n,shape(w)));
}
static F2(knwrite){PROLOG;A m,n;RZ(w);
X m=ge(from(sc(2),a),shape(ope(from(sc(1),w))));
X if(!IAV(m)) EPILOG(kmwrite(w));
X  else {
X  m=from(sc(0),w);w=ope(from(sc(1),w));
X  m=(A)jiwrite(w,over(m,box(over(from(sc(0),a),shape(w)))));
X  EPILOG(over(from(sc(0),a),over(shape(w),from(sc(2),a))));
X }
}
static F2(kput){PROLOG; A m,n,o,d,e,f,t;
X F2RANK(1,0,kput,0);RZ(a&&w);
X ASSERT(2==i0(tally(a)),EVDOMAIN);ASSERT(kvs(w),EVDOMAIN);
X if (i0(eps(head(a),kdir(w)))) kdel(ope(head(a)),w);
X n=exec1(jiread(over(w,box(v2(0,512)))));
X ASSERT(2==AR(n)&&6==AN(n),EVFACE);
X o=exec1(jiread(over(w,box(from(v2(0,1),from(sc(0),n))))));
X d=exec1(jiread(over(w,box(from(v2(0,1),from(sc(1),n))))));
X m=from(sc(0),a);a=lrep(ope(from(sc(1),a)));
X e=indexof(o,m);t=ge(e,tally(o));
X if (IAV(t)){
X  f=kmwrite(over(w,box(a)));o=over(o,m);
X  m=knwrite(ravel(from(sc(0),n)),over(w,box(lrep(o))));
X  d=over(d,f);n=knwrite(ravel(from(sc(1),n)),over(w,box(lrep(d))));
X  m=reitem(v2(2,3),over(m,n));m=take(sc(512),lrep(m));
X  EPILOG(left1(sc(1),jiwrite(m,over(w,box(v2(0,512))))));
X }else{
X  f=knwrite(ravel(from(e,d)),over(w,box(a)));
X  m=over(take(e,d),over(f,drop(increm(e),d)));
X  m=knwrite(ravel(from(sc(1),n)),over(w,box(lrep(m))));
X  m=reitem(v2(2,3),over(from(sc(0),n),m));
X  EPILOG(left1(sc(1),jiwrite(m,over(w,box(v2(0,512))))));
X }
} 
static F1(kdir){PROLOG;A b;
X F1RANK(0,kdir,0);ASSERT(kvs(w),EVDOMAIN); 
X b=exec1(jiread(over(w,box(v2(0,512)))));
X ASSERT(2==AR(b)&&6==AN(b),EVFACE);
X EPILOG(exec1(jiread(over(w,box(from(v2(0,1),from(sc(0),b)))))));
}
static F2(kcpy){PROLOG;A m,n;I i,t;
X F2RANK(0,0,kcpy,0);RZ(a&&w);ASSERT(kvs(w),EVDOMAIN);
X ASSERT(kvs(a),EVDOMAIN);
X m=kdir(a);n=sc(0);t=i0(tally(m));kcrt(w);
X for(i=0;i<t;i++){
X  kput(over(from(n,m),box(kget(ope(from(n,m)),a))),w);
X  n=increm(n);
X }
X /* EPILOG(over(jfsize(a),jfsize(w))); */
X EPILOG(sc(1)); 
}
static F2(kdel){PROLOG;A m,n,o,d;
X F2RANK(RMAXL,0,kdel,0);RZ(a&&w);ASSERT(kvs(w),EVDOMAIN); 
X m=exec1(jiread(over(w,box(v2(0,512)))));
X ASSERT(2==AR(m)&&6==AN(m),EVFACE);
X n=exec1(jiread(over(w,box(from(v2(0,1),from(sc(0),m))))));
X o=exec1(jiread(over(w,box(from(v2(0,1),from(sc(1),m))))));
X d=not(eps(n,box(a)));n=repeat(d,n);
X n=knwrite(ravel(from(sc(0),m)),over(w,box(lrep(n))));
X o=repeat(d,o);o=knwrite(ravel(from(sc(1),m)),over(w,box(lrep(o))));
X m=reitem(v2(2,3),over(n,o));m=take(sc(512),lrep(m));
X EPILOG(left1(eps(sc(0),d),jiwrite(m,over(w,box(v2(0,512))))));
}
static F1(kers){
X F1RANK(0,kers,0);RZ(w);ASSERT(kvs(w),EVDOMAIN); R (A)jferase(w);
}
static F1(kmer){ASSERT(0,EVDOMAIN);}
static F2(kder){ASSERT(0,EVDOMAIN);}
C jkey(k,f1,f2)I k;AF*f1,*f2;
{ switch(k){
X  case 0: *f1=kcrt; *f2=kder; R 1;
X  case 1: *f1=kmer; *f2=kget; R 1;
X  case 2: *f1=kmer; *f2=kput; R 1;
X  case 3: *f1=kdir; *f2=kder; R 1;
X  case 4: *f1=kmer; *f2=kcpy; R 1;
X  case 5: *f1=kmer; *f2=kdel; R 1;
X  case 6: *f1=kers; *f2=kder; R 1;
X  default: ASSERT(0,EVNONCE);       
X  }
}
SHAR_EOF
chmod 0600 jk.c ||
echo 'restore of jk.c failed'
Wc_c="`wc -c < 'jk.c'`"
test 5988 -eq "$Wc_c" ||
	echo 'jk.c: original size 5988, current size' "$Wc_c"
fi
# ============= key1.js ==============
if test -f 'key1.js' -a X"$1" != X"-c"; then
	echo 'x - skipping key1.js (File already exists)'
else
echo 'x - extracting key1.js (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'key1.js' &&
X   create =. 50!:0
X   get    =. 50!:1
X   put    =. 50!:2
X   dir    =. 50!:3
X   copy   =. 50!:4
X   delete =. 50!:5
X   create <'file1'
X   ('a';i.2 3) put <'file1'
X   dir <'file1'
X   ((<'b');i.3)   put <'file1'
X   dir <'file1'
X   (<'file1') copy <'file2'
X   (<'file1') copy <'file2'
X   dir <'file1'
X   dir <'file2'
X   (<'b')   delete <'file1'
X   dir <'file1'
X   ('b';'This is a story of the evolution of one special language') put <'file1'
X   dir <'file1'
X   (<'file1') copy (<'file2')
X   dir <'file2'
X   ('b') get <'file2'
X   ('b') get <'file2'
X   dir <'file2'
X   ('a') get <'file2'
X   'b' get <'file1'
X   dir <'file1'
X   ((i.2 3) ; i.100) put <'file1'
X   dir <'file1'
X   (i.2 3) get <'file1'
X   (i.2 3) delete <'file1'
X   dir <'file1'
X   NB. domain error at right
X   'ab'=.  ('a',:'b') get"0 ,.'file1';'file1'
X   NB.  Domain error since 'a'get<'file1'['b'<'file1' are different types
X   'ab'=.  ('a',:'b') get"0 <'file1'
X   dir <'file1'
X   NB. index error must use rank 0
X   'ab'=.  ('a',:'b') get"1 <'file1'
X   c=.i.10
X   d=.i.3 5
X   'c';c;'d';d
X   (  2 2$'c';c;'d';d) put"1 <'file1'
X   (  2 2$'c';c;'d';d) put"1 <'file1'
X   dir <'file1'
X   'b' get <'file1'
X   'f' get <'file1'
X   'd' get <'file1'
X   50!:0 <'testfile'
X   NB. demo
X   (('abc');(i.10)) put <'testfile'
X   (('def');(i.5 5)) put <'testfile'
X   (('mno');(2*i.5 5)) put <'testfile'
X   (('xyz');('junkstuff')) put <'testfile'
X   ('abc','def',:'mno') get"1 <'testfile'
X   dir <'testfile'
X   ('abc') get <'testfile'
X   ('xyz') get <'testfile'
X   create <'newtestfile'
X   (<'testfile') copy <'newtestfile'
X   dir <'newtestfile'
X   ('abc') delete <'newtestfile'
X   dir <'newtestfile'
X   ('def') delete <'newtestfile'
X   ('mno') delete <'newtestfile'
X   ('xyz') delete <'newtestfile'
X   (('yyz');('junkstuff')) put <'testfile'
X  
X    a =. i. 0 0
X    a =. a,'y. =. 4 >. y.'
X    a =. a,'b=. ? (y. , 5 5) $ 1000'
X    a =. a,'i=.0 '
X    a =. a,'create <''testfile'' '
X    a =. a,'loop0)'
X    a =. a,'1!:2&2 i'
X    a =. a,'d=. (i;(i{b))put <''testfile'' '
X    a =. a,'$.=.>(y.=(i=.>:i)) { loop0 ; end0 '
X    a =. a,'end0) dir <''testfile'' '
X    a =. a,'1!:2&2 ,&'' '' ": (3{b)'
X    a =. a,'1!:2&2 (3) get <''testfile'' '
X    a =. a,'i=. 0'
X    a =. a,'loop1)'
X    a =. a,'d=. i delete <''testfile'' '
X    a =. a,'$.=.>(y.=(i=.>:i)) { loop1 ; end1 '
X    a =. a,'end1)'
X    a =. a,'y. =. dir <''testfile'' '
X    a =. a : '' 
X   
X    a 10  NB. torture test.
X 
X    NB. bad file name spellings  
X    create <'testfile typeo'  
X    NB. bad file name spellings  
X    (<'sourcefile')copy <'destination file'
SHAR_EOF
chmod 0600 key1.js ||
echo 'restore of key1.js failed'
Wc_c="`wc -c < 'key1.js'`"
test 2551 -eq "$Wc_c" ||
	echo 'key1.js: original size 2551, current size' "$Wc_c"
fi
# ============= key2.js ==============
if test -f 'key2.js' -a X"$1" != X"-c"; then
	echo 'x - skipping key2.js (File already exists)'
else
echo 'x - extracting key2.js (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'key2.js' &&
X   NB. Eythan's ideas :
X   create <'file1'
X   NB. These work file :
X   ('a';i.2 2) put <'file1'
X   ('b';i.3 3 3) put <'file1'
X   NB. This    'ef'=.('a',:'b') get"0 <'file1' is bad. But
X   'ef'=.('a',:'b') <@get"0 <'file1'
X   NB. or 
X    'ef'=.('ab') <@get"0 <'file1'
X   NB. are correctly assigned.
X
X   NB. The problem with
X   'ef'=.('a',:'b') get"1 <'file1'
X
X   NB. is that the key 'a'  is a scalar and 'a',:'b' create matrix and the 
X   NB. rank 1 make a vector.  That is why there is an index error.
X
X   NB. So if 
X   (2 2 $(1$'a');(i.100);(1$'b');'hello world') put"1 <'file1'
X   NB.  then
X   'ab'=.  ('a',:'b') <@get"1 <'file1'
X   NB. should be all right.
X
X   NB. There are limits to the size of the nouns put can store :
X   NB. ('million';i.10000000) put <'file1'
X   NB. returns ws full
X
X   c=.  <"0 i. 8
X   NB. the instruction below is a domain error since left arugments
X   NB. to put must have two items 
X   ('c';c)put <'file1'
X   NB. But this is ok
X   ('c'; (<c))put <'file1'
X   NB. And 
X   'c' get <'file1'
X   NB. now works fine
X
X
X
SHAR_EOF
chmod 0600 key2.js ||
echo 'restore of key2.js failed'
Wc_c="`wc -c < 'key2.js'`"
test 1042 -eq "$Wc_c" ||
	echo 'key2.js: original size 1042, current size' "$Wc_c"
fi
# ============= key.doc ==============
if test -f 'key.doc' -a X"$1" != X"-c"; then
	echo 'x - skipping key.doc (File already exists)'
else
echo 'x - extracting key.doc (Text)'
sed 's/^X//' << 'SHAR_EOF' > 'key.doc' &&
X 
X NB. KEYED FILES.                  Mike Powell, Dec 1992.
X NB. J interface by Emmett McLean emclean@vax1.sfsu.edu June 3, 1993
X NB. revised June 14, 1993
X
X /* Special thanks to Mike Powell for writting these verbs */
X
X This package provides implements keyed file operations as primitive
X operators.
X
X Tested on NeXT/ULTRIX 4.3
X All values are stored in 5!:5 format. Values retrieved from the file
X are recreated with the Do verb, ". .
X
X Some checking is done. A domain error occurs if a filename is not
X composed of contigous spaces.
X
X Create =. 50!:0
X Get    =. 50!:1
X Put    =. 50!:2
X Dir    =. 50!:3
X Copy   =. 50!:4
X Delete =. 50!:5
X
X 50!:0 <'filename' NB. Create
X   Returns 1 upon successful file creation.
X
X NB. Get
X key 50!:1 <'filename' 
X   Returns the value associated with key.
X
X   Produces an error if the key does not exist.
X
X NB. Put
X (key;value) 50!:2 <'filename' 
X   Returns 1 upon successful insertion.
X   The tally of the left argument must be two.
X
X   A key is a noun. For example, the following are all usable as distinct
X   keys:
X     'abcd'
X  <'abcd'
X  1 4$'abcd'
X  i.4 10
X  6.7j8
X
X NB. Dir
X 50!:3<'filename'
X   Returns the list of keys.
X
X   For example, to test if a key is already present;
X   (<'abc')e. Dir<'filename'
X
X NB. Copy
X (<'sourcefile')50!:4 <'destination file'
X   Returns one upon successfully copying files.
X
X   Copies the contents of one file to another. Creates the destination
X   file. Eliminates wasted space.  Returns the before and after file sizes.
X
X NB. Delete
X key 50!:5<'filename'
X   Removes key from the list of keys.
X   Returns boolean (1=deleted, 0=not deleted).
X
SHAR_EOF
chmod 0700 key.doc ||
echo 'restore of key.doc failed'
Wc_c="`wc -c < 'key.doc'`"
test 1614 -eq "$Wc_c" ||
	echo 'key.doc: original size 1614, current size' "$Wc_c"
fi
exit 0

